{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public pendingOwner;\r\n    mapping(address => bool) public managers;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event SetManager(address indexed owner, address indexed newManager);\r\n    event RemoveManager(address indexed owner, address indexed previousManager);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"non-owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than a manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(managers[msg.sender], \"non-manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the user(`account`) is the a manager.\r\n     */\r\n    function isManager(address _account) public view returns (bool) {\r\n        return managers[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner_`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != owner, \"transferOwnership: the same owner.\");\r\n        require(pendingOwner != _newOwner, \"transferOwnership : the same pendingOwner.\");\r\n        pendingOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Accepts ownership of the contract.\r\n     * Can only be called by the settting new owner(`pendingOwner`).\r\n     */\r\n    function acceptOwnership() external {\r\n        require(msg.sender == pendingOwner, \"AcceptOwnership: only new owner do this.\");\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Set a new user(`account`) as a manager.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function setManager(address _account) external onlyOwner {\r\n        require(_account != address(0), \"setManager: account cannot be a zero address.\");\r\n        require(!isManager(_account), \"setManager: Already a manager address.\");\r\n        managers[_account] = true;\r\n        emit SetManager(owner, _account);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a previous manager account.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function removeManager(address _account) external onlyOwner {\r\n        require(_account != address(0), \"RemoveManager: _account cannot be a zero address.\");\r\n        require(isManager(_account), \"RemoveManager: Not an admin address.\");\r\n        managers[_account] = false;\r\n        emit RemoveManager(owner, _account);\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    bool public paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () internal {\r\n        paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the contract owner to pause, triggers stopped state.\r\n     */\r\n    function pause() public whenNotPaused onlyOwner {\r\n        paused = true;\r\n        emit Paused(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the contract owner to unpause, returns to normal state.\r\n     */\r\n    function unpause() public whenPaused onlyOwner {\r\n        paused = false;\r\n        emit Unpaused(owner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint _value) external;\r\n    function transferFrom(address _from, address _to, uint _value) external;\r\n    function approve(address _spender, uint _value) external;\r\n    function balanceOf(address account) external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n}\r\n\r\ncontract ERC20SafeTransfer {\r\n    function doTransferOut(address _token, address _to, uint _amount) internal returns (bool) {\r\n        IERC20 token = IERC20(_token);\r\n        bool result;\r\n\r\n        token.transfer(_to, _amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {\r\n                    result := not(0)\r\n                }\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)\r\n                }\r\n                default {\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function doTransferFrom(address _token, address _from, address _to, uint _amount) internal returns (bool) {\r\n        IERC20 token = IERC20(_token);\r\n        bool result;\r\n\r\n        token.transferFrom(_from, _to, _amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {\r\n                    result := not(0)\r\n                }\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)\r\n                }\r\n                default {\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\ncontract ILendfMeData {\r\n    function getLiquidity(address account) public view returns (int);\r\n}\r\n\r\nlibrary DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0, \"ds-math-div-overflow\");\r\n        z = x / y;\r\n    }\r\n}\r\n\r\ncontract Distribution is Pausable, ERC20SafeTransfer {\r\n    using DSMath for uint;\r\n    // --- Data ---\r\n    bool private initialized;                   // Flag of initialize data.\r\n\r\n    address public DF;\r\n    address public LendfMeData;\r\n\r\n    uint public start;                          // When will the contract start.\r\n    uint public step;                           // Duration of each period.\r\n\r\n    uint[] public distributionRatio;            // Accumulated distribution ratio based on every period.\r\n    uint public totalRatio;\r\n\r\n    uint public totalAmount;                    // Total amount of asset to distribute.\r\n    uint public totalLockedValue;               // Total net value.\r\n    mapping (address => uint) public claimed;   // Amount that user has claimed.\r\n    uint public totalClaimed;                   // Total amount of asset has claimed.\r\n\r\n    /**\r\n     * @dev emitted when user cliams.\r\n     */\r\n    event Claim(address _src, uint _amount);\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not expired.\r\n     */\r\n    modifier unclocked() {\r\n        require(start + step * distributionRatio.length.sub(1) >= now, \"unclocked: Contract has been locked!\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * The constructor is used here to ensure that the implementation contract is initialized.\r\n     * An uncontrolled implementation contract might lead to misleading state for users who\r\n     * accidentally interact with it.\r\n     */\r\n    constructor(\r\n        address _token,\r\n        uint _totalAmount,\r\n        address _lendfMeData,\r\n        uint _totalLockedValue,\r\n        uint _start,\r\n        uint _step,\r\n        uint[] memory _distributionRatio\r\n    ) public {\r\n        initialize(_token, _totalAmount, _lendfMeData, _totalLockedValue, _start, _step, _distributionRatio);\r\n    }\r\n\r\n    // --- Init ---\r\n    // This function is used with contract proxy, do not modify this function.\r\n    function initialize(\r\n        address _token,\r\n        uint _totalAmount,\r\n        address _lendfMeData,\r\n        uint _totalLockedValue,\r\n        uint _start,\r\n        uint _step,\r\n        uint[] memory _distributionRatio\r\n    ) public {\r\n        require(!initialized, \"initialize: Already initialized.\");\r\n        owner = msg.sender;\r\n        managers[msg.sender] = true;\r\n        initialized = true;\r\n        DF = _token;\r\n        totalAmount = _totalAmount;\r\n        LendfMeData = _lendfMeData;\r\n        totalLockedValue = _totalLockedValue;\r\n        start = _start;\r\n        step = _step;\r\n        setDistributionRatio(_distributionRatio);\r\n    }\r\n\r\n    // ***************************\r\n    // **** Manager functions ****\r\n    // ***************************\r\n\r\n    /**\r\n     * @dev Manager function to set which asset will be distributed.\r\n     * @param _token Asset that users will get by claiming.\r\n     */\r\n    function setToken(address _token) external onlyManager {\r\n        require(DF != _token, \"setToken: Asset is same as the previous!\");\r\n        DF = _token;\r\n    }\r\n\r\n    function setTotalAmount(uint _totalAmount) external onlyManager {\r\n        require(totalAmount < _totalAmount, \"setTotalAmount: New total amount should be greater than previous!\");\r\n        totalAmount = _totalAmount;\r\n    }\r\n\r\n    function setLendfMeData(address _lendfMeData) external onlyManager {\r\n        require(LendfMeData != _lendfMeData, \"setLendfMeData: New data contract should be different!\");\r\n        LendfMeData = _lendfMeData;\r\n    }\r\n\r\n    function setTotalLiquidity(uint _totalLockedValue) external onlyManager {\r\n        require(totalLockedValue < _totalLockedValue,\r\n                \"setTotalLiquidity: New locked value should be greater than previous!\");\r\n        totalLockedValue = _totalLockedValue;\r\n    }\r\n\r\n    function setStartTime(uint _start) external onlyManager {\r\n        require(start != _start, \"setStartTime: New start time should be different!\");\r\n        start = _start;\r\n    }\r\n\r\n    function setStep(uint _step) external onlyManager {\r\n        require(step != _step, \"setStep:  New step should be different!\");\r\n        step = _step;\r\n    }\r\n\r\n    /**\r\n     * @dev Manager function to set distribution ratio.\r\n     * @param _distributionRatio Array that distribution ratio at each period.\r\n     */\r\n    function setDistributionRatio(uint[] memory _distributionRatio) public onlyManager {\r\n        delete distributionRatio;\r\n        // first set to 0, cause contract does not support claim yet.\r\n        distributionRatio.push(0);\r\n        uint _sum;\r\n        for (uint i = 0; i < _distributionRatio.length; i++) {\r\n            _sum = _sum.add(_distributionRatio[i]);\r\n            distributionRatio.push(_sum);\r\n        }\r\n        // last set to 0, cause contract has experid.\r\n        distributionRatio.push(0);\r\n        totalRatio = _sum;\r\n    }\r\n\r\n    // ***************************\r\n    // ***** Owner functions *****\r\n    // ***************************\r\n\r\n    /**\r\n     * @dev Owner function to transfer asset`_token` out when contract has expired.\r\n     * @param _token Reserve asset, generally spaking it should be DF.\r\n     * @param _recipient Account to receive asset.\r\n     * @param _amount Amount of asset to withdraw.\r\n     */\r\n    function removeReserve(address _token, address _recipient, uint _amount) external onlyOwner {\r\n        require(start + step * distributionRatio.length.sub(1) < now, \"removeReserve: Too early to remove!\");\r\n        require(doTransferOut(_token, _recipient, _amount), \"removeReserve: Transfer out failed!\");\r\n    }\r\n\r\n    /**\r\n     * @dev Owner function to transfer asset`_token` to this contract to start or move on.\r\n     * @param _amount Amount of asset to add.\r\n     */\r\n    function addReserve(uint _amount) external onlyOwner {\r\n\t\trequire(doTransferFrom(DF, msg.sender, address(this), _amount), \"addReserve: TransferFrom failed!\");\r\n\t}\r\n\r\n    // **************************\r\n    // *** Internal functions ***\r\n    // **************************\r\n\r\n    /**\r\n     * @dev Claims to get specified amount of asset, but only when the contract is not paused and not expired.\r\n     * @param _src Account who will receive distributed asset.\r\n     * @param _amount Amount to claim, scaled by 1e18.\r\n     */\r\n    function claim(address _src, uint _amount) internal whenNotPaused unclocked {\r\n        require(_amount > 0, \"claim: Amount to claim should be greater than 0!\");\r\n        claimed[_src] = claimed[_src].add(_amount);\r\n        totalClaimed = totalClaimed.add(_amount);\r\n        emit Claim(_src, _amount);\r\n\r\n        require(doTransferOut(DF, _src, _amount), \"claim(address,uint): Transfer failed!\");\r\n    }\r\n\r\n    // **************************\r\n    // **** Public functions ****\r\n    // **************************\r\n\r\n    /**\r\n     * @dev Gets all distributed asset during one distributing period.\r\n     */\r\n    function claim() external {\r\n        address _src = msg.sender;\r\n        claim(_src, getCurrentClaimableAmount(_src));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets some distributed asset.\r\n     * @param _amount Amount that user wants to claim.\r\n     */\r\n    function claim(uint _amount) external {\r\n        address _src = msg.sender;\r\n        require(getCurrentClaimableAmount(_src) >= _amount, \"claim(uint): Too large amount to claim!\");\r\n        claim(_src, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns account liquidity in terms of eth-wei value, scaled by 1e18.\r\n     * @param _src The account to examine.\r\n     */\r\n    function getAccountLiquidity(address _src) public view returns (uint) {\r\n        int _liquidity = ILendfMeData(LendfMeData).getLiquidity(_src);\r\n        if (_liquidity <= 0)\r\n            return 0;\r\n        return uint(_liquidity);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of released asset up to now.\r\n     */\r\n    function getCurrentUnlockedAmount() public view returns (uint) {\r\n        if (step == 0)\r\n            return 0;\r\n        uint _stage = now > start ? (now - start).div(step) : 0;\r\n        if (_stage >= distributionRatio.length)\r\n            return 0;\r\n        return totalAmount.mul(distributionRatio[_stage]).div(totalRatio);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total amount that user`_src` can claim based on `_unlockAmount`.\r\n     * @param _src The account to examine.\r\n     * @param _unlockAmount Released amount during current period.\r\n     */\r\n    function calculateClaimableAmount(address _src, uint _unlockAmount) public view returns (uint) {\r\n        return getAccountLiquidity(_src).mul(_unlockAmount).div(totalLockedValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns maximum valid amount that user`_src` can claim up to now.\r\n     * @param _src The account to examine.\r\n     */\r\n    function getCurrentClaimableAmount(address _src) public view returns (uint) {\r\n        uint _amount = calculateClaimableAmount(_src, getCurrentUnlockedAmount());\r\n        return _amount < claimed[_src] ? 0 : _amount.sub(claimed[_src]);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total amount that user`_src` can claim at the current period.\r\n     * @param _src The account to examine.\r\n     */\r\n    function getTotalClaimableAmount(address _src) public view returns (uint) {\r\n        uint _amount = calculateClaimableAmount(_src, totalAmount);\r\n        return start + step * distributionRatio.length.sub(1) < now ? 0 : (_amount < claimed[_src] ? 0 : _amount.sub(claimed[_src]));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns remaining amount that user`_src` can claim up to now.\r\n     * @param _src The account to examine.\r\n     */\r\n    function getUnclaimedAmount(address _src) external view returns (uint) {\r\n        return getTotalClaimableAmount(_src).sub(getCurrentClaimableAmount(_src));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns details that user`_src` claims.\r\n     * @param _src The account to examine.\r\n     * @return uint[] Array that start times for each period.\r\n     *         uint[] Array that the maximum amount to claim in every period.\r\n     */\r\n    function getClaimableList(address _src) external view returns (uint[] memory, uint[] memory) {\r\n\r\n        uint _length = distributionRatio.length - 2;\r\n        uint[] memory _timeList = new uint[](_length);\r\n        uint[] memory _amountList = new uint[](_length);\r\n        uint _start = start;\r\n        uint _step = step;\r\n        for (uint i = 1; i <= _length; i++) {\r\n            _timeList[i - 1] = _start + i * _step;\r\n            _amountList[i - 1] = calculateClaimableAmount(_src, totalAmount.mul(distributionRatio[i].sub(distributionRatio[i - 1])).div(totalRatio));\r\n        }\r\n\r\n        return(_timeList, _amountList);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns remaining period details that user`_src` can claim.\r\n     * @param _src The account to examine.\r\n     * @return uint[] Array that start times for each remaining period.\r\n     *         uint[] Array that the maximum amount to claim in every remaining period.\r\n     */\r\n    function getRemainingClaimableList(address _src) external view returns (uint[] memory, uint[] memory) {\r\n\r\n        uint _start = start;\r\n        uint _step = step;\r\n        uint _stage = now > _start.add(_step) ? (now - _start).div(_step) : 0;\r\n        uint _length = distributionRatio.length - 2;\r\n        _length = _length < _stage ? 0 : _length - _stage;\r\n        uint[] memory _timeList = new uint[](_length);\r\n        uint[] memory _amountList = new uint[](_length);\r\n        for (uint i = 1; i <= _length; i++) {\r\n            _timeList[i - 1] = _start + (_stage + i) * _step;\r\n            _amountList[i - 1] = calculateClaimableAmount(_src, totalAmount.mul(distributionRatio[_stage + i].sub(distributionRatio[_stage + i - 1])).div(totalRatio));\r\n        }\r\n\r\n        return(_timeList, _amountList);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns current period.\r\n     */\r\n    function getCurrentStage() external view returns (uint) {\r\n        uint _stage = now > start ? (now - start).div(step) : 0;\r\n        return _stage > distributionRatio.length ? distributionRatio.length : _stage;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns basic contract data.\r\n     * @return uint Total net value of the LendfMe contract.\r\n     *         uint Toal net value of user`_src`.\r\n     *         uint Maximun amount that user`_src` can claim during this distribution.\r\n     *         uint Remaining amount that user`_src` can claim up to now.\r\n     *         uint Amount that user has claimed.\r\n     *         uint Maximum valid amount that user`_src` can claim up to now.\r\n     */\r\n    function getDistributionData(address _src) external view returns (uint, uint, uint, uint, uint, uint) {\r\n        uint _shareAmount = calculateClaimableAmount(_src, totalAmount);\r\n        uint _unlockedAmount = calculateClaimableAmount(_src, getCurrentUnlockedAmount());\r\n        return (\r\n            totalLockedValue,\r\n            getAccountLiquidity(_src),\r\n            _shareAmount,\r\n            _shareAmount > _unlockedAmount ? _shareAmount - _unlockedAmount : 0,\r\n            claimed[_src],\r\n            getCurrentClaimableAmount(_src)\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"getDistributionData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalLockedValue\",\"type\":\"uint256\"}],\"name\":\"setTotalLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"getClaimableList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockedValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lendfMeData\",\"type\":\"address\"}],\"name\":\"setLendfMeData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"getAccountLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"getTotalClaimableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalAmount\",\"type\":\"uint256\"}],\"name\":\"setTotalAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"getCurrentClaimableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distributionRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_distributionRatio\",\"type\":\"uint256[]\"}],\"name\":\"setDistributionRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"name\":\"_lendfMeData\",\"type\":\"address\"},{\"name\":\"_totalLockedValue\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_step\",\"type\":\"uint256\"},{\"name\":\"_distributionRatio\",\"type\":\"uint256[]\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"getUnclaimedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"}],\"name\":\"getRemainingClaimableList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentUnlockedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LendfMeData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"step\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"},{\"name\":\"_unlockAmount\",\"type\":\"uint256\"}],\"name\":\"calculateClaimableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_step\",\"type\":\"uint256\"}],\"name\":\"setStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"name\":\"_lendfMeData\",\"type\":\"address\"},{\"name\":\"_totalLockedValue\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_step\",\"type\":\"uint256\"},{\"name\":\"_distributionRatio\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"SetManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"}],\"name\":\"RemoveManager\",\"type\":\"event\"}]","ContractName":"Distribution","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000431ad2ff6a9c365805ebad47ee021148d6f7dbe000000000000000000000000000000000000000000001a784379d99db420000000000000000000000000000003e207befe239414ffe87d2ce6eff5234ab923e4400000000000000000000000000000000000000000014b8262c63a7bf64200000000000000000000000000000000000000000000000000000000000005ddb35a00000000000000000000000000000000000000000000000000000000000f2940000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000032","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9377a5f46ef6bff3f51c0e303ade7a7d6c3be7559b50e680495227014b05cc31"}]}