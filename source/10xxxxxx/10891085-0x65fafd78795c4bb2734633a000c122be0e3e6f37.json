{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Apache-2.0\r\n// Copyright 2017 Loopring Technology Limited.\r\npragma solidity ^0.7.0;\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title AddressSet\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract AddressSet\r\n{\r\n    struct Set\r\n    {\r\n        address[] addresses;\r\n        mapping (address => uint) positions;\r\n        uint count;\r\n    }\r\n    mapping (bytes32 => Set) private sets;\r\n\r\n    function addAddressToSet(\r\n        bytes32 key,\r\n        address addr,\r\n        bool    maintainList\r\n        ) internal\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.positions[addr] == 0, \"ALREADY_IN_SET\");\r\n\r\n        if (maintainList) {\r\n            require(set.addresses.length == set.count, \"PREVIOUSLY_NOT_MAINTAILED\");\r\n            set.addresses.push(addr);\r\n        } else {\r\n            require(set.addresses.length == 0, \"MUST_MAINTAIN\");\r\n        }\r\n\r\n        set.count += 1;\r\n        set.positions[addr] = set.count;\r\n    }\r\n\r\n    function removeAddressFromSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n    {\r\n        Set storage set = sets[key];\r\n        uint pos = set.positions[addr];\r\n        require(pos != 0, \"NOT_IN_SET\");\r\n\r\n        delete set.positions[addr];\r\n        set.count -= 1;\r\n\r\n        if (set.addresses.length > 0) {\r\n            address lastAddr = set.addresses[set.count];\r\n            if (lastAddr != addr) {\r\n                set.addresses[pos - 1] = lastAddr;\r\n                set.positions[lastAddr] = pos;\r\n            }\r\n            set.addresses.pop();\r\n        }\r\n    }\r\n\r\n    function removeSet(bytes32 key)\r\n        internal\r\n    {\r\n        delete sets[key];\r\n    }\r\n\r\n    function isAddressInSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return sets[key].positions[addr] != 0;\r\n    }\r\n\r\n    function numAddressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        Set storage set = sets[key];\r\n        return set.count;\r\n    }\r\n\r\n    function addressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.count == set.addresses.length, \"NOT_MAINTAINED\");\r\n        return sets[key].addresses;\r\n    }\r\n}\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\nabstract contract ERC1271 {\r\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\r\n\r\n    function isValidSignature(\r\n        bytes32      _hash,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes4 magicValueB32);\r\n}\r\n\r\n//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n\r\n\r\nlibrary BytesUtil {\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\r\n        require(_bytes.length >= (_start + 3));\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\r\n        require(_bytes.length >= (_start + 4));\r\n        bytes4 tempBytes4;\r\n\r\n        assembly {\r\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes4;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function fastSHA256(\r\n        bytes memory data\r\n        )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32[] memory result = new bytes32[](1);\r\n        bool success;\r\n        assembly {\r\n             let ptr := add(data, 32)\r\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\r\n        }\r\n        require(success, \"SHA256_FAILED\");\r\n        return result[0];\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Utility Functions for addresses\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary AddressUtil\r\n{\r\n    using AddressUtil for *;\r\n\r\n    function isContract(\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(addr) }\r\n        return (codehash != 0x0 &&\r\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n\r\n    function toPayable(\r\n        address addr\r\n        )\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return payable(addr);\r\n    }\r\n\r\n    // Works like address.send but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETH(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        address payable recipient = to.toPayable();\r\n        /* solium-disable-next-line */\r\n        (success,) = recipient.call{value: amount, gas: gasLimit}(\"\");\r\n    }\r\n\r\n    // Works like address.transfer but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETHAndVerify(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        success = to.sendETH(amount, gasLimit);\r\n        require(success, \"TRANSFER_FAILURE\");\r\n    }\r\n\r\n    // Works like call but is slightly more efficient when data\r\n    // needs to be copied from memory to do the call.\r\n    function fastCall(\r\n        address to,\r\n        uint    gasLimit,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bool success, bytes memory returnData)\r\n    {\r\n        if (to != address(0)) {\r\n            assembly {\r\n                // Do the call\r\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\r\n                // Copy the return data\r\n                let size := returndatasize()\r\n                returnData := mload(0x40)\r\n                mstore(returnData, size)\r\n                returndatacopy(add(returnData, 32), 0, size)\r\n                // Update free memory pointer\r\n                mstore(0x40, add(returnData, add(32, size)))\r\n            }\r\n        }\r\n    }\r\n\r\n    // Like fastCall, but throws when the call is unsuccessful.\r\n    function fastCallAndVerify(\r\n        address to,\r\n        uint    gasLimit,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bytes memory returnData)\r\n    {\r\n        bool success;\r\n        (success, returnData) = fastCall(to, gasLimit, value, data);\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(returnData, 32), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title SignatureUtil\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @dev This method supports multihash standard. Each signature's last byte indicates\r\n///      the signature's type.\r\nlibrary SignatureUtil\r\n{\r\n    using BytesUtil     for bytes;\r\n    using MathUint      for uint;\r\n    using AddressUtil   for address;\r\n\r\n    enum SignatureType {\r\n        ILLEGAL,\r\n        INVALID,\r\n        EIP_712,\r\n        ETH_SIGN,\r\n        WALLET   // deprecated\r\n    }\r\n\r\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\r\n\r\n    function verifySignatures(\r\n        bytes32          signHash,\r\n        address[] memory signers,\r\n        bytes[]   memory signatures\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(signers.length == signatures.length, \"BAD_SIGNATURE_DATA\");\r\n        address lastSigner;\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            require(signers[i] > lastSigner, \"INVALID_SIGNERS_ORDER\");\r\n            lastSigner = signers[i];\r\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function verifySignature(\r\n        bytes32        signHash,\r\n        address        signer,\r\n        bytes   memory signature\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (signer == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        return signer.isContract()?\r\n            verifyERC1271Signature(signHash, signer, signature):\r\n            verifyEOASignature(signHash, signer, signature);\r\n    }\r\n\r\n    function recoverECDSASigner(\r\n        bytes32      signHash,\r\n        bytes memory signature\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        if (signature.length != 65) {\r\n            return address(0);\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8   v;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := and(mload(add(signature, 0x41)), 0xff)\r\n        }\r\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n        if (v == 27 || v == 28) {\r\n            return ecrecover(signHash, v, r, s);\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    function verifyEOASignature(\r\n        bytes32        signHash,\r\n        address        signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        pure\r\n        returns (bool success)\r\n    {\r\n        if (signer == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint signatureTypeOffset = signature.length.sub(1);\r\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\r\n\r\n        // Strip off the last byte of the signature by updating the length\r\n        assembly {\r\n            mstore(signature, signatureTypeOffset)\r\n        }\r\n\r\n        if (signatureType == SignatureType.EIP_712) {\r\n            success = (signer == recoverECDSASigner(signHash, signature));\r\n        } else if (signatureType == SignatureType.ETH_SIGN) {\r\n            bytes32 hash = keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signHash)\r\n            );\r\n            success = (signer == recoverECDSASigner(hash, signature));\r\n        } else {\r\n            success = false;\r\n        }\r\n\r\n        // Restore the signature length\r\n        assembly {\r\n            mstore(signature, add(signatureTypeOffset, 1))\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function verifyERC1271Signature(\r\n        bytes32 signHash,\r\n        address signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            ERC1271.isValidSignature.selector,\r\n            signHash,\r\n            signature\r\n        );\r\n        (bool success, bytes memory result) = signer.staticcall(callData);\r\n        return (\r\n            success &&\r\n            result.length == 32 &&\r\n            result.toBytes4(0) == ERC1271_MAGICVALUE\r\n        );\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract OwnerManagable is Claimable, AddressSet\r\n{\r\n    bytes32 internal constant MANAGER = keccak256(\"__MANAGED__\");\r\n\r\n    event ManagerAdded  (address manager);\r\n    event ManagerRemoved(address manager);\r\n\r\n    modifier onlyManager\r\n    {\r\n        require(isManager(msg.sender), \"NOT_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrManager\r\n    {\r\n        require(msg.sender == owner || isManager(msg.sender), \"NOT_OWNER_OR_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    constructor() Claimable() {}\r\n\r\n    /// @dev Gets the managers.\r\n    /// @return The list of managers.\r\n    function managers()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return addressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Gets the number of managers.\r\n    /// @return The numer of managers.\r\n    function numManagers()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Checks if an address is a manger.\r\n    /// @param addr The address to check.\r\n    /// @return True if the address is a manager, False otherwise.\r\n    function isManager(address addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isAddressInSet(MANAGER, addr);\r\n    }\r\n\r\n    /// @dev Adds a new manager.\r\n    /// @param manager The new address to add.\r\n    function addManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        addManagerInternal(manager);\r\n    }\r\n\r\n    /// @dev Removes a manager.\r\n    /// @param manager The manager to remove.\r\n    function removeManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        removeAddressFromSet(MANAGER, manager);\r\n        emit ManagerRemoved(manager);\r\n    }\r\n\r\n    function addManagerInternal(address manager)\r\n        internal\r\n    {\r\n        addAddressToSet(MANAGER, manager, true);\r\n        emit ManagerAdded(manager);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title OfficialGuardian\r\n/// @author Freeman Zhong - <kongliang@loopring.org>\r\ncontract OfficialGuardian is OwnerManagable, ERC1271\r\n{\r\n    using SignatureUtil for bytes32;\r\n    mapping (address => bool) public whitelist;\r\n\r\n    function isValidSignature(\r\n        bytes32        _signHash,\r\n        bytes   memory _signature\r\n        )\r\n        public\r\n        view\r\n        override\r\n        returns (bytes4)\r\n    {\r\n        return isManager(_signHash.recoverECDSASigner(_signature))?\r\n            ERC1271_MAGICVALUE:\r\n            bytes4(0);\r\n    }\r\n\r\n    function addWhitelist(address target, bool toAdd)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(target != address(0), \"ZERO_ADDRESS\");\r\n        require(whitelist[target] != toAdd, \"SAME_VALUE\");\r\n        whitelist[target] = toAdd;\r\n    }\r\n\r\n    function transact(\r\n        address  target,\r\n        uint     value,\r\n        bytes    calldata data\r\n        )\r\n        external\r\n        onlyManager\r\n        returns (\r\n            bool success,\r\n            bytes memory returnData\r\n        )\r\n    {\r\n        require(whitelist[target], \"INVALID_TARGET\");\r\n        // solium-disable-next-line security/no-call-value\r\n        (success, returnData) = target.call{value: value}(data);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toAdd\",\"type\":\"bool\"}],\"name\":\"addWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_signHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numManagers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transact\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OfficialGuardian","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ba85a65629b9938f9696d5ff6926cd4a85a8196e29d85216c7b60bc7fa29ee00"}]}