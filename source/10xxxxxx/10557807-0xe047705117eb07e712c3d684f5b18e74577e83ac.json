{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.21 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ncontract BitcashPay is ReentrancyGuard{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name          =           'BitcashPay';\r\n    string public constant symbol        =           'BCP';\r\n    uint public totalSupply;\r\n    uint8 public constant decimals       =           8;\r\n    address payable owner;\r\n    uint public buyPriceEth              =           100 szabo;\r\n    uint public sellPriceEth             =           100 szabo;\r\n    uint private constant MULTIPLIER     =           100000000;\r\n\r\n    bool public directSellAllowed       =           false;\r\n    bool public directBuyAllowed        =           false;\r\n\r\n    bool public directTransferAllowed   =           false;\r\n\r\n    uint public reservedCoin            =           175000000;\r\n    address payable PresaleAddress;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint private releaseTime = 1627776000;\r\n    \r\n    constructor() ReentrancyGuard() public {\r\n        uint _totalSupply = 850000000;\r\n        owner = msg.sender;\r\n        balanceOf[msg.sender] = _totalSupply.mul(MULTIPLIER);\r\n        totalSupply = _totalSupply.mul(MULTIPLIER);\r\n    }\r\n\r\n    modifier ownerOnly {\r\n        if (msg.sender != owner && msg.sender != address(this)) revert(\"Access Denied!\");\r\n        _;\r\n    }\r\n\r\n    function burnToken(address account, uint256 amount) ownerOnly public returns (bool success) {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        balanceOf[account] = balanceOf[account].sub(amount.mul(MULTIPLIER), \"ERC20: burn amount exceeds balance\");\r\n        totalSupply = totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n        return true;\r\n    }\r\n\r\n    function transferEther(address payable _to, uint _amount) public ownerOnly returns (bool success)\r\n    {\r\n        uint amount = _amount * 10 ** 18;\r\n        _to.transfer(amount.div(1000));\r\n        return true;\r\n    }\r\n\r\n    function setBuyPrice(uint buyPrice) public ownerOnly {\r\n        buyPriceEth = buyPrice;\r\n    }\r\n\r\n    function setSellPrice(uint sellPrice) public ownerOnly {\r\n        sellPriceEth = sellPrice;\r\n    }\r\n\r\n    function allowDirectBuy() private {\r\n        directBuyAllowed = true;\r\n    }\r\n\r\n    function allowDirectSell() private {\r\n        directSellAllowed = true;\r\n    }\r\n\r\n    function allowDirectTransfer() private {\r\n        directTransferAllowed = true;\r\n    }\r\n\r\n    function denyDirectBuy() private {\r\n        directBuyAllowed = false;\r\n    }\r\n\r\n    function denyDirectSell() private {\r\n        directSellAllowed = false;\r\n    }\r\n\r\n    function denyDirectTransfer() private {\r\n        directTransferAllowed = false;\r\n    }\r\n\r\n    function ownerAllowDirectBuy() public ownerOnly {\r\n        allowDirectBuy();\r\n    }\r\n\r\n    function ownerAllowDirectSell() public ownerOnly {\r\n        allowDirectSell();\r\n    }\r\n\r\n    function ownerAllowDirectTransfer() public ownerOnly {\r\n        allowDirectTransfer();\r\n    }\r\n\r\n    function ownerDenyDirectBuy() public ownerOnly {\r\n        denyDirectBuy();\r\n    }\r\n\r\n    function ownerDenyDirectSell() public ownerOnly {\r\n        denyDirectSell();\r\n    }\r\n\r\n    function ownerDenyDirectTransfer() public ownerOnly {\r\n        denyDirectTransfer();\r\n    }\r\n\r\n\r\n    function setPresaleAddress(address payable _presaleAddress) public ownerOnly {\r\n        PresaleAddress = _presaleAddress;\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint _amount) public nonReentrant returns (bool success){\r\n        if (msg.sender != owner && _to == address(this) && directSellAllowed) {\r\n            sellBitcashPayAgainstEther(_amount);                             \r\n            return true;\r\n        }\r\n        _transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (balanceOf[_from] >= _value && allowed[_from][msg.sender] >= _value && balanceOf[_to] + _value > balanceOf[_to]) {\r\n            balanceOf[_from] -= _value;\r\n            balanceOf[_to] += _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(directTransferAllowed || releaseTime <= block.timestamp, \"Direct Transfer is now allowed this time.\");\r\n        require(balanceOf[sender] > amount, \"Insufficient Balance\");\r\n        if(msg.sender == address(this)) {\r\n            require(releaseTime <= block.timestamp, \"Reserved token is still locked\");\r\n        }\r\n\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        balanceOf[sender] = balanceOf[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        balanceOf[recipient] = balanceOf[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function sellBitcashPayAgainstEther(uint amount) private nonReentrant returns (uint refund_amount) {\r\n        allowDirectTransfer();\r\n        refund_amount = (amount.div(MULTIPLIER)).mul(sellPriceEth);\r\n\r\n        require(sellPriceEth != 0, \"Sell price cannot be zero\");\r\n        require(amount.div(MULTIPLIER) >= 100, \"Minimum of 100 BCP is required.\");\r\n        require(address(this).balance > refund_amount, \"Contract Insuficient Balance\");\r\n        \r\n        msg.sender.transfer(refund_amount);\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        balanceOf[owner] = balanceOf[owner].add(amount);\r\n\r\n        emit Transfer(address(this), msg.sender, amount);\r\n        denyDirectTransfer();\r\n        return refund_amount;\r\n    }\r\n\r\n    event Bonus (address to, uint value);\r\n\r\n    function getBonus(address _to, uint256 _value) public nonReentrant returns (uint bonus) {\r\n        require(msg.sender == PresaleAddress, \"Access Denied!\");\r\n        balanceOf[owner] = balanceOf[owner].sub(_value, \"ERC20: transfer amount exceeds balance\");\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        \r\n        emit Bonus(_to, _value.div(MULTIPLIER));\r\n        return bonus;\r\n    }\r\n\r\n    function airDropper(address[] memory _to, uint[] memory _value) public nonReentrant ownerOnly returns (uint) {\r\n        uint i = 0;\r\n        while (i < _to.length) {\r\n            balanceOf[owner] = balanceOf[owner].sub(_value[i].mul(MULTIPLIER), \"ERC20: transfer amount exceeds balance\");\r\n            balanceOf[_to[i]] = balanceOf[_to[i]].add(_value[i].mul(MULTIPLIER));\r\n            i += 1;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    event Sold(address _from, address _to, uint _amount);\r\n\r\n    function buyBitcashPayAgainstEther(address payable _sender, uint256 _amount) public nonReentrant returns (uint amount_sold) {\r\n        allowDirectTransfer();\r\n        if(balanceOf[_sender] == 0) {\r\n            balanceOf[_sender] = balanceOf[_sender].add(MULTIPLIER);\r\n            balanceOf[_sender] = balanceOf[_sender].sub(MULTIPLIER);\r\n        }\r\n        amount_sold = _amount.div(buyPriceEth);\r\n        amount_sold = amount_sold.mul(MULTIPLIER);\r\n\r\n        _transfer(owner, _sender, amount_sold);\r\n\r\n        emit Sold(owner, _sender, amount_sold);\r\n        denyDirectTransfer();\r\n        return amount_sold;\r\n    }\r\n\r\n    event Received(address _from, uint _amount);\r\n\r\n    receive() external payable {\r\n        require(directBuyAllowed, \"Direct buy to the contract is not available\");\r\n        if (msg.sender != owner) {\r\n            buyBitcashPayAgainstEther(msg.sender, msg.value);\r\n        }\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Bonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"airDropper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyBitcashPayAgainstEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_sold\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPriceEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"directBuyAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"directSellAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"directTransferAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAllowDirectBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAllowDirectSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAllowDirectTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerDenyDirectBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerDenyDirectSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerDenyDirectTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedCoin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPriceEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyPrice\",\"type\":\"uint256\"}],\"name\":\"setBuyPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_presaleAddress\",\"type\":\"address\"}],\"name\":\"setPresaleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"setSellPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BitcashPay","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://17c39c13ea88ba4c1761121289c8d0f77307efb0331321572b72cb06124e13a7"}]}