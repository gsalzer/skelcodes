{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/InterFaces/IAuctionRegistery.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract AuctionRegisteryContracts {\r\n    bytes32 internal constant MAIN_TOKEN = \"MAIN_TOKEN\";\r\n    bytes32 internal constant ETN_TOKEN = \"ETN_TOKEN\";\r\n    bytes32 internal constant STOCK_TOKEN = \"STOCK_TOKEN\";\r\n    bytes32 internal constant WHITE_LIST = \"WHITE_LIST\";\r\n    bytes32 internal constant AUCTION = \"AUCTION\";\r\n    bytes32 internal constant AUCTION_PROTECTION = \"AUCTION_PROTECTION\";\r\n    bytes32 internal constant LIQUIDITY = \"LIQUIDITY\";\r\n    bytes32 internal constant CURRENCY = \"CURRENCY\";\r\n    bytes32 internal constant VAULT = \"VAULT\";\r\n    bytes32 internal constant CONTRIBUTION_TRIGGER = \"CONTRIBUTION_TRIGGER\";\r\n    bytes32 internal constant COMPANY_FUND_WALLET = \"COMPANY_FUND_WALLET\";\r\n    bytes32 internal constant SMART_SWAP = \"SMART_SWAP\";\r\n    bytes32 internal constant SMART_SWAP_P2P = \"SMART_SWAP_P2P\";\r\n    bytes32 internal constant ESCROW = \"ESCROW\";\r\n}\r\n\r\ninterface IAuctionRegistery {\r\n    function getAddressOf(bytes32 _contractName)\r\n        external\r\n        view\r\n        returns (address payable);\r\n}\r\n\r\n// File: contracts/TokenVault/TokenVaultStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\ncontract TokenVaultStorage {\r\n    \r\n    IAuctionRegistery public contractsRegistry;\r\n    \r\n    address payable public auctionProtectionAddress;\r\n    \r\n    mapping(address=>bool) public isSpender;\r\n    \r\n    mapping(address => uint256) public spenderIndex;\r\n    \r\n    address[] public spenders;\r\n    \r\n    event TokenSpenderAdded(address indexed _which);\r\n    \r\n    event TokenSpenderRemoved(address indexed _which);\r\n    \r\n    event FundTransfer(address indexed _by,address _to,address _token,uint256 amount);\r\n    \r\n    event FundDeposited(address _token, address _from, uint256 _amount);\r\n    \r\n}\r\n\r\n// File: contracts/common/Constant.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract Constant {\r\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\r\n\r\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\r\n\r\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\r\n\r\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\r\n\r\n    string constant ERR_SAME_ADDRESS = \"ERR_SAME_ADDRESS\";\r\n\r\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\r\n\r\n    modifier notOwnAddress(address _which) {\r\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // validates an address is not zero\r\n    modifier notZeroAddress(address _which) {\r\n        require(_which != address(0), ERR_ZERO_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThisAddress(address _which) {\r\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    modifier notZeroValue(uint256 _value) {\r\n        require(_value > 0, ERR_VALUE_IS_ZERO);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/common/ProxyOwnable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\ncontract ProxyOwnable is Constant {\r\n    \r\n    address public primaryOwner;\r\n\r\n    address public authorityAddress;\r\n\r\n    address public newAuthorityAddress;\r\n\r\n    address public systemAddress;\r\n    \r\n    bool public isOwnerInitialize = false;\r\n\r\n    event OwnershipTransferred(\r\n        string ownerType,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    \r\n    event AuthorityAddressChnageCall(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the `primaryOwner` and `systemAddress` and '_multisigAddress'\r\n     * account.\r\n     */\r\n\r\n    function initializeOwner(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress\r\n    ) internal notZeroAddress(_primaryOwner) notZeroAddress(_systemAddress) notZeroAddress(_authorityAddress) {\r\n        \r\n        require(!isOwnerInitialize,\"ERR_OWNER_INTIALIZED_ALREADY\");\r\n        \r\n        require(_primaryOwner != _systemAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_systemAddress != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_primaryOwner != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        primaryOwner = _primaryOwner;\r\n        systemAddress = _systemAddress;\r\n        authorityAddress = _authorityAddress;\r\n        isOwnerInitialize = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == primaryOwner, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender == systemAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOneOfOnwer() {\r\n        require(\r\n            msg.sender == primaryOwner || msg.sender == systemAddress,\r\n            ERR_AUTHORIZED_ADDRESS_ONLY\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == authorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev change primary ownership governance \r\n     */\r\n    function changePrimaryOwner()\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        emit OwnershipTransferred(\"PRIMARY_OWNER\", primaryOwner, authorityAddress);\r\n        primaryOwner = authorityAddress;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new system address\r\n     */\r\n    function changeSystemAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notThisAddress(_which)\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress &&\r\n                _which != primaryOwner,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        emit OwnershipTransferred(\"SYSTEM_ADDRESS\", systemAddress, _which);\r\n        systemAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new Authority address\r\n     */\r\n    function changeAuthorityAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        newAuthorityAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    function acceptAuthorityAddress() public returns (bool) {\r\n        require(msg.sender == newAuthorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        emit OwnershipTransferred(\r\n            \"AUTHORITY_ADDRESS\",\r\n            authorityAddress,\r\n            newAuthorityAddress\r\n        );\r\n        authorityAddress = newAuthorityAddress;\r\n        newAuthorityAddress = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/common/SafeMath.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 result;\r\n        assembly {\r\n            result := exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // calculates a^(1/n) to dp decimal places\r\n    // maxIts bounds the number of iterations performed\r\n    function nthRoot(\r\n        uint256 _a,\r\n        uint256 _n,\r\n        uint256 _dp,\r\n        uint256 _maxIts\r\n    ) internal pure returns (uint256) {\r\n        assert(_n > 1);\r\n\r\n        // The scale factor is a crude way to turn everything into integer calcs.\r\n        // Actually do (a * (10 ^ ((dp + 1) * n))) ^ (1/n)\r\n        // We calculate to one extra dp and round at the end\r\n        uint256 one = 10**(1 + _dp);\r\n        uint256 a0 = one**_n * _a;\r\n\r\n        // Initial guess: 1.0\r\n        uint256 xNew = one;\r\n        uint256 x;\r\n\r\n        uint256 iter = 0;\r\n        while (xNew != x && iter < _maxIts) {\r\n            x = xNew;\r\n            uint256 t0 = x**(_n - 1);\r\n            if (x * t0 > a0) {\r\n                xNew = x - (x - a0 / t0) / _n;\r\n            } else {\r\n                xNew = x + (a0 / t0 - x) / _n;\r\n            }\r\n            ++iter;\r\n        }\r\n\r\n        // Round to nearest in the last dp.\r\n        return (xNew + 5) / 10;\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IERC20Token.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: contracts/common/TokenTransfer.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ncontract TokenTransfer {\r\n    function ensureTransferFrom(\r\n        IERC20Token _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_from == address(this))\r\n            require(_token.transfer(_to, _amount), \"ERR_TOKEN_TRANSFER_FAIL\");\r\n        else\r\n            require(\r\n                _token.transferFrom(_from, _to, _amount),\r\n                \"ERR_TOKEN_TRANSFER_FAIL\"\r\n            );\r\n    }\r\n\r\n    function approveTransferFrom(\r\n        IERC20Token _token,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_token.approve(_spender, _amount), \"ERR_TOKEN_APPROVAL_FAIL\");\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/IRegistry.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title IRegistry\r\n * @dev This contract represents the interface of a registry contract\r\n */\r\ninterface IRegistry {\r\n    /**\r\n     * @dev This event will be emitted every time a new proxy is created\r\n     * @param proxy representing the address of the proxy created\r\n     */\r\n    event ProxyCreated(address proxy);\r\n\r\n    /**\r\n     * @dev This event will be emitted every time a new implementation is registered\r\n     * @param version representing the version name of the registered implementation\r\n     * @param implementation representing the address of the registered implementation\r\n     */\r\n    event VersionAdded(uint256 version, address implementation);\r\n\r\n    /**\r\n     * @dev Registers a new version with its implementation address\r\n     * @param version representing the version name of the new implementation to be registered\r\n     * @param implementation representing the address of the new implementation to be registered\r\n     */\r\n    function addVersion(uint256  version, address implementation)\r\n        external;\r\n\r\n    /**\r\n     * @dev Tells the address of the implementation for a given version\r\n     * @param version to query the implementation of\r\n     * @return address of the implementation registered for the given version\r\n     */\r\n    function getVersion(uint256 version)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/Proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n     * @dev Tells the address of the implementation where every call will be delegated.\r\n     * @return address of the implementation to which it will be delegated\r\n     */\r\n    function implementation() public view returns (address);\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    \r\n    function() external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0),\"ERR_IMPLEMENTEION_ZERO\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }  \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n}\r\n\r\n// File: contracts/Proxy/UpgradeabilityStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage is Proxy {\r\n    // Versions registry\r\n    IRegistry public registry;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/Upgradeable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title Upgradeable\r\n * @dev This contract holds all the minimum required functionality for a behavior to be upgradeable.\r\n * This means, required state variables for owned upgradeability purpose and simple initialization validation.\r\n */\r\ncontract Upgradeable is UpgradeabilityStorage {\r\n    /**\r\n     * @dev Validates the caller is the versions registry.\r\n     * THIS FUNCTION SHOULD BE OVERRIDDEN CALLING SUPER\r\n     */\r\n    function initialize() public view {\r\n        require(msg.sender == address(registry),\"ERR_ONLY_REGISTRERY_CAN_CALL\");\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IAuctionProtection.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IAuctionProtection {\r\n    function lockEther(uint256 _auctionDay,address _which)\r\n        external\r\n        payable\r\n        returns (bool);\r\n    \r\n    function stackFund(uint256 _amount)\r\n        external\r\n        returns (bool);\r\n        \r\n    function depositToken(\r\n        uint256 _auctionDay,\r\n        address _which,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n    \r\n    function unLockTokens() external returns (bool);\r\n}\r\n\r\n// File: contracts/TokenVault/TokenVault.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface InitializeInterface {\r\n    function initialize(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        address _registryaddress\r\n    ) external;\r\n}\r\n\r\ncontract TokenRegistery is ProxyOwnable,TokenVaultStorage, AuctionRegisteryContracts {\r\n    \r\n    \r\n    function updateRegistery(address _address)\r\n        external\r\n        onlyAuthorized()\r\n        notZeroAddress(_address)\r\n        returns (bool)\r\n    {\r\n        \r\n        contractsRegistry = IAuctionRegistery(_address);\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n\r\n    function getAddressOf(bytes32 _contractName)\r\n        internal\r\n        view\r\n        returns (address payable)\r\n    {\r\n        return contractsRegistry.getAddressOf(_contractName);\r\n    }\r\n    \r\n    /**@dev updates all the address from the registry contract\r\n    this decision was made to save gas that occurs from calling an external view function */\r\n    \r\n    function _updateAddresses() internal {\r\n        auctionProtectionAddress = getAddressOf(AUCTION_PROTECTION);\r\n    }\r\n    \r\n    function updateAddresses() external returns (bool) {\r\n        _updateAddresses();\r\n    }\r\n}\r\n\r\ncontract TokenSpenders is TokenRegistery,SafeMath {\r\n    \r\n    \r\n    modifier onlySpender() {\r\n        require(isSpender[msg.sender],ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n    \r\n    // once all spender from set give authority to govenranacne \r\n    function addSpender(address _which) external onlyOwner() returns(bool){\r\n        require(isSpender[_which] == false,ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        isSpender[_which] = true;\r\n        spenderIndex[_which] = spenders.length;\r\n        spenders.push(_which);\r\n        emit TokenSpenderAdded(_which);\r\n        return true;\r\n        \r\n    }\r\n    \r\n    function removeSpender(address _which) external onlyAuthorized() returns(bool){\r\n        require(isSpender[_which],ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        uint256 _spenderIndex = spenderIndex[_which];\r\n        address _lastAdress = spenders[safeSub(spenders.length, 1)];\r\n        spenders[_spenderIndex] = _lastAdress;\r\n        spenderIndex[_lastAdress] = _spenderIndex;\r\n        delete isSpender[_which];\r\n        spenders.pop();\r\n        emit TokenSpenderRemoved(_which);\r\n        return true;\r\n        \r\n    }\r\n}\r\n\r\n\r\ncontract TokenVault is\r\n    Upgradeable,\r\n    TokenSpenders,\r\n    InitializeInterface,\r\n    TokenTransfer\r\n{   \r\n    \r\n  \r\n    \r\n    function initialize(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        address _registryaddress\r\n    ) public {\r\n        super.initialize();\r\n        contractsRegistry = IAuctionRegistery(_registryaddress);\r\n        _updateAddresses();\r\n        initializeOwner(\r\n            _primaryOwner,\r\n            _systemAddress,\r\n            _authorityAddress\r\n        );\r\n       \r\n    }\r\n    \r\n  \r\n    function() external payable{\r\n        emit FundDeposited(address(0), msg.sender, msg.value);\r\n    }\r\n\r\n    function depositeToken(IERC20Token _token, address _from, uint256 _amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        ensureTransferFrom(_token, _from, address(this), _amount);\r\n        emit FundDeposited(address(_token), _from, _amount);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function directTransfer(address _token,address _to,uint256 amount) external onlySpender() returns (bool){\r\n        ensureTransferFrom(IERC20Token(_token),address(this),_to,amount);\r\n        emit FundTransfer(msg.sender,_to,_token,amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferEther(address payable _to,uint256 amount) external onlySpender() returns (bool){\r\n        _to.transfer(amount);\r\n        emit FundTransfer(msg.sender,_to,address(0),amount);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    // This method is auction protection methods called from here \r\n    // vault address set when contribution is 0\r\n    function unLockTokens() external onlySystem() returns (bool){\r\n        return IAuctionProtection(auctionProtectionAddress).unLockTokens();\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeSystemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unLockTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionProtectionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changePrimaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwnerInitialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spenders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"removeSpender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSpender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"spenderIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateRegistery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"addSpender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"directTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primaryOwner\",\"type\":\"address\"},{\"name\":\"_systemAddress\",\"type\":\"address\"},{\"name\":\"_authorityAddress\",\"type\":\"address\"},{\"name\":\"_registryaddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"TokenSpenderAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"TokenSpenderRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerType\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AuthorityAddressChnageCall\",\"type\":\"event\"}]","ContractName":"TokenVault","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4431efafa1234f0a24353ff517434107387dcc254dde1ee1ff24a2e7e7a05192"}]}