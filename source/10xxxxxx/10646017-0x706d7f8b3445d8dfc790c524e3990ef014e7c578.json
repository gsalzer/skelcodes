{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IAmp {\r\n    function registerCollateralManager() external;\r\n}\r\n\r\n/**\r\n * @title Ownable is a contract the provides contract ownership functionality, including a two-\r\n * phase transfer.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _authorizedNewOwner;\r\n\r\n    /**\r\n     * @notice Emitted when the owner authorizes ownership transfer to a new address\r\n     * @param authorizedAddress New owner address\r\n     */\r\n    event OwnershipTransferAuthorization(address indexed authorizedAddress);\r\n\r\n    /**\r\n     * @notice Emitted when the authorized address assumed ownership\r\n     * @param oldValue Old owner\r\n     * @param newValue New owner\r\n     */\r\n    event OwnerUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**\r\n     * @notice Sets the owner to the sender / contract creator\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the owner of the contract\r\n     * @return The contract owner\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the authorized new owner of the contract\r\n     * @return The authorized new contract owner\r\n     */\r\n    function authorizedNewOwner() public view returns (address) {\r\n        return _authorizedNewOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Authorizes the transfer of ownership from owner to the provided address.\r\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership().\r\n     * This authorization may be removed by another call to this function authorizing the zero\r\n     * address.\r\n     * @param _authorizedAddress The address authorized to become the new owner\r\n     */\r\n    function authorizeOwnershipTransfer(address _authorizedAddress) external {\r\n        require(msg.sender == _owner, \"Invalid sender\");\r\n\r\n        _authorizedNewOwner = _authorizedAddress;\r\n\r\n        emit OwnershipTransferAuthorization(_authorizedNewOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of this contract to the _authorizedNewOwner\r\n     * @dev Error invalid sender.\r\n     */\r\n    function assumeOwnership() external {\r\n        require(msg.sender == _authorizedNewOwner, \"Invalid sender\");\r\n\r\n        address oldValue = _owner;\r\n        _owner = _authorizedNewOwner;\r\n        _authorizedNewOwner = address(0);\r\n\r\n        emit OwnerUpdate(oldValue, _owner);\r\n    }\r\n}\r\n\r\nabstract contract ERC1820Registry {\r\n    function setInterfaceImplementer(\r\n        address _addr,\r\n        bytes32 _interfaceHash,\r\n        address _implementer\r\n    ) external virtual;\r\n\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\r\n        external\r\n        virtual\r\n        view\r\n        returns (address);\r\n\r\n    function setManager(address _addr, address _newManager) external virtual;\r\n\r\n    function getManager(address _addr) public virtual view returns (address);\r\n}\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(\r\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\r\n    );\r\n\r\n    function setInterfaceImplementation(\r\n        string memory _interfaceLabel,\r\n        address _implementation\r\n    ) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(\r\n            address(this),\r\n            interfaceHash,\r\n            _implementation\r\n        );\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\n/**\r\n * @title IAmpTokensRecipient\r\n * @dev IAmpTokensRecipient token transfer hook interface\r\n */\r\ninterface IAmpTokensRecipient {\r\n    /**\r\n     * @dev Report if the recipient will successfully receive the tokens\r\n     */\r\n    function canReceive(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Hook executed upon a transfer to the recipient\r\n     */\r\n    function tokensReceived(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title IAmpTokensSender\r\n * @dev IAmpTokensSender token transfer hook interface\r\n */\r\ninterface IAmpTokensSender {\r\n    /**\r\n     * @dev Report if the transfer will succeed from the pespective of the\r\n     * token sender\r\n     */\r\n    function canTransfer(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Hook executed upon a transfer on behalf of the sender\r\n     */\r\n    function tokensToTransfer(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title PartitionUtils\r\n * @notice Partition related helper functions.\r\n */\r\n\r\nlibrary PartitionUtils {\r\n    bytes32 public constant CHANGE_PARTITION_FLAG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @notice Retrieve the destination partition from the 'data' field.\r\n     * A partition change is requested ONLY when 'data' starts with the flag:\r\n     *\r\n     *   0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n     *\r\n     * When the flag is detected, the destination partition is extracted from the\r\n     * 32 bytes following the flag.\r\n     * @param _data Information attached to the transfer. Will contain the\r\n     * destination partition if a change is requested.\r\n     * @param _fallbackPartition Partition value to return if a partition change\r\n     * is not requested in the `_data`.\r\n     * @return toPartition Destination partition. If the `_data` does not contain\r\n     * the prefix and bytes32 partition in the first 64 bytes, the method will\r\n     * return the provided `_fromPartition`.\r\n     */\r\n    function _getDestinationPartition(bytes memory _data, bytes32 _fallbackPartition)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        if (_data.length < 64) {\r\n            return _fallbackPartition;\r\n        }\r\n\r\n        (bytes32 flag, bytes32 toPartition) = abi.decode(_data, (bytes32, bytes32));\r\n        if (flag == CHANGE_PARTITION_FLAG) {\r\n            return toPartition;\r\n        }\r\n\r\n        return _fallbackPartition;\r\n    }\r\n\r\n    /**\r\n     * @notice Helper to get the strategy identifying prefix from the `_partition`.\r\n     * @param _partition Partition to get the prefix for.\r\n     * @return 4 byte partition strategy prefix.\r\n     */\r\n    function _getPartitionPrefix(bytes32 _partition) internal pure returns (bytes4) {\r\n        return bytes4(_partition);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to split the partition into the prefix, sub partition\r\n     * and partition owner components.\r\n     * @param _partition The partition to split into parts.\r\n     * @return The 4 byte partition prefix, 8 byte sub partition, and final 20\r\n     * bytes representing an address.\r\n     */\r\n    function _splitPartition(bytes32 _partition)\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes4,\r\n            bytes8,\r\n            address\r\n        )\r\n    {\r\n        bytes4 prefix = bytes4(_partition);\r\n        bytes8 subPartition = bytes8(_partition << 32);\r\n        address addressPart = address(uint160(uint256(_partition)));\r\n        return (prefix, subPartition, addressPart);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to get a partition strategy ERC1820 interface name\r\n     * based on partition prefix.\r\n     * @param _prefix 4 byte partition prefix.\r\n     * @dev Each 4 byte prefix has a unique interface name so that an individual\r\n     * hook implementation can be set for each prefix.\r\n     */\r\n    function _getPartitionStrategyValidatorIName(bytes4 _prefix)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(\"AmpPartitionStrategyValidator\", _prefix));\r\n    }\r\n}\r\n\r\n/**\r\n * @title FlexaCollateralManager is an implementation of IAmpTokensSender and IAmpTokensRecipient\r\n * which serves as the Amp collateral manager for the Flexa Network.\r\n */\r\ncontract FlexaCollateralManager is Ownable, IAmpTokensSender, IAmpTokensRecipient, ERC1820Client {\r\n    /**\r\n     * @dev AmpTokensSender interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_SENDER = \"AmpTokensSender\";\r\n\r\n    /**\r\n     * @dev AmpTokensRecipient interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_RECIPIENT = \"AmpTokensRecipient\";\r\n\r\n    /**\r\n     * @dev Change Partition Flag used in transfer data parameters to signal which partition\r\n     * will receive the tokens.\r\n     */\r\n    bytes32\r\n        internal constant CHANGE_PARTITION_FLAG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Required prefix for all registered partitions. Used to ensure the Collateral Pool\r\n     * Partition Validator is used within Amp.\r\n     */\r\n    bytes4 internal constant PARTITION_PREFIX = 0xCCCCCCCC;\r\n\r\n    /**********************************************************************************************\r\n     * Operator Data Flags\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @dev Flag used in operator data parameters to indicate the transfer is a withdrawal\r\n     */\r\n    bytes32\r\n        internal constant WITHDRAWAL_FLAG = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\r\n\r\n    /**\r\n     * @dev Flag used in operator data parameters to indicate the transfer is a fallback\r\n     * withdrawal\r\n     */\r\n    bytes32\r\n        internal constant FALLBACK_WITHDRAWAL_FLAG = 0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\r\n\r\n    /**\r\n     * @dev Flag used in operator data parameters to indicate the transfer is a supply refund\r\n     */\r\n    bytes32\r\n        internal constant REFUND_FLAG = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\r\n\r\n    /**\r\n     * @dev Flag used in operator data parameters to indicate the transfer is a direct transfer\r\n     */\r\n    bytes32\r\n        internal constant DIRECT_TRANSFER_FLAG = 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd;\r\n\r\n    /**********************************************************************************************\r\n     * Configuration\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Address of the Amp contract. Immutable.\r\n     */\r\n    address public amp;\r\n\r\n    /**\r\n     * @notice Permitted partitions\r\n     */\r\n    mapping(bytes32 => bool) public partitions;\r\n\r\n    /**********************************************************************************************\r\n     * Roles\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Address authorized to publish withdrawal roots\r\n     */\r\n    address public withdrawalPublisher;\r\n\r\n    /**\r\n     * @notice Address authorized to publish fallback withdrawal roots\r\n     */\r\n    address public fallbackPublisher;\r\n\r\n    /**\r\n     * @notice Address authorized to adjust the withdrawal limit\r\n     */\r\n    address public withdrawalLimitPublisher;\r\n\r\n    /**\r\n     * @notice Address authorized to directly transfer tokens\r\n     */\r\n    address public directTransferer;\r\n\r\n    /**\r\n     * @notice Address authorized to manage permitted partition\r\n     */\r\n    address public partitionManager;\r\n\r\n    /**\r\n     * @notice Struct used to record received tokens that can be recovered during the fallback\r\n     * withdrawal period\r\n     * @param supplier Token supplier\r\n     * @param partition Partition which received the tokens\r\n     * @param amount Number of tokens received\r\n     */\r\n    struct Supply {\r\n        address supplier;\r\n        bytes32 partition;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Supply State\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Supply nonce used to track incoming token transfers\r\n     */\r\n    uint256 public supplyNonce = 0;\r\n\r\n    /**\r\n     * @notice Mapping of all incoming token transfers\r\n     */\r\n    mapping(uint256 => Supply) public nonceToSupply;\r\n\r\n    /**********************************************************************************************\r\n     * Withdrawal State\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Remaining withdrawal limit. Initially set to 100,000 Amp.\r\n     */\r\n    uint256 public withdrawalLimit = 100 * 1000 * (10**18);\r\n\r\n    /**\r\n     * @notice Withdrawal maximum root nonce\r\n     */\r\n    uint256 public maxWithdrawalRootNonce = 0;\r\n\r\n    /**\r\n     * @notice Active set of withdrawal roots\r\n     */\r\n    mapping(bytes32 => uint256) public withdrawalRootToNonce;\r\n\r\n    /**\r\n     * @notice Last invoked withdrawal root for each account, per partition\r\n     */\r\n    mapping(bytes32 => mapping(address => uint256)) public addressToWithdrawalNonce;\r\n\r\n    /**\r\n     * @notice Total amount withdrawn for each account, per partition\r\n     */\r\n    mapping(bytes32 => mapping(address => uint256)) public addressToCumulativeAmountWithdrawn;\r\n\r\n    /**********************************************************************************************\r\n     * Fallback Withdrawal State\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Withdrawal fallback delay. Initially set to one week.\r\n     */\r\n    uint256 public fallbackWithdrawalDelaySeconds = 1 weeks;\r\n\r\n    /**\r\n     * @notice Current fallback withdrawal root\r\n     */\r\n    bytes32 public fallbackRoot;\r\n\r\n    /**\r\n     * @notice Timestamp of when the last fallback root was published\r\n     */\r\n    uint256 public fallbackSetDate = 2**200; // very far in the future\r\n\r\n    /**\r\n     * @notice Latest supply reflected in the fallback withdrawal authorization tree\r\n     */\r\n    uint256 public fallbackMaxIncludedSupplyNonce = 0;\r\n\r\n    /**********************************************************************************************\r\n     * Supplier Events\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Indicates a token supply has been received\r\n     * @param supplier Token supplier\r\n     * @param amount Number of tokens transferred\r\n     * @param nonce Nonce of the supply\r\n     */\r\n    event SupplyReceipt(\r\n        address indexed supplier,\r\n        bytes32 indexed partition,\r\n        uint256 amount,\r\n        uint256 indexed nonce\r\n    );\r\n\r\n    /**\r\n     * @notice Indicates that a withdrawal was executed\r\n     * @param supplier Address whose withdrawal authorization was executed\r\n     * @param partition Partition from which the tokens were transferred\r\n     * @param amount Amount of tokens transferred\r\n     * @param rootNonce Nonce of the withdrawal root used for authorization\r\n     * @param authorizedAccountNonce Maximum previous nonce used by the account\r\n     */\r\n    event Withdrawal(\r\n        address indexed supplier,\r\n        bytes32 indexed partition,\r\n        uint256 amount,\r\n        uint256 indexed rootNonce,\r\n        uint256 authorizedAccountNonce\r\n    );\r\n\r\n    /**\r\n     * @notice Indicates a fallback withdrawal was executed\r\n     * @param supplier Address whose fallback withdrawal authorization was executed\r\n     * @param partition Partition from which the tokens were transferred\r\n     * @param amount Amount of tokens transferred\r\n     */\r\n    event FallbackWithdrawal(\r\n        address indexed supplier,\r\n        bytes32 indexed partition,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /**\r\n     * @notice Indicates a release of supply is requested\r\n     * @param supplier Token supplier\r\n     * @param partition Parition from which the tokens should be released\r\n     * @param amount Number of tokens requested to be released\r\n     * @param data Metadata provided by the requestor\r\n     */\r\n    event ReleaseRequest(\r\n        address indexed supplier,\r\n        bytes32 indexed partition,\r\n        uint256 indexed amount,\r\n        bytes data\r\n    );\r\n\r\n    /**\r\n     * @notice Indicates a supply refund was executed\r\n     * @param supplier Address whose refund authorization was executed\r\n     * @param partition Partition from which the tokens were transferred\r\n     * @param amount Amount of tokens transferred\r\n     * @param nonce Nonce of the original supply\r\n     */\r\n    event SupplyRefund(\r\n        address indexed supplier,\r\n        bytes32 indexed partition,\r\n        uint256 amount,\r\n        uint256 indexed nonce\r\n    );\r\n\r\n    /**********************************************************************************************\r\n     * Direct Transfer Events\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Emitted when tokens are directly transfered\r\n     * @param operator Address that executed the direct transfer\r\n     * @param from_partition Partition from which the tokens were transferred\r\n     * @param to_address Address to which the tokens were transferred\r\n     * @param to_partition Partition to which the tokens were transferred\r\n     * @param value Amount of tokens transferred\r\n     */\r\n    event DirectTransfer(\r\n        address operator,\r\n        bytes32 indexed from_partition,\r\n        address indexed to_address,\r\n        bytes32 indexed to_partition,\r\n        uint256 value\r\n    );\r\n\r\n    /**********************************************************************************************\r\n     * Admin Configuration Events\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Emitted when a partition is permitted for supply\r\n     * @param partition Partition added to the permitted set\r\n     */\r\n    event PartitionAdded(bytes32 indexed partition);\r\n\r\n    /**\r\n     * @notice Emitted when a partition is removed from the set permitted for supply\r\n     * @param partition Partition removed from the permitted set\r\n     */\r\n    event PartitionRemoved(bytes32 indexed partition);\r\n\r\n    /**********************************************************************************************\r\n     * Admin Withdrawal Management Events\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Emitted when a new withdrawal root hash is added to the active set\r\n     * @param rootHash Merkle root hash.\r\n     * @param nonce Nonce of the Merkle root hash.\r\n     */\r\n    event WithdrawalRootHashAddition(bytes32 indexed rootHash, uint256 indexed nonce);\r\n\r\n    /**\r\n     * @notice Emitted when a withdrawal root hash is removed from the active set\r\n     * @param rootHash Merkle root hash.\r\n     * @param nonce Nonce of the Merkle root hash.\r\n     */\r\n    event WithdrawalRootHashRemoval(bytes32 indexed rootHash, uint256 indexed nonce);\r\n\r\n    /**\r\n     * @notice Emitted when the withdrawal limit is updated\r\n     * @param oldValue Old limit.\r\n     * @param newValue New limit.\r\n     */\r\n    event WithdrawalLimitUpdate(uint256 indexed oldValue, uint256 indexed newValue);\r\n\r\n    /**********************************************************************************************\r\n     * Admin Fallback Management Events\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Emitted when a new fallback withdrawal root hash is set\r\n     * @param rootHash Merkle root hash\r\n     * @param maxSupplyNonceIncluded Nonce of the last supply reflected in the tree data\r\n     * @param setDate Timestamp of when the root hash was set\r\n     */\r\n    event FallbackRootHashSet(\r\n        bytes32 indexed rootHash,\r\n        uint256 indexed maxSupplyNonceIncluded,\r\n        uint256 setDate\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when the fallback root hash set date is reset\r\n     * @param newDate Timestamp of when the fallback reset date was set\r\n     */\r\n    event FallbackMechanismDateReset(uint256 indexed newDate);\r\n\r\n    /**\r\n     * @notice Emitted when the fallback delay is updated\r\n     * @param oldValue Old delay\r\n     * @param newValue New delay\r\n     */\r\n    event FallbackWithdrawalDelayUpdate(uint256 indexed oldValue, uint256 indexed newValue);\r\n\r\n    /**********************************************************************************************\r\n     * Role Management Events\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Emitted when the Withdrawal Publisher is updated\r\n     * @param oldValue Old publisher\r\n     * @param newValue New publisher\r\n     */\r\n    event WithdrawalPublisherUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**\r\n     * @notice Emitted when the Fallback Publisher is updated\r\n     * @param oldValue Old publisher\r\n     * @param newValue New publisher\r\n     */\r\n    event FallbackPublisherUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**\r\n     * @notice Emitted when Withdrawal Limit Publisher is updated\r\n     * @param oldValue Old publisher\r\n     * @param newValue New publisher\r\n     */\r\n    event WithdrawalLimitPublisherUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**\r\n     * @notice Emitted when the DirectTransferer address is updated\r\n     * @param oldValue Old DirectTransferer address\r\n     * @param newValue New DirectTransferer address\r\n     */\r\n    event DirectTransfererUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**\r\n     * @notice Emitted when the Partition Manager address is updated\r\n     * @param oldValue Old Partition Manager address\r\n     * @param newValue New Partition Manager address\r\n     */\r\n    event PartitionManagerUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**********************************************************************************************\r\n     * Constructor\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice FlexaCollateralManager constructor\r\n     * @param _amp Address of the Amp token contract\r\n     */\r\n    constructor(address _amp) public {\r\n        amp = _amp;\r\n\r\n        ERC1820Client.setInterfaceImplementation(AMP_TOKENS_RECIPIENT, address(this));\r\n        ERC1820Client.setInterfaceImplementation(AMP_TOKENS_SENDER, address(this));\r\n\r\n        IAmp(amp).registerCollateralManager();\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * IAmpTokensRecipient Hooks\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Validates where the supplied parameters are valid for a transfer of tokens to this\r\n     * contract\r\n     * @dev Implements IAmpTokensRecipient\r\n     * @param _partition Partition from which the tokens were transferred\r\n     * @param _to The destination address of the tokens. Must be this.\r\n     * @param _data Optional data sent with the transfer. Used to set the destination partition.\r\n     * @return true if the tokens can be received, otherwise false\r\n     */\r\n    function canReceive(\r\n        bytes4, /* functionSig */\r\n        bytes32 _partition,\r\n        address, /* operator */\r\n        address, /* from */\r\n        address _to,\r\n        uint256, /* value */\r\n        bytes calldata _data,\r\n        bytes calldata /* operatorData */\r\n    ) external override view returns (bool) {\r\n        if (msg.sender != amp || _to != address(this)) {\r\n            return false;\r\n        }\r\n\r\n        bytes32 _destinationPartition = PartitionUtils._getDestinationPartition(_data, _partition);\r\n\r\n        return partitions[_destinationPartition];\r\n    }\r\n\r\n    /**\r\n     * @notice Function called by the token contract after executing a transfer.\r\n     * @dev Implements IAmpTokensRecipient\r\n     * @param _partition Partition from which the tokens were transferred\r\n     * @param _operator Address which triggered the transfer. This address will be credited with\r\n     * the supply.\r\n     * @param _to The destination address of the tokens. Must be this.\r\n     * @param _value Number of tokens the token holder balance is decreased by.\r\n     * @param _data Optional data sent with the transfer. Used to set the destination partition.\r\n     */\r\n    function tokensReceived(\r\n        bytes4, /* functionSig */\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address, /* from */\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata /* operatorData */\r\n    ) external override {\r\n        require(msg.sender == amp, \"Invalid sender\");\r\n        require(_to == address(this), \"Invalid to address\");\r\n\r\n        bytes32 _destinationPartition = PartitionUtils._getDestinationPartition(_data, _partition);\r\n\r\n        require(partitions[_destinationPartition], \"Invalid destination partition\");\r\n\r\n        supplyNonce = SafeMath.add(supplyNonce, 1);\r\n        nonceToSupply[supplyNonce].supplier = _operator;\r\n        nonceToSupply[supplyNonce].partition = _destinationPartition;\r\n        nonceToSupply[supplyNonce].amount = _value;\r\n\r\n        emit SupplyReceipt(_operator, _destinationPartition, _value, supplyNonce);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * IAmpTokensSender Hooks\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Validates where the supplied parameters are valid for a transfer of tokens from this\r\n     * contract\r\n     * @dev Implements IAmpTokensSender\r\n     * @param _partition Source partition of the tokens\r\n     * @param _operator Address which triggered the transfer\r\n     * @param _from The source address of the tokens. Must be this.\r\n     * @param _value Amount of tokens to be transferred\r\n     * @param _operatorData Extra information attached by the operator. Must include the transfer\r\n     * operation flag and additional authorization data custom for each transfer operation type.\r\n     * @return true if the token transfer would succeed, otherwise false\r\n     */\r\n    function canTransfer(\r\n        bytes4, /*functionSig*/\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address, /* to */\r\n        uint256 _value,\r\n        bytes calldata, /* data */\r\n        bytes calldata _operatorData\r\n    ) external override view returns (bool) {\r\n        if (msg.sender != amp || _from != address(this)) {\r\n            return false;\r\n        }\r\n\r\n        bytes32 flag = _decodeOperatorDataFlag(_operatorData);\r\n\r\n        if (flag == WITHDRAWAL_FLAG) {\r\n            return _validateWithdrawal(_partition, _operator, _value, _operatorData);\r\n        }\r\n        if (flag == FALLBACK_WITHDRAWAL_FLAG) {\r\n            return _validateFallbackWithdrawal(_partition, _operator, _value, _operatorData);\r\n        }\r\n        if (flag == REFUND_FLAG) {\r\n            return _validateRefund(_partition, _operator, _value, _operatorData);\r\n        }\r\n        if (flag == DIRECT_TRANSFER_FLAG) {\r\n            return _validateDirectTransfer(_operator, _value);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Function called by the token contract when executing a transfer\r\n     * @dev Implements IAmpTokensSender\r\n     * @param _partition Source partition of the tokens\r\n     * @param _operator Address which triggered the transfer\r\n     * @param _from The source address of the tokens. Must be this.\r\n     * @param _to The target address of the tokens.\r\n     * @param _value Amount of tokens to be transferred\r\n     * @param _data Data attached to the transfer. Typically includes partition change information.\r\n     * @param _operatorData Extra information attached by the operator. Must include the transfer\r\n     * operation flag and additional authorization data custom for each transfer operation type.\r\n     */\r\n    function tokensToTransfer(\r\n        bytes4, /* functionSig */\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external override {\r\n        require(msg.sender == amp, \"Invalid sender\");\r\n        require(_from == address(this), \"Invalid from address\");\r\n\r\n        bytes32 flag = _decodeOperatorDataFlag(_operatorData);\r\n\r\n        if (flag == WITHDRAWAL_FLAG) {\r\n            _executeWithdrawal(_partition, _operator, _value, _operatorData);\r\n        } else if (flag == FALLBACK_WITHDRAWAL_FLAG) {\r\n            _executeFallbackWithdrawal(_partition, _operator, _value, _operatorData);\r\n        } else if (flag == REFUND_FLAG) {\r\n            _executeRefund(_partition, _operator, _value, _operatorData);\r\n        } else if (flag == DIRECT_TRANSFER_FLAG) {\r\n            _executeDirectTransfer(_partition, _operator, _to, _value, _data);\r\n        } else {\r\n            revert(\"invalid flag\");\r\n        }\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Withdrawals\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Validates withdrawal data\r\n     * @param _partition Source partition of the withdrawal\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the withdrawal authorization data\r\n     * @return true if the withdrawal data is valid, otherwise false\r\n     */\r\n    function _validateWithdrawal(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    ) internal view returns (bool) {\r\n        (\r\n            address supplier,\r\n            uint256 maxAuthorizedAccountNonce,\r\n            uint256 withdrawalRootNonce\r\n        ) = _getWithdrawalData(_partition, _value, _operatorData);\r\n\r\n        return\r\n            _validateWithdrawalData(\r\n                _partition,\r\n                _operator,\r\n                _value,\r\n                supplier,\r\n                maxAuthorizedAccountNonce,\r\n                withdrawalRootNonce\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Validates the withdrawal data and updates state to reflect the transfer\r\n     * @param _partition Source partition of the withdrawal\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the withdrawal authorization data\r\n     */\r\n    function _executeWithdrawal(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    ) internal {\r\n        (\r\n            address supplier,\r\n            uint256 maxAuthorizedAccountNonce,\r\n            uint256 withdrawalRootNonce\r\n        ) = _getWithdrawalData(_partition, _value, _operatorData);\r\n\r\n        require(\r\n            _validateWithdrawalData(\r\n                _partition,\r\n                _operator,\r\n                _value,\r\n                supplier,\r\n                maxAuthorizedAccountNonce,\r\n                withdrawalRootNonce\r\n            ),\r\n            \"Transfer unauthorized\"\r\n        );\r\n\r\n        addressToCumulativeAmountWithdrawn[_partition][supplier] = SafeMath.add(\r\n            _value,\r\n            addressToCumulativeAmountWithdrawn[_partition][supplier]\r\n        );\r\n\r\n        addressToWithdrawalNonce[_partition][supplier] = withdrawalRootNonce;\r\n\r\n        withdrawalLimit = SafeMath.sub(withdrawalLimit, _value);\r\n\r\n        emit Withdrawal(\r\n            supplier,\r\n            _partition,\r\n            _value,\r\n            withdrawalRootNonce,\r\n            maxAuthorizedAccountNonce\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Extracts withdrawal data from the supplied parameters\r\n     * @param _partition Source partition of the withdrawal\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the withdrawal authorization data, including the withdrawal\r\n     * operation flag, supplier, maximum authorized account nonce, and Merkle proof.\r\n     * @return supplier, the address whose account is authorized\r\n     * @return maxAuthorizedAccountNonce, the maximum existing used withdrawal nonce for the\r\n     * supplier and partition\r\n     * @return withdrawalRootNonce, the active withdrawal root nonce found based on the supplied\r\n     * data and Merkle proof\r\n     */\r\n    function _getWithdrawalData(\r\n        bytes32 _partition,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            address, /* supplier */\r\n            uint256, /* maxAuthorizedAccountNonce */\r\n            uint256 /* withdrawalRootNonce */\r\n        )\r\n    {\r\n        (\r\n            address supplier,\r\n            uint256 maxAuthorizedAccountNonce,\r\n            bytes32[] memory merkleProof\r\n        ) = _decodeWithdrawalOperatorData(_operatorData);\r\n\r\n        bytes32 leafDataHash = _calculateWithdrawalLeaf(\r\n            supplier,\r\n            _partition,\r\n            _value,\r\n            maxAuthorizedAccountNonce\r\n        );\r\n\r\n        bytes32 calculatedRoot = _calculateMerkleRoot(merkleProof, leafDataHash);\r\n        uint256 withdrawalRootNonce = withdrawalRootToNonce[calculatedRoot];\r\n\r\n        return (supplier, maxAuthorizedAccountNonce, withdrawalRootNonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates that the parameters are valid for the requested withdrawal\r\n     * @param _partition Source partition of the tokens\r\n     * @param _operator Address that is executing the withdrawal\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _supplier The address whose account is authorized\r\n     * @param _maxAuthorizedAccountNonce The maximum existing used withdrawal nonce for the\r\n     * supplier and partition\r\n     * @param _withdrawalRootNonce The active withdrawal root nonce found based on the supplied\r\n     * data and Merkle proof\r\n     * @return true if the withdrawal data is valid, otherwise false\r\n     */\r\n    function _validateWithdrawalData(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        address _supplier,\r\n        uint256 _maxAuthorizedAccountNonce,\r\n        uint256 _withdrawalRootNonce\r\n    ) internal view returns (bool) {\r\n        return\r\n            // Only owner, withdrawal publisher or supplier can invoke withdrawals\r\n            (_operator == owner() || _operator == withdrawalPublisher || _operator == _supplier) &&\r\n            // Ensure maxAuthorizedAccountNonce has not been exceeded\r\n            (addressToWithdrawalNonce[_partition][_supplier] <= _maxAuthorizedAccountNonce) &&\r\n            // Ensure we are within the global withdrawal limit\r\n            (_value <= withdrawalLimit) &&\r\n            // Merkle tree proof is valid\r\n            (_withdrawalRootNonce > 0) &&\r\n            // Ensure the withdrawal root is more recent than the maxAuthorizedAccountNonce\r\n            (_withdrawalRootNonce > _maxAuthorizedAccountNonce);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Fallback Withdrawals\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Validates fallback withdrawal data\r\n     * @param _partition Source partition of the withdrawal\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the fallback withdrawal authorization data\r\n     * @return true if the fallback withdrawal data is valid, otherwise false\r\n     */\r\n    function _validateFallbackWithdrawal(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    ) internal view returns (bool) {\r\n        (\r\n            address supplier,\r\n            uint256 maxCumulativeWithdrawalAmount,\r\n            uint256 newCumulativeWithdrawalAmount,\r\n            bytes32 calculatedRoot\r\n        ) = _getFallbackWithdrawalData(_partition, _value, _operatorData);\r\n\r\n        return\r\n            _validateFallbackWithdrawalData(\r\n                _operator,\r\n                maxCumulativeWithdrawalAmount,\r\n                newCumulativeWithdrawalAmount,\r\n                supplier,\r\n                calculatedRoot\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Validates the fallback withdrawal data and updates state to reflect the transfer\r\n     * @param _partition Source partition of the withdrawal\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the fallback withdrawal authorization data\r\n     */\r\n    function _executeFallbackWithdrawal(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    ) internal {\r\n        (\r\n            address supplier,\r\n            uint256 maxCumulativeWithdrawalAmount,\r\n            uint256 newCumulativeWithdrawalAmount,\r\n            bytes32 calculatedRoot\r\n        ) = _getFallbackWithdrawalData(_partition, _value, _operatorData);\r\n\r\n        require(\r\n            _validateFallbackWithdrawalData(\r\n                _operator,\r\n                maxCumulativeWithdrawalAmount,\r\n                newCumulativeWithdrawalAmount,\r\n                supplier,\r\n                calculatedRoot\r\n            ),\r\n            \"Transfer unauthorized\"\r\n        );\r\n\r\n        addressToCumulativeAmountWithdrawn[_partition][supplier] = newCumulativeWithdrawalAmount;\r\n\r\n        addressToWithdrawalNonce[_partition][supplier] = maxWithdrawalRootNonce;\r\n\r\n        emit FallbackWithdrawal(supplier, _partition, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Extracts withdrawal data from the supplied parameters\r\n     * @param _partition Source partition of the withdrawal\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the fallback withdrawal authorization data, including the\r\n     * fallback withdrawal operation flag, supplier, max cumulative withdrawal amount, and Merkle\r\n     * proof.\r\n     * @return supplier, the address whose account is authorized\r\n     * @return maxCumulativeWithdrawalAmount, the maximum amount of tokens that can be withdrawn\r\n     * for the supplier's account, including both withdrawals and fallback withdrawals\r\n     * @return newCumulativeWithdrawalAmount, the new total of all withdrawals include the\r\n     * current request\r\n     * @return calculatedRoot, the Merkle tree root calculated based on the supplied data and proof\r\n     */\r\n    function _getFallbackWithdrawalData(\r\n        bytes32 _partition,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            address, /* supplier */\r\n            uint256, /* maxCumulativeWithdrawalAmount */\r\n            uint256, /* newCumulativeWithdrawalAmount */\r\n            bytes32 /* calculatedRoot */\r\n        )\r\n    {\r\n        (\r\n            address supplier,\r\n            uint256 maxCumulativeWithdrawalAmount,\r\n            bytes32[] memory merkleProof\r\n        ) = _decodeWithdrawalOperatorData(_operatorData);\r\n\r\n        uint256 newCumulativeWithdrawalAmount = SafeMath.add(\r\n            _value,\r\n            addressToCumulativeAmountWithdrawn[_partition][supplier]\r\n        );\r\n\r\n        bytes32 leafDataHash = _calculateFallbackLeaf(\r\n            supplier,\r\n            _partition,\r\n            maxCumulativeWithdrawalAmount\r\n        );\r\n        bytes32 calculatedRoot = _calculateMerkleRoot(merkleProof, leafDataHash);\r\n\r\n        return (\r\n            supplier,\r\n            maxCumulativeWithdrawalAmount,\r\n            newCumulativeWithdrawalAmount,\r\n            calculatedRoot\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Validates that the parameters are valid for the requested fallback withdrawal\r\n     * @param _operator Address that is executing the withdrawal\r\n     * @param _maxCumulativeWithdrawalAmount, the maximum amount of tokens that can be withdrawn\r\n     * for the supplier's account, including both withdrawals and fallback withdrawals\r\n     * @param _newCumulativeWithdrawalAmount, the new total of all withdrawals include the\r\n     * current request\r\n     * @param _supplier The address whose account is authorized\r\n     * @param _calculatedRoot The Merkle tree root calculated based on the supplied data and proof\r\n     * @return true if the fallback withdrawal data is valid, otherwise false\r\n     */\r\n    function _validateFallbackWithdrawalData(\r\n        address _operator,\r\n        uint256 _maxCumulativeWithdrawalAmount,\r\n        uint256 _newCumulativeWithdrawalAmount,\r\n        address _supplier,\r\n        bytes32 _calculatedRoot\r\n    ) internal view returns (bool) {\r\n        return\r\n            // Only owner or supplier can invoke the fallback withdrawal\r\n            (_operator == owner() || _operator == _supplier) &&\r\n            // Ensure we have entered fallback mode\r\n            (SafeMath.add(fallbackSetDate, fallbackWithdrawalDelaySeconds) <= block.timestamp) &&\r\n            // Check that the maximum allowable withdrawal for the supplier has not been exceeded\r\n            (_newCumulativeWithdrawalAmount <= _maxCumulativeWithdrawalAmount) &&\r\n            // Merkle tree proof is valid\r\n            (fallbackRoot == _calculatedRoot);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Supply Refunds\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Validates refund data\r\n     * @param _partition Source partition of the refund\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the refund authorization data\r\n     * @return true if the refund data is valid, otherwise false\r\n     */\r\n    function _validateRefund(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    ) internal view returns (bool) {\r\n        (uint256 _supplyNonce, Supply memory supply) = _getRefundData(_operatorData);\r\n\r\n        return _verifyRefundData(_partition, _operator, _value, _supplyNonce, supply);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates the refund data and updates state to reflect the transfer\r\n     * @param _partition Source partition of the refund\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _operatorData Contains the refund authorization data\r\n     */\r\n    function _executeRefund(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        bytes memory _operatorData\r\n    ) internal {\r\n        (uint256 nonce, Supply memory supply) = _getRefundData(_operatorData);\r\n\r\n        require(\r\n            _verifyRefundData(_partition, _operator, _value, nonce, supply),\r\n            \"Transfer unauthorized\"\r\n        );\r\n\r\n        delete nonceToSupply[nonce];\r\n\r\n        emit SupplyRefund(supply.supplier, _partition, supply.amount, nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Extracts refund data from the supplied parameters\r\n     * @param _operatorData Contains the refund authorization data, including the refund\r\n     * operation flag and supply nonce.\r\n     * @return supplyNonce, nonce of the recorded supply\r\n     * @return supply, The supplier, partition and amount of tokens in the original supply\r\n     */\r\n    function _getRefundData(bytes memory _operatorData)\r\n        internal\r\n        view\r\n        returns (uint256, Supply memory)\r\n    {\r\n        uint256 _supplyNonce = _decodeRefundOperatorData(_operatorData);\r\n        Supply memory supply = nonceToSupply[_supplyNonce];\r\n\r\n        return (_supplyNonce, supply);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates that the parameters are valid for the requested refund\r\n     * @param _partition Source partition of the tokens\r\n     * @param _operator Address that is executing the refund\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _supplyNonce nonce of the recorded supply\r\n     * @param _supply The supplier, partition and amount of tokens in the original supply\r\n     * @return true if the refund data is valid, otherwise false\r\n     */\r\n    function _verifyRefundData(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        uint256 _value,\r\n        uint256 _supplyNonce,\r\n        Supply memory _supply\r\n    ) internal view returns (bool) {\r\n        return\r\n            // Supply record exists\r\n            (_supply.amount > 0) &&\r\n            // Only owner or supplier can invoke the refund\r\n            (_operator == owner() || _operator == _supply.supplier) &&\r\n            // Requested partition matches the Supply record\r\n            (_partition == _supply.partition) &&\r\n            // Requested value matches the Supply record\r\n            (_value == _supply.amount) &&\r\n            // Ensure we have entered fallback mode\r\n            (SafeMath.add(fallbackSetDate, fallbackWithdrawalDelaySeconds) <= block.timestamp) &&\r\n            // Supply has not already been included in the fallback withdrawal data\r\n            (_supplyNonce > fallbackMaxIncludedSupplyNonce);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Direct Transfers\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Validates direct transfer data\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _value Number of tokens to be transferred\r\n     * @return true if the direct transfer data is valid, otherwise false\r\n     */\r\n    function _validateDirectTransfer(address _operator, uint256 _value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            // Only owner and directTransferer can invoke withdrawals\r\n            (_operator == owner() || _operator == directTransferer) &&\r\n            // Ensure we are within the global withdrawal limit\r\n            (_value <= withdrawalLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates the direct transfer data and updates state to reflect the transfer\r\n     * @param _partition Source partition of the direct transfer\r\n     * @param _operator Address that is invoking the transfer\r\n     * @param _to The target address of the tokens.\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _data Data attached to the transfer. Typically includes partition change information.\r\n     */\r\n    function _executeDirectTransfer(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data\r\n    ) internal {\r\n        require(_validateDirectTransfer(_operator, _value), \"Transfer unauthorized\");\r\n\r\n        withdrawalLimit = SafeMath.sub(withdrawalLimit, _value);\r\n\r\n        bytes32 to_partition = PartitionUtils._getDestinationPartition(_data, _partition);\r\n\r\n        emit DirectTransfer(_operator, _partition, _to, to_partition, _value);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Release Request\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Emits a release request event that can be used to trigger the release of tokens\r\n     * @param _partition Parition from which the tokens should be released\r\n     * @param _amount Number of tokens requested to be released\r\n     * @param _data Metadata to include with the release request\r\n     */\r\n    function requestRelease(\r\n        bytes32 _partition,\r\n        uint256 _amount,\r\n        bytes memory _data\r\n    ) external {\r\n        emit ReleaseRequest(msg.sender, _partition, _amount, _data);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Partition Management\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Adds a partition to the set allowed to receive tokens\r\n     * @param _partition Parition to be permitted for incoming transfers\r\n     */\r\n    function addPartition(bytes32 _partition) external {\r\n        require(msg.sender == owner() || msg.sender == partitionManager, \"Invalid sender\");\r\n        require(partitions[_partition] == false, \"Partition already permitted\");\r\n\r\n        (bytes4 prefix, , address partitionOwner) = PartitionUtils._splitPartition(_partition);\r\n\r\n        require(prefix == PARTITION_PREFIX, \"Invalid partition prefix\");\r\n        require(partitionOwner == address(this), \"Invalid partition owner\");\r\n\r\n        partitions[_partition] = true;\r\n\r\n        emit PartitionAdded(_partition);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a partition from the set allowed to receive tokens\r\n     * @param _partition Parition to be disallowed from incoming transfers\r\n     */\r\n    function removePartition(bytes32 _partition) external {\r\n        require(msg.sender == owner() || msg.sender == partitionManager, \"Invalid sender\");\r\n        require(partitions[_partition], \"Partition not permitted\");\r\n\r\n        delete partitions[_partition];\r\n\r\n        emit PartitionRemoved(_partition);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Withdrawal Management\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Modifies the withdrawal limit by the provided amount.\r\n     * @param _amount Limit delta\r\n     */\r\n    function modifyWithdrawalLimit(int256 _amount) external {\r\n        require(msg.sender == owner() || msg.sender == withdrawalLimitPublisher, \"Invalid sender\");\r\n        uint256 oldLimit = withdrawalLimit;\r\n        if (_amount < 0) {\r\n            uint256 unsignedAmount = uint256(-_amount);\r\n            withdrawalLimit = SafeMath.sub(withdrawalLimit, unsignedAmount);\r\n        } else {\r\n            uint256 unsignedAmount = uint256(_amount);\r\n            withdrawalLimit = SafeMath.add(withdrawalLimit, unsignedAmount);\r\n        }\r\n        emit WithdrawalLimitUpdate(oldLimit, withdrawalLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds the root hash of a Merkle tree containing authorized token withdrawals to the\r\n     * active set\r\n     * @param _root The root hash to be added to the active set\r\n     * @param _nonce The nonce of the new root hash. Must be exactly one higher than the existing\r\n     * max nonce.\r\n     * @param _replacedRoots The root hashes to be removed from the repository.\r\n     */\r\n    function addWithdrawalRoot(\r\n        bytes32 _root,\r\n        uint256 _nonce,\r\n        bytes32[] calldata _replacedRoots\r\n    ) external {\r\n        require(msg.sender == owner() || msg.sender == withdrawalPublisher, \"Invalid sender\");\r\n\r\n        require(_root != 0, \"Invalid root\");\r\n        require(maxWithdrawalRootNonce + 1 == _nonce, \"Nonce not current max plus one\");\r\n        require(withdrawalRootToNonce[_root] == 0, \"Nonce already used\");\r\n\r\n        withdrawalRootToNonce[_root] = _nonce;\r\n        maxWithdrawalRootNonce = _nonce;\r\n\r\n        emit WithdrawalRootHashAddition(_root, _nonce);\r\n\r\n        for (uint256 i = 0; i < _replacedRoots.length; i++) {\r\n            deleteWithdrawalRoot(_replacedRoots[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes withdrawal root hashes from active set\r\n     * @param _roots The root hashes to be removed from the active set\r\n     */\r\n    function removeWithdrawalRoots(bytes32[] calldata _roots) external {\r\n        require(msg.sender == owner() || msg.sender == withdrawalPublisher, \"Invalid sender\");\r\n\r\n        for (uint256 i = 0; i < _roots.length; i++) {\r\n            deleteWithdrawalRoot(_roots[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a withdrawal root hash from active set\r\n     * @param _root The root hash to be removed from the active set\r\n     */\r\n    function deleteWithdrawalRoot(bytes32 _root) private {\r\n        uint256 nonce = withdrawalRootToNonce[_root];\r\n\r\n        require(nonce > 0, \"Root not found\");\r\n\r\n        delete withdrawalRootToNonce[_root];\r\n\r\n        emit WithdrawalRootHashRemoval(_root, nonce);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Fallback Management\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Sets the root hash of the Merkle tree containing fallback\r\n     * withdrawal authorizations.\r\n     * @param _root The root hash of a Merkle tree containing the fallback withdrawal\r\n     * authorizations\r\n     * @param _maxSupplyNonce The nonce of the latest supply whose value is reflected in the\r\n     * fallback withdrawal authorizations.\r\n     */\r\n    function setFallbackRoot(bytes32 _root, uint256 _maxSupplyNonce) external {\r\n        require(msg.sender == owner() || msg.sender == fallbackPublisher, \"Invalid sender\");\r\n        require(_root != 0, \"Invalid root\");\r\n        require(\r\n            SafeMath.add(fallbackSetDate, fallbackWithdrawalDelaySeconds) > block.timestamp,\r\n            \"Fallback is active\"\r\n        );\r\n        require(\r\n            _maxSupplyNonce >= fallbackMaxIncludedSupplyNonce,\r\n            \"Included supply nonce decreased\"\r\n        );\r\n        require(_maxSupplyNonce <= supplyNonce, \"Included supply nonce exceeds latest supply\");\r\n\r\n        fallbackRoot = _root;\r\n        fallbackMaxIncludedSupplyNonce = _maxSupplyNonce;\r\n        fallbackSetDate = block.timestamp;\r\n\r\n        emit FallbackRootHashSet(_root, fallbackMaxIncludedSupplyNonce, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the fallback set date to the current block's timestamp. This can be used to\r\n     * delay the start of the fallback period without publishing a new root, or to deactivate the\r\n     * fallback mechanism so a new fallback root may be published.\r\n     */\r\n    function resetFallbackMechanismDate() external {\r\n        require(msg.sender == owner() || msg.sender == fallbackPublisher, \"Invalid sender\");\r\n        fallbackSetDate = block.timestamp;\r\n\r\n        emit FallbackMechanismDateReset(fallbackSetDate);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the time-lock period before the fallback mechanism is activated after the\r\n     * last fallback root was published.\r\n     * @param _newFallbackDelaySeconds The new delay period in seconds\r\n     */\r\n    function setFallbackWithdrawalDelay(uint256 _newFallbackDelaySeconds) external {\r\n        require(msg.sender == owner(), \"Invalid sender\");\r\n        require(_newFallbackDelaySeconds != 0, \"Invalid zero delay seconds\");\r\n        require(_newFallbackDelaySeconds < 10 * 365 days, \"Invalid delay over 10 years\");\r\n\r\n        uint256 oldDelay = fallbackWithdrawalDelaySeconds;\r\n        fallbackWithdrawalDelaySeconds = _newFallbackDelaySeconds;\r\n\r\n        emit FallbackWithdrawalDelayUpdate(oldDelay, _newFallbackDelaySeconds);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Role Management\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Updates the Withdrawal Publisher address, the only address other than the owner that\r\n     * can publish / remove withdrawal Merkle tree roots.\r\n     * @param _newWithdrawalPublisher The address of the new Withdrawal Publisher\r\n     * @dev Error invalid sender.\r\n     */\r\n    function setWithdrawalPublisher(address _newWithdrawalPublisher) external {\r\n        require(msg.sender == owner(), \"Invalid sender\");\r\n\r\n        address oldValue = withdrawalPublisher;\r\n        withdrawalPublisher = _newWithdrawalPublisher;\r\n\r\n        emit WithdrawalPublisherUpdate(oldValue, withdrawalPublisher);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Fallback Publisher address, the only address other than the owner that\r\n     * can publish / remove fallback withdrawal Merkle tree roots.\r\n     * @param _newFallbackPublisher The address of the new Fallback Publisher\r\n     * @dev Error invalid sender.\r\n     */\r\n    function setFallbackPublisher(address _newFallbackPublisher) external {\r\n        require(msg.sender == owner(), \"Invalid sender\");\r\n\r\n        address oldValue = fallbackPublisher;\r\n        fallbackPublisher = _newFallbackPublisher;\r\n\r\n        emit FallbackPublisherUpdate(oldValue, fallbackPublisher);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Withdrawal Limit Publisher address, the only address other than the\r\n     * owner that can set the withdrawal limit.\r\n     * @param _newWithdrawalLimitPublisher The address of the new Withdrawal Limit Publisher\r\n     * @dev Error invalid sender.\r\n     */\r\n    function setWithdrawalLimitPublisher(address _newWithdrawalLimitPublisher) external {\r\n        require(msg.sender == owner(), \"Invalid sender\");\r\n\r\n        address oldValue = withdrawalLimitPublisher;\r\n        withdrawalLimitPublisher = _newWithdrawalLimitPublisher;\r\n\r\n        emit WithdrawalLimitPublisherUpdate(oldValue, withdrawalLimitPublisher);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the DirectTransferer address, the only address other than the owner that\r\n     * can execute direct transfers\r\n     * @param _newDirectTransferer The address of the new DirectTransferer\r\n     */\r\n    function setDirectTransferer(address _newDirectTransferer) external {\r\n        require(msg.sender == owner(), \"Invalid sender\");\r\n\r\n        address oldValue = directTransferer;\r\n        directTransferer = _newDirectTransferer;\r\n\r\n        emit DirectTransfererUpdate(oldValue, directTransferer);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Partition Manager address, the only address other than the owner that\r\n     * can add and remove permitted partitions\r\n     * @param _newPartitionManager The address of the new PartitionManager\r\n     */\r\n    function setPartitionManager(address _newPartitionManager) external {\r\n        require(msg.sender == owner(), \"Invalid sender\");\r\n\r\n        address oldValue = partitionManager;\r\n        partitionManager = _newPartitionManager;\r\n\r\n        emit PartitionManagerUpdate(oldValue, partitionManager);\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Operator Data Decoders\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Extract flag from operatorData\r\n     * @param _operatorData The operator data to be decoded\r\n     * @return flag, the transfer operation type\r\n     */\r\n    function _decodeOperatorDataFlag(bytes memory _operatorData) internal pure returns (bytes32) {\r\n        return abi.decode(_operatorData, (bytes32));\r\n    }\r\n\r\n    /**\r\n     * @notice Extracts the supplier, max authorized nonce, and Merkle proof from the operator data\r\n     * @param _operatorData The operator data to be decoded\r\n     * @return supplier, the address whose account is authorized\r\n     * @return For withdrawals: max authorized nonce, the last used withdrawal root nonce for the\r\n     * supplier and partition. For fallback withdrawals: max cumulative withdrawal amount, the\r\n     * maximum amount of tokens that can be withdrawn for the supplier's account, including both\r\n     * withdrawals and fallback withdrawals\r\n     * @return proof, the Merkle proof to be used for the authorization\r\n     */\r\n    function _decodeWithdrawalOperatorData(bytes memory _operatorData)\r\n        internal\r\n        pure\r\n        returns (\r\n            address,\r\n            uint256,\r\n            bytes32[] memory\r\n        )\r\n    {\r\n        (, address supplier, uint256 nonce, bytes32[] memory proof) = abi.decode(\r\n            _operatorData,\r\n            (bytes32, address, uint256, bytes32[])\r\n        );\r\n\r\n        return (supplier, nonce, proof);\r\n    }\r\n\r\n    /**\r\n     * @notice Extracts the supply nonce from the operator data\r\n     * @param _operatorData The operator data to be decoded\r\n     * @return nonce, the nonce of the supply to be refunded\r\n     */\r\n    function _decodeRefundOperatorData(bytes memory _operatorData) internal pure returns (uint256) {\r\n        (, uint256 nonce) = abi.decode(_operatorData, (bytes32, uint256));\r\n\r\n        return nonce;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n     * Merkle Tree Verification\r\n     *********************************************************************************************/\r\n\r\n    /**\r\n     * @notice Hashes the supplied data and returns the hash to be used in conjunction with a proof\r\n     * to calculate the Merkle tree root\r\n     * @param _supplier The address whose account is authorized\r\n     * @param _partition Source partition of the tokens\r\n     * @param _value Number of tokens to be transferred\r\n     * @param _maxAuthorizedAccountNonce The maximum existing used withdrawal nonce for the\r\n     * supplier and partition\r\n     * @return leaf, the hash of the supplied data\r\n     */\r\n    function _calculateWithdrawalLeaf(\r\n        address _supplier,\r\n        bytes32 _partition,\r\n        uint256 _value,\r\n        uint256 _maxAuthorizedAccountNonce\r\n    ) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(abi.encodePacked(_supplier, _partition, _value, _maxAuthorizedAccountNonce));\r\n    }\r\n\r\n    /**\r\n     * @notice Hashes the supplied data and returns the hash to be used in conjunction with a proof\r\n     * to calculate the Merkle tree root\r\n     * @param _supplier The address whose account is authorized\r\n     * @param _partition Source partition of the tokens\r\n     * @param _maxCumulativeWithdrawalAmount, the maximum amount of tokens that can be withdrawn\r\n     * for the supplier's account, including both withdrawals and fallback withdrawals\r\n     * @return leaf, the hash of the supplied data\r\n     */\r\n    function _calculateFallbackLeaf(\r\n        address _supplier,\r\n        bytes32 _partition,\r\n        uint256 _maxCumulativeWithdrawalAmount\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_supplier, _partition, _maxCumulativeWithdrawalAmount));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the Merkle root for the unique Merkle tree described by the provided\r\n       Merkle proof and leaf hash.\r\n     * @param _merkleProof The sibling node hashes at each level of the tree.\r\n     * @param _leafHash The hash of the leaf data for which merkleProof is an inclusion proof.\r\n     * @return The calculated Merkle root.\r\n     */\r\n    function _calculateMerkleRoot(bytes32[] memory _merkleProof, bytes32 _leafHash)\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        bytes32 computedHash = _leafHash;\r\n\r\n        for (uint256 i = 0; i < _merkleProof.length; i++) {\r\n            bytes32 proofElement = _merkleProof[i];\r\n\r\n            if (computedHash < proofElement) {\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        return computedHash;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_amp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"from_partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"to_partition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DirectTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"DirectTransfererUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"FallbackMechanismDateReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"FallbackPublisherUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxSupplyNonceIncluded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setDate\",\"type\":\"uint256\"}],\"name\":\"FallbackRootHashSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FallbackWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"FallbackWithdrawalDelayUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"OwnershipTransferAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"PartitionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"PartitionManagerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"PartitionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ReleaseRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"SupplyReceipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"SupplyRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rootNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"authorizedAccountNonce\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"WithdrawalLimitPublisherUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"WithdrawalLimitUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"WithdrawalPublisherUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRootHashAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRootHashRemoval\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"}],\"name\":\"addPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_replacedRoots\",\"type\":\"bytes32[]\"}],\"name\":\"addWithdrawalRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToCumulativeAmountWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToWithdrawalNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assumeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizedAddress\",\"type\":\"address\"}],\"name\":\"authorizeOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorizedNewOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"canReceive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"canTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"directTransferer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackMaxIncludedSupplyNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackPublisher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackSetDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackWithdrawalDelaySeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWithdrawalRootNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_amount\",\"type\":\"int256\"}],\"name\":\"modifyWithdrawalLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceToSupply\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partitionManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"partitions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"}],\"name\":\"removePartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_roots\",\"type\":\"bytes32[]\"}],\"name\":\"removeWithdrawalRoots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"requestRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetFallbackMechanismDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDirectTransferer\",\"type\":\"address\"}],\"name\":\"setDirectTransferer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFallbackPublisher\",\"type\":\"address\"}],\"name\":\"setFallbackPublisher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupplyNonce\",\"type\":\"uint256\"}],\"name\":\"setFallbackRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFallbackDelaySeconds\",\"type\":\"uint256\"}],\"name\":\"setFallbackWithdrawalDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPartitionManager\",\"type\":\"address\"}],\"name\":\"setPartitionManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWithdrawalLimitPublisher\",\"type\":\"address\"}],\"name\":\"setWithdrawalLimitPublisher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWithdrawalPublisher\",\"type\":\"address\"}],\"name\":\"setWithdrawalPublisher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"tokensToTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalLimitPublisher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalPublisher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawalRootToNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FlexaCollateralManager","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ff20817765cb7f73d4bde2e66e067e58d11095c2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7434a8a187fdf6b2bb9d572324a4795d279acd4909615e386e4190bcb0fe3e07"}]}