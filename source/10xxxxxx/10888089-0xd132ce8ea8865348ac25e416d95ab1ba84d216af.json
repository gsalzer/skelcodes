{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function owner() external view returns (address);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISushiSwapPoolNames {\n    function logos(uint256) external view returns(string memory);\n    function names(uint256) external view returns(string memory);\n    function setPoolInfo(uint256 pid, string memory logo, string memory name) external;\n}\n\ninterface ISushiToken is IERC20{\n    function delegates(address who) external view returns(address);\n    function getCurrentVotes(address who) external view returns(uint256);\n    function nonces(address who) external view returns(uint256);\n}\n\ninterface IMasterChef {\n    function BONUS_MULTIPLIER() external view returns (uint256);\n    function bonusEndBlock() external view returns (uint256);\n    function devaddr() external view returns (address);\n    function migrator() external view returns (address);\n    function owner() external view returns (address);\n    function startBlock() external view returns (uint256);\n    function sushi() external view returns (address);\n    function sushiPerBlock() external view returns (uint256);\n    function totalAllocPoint() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function poolInfo(uint256 nr) external view returns (address, uint256, uint256, uint256);\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\n}\n\ninterface IFactory {\n    function allPairsLength() external view returns (uint256);\n    function allPairs(uint256 i) external view returns (address);\n    function getPair(address token0, address token1) external view returns (address);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n}\n\ninterface IPair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112, uint112, uint32);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); uint256 c = a - b; return c; }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; }\n}\n\ncontract Ownable {\n    address public owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = msg.sender;\n        owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n\ncontract BoringCryptoTokenScanner\n{\n    using SafeMath for uint256;\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n    \n    struct BalanceFull {\n        address token;\n        uint256 balance;\n        uint256 rate;\n    }\n    \n    struct TokenInfo {\n        address token;\n        uint256 decimals;\n        string name;\n        string symbol;\n    }\n\n    function getTokenInfo(address[] calldata addresses) public view returns(TokenInfo[] memory) {\n        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            infos[i].token = address(token);\n            \n            infos[i].name = token.name();\n            infos[i].symbol = token.symbol();\n            infos[i].decimals = token.decimals();\n        }\n\n        return infos;\n    }\n\n    function findBalances(address who, address[] calldata addresses) public view returns(Balance[] memory) {\n        uint256 balanceCount;\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (IERC20(addresses[i]).balanceOf(who) > 0) {\n                balanceCount++;\n            }\n        }\n\n        Balance[] memory balances = new Balance[](balanceCount);\n\n        balanceCount = 0;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            uint256 balance = token.balanceOf(who);\n            if (balance > 0) {\n                balances[balanceCount].token = address(token);\n                balances[balanceCount].balance = token.balanceOf(who);\n                balanceCount++;\n            }\n        }\n\n        return balances;\n    }\n    \n    function getBalances(address who, address[] calldata addresses, IFactory factory, address currency) public view returns(BalanceFull[] memory) {\n        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            balances[i].token = address(token);\n            balances[i].balance = token.balanceOf(who);\n\n            IPair pair = IPair(factory.getPair(addresses[i], currency));\n            if(address(pair) != address(0))\n            {\n                uint256 reserveCurrency;\n                uint256 reserveToken;\n                if (pair.token0() == currency) {\n                    (reserveCurrency, reserveToken,) = pair.getReserves();\n                }\n                else\n                {\n                    (reserveToken, reserveCurrency,) = pair.getReserves();\n                }\n                balances[i].rate = reserveToken * 1e18 / reserveCurrency;\n            }\n        }\n\n        return balances;\n    }\n\n    struct Factory {\n        IFactory factory;\n        uint256 allPairsLength;\n        address feeTo;\n        address feeToSetter;\n    }\n    \n    function getFactoryInfo(IFactory[] calldata addresses) public view returns(Factory[] memory) {\n        Factory[] memory factories = new Factory[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IFactory factory = addresses[i];\n            factories[i].factory = factory;\n            \n            factories[i].allPairsLength = factory.allPairsLength();\n            factories[i].feeTo = factory.feeTo();\n            factories[i].feeToSetter = factory.feeToSetter();\n        }\n\n        return factories;\n    }\n\n    struct Pair {\n        address token;\n        address token0;\n        address token1;\n    }\n    \n    function getPairs(IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\n        if (toID == 0){\n            toID = factory.allPairsLength();\n        }\n        \n        Pair[] memory pairs = new Pair[](toID - fromID);\n\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            uint256 i = id - fromID;\n            pairs[i].token = token;\n            pairs[i].token0 = IPair(token).token0();\n            pairs[i].token1 = IPair(token).token1();\n        }\n        return pairs;\n    }\n\n    function findPairs(address who, IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\n        if (toID == 0){\n            toID = factory.allPairsLength();\n        }\n        \n        uint256 pairCount;\n\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            if (IERC20(token).balanceOf(who) > 0) {\n                pairCount++;\n            }\n        }\n\n        Pair[] memory pairs = new Pair[](pairCount);\n\n        pairCount = 0;\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            uint256 balance = IERC20(token).balanceOf(who);\n            if (balance > 0) {\n                pairs[pairCount].token = token;\n                pairs[pairCount].token0 = IPair(token).token0();\n                pairs[pairCount].token1 = IPair(token).token1();\n                pairCount++;\n            }\n        }\n\n        return pairs;\n    }\n\n    struct PairFull {\n        address token;\n        address token0;\n        address token1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n        uint256 balance;\n    }\n\n    function getPairsFull(address who, address[] calldata addresses) public view returns(PairFull[] memory) {\n        PairFull[] memory pairs = new PairFull[](addresses.length);\n        for (uint256 i = 0; i < addresses.length; i++) {\n            address token = addresses[i];\n            pairs[i].token = token;\n            pairs[i].token0 = IPair(token).token0();\n            pairs[i].token1 = IPair(token).token1();\n            (uint256 reserve0, uint256 reserve1,) = IPair(token).getReserves();\n            pairs[i].reserve0 = reserve0;\n            pairs[i].reserve1 = reserve1;\n            pairs[i].balance = IERC20(token).balanceOf(who);\n        }\n        return pairs;\n    }\n}\n\n\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"findBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoTokenScanner.Balance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toID\",\"type\":\"uint256\"}],\"name\":\"findPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct BoringCryptoTokenScanner.Pair[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"getBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoTokenScanner.BalanceFull[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFactory[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getFactoryInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allPairsLength\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToSetter\",\"type\":\"address\"}],\"internalType\":\"struct BoringCryptoTokenScanner.Factory[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toID\",\"type\":\"uint256\"}],\"name\":\"getPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct BoringCryptoTokenScanner.Pair[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getPairsFull\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoTokenScanner.PairFull[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct BoringCryptoTokenScanner.TokenInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BoringCryptoTokenScanner","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}