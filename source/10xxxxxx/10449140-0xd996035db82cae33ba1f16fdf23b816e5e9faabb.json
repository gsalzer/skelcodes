{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract TradeEngine {\r\n    function balanceOf(address, address) public view returns (uint256) {}\r\n\r\n    function orderBNS(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        address\r\n    ) public returns (bool) {}\r\n\r\n    function deductFee(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) public returns (bool) {}\r\n}\r\n\r\ncontract Token {\r\n    function tokenBalanceOf(address, address) public view returns (uint256) {}\r\n\r\n    function balanceOf(address) public view returns (uint256) {}\r\n\r\n    function transfer(address, uint256) public returns (bool) {}\r\n\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) public returns (bool) {}\r\n\r\n    function frozenBalanceOf(address) public returns (uint256) {}\r\n\r\n    function issueMulti(\r\n        address[],\r\n        uint256[],\r\n        uint256,\r\n        uint256\r\n    ) public returns (bool) {}\r\n\r\n    function lockTime(address) public view returns (uint256) {}\r\n\r\n    function subscribe(\r\n        address,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) public returns (uint256) {}\r\n\r\n    function charge(uint256) public returns (bool) {}\r\n\r\n    function subscribeToSpp(\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        address,\r\n        address\r\n    ) public returns (uint256) {}\r\n\r\n    function closeSpp(uint256) public returns (bool) {}\r\n\r\n    function getSppIdFromHash(bytes32) public returns (uint256) {}\r\n\r\n    function setLastPaidAt(bytes32) public returns (bool) {}\r\n\r\n    function setRemainingToBeFulfilled(bytes32, uint256)\r\n        public\r\n        returns (bool)\r\n    {}\r\n\r\n    function getRemainingToBeFulfilledByHash(bytes32)\r\n        public\r\n        returns (uint256)\r\n    {}\r\n\r\n    function getlistOfSubscriptions(address) public view returns (uint256[]) {}\r\n\r\n    function getlistOfSppSubscriptions(address)\r\n        public\r\n        view\r\n        returns (uint256[])\r\n    {}\r\n\r\n    function getcurrentTokenAmounts(uint256)\r\n        public\r\n        view\r\n        returns (uint256[2] memory)\r\n    {}\r\n\r\n    function getTokenStats(uint256) public view returns (address[2] memory) {}\r\n\r\n    function setcurrentTokenStats(\r\n        bytes32,\r\n        uint256,\r\n        uint256\r\n    ) public returns (bool) {}\r\n\r\n    function getRemainingToBeFulfilledBySppID(uint256)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {}\r\n}\r\n\r\ncontract BNSToken is Token {\r\n    using SafeMath for uint256;\r\n\r\n    event Subscribe(\r\n        uint256 indexed orderId,\r\n        address indexed merchantAddress,\r\n        address indexed customerAddress,\r\n        address token,\r\n        uint256 value,\r\n        uint256 period\r\n    );\r\n    event Charge(uint256 orderId);\r\n    event SubscribeToSpp(\r\n        uint256 indexed sppID,\r\n        address indexed customerAddress,\r\n        uint256 value,\r\n        uint256 period,\r\n        address indexed tokenGet,\r\n        address tokenGive\r\n    );\r\n    event ChargeSpp(uint256 sppID, uint256 expires, uint256 nonce);\r\n    event Deposit(\r\n        address indexed token,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 balance\r\n    );\r\n    event Withdraw(\r\n        address indexed token,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 balance\r\n    );\r\n    event CloseSpp(uint256 sppID);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Mint(string hash, address indexed account, uint256 value);\r\n    event SetCurrentTokenStats(\r\n        uint256 indexed sppID,\r\n        uint256 amountGotten,\r\n        uint256 amountGiven\r\n    );\r\n\r\n    modifier _ownerOnly() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier _tradeEngineOnly() {\r\n        require(msg.sender == TradeEngineAddress);\r\n        _;\r\n    }\r\n\r\n    bool public scLock = false;\r\n\r\n    modifier _ifNotLocked() {\r\n        require(scLock == false);\r\n        _;\r\n    }\r\n\r\n    function setLock() public _ownerOnly {\r\n        scLock = !scLock;\r\n    }\r\n\r\n    function changeOwner(address owner_) public _ownerOnly {\r\n        potentialAdmin = owner_;\r\n    }\r\n\r\n    function becomeOwner() public {\r\n        if (potentialAdmin == msg.sender) owner = msg.sender;\r\n    }\r\n\r\n    function mint(\r\n        string hash,\r\n        address account,\r\n        uint256 value\r\n    ) public _ownerOnly {\r\n        require(account != address(0));\r\n        require(\r\n            SafeMath.add(totalSupply, value) <= totalPossibleSupply,\r\n            \"totalSupply can't be more than the totalPossibleSupply\"\r\n        );\r\n        totalSupply = SafeMath.add(totalSupply, value);\r\n        balances[account] = SafeMath.add(balances[account], value);\r\n        emit Mint(hash, account, value);\r\n    }\r\n\r\n    function burn(uint256 value) public _ownerOnly {\r\n        totalSupply = totalSupply.sub(value);\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        emit Transfer(msg.sender, address(0), value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        if (\r\n            balances[msg.sender] >= _value &&\r\n            _value >= 0 &&\r\n            userdata[msg.sender].exists == false\r\n        ) {\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function issueMulti(\r\n        address[] _to,\r\n        uint256[] _value,\r\n        uint256 ldays,\r\n        uint256 period\r\n    ) public _ownerOnly returns (bool success) {\r\n        require(_value.length <= 20, \"too long array\");\r\n        require(_value.length == _to.length, \"array size misatch\");\r\n        uint256 sum = 0;\r\n        userstats memory _oldData;\r\n        uint256 _oldFrozen = 0;\r\n        for (uint256 i = 0; i < _value.length; i++) {\r\n            sum = sum.add(_value[i]);\r\n        }\r\n        if (balances[msg.sender] >= sum && sum > 0) {\r\n            balances[msg.sender] = balances[msg.sender].sub(sum);\r\n            for (uint256 j = 0; j < _to.length; j++) {\r\n                balances[_to[j]] = balances[_to[j]].add(_value[j]);\r\n                _oldData = userdata[_to[j]];\r\n                _oldFrozen = _oldData.frozen_balance;\r\n\r\n                userdata[_to[j]] = userstats({\r\n                    exists: true,\r\n                    frozen_balance: _oldFrozen.add(_value[j]),\r\n                    lock_till: now.add((ldays.mul(86400))),\r\n                    time_period: (period.mul(86400)),\r\n                    per_tp_release_amt: SafeMath.div(\r\n                        SafeMath.add(_value[j], _oldFrozen),\r\n                        (ldays.div(period))\r\n                    )\r\n                });\r\n                emit Transfer(msg.sender, _to[j], _value[j]);\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool success) {\r\n        if (\r\n            balances[_from] >= _value &&\r\n            _value >= 0 &&\r\n            (allowed[_from][msg.sender] >= _value || _from == msg.sender)\r\n        ) {\r\n            userstats memory _userData = userdata[_from];\r\n\r\n            if (_userData.exists == false) {\r\n                _transfer(_from, _to, _value);\r\n                return true;\r\n            }\r\n\r\n            uint256 lock = _userData.lock_till;\r\n\r\n            if (now >= lock) {\r\n                _userData.frozen_balance = 0;\r\n                _userData.exists = false;\r\n                userdata[_from] = _userData;\r\n                _transfer(_from, _to, _value);\r\n                return true;\r\n            }\r\n\r\n            uint256 a = (lock - now);\r\n            uint256 b = _userData.time_period;\r\n            uint256 should_be_frozen = SafeMath.mul(\r\n                (SafeMath.div(a, b) + 1),\r\n                _userData.per_tp_release_amt\r\n            );\r\n\r\n            if (_userData.frozen_balance > should_be_frozen) {\r\n                _userData.frozen_balance = should_be_frozen;\r\n                userdata[_from] = _userData;\r\n            }\r\n\r\n            if (balances[_from].sub(_value) >= _userData.frozen_balance) {\r\n                _transfer(_from, _to, _value);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        balances[_to] = balances[_to].add(_value);\r\n        if (_from != msg.sender)\r\n            allowed[_from][msg.sender] = SafeMath.sub(\r\n                allowed[_from][msg.sender],\r\n                _value\r\n            );\r\n        balances[_from] = balances[_from].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function balanceOf(address _from) public view returns (uint256 balance) {\r\n        return balances[_from];\r\n    }\r\n\r\n    function frozenBalanceOf(address _from) public returns (uint256 balance) {\r\n        userstats memory _userData = userdata[_from];\r\n        if (_userData.exists == false) return;\r\n\r\n        uint256 lock = _userData.lock_till;\r\n\r\n        if (now >= lock) {\r\n            _userData.frozen_balance = 0;\r\n            _userData.exists = false;\r\n            userdata[_from] = _userData;\r\n            return 0;\r\n        }\r\n\r\n        uint256 a = (lock - now);\r\n        uint256 b = _userData.time_period;\r\n        uint256 should_be_frozen = SafeMath.mul(\r\n            (SafeMath.div(a, b) + 1),\r\n            _userData.per_tp_release_amt\r\n        );\r\n\r\n        if (_userData.frozen_balance > should_be_frozen) {\r\n            _userData.frozen_balance = should_be_frozen;\r\n            userdata[_from] = _userData;\r\n        }\r\n\r\n        return _userData.frozen_balance;\r\n    }\r\n\r\n    function lockTime(address _from) public view returns (uint256 time) {\r\n        if (userdata[_from].exists == false) revert();\r\n        return userdata[_from].lock_till;\r\n    }\r\n\r\n    function deposit() public payable {\r\n        tokens[0][msg.sender] = SafeMath.add(tokens[0][msg.sender], msg.value);\r\n        emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public {\r\n        if (tokens[0][msg.sender] < amount) revert();\r\n        tokens[0][msg.sender] = SafeMath.sub(tokens[0][msg.sender], amount);\r\n        if (!msg.sender.call.value(amount)()) revert();\r\n        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n    }\r\n\r\n    function depositToken(address token, uint256 amount) public {\r\n        //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n        if (token == 0) revert();\r\n        if (!Token(token).transferFrom(msg.sender, this, amount)) revert();\r\n        tokens[token][msg.sender] = SafeMath.add(\r\n            tokens[token][msg.sender],\r\n            amount\r\n        );\r\n        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n    }\r\n\r\n    function withdrawToken(address token, uint256 amount) public {\r\n        if (token == 0) revert();\r\n        if (tokens[token][msg.sender] < amount) revert();\r\n        tokens[token][msg.sender] = SafeMath.sub(\r\n            tokens[token][msg.sender],\r\n            amount\r\n        );\r\n        if (!Token(token).transfer(msg.sender, amount)) revert();\r\n        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n    }\r\n\r\n    function tokenBalanceOf(address token, address user)\r\n        public\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        return tokens[token][user];\r\n    }\r\n\r\n    function subscribe(\r\n        address merchantAddress,\r\n        address customerAddress,\r\n        address token,\r\n        uint256 value,\r\n        uint256 period\r\n    ) public _ifNotLocked returns (uint256 oID) {\r\n        if (customerAddress != msg.sender || period < minPeriod) {\r\n            return 0;\r\n        }\r\n        if (tokens[token][msg.sender] >= value && value > 0) {\r\n            orderId += 1;\r\n            subscriptiondata[orderId] = subscriptionstats({\r\n                exists: true,\r\n                value: value,\r\n                period: period,\r\n                lastPaidAt: now.sub(period),\r\n                merchantAddress: merchantAddress,\r\n                customerAddress: customerAddress,\r\n                tokenType: token\r\n            });\r\n            subList[customerAddress].arr.push(orderId);\r\n            emit Subscribe(\r\n                orderId,\r\n                merchantAddress,\r\n                customerAddress,\r\n                token,\r\n                value,\r\n                period\r\n            );\r\n            return orderId;\r\n        }\r\n    }\r\n\r\n    function charge(uint256 orderId)\r\n        public\r\n        _ifNotLocked\r\n        returns (bool success)\r\n    {\r\n        subscriptionstats memory _orderData = subscriptiondata[orderId];\r\n        require(\r\n            _orderData.exists == true,\r\n            \"This subscription does not exist, wrong orderId\"\r\n        );\r\n        require(\r\n            _orderData.merchantAddress == msg.sender,\r\n            \"You are not the real merchant\"\r\n        );\r\n        require(\r\n            (_orderData.lastPaidAt).add(_orderData.period) <= now,\r\n            \"charged too early\"\r\n        );\r\n        address token = _orderData.tokenType;\r\n        tokens[token][_orderData.customerAddress] = tokens[token][_orderData\r\n            .customerAddress]\r\n            .sub(_orderData.value);\r\n        uint256 fee = ((_orderData.value).mul(25)).div(10000);\r\n        tokens[token][feeAccount] = SafeMath.add(\r\n            tokens[token][feeAccount],\r\n            fee\r\n        );\r\n        tokens[token][_orderData.merchantAddress] = tokens[token][_orderData\r\n            .merchantAddress]\r\n            .add((_orderData.value.sub(fee)));\r\n        _orderData.lastPaidAt = SafeMath.add(\r\n            _orderData.lastPaidAt,\r\n            _orderData.period\r\n        );\r\n        subscriptiondata[orderId] = _orderData;\r\n        emit Charge(orderId);\r\n        return true;\r\n    }\r\n\r\n    function closeSubscription(uint256 orderId) public returns (bool success) {\r\n        subscriptionstats memory _orderData = subscriptiondata[orderId];\r\n        require(\r\n            _orderData.exists == true,\r\n            \"This subscription does not exist, wrong orderId OR already closed\"\r\n        );\r\n        require(\r\n            _orderData.customerAddress == msg.sender,\r\n            \"You are not the customer of this orderId\"\r\n        );\r\n        subscriptiondata[orderId].exists = false;\r\n        return true;\r\n    }\r\n\r\n    function subscribeToSpp(\r\n        address customerAddress,\r\n        uint256 value,\r\n        uint256 period,\r\n        address tokenGet,\r\n        address tokenGive\r\n    ) public _ifNotLocked returns (uint256 sID) {\r\n        if (customerAddress != msg.sender || period < 86400) {\r\n            return 0;\r\n        }\r\n        if (\r\n            TradeEngine(TradeEngineAddress).balanceOf(\r\n                tokenGive,\r\n                customerAddress\r\n            ) >= value\r\n        ) {\r\n            require(\r\n                TradeEngine(TradeEngineAddress).deductFee(\r\n                    customerAddress,\r\n                    usdt,\r\n                    uint256(2 * (10**usdtDecimal))\r\n                ),\r\n                \"fee not able to charge\"\r\n            );\r\n            sppID += 1;\r\n            sppSubscriptionStats[sppID] = sppSubscribers({\r\n                exists: true,\r\n                customerAddress: customerAddress,\r\n                tokenGet: tokenGet,\r\n                tokenGive: tokenGive,\r\n                value: value,\r\n                remainingToBeFulfilled: value,\r\n                period: period,\r\n                lastPaidAt: now - period\r\n            });\r\n            tokenStats[sppID] = currentTokenStats({\r\n                TokenToGet: tokenGet,\r\n                TokenToGive: tokenGive,\r\n                amountGotten: 0,\r\n                amountGiven: 0\r\n            });\r\n            sppSubList[customerAddress].arr.push(sppID);\r\n            emit SubscribeToSpp(\r\n                sppID,\r\n                customerAddress,\r\n                value,\r\n                period,\r\n                tokenGet,\r\n                tokenGive\r\n            );\r\n            return sppID;\r\n        }\r\n    }\r\n\r\n    function chargeSpp(\r\n        uint256 sppID,\r\n        uint256 amountGet,\r\n        uint256 amountGive,\r\n        uint256 expires\r\n    ) public _ownerOnly _ifNotLocked {\r\n        sppSubscribers memory _subscriptionData = sppSubscriptionStats[sppID];\r\n        require(\r\n            amountGive == _subscriptionData.remainingToBeFulfilled,\r\n            \"check\"\r\n        );\r\n        require(\r\n            onGoing[sppID] < block.number,\r\n            \"chargeSpp is already onGoing for this sppId\"\r\n        );\r\n        require(\r\n            _subscriptionData.exists == true,\r\n            \"This SPP does not exist, wrong SPP ID\"\r\n        );\r\n        require(\r\n            (_subscriptionData.lastPaidAt).add(_subscriptionData.period) <= now,\r\n            \"Charged too early\"\r\n        );\r\n        require(\r\n            TradeEngine(TradeEngineAddress).deductFee(\r\n                _subscriptionData.customerAddress,\r\n                usdt,\r\n                uint256(15 * rateEthUsdt/1000)\r\n            ),\r\n            \"fee unable to charge\"\r\n        ); // need to multiply with 10^8??\r\n        nonce += 1;\r\n        bytes32 hash = sha256(\r\n            abi.encodePacked(\r\n                TradeEngineAddress,\r\n                _subscriptionData.tokenGet,\r\n                amountGet,\r\n                _subscriptionData.tokenGive,\r\n                amountGive,\r\n                block.number + expires,\r\n                nonce\r\n            )\r\n        );\r\n        hash2sppId[hash] = sppID;\r\n        onGoing[sppID] = block.number + expires;\r\n        TradeEngine(TradeEngineAddress).orderBNS(\r\n            _subscriptionData.tokenGet,\r\n            amountGet,\r\n            _subscriptionData.tokenGive,\r\n            amountGive,\r\n            block.number + expires,\r\n            nonce,\r\n            _subscriptionData.customerAddress\r\n        );\r\n        emit ChargeSpp(sppID, (block.number + expires), nonce);\r\n    }\r\n\r\n    function closeSpp(uint256 sppID) public returns (bool success) {\r\n        if (msg.sender != sppSubscriptionStats[sppID].customerAddress)\r\n            return false;\r\n        sppSubscriptionStats[sppID].exists = false;\r\n        emit CloseSpp(sppID);\r\n        return true;\r\n    }\r\n\r\n    function setrateEthUsdt(uint256 _value) public _ownerOnly {\r\n        rateEthUsdt = _value;\r\n    }\r\n\r\n    function setAddresses(address usdt1, address feeAccount1)\r\n        public\r\n        _ownerOnly\r\n    {\r\n        usdt = usdt1;\r\n        feeAccount = feeAccount1;\r\n    }\r\n\r\n    function setUsdtDecimal(uint256 decimal) public _ownerOnly {\r\n        usdtDecimal = decimal;\r\n    }\r\n\r\n    function setMinPeriod(uint256 p) public _ownerOnly {\r\n        minPeriod = p;\r\n    }\r\n\r\n    function setTradeEngineAddress(address _add) public _ownerOnly {\r\n        TradeEngineAddress = _add;\r\n    }\r\n\r\n    function setLastPaidAt(bytes32 hash) public returns (bool success) {\r\n        if (msg.sender != TradeEngineAddress) return false;\r\n        uint256 sppID = hash2sppId[hash];\r\n        sppSubscribers memory _subscriptionData = sppSubscriptionStats[sppID];\r\n        if (\r\n            (now - (_subscriptionData.lastPaidAt + _subscriptionData.period)) <\r\n            14400\r\n        ) {\r\n            sppSubscriptionStats[hash2sppId[hash]]\r\n                .lastPaidAt = _subscriptionData.lastPaidAt.add(\r\n                _subscriptionData.period\r\n            );\r\n        } else {\r\n            sppSubscriptionStats[hash2sppId[hash]].lastPaidAt = now;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setRemainingToBeFulfilled(bytes32 hash, uint256 amt)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        if (msg.sender != TradeEngineAddress) return false;\r\n        uint256 sppID = hash2sppId[hash];\r\n        sppSubscribers memory _subscriptionData = sppSubscriptionStats[sppID];\r\n        if ((_subscriptionData.remainingToBeFulfilled == amt))\r\n            sppSubscriptionStats[hash2sppId[hash]]\r\n                .remainingToBeFulfilled = _subscriptionData.value;\r\n        else {\r\n            sppSubscriptionStats[hash2sppId[hash]]\r\n                .remainingToBeFulfilled = _subscriptionData\r\n                .remainingToBeFulfilled\r\n                .sub(amt);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setcurrentTokenStats(\r\n        bytes32 hash,\r\n        uint256 amountGotten,\r\n        uint256 amountGiven\r\n    ) public returns (bool success) {\r\n        if (msg.sender != TradeEngineAddress) return false;\r\n        uint256 sppID = hash2sppId[hash];\r\n        currentTokenStats memory _tokenStats = tokenStats[sppID];\r\n        tokenStats[sppID].amountGotten = _tokenStats.amountGotten.add(\r\n            amountGotten\r\n        );\r\n        tokenStats[sppID].amountGiven = _tokenStats.amountGiven.add(\r\n            amountGiven\r\n        );\r\n        emit SetCurrentTokenStats(sppID, amountGotten, amountGiven);\r\n        return true;\r\n    }\r\n\r\n    function isActiveSpp(uint256 sppID) public view returns (bool res) {\r\n        return sppSubscriptionStats[sppID].exists;\r\n    }\r\n\r\n    function getSppIdFromHash(bytes32 hash) public returns (uint256 sppID) {\r\n        return hash2sppId[hash];\r\n    }\r\n\r\n    function getLatestOrderId() public view returns (uint256 oId) {\r\n        return orderId;\r\n    }\r\n\r\n    function getRemainingToBeFulfilledByHash(bytes32 hash)\r\n        public\r\n        _tradeEngineOnly\r\n        returns (uint256 res)\r\n    {\r\n        return sppSubscriptionStats[hash2sppId[hash]].remainingToBeFulfilled;\r\n    }\r\n\r\n    function getRemainingToBeFulfilledBySppID(uint256 sppID)\r\n        public\r\n        view\r\n        returns (uint256 res)\r\n    {\r\n        return sppSubscriptionStats[sppID].remainingToBeFulfilled;\r\n    }\r\n\r\n    function getlistOfSubscriptions(address _from)\r\n        public\r\n        view\r\n        returns (uint256[] arr)\r\n    {\r\n        return subList[_from].arr;\r\n    }\r\n\r\n    function getlistOfSppSubscriptions(address _from)\r\n        public\r\n        view\r\n        returns (uint256[] arr)\r\n    {\r\n        return sppSubList[_from].arr;\r\n    }\r\n\r\n    function getcurrentTokenAmounts(uint256 sppID)\r\n        public\r\n        view\r\n        returns (uint256[2] memory arr)\r\n    {\r\n        arr[0] = tokenStats[sppID].amountGotten;\r\n        arr[1] = tokenStats[sppID].amountGiven;\r\n        return arr;\r\n    }\r\n\r\n    function getTokenStats(uint256 sppID)\r\n        public\r\n        view\r\n        returns (address[2] memory arr)\r\n    {\r\n        arr[0] = tokenStats[sppID].TokenToGet;\r\n        arr[1] = tokenStats[sppID].TokenToGive;\r\n        return arr;\r\n    }\r\n\r\n    function getLatestSppId() public view returns (uint256 sppId) {\r\n        return sppID;\r\n    }\r\n\r\n    function getTimeRemainingToCharge(uint256 sppID)\r\n        public\r\n        view\r\n        returns (uint256 time)\r\n    {\r\n        return ((sppSubscriptionStats[sppID].lastPaidAt).add(sppSubscriptionStats[sppID].period) - now);\r\n    }\r\n\r\n    struct sppSubscribers {\r\n        bool exists;\r\n        address customerAddress;\r\n        address tokenGive;\r\n        address tokenGet;\r\n        uint256 value;\r\n        uint256 period;\r\n        uint256 lastPaidAt;\r\n        uint256 remainingToBeFulfilled;\r\n    }\r\n\r\n    struct currentTokenStats {\r\n        address TokenToGet;\r\n        uint256 amountGotten;\r\n        address TokenToGive;\r\n        uint256 amountGiven;\r\n    }\r\n\r\n    struct listOfSubscriptions {\r\n        uint256[] arr;\r\n    }\r\n\r\n    struct listOfSppByAddress {\r\n        uint256[] arr;\r\n    }\r\n\r\n    mapping(uint256 => currentTokenStats) tokenStats;\r\n    mapping(address => listOfSppByAddress) sppSubList;\r\n    mapping(address => listOfSubscriptions) subList;\r\n    mapping(bytes32 => uint256) public hash2sppId;\r\n    mapping(uint256 => uint256) public onGoing;\r\n    mapping(uint256 => sppSubscribers) public sppSubscriptionStats;\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n    mapping(address => mapping(address => uint256)) public tokens;\r\n    mapping(address => userstats) public userdata;\r\n    mapping(address => uint256) public balances;\r\n    mapping(uint256 => subscriptionstats) public subscriptiondata;\r\n\r\n    struct userstats {\r\n        uint256 per_tp_release_amt;\r\n        uint256 time_period;\r\n        uint256 frozen_balance;\r\n        uint256 lock_till;\r\n        bool exists;\r\n    }\r\n\r\n    struct subscriptionstats {\r\n        uint256 value;\r\n        uint256 period;\r\n        uint256 lastPaidAt;\r\n        address merchantAddress;\r\n        address customerAddress;\r\n        address tokenType;\r\n        bool exists;\r\n    }\r\n\r\n    uint256 public totalSupply;\r\n    uint256 public totalPossibleSupply;\r\n    uint256 public orderId;\r\n    address public owner;\r\n    address private potentialAdmin;\r\n    address public TradeEngineAddress;\r\n    uint256 sppID;\r\n    address public usdt;\r\n    uint256 public usdtDecimal;\r\n    uint256 public rateEthUsdt;\r\n    uint256 nonce;\r\n    address public feeAccount;\r\n    uint256 public minPeriod;\r\n}\r\n\r\ncontract CoinBNS is BNSToken {\r\n    function() public {\r\n        revert();\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = \"H1.0\";\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        balances[msg.sender] = 250000000000000000;\r\n        totalSupply = 250000000000000000;\r\n        totalPossibleSupply = 250000000000000000;\r\n        name = \"BNS Token\";\r\n        decimals = 8;\r\n        symbol = \"BNS\";\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getLatestSppId\",\"outputs\":[{\"name\":\"sppId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TradeEngineAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"}],\"name\":\"getcurrentTokenAmounts\",\"outputs\":[{\"name\":\"arr\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orderId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subscriptiondata\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"},{\"name\":\"lastPaidAt\",\"type\":\"uint256\"},{\"name\":\"merchantAddress\",\"type\":\"address\"},{\"name\":\"customerAddress\",\"type\":\"address\"},{\"name\":\"tokenType\",\"type\":\"address\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"setLastPaidAt\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"getRemainingToBeFulfilledByHash\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"},{\"name\":\"ldays\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"issueMulti\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"customerAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"},{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"tokenGive\",\"type\":\"address\"}],\"name\":\"subscribeToSpp\",\"outputs\":[{\"name\":\"sID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"}],\"name\":\"getTimeRemainingToCharge\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"}],\"name\":\"closeSpp\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPossibleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"}],\"name\":\"isActiveSpp\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdtDecimal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLatestOrderId\",\"outputs\":[{\"name\":\"oId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"closeSubscription\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"merchantAddress\",\"type\":\"address\"},{\"name\":\"customerAddress\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[{\"name\":\"oID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"getlistOfSubscriptions\",\"outputs\":[{\"name\":\"arr\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sppSubscriptionStats\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"customerAddress\",\"type\":\"address\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"},{\"name\":\"lastPaidAt\",\"type\":\"uint256\"},{\"name\":\"remainingToBeFulfilled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userdata\",\"outputs\":[{\"name\":\"per_tp_release_amt\",\"type\":\"uint256\"},{\"name\":\"time_period\",\"type\":\"uint256\"},{\"name\":\"frozen_balance\",\"type\":\"uint256\"},{\"name\":\"lock_till\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateEthUsdt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"string\"},{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usdt1\",\"type\":\"address\"},{\"name\":\"feeAccount1\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setrateEthUsdt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onGoing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"getSppIdFromHash\",\"outputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setRemainingToBeFulfilled\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"lockTime\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"chargeSpp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"decimal\",\"type\":\"uint256\"}],\"name\":\"setUsdtDecimal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"frozenBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"}],\"name\":\"getTokenStats\",\"outputs\":[{\"name\":\"arr\",\"type\":\"address[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hash2sppId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"charge\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"amountGotten\",\"type\":\"uint256\"},{\"name\":\"amountGiven\",\"type\":\"uint256\"}],\"name\":\"setcurrentTokenStats\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sppID\",\"type\":\"uint256\"}],\"name\":\"getRemainingToBeFulfilledBySppID\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"setMinPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"getlistOfSppSubscriptions\",\"outputs\":[{\"name\":\"arr\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"setTradeEngineAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"merchantAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"Subscribe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"Charge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sppID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"}],\"name\":\"SubscribeToSpp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sppID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"ChargeSpp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sppID\",\"type\":\"uint256\"}],\"name\":\"CloseSpp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sppID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountGotten\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountGiven\",\"type\":\"uint256\"}],\"name\":\"SetCurrentTokenStats\",\"type\":\"event\"}]","ContractName":"CoinBNS","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://73379843f1a6cc28081504c5515fd40655dfc56624ded97b1bd3f1dd5d5c6c99"}]}