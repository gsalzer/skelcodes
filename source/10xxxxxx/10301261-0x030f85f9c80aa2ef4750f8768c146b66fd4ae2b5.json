{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary BytesUtil {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\r\n        require(_bytes.length >= (_start + 4));\r\n        bytes4 tempBytes4;\r\n\r\n        assembly {\r\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes4;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n// Copied from https://eips.ethereum.org/EIPS/eip-1271.\r\n\r\n\r\n\r\nabstract contract ERC1271 {\r\n\r\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n    bytes4 constant internal MAGICVALUE = 0x20c13b0b;\r\n\r\n    /**\r\n     * @dev Should return whether the signature provided is valid for the provided data\r\n     * @param _data Arbitrary length data signed on the behalf of address(this)\r\n     * @param _signature Signature byte array associated with _data\r\n     *\r\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n     * MUST allow external calls\r\n     */\r\n    function isValidSignature(\r\n        bytes memory _data,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes4 magicValue);\r\n}/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title AddressSet\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract AddressSet\r\n{\r\n    struct Set\r\n    {\r\n        address[] addresses;\r\n        mapping (address => uint) positions;\r\n        uint count;\r\n    }\r\n    mapping (bytes32 => Set) private sets;\r\n\r\n    function addAddressToSet(\r\n        bytes32 key,\r\n        address addr,\r\n        bool maintainList\r\n        ) internal\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.positions[addr] == 0, \"ALREADY_IN_SET\");\r\n\r\n        if (maintainList) {\r\n            require(set.addresses.length == set.count, \"PREVIOUSLY_NOT_MAINTAILED\");\r\n            set.addresses.push(addr);\r\n        } else {\r\n            require(set.addresses.length == 0, \"MUST_MAINTAIN\");\r\n        }\r\n\r\n        set.count += 1;\r\n        set.positions[addr] = set.count;\r\n    }\r\n\r\n    function removeAddressFromSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n    {\r\n        Set storage set = sets[key];\r\n        uint pos = set.positions[addr];\r\n        require(pos != 0, \"NOT_IN_SET\");\r\n\r\n        delete set.positions[addr];\r\n        set.count -= 1;\r\n\r\n        if (set.addresses.length > 0) {\r\n            address lastAddr = set.addresses[set.count];\r\n            if (lastAddr != addr) {\r\n                set.addresses[pos - 1] = lastAddr;\r\n                set.positions[lastAddr] = pos;\r\n            }\r\n            set.addresses.pop();\r\n        }\r\n    }\r\n\r\n    function removeSet(bytes32 key)\r\n        internal\r\n    {\r\n        delete sets[key];\r\n    }\r\n\r\n    function isAddressInSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return sets[key].positions[addr] != 0;\r\n    }\r\n\r\n    function numAddressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        Set storage set = sets[key];\r\n        return set.count;\r\n    }\r\n\r\n    function addressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.count == set.addresses.length, \"NOT_MAINTAINED\");\r\n        return sets[key].addresses;\r\n    }\r\n}\r\n\r\n\r\ncontract OwnerManagable is Claimable, AddressSet\r\n{\r\n    bytes32 internal constant MANAGER = keccak256(\"__MANAGED__\");\r\n\r\n    event ManagerAdded  (address indexed manager);\r\n    event ManagerRemoved(address indexed manager);\r\n\r\n    modifier onlyManager\r\n    {\r\n        require(isManager(msg.sender), \"NOT_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrManager\r\n    {\r\n        require(msg.sender == owner || isManager(msg.sender), \"NOT_OWNER_OR_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    constructor() public Claimable() {}\r\n\r\n    /// @dev Gets the managers.\r\n    /// @return The list of managers.\r\n    function managers()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return addressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Gets the number of managers.\r\n    /// @return The numer of managers.\r\n    function numManagers()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Checks if an address is a manger.\r\n    /// @param addr The address to check.\r\n    /// @return True if the address is a manager, False otherwise.\r\n    function isManager(address addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isAddressInSet(MANAGER, addr);\r\n    }\r\n\r\n    /// @dev Adds a new manager.\r\n    /// @param manager The new address to add.\r\n    function addManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        addManagerInternal(manager);\r\n    }\r\n\r\n    /// @dev Removes a manager.\r\n    /// @param manager The manager to remove.\r\n    function removeManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        removeAddressFromSet(MANAGER, manager);\r\n        emit ManagerRemoved(manager);\r\n    }\r\n\r\n    function addManagerInternal(address manager)\r\n        internal\r\n    {\r\n        addAddressToSet(MANAGER, manager, true);\r\n        emit ManagerAdded(manager);\r\n    }\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Utility Functions for addresses\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary AddressUtil\r\n{\r\n    using AddressUtil for *;\r\n\r\n    function isContract(\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint32 size;\r\n        assembly { size := extcodesize(addr) }\r\n        return (size > 0);\r\n    }\r\n\r\n    function toPayable(\r\n        address addr\r\n        )\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(addr));\r\n    }\r\n\r\n    // Works like address.send but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETH(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        address payable recipient = to.toPayable();\r\n        /* solium-disable-next-line */\r\n        (success, ) = recipient.call{value: amount, gas: gasLimit}(\"\");\r\n    }\r\n\r\n    // Works like address.transfer but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETHAndVerify(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        success = to.sendETH(amount, gasLimit);\r\n        require(success, \"TRANSFER_FAILURE\");\r\n    }\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title SignatureUtil\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @dev This method supports multihash standard. Each signature's first byte indicates\r\n///      the signature's type, the second byte indicates the signature's length, therefore,\r\n///      each signature will have 2 extra bytes prefix. Mulitple signatures are concatenated\r\n///      together.\r\nlibrary SignatureUtil\r\n{\r\n    using BytesUtil     for bytes;\r\n    using MathUint      for uint;\r\n\r\n    enum SignatureType {\r\n        ILLEGAL,\r\n        INVALID,\r\n        EIP_712,\r\n        ETH_SIGN,\r\n        WALLET\r\n    }\r\n\r\n    bytes4 constant private ERC1271_MAGICVALUE = 0x20c13b0b;\r\n\r\n    function verifySignatures(\r\n        bytes32   signHash,\r\n        address[] memory signers,\r\n        bytes[]   memory signatures\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(signers.length == signatures.length, \"BAD_SIGNATURE_DATA\");\r\n        address lastSigner;\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            require(signers[i] > lastSigner, \"INVALID_SIGNERS_ORDER\");\r\n            lastSigner = signers[i];\r\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function verifySignature(\r\n        bytes32 signHash,\r\n        address signer,\r\n        bytes   memory signature\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint signatureTypeOffset = signature.length.sub(1);\r\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\r\n\r\n        bytes memory stripped = signature.slice(0, signatureTypeOffset);\r\n\r\n        if (signatureType == SignatureType.WALLET) {\r\n            return verifyERC1271Signature(signHash, signer, stripped);\r\n        } else if (signatureType == SignatureType.EIP_712) {\r\n            return recoverECDSASigner(signHash, stripped) == signer;\r\n        } else if (signatureType == SignatureType.ETH_SIGN) {\r\n            bytes32 hash = keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signHash)\r\n            );\r\n            return recoverECDSASigner(hash, stripped) == signer;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function verifyERC1271Signature(\r\n        bytes32 signHash,\r\n        address signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            ERC1271(0).isValidSignature.selector,\r\n            abi.encode(signHash),\r\n            signature\r\n        );\r\n        (bool success, bytes memory result) = signer.staticcall(callData);\r\n        return (\r\n            success &&\r\n            result.length == 32 &&\r\n            result.toBytes4(0) == ERC1271_MAGICVALUE\r\n        );\r\n    }\r\n\r\n    function recoverECDSASigner(\r\n        bytes32      signHash,\r\n        bytes memory signature\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        if (signature.length != 65) {\r\n            return address(0);\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8   v;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := and(mload(add(signature, 0x41)), 0xff)\r\n        }\r\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n        if (v == 27 || v == 28) {\r\n            return ecrecover(signHash, v, r, s);\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title OfficialGuardian\r\n/// @author Freeman Zhong - <kongliang@loopring.org>\r\ncontract OfficialGuardian is OwnerManagable, ERC1271\r\n{\r\n    using SignatureUtil for bytes32;\r\n\r\n    function isValidSignature(\r\n        bytes memory _data,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        override\r\n        returns (bytes4 magicValue)\r\n    {\r\n        bytes32 hash;\r\n        if (_data.length == 32) {\r\n            hash = BytesUtil.toBytes32(_data, 0);\r\n        } else {\r\n            hash = keccak256(_data);\r\n        }\r\n\r\n        address signer = hash.recoverECDSASigner(_signature);\r\n        if (isManager(signer)) {\r\n            return MAGICVALUE;\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numManagers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OfficialGuardian","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://09aea85fb8ba29c5cac01d0df356a00d61ffda32bec2ae0fc7ff0481570a23f0"}]}