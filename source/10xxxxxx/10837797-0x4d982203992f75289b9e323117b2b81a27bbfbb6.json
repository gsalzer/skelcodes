{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint64 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint64 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    require(b <= a);\r\n    uint64 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    uint64 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/lib/Math.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n\r\n  // return ceil(n/d)\r\n  function divCeil(uint256 n, uint256 d) internal pure returns (uint256) {\r\n    return n % d == 0 ? n / d : n / d + 1;\r\n  }\r\n}\r\n\r\n// File: contracts/lib/RLP.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title RLPReader\r\n * @dev RLPReader is used to read and parse RLP encoded data in memory.\r\n * @author Andreas Olofsson (androlo1980@gmail.com)\r\n */\r\n\r\n\r\nlibrary RLP {\r\n    uint constant DATA_SHORT_START = 0x80;\r\n    uint constant DATA_LONG_START = 0xB8;\r\n    uint constant LIST_SHORT_START = 0xC0;\r\n    uint constant LIST_LONG_START = 0xF8;\r\n\r\n    uint constant DATA_LONG_OFFSET = 0xB7;\r\n    uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n\r\n\r\n    struct RLPItem {\r\n        uint _unsafeMemPtr;    // Pointer to the RLP-encoded bytes.\r\n        uint _unsafeLength;    // Number of bytes. This is the full length of the string.\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem _unsafeItem;   // Item that's being iterated over.\r\n        uint _unsafeNextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /* RLPItem */\r\n\r\n    /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    /// @param self The RLP encoded bytes.\r\n    /// @return An RLPItem\r\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\r\n        uint len = self.length;\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(self, 0x20)\r\n        }\r\n        return RLPItem(memPtr, len);\r\n    }\r\n\r\n    /// @dev Get the list of sub-items from an RLP encoded list.\r\n    /// Warning: This requires passing in the number of items.\r\n    /// @param self The RLP item.\r\n    /// @return Array of RLPItems.\r\n    function toList(RLPItem memory self, uint256 numItems) internal pure returns (RLPItem[] memory list) {\r\n        list = new RLPItem[](numItems);\r\n        Iterator memory it = iterator(self);\r\n        uint idx;\r\n        while (idx < numItems) {\r\n            list[idx] = next(it);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into a uint. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toUint(RLPItem memory self) internal pure returns (uint data) {\r\n        (uint rStartPos, uint len) = _decode(self);\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, sub(32, len)))\r\n        }\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into an address. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toAddress(RLPItem memory self)\r\n    internal\r\n    pure\r\n    returns (address data)\r\n    {\r\n        (uint rStartPos,) = _decode(self);\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    /// @dev Create an iterator.\r\n    /// @param self The RLP item.\r\n    /// @return An 'Iterator' over the item.\r\n    function iterator(RLPItem memory self) private pure returns (Iterator memory it) {\r\n        uint ptr = self._unsafeMemPtr + _payloadOffset(self);\r\n        it._unsafeItem = self;\r\n        it._unsafeNextPtr = ptr;\r\n    }\r\n\r\n    /* Iterator */\r\n    function next(Iterator memory self) private pure returns (RLPItem memory subItem) {\r\n        uint ptr = self._unsafeNextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        subItem._unsafeMemPtr = ptr;\r\n        subItem._unsafeLength = itemLength;\r\n        self._unsafeNextPtr = ptr + itemLength;\r\n    }\r\n\r\n    function hasNext(Iterator memory self) private pure returns (bool) {\r\n        RLPItem memory item = self._unsafeItem;\r\n        return self._unsafeNextPtr < item._unsafeMemPtr + item._unsafeLength;\r\n    }\r\n\r\n    // Get the payload offset.\r\n    function _payloadOffset(RLPItem memory self)\r\n    private\r\n    pure\r\n    returns (uint)\r\n    {\r\n        uint b0;\r\n        uint memPtr = self._unsafeMemPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 < DATA_SHORT_START)\r\n            return 0;\r\n        if (b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n            return 1;\r\n        if (b0 < LIST_SHORT_START)\r\n            return b0 - DATA_LONG_OFFSET + 1;\r\n        return b0 - LIST_LONG_OFFSET + 1;\r\n    }\r\n\r\n    // Get the full length of an RLP item.\r\n    function _itemLength(uint memPtr)\r\n    private\r\n    pure\r\n    returns (uint len)\r\n    {\r\n        uint b0;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 < DATA_SHORT_START)\r\n            len = 1;\r\n        else if (b0 < DATA_LONG_START)\r\n            len = b0 - DATA_SHORT_START + 1;\r\n    }\r\n\r\n    // Get start position and length of the data.\r\n    function _decode(RLPItem memory self)\r\n    private\r\n    pure\r\n    returns (uint memPtr, uint len)\r\n    {\r\n        uint b0;\r\n        uint start = self._unsafeMemPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(start))\r\n        }\r\n        if (b0 < DATA_SHORT_START) {\r\n            memPtr = start;\r\n            len = 1;\r\n            return (memPtr, len);\r\n        }\r\n        if (b0 < DATA_LONG_START) {\r\n            len = self._unsafeLength - 1;\r\n            memPtr = start + 1;\r\n        } else {\r\n            uint bLen;\r\n            assembly {\r\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n            }\r\n            len = self._unsafeLength - 1 - bLen;\r\n            memPtr = start + bLen + 1;\r\n        }\r\n        return (memPtr, len);\r\n    }\r\n\r\n    /// @dev Return the RLP encoded bytes.\r\n    /// @param self The RLPItem.\r\n    /// @return The bytes.\r\n    function toBytes(RLPItem memory self)\r\n    internal\r\n    pure\r\n    returns (bytes memory bts)\r\n    {\r\n        uint len = self._unsafeLength;\r\n        if (len == 0)\r\n            return bts;\r\n        bts = new bytes(len);\r\n        _copyToBytes(self._unsafeMemPtr, bts, len);\r\n    }\r\n\r\n    // Assumes that enough memory has been allocated to store in target.\r\n    function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen)\r\n    private\r\n    pure\r\n    {\r\n        // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n        // we can write entire words, and just overwrite any excess.\r\n        assembly {\r\n            {\r\n            // evm operations on words\r\n                let words := div(add(btsLen, 31), 32)\r\n                let rOffset := btsPtr\r\n                let wOffset := add(tgt, 0x20)\r\n                for\r\n                { let i := 0 } // start at arr + 0x20 -> first byte corresponds to length\r\n                lt(i, words)\r\n                { i := add(i, 1) }\r\n                {\r\n                    let offset := mul(i, 0x20)\r\n                    mstore(add(wOffset, offset), mload(add(rOffset, offset)))\r\n                }\r\n                mstore(add(tgt, add(0x20, mload(tgt))), 0)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/lib/RLPEncode.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title A simple RLP encoding library\r\n * @author Bakaoh\r\n */\r\nlibrary RLPEncode {\r\n\r\n    uint8 constant STRING_OFFSET = 0x80;\r\n    uint8 constant LIST_OFFSET = 0xc0;\r\n\r\n    /**\r\n     * @notice Encode string item\r\n     * @param self The string (ie. byte array) item to encode\r\n     * @return The RLP encoded string in bytes\r\n     */\r\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\r\n        if (self.length == 1 && self[0] <= 0x7f) {\r\n            return self;\r\n        }\r\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\r\n    }\r\n\r\n    /**\r\n     * @notice Encode address\r\n     * @param self The address to encode\r\n     * @return The RLP encoded address in bytes\r\n     */\r\n    function encodeAddress(address self) internal pure returns (bytes memory) {\r\n        bytes memory b;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, self))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n        return encodeBytes(b);\r\n    }\r\n\r\n    /**\r\n     * @notice Encode uint\r\n     * @param self The uint to encode\r\n     * @return The RLP encoded uint in bytes\r\n     */\r\n    function encodeUint(uint self) internal pure returns (bytes memory) {\r\n        return encodeBytes(toBinary(self));\r\n    }\r\n\r\n    /**\r\n     * @notice Encode int\r\n     * @param self The int to encode\r\n     * @return The RLP encoded int in bytes\r\n     */\r\n    function encodeInt(int self) internal pure returns (bytes memory) {\r\n        return encodeUint(uint(self));\r\n    }\r\n\r\n    /**\r\n     * @notice Encode bool\r\n     * @param self The bool to encode\r\n     * @return The RLP encoded bool in bytes\r\n     */\r\n    function encodeBool(bool self) internal pure returns (bytes memory) {\r\n        bytes memory rs = new bytes(1);\r\n        if (self) {\r\n            rs[0] = bytes1(uint8(1));\r\n        }\r\n        return rs;\r\n    }\r\n\r\n    /**\r\n     * @notice Encode list of items\r\n     * @param self The list of items to encode, each item in list must be already encoded\r\n     * @return The RLP encoded list of items in bytes\r\n     */\r\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\r\n        bytes memory payload = new bytes(0);\r\n        for (uint i = 0; i < self.length; i++) {\r\n            payload = mergeBytes(payload, self[i]);\r\n        }\r\n        return mergeBytes(encodeLength(payload.length, LIST_OFFSET), payload);\r\n    }\r\n\r\n    /**\r\n     * @notice Concat two bytes arrays\r\n     * @dev This should be optimize with assembly to save gas costs\r\n     * @param param1 The first bytes array\r\n     * @param param2 The second bytes array\r\n     * @return The merged bytes array\r\n     */\r\n    function mergeBytes(bytes memory param1, bytes memory param2) internal pure returns (bytes memory) {\r\n        bytes memory merged = new bytes(param1.length + param2.length);\r\n        uint k = 0;\r\n        uint i;\r\n        for (i = 0; i < param1.length; i++) {\r\n            merged[k] = param1[i];\r\n            k++;\r\n        }\r\n\r\n        for (i = 0; i < param2.length; i++) {\r\n            merged[k] = param2[i];\r\n            k++;\r\n        }\r\n        return merged;\r\n    }\r\n\r\n    /**\r\n     * @notice Encode the first byte, followed by the `length` in binary form if `length` is more than 55.\r\n     * @param length The length of the string or the payload\r\n     * @param offset `STRING_OFFSET` if item is string, `LIST_OFFSET` if item is list\r\n     * @return RLP encoded bytes\r\n     */\r\n    function encodeLength(uint length, uint offset) internal pure returns (bytes memory) {\r\n        require(length < 256**8, \"input too long\");\r\n        bytes memory rs = new bytes(1);\r\n        if (length <= 55) {\r\n            rs[0] = byte(uint8(length + offset));\r\n            return rs;\r\n        }\r\n        bytes memory bl = toBinary(length);\r\n        rs[0] = byte(uint8(bl.length + offset + 55));\r\n        return mergeBytes(rs, bl);\r\n    }\r\n\r\n    /**\r\n     * @notice Encode integer in big endian binary form with no leading zeroes\r\n     * @dev This should be optimize with assembly to save gas costs\r\n     * @param x The integer to encode\r\n     * @return RLP encoded bytes\r\n     */\r\n    function toBinary(uint x) internal pure returns (bytes memory) {\r\n        uint i;\r\n        bytes memory b = new bytes(32);\r\n        assembly {\r\n            mstore(add(b, 32), x)\r\n        }\r\n        for (i = 0; i < 32; i++) {\r\n            if (b[i] != 0) {\r\n                break;\r\n            }\r\n        }\r\n        bytes memory rs = new bytes(32 - i);\r\n        for (uint j = 0; j < rs.length; j++) {\r\n            rs[j] = b[i++];\r\n        }\r\n        return rs;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/BMT.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary BMT {\r\n  // TODO: remove recursive call\r\n  function getRoot(bytes32[] memory level)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    if (level.length == 1) return level[0];\r\n\r\n    bytes32[] memory nextLevel = new bytes32[]((level.length + 1) / 2);\r\n    uint i;\r\n\r\n    for (; i + 1 < level.length; i += 2) {\r\n      nextLevel[i/2] = keccak256(abi.encodePacked(level[i], level[i+1]));\r\n    }\r\n\r\n    if (level.length % 2 == 1) {\r\n      nextLevel[i/2] = keccak256(\r\n        abi.encodePacked(level[level.length - 1], level[level.length - 1])\r\n      );\r\n    }\r\n\r\n    return getRoot(nextLevel);\r\n  }\r\n\r\n  function checkMembership(\r\n    bytes32 leaf,\r\n    uint256 index,\r\n    bytes32 rootHash,\r\n    bytes memory proof\r\n  )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    require(proof.length % 32 == 0);\r\n\r\n    uint256 numElements = proof.length / 32;\r\n    require(numElements < 16);\r\n\r\n    bytes32 proofElement;\r\n    bytes32 computedHash = leaf;\r\n\r\n    for (uint256 i = 32; i <= 32 * numElements; i += 32) {\r\n      assembly {\r\n        proofElement := mload(add(proof, i))\r\n      }\r\n      if (index % 2 == 0) {\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n      } else {\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n      }\r\n      index = index / 2;\r\n    }\r\n    return computedHash == rootHash;\r\n  }\r\n}\r\n\r\n// File: contracts/RequestableI.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\ninterface RequestableI {\r\n  function applyRequestInRootChain(\r\n    bool isExit,\r\n    uint256 requestId,\r\n    address requestor,\r\n    bytes32 trieKey,\r\n    bytes calldata trieValue\r\n  ) external returns (bool success);\r\n\r\n  function applyRequestInChildChain(\r\n    bool isExit,\r\n    uint256 requestId,\r\n    address requestor,\r\n    bytes32 trieKey,\r\n    bytes calldata trieValue\r\n  ) external returns (bool success);\r\n}\r\n\r\n// File: contracts/lib/Data.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import \"../patricia_tree/PatriciaTree.sol\"; // use binary merkle tree\r\n\r\n\r\n\r\nlibrary Data {\r\n  using SafeMath for uint;\r\n  using SafeMath for uint64;\r\n  using Math for *;\r\n  using RLP for *;\r\n  using RLPEncode for *;\r\n  using BMT for *;\r\n\r\n  // solium-disable max-len\r\n  bytes4 public constant APPLY_IN_CHILDCHAIN_SIGNATURE = bytes4(keccak256(\"applyRequestInChildChain(bool,uint256,address,bytes32,bytes)\"));\r\n  bytes4 public constant APPLY_IN_ROOTCHAIN_SIGNATURE = bytes4(keccak256(\"applyRequestInRootChain(bool,uint256,address,bytes32,bytes)\"));\r\n  // solium-enable max-len\r\n\r\n  address public constant NA = address(0);\r\n  uint public constant NA_TX_GAS_PRICE = 1e9;\r\n  uint public constant NA_TX_GAS_LIMIT = 100000;\r\n\r\n  // How many requests can be included in a single request block\r\n  function MAX_REQUESTS() internal pure returns (uint) {\r\n    // TODO: use 100 in production mode\r\n    // return 1000;\r\n    return 20;\r\n  }\r\n\r\n  // Timeout for URB submission\r\n  function URE_TIMEOUT() internal pure returns (uint) {\r\n    return 1 hours;\r\n  }\r\n\r\n  function decodePos(uint _pos) internal pure returns (uint v1, uint v2) {\r\n    assembly {\r\n      v1 := div(_pos, exp(2, 128))\r\n      v2 := and(_pos, sub(exp(2, 128), 1))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * highestFinalizedBlock\r\n   * firstEpochNumber\r\n   * blockToRenew               0 means no renew required\r\n   * forkedBlock                forked block number due to URB submission\r\n   *                            last finalized block is forkedBlockNumber - 1\r\n   * urbEpochNumber\r\n   * lastEpoch\r\n   * lastBlock\r\n   * lastFinalizedBlock\r\n   * timestamp\r\n   * firstEnterEpoch            epoch number of first enter request epoch\r\n   * lastEnterEpoch             epoch number of last enter request epoch\r\n   * nextBlockToRebase\r\n   * rebased                    true if all blocks are rebased\r\n   * epochs                     epochs in this fork\r\n   * blocks                     blocks in this fork\r\n   */\r\n  struct Fork {\r\n    // uint64 blockToRenew;\r\n    uint64 forkedBlock; // TODO: change to forkedEpoch\r\n    uint64 firstEpoch;\r\n    uint64 lastEpoch;\r\n    uint64 firstBlock;\r\n    uint64 lastBlock;\r\n    uint64 lastFinalizedEpoch;\r\n    uint64 lastFinalizedBlock;\r\n    uint64 timestamp;\r\n    uint64 firstEnterEpoch;\r\n    uint64 lastEnterEpoch;\r\n    uint64 nextBlockToRebase;\r\n    bool rebased;\r\n    mapping (uint => Epoch) epochs;\r\n    mapping (uint => PlasmaBlock) blocks;\r\n  }\r\n\r\n  function getForkedEpoch(Fork storage self) internal view returns (uint64) {\r\n    require(self.forkedBlock != 0);\r\n    return self.blocks[self.forkedBlock].epochNumber;\r\n  }\r\n\r\n  /**\r\n   * @notice Insert a block (ORB / NRB) into the fork.\r\n   */\r\n  function insertBlock(\r\n    Fork storage _f,\r\n    bytes32 _statesRoot,\r\n    bytes32 _transactionsRoot,\r\n    bytes32 _receiptsRoot,\r\n    bool _isRequest,\r\n    bool _userActivated,\r\n    bool _rebase\r\n  )\r\n    internal\r\n    returns (uint epochNumber, uint blockNumber)\r\n  {\r\n    epochNumber = _f.lastEpoch;\r\n    blockNumber = _f.lastBlock.add(1);\r\n\r\n    Data.Epoch storage epoch = _f.epochs[epochNumber];\r\n\r\n    if (blockNumber == epoch.endBlockNumber + 1) {\r\n      epochNumber += 1;\r\n      _f.lastEpoch = uint64(epochNumber);\r\n      epoch = _f.epochs[epochNumber];\r\n    }\r\n\r\n    require(epoch.startBlockNumber <= blockNumber);\r\n    require(_rebase || epoch.endBlockNumber >= blockNumber);\r\n\r\n    require(epoch.isRequest == _isRequest);\r\n    require(epoch.userActivated == _userActivated);\r\n\r\n    Data.PlasmaBlock storage b = _f.blocks[blockNumber];\r\n\r\n    b.epochNumber = uint64(epochNumber);\r\n    b.statesRoot = _statesRoot;\r\n    b.transactionsRoot = _transactionsRoot;\r\n    b.receiptsRoot = _receiptsRoot;\r\n    b.timestamp = uint64(block.timestamp);\r\n    b.isRequest = _isRequest;\r\n    b.userActivated = _userActivated;\r\n\r\n    if (_isRequest) {\r\n      b.requestBlockId = uint64(epoch.RE.firstRequestBlockId + blockNumber - epoch.startBlockNumber);\r\n    }\r\n\r\n    _f.lastBlock = uint64(blockNumber);\r\n    return (epochNumber, blockNumber);\r\n  }\r\n\r\n\r\n  /**\r\n   * TODO: implement insert rebased non-request epoch\r\n   * @notice Insert non-request epoch into the fork.\r\n   */\r\n  function insertNRE(\r\n    Fork storage _f,\r\n    uint _epochNumber,\r\n    bytes32 _epochStateRoot,\r\n    bytes32 _epochTransactionsRoot,\r\n    bytes32 _epochReceiptsRoot,\r\n    uint _startBlockNumber,\r\n    uint _endBlockNumber\r\n  )\r\n    internal\r\n  {\r\n    require(_f.lastEpoch.add(1) == _epochNumber);\r\n    require(_f.lastBlock.add(1) == _startBlockNumber);\r\n\r\n    Data.Epoch storage epoch = _f.epochs[_epochNumber];\r\n\r\n    require(!epoch.isRequest);\r\n    require(!epoch.userActivated);\r\n    require(!epoch.rebase);\r\n\r\n    require(epoch.startBlockNumber == _startBlockNumber);\r\n    require(epoch.endBlockNumber == _endBlockNumber);\r\n\r\n    epoch.NRE.epochStateRoot = _epochStateRoot;\r\n    epoch.NRE.epochTransactionsRoot = _epochTransactionsRoot;\r\n    epoch.NRE.epochReceiptsRoot = _epochReceiptsRoot;\r\n    epoch.NRE.submittedAt = uint64(block.timestamp);\r\n\r\n    _f.lastEpoch = uint64(_epochNumber);\r\n    _f.lastBlock = uint64(_endBlockNumber);\r\n  }\r\n\r\n  function getLastEpochNumber(Fork storage _f, bool _isRequest) internal returns (uint) {\r\n    if (_f.epochs[_f.lastEpoch].isRequest == _isRequest) {\r\n      return _f.lastEpoch;\r\n    }\r\n\r\n    return _f.lastEpoch - 1;\r\n  }\r\n\r\n  // function getFirstNotFinalizedEpochNumber(Fork storage _f, bool _isRequest) internal returns (uint) {\r\n  //   if (_f.epochs[_f.lastEpoch].isRequest == _isRequest) {\r\n  //     return _f.lastEpoch;\r\n  //   }\r\n\r\n  //   return _f.lastEpoch - 1;\r\n  // }\r\n\r\n  /**\r\n   * @notice Update nextBlockToRebase to next request block containing enter request.\r\n   *         If all ORBs are rebased, return true.\r\n   */\r\n  function checkNextORBToRebase(\r\n    Fork storage _cur,\r\n    Fork storage _pre,\r\n    RequestBlock[] storage _rbs\r\n  ) internal returns (bool finished) {\r\n    uint blockNumber = _cur.nextBlockToRebase;\r\n    uint epochNumber = _pre.blocks[_cur.nextBlockToRebase].epochNumber;\r\n    // uint lastEpochNumber = getLastEpochNumber(_pre, true);\r\n\r\n    while (_pre.epochs[epochNumber].initialized) {\r\n      // at the end of epoch\r\n      if (_pre.epochs[epochNumber].endBlockNumber <= blockNumber) {\r\n        epochNumber += 2;\r\n        blockNumber = _pre.epochs[epochNumber].startBlockNumber;\r\n      }\r\n\r\n      // skip until epoch has enter request\r\n      while (_pre.epochs[epochNumber].RE.numEnter == 0 && _pre.epochs[epochNumber].initialized) {\r\n        epochNumber += 2;\r\n        blockNumber = _pre.epochs[epochNumber].startBlockNumber;\r\n      }\r\n\r\n      // short circuit if all OREs are empty or has no enter\r\n      if (!_pre.epochs[epochNumber].initialized) {\r\n        return true;\r\n      }\r\n\r\n      // skip blocks without enter request\r\n      uint endBlockNumber = _pre.epochs[epochNumber].endBlockNumber;\r\n      while (blockNumber <= endBlockNumber) {\r\n        if (_rbs[_pre.blocks[blockNumber].requestBlockId].numEnter > 0) {\r\n          break;\r\n        }\r\n        blockNumber += 1;\r\n      }\r\n\r\n      // continue if there is no block containing enter request\r\n      if (blockNumber > endBlockNumber) {\r\n        epochNumber += 2;\r\n        blockNumber = _pre.epochs[epochNumber].startBlockNumber;\r\n        continue;\r\n      }\r\n\r\n      // target block number is found\r\n      _cur.nextBlockToRebase = uint64(blockNumber);\r\n      return false;\r\n    }\r\n\r\n    // ready to prepare NRE\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Update nextBlockToRebase to next non request block\r\n   *         If all NRBs are rebased, return true.\r\n   * TODO    What if no ORE' ?\r\n   */\r\n  function checkNextNRBToRebase(\r\n    Fork storage _cur,\r\n    Fork storage _pre\r\n  ) internal returns (bool finished) {\r\n    uint blockNumber = _cur.nextBlockToRebase;\r\n    uint epochNumber = _pre.blocks[blockNumber].epochNumber;\r\n\r\n    // at the end of epoch\r\n    if (_pre.epochs[epochNumber].endBlockNumber <= blockNumber) {\r\n      epochNumber += 2;\r\n      blockNumber = _pre.epochs[epochNumber].startBlockNumber;\r\n    } else {\r\n      blockNumber += 1;\r\n    }\r\n\r\n    // short circit if all NRE's are rebased\r\n    if (!_pre.epochs[epochNumber].initialized) {\r\n      _cur.nextBlockToRebase = 0;\r\n      return true;\r\n    }\r\n\r\n    // short circuit if block is not submitted\r\n    if (_pre.blocks[blockNumber].timestamp == 0) {\r\n      _cur.nextBlockToRebase = 0;\r\n      return true;\r\n    }\r\n\r\n    _cur.nextBlockToRebase = uint64(blockNumber);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * startBlockNumber       first block number of the epoch.\r\n   * endBlockNumber         last block number of the epoch. 0 if the epoch is ORE' / NRE' until ORE' is filled.\r\n   * timestamp              timestamp when the epoch is initialized.\r\n   *                        required for URB / ORB\r\n   * epochStateRoot         merkle root of [block.stateRoot] for block in the epoch.\r\n   * epochTransactionsRoot  merkle root of [block.transactionsRoot] for block in the epoch.\r\n   * epochReceiptsRoot      merkle root of [block.receiptsRoot] for block in the epoch.\r\n   * isEmpty                true if request epoch has no request block\r\n   *                        also and requestStart == requestEnd == previousEpoch.RE.requestEnd\r\n   *                        and startBlockNumber == endBlockNumber == previousEpoch.endBlockNumber\r\n   *                        and firstRequestBlockId == previousEpoch.firstRequestBlockId\r\n   * initialized            true if epoch is initialized\r\n   * isRequest              true in case of URB / ORB\r\n   * userActivated          true in case of URB\r\n   * rebase                 true in case of ORE' or NRE'\r\n   */\r\n  struct Epoch {\r\n    uint64 startBlockNumber;\r\n    uint64 endBlockNumber;\r\n    uint64 timestamp;\r\n    bool isEmpty;\r\n    bool initialized;\r\n    bool isRequest;\r\n    bool userActivated;\r\n    bool rebase;\r\n    RequestEpochMeta RE;\r\n    NonRequestEpochMeta NRE;\r\n  }\r\n\r\n  struct NonRequestEpochMeta {\r\n    bytes32 epochStateRoot;\r\n    bytes32 epochTransactionsRoot;\r\n    bytes32 epochReceiptsRoot;\r\n    uint64 submittedAt;\r\n    uint64 finalizedAt;\r\n    bool finalized;\r\n    bool challenging;\r\n    bool challenged;\r\n  }\r\n\r\n  /**\r\n   * requestStart           first request id.\r\n   * requestEnd             last request id.\r\n   * firstRequestBlockId    first id of RequestBlock[]\r\n   *                        if epochs is ORE', copy from last request epoch in previous fork\r\n   * numEnter               number of enter request\r\n   * nextEnterEpoch         next request epoch including enter request\r\n   * nextEpoch              next non-empty request epoch\r\n   */\r\n  struct RequestEpochMeta {\r\n    uint64 requestStart;\r\n    uint64 requestEnd;\r\n    uint64 firstRequestBlockId;\r\n    uint64 numEnter;\r\n    uint64 nextEnterEpoch;\r\n    uint64 nextEpoch;\r\n  }\r\n\r\n  // function noExit(Epoch storage self) internal returns (bool) {\r\n  //   if (self.rebase) return true;\r\n  //   return self.RE.requestEnd.sub64(self.RE.requestStart).add64(1) == self.RE.firstRequestBlockId;\r\n  // }\r\n\r\n  function getNumBlocks(Epoch storage _e) internal view returns (uint) {\r\n    if (_e.isEmpty || _e.rebase && _e.endBlockNumber == 0) return 0;\r\n    return _e.endBlockNumber + 1 - _e.startBlockNumber;\r\n  }\r\n\r\n  function getNumRequests(Epoch storage _e) internal view returns (uint) {\r\n    if (_e.isEmpty || _e.rebase && _e.endBlockNumber == 0) return 0;\r\n    return _e.RE.requestEnd + 1 - _e.RE.requestStart;\r\n  }\r\n\r\n  function calcNumBlock(uint _rs, uint _re) internal pure returns (uint) {\r\n    return _re.sub(_rs).add(1).divCeil(MAX_REQUESTS());\r\n  }\r\n\r\n  /**\r\n   * epochNumber\r\n   * requestBlockId       id of RequestBlock[]\r\n   * timestamp\r\n   * referenceBlock       block number in previous fork\r\n   * statesRoot\r\n   * transactionsRoot\r\n   * receiptsRoot\r\n   * isRequest            true in case of URB & OR\r\n   * userActivated        true in case of URB\r\n   * challenged           true if it is challenge\r\n   * challenging          true if it is being challenged\r\n   * finalized            true if it is successfully finalize\r\n   */\r\n  struct PlasmaBlock {\r\n    uint64 epochNumber;\r\n    uint64 requestBlockId;\r\n    uint64 timestamp;\r\n    uint64 finalizedAt;\r\n    uint64 referenceBlock;\r\n    bytes32 statesRoot;\r\n    bytes32 transactionsRoot;\r\n    bytes32 receiptsRoot;\r\n    bool isRequest;\r\n    bool userActivated;\r\n    bool challenged;\r\n    bool challenging;\r\n    bool finalized;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * timestamp\r\n   * isExit\r\n   * isTransfer\r\n   * finalized         true if request is finalized\r\n   * challenged\r\n   * value             ether amount in wei\r\n   * requestor\r\n   * to                requestable contract in root chain\r\n   * trieKey\r\n   * trieValue\r\n   * hash              keccak256 hash of request transaction (in plasma chain)\r\n   */\r\n  struct Request {\r\n    uint64 timestamp;\r\n    bool isExit;\r\n    bool isTransfer;\r\n    bool finalized;\r\n    bool challenged;\r\n    uint128 value;\r\n    address payable requestor;\r\n    address to;\r\n    bytes32 trieKey;\r\n    bytes32 hash;\r\n    bytes trieValue;\r\n  }\r\n\r\n  function applyRequestInRootChain(\r\n    Request memory self,\r\n    uint _requestId\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    require(gasleft() > NA_TX_GAS_LIMIT + 5000);\r\n\r\n    return RequestableI(self.to).applyRequestInRootChain(\r\n      self.isExit,\r\n      _requestId,\r\n      self.requestor,\r\n      self.trieKey,\r\n      self.trieValue\r\n    );\r\n  }\r\n\r\n  function toChildChainRequest(\r\n    Request memory self,\r\n    address _to\r\n  )\r\n    internal\r\n    pure\r\n    returns (Request memory out)\r\n  {\r\n    out.isExit = self.isExit;\r\n    out.isTransfer = self.isTransfer;\r\n    out.requestor = self.requestor;\r\n\r\n    // Enter request of EtherToken mints PETH to requestor.\r\n    if (!self.isExit && self.isTransfer) {\r\n      out.to = self.requestor;\r\n      bytes memory b = self.trieValue;\r\n      uint128 v;\r\n\r\n      assembly {\r\n        v := mload(add(b, 0x20))\r\n      }\r\n\r\n      require(v > 0);\r\n\r\n      // no trieKey and trieValue for EtherToken enter\r\n      out.value = uint128(v);\r\n    } else {\r\n      out.to = _to;\r\n      out.value = self.value;\r\n      out.trieKey = self.trieKey;\r\n      out.trieValue = self.trieValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice return tx.data\r\n   */\r\n  function getData(\r\n    Request memory self,\r\n    uint _requestId,\r\n    bool _rootchain\r\n  )\r\n    internal\r\n    pure\r\n    returns (bytes memory out)\r\n  {\r\n    if (self.isTransfer && !self.isExit) {\r\n      return out;\r\n    }\r\n\r\n    bytes4 funcSig = _rootchain ? APPLY_IN_ROOTCHAIN_SIGNATURE : APPLY_IN_CHILDCHAIN_SIGNATURE;\r\n\r\n    out = abi.encodePacked(\r\n      funcSig,\r\n      abi.encode(\r\n        bytes32(uint(self.isExit ? 1 : 0)),\r\n        _requestId,\r\n        uint256(uint160(self.requestor)),\r\n        self.trieKey,\r\n        self.trieValue\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice convert Request to TX\r\n   */\r\n  function toTX(\r\n    Request memory self,\r\n    uint _requestId,\r\n    bool _rootchain\r\n  )\r\n    internal\r\n    pure\r\n    returns (TX memory out)\r\n  {\r\n    out.gasPrice = NA_TX_GAS_PRICE;\r\n    out.gasLimit = uint64(NA_TX_GAS_LIMIT);\r\n    out.to = self.to;\r\n    out.value = self.value;\r\n    out.data = getData(self, _requestId, _rootchain);\r\n  }\r\n\r\n  /**\r\n   * submitted      true if no more request can be inserted\r\n   *                because epoch is initialized\r\n   * epochNumber    non request epoch number where the request is created\r\n   * requestStart   first request id\r\n   * requestEnd     last request id\r\n   * trie           patricia tree contract address\r\n   */\r\n  struct RequestBlock {\r\n    bool submitted;\r\n    uint64 numEnter;\r\n    uint64 epochNumber;\r\n    uint64 requestStart;\r\n    uint64 requestEnd;\r\n    address trie;\r\n  }\r\n\r\n  // function noExit(RequestBlock storage self) internal returns (bool) {\r\n  //   return self.RE.requestEnd.sub64(self.RE.requestStart).add64(1) == self.RE.firstRequestBlockId;\r\n  // }\r\n\r\n  function init(RequestBlock storage self) internal {\r\n    /* use binary merkle tree instead of patricia tree\r\n    if (self.trie == address(0)) {\r\n      self.trie = new PatriciaTree();\r\n    }\r\n     */\r\n  }\r\n\r\n  function addRequest(\r\n    RequestBlock storage self,\r\n    Request storage _rootchainRequest,  // request in root chain\r\n    Request memory _childchainRequest,  // request in child chain\r\n    uint _requestId\r\n  ) internal {\r\n    _rootchainRequest.hash = hash(toTX(_childchainRequest, _requestId, false));\r\n\r\n    /* use binary merkle tree instead of patricia tree\r\n    require(self.trie != address(0));\r\n\r\n    uint txIndex = _requestId.sub(self.RE.requestStart);\r\n\r\n    bytes memory key = txIndex.encodeUint();\r\n    bytes memory value = toBytes(toTX(_request, _requestId, false));\r\n\r\n    PatriciaTree(self.trie).insert(key, value);\r\n    self.transactionsRoot = PatriciaTree(self.trie).getRootHash();\r\n     */\r\n  }\r\n\r\n  /*\r\n   * TX for Ethereum transaction\r\n   */\r\n  struct TX {\r\n    uint64 nonce;\r\n    uint256 gasPrice;\r\n    uint64 gasLimit;\r\n    address to;\r\n    uint256 value;\r\n    bytes data;\r\n    uint256 v;\r\n    uint256 r;\r\n    uint256 s;\r\n  }\r\n\r\n  function isNATX(TX memory self) internal pure returns (bool) {\r\n    return self.v == 0 && self.r == 0 && self.s == 0;\r\n  }\r\n\r\n  // function toTX(bytes memory self) internal pure returns (TX memory out) {\r\n  //   RLP.RLPItem[] memory packArr = self.toRLPItem().toList(9);\r\n\r\n  //   out.nonce = uint64(packArr[0].toUint());\r\n  //   out.gasPrice = packArr[1].toUint();\r\n  //   out.gasLimit = uint64(packArr[2].toUint());\r\n  //   out.to = packArr[3].toAddress();\r\n  //   out.value = packArr[4].toUint();\r\n  //   out.data = packArr[5].toBytes();\r\n  //   out.v = packArr[6].toUint();\r\n  //   out.r = packArr[7].toUint();\r\n  //   out.s = packArr[8].toUint();\r\n  // }\r\n\r\n  /**\r\n   * @notice Convert TX to RLP-encoded bytes\r\n   */\r\n  function toBytes(TX memory self) internal pure returns (bytes memory out) {\r\n    bytes[] memory packArr = new bytes[](9);\r\n\r\n    packArr[0] = self.nonce.encodeUint();\r\n    packArr[1] = self.gasPrice.encodeUint();\r\n    packArr[2] = self.gasLimit.encodeUint();\r\n    packArr[3] = self.to.encodeAddress();\r\n    packArr[4] = self.value.encodeUint();\r\n    packArr[5] = self.data.encodeBytes();\r\n    packArr[6] = self.v.encodeUint();\r\n    packArr[7] = self.r.encodeUint();\r\n    packArr[8] = self.s.encodeUint();\r\n\r\n    return packArr.encodeList();\r\n  }\r\n\r\n  function hash(TX memory self) internal pure returns (bytes32) {\r\n    bytes memory txBytes = toBytes(self);\r\n    return keccak256(txBytes);\r\n  }\r\n\r\n  /**\r\n   * Transaction Receipt\r\n   */\r\n\r\n  struct Log {\r\n    address contractAddress;\r\n    bytes32[] topics;\r\n    bytes data;\r\n  }\r\n\r\n  struct Receipt {\r\n    uint64 status;\r\n    uint64 cumulativeGasUsed;\r\n    bytes bloom; // 2048 bloom bits, byte[256]\r\n    Log[] logs;\r\n  }\r\n\r\n  function toReceipt(bytes memory self) internal pure returns (Receipt memory r) {\r\n    RLP.RLPItem[] memory items = self.toRLPItem().toList(4);\r\n\r\n    r.status = uint64(items[0].toUint());\r\n    r.cumulativeGasUsed = uint64(items[1].toUint());\r\n    r.bloom = items[2].toBytes();\r\n\r\n    // TODO: parse Logs\r\n    r.logs = new Log[](0);\r\n  }\r\n\r\n  function toReceiptStatus(bytes memory self) internal pure returns (uint) {\r\n    RLP.RLPItem[] memory items = self.toRLPItem().toList(4);\r\n    return items[0].toUint();\r\n  }\r\n\r\n\r\n  /**\r\n   * Helpers\r\n   */\r\n\r\n  /**\r\n   * @notice Checks transaction root of a request block\r\n   */\r\n  function _checkTxRoot(\r\n    bytes32 _transactionsRoot,\r\n    RequestBlock storage _rb,\r\n    Request[] storage _rs,\r\n    bool _skipExit\r\n  ) internal {\r\n    uint s = _rb.requestStart;\r\n    uint e = _rb.requestEnd;\r\n    uint n = _skipExit ? _rb.numEnter : e - s + 1;\r\n\r\n    require(n > 0);\r\n\r\n    bytes32[] memory hashes = new bytes32[](n);\r\n\r\n    // TODO: optimize to reduce gas\r\n    uint j = s;\r\n    for (uint i = s; i <= e; i++) {\r\n      if (!_skipExit || !_rs[i].isExit) {\r\n        hashes[j - s] = _rs[i].hash;\r\n        j++;\r\n      }\r\n    }\r\n\r\n    require(hashes.getRoot() == _transactionsRoot);\r\n\r\n    /* use binary merkle tree instead of patricia tree\r\n    Data.RequestBlock storage ORB = ORBs[fork.blocks[blockNumber].requestBlockId];\r\n    require(_transactionsRoot == ORB.transactionsRoot);\r\n      */\r\n  }\r\n}\r\n\r\n// File: contracts/lib/Address.sol\r\n\r\n// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/utils/Address.sol\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param account address of the account to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/lib/Roles.sol\r\n\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/67bca85/contracts/access/Roles.sol\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev Give an account access to this role.\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(!has(role, account));\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Remove an account's access to this role.\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(has(role, account));\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Check if an account has this role.\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account) internal view returns (bool) {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: contracts/roles/MapperRole.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\ncontract MapperRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event MapperAdded(address indexed account);\r\n  event MapperRemoved(address indexed account);\r\n\r\n  Roles.Role private _mappers;\r\n\r\n  constructor () internal {\r\n    _addMapper(msg.sender);\r\n  }\r\n\r\n  modifier onlyMapper() {\r\n    require(isMapper(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isMapper(address account) public view returns (bool) {\r\n    return _mappers.has(account);\r\n  }\r\n\r\n  function addMapper(address account) public onlyMapper {\r\n    _addMapper(account);\r\n  }\r\n\r\n  function renounceMapper() public {\r\n    _removeMapper(msg.sender);\r\n  }\r\n\r\n  function _addMapper(address account) internal {\r\n    _mappers.add(account);\r\n    emit MapperAdded(account);\r\n  }\r\n\r\n  function _removeMapper(address account) internal {\r\n    _mappers.remove(account);\r\n    emit MapperRemoved(account);\r\n  }\r\n}\r\n\r\n// File: contracts/roles/SubmitterRole.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\ncontract SubmitterRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event SubmitterAdded(address indexed account);\r\n  event SubmitterRemoved(address indexed account);\r\n\r\n  Roles.Role private _submitters;\r\n\r\n  constructor () internal {\r\n    _addSubmitter(msg.sender);\r\n  }\r\n\r\n  modifier onlySubmitter() {\r\n    require(isSubmitter(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isSubmitter(address account) public view returns (bool) {\r\n    return _submitters.has(account);\r\n  }\r\n\r\n  function addSubmitter(address account) public onlySubmitter {\r\n    _addSubmitter(account);\r\n  }\r\n\r\n  function renounceSubmitter() public {\r\n    _removeSubmitter(msg.sender);\r\n  }\r\n\r\n  function _addSubmitter(address account) internal {\r\n    _submitters.add(account);\r\n    emit SubmitterAdded(account);\r\n  }\r\n\r\n  function _removeSubmitter(address account) internal {\r\n    _submitters.remove(account);\r\n    emit SubmitterRemoved(account);\r\n  }\r\n}\r\n\r\n// File: contracts/Layer2Storage.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\ncontract Layer2Storage {\r\n  /*\r\n   * Storage\r\n   */\r\n  bool public development; // dev mode\r\n  address public operator;\r\n  address public epochHandler;\r\n  address public submitHandler;\r\n  address public etherToken;\r\n  address public seigManager;\r\n\r\n  // 1 epoch = N NRBs or k URBs or k ORBs.\r\n  // N consecutive NRBs must be submitted in an epoch. In case of request block,\r\n  // massive requests can be included in k ORBs, and k is determined when\r\n  // N NRBs are submitted or when preparing URBs submission.\r\n  uint public NRELength;\r\n\r\n  // Increase for each URB\r\n  uint public currentFork;\r\n\r\n  // First not-empty request epochs of a fork\r\n  mapping (uint => uint) public firstFilledORENumber;\r\n\r\n  mapping (uint => Data.Fork) public forks;\r\n\r\n  // Enter & Exit requests for ORB / URB\r\n  Data.Request[] public EROs;\r\n  Data.Request[] public ERUs;\r\n\r\n  // Consecutive request block. The fork where they are in is defined in Data.PlasmaBlock\r\n  Data.RequestBlock[] public ORBs;\r\n  Data.RequestBlock[] public URBs;\r\n\r\n  // count enter requests for epoch\r\n  uint public numEnterForORB;\r\n\r\n  // epoch number of last non-empty request epoch.\r\n  mapping(uint => uint) public lastNonEmptyRequestEpoch;\r\n\r\n  // epoch number of first non-empty request epoch.\r\n  mapping(uint => uint) public firstNonEmptyRequestEpoch;\r\n\r\n  // Last applied request\r\n  uint public lastAppliedForkNumber;\r\n  uint public lastAppliedEpochNumber;\r\n  uint public lastAppliedBlockNumber;\r\n\r\n  // solium-disable mixedcase\r\n  uint public EROIdToFinalize;\r\n  uint public ERUIdToFinalize;\r\n  // solium-enable mixedcase\r\n\r\n  // uint public finalizableEROId = 2^256 - 1;\r\n  // uint public finalizableERUId = 2^256 - 1;\r\n\r\n  // Requestable contract address in child chain\r\n  mapping (address => address) public requestableContracts;\r\n\r\n  /*\r\n   * Constant\r\n   */\r\n  address constant public NULL_ADDRESS = 0x0000000000000000000000000000000000000000;\r\n\r\n  // Cost parameters for development and test\r\n  uint public constant COST_ERO = 0;\r\n  uint public constant COST_ERU = 0;\r\n  uint public constant COST_URB_PREPARE = 0;\r\n  uint public constant COST_URB = 0;\r\n  uint public constant COST_ORB = 0;\r\n  uint public constant COST_NRB = 0;\r\n  uint public constant PREPARE_TIMEOUT = 60; // 60 sec for dev\r\n\r\n  // Challenge periods for computation and withholding\r\n  uint public constant CP_COMPUTATION = 15; // 15 sec for dev\r\n  uint public constant CP_WITHHOLDING = 20; // 20 sec for dev\r\n  uint public constant CP_EXIT = 10; // 10 sec for dev\r\n\r\n  // TODO: develop more concrete cost model\r\n  // Cost parameters for production\r\n  // uint public constant COST_ERO = 0.1 ether;         // cost for invalid exit\r\n  // uint public constant COST_ERU = 0.2 ether;         // cost for fork & rebase\r\n  // uint public constant COST_URB_PREPARE = 0.1 ether; // cost for URB prepare\r\n  // uint public constant COST_URB = 0.9 ether;         // cost for fork & rebase\r\n  // uint public constant COST_ORB = 0.1 ether;         // cost for invalid computation\r\n  // uint public constant COST_NRB = 0.1 ether;         // cost for invalid computation\r\n  // uint public constant PREPARE_TIMEOUT = 1 hours;\r\n\r\n  // // Challenge periods for computation and withholding\r\n  // uint public constant CP_COMPUTATION = 1 days;\r\n  // uint public constant CP_WITHHOLDING = 7 days;\r\n  // uint public constant CP_EXIT = 1 days;\r\n\r\n\r\n  // Gas limit for request trasaction\r\n  uint public constant REQUEST_GAS = 100000;\r\n\r\n  bool public constant isLayer2 = true;\r\n}\r\n\r\n// File: contracts/Layer2Event.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\ncontract Layer2Event {\r\n  event OperatorChanged(address _newOperator);\r\n\r\n  event SessionTimeout(bool userActivated);\r\n\r\n  event Forked(uint newFork, uint epochNumber, uint forkedBlockNumber);\r\n\r\n  /**\r\n   * epochNumber          the number of prepared epoch\r\n   * startBlockNumber     first block number of the epoch.\r\n   * endBlockNumber       last block number of the epoch. It is 0 for ORE' and NRE'.\r\n   * requestStart         first request id of the epoch.\r\n   * requestEnd           last request id of the epoch.\r\n   * epochIsEmpty         true if epoch doesn't have block.\r\n   * isRequest            true for ORE and URE.\r\n   * userActivated        true for URE.\r\n   */\r\n  event EpochPrepared(\r\n    uint forkNumber,\r\n    uint epochNumber,\r\n    uint startBlockNumber,\r\n    uint endBlockNumber,\r\n    uint requestStart,\r\n    uint requestEnd,\r\n    bool epochIsEmpty,\r\n    bool isRequest,\r\n    bool userActivated,\r\n    bool rebase\r\n  );\r\n\r\n  event EpochFilling(\r\n    uint forkNumber,\r\n    uint epochNumber\r\n  );\r\n\r\n  event EpochFilled(\r\n    uint forkNumber,\r\n    uint epochNumber\r\n  );\r\n\r\n  event EpochRebased(\r\n    uint forkNumber,\r\n    uint epochNumber,\r\n    uint startBlockNumber,\r\n    uint endBlockNumber,\r\n    uint requestStart,\r\n    uint requestEnd,\r\n    bool epochIsEmpty,\r\n    bool isRequest,\r\n    bool userActivated\r\n  );\r\n\r\n  event BlockSubmitted(\r\n    uint fork,\r\n    uint epochNumber,\r\n    uint blockNumber,\r\n    bool isRequest,\r\n    bool userActivated\r\n  );\r\n\r\n  event RequestCreated(\r\n    uint requestId,\r\n    address requestor,\r\n    address to,\r\n    uint weiAmount,\r\n    bytes32 trieKey,\r\n    bytes trieValue,\r\n    bool isExit,\r\n    bool userActivated\r\n  );\r\n  event ERUCreated(\r\n    uint requestId,\r\n    address requestor,\r\n    address to,\r\n    bytes trieKey,\r\n    bytes32 trieValue\r\n  );\r\n\r\n  event BlockFinalized(uint forkNumber, uint blockNumber);\r\n  event EpochFinalized(\r\n    uint forkNumber,\r\n    uint epochNumber,\r\n    uint startBlockNumber,\r\n    uint endBlockNumber\r\n  );\r\n\r\n  // emit when exit is finalized. _userActivated is true for ERU\r\n  event RequestFinalized(uint requestId, bool userActivated);\r\n  event RequestApplied(uint requestId, bool userActivated);\r\n  event RequestChallenged(uint requestId, bool userActivated);\r\n\r\n  event RequestableContractMapped(address contractInRootchain, address contractInChildchain);\r\n}\r\n\r\n// File: contracts/Layer2Base.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n/**\r\n * @notice Layer2Base provides functions to be delegated to other handlers,\r\n *         EpochHandler, SubmitHandler.\r\n */\r\ncontract Layer2Base is Layer2Storage, Layer2Event {\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  // solium-disable mixedcase\r\n  // EpochHandler functions\r\n  bytes4 constant PREPARE_TO_SUTMIBT_ORB_SIG = bytes4(keccak256(\"prepareORE()\"));\r\n  bytes4 constant PREPARE_TO_SUTMIBT_NRB_SIG = bytes4(keccak256(\"prepareNRE()\"));\r\n  bytes4 constant PREPARE_TO_SUTMIBT_URB_SIG = bytes4(keccak256(\"prepareToSubmitURB()\"));\r\n  bytes4 constant PREPARE_ORE_AFTER_URE_SIG = bytes4(keccak256(\"prepareOREAfterURE()\"));\r\n  bytes4 constant PREPARE_NRE_AFTER_URE_SIG = bytes4(keccak256(\"prepareNREAfterURE()\"));\r\n\r\n  // SubmitHandler functions\r\n  bytes4 constant SUBMIT_NRE_SIG = bytes4(keccak256(\"submitNRE(uint256,uint256,bytes32,bytes32,bytes32)\"));\r\n  bytes4 constant SUBMIT_ORB_SIG = bytes4(keccak256(\"submitORB(uint256,bytes32,bytes32,bytes32)\"));\r\n  bytes4 constant SUBMIT_URB_SIG = bytes4(keccak256(\"submitURB(uint256,bytes32,bytes32,bytes32)\"));\r\n  // solium-endable mixedcase\r\n\r\n  /**\r\n   * Functions\r\n   */\r\n  // delegate to epoch handler\r\n  function _delegatePrepareORE() internal {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = epochHandler.delegatecall(abi.encodeWithSelector(PREPARE_TO_SUTMIBT_ORB_SIG));\r\n    require(success);\r\n  }\r\n\r\n  // delegate to epoch handler\r\n  function _delegatePrepareNRE() internal {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = epochHandler.delegatecall(abi.encodeWithSelector(PREPARE_TO_SUTMIBT_NRB_SIG));\r\n    // (bool success, bytes memory returnData) = epochHandler.delegatecall(abi.encodeWithSelector(PREPARE_TO_SUTMIBT_NRB_SIG));\r\n    require(success);\r\n  }\r\n\r\n  // delegate to epoch handler\r\n  function _delegatePrepareToSubmitURB() internal {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = epochHandler.delegatecall(abi.encodeWithSelector(PREPARE_TO_SUTMIBT_URB_SIG));\r\n    // (bool success, bytes memory returnData) = epochHandler.delegatecall(abi.encodeWithSelector(PREPARE_TO_SUTMIBT_NRB_SIG));\r\n    require(success);\r\n  }\r\n\r\n  // delegate to epoch handler\r\n  function _delegatePrepareOREAfterURE() internal {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = epochHandler.delegatecall(abi.encodeWithSelector(PREPARE_ORE_AFTER_URE_SIG));\r\n    require(success);\r\n  }\r\n\r\n  // delegate to epoch handler\r\n  function _delegatePrepareNREAfterURE() internal {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = epochHandler.delegatecall(abi.encodeWithSelector(PREPARE_NRE_AFTER_URE_SIG));\r\n    require(success);\r\n  }\r\n\r\n  // delegate to submit handler\r\n  function _delegateSubmitNRE(\r\n    uint _pos1, // forknumber + epochNumber\r\n    uint _pos2, // startBlockNumber + endBlockNumber\r\n    bytes32 _epochStateRoot,\r\n    bytes32 _epochTransactionsRoot,\r\n    bytes32 _epochReceiptsRoot\r\n  )\r\n    internal\r\n    returns (bool success)\r\n  {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = submitHandler.delegatecall(abi.encodeWithSelector(\r\n      SUBMIT_NRE_SIG,\r\n      _pos1,\r\n      _pos2,\r\n      _epochStateRoot,\r\n      _epochTransactionsRoot,\r\n      _epochReceiptsRoot\r\n    ));\r\n    require(success);\r\n    return true;\r\n  }\r\n\r\n  // delegate to submit handler\r\n  function _delegateSubmitORB(\r\n    uint _pos,\r\n    bytes32 _statesRoot,\r\n    bytes32 _transactionsRoot,\r\n    bytes32 _receiptsRoot\r\n  )\r\n    internal\r\n    returns (bool success)\r\n  {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = submitHandler.delegatecall(abi.encodeWithSelector(\r\n      SUBMIT_ORB_SIG,\r\n      _pos,\r\n      _statesRoot,\r\n      _transactionsRoot,\r\n      _receiptsRoot\r\n    ));\r\n    require(success);\r\n    return true;\r\n  }\r\n\r\n  // delegate to submit handler\r\n  function _delegateSubmitURB(\r\n    uint _pos,\r\n    bytes32 _statesRoot,\r\n    bytes32 _transactionsRoot,\r\n    bytes32 _receiptsRoot\r\n  )\r\n    internal\r\n    returns (bool success)\r\n  {\r\n    // solium-disable-next-line security/no-low-level-calls, max-len, no-unused-vars\r\n    (bool success, bytes memory returnData) = submitHandler.delegatecall(abi.encodeWithSelector(\r\n      SUBMIT_URB_SIG,\r\n      _pos,\r\n      _statesRoot,\r\n      _transactionsRoot,\r\n      _receiptsRoot\r\n    ));\r\n    require(success);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/Layer2.sol\r\n\r\npragma solidity ^0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n// import \"./patricia_tree/PatriciaTreeFace.sol\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Layer2 is Layer2Storage, Layer2Event, Layer2Base, MapperRole, SubmitterRole {\r\n  using SafeMath for uint;\r\n  using SafeMath for uint64;\r\n  using Math for *;\r\n  using Data for *;\r\n  using Address for address;\r\n  using BMT for *;\r\n\r\n  /*\r\n   * Modifiers\r\n   */\r\n  modifier onlyOperator() {\r\n    require(msg.sender == operator);\r\n    _;\r\n  }\r\n\r\n  modifier onlyValidCost(uint _expected) {\r\n    require(msg.value >= _expected);\r\n    _;\r\n  }\r\n\r\n  modifier finalizeBlocks() {\r\n    if (!development) {\r\n      _finalizeBlock();\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier checkURBSubmission () {\r\n    Data.Fork storage fork = forks[currentFork];\r\n    if (fork.timestamp + Data.URE_TIMEOUT() < block.timestamp) {\r\n      // TODO: reset fork\r\n      fork.forkedBlock = 0;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyOperatorOrSeigManager () {\r\n    require(msg.sender == operator || msg.sender == seigManager);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * Constructor\r\n   */\r\n  constructor(\r\n    address _epochHandler,\r\n    address _submitHandler,\r\n    address _etherToken,\r\n    bool _development,\r\n    uint _NRELength,\r\n\r\n    // genesis block state\r\n    bytes32 _statesRoot,\r\n    bytes32 _transactionsRoot,\r\n    bytes32 _receiptsRoot\r\n  )\r\n    public\r\n  {\r\n    require(_epochHandler.isContract());\r\n    require(_submitHandler.isContract());\r\n    require(_etherToken.isContract());\r\n\r\n    epochHandler = _epochHandler;\r\n    submitHandler = _submitHandler;\r\n    etherToken = _etherToken;\r\n\r\n    development = _development;\r\n    operator = msg.sender;\r\n    NRELength = _NRELength;\r\n\r\n    Data.Fork storage fork = forks[currentFork];\r\n    Data.PlasmaBlock storage genesis = fork.blocks[0];\r\n    genesis.statesRoot = _statesRoot;\r\n    genesis.transactionsRoot = _transactionsRoot;\r\n    genesis.receiptsRoot = _receiptsRoot;\r\n\r\n    // set up the genesis epoch\r\n    fork.epochs[0].timestamp = uint64(block.timestamp);\r\n    fork.epochs[0].initialized = true;\r\n\r\n    // prepare ORE#2\r\n    fork.epochs[2].isEmpty = true;\r\n    fork.epochs[2].isRequest = true;\r\n\r\n    _doFinalizeBlock(fork, genesis, 0);\r\n    _doFinalizeNRE(fork, 0);\r\n\r\n    _delegatePrepareNRE();\r\n  }\r\n\r\n  /*\r\n   * External Functions\r\n   */\r\n\r\n  function changeOperator(address _operator) external onlyOperatorOrSeigManager {\r\n    operator = _operator;\r\n    emit OperatorChanged(_operator);\r\n  }\r\n\r\n  function addSubmitter(address account) public onlyOperator {\r\n    _addSubmitter(account);\r\n  }\r\n\r\n  function addMapper(address account) public onlyOperator {\r\n    _addMapper(account);\r\n  }\r\n\r\n  function setSeigManager(address account) public onlyOperatorOrSeigManager {\r\n    seigManager = account;\r\n  }\r\n\r\n  /**\r\n   * @notice map requestable contract in child chain\r\n   * NOTE: only operator?\r\n   */\r\n  function mapRequestableContractByOperator(address _layer2, address _childchain)\r\n    external\r\n    onlyMapper\r\n    returns (bool success)\r\n  {\r\n    require(_layer2.isContract());\r\n    require(requestableContracts[_layer2] == address(0));\r\n\r\n    requestableContracts[_layer2] = _childchain;\r\n\r\n    emit RequestableContractMapped(_layer2, _childchain);\r\n    return true;\r\n  }\r\n\r\n  function getNumEROs() external view returns (uint) {\r\n    return EROs.length;\r\n  }\r\n\r\n  function getNumORBs() external view returns (uint) {\r\n    return ORBs.length;\r\n  }\r\n\r\n  function getEROBytes(uint _requestId) public view returns (bytes memory out) {\r\n    Data.Request storage ERO = EROs[_requestId];\r\n\r\n    return ERO.toChildChainRequest(requestableContracts[ERO.to])\r\n      .toTX(_requestId, false)\r\n      .toBytes();\r\n  }\r\n\r\n  /**\r\n   * @notice Declare to submit URB.\r\n   */\r\n  function prepareToSubmitURB()\r\n    public\r\n    payable\r\n    onlyValidCost(COST_URB_PREPARE)\r\n    // finalizeBlocks\r\n  {\r\n    // TODO: change to continuous rebase scheme.\r\n    // disable UAF.\r\n    revert();\r\n    // return false;\r\n    // Layer2Base.prepareToSubmitURB();\r\n  }\r\n\r\n  function submitNRE(\r\n    uint _pos1, // forknumber + epochNumber\r\n    uint _pos2, // startBlockNumber + endBlockNumber\r\n    bytes32 _epochStateRoot,\r\n    bytes32 _epochTransactionsRoot,\r\n    bytes32 _epochReceiptsRoot\r\n  )\r\n    external\r\n    payable\r\n    onlySubmitter\r\n    onlyValidCost(COST_NRB)\r\n    finalizeBlocks\r\n    returns (bool success)\r\n  {\r\n    return Layer2Base._delegateSubmitNRE(\r\n      _pos1,\r\n      _pos2,\r\n      _epochStateRoot,\r\n      _epochTransactionsRoot,\r\n      _epochReceiptsRoot\r\n    );\r\n  }\r\n\r\n  function submitORB(\r\n    uint _pos,\r\n    bytes32 _statesRoot,\r\n    bytes32 _transactionsRoot,\r\n    bytes32 _receiptsRoot\r\n  )\r\n    external\r\n    payable\r\n    onlySubmitter\r\n    onlyValidCost(COST_NRB)\r\n    finalizeBlocks\r\n    returns (bool success)\r\n  {\r\n    return Layer2Base._delegateSubmitORB(\r\n      _pos,\r\n      _statesRoot,\r\n      _transactionsRoot,\r\n      _receiptsRoot\r\n    );\r\n  }\r\n\r\n  function submitURB(\r\n    uint _pos,\r\n    bytes32 _statesRoot,\r\n    bytes32 _transactionsRoot,\r\n    bytes32 _receiptsRoot\r\n  )\r\n    external\r\n    payable\r\n    onlyValidCost(COST_URB)\r\n    returns (bool success)\r\n  {\r\n    // TODO: change to continuous rebase scheme.\r\n    // disable UAF.\r\n    revert();\r\n    return false;\r\n\r\n    // return Layer2Base._delegateSubmitURB(\r\n    //   _pos,\r\n    //   _statesRoot,\r\n    //   _transactionsRoot,\r\n    //   _receiptsRoot\r\n    // );\r\n  }\r\n\r\n  function finalizeBlock() external returns (bool success) {\r\n    require(_finalizeBlock());\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Computation verifier contract reverts the block in case of wrong\r\n   *         computation.\r\n   */\r\n  /* function revertBlock(uint _forkNumber, uint _blockNumber) external {\r\n    // TODO: make a new fork?\r\n  } */\r\n\r\n  function challengeExit(\r\n    uint _forkNumber,\r\n    uint _blockNumber,\r\n    uint _index,\r\n    bytes calldata _receiptData,\r\n    bytes calldata _proof\r\n  ) external {\r\n    Data.Fork storage fork = forks[_forkNumber];\r\n    Data.PlasmaBlock storage pb = fork.blocks[_blockNumber];\r\n\r\n    require(pb.isRequest);\r\n    require(pb.finalized);\r\n\r\n    uint requestId;\r\n    bool userActivated = pb.userActivated;\r\n\r\n    if (userActivated) {\r\n      requestId = _doChallengeExit(pb, URBs[pb.requestBlockId], ERUs, _index, _receiptData, _proof);\r\n      // TODO: dynamic cost for ERU\r\n      msg.sender.transfer(COST_ERU);\r\n    } else {\r\n      requestId = _doChallengeExit(pb, ORBs[pb.requestBlockId], EROs,_index, _receiptData, _proof);\r\n      msg.sender.transfer(COST_ERO);\r\n    }\r\n\r\n    emit RequestChallenged(requestId, userActivated);\r\n  }\r\n\r\n  function _doChallengeExit(\r\n    Data.PlasmaBlock storage _pb,\r\n    Data.RequestBlock storage _rb,\r\n    Data.Request[] storage _rs,\r\n    uint _index,\r\n    bytes memory _receiptData,\r\n    bytes memory _proof\r\n  )\r\n    internal\r\n    returns (uint requestId)\r\n  {\r\n    requestId = _rb.requestStart + _index;\r\n    require(requestId <= _rb.requestEnd);\r\n\r\n    Data.Request storage r = _rs[requestId];\r\n\r\n    require(_pb.finalizedAt + CP_EXIT > block.timestamp);\r\n    require(_pb.finalized);\r\n    require(!r.challenged);\r\n    require(!r.finalized);\r\n\r\n    bytes32 leaf = keccak256(_receiptData);\r\n\r\n    require(_receiptData.toReceiptStatus() == 0);\r\n    if (!development) {\r\n      require(BMT.checkMembership(leaf, _index, _pb.receiptsRoot, _proof));\r\n    }\r\n\r\n    r.challenged = true;\r\n\r\n    return requestId;\r\n  }\r\n\r\n  /**\r\n   * @notice It challenges on NRBs containing null address transaction.\r\n   */\r\n  function challengeNullAddress(\r\n    uint _blockNumber,\r\n    bytes calldata _key,\r\n    bytes calldata _txByte, // RLP encoded transaction\r\n    uint _branchMask,\r\n    bytes32[] calldata  _siblings\r\n  ) external {\r\n    Data.Fork storage fork = forks[currentFork];\r\n    Data.PlasmaBlock storage pb = fork.blocks[_blockNumber];\r\n\r\n    // check if the plasma block is NRB\r\n    require(!pb.isRequest);\r\n\r\n    // check if challenge period does not end yet\r\n    require(pb.timestamp + CP_COMPUTATION > block.timestamp);\r\n\r\n    // PatriciaTreeFace trie;\r\n    // if (pb.userActivated) {\r\n    //   trie = PatriciaTreeFace(URBs[pb.requestBlockId].trie);\r\n    // } else {\r\n    //   trie = PatriciaTreeFace(ORBs[pb.requestBlockId].trie);\r\n    // }\r\n\r\n    // Data.TX memory txData = Data.toTX(_txByte);\r\n    // require(txData.isNATX());\r\n\r\n    // TODO: use patricia verify library\r\n    // require(trie.verifyProof(pb.transactionsRoot, _key, _txByte, _branchMask, _siblings));\r\n\r\n    // TODO: fork? penalize?\r\n  }\r\n\r\n  /*\r\n   * Public Functions\r\n   */\r\n  function startExit(\r\n    address _to,\r\n    bytes32 _trieKey,\r\n    bytes memory _trieValue\r\n  )\r\n    public\r\n    payable\r\n    onlyValidCost(COST_ERO)\r\n    returns (bool success)\r\n  {\r\n    uint requestId;\r\n    requestId = _storeRequest(EROs, ORBs, _to, 0, _trieKey, _trieValue, true, false);\r\n\r\n    emit RequestCreated(requestId, msg.sender, _to, 0, _trieKey, _trieValue, true, false);\r\n    return true;\r\n  }\r\n\r\n  function startEnter(\r\n    address _to,\r\n    bytes32 _trieKey,\r\n    bytes memory _trieValue\r\n  )\r\n    public\r\n    payable\r\n    returns (bool success)\r\n  {\r\n    uint requestId;\r\n    uint weiAmount = msg.value;\r\n    requestId = _storeRequest(EROs, ORBs, _to, weiAmount, _trieKey, _trieValue, false, false);\r\n    numEnterForORB += 1;\r\n\r\n    Data.Fork storage fork = forks[currentFork];\r\n\r\n    emit RequestApplied(requestId, false);\r\n    emit RequestCreated(requestId, msg.sender, _to, weiAmount, _trieKey, _trieValue, false, false);\r\n    return true;\r\n  }\r\n\r\n  function makeERU(\r\n    address _to,\r\n    bytes32 _trieKey,\r\n    bytes memory _trieValue\r\n  )\r\n    public\r\n    payable\r\n    onlyValidCost(COST_ERU)\r\n    returns (bool success)\r\n  {\r\n    uint requestId;\r\n    requestId = _storeRequest(ERUs, URBs, _to, 0, _trieKey, _trieValue, true, true);\r\n\r\n    emit RequestCreated(requestId, msg.sender, _to, 0, _trieKey, _trieValue, true, true);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Finalize a request if request block including it\r\n   *         is finalized.\r\n   * TODO: refactor implementation\r\n   */\r\n  function finalizeRequest() public returns (bool success) {\r\n    uint requestId;\r\n    Data.Fork storage fork = forks[lastAppliedForkNumber];\r\n    uint epochNumber = lastAppliedEpochNumber;\r\n\r\n    require(lastAppliedBlockNumber <= fork.lastBlock);\r\n\r\n    Data.PlasmaBlock storage pb = fork.blocks[lastAppliedBlockNumber];\r\n    Data.Epoch storage epoch = fork.epochs[epochNumber];\r\n\r\n    // TODO: execute after finding next request block\r\n    // find next fork\r\n    if (fork.forkedBlock != 0 && lastAppliedBlockNumber >= fork.forkedBlock) {\r\n      lastAppliedForkNumber += 1;\r\n      fork = forks[lastAppliedForkNumber];\r\n\r\n      epochNumber = fork.firstEpoch;\r\n      epoch = fork.epochs[epochNumber];\r\n\r\n      lastAppliedBlockNumber = fork.firstBlock;\r\n      lastAppliedEpochNumber = epochNumber;\r\n\r\n      pb = fork.blocks[lastAppliedBlockNumber];\r\n    }\r\n\r\n    // find next request block\r\n    if (!pb.isRequest) {\r\n      if (epochNumber == 0) {\r\n        epochNumber = firstNonEmptyRequestEpoch[lastAppliedForkNumber];\r\n      } else {\r\n        epochNumber = fork.epochs[epochNumber].RE.nextEpoch;\r\n      }\r\n      require(epochNumber != 0);\r\n\r\n      epoch = fork.epochs[epochNumber];\r\n      lastAppliedBlockNumber = epoch.startBlockNumber;\r\n      pb = fork.blocks[lastAppliedBlockNumber];\r\n    } else {\r\n      epochNumber = pb.epochNumber;\r\n      epoch = fork.epochs[epochNumber];\r\n    }\r\n\r\n    lastAppliedEpochNumber = epochNumber;\r\n\r\n    require(!epoch.isEmpty);\r\n    require(epoch.isRequest);\r\n    require(pb.isRequest);\r\n    require(pb.finalized);\r\n    require(pb.finalizedAt + CP_EXIT <= block.timestamp);\r\n\r\n    // apply ERU\r\n    if (pb.userActivated) {\r\n      requestId = ERUIdToFinalize;\r\n\r\n      require(ERUs.length > requestId);\r\n\r\n      Data.Request storage ERU = ERUs[requestId];\r\n      Data.RequestBlock storage URB = URBs[pb.requestBlockId];\r\n\r\n      require(URB.requestStart <= requestId && requestId <= URB.requestEnd);\r\n\r\n      // check next block\r\n      if (requestId == URB.requestEnd) {\r\n        if (fork.forkedBlock > 0 && lastAppliedBlockNumber == fork.forkedBlock - 1) {\r\n          lastAppliedForkNumber += 1;\r\n        }\r\n\r\n        lastAppliedBlockNumber += 1;\r\n      }\r\n\r\n      ERUIdToFinalize = requestId + 1;\r\n\r\n      if (ERU.isExit && !ERU.challenged) {\r\n        // NOTE: do not check it reverted or not?\r\n        ERU.applyRequestInRootChain(requestId);\r\n        // TODO: dynamic cost and bond release period\r\n        ERU.requestor.transfer(COST_ERU);\r\n        emit RequestApplied(requestId, true);\r\n      }\r\n      ERU.finalized = true;\r\n\r\n      emit RequestFinalized(requestId, true);\r\n      return true;\r\n    }\r\n\r\n    // apply ERO\r\n    requestId = EROIdToFinalize;\r\n\r\n    require(EROs.length > requestId);\r\n\r\n    Data.RequestBlock storage ORB = ORBs[pb.requestBlockId];\r\n\r\n    require(ORB.requestStart <= requestId && requestId <= ORB.requestEnd);\r\n\r\n    // check next block\r\n    if (requestId == ORB.requestEnd) {\r\n      // TODO: iterator blocks by NRE length for NRE'\r\n      if (fork.forkedBlock > 0 && lastAppliedBlockNumber == fork.forkedBlock - 1) {\r\n        lastAppliedForkNumber += 1;\r\n      }\r\n\r\n      lastAppliedBlockNumber += 1;\r\n    }\r\n\r\n    Data.Request storage ERO = EROs[requestId];\r\n    EROIdToFinalize = requestId + 1;\r\n    ERO.finalized = true;\r\n\r\n    if (ERO.isExit && !ERO.challenged) {\r\n      ERO.applyRequestInRootChain(requestId);\r\n      ERO.requestor.transfer(COST_ERO);\r\n      emit RequestApplied(requestId, false);\r\n    }\r\n\r\n    emit RequestFinalized(requestId, false);\r\n    return true;\r\n  }\r\n\r\n  function finalizeRequests(uint n) external returns (bool success) {\r\n    for (uint i = 0; i < n; i++) {\r\n      require(finalizeRequest());\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice return the max number of request\r\n   */\r\n  function MAX_REQUESTS() external pure returns (uint maxRequests) {\r\n    return Data.MAX_REQUESTS();\r\n  }\r\n\r\n  function lastBlock(uint forkNumber) public view returns (uint lastBlock) {\r\n    return forks[forkNumber].lastBlock;\r\n  }\r\n\r\n  function lastEpoch(uint forkNumber) public view returns (uint lastBlock) {\r\n    return forks[forkNumber].lastEpoch;\r\n  }\r\n\r\n  function getEpoch(\r\n    uint forkNumber,\r\n    uint epochNumber\r\n  ) external view returns (\r\n    Data.Epoch memory epoch\r\n  ) {\r\n    return forks[forkNumber].epochs[epochNumber];\r\n  }\r\n\r\n  function getLastEpoch() public view returns (Data.Epoch memory) {\r\n    return forks[currentFork].epochs[forks[currentFork].lastEpoch];\r\n  }\r\n\r\n  function getBlock(\r\n    uint forkNumber,\r\n    uint blockNumber\r\n  ) public view returns (Data.PlasmaBlock memory) {\r\n    return forks[forkNumber].blocks[blockNumber];\r\n  }\r\n\r\n  function getBlockFinalizedAt(\r\n    uint forkNumber,\r\n    uint blockNumber\r\n  ) public view returns (uint) {\r\n    return forks[forkNumber].blocks[blockNumber].finalizedAt;\r\n  }\r\n\r\n  function getLastFinalizedBlock(uint forkNumber) public view returns (uint) {\r\n    return forks[forkNumber].lastFinalizedBlock;\r\n  }\r\n\r\n  function getLastFinalizedEpoch(uint forkNumber) public view returns (uint) {\r\n    return forks[forkNumber].lastFinalizedEpoch;\r\n  }\r\n\r\n  /**\r\n   * @notice return true if the chain is forked by URB\r\n   */\r\n  function forked(uint _forkNumber) public view returns (bool result) {\r\n    return _forkNumber != currentFork;\r\n  }\r\n\r\n  /**\r\n   * @notice return true if the request is finalized\r\n   */\r\n  function getRequestFinalized(uint _requestId, bool _userActivated) public view returns (bool finalized) {\r\n    if (_userActivated) {\r\n      ERUs[_requestId].finalized;\r\n    }\r\n\r\n    return EROs[_requestId].finalized;\r\n  }\r\n\r\n  /*\r\n   * Internal Functions\r\n   */\r\n  function _storeRequest(\r\n    Data.Request[] storage _requests,\r\n    Data.RequestBlock[] storage _rbs,\r\n    address _to,\r\n    uint _weiAmount,\r\n    bytes32 _trieKey,\r\n    bytes memory _trieValue,\r\n    bool _isExit,\r\n    bool _userActivated\r\n  )\r\n    internal\r\n    returns (uint requestId)\r\n  {\r\n    // trieValue cannot be longer than 1KB.\r\n    require(_trieValue.length <= 1024);\r\n\r\n    bool isTransfer = _to == etherToken;\r\n\r\n    // check parameters for simple ether transfer and message-call\r\n    require(isTransfer && !_isExit || (requestableContracts[_to] != address(0)));\r\n\r\n    requestId = _requests.length++;\r\n    Data.Request storage r = _requests[requestId];\r\n\r\n    r.requestor = msg.sender;\r\n    r.to = _to;\r\n    r.timestamp = uint64(block.timestamp);\r\n    r.isExit = _isExit;\r\n    r.isTransfer = isTransfer;\r\n    r.value = uint128(_weiAmount);\r\n    r.trieKey = _trieKey;\r\n    r.trieValue = _trieValue;\r\n\r\n    // apply message-call in case of enter request.\r\n    if (!_isExit) {\r\n      require(r.applyRequestInRootChain(requestId));\r\n    }\r\n\r\n    uint requestBlockId = _rbs.length == 0 ? _rbs.length++ : _rbs.length - 1;\r\n\r\n    Data.RequestBlock storage rb = _rbs[requestBlockId];\r\n\r\n    // make a new RequestBlock.\r\n    if (rb.submitted || rb.requestEnd - rb.requestStart + 1 == Data.MAX_REQUESTS()) {\r\n      rb.submitted = true;\r\n      rb = _rbs[_rbs.length++];\r\n      rb.requestStart = uint64(requestId);\r\n    }\r\n\r\n    rb.init();\r\n\r\n    rb.requestEnd = uint64(requestId);\r\n    if (!_isExit) {\r\n      rb.numEnter += 1;\r\n    }\r\n\r\n    if (isTransfer && !_isExit) {\r\n      rb.addRequest(r, r.toChildChainRequest(msg.sender), requestId);\r\n    } else {\r\n      rb.addRequest(r, r.toChildChainRequest(requestableContracts[_to]), requestId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice finalize a block if possible.\r\n   */\r\n  function _finalizeBlock() internal returns (bool) {\r\n    Data.Fork storage fork = forks[currentFork];\r\n\r\n    // short circuit if waiting URBs\r\n    if (fork.forkedBlock != 0) {\r\n      return false;\r\n    }\r\n\r\n    uint blockNumber = Math.max(fork.firstBlock, fork.lastFinalizedBlock + 1);\r\n\r\n    // short circuit if all blocks are submitted yet\r\n    if (blockNumber > fork.lastBlock) {\r\n      return false;\r\n    }\r\n\r\n    Data.PlasmaBlock storage pb = fork.blocks[blockNumber];\r\n\r\n    // short circuit if the block is under challenge\r\n    if (pb.challenging) {\r\n      return false;\r\n    }\r\n\r\n    // 1. finalize request block\r\n    if (pb.isRequest) {\r\n      // short circuit if challenge period doesn't end\r\n      if (pb.timestamp + CP_COMPUTATION > block.timestamp) {\r\n        return false;\r\n      }\r\n\r\n      // finalize block\r\n      _doFinalizeBlock(fork, pb, blockNumber);\r\n      return true;\r\n    }\r\n\r\n    // 2. finalize non request epoch\r\n    uint nextEpochNumber = fork.lastFinalizedEpoch + 1;\r\n    while (fork.epochs[nextEpochNumber].isRequest) {\r\n      nextEpochNumber += 1;\r\n    }\r\n\r\n    // if the first block of the next request epoch is finalized, finalize all\r\n    // blocks of the current non request epoch.\r\n    if (_checkFinalizableNRE(fork, nextEpochNumber)) {\r\n      _doFinalizeNRE(fork, nextEpochNumber);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @notice return true if NRE can be finalized.\r\n   */\r\n  function _checkFinalizableNRE(Data.Fork storage fork, uint _epochNumber) internal view returns (bool) {\r\n    // short circuit if epoch is not submitted yet\r\n    if (_epochNumber > fork.lastEpoch) {\r\n      return false;\r\n    }\r\n\r\n    Data.Epoch storage epoch = fork.epochs[_epochNumber];\r\n\r\n    // short circuit if epoch is not initialized\r\n    if (!epoch.initialized) {\r\n      return false;\r\n    }\r\n\r\n    // short circuit if epoch is not NRE\r\n    if (epoch.isRequest) {\r\n      return false;\r\n    }\r\n\r\n    // short circuit if epoch is challenged or under challenge\r\n    if (epoch.NRE.challenging || epoch.NRE.challenged) {\r\n      return false;\r\n    }\r\n\r\n    // return if challenge period end\r\n    return epoch.NRE.submittedAt + CP_WITHHOLDING <= block.timestamp;\r\n    // return true;\r\n  }\r\n\r\n  /**\r\n   * @notice finalize a block\r\n   */\r\n  function _doFinalizeBlock(\r\n    Data.Fork storage _f,\r\n    Data.PlasmaBlock storage _pb,\r\n    uint _blockNumber\r\n  ) internal {\r\n    _pb.finalized = true;\r\n    _pb.finalizedAt = uint64(block.timestamp);\r\n\r\n    _f.lastFinalizedBlock = uint64(_blockNumber);\r\n    _f.lastFinalizedEpoch = uint64(_pb.epochNumber);\r\n\r\n    emit BlockFinalized(currentFork, _blockNumber);\r\n  }\r\n\r\n  /**\r\n   * @notice finalize all blocks in the non request epoch\r\n   */\r\n  function _doFinalizeNRE(\r\n    Data.Fork storage _f,\r\n    uint _epochNumber\r\n  ) internal {\r\n    Data.Epoch storage epoch = _f.epochs[_epochNumber];\r\n\r\n    epoch.NRE.finalized = true;\r\n    epoch.NRE.finalizedAt = uint64(block.timestamp);\r\n\r\n    _f.lastFinalizedBlock = uint64(epoch.endBlockNumber);\r\n    _f.lastFinalizedEpoch = uint64(_epochNumber);\r\n\r\n    // a single EpochFinalized event replaces lots of BlockFinalized events.\r\n    emit EpochFinalized(currentFork, _epochNumber, epoch.startBlockNumber, epoch.endBlockNumber);\r\n\r\n    return;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_epochHandler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_submitHandler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_etherToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_development\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_NRELength\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_statesRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_receiptsRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"BlockFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fork\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRequest\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"}],\"name\":\"BlockSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"trieKey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"trieValue\",\"type\":\"bytes32\"}],\"name\":\"ERUCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"}],\"name\":\"EpochFilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"}],\"name\":\"EpochFilling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlockNumber\",\"type\":\"uint256\"}],\"name\":\"EpochFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"epochIsEmpty\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRequest\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rebase\",\"type\":\"bool\"}],\"name\":\"EpochPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"epochIsEmpty\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRequest\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"}],\"name\":\"EpochRebased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFork\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forkedBlockNumber\",\"type\":\"uint256\"}],\"name\":\"Forked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MapperAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MapperRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"}],\"name\":\"RequestApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"}],\"name\":\"RequestChallenged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"trieKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"trieValue\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExit\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"}],\"name\":\"RequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"}],\"name\":\"RequestFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractInRootchain\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractInChildchain\",\"type\":\"address\"}],\"name\":\"RequestableContractMapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"}],\"name\":\"SessionTimeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SubmitterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SubmitterRemoved\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST_ERO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST_ERU\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST_NRB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST_ORB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST_URB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COST_URB_PREPARE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CP_COMPUTATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CP_EXIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CP_WITHHOLDING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EROIdToFinalize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"EROs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTransfer\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenged\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"address payable\",\"name\":\"requestor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trieKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"trieValue\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERUIdToFinalize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ERUs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isExit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTransfer\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenged\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"address payable\",\"name\":\"requestor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trieKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"trieValue\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_REQUESTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRequests\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NRELength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NULL_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ORBs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"submitted\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"numEnter\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"epochNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"requestStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"requestEnd\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"trie\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PREPARE_TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REQUEST_GAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"URBs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"submitted\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"numEnter\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"epochNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"requestStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"requestEnd\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"trie\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMapper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addSubmitter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_forkNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_receiptData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"challengeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_key\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_txByte\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_branchMask\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_siblings\",\"type\":\"bytes32[]\"}],\"name\":\"challengeNullAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentFork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"development\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"finalizeRequests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"firstFilledORENumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"firstNonEmptyRequestEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_forkNumber\",\"type\":\"uint256\"}],\"name\":\"forked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forks\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"forkedBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"firstEpoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastEpoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"firstBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastFinalizedEpoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastFinalizedBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"firstEnterEpoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastEnterEpoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextBlockToRebase\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"rebased\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getBlock\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"epochNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"requestBlockId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finalizedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"referenceBlock\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"statesRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"receiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isRequest\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenged\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenging\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"}],\"internalType\":\"struct Data.PlasmaBlock\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getBlockFinalizedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getEROBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"out\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"}],\"name\":\"getEpoch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"startBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isEmpty\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRequest\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rebase\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"requestStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"requestEnd\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"firstRequestBlockId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"numEnter\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextEnterEpoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextEpoch\",\"type\":\"uint64\"}],\"internalType\":\"struct Data.RequestEpochMeta\",\"name\":\"RE\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"epochStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"epochTransactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"epochReceiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"submittedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finalizedAt\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenging\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenged\",\"type\":\"bool\"}],\"internalType\":\"struct Data.NonRequestEpochMeta\",\"name\":\"NRE\",\"type\":\"tuple\"}],\"internalType\":\"struct Data.Epoch\",\"name\":\"epoch\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastEpoch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"startBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isEmpty\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRequest\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"userActivated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rebase\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"requestStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"requestEnd\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"firstRequestBlockId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"numEnter\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextEnterEpoch\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextEpoch\",\"type\":\"uint64\"}],\"internalType\":\"struct Data.RequestEpochMeta\",\"name\":\"RE\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"epochStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"epochTransactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"epochReceiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"submittedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finalizedAt\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenging\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"challenged\",\"type\":\"bool\"}],\"internalType\":\"struct Data.NonRequestEpochMeta\",\"name\":\"NRE\",\"type\":\"tuple\"}],\"internalType\":\"struct Data.Epoch\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"}],\"name\":\"getLastFinalizedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"}],\"name\":\"getLastFinalizedEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumEROs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumORBs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_userActivated\",\"type\":\"bool\"}],\"name\":\"getRequestFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLayer2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMapper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSubmitter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastAppliedBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastAppliedEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastAppliedForkNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forkNumber\",\"type\":\"uint256\"}],\"name\":\"lastEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastNonEmptyRequestEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_trieKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_trieValue\",\"type\":\"bytes\"}],\"name\":\"makeERU\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_layer2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_childchain\",\"type\":\"address\"}],\"name\":\"mapRequestableContractByOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numEnterForORB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"prepareToSubmitURB\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMapper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceSubmitter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requestableContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seigManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setSeigManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_trieKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_trieValue\",\"type\":\"bytes\"}],\"name\":\"startEnter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_trieKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_trieValue\",\"type\":\"bytes\"}],\"name\":\"startExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submitHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pos1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pos2\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_epochStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_epochTransactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_epochReceiptsRoot\",\"type\":\"bytes32\"}],\"name\":\"submitNRE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pos\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_statesRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_receiptsRoot\",\"type\":\"bytes32\"}],\"name\":\"submitORB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pos\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_statesRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_receiptsRoot\",\"type\":\"bytes32\"}],\"name\":\"submitURB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"Layer2","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000a2d8bf53ff0e6b208fddd2696b156a7ccb4d1a80000000000000000000000004b01361e3bb5c1856103ce7fc1c923b6adcc3eed0000000000000000000000005c642140a3b6fa39dfd1aa9eba6c5239f5c457d500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002db431b544b2f5468e3f771d7843d9c5df3b4edcf8bc1c599f18f0b4ea8709bc356e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b42156e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bfe268b1a951973c135b3127ddf36b187f7ab4cdf0aca2a2f9f73df284680013"}]}