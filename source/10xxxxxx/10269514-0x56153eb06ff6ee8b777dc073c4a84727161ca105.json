{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/ZkSync.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeMathUInt128.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nimport \\\"./Storage.sol\\\";\\nimport \\\"./Config.sol\\\";\\nimport \\\"./Events.sol\\\";\\n\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title zkSync main contract\\n/// @author Matter Labs\\ncontract ZkSync is UpgradeableMaster, Storage, Config, Events, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeMathUInt128 for uint128;\\n\\n    bytes32 public constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n    // Upgrade functional\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint) {\\n        return UPGRADE_NOTICE_PERIOD;\\n    }\\n\\n    /// @notice Notification that upgrade notice period started\\n    function upgradeNoticePeriodStarted() external {\\n\\n    }\\n\\n    /// @notice Notification that upgrade preparation status is activated\\n    function upgradePreparationStarted() external {\\n        upgradePreparationActive = true;\\n        upgradePreparationActivationTime = now;\\n    }\\n\\n    /// @notice Notification that upgrade canceled\\n    function upgradeCanceled() external {\\n        upgradePreparationActive = false;\\n        upgradePreparationActivationTime = 0;\\n    }\\n\\n    /// @notice Notification that upgrade finishes\\n    function upgradeFinishes() external {\\n        upgradePreparationActive = false;\\n        upgradePreparationActivationTime = 0;\\n    }\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool) {\\n        return !exodusMode && totalOpenPriorityRequests == 0;\\n    }\\n\\n    /// @notice Franklin contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    /// _governanceAddress The address of Governance contract\\n    /// _verifierAddress The address of Verifier contract\\n    /// _ // FIXME: remove _genesisAccAddress\\n    /// _genesisRoot Genesis blocks (first block) root\\n    function initialize(bytes calldata initializationParameters) external {\\n        initializeReentrancyGuard();\\n\\n        (\\n        address _governanceAddress,\\n        address _verifierAddress,\\n        bytes32 _genesisRoot\\n        ) = abi.decode(initializationParameters, (address, address, bytes32));\\n\\n        verifier = Verifier(_verifierAddress);\\n        governance = Governance(_governanceAddress);\\n\\n        blocks[0].stateRoot = _genesisRoot;\\n    }\\n\\n    /// @notice zkSync contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {\\n        revert(\\\"upgzk\\\"); // it is the first version, upgrade is not supported, use initialize\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: will revert if transfer call fails or rollup balance difference (before and after transfer) is bigger than _maxAmount\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @param _maxAmount Maximum possible amount of tokens to transfer to this account\\n    function withdrawERC20Guarded(IERC20 _token, address _to, uint128 _amount, uint128 _maxAmount) external returns (uint128 withdrawnAmount) {\\n        require(msg.sender == address(this), \\\"wtg10\\\"); // wtg10 - can be called only from this contract as one \\\"external\\\" call (to revert all this function state changes if it is needed)\\n\\n        uint256 balance_before = _token.balanceOf(address(this));\\n        require(Utils.sendERC20(_token, _to, _amount), \\\"wtg11\\\"); // wtg11 - ERC20 transfer fails\\n        uint256 balance_after = _token.balanceOf(address(this));\\n        uint256 balance_diff = balance_before.sub(balance_after);\\n        require(balance_diff <= _maxAmount, \\\"wtg12\\\"); // wtg12 - rollup balance difference (before and after transfer) is bigger than _maxAmount\\n\\n        return SafeCast.toUint128(balance_diff);\\n    }\\n\\n    /// @notice executes pending withdrawals\\n    /// @param _n The number of withdrawals to complete starting from oldest\\n    function completeWithdrawals(uint32 _n) external nonReentrant {\\n        // TODO: when switched to multi validators model we need to add incentive mechanism to call complete.\\n        uint32 toProcess = Utils.minU32(_n, numberOfPendingWithdrawals);\\n        uint32 startIndex = firstPendingWithdrawalIndex;\\n        numberOfPendingWithdrawals -= toProcess;\\n        firstPendingWithdrawalIndex += toProcess;\\n\\n        for (uint32 i = startIndex; i < startIndex + toProcess; ++i) {\\n            uint16 tokenId = pendingWithdrawals[i].tokenId;\\n            address to = pendingWithdrawals[i].to;\\n            // send fails are ignored hence there is always a direct way to withdraw.\\n            delete pendingWithdrawals[i];\\n\\n            bytes22 packedBalanceKey = packAddressAndTokenId(to, tokenId);\\n            uint128 amount = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n            // amount is zero means funds has been withdrawn with withdrawETH or withdrawERC20\\n            if (amount != 0) {\\n                balancesToWithdraw[packedBalanceKey].balanceToWithdraw -= amount;\\n                bool sent = false;\\n                if (tokenId == 0) {\\n                    address payable toPayable = address(uint160(to));\\n                    sent = Utils.sendETHNoRevert(toPayable, amount);\\n                } else {\\n                    address tokenAddr = governance.tokenAddresses(tokenId);\\n                    // we can just check that call not reverts because it wants to withdraw all amount\\n                    (sent, ) = address(this).call.gas(ERC20_WITHDRAWAL_GAS_LIMIT)(\\n                        abi.encodeWithSignature(\\\"withdrawERC20Guarded(address,address,uint128,uint128)\\\", tokenAddr, to, amount, amount)\\n                    );\\n                }\\n                if (!sent) {\\n                    balancesToWithdraw[packedBalanceKey].balanceToWithdraw += amount;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Accrues users balances from deposit priority requests in Exodus mode\\n    /// @dev WARNING: Only for Exodus mode\\n    /// @dev Canceling may take several separate transactions to be completed\\n    /// @param _n number of requests to process\\n    function cancelOutstandingDepositsForExodusMode(uint64 _n) external nonReentrant {\\n        require(exodusMode, \\\"coe01\\\"); // exodus mode not active\\n        uint64 toProcess = Utils.minU64(totalOpenPriorityRequests, _n);\\n        require(toProcess > 0, \\\"coe02\\\"); // no deposits to process\\n        for (uint64 id = firstPriorityRequestId; id < firstPriorityRequestId + toProcess; id++) {\\n            if (priorityRequests[id].opType == Operations.OpType.Deposit) {\\n                Operations.Deposit memory op = Operations.readDepositPubdata(priorityRequests[id].pubData);\\n                bytes22 packedBalanceKey = packAddressAndTokenId(op.owner, op.tokenId);\\n                balancesToWithdraw[packedBalanceKey].balanceToWithdraw += op.amount;\\n            }\\n            delete priorityRequests[id];\\n        }\\n        firstPriorityRequestId += toProcess;\\n        totalOpenPriorityRequests -= toProcess;\\n    }\\n\\n    /// @notice Deposit ETH to Layer 2 - transfer ether from user into contract, validate it, register deposit\\n    /// @param _franklinAddr The receiver Layer 2 address\\n    function depositETH(address _franklinAddr) external payable nonReentrant {\\n        requireActive();\\n        registerDeposit(0, SafeCast.toUint128(msg.value), _franklinAddr);\\n    }\\n\\n    /// @notice Withdraw ETH to Layer 1 - register withdrawal and transfer ether to sender\\n    /// @param _amount Ether amount to withdraw\\n    function withdrawETH(uint128 _amount) external nonReentrant {\\n        registerWithdrawal(0, _amount, msg.sender);\\n        (bool success, ) = msg.sender.call.value(_amount)(\\\"\\\");\\n        require(success, \\\"fwe11\\\"); // ETH withdraw failed\\n    }\\n\\n    /// @notice Deposit ERC20 token to Layer 2 - transfer ERC20 tokens from user into contract, validate it, register deposit\\n    /// @param _token Token address\\n    /// @param _amount Token amount\\n    /// @param _franklinAddr Receiver Layer 2 address\\n    function depositERC20(IERC20 _token, uint104 _amount, address _franklinAddr) external nonReentrant {\\n        requireActive();\\n\\n        // Get token id by its address\\n        uint16 tokenId = governance.validateTokenAddress(address(_token));\\n\\n        uint256 balance_before = _token.balanceOf(address(this));\\n        require(_token.transferFrom(msg.sender, address(this), SafeCast.toUint128(_amount)), \\\"fd012\\\"); // token transfer failed deposit\\n        uint256 balance_after = _token.balanceOf(address(this));\\n        uint128 deposit_amount = SafeCast.toUint128(balance_after.sub(balance_before));\\n\\n        registerDeposit(tokenId, deposit_amount, _franklinAddr);\\n    }\\n\\n    /// @notice Withdraw ERC20 token to Layer 1 - register withdrawal and transfer ERC20 to sender\\n    /// @param _token Token address\\n    /// @param _amount amount to withdraw\\n    function withdrawERC20(IERC20 _token, uint128 _amount) external nonReentrant {\\n        uint16 tokenId = governance.validateTokenAddress(address(_token));\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, tokenId);\\n        uint128 balance = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n        uint128 withdrawnAmount = this.withdrawERC20Guarded(_token, msg.sender, _amount, balance);\\n        registerWithdrawal(tokenId, withdrawnAmount, msg.sender);\\n    }\\n\\n    /// @notice Register full exit request - pack pubdata, add priority request\\n    /// @param _accountId Numerical id of the account\\n    /// @param _token Token address, 0 address for ether\\n    function fullExit (uint32 _accountId, address _token) external nonReentrant {\\n        requireActive();\\n        require(_accountId <= MAX_ACCOUNT_ID, \\\"fee11\\\");\\n\\n        uint16 tokenId;\\n        if (_token == address(0)) {\\n            tokenId = 0;\\n        } else {\\n            tokenId = governance.validateTokenAddress(_token);\\n        }\\n\\n        // Priority Queue request\\n        Operations.FullExit memory op = Operations.FullExit({\\n            accountId:  _accountId,\\n            owner:      msg.sender,\\n            tokenId:    tokenId,\\n            amount:     0 // unknown at this point\\n        });\\n        bytes memory pubData = Operations.writeFullExitPubdata(op);\\n        addPriorityRequest(Operations.OpType.FullExit, pubData);\\n\\n        // User must fill storage slot of balancesToWithdraw(msg.sender, tokenId) with nonzero value\\n        // In this case operator should just overwrite this slot during confirming withdrawal\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, tokenId);\\n        balancesToWithdraw[packedBalanceKey].gasReserveValue = 0xff;\\n    }\\n\\n    /// @notice Commit block - collect onchain operations, create its commitment, emit BlockCommit event\\n    /// @param _blockNumber Block number\\n    /// @param _feeAccount Account to collect fees\\n    /// @param _newBlockInfo New state of the block. (first element is the account tree root hash, rest of the array is reserved for the future)\\n    /// @param _publicData Operations pubdata\\n    /// @param _ethWitness Data passed to ethereum outside pubdata of the circuit.\\n    /// @param _ethWitnessSizes Amount of eth witness bytes for the corresponding operation.\\n    function commitBlock(\\n        uint32 _blockNumber,\\n        uint32 _feeAccount,\\n        bytes32[] calldata _newBlockInfo,\\n        bytes calldata _publicData,\\n        bytes calldata _ethWitness,\\n        uint32[] calldata _ethWitnessSizes\\n    ) external nonReentrant {\\n        requireActive();\\n        require(_blockNumber == totalBlocksCommitted + 1, \\\"fck11\\\"); // only commit next block\\n        governance.requireActiveValidator(msg.sender);\\n        require(_newBlockInfo.length == 1, \\\"fck13\\\"); // This version of the contract expects only account tree root hash\\n\\n        bytes memory publicData = _publicData;\\n\\n        // Unpack onchain operations and store them.\\n        // Get priority operations number for this block.\\n        uint64 prevTotalCommittedPriorityRequests = totalCommittedPriorityRequests;\\n\\n        bytes32 withdrawalsDataHash = collectOnchainOps(_blockNumber, publicData, _ethWitness, _ethWitnessSizes);\\n\\n        uint64 nPriorityRequestProcessed = totalCommittedPriorityRequests - prevTotalCommittedPriorityRequests;\\n\\n        createCommittedBlock(_blockNumber, _feeAccount, _newBlockInfo[0], publicData, withdrawalsDataHash, nPriorityRequestProcessed);\\n        totalBlocksCommitted++;\\n\\n        emit BlockCommit(_blockNumber);\\n    }\\n\\n    /// @notice Block verification.\\n    /// @notice Verify proof -> process onchain withdrawals (accrue balances from withdrawals) -> remove priority requests\\n    /// @param _blockNumber Block number\\n    /// @param _proof Block proof\\n    /// @param _withdrawalsData Block withdrawals data\\n    function verifyBlock(uint32 _blockNumber, uint256[] calldata _proof, bytes calldata _withdrawalsData)\\n        external nonReentrant\\n    {\\n        requireActive();\\n        require(_blockNumber == totalBlocksVerified + 1, \\\"fvk11\\\"); // only verify next block\\n        governance.requireActiveValidator(msg.sender);\\n\\n        require(verifier.verifyBlockProof(_proof, blocks[_blockNumber].commitment, blocks[_blockNumber].chunks), \\\"fvk13\\\"); // proof verification failed\\n\\n        processOnchainWithdrawals(_withdrawalsData, blocks[_blockNumber].withdrawalsDataHash);\\n\\n        deleteRequests(\\n            blocks[_blockNumber].priorityOperations\\n        );\\n\\n        totalBlocksVerified += 1;\\n\\n        emit BlockVerification(_blockNumber);\\n    }\\n\\n\\n    /// @notice Reverts unverified blocks\\n    /// @param _maxBlocksToRevert the maximum number blocks that will be reverted (use if can't revert all blocks because of gas limit).\\n    function revertBlocks(uint32 _maxBlocksToRevert) external nonReentrant {\\n        require(isBlockCommitmentExpired(), \\\"rbs11\\\"); // trying to revert non-expired blocks.\\n        governance.requireActiveValidator(msg.sender);\\n\\n        uint32 blocksCommited = totalBlocksCommitted;\\n        uint32 blocksToRevert = Utils.minU32(_maxBlocksToRevert, blocksCommited - totalBlocksVerified);\\n        uint64 revertedPriorityRequests = 0;\\n\\n        for (uint32 i = totalBlocksCommitted - blocksToRevert + 1; i <= blocksCommited; i++) {\\n            Block memory revertedBlock = blocks[i];\\n            require(revertedBlock.committedAtBlock > 0, \\\"frk11\\\"); // block not found\\n\\n            revertedPriorityRequests += revertedBlock.priorityOperations;\\n\\n            delete blocks[i];\\n        }\\n\\n        blocksCommited -= blocksToRevert;\\n        totalBlocksCommitted -= blocksToRevert;\\n        totalCommittedPriorityRequests -= revertedPriorityRequests;\\n\\n        emit BlocksRevert(totalBlocksVerified, blocksCommited);\\n    }\\n\\n    /// @notice Checks that upgrade preparation is active and it is in lock period (period when contract will not add any new priority requests)\\n    function upgradePreparationLockStatus() public returns (bool) {\\n        return upgradePreparationActive && now < upgradePreparationActivationTime + UPGRADE_PREPARATION_LOCK_PERIOD;\\n    }\\n\\n    /// @notice Checks if Exodus mode must be entered. If true - enters exodus mode and emits ExodusMode event.\\n    /// @dev Exodus mode must be entered in case of current ethereum block number is higher than the oldest\\n    /// @dev of existed priority requests expiration block number.\\n    /// @return bool flag that is true if the Exodus mode must be entered.\\n    function triggerExodusIfNeeded() external returns (bool) {\\n        bool trigger = block.number >= priorityRequests[firstPriorityRequestId].expirationBlock &&\\n        priorityRequests[firstPriorityRequestId].expirationBlock != 0;\\n        if (trigger) {\\n            if (!exodusMode) {\\n                exodusMode = true;\\n                emit ExodusMode();\\n            }\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Withdraws token from Franklin to root chain in case of exodus mode. User must provide proof that he owns funds\\n    /// @param _accountId Id of the account in the tree\\n    /// @param _proof Proof\\n    /// @param _tokenId Verified token id\\n    /// @param _amount Amount for owner (must be total amount, not part of it)\\n    function exit(uint32 _accountId, uint16 _tokenId, uint128 _amount, uint256[] calldata _proof) external nonReentrant {\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, _tokenId);\\n        require(exodusMode, \\\"fet11\\\"); // must be in exodus mode\\n        require(!exited[_accountId][_tokenId], \\\"fet12\\\"); // already exited\\n        require(verifier.verifyExitProof(blocks[totalBlocksVerified].stateRoot, _accountId, msg.sender, _tokenId, _amount, _proof), \\\"fet13\\\"); // verification failed\\n\\n        uint128 balance = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n        balancesToWithdraw[packedBalanceKey].balanceToWithdraw = balance.add(_amount);\\n        exited[_accountId][_tokenId] = true;\\n    }\\n\\n    function setAuthPubkeyHash(bytes calldata _pubkey_hash, uint32 _nonce) external nonReentrant {\\n        require(_pubkey_hash.length == PUBKEY_HASH_BYTES, \\\"ahf10\\\"); // PubKeyHash should be 20 bytes.\\n        require(authFacts[msg.sender][_nonce] == bytes32(0), \\\"ahf11\\\"); // auth fact for nonce should be empty\\n\\n        authFacts[msg.sender][_nonce] = keccak256(_pubkey_hash);\\n\\n        emit FactAuth(msg.sender, _nonce, _pubkey_hash);\\n    }\\n\\n    /// @notice Register deposit request - pack pubdata, add priority request and emit OnchainDeposit event\\n    /// @param _tokenId Token by id\\n    /// @param _amount Token amount\\n    /// @param _owner Receiver\\n    function registerDeposit(\\n        uint16 _tokenId,\\n        uint128 _amount,\\n        address _owner\\n    ) internal {\\n        // Priority Queue request\\n        Operations.Deposit memory op = Operations.Deposit({\\n            accountId:  0, // unknown at this point\\n            owner:      _owner,\\n            tokenId:    _tokenId,\\n            amount:     _amount\\n            });\\n        bytes memory pubData = Operations.writeDepositPubdata(op);\\n        addPriorityRequest(Operations.OpType.Deposit, pubData);\\n\\n        emit OnchainDeposit(\\n            msg.sender,\\n            _tokenId,\\n            _amount,\\n            _owner\\n        );\\n    }\\n\\n    /// @notice Register withdrawal - update user balance and emit OnchainWithdrawal event\\n    /// @param _token - token by id\\n    /// @param _amount - token amount\\n    /// @param _to - address to withdraw to\\n    function registerWithdrawal(uint16 _token, uint128 _amount, address payable _to) internal {\\n        bytes22 packedBalanceKey = packAddressAndTokenId(_to, _token);\\n        uint128 balance = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n        balancesToWithdraw[packedBalanceKey].balanceToWithdraw = balance.sub(_amount);\\n        emit OnchainWithdrawal(\\n            _to,\\n            _token,\\n            _amount\\n        );\\n    }\\n\\n    /// @notice Store committed block structure to the storage.\\n    /// @param _nCommittedPriorityRequests - number of priority requests in block\\n    function createCommittedBlock(\\n        uint32 _blockNumber,\\n        uint32 _feeAccount,\\n        bytes32 _newRoot,\\n        bytes memory _publicData,\\n        bytes32 _withdrawalDataHash,\\n        uint64 _nCommittedPriorityRequests\\n    ) internal {\\n        require(_publicData.length % CHUNK_BYTES == 0, \\\"cbb10\\\"); // Public data size is not multiple of CHUNK_BYTES\\n\\n        uint32 blockChunks = uint32(_publicData.length / CHUNK_BYTES);\\n        require(verifier.isBlockSizeSupported(blockChunks), \\\"ccb11\\\");\\n\\n        // Create block commitment for verification proof\\n        bytes32 commitment = createBlockCommitment(\\n            _blockNumber,\\n            _feeAccount,\\n            blocks[_blockNumber - 1].stateRoot,\\n            _newRoot,\\n            _publicData\\n        );\\n\\n        blocks[_blockNumber] = Block(\\n            uint32(block.number), // committed at\\n            _nCommittedPriorityRequests, // number of priority onchain ops in block\\n            blockChunks,\\n            _withdrawalDataHash, // hash of onchain withdrawals data (will be used during checking block withdrawal data in verifyBlock function)\\n            commitment, // blocks' commitment\\n            _newRoot // new root\\n        );\\n    }\\n\\n    function emitDepositCommitEvent(uint32 _blockNumber, Operations.Deposit memory depositData) internal {\\n        emit DepositCommit(_blockNumber, depositData.accountId, depositData.owner, depositData.tokenId, depositData.amount);\\n    }\\n\\n    function emitFullExitCommitEvent(uint32 _blockNumber, Operations.FullExit memory fullExitData) internal {\\n        emit FullExitCommit(_blockNumber, fullExitData.accountId, fullExitData.owner, fullExitData.tokenId, fullExitData.amount);\\n    }\\n\\n    /// @notice Gets operations packed in bytes array. Unpacks it and stores onchain operations.\\n    /// @param _blockNumber Franklin block number\\n    /// @param _publicData Operations packed in bytes array\\n    /// @param _ethWitness Eth witness that was posted with commit\\n    /// @param _ethWitnessSizes Amount of eth witness bytes for the corresponding operation.\\n    /// Priority operations must be committed in the same order as they are in the priority queue.\\n    function collectOnchainOps(uint32 _blockNumber, bytes memory _publicData, bytes memory _ethWitness, uint32[] memory _ethWitnessSizes)\\n        internal returns (bytes32 withdrawalsDataHash) {\\n        require(_publicData.length % CHUNK_BYTES == 0, \\\"fcs11\\\"); // pubdata length must be a multiple of CHUNK_BYTES\\n\\n        uint64 currentPriorityRequestId = firstPriorityRequestId + totalCommittedPriorityRequests;\\n\\n        uint256 pubDataPtr = 0;\\n        uint256 pubDataStartPtr = 0;\\n        uint256 pubDataEndPtr = 0;\\n\\n        assembly { pubDataStartPtr := add(_publicData, 0x20) }\\n        pubDataPtr = pubDataStartPtr;\\n        pubDataEndPtr = pubDataStartPtr + _publicData.length;\\n\\n        uint64 ethWitnessOffset = 0;\\n        uint16 processedOperationsRequiringEthWitness = 0;\\n\\n        withdrawalsDataHash = EMPTY_STRING_KECCAK;\\n\\n        while (pubDataPtr < pubDataEndPtr) {\\n            Operations.OpType opType;\\n            // read operation type from public data (the first byte per each operation)\\n            assembly {\\n                opType := shr(0xf8, mload(pubDataPtr))\\n            }\\n\\n            // cheap operations processing\\n            if (opType == Operations.OpType.Transfer) {\\n                pubDataPtr += TRANSFER_BYTES;\\n            } else if (opType == Operations.OpType.Noop) {\\n                pubDataPtr += NOOP_BYTES;\\n            } else if (opType == Operations.OpType.TransferToNew) {\\n                pubDataPtr += TRANSFER_TO_NEW_BYTES;\\n            } else {\\n                // other operations processing\\n\\n                // calculation of public data offset\\n                uint256 pubdataOffset = pubDataPtr - pubDataStartPtr;\\n\\n                if (opType == Operations.OpType.Deposit) {\\n                    bytes memory pubData = Bytes.slice(_publicData, pubdataOffset + 1, DEPOSIT_BYTES - 1);\\n\\n                    Operations.Deposit memory depositData = Operations.readDepositPubdata(pubData);\\n                    emitDepositCommitEvent(_blockNumber, depositData);\\n\\n                    OnchainOperation memory onchainOp = OnchainOperation(\\n                        Operations.OpType.Deposit,\\n                        pubData\\n                    );\\n                    commitNextPriorityOperation(onchainOp, currentPriorityRequestId);\\n                    currentPriorityRequestId++;\\n\\n                    pubDataPtr += DEPOSIT_BYTES;\\n                } else if (opType == Operations.OpType.PartialExit) {\\n                    Operations.PartialExit memory data = Operations.readPartialExitPubdata(_publicData, pubdataOffset + 1);\\n\\n                    bool addToPendingWithdrawalsQueue = true;\\n                    withdrawalsDataHash = keccak256(abi.encode(withdrawalsDataHash, addToPendingWithdrawalsQueue, data.owner, data.tokenId, data.amount));\\n\\n                    pubDataPtr += PARTIAL_EXIT_BYTES;\\n                } else if (opType == Operations.OpType.FullExit) {\\n                    bytes memory pubData = Bytes.slice(_publicData, pubdataOffset + 1, FULL_EXIT_BYTES - 1);\\n\\n                    Operations.FullExit memory fullExitData = Operations.readFullExitPubdata(pubData);\\n                    emitFullExitCommitEvent(_blockNumber, fullExitData);\\n\\n                    bool addToPendingWithdrawalsQueue = false;\\n                    withdrawalsDataHash = keccak256(abi.encode(withdrawalsDataHash, addToPendingWithdrawalsQueue, fullExitData.owner, fullExitData.tokenId, fullExitData.amount));\\n\\n                    OnchainOperation memory onchainOp = OnchainOperation(\\n                        Operations.OpType.FullExit,\\n                        pubData\\n                    );\\n                    commitNextPriorityOperation(onchainOp, currentPriorityRequestId);\\n                    currentPriorityRequestId++;\\n\\n                    pubDataPtr += FULL_EXIT_BYTES;\\n                } else if (opType == Operations.OpType.ChangePubKey) {\\n                    require(processedOperationsRequiringEthWitness < _ethWitnessSizes.length, \\\"fcs13\\\"); // eth witness data malformed\\n                    Operations.ChangePubKey memory op = Operations.readChangePubKeyPubdata(_publicData, pubdataOffset + 1);\\n\\n                    if (_ethWitnessSizes[processedOperationsRequiringEthWitness] != 0) {\\n                        bytes memory currentEthWitness = Bytes.slice(_ethWitness, ethWitnessOffset, _ethWitnessSizes[processedOperationsRequiringEthWitness]);\\n\\n                        bool valid = verifyChangePubkeySignature(currentEthWitness, op.pubKeyHash, op.nonce, op.owner, op.accountId);\\n                        require(valid, \\\"fpp15\\\"); // failed to verify change pubkey hash signature\\n                    } else {\\n                        bool valid = authFacts[op.owner][op.nonce] == keccak256(abi.encodePacked(op.pubKeyHash));\\n                        require(valid, \\\"fpp16\\\"); // new pub key hash is not authenticated properly\\n                    }\\n\\n                    ethWitnessOffset += _ethWitnessSizes[processedOperationsRequiringEthWitness];\\n                    processedOperationsRequiringEthWitness++;\\n\\n                    pubDataPtr += CHANGE_PUBKEY_BYTES;\\n                } else {\\n                    revert(\\\"fpp14\\\"); // unsupported op\\n                }\\n            }\\n        }\\n        require(pubDataPtr == pubDataEndPtr, \\\"fcs12\\\"); // last chunk exceeds pubdata\\n        require(ethWitnessOffset == _ethWitness.length, \\\"fcs14\\\"); // _ethWitness was not used completely\\n        require(processedOperationsRequiringEthWitness == _ethWitnessSizes.length, \\\"fcs15\\\"); // _ethWitnessSizes was not used completely\\n\\n        require(currentPriorityRequestId <= firstPriorityRequestId + totalOpenPriorityRequests, \\\"fcs16\\\"); // fcs16 - excess priority requests in pubdata\\n        totalCommittedPriorityRequests = currentPriorityRequestId - firstPriorityRequestId;\\n    }\\n\\n    /// @notice Checks that signature is valid for pubkey change message\\n    /// @param _signature Signature\\n    /// @param _newPkHash New pubkey hash\\n    /// @param _nonce Nonce used for message\\n    /// @param _ethAddress Account's ethereum address\\n    /// @param _accountId Id of zkSync account\\n    function verifyChangePubkeySignature(bytes memory _signature, bytes20 _newPkHash, uint32 _nonce, address _ethAddress, uint32 _accountId) internal pure returns (bool) {\\n        bytes memory signedMessage = abi.encodePacked(\\n            \\\"\\\\x19Ethereum Signed Message:\\\\n152\\\",\\n            \\\"Register zkSync pubkey:\\\\n\\\\n\\\",\\n            Bytes.bytesToHexASCIIBytes(abi.encodePacked(_newPkHash)), \\\"\\\\n\\\",\\n            \\\"nonce: 0x\\\", Bytes.bytesToHexASCIIBytes(Bytes.toBytesFromUInt32(_nonce)), \\\"\\\\n\\\",\\n            \\\"account id: 0x\\\", Bytes.bytesToHexASCIIBytes(Bytes.toBytesFromUInt32(_accountId)),\\n            \\\"\\\\n\\\\n\\\",\\n            \\\"Only sign this message for a trusted client!\\\"\\n        );\\n        address recoveredAddress = Utils.recoverAddressFromEthSignature(_signature, signedMessage);\\n        return recoveredAddress == _ethAddress;\\n    }\\n\\n    /// @notice Creates block commitment from its data\\n    /// @param _blockNumber Block number\\n    /// @param _feeAccount Account to collect fees\\n    /// @param _oldRoot Old tree root\\n    /// @param _newRoot New tree root\\n    /// @param _publicData Operations pubdata\\n    /// @return block commitment\\n    function createBlockCommitment(\\n        uint32 _blockNumber,\\n        uint32 _feeAccount,\\n        bytes32 _oldRoot,\\n        bytes32 _newRoot,\\n        bytes memory _publicData\\n    ) internal view returns (bytes32 commitment) {\\n        bytes32 hash = sha256(\\n            abi.encodePacked(uint256(_blockNumber), uint256(_feeAccount))\\n        );\\n        hash = sha256(abi.encodePacked(hash, uint256(_oldRoot)));\\n        hash = sha256(abi.encodePacked(hash, uint256(_newRoot)));\\n\\n        /// The code below is equivalent to `commitment = sha256(abi.encodePacked(hash, _publicData))`\\n\\n        /// We use inline assembly instead of this concise and readable code in order to avoid copying of `_publicData` (which saves ~90 gas per transfer operation).\\n\\n        /// Specifically, we perform the following trick:\\n        /// First, replace the first 32 bytes of `_publicData` (where normally its length is stored) with the value of `hash`.\\n        /// Then, we call `sha256` precompile passing the `_publicData` pointer and the length of the concatenated byte buffer.\\n        /// Finally, we put the `_publicData.length` back to its original location (to the first word of `_publicData`).\\n        assembly {\\n            let hashResult := mload(0x40)\\n            let pubDataLen := mload(_publicData)\\n            mstore(_publicData, hash)\\n            // staticcall to the sha256 precompile at address 0x2\\n            let success := staticcall(\\n                gas,\\n                0x2,\\n                _publicData,\\n                add(pubDataLen, 0x20),\\n                hashResult,\\n                0x20\\n            )\\n            mstore(_publicData, pubDataLen)\\n\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success case 0 { invalid() }\\n\\n            commitment := mload(hashResult)\\n        }\\n    }\\n\\n    /// @notice Checks that operation is same as operation in priority queue\\n    /// @param _onchainOp The operation\\n    /// @param _priorityRequestId Operation's id in priority queue\\n    function commitNextPriorityOperation(OnchainOperation memory _onchainOp, uint64 _priorityRequestId) internal view {\\n        Operations.OpType priorReqType = priorityRequests[_priorityRequestId].opType;\\n        bytes memory priorReqPubdata = priorityRequests[_priorityRequestId].pubData;\\n\\n        require(priorReqType == _onchainOp.opType, \\\"nvp12\\\"); // incorrect priority op type\\n\\n        if (_onchainOp.opType == Operations.OpType.Deposit) {\\n            require(Operations.depositPubdataMatch(priorReqPubdata, _onchainOp.pubData), \\\"vnp13\\\");\\n        } else if (_onchainOp.opType == Operations.OpType.FullExit) {\\n            require(Operations.fullExitPubdataMatch(priorReqPubdata, _onchainOp.pubData), \\\"vnp14\\\");\\n        } else {\\n            revert(\\\"vnp15\\\"); // invalid or non-priority operation\\n        }\\n    }\\n\\n    /// @notice Processes onchain withdrawals. Full exit withdrawals will not be added to pending withdrawals queue\\n    /// @dev NOTICE: must process only withdrawals which hash matches with expectedWithdrawalsDataHash.\\n    /// @param withdrawalsData Withdrawals data\\n    /// @param expectedWithdrawalsDataHash Expected withdrawals data hash\\n    function processOnchainWithdrawals(bytes memory withdrawalsData, bytes32 expectedWithdrawalsDataHash) internal {\\n        require(withdrawalsData.length % ONCHAIN_WITHDRAWAL_BYTES == 0, \\\"pow11\\\"); // pow11 - withdrawalData length is not multiple of ONCHAIN_WITHDRAWAL_BYTES\\n\\n        bytes32 withdrawalsDataHash = EMPTY_STRING_KECCAK;\\n\\n        uint offset = 0;\\n        uint32 localNumberOfPendingWithdrawals = numberOfPendingWithdrawals;\\n        while (offset < withdrawalsData.length) {\\n            (bool addToPendingWithdrawalsQueue, address _to, uint16 _tokenId, uint128 _amount) = Operations.readWithdrawalData(withdrawalsData, offset);\\n            bytes22 packedBalanceKey = packAddressAndTokenId(_to, _tokenId);\\n\\n            uint128 balance = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n            // after this all writes to this slot will cost 5k gas\\n            balancesToWithdraw[packedBalanceKey] = BalanceToWithdraw({\\n                balanceToWithdraw: balance.add(_amount),\\n                gasReserveValue: 0xff\\n            });\\n\\n            if (addToPendingWithdrawalsQueue) {\\n                pendingWithdrawals[firstPendingWithdrawalIndex + localNumberOfPendingWithdrawals] = PendingWithdrawal(_to, _tokenId);\\n                localNumberOfPendingWithdrawals++;\\n            }\\n\\n            withdrawalsDataHash = keccak256(abi.encode(withdrawalsDataHash, addToPendingWithdrawalsQueue, _to, _tokenId, _amount));\\n            offset += ONCHAIN_WITHDRAWAL_BYTES;\\n        }\\n        numberOfPendingWithdrawals = localNumberOfPendingWithdrawals;\\n        require(withdrawalsDataHash == expectedWithdrawalsDataHash, \\\"pow12\\\"); // pow12 - withdrawals data hash not matches with expected value\\n    }\\n\\n    /// @notice Checks whether oldest unverified block has expired\\n    /// @return bool flag that indicates whether oldest unverified block has expired\\n    function isBlockCommitmentExpired() internal view returns (bool) {\\n        return (\\n            totalBlocksCommitted > totalBlocksVerified &&\\n            blocks[totalBlocksVerified + 1].committedAtBlock > 0 &&\\n            block.number > blocks[totalBlocksVerified + 1].committedAtBlock + EXPECT_VERIFICATION_IN\\n        );\\n    }\\n\\n    /// @notice Checks that current state not is exodus mode\\n    function requireActive() internal view {\\n        require(!exodusMode, \\\"fre11\\\"); // exodus mode activated\\n    }\\n\\n    // Priority queue\\n\\n    /// @notice Saves priority request in storage\\n    /// @dev Calculates expiration block for request, store this request and emit NewPriorityRequest event\\n    /// @param _opType Rollup operation type\\n    /// @param _pubData Operation pubdata\\n    function addPriorityRequest(\\n        Operations.OpType _opType,\\n        bytes memory _pubData\\n    ) internal {\\n        require(!upgradePreparationLockStatus(), \\\"apr11\\\"); // apr11 - priority request can't be added during lock period of preparation of upgrade\\n\\n        // Expiration block is: current block number + priority expiration delta\\n        uint256 expirationBlock = block.number + PRIORITY_EXPIRATION;\\n\\n        uint64 nextPriorityRequestId = firstPriorityRequestId + totalOpenPriorityRequests;\\n\\n        priorityRequests[nextPriorityRequestId] = PriorityOperation({\\n            opType: _opType,\\n            pubData: _pubData,\\n            expirationBlock: expirationBlock\\n        });\\n\\n        emit NewPriorityRequest(\\n            msg.sender,\\n            nextPriorityRequestId,\\n            _opType,\\n            _pubData,\\n            expirationBlock\\n        );\\n\\n        totalOpenPriorityRequests++;\\n    }\\n\\n    /// @notice Deletes processed priority requests\\n    /// @param _number The number of requests\\n    function deleteRequests(uint64 _number) internal {\\n        require(_number <= totalOpenPriorityRequests, \\\"pcs21\\\"); // number is higher than total priority requests number\\n\\n        uint64 numberOfRequestsToClear = Utils.minU64(_number, MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY);\\n        uint64 startIndex = firstPriorityRequestId;\\n        for (uint64 i = startIndex; i < startIndex + numberOfRequestsToClear; i++) {\\n            delete priorityRequests[i];\\n        }\\n\\n        totalOpenPriorityRequests -= _number;\\n        firstPriorityRequestId += _number;\\n        totalCommittedPriorityRequests -= _number;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    /// Address of lock flag variable.\\n    /// Flag is placed at random memory location to not interfere with Storage contract.\\n    uint constant private LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\\\"ReentrancyGuard\\\") - 1;\\n\\n    function initializeReentrancyGuard () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        assembly { sstore(LOCK_FLAG_ADDRESS, 1) }\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        bool notEntered;\\n        assembly { notEntered := sload(LOCK_FLAG_ADDRESS) }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        assembly { sstore(LOCK_FLAG_ADDRESS, 0) }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        assembly { sstore(LOCK_FLAG_ADDRESS, 1) }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMathUInt128.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUInt128 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        require(b <= a, errorMessage);\\n        uint128 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint128 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint128 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeCast.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and then downcasting.\\n *\\n * _Available since v2.5.0._\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\n\\nlibrary Utils {\\n    /// @notice Returns lesser of two values\\n    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Returns lesser of two values\\n    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transfer` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendERC20(IERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) = address(_token).call(\\n            abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _amount)\\n        );\\n        // `transfer` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Sends ETH\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendETHNoRevert(address payable _to, uint256 _amount) internal returns (bool) {\\n        // TODO: Use constant from Config\\n        uint256 ETH_WITHDRAWAL_GAS_LIMIT = 10000;\\n\\n        (bool callSuccess, ) = _to.call.gas(ETH_WITHDRAWAL_GAS_LIMIT).value(_amount)(\\\"\\\");\\n        return callSuccess;\\n    }\\n\\n    /// @notice Recovers signer's address from ethereum signature for given message\\n    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)\\n    /// @param _message signed message.\\n    /// @return address of the signer\\n    function recoverAddressFromEthSignature(bytes memory _signature, bytes memory _message) internal pure returns (address) {\\n        require(_signature.length == 65, \\\"ves10\\\"); // incorrect signature length\\n\\n        bytes32 signR;\\n        bytes32 signS;\\n        uint offset = 0;\\n\\n        (offset, signR) = Bytes.readBytes32(_signature, offset);\\n        (offset, signS) = Bytes.readBytes32(_signature, offset);\\n        uint8 signV = uint8(_signature[offset]);\\n\\n        return ecrecover(keccak256(_message), signV, signR, signS);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Storage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./Verifier.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n\\n/// @title zkSync storage contract\\n/// @author Matter Labs\\ncontract Storage {\\n\\n    /// @notice Flag indicates that upgrade preparation status is active\\n    /// @dev Will store false in case of not active upgrade mode\\n    bool public upgradePreparationActive;\\n\\n    /// @notice Upgrade preparation activation timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint public upgradePreparationActivationTime;\\n\\n    /// @notice Verifier contract. Used to verify block proof and exit proof\\n    Verifier internal verifier;\\n\\n    /// @notice Governance contract. Contains the governor (the owner) of whole system, validators list, possible tokens list\\n    Governance internal governance;\\n\\n    struct BalanceToWithdraw {\\n        uint128 balanceToWithdraw;\\n        uint8 gasReserveValue; // gives user opportunity to fill storage slot with nonzero value\\n    }\\n\\n    /// @notice Root-chain balances (per owner and token id, see packAddressAndTokenId) to withdraw\\n    mapping(bytes22 => BalanceToWithdraw) public balancesToWithdraw;\\n\\n    /// @notice verified withdrawal pending to be executed.\\n    struct PendingWithdrawal {\\n        address to;\\n        uint16 tokenId;\\n    }\\n    \\n    /// @notice Verified but not executed withdrawals for addresses stored in here (key is pendingWithdrawal's index in pending withdrawals queue)\\n    mapping(uint32 => PendingWithdrawal) public pendingWithdrawals;\\n    uint32 public firstPendingWithdrawalIndex;\\n    uint32 public numberOfPendingWithdrawals;\\n\\n    /// @notice Total number of verified blocks i.e. blocks[totalBlocksVerified] points at the latest verified block (block 0 is genesis)\\n    uint32 public totalBlocksVerified;\\n\\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\\n    uint32 public totalBlocksCommitted;\\n\\n    /// @notice Rollup block data (once per block)\\n    /// @member validator Block producer\\n    /// @member committedAtBlock ETH block number at which this block was committed\\n    /// @member cumulativeOnchainOperations Total number of operations in this and all previous blocks\\n    /// @member priorityOperations Total number of priority operations for this block\\n    /// @member commitment Hash of the block circuit commitment\\n    /// @member stateRoot New tree root hash\\n    ///\\n    /// Consider memory alignment when changing field order: https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html\\n    struct Block {\\n        uint32 committedAtBlock;\\n        uint64 priorityOperations;\\n        uint32 chunks;\\n        bytes32 withdrawalsDataHash; /// can be restricted to 16 bytes to reduce number of required storage slots\\n        bytes32 commitment;\\n        bytes32 stateRoot;\\n    }\\n\\n    /// @notice Blocks by Franklin block id\\n    mapping(uint32 => Block) public blocks;\\n\\n    /// @notice Onchain operations - operations processed inside rollup blocks\\n    /// @member opType Onchain operation type\\n    /// @member amount Amount used in the operation\\n    /// @member pubData Operation pubdata\\n    struct OnchainOperation {\\n        Operations.OpType opType;\\n        bytes pubData;\\n    }\\n\\n    /// @notice Flag indicates that a user has exited certain token balance (per account id and tokenId)\\n    mapping(uint32 => mapping(uint16 => bool)) public exited;\\n\\n    /// @notice Flag indicates that exodus (mass exit) mode is triggered\\n    /// @notice Once it was raised, it can not be cleared again, and all users must exit\\n    bool public exodusMode;\\n\\n    /// @notice User authenticated fact hashes for some nonce.\\n    mapping(address => mapping(uint32 => bytes32)) public authFacts;\\n\\n    /// @notice Priority Operation container\\n    /// @member opType Priority operation type\\n    /// @member pubData Priority operation public data\\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n    struct PriorityOperation {\\n        Operations.OpType opType;\\n        bytes pubData;\\n        uint256 expirationBlock;\\n    }\\n\\n    /// @notice Priority Requests mapping (request id - operation)\\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\\n    /// @dev Numbers are in order of requests receiving\\n    mapping(uint64 => PriorityOperation) public priorityRequests;\\n\\n    /// @notice First open priority request id\\n    uint64 public firstPriorityRequestId;\\n\\n    /// @notice Total number of requests\\n    uint64 public totalOpenPriorityRequests;\\n\\n    /// @notice Total number of committed requests.\\n    /// @dev Used in checks: if the request matches the operation on Rollup contract and if provided number of requests is not too big\\n    uint64 public totalCommittedPriorityRequests;\\n\\n    /// @notice Packs address and token id into single word to use as a key in balances mapping\\n    function packAddressAndTokenId(address _address, uint16 _tokenId) internal pure returns (bytes22) {\\n        return bytes22((uint176(_address) | (uint176(_tokenId) << 160)));\\n    }\\n\\n    /// @notice Gets value from balancesToWithdraw\\n    function getBalanceToWithdraw(address _address, uint16 _tokenId) public view returns (uint128) {\\n        return balancesToWithdraw[packAddressAndTokenId(_address, _tokenId)].balanceToWithdraw;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title zkSync configuration constants\\n/// @author Matter Labs\\ncontract Config {\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode (in seconds)\\n    uint constant UPGRADE_NOTICE_PERIOD = 30 minutes;\\n\\n    /// @notice Period after the start of preparation upgrade when contract wouldn't register new priority operations (in seconds)\\n    uint constant UPGRADE_PREPARATION_LOCK_PERIOD = 30 minutes;\\n\\n    /// @notice ERC20 token withdrawal gas limit, used only for complete withdrawals\\n    uint256 constant ERC20_WITHDRAWAL_GAS_LIMIT = 250000;\\n\\n    /// @notice ETH token withdrawal gas limit, used only for complete withdrawals\\n    uint256 constant ETH_WITHDRAWAL_GAS_LIMIT = 10000;\\n\\n    /// @notice Bytes in one chunk\\n    uint8 constant CHUNK_BYTES = 9;\\n\\n    /// @notice zkSync address length\\n    uint8 constant ADDRESS_BYTES = 20;\\n\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n\\n    /// @notice Public key bytes length\\n    uint8 constant PUBKEY_BYTES = 32;\\n\\n    /// @notice Ethereum signature r/s bytes length\\n    uint8 constant ETH_SIGN_RS_BYTES = 32;\\n\\n    /// @notice Success flag bytes length\\n    uint8 constant SUCCESS_FLAG_BYTES = 1;\\n\\n    /// @notice Max amount of tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 128 - 1;\\n\\n    /// @notice Max account id that could be registered in the network\\n    uint32 constant MAX_ACCOUNT_ID = (2 ** 24) - 1;\\n\\n    /// @notice Expected average period of block creation\\n    uint256 constant BLOCK_PERIOD = 15 seconds;\\n\\n    /// @notice ETH blocks verification expectation\\n    uint256 constant EXPECT_VERIFICATION_IN = 3 hours / BLOCK_PERIOD;\\n\\n    uint256 constant NOOP_BYTES = 1 * CHUNK_BYTES;\\n    uint256 constant DEPOSIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_TO_NEW_BYTES = 6 * CHUNK_BYTES;\\n    uint256 constant PARTIAL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\\n\\n    /// @notice Full exit operation length\\n    uint256 constant FULL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @notice OnchainWithdrawal data length\\n    uint256 constant ONCHAIN_WITHDRAWAL_BYTES = 1 + 20 + 2 + 16; // (uint8 addToPendingWithdrawalsQueue, address _to, uint16 _tokenId, uint128 _amount)\\n\\n    /// @notice ChangePubKey operation length\\n    uint256 constant CHANGE_PUBKEY_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @notice Expiration delta for priority request to be satisfied (in ETH blocks)\\n    /// NOTE: Priority expiration should be > EXPECT_VERIFICATION_IN, otherwise incorrect block with priority op could not be reverted.\\n    uint256 constant PRIORITY_EXPIRATION = 6 days / BLOCK_PERIOD;\\n\\n    /// @notice Maximum number of priority request to clear during verifying the block\\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\\n    uint64 constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Events.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n\\n/// @title zkSync events\\n/// @author Matter Labs\\ninterface Events {\\n\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when a block is verified\\n    event BlockVerification(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when user send a transaction to withdraw her funds from onchain balance\\n    event OnchainWithdrawal(\\n        address indexed owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Event emitted when user send a transaction to deposit her funds\\n    event OnchainDeposit(\\n        address indexed sender,\\n        uint16 indexed tokenId,\\n        uint128 amount,\\n        address indexed owner\\n    );\\n\\n    /// @notice Event emitted when user sends a authentication fact (e.g. pub-key hash)\\n    event FactAuth(\\n        address indexed sender,\\n        uint32 nonce,\\n        bytes fact\\n    );\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(\\n        uint32 totalBlocksVerified,\\n        uint32 totalBlocksCommitted\\n    );\\n\\n    /// @notice Exodus mode entered event\\n    event ExodusMode();\\n\\n    /// @notice New priority request event. Emitted when a request is placed into mapping\\n    event NewPriorityRequest(\\n        address sender,\\n        uint64 serialId,\\n        Operations.OpType opType,\\n        bytes pubData,\\n        uint256 expirationBlock\\n    );\\n\\n    event DepositCommit(\\n        uint32 indexed franklinBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    event FullExitCommit(\\n        uint32 indexed franklinBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n}\\n\\n/// @title Upgrade events\\n/// @author Matter Labs\\ninterface UpgradeEvents {\\n\\n    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts\\n    event NewUpgradable(\\n        uint indexed versionId,\\n        address indexed upgradeable\\n    );\\n\\n    /// @notice Upgrade mode enter event\\n    event NoticePeriodStart(\\n        uint indexed versionId,\\n        address[] newTargets,\\n        uint noticePeriod // notice period (in seconds)\\n    );\\n\\n    /// @notice Upgrade mode cancel event\\n    event UpgradeCancel(\\n        uint indexed versionId\\n    );\\n\\n    /// @notice Upgrade mode preparation status event\\n    event PreparationStart(\\n        uint indexed versionId\\n    );\\n\\n    /// @notice Upgrade mode complete event\\n    event UpgradeComplete(\\n        uint indexed versionId,\\n        address[] newTargets\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Bytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\\n// implements the following algorithm:\\n// f(bytes memory input, uint offset) -> X out\\n// where byte representation of out is N bytes from input at the given offset\\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\\n// 2) We load W from memory into out, last N bytes of W are placed into out\\n\\nlibrary Bytes {\\n\\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 2);\\n    }\\n\\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 3);\\n    }\\n\\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 4);\\n    }\\n\\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 16);\\n    }\\n\\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\\n    function toBytesFromUIntTruncated(uint self, uint8 byteLength) private pure returns (bytes memory bts) {\\n        require(byteLength <= 32, \\\"bt211\\\");\\n        bts = new bytes(byteLength);\\n        // Even though the bytes will allocate a full word, we don't want\\n        // any potential garbage bytes in there.\\n        uint data = self << ((32 - byteLength) * 8);\\n        assembly {\\n            mstore(add(bts, /*BYTES_HEADER_SIZE*/32), data)\\n        }\\n    }\\n\\n    // Copies 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\\n        bts = toBytesFromUIntTruncated(uint(self), 20);\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\\n        uint256 offset = _start + 20;\\n        require(self.length >= offset, \\\"bta11\\\");\\n        assembly {\\n            addr := mload(add(self, offset))\\n        }\\n    }\\n\\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\\n        require(self.length >= (_start + 20), \\\"btb20\\\");\\n        assembly {\\n            r := mload(add(add(self, 0x20), _start))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x2)\\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\\n        uint256 offset = _start + 0x2;\\n        require(_bytes.length >= offset, \\\"btu02\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x3)\\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\\n        uint256 offset = _start + 0x3;\\n        require(_bytes.length >= offset, \\\"btu03\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x4)\\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\\n        uint256 offset = _start + 0x4;\\n        require(_bytes.length >= offset, \\\"btu04\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x10)\\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\\n        uint256 offset = _start + 0x10;\\n        require(_bytes.length >= offset, \\\"btu16\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x14)\\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\\n        uint256 offset = _start + 0x14;\\n        require(_bytes.length >= offset, \\\"btu20\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x20)\\n    function bytesToBytes32(bytes memory  _bytes, uint256 _start) internal pure returns (bytes32 r) {\\n        uint256 offset = _start + 0x20;\\n        require(_bytes.length >= offset, \\\"btb32\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\\n    // Get slice from bytes arrays\\n    // Returns the newly created 'bytes memory'\\n    // NOTE: theoretically possible overflow of (_start + _length)\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length), \\\"bse11\\\"); // bytes length is less then start byte + length bytes\\n\\n        bytes memory tempBytes = new bytes(_length);\\n\\n        if (_length != 0) {\\n            // TODO: Review this thoroughly.\\n            assembly {\\n                let slice_curr := add(tempBytes, 0x20)\\n                let slice_end := add(slice_curr, _length)\\n\\n                for {\\n                    let array_current := add(_bytes, add(_start, 0x20))\\n                } lt(slice_curr, slice_end) {\\n                    slice_curr := add(slice_curr, 0x20)\\n                    array_current := add(array_current, 0x20)\\n                } {\\n                    mstore(slice_curr, mload(array_current))\\n                }\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// Reads byte stream\\n    /// @return new_offset - offset + amount of bytes read\\n    /// @return data - actually read data\\n    // NOTE: theoretically possible overflow of (_offset + _length)\\n    function read(bytes memory _data, uint _offset, uint _length) internal pure returns (uint new_offset, bytes memory data) {\\n        data = slice(_data, _offset, _length);\\n        new_offset = _offset + _length;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readBool(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bool r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]) != 0;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readUint8(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint8 r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 2)\\n    function readUInt16(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint16 r) {\\n        new_offset = _offset + 2;\\n        r = bytesToUInt16(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 3)\\n    function readUInt24(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint24 r) {\\n        new_offset = _offset + 3;\\n        r = bytesToUInt24(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 4)\\n    function readUInt32(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint32 r) {\\n        new_offset = _offset + 4;\\n        r = bytesToUInt32(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 16)\\n    function readUInt128(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint128 r) {\\n        new_offset = _offset + 16;\\n        r = bytesToUInt128(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readUInt160(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint160 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToUInt160(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readAddress(bytes memory _data, uint _offset) internal pure returns (uint new_offset, address r) {\\n        new_offset = _offset + 20;\\n        r = bytesToAddress(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readBytes20(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bytes20 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToBytes20(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 32)\\n    function readBytes32(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bytes32 r) {\\n        new_offset = _offset + 32;\\n        r = bytesToBytes32(_data, _offset);\\n    }\\n\\n    // Helper function for hex conversion.\\n    function halfByteToHex(byte _byte) internal pure returns (byte _hexByte) {\\n        require(uint8(_byte) < 0x10, \\\"hbh11\\\");  // half byte's value is out of 0..15 range.\\n\\n        // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n        return byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byte) * 8)));\\n    }\\n\\n    // Convert bytes to ASCII hex representation\\n    function bytesToHexASCIIBytes(bytes memory  _input) internal pure returns (bytes memory _output) {\\n        bytes memory outStringBytes = new bytes(_input.length * 2);\\n\\n        // code in `assembly` construction is equivalent of the next code:\\n        // for (uint i = 0; i < _input.length; ++i) {\\n        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);\\n        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);\\n        // }\\n        assembly {\\n            let input_curr := add(_input, 0x20)\\n            let input_end := add(input_curr, mload(_input))\\n\\n            for {\\n                let out_curr := add(outStringBytes, 0x20)\\n            } lt(input_curr, input_end) {\\n                input_curr := add(input_curr, 0x01)\\n                out_curr := add(out_curr, 0x02)\\n            } {\\n                let curr_input_byte := shr(0xf8, mload(input_curr))\\n                // here outStringByte from each half of input byte calculates by the next:\\n                //\\n                // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n                // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))\\n                mstore(out_curr,            shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130)))\\n                mstore(add(out_curr, 0x01), shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130)))\\n            }\\n        }\\n        return outStringBytes;\\n    }\\n\\n    /// Trim bytes into single word\\n    function trim(bytes memory _data, uint _new_length) internal pure returns (uint r) {\\n        require(_new_length <= 0x20, \\\"trm10\\\");  // new_length is longer than word\\n        require(_data.length >= _new_length, \\\"trm11\\\");  // data is to short\\n\\n        uint a;\\n        assembly {\\n            a := mload(add(_data, 0x20)) // load bytes into uint256\\n        }\\n\\n        return a >> ((0x20 - _new_length) * 8);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Operations.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Bytes.sol\\\";\\n\\n\\n/// @title zkSync operations tools\\nlibrary Operations {\\n\\n    // Circuit ops and their pubdata (chunks * bytes)\\n\\n    /// @notice zkSync circuit operation type\\n    enum OpType {\\n        Noop,\\n        Deposit,\\n        TransferToNew,\\n        PartialExit,\\n        _CloseAccount, // used for correct op id offset\\n        Transfer,\\n        FullExit,\\n        ChangePubKey\\n    }\\n\\n    // Byte lengths\\n\\n    uint8 constant TOKEN_BYTES = 2;\\n\\n    uint8 constant PUBKEY_BYTES = 32;\\n\\n    uint8 constant NONCE_BYTES = 4;\\n\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n\\n    uint8 constant ADDRESS_BYTES = 20;\\n\\n    /// @notice Packed fee bytes lengths\\n    uint8 constant FEE_BYTES = 2;\\n\\n    /// @notice zkSync account id bytes lengths\\n    uint8 constant ACCOUNT_ID_BYTES = 4;\\n\\n    uint8 constant AMOUNT_BYTES = 16;\\n\\n    /// @notice Signature (for example full exit signature) bytes length\\n    uint8 constant SIGNATURE_BYTES = 64;\\n\\n    // Deposit pubdata\\n    struct Deposit {\\n        uint32 accountId;\\n        uint16 tokenId;\\n        uint128 amount;\\n        address owner;\\n    }\\n\\n    uint public constant PACKED_DEPOSIT_PUBDATA_BYTES = \\n        ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES;\\n\\n    /// Deserialize deposit pubdata\\n    function readDepositPubdata(bytes memory _data) internal pure\\n        returns (Deposit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset);   // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset);   // amount\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);    // owner\\n\\n        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, \\\"rdp10\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    /// Serialize deposit pubdata\\n    function writeDepositPubdata(Deposit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),   // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId,  // tokenId\\n            op.amount,   // amount\\n            op.owner     // owner\\n        );\\n    }\\n\\n    /// @notice Check that deposit pubdata from request and block matches\\n    function depositPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // We must ignore `accountId` because it is present in block pubdata but not in priority queue\\n        bytes memory lhs_trimmed = Bytes.slice(_lhs, ACCOUNT_ID_BYTES, PACKED_DEPOSIT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        bytes memory rhs_trimmed = Bytes.slice(_rhs, ACCOUNT_ID_BYTES, PACKED_DEPOSIT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        return keccak256(lhs_trimmed) == keccak256(rhs_trimmed);\\n    }\\n\\n    // FullExit pubdata\\n\\n    struct FullExit {\\n        uint32 accountId;\\n        address owner;\\n        uint16 tokenId;\\n        uint128 amount;\\n    }\\n\\n    uint public constant PACKED_FULL_EXIT_PUBDATA_BYTES = \\n        ACCOUNT_ID_BYTES + ADDRESS_BYTES + TOKEN_BYTES + AMOUNT_BYTES;\\n\\n    function readFullExitPubdata(bytes memory _data) internal pure\\n        returns (FullExit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset);      // accountId\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);         // owner\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset);        // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset);        // amount\\n\\n        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, \\\"rfp10\\\"); // reading invalid full exit pubdata size\\n    }\\n\\n    function writeFullExitPubdata(FullExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            op.accountId,  // accountId\\n            op.owner,      // owner\\n            op.tokenId,    // tokenId\\n            op.amount      // amount\\n        );\\n    }\\n\\n    /// @notice Check that full exit pubdata from request and block matches\\n    function fullExitPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // `amount` is ignored because it is present in block pubdata but not in priority queue\\n        uint lhs = Bytes.trim(_lhs, PACKED_FULL_EXIT_PUBDATA_BYTES - AMOUNT_BYTES);\\n        uint rhs = Bytes.trim(_rhs, PACKED_FULL_EXIT_PUBDATA_BYTES - AMOUNT_BYTES);\\n        return lhs == rhs;\\n    }\\n\\n    // PartialExit pubdata\\n    \\n    struct PartialExit {\\n        //uint32 accountId; -- present in pubdata, ignored at serialization\\n        uint16 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address owner;\\n    }\\n\\n    function readPartialExitPubdata(bytes memory _data, uint _offset) internal pure\\n        returns (PartialExit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = _offset + ACCOUNT_ID_BYTES;                   // accountId (ignored)\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES;                                        // fee (ignored)\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);  // owner\\n    }\\n\\n    function writePartialExitPubdata(PartialExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),  // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId, // tokenId\\n            op.amount,  // amount\\n            bytes2(0),  // fee (ignored)  (update when FEE_BYTES is changed)\\n            op.owner    // owner\\n        );\\n    }\\n\\n    // ChangePubKey\\n\\n    struct ChangePubKey {\\n        uint32 accountId;\\n        bytes20 pubKeyHash;\\n        address owner;\\n        uint32 nonce;\\n    }\\n\\n    function readChangePubKeyPubdata(bytes memory _data, uint _offset) internal pure\\n        returns (ChangePubKey memory parsed)\\n    {\\n        uint offset = _offset;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset);                // accountId\\n        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset);              // pubKeyHash\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);                   // owner\\n        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset);                    // nonce\\n    }\\n\\n    // Withdrawal data process\\n\\n    function readWithdrawalData(bytes memory _data, uint _offset) internal pure\\n        returns (bool _addToPendingWithdrawalsQueue, address _to, uint16 _tokenId, uint128 _amount)\\n    {\\n        uint offset = _offset;\\n        (offset, _addToPendingWithdrawalsQueue) = Bytes.readBool(_data, offset);\\n        (offset, _to) = Bytes.readAddress(_data, offset);\\n        (offset, _tokenId) = Bytes.readUInt16(_data, offset);\\n        (offset, _amount) = Bytes.readUInt128(_data, offset);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/UpgradeableMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\\n/// @author Matter Labs\\ninterface UpgradeableMaster {\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint);\\n\\n    /// @notice Notifies contract that notice period started\\n    function upgradeNoticePeriodStarted() external;\\n\\n    /// @notice Notifies contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external;\\n\\n    /// @notice Notifies contract that upgrade canceled\\n    function upgradeCanceled() external;\\n\\n    /// @notice Notifies contract that upgrade finishes\\n    function upgradeFinishes() external;\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/Governance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Config.sol\\\";\\n\\n\\n/// @title Governance Contract\\n/// @author Matter Labs\\ncontract Governance is Config {\\n\\n    /// @notice Token added to Franklin net\\n    event NewToken(\\n        address indexed token,\\n        uint16 indexed tokenId\\n    );\\n\\n    /// @notice Governor changed\\n    event NewGovernor(\\n        address newGovernor\\n    );\\n\\n    /// @notice Validator's status changed\\n    event ValidatorStatusUpdate(\\n        address indexed validatorAddress,\\n        bool isActive\\n    );\\n\\n    /// @notice Address which will exercise governance over the network i.e. add tokens, change validator set, conduct upgrades\\n    address public networkGovernor;\\n\\n    /// @notice Total number of ERC20 tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 public totalTokens;\\n\\n    /// @notice List of registered tokens by tokenId\\n    mapping(uint16 => address) public tokenAddresses;\\n\\n    /// @notice List of registered tokens by address\\n    mapping(address => uint16) public tokenIds;\\n\\n    /// @notice List of permitted validators\\n    mapping(address => bool) public validators;\\n\\n    constructor() public {}\\n\\n    /// @notice Governance contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    ///     _networkGovernor The address of network governor\\n    function initialize(bytes calldata initializationParameters) external {\\n        address _networkGovernor = abi.decode(initializationParameters, (address));\\n\\n        networkGovernor = _networkGovernor;\\n    }\\n\\n    /// @notice Governance contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {\\n        revert(\\\"upggv\\\"); // it is the first version, upgrade is not supported, use initialize\\n    }\\n\\n    /// @notice Change current governor\\n    /// @param _newGovernor Address of the new governor\\n    function changeGovernor(address _newGovernor) external {\\n        requireGovernor(msg.sender);\\n        if (networkGovernor != _newGovernor) {\\n            networkGovernor = _newGovernor;\\n            emit NewGovernor(_newGovernor);\\n        }\\n    }\\n\\n    /// @notice Add token to the list of networks tokens\\n    /// @param _token Token address\\n    function addToken(address _token) external {\\n        requireGovernor(msg.sender);\\n        require(tokenIds[_token] == 0, \\\"gan11\\\"); // token exists\\n        require(totalTokens < MAX_AMOUNT_OF_REGISTERED_TOKENS, \\\"gan12\\\"); // no free identifiers for tokens\\n\\n        totalTokens++;\\n        uint16 newTokenId = totalTokens; // it is not `totalTokens - 1` because tokenId = 0 is reserved for eth\\n\\n        tokenAddresses[newTokenId] = _token;\\n        tokenIds[_token] = newTokenId;\\n        emit NewToken(_token, newTokenId);\\n    }\\n\\n    /// @notice Change validator status (active or not active)\\n    /// @param _validator Validator address\\n    /// @param _active Active flag\\n    function setValidator(address _validator, bool _active) external {\\n        requireGovernor(msg.sender);\\n        if (validators[_validator] != _active) {\\n            validators[_validator] = _active;\\n            emit ValidatorStatusUpdate(_validator, _active);\\n        }\\n    }\\n\\n    /// @notice Check if specified address is is governor\\n    /// @param _address Address to check\\n    function requireGovernor(address _address) public view {\\n        require(_address == networkGovernor, \\\"grr11\\\"); // only by governor\\n    }\\n\\n    /// @notice Checks if validator is active\\n    /// @param _address Validator address\\n    function requireActiveValidator(address _address) external view {\\n        require(validators[_address], \\\"grr21\\\"); // validator is not active\\n    }\\n\\n    /// @notice Validate token id (must be less than or equal to total tokens amount)\\n    /// @param _tokenId Token id\\n    /// @return bool flag that indicates if token id is less than or equal to total tokens amount\\n    function isValidTokenId(uint16 _tokenId) external view returns (bool) {\\n        return _tokenId <= totalTokens;\\n    }\\n\\n    /// @notice Validate token address\\n    /// @param _tokenAddr Token address\\n    /// @return tokens id\\n    function validateTokenAddress(address _tokenAddr) external view returns (uint16) {\\n        uint16 tokenId = tokenIds[_tokenAddr];\\n        require(tokenId != 0, \\\"gvs11\\\"); // 0 is not a valid token\\n        return tokenId;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Verifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./KeysWithPlonkVerifier.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract Verifier is KeysWithPlonkVerifier {\\n\\n    bool constant DUMMY_VERIFIER = false;\\n\\n    function initialize(bytes calldata) external {\\n    }\\n\\n    /// @notice Verifier contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {\\n        revert(\\\"upgvf\\\"); // it is the first version, upgrade is not supported, use initialize\\n    }\\n\\n    function isBlockSizeSupported(uint32 _size) public pure returns (bool) {\\n        if (DUMMY_VERIFIER) {\\n            return true;\\n        } else {\\n            return isBlockSizeSupportedInternal(_size);\\n        }\\n    }\\n\\n    function verifyBlockProof(\\n        uint256[] calldata _proof,\\n        bytes32 _commitment,\\n        uint32 _chunks\\n    ) external view returns (bool) {\\n        if (DUMMY_VERIFIER) {\\n            uint oldGasValue = gasleft();\\n            uint tmp;\\n            while (gasleft() + 470000 > oldGasValue) {\\n                tmp += 1;\\n            }\\n            return true;\\n        }\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(_commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkBlock(_chunks);\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n\\n    function verifyExitProof(\\n        bytes32 _rootHash,\\n        uint32 _accountId,\\n        address _owner,\\n        uint16 _tokenId,\\n        uint128 _amount,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes32 commitment = sha256(abi.encodePacked(_rootHash, _accountId, _owner, _tokenId, _amount));\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkExit();\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\ninterface Upgradeable {\\n\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/KeysWithPlonkVerifier.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.7.0;\\n\\nimport \\\"./PlonkCore.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkVerifier is VerifierWithDeserialize {\\n\\n    function isBlockSizeSupportedInternal(uint32 _size) internal pure returns (bool) {\\n        if (_size == uint32(6)) { return true; }\\n        else if (_size == uint32(30)) { return true; }\\n        else if (_size == uint32(74)) { return true; }\\n        else if (_size == uint32(150)) { return true; }\\n        else if (_size == uint32(334)) { return true; }\\n        else if (_size == uint32(678)) { return true; }\\n        else { return false; }\\n    }\\n\\n    function getVkBlock(uint32 _chunks) internal pure returns (VerificationKey memory vk) {\\n        if (_chunks == uint32(6)) { return getVkBlock6(); }\\n        else if (_chunks == uint32(30)) { return getVkBlock30(); }\\n        else if (_chunks == uint32(74)) { return getVkBlock74(); }\\n        else if (_chunks == uint32(150)) { return getVkBlock150(); }\\n        else if (_chunks == uint32(334)) { return getVkBlock334(); }\\n        else if (_chunks == uint32(678)) { return getVkBlock678(); }\\n    }\\n\\n    \\n    function getVkBlock6() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 2097152;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x032750f8f3c2493d0828c7285d0258e1bdcaa463f4442a52747b5c96639659bb);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x1b7fa1de720cdc2b00f479d3a35202d68654dd91a9deb0b05379ea97271afeb7,\\n            0x0f8008f972e7922e94754b06b9cfb928028fd6f08468f4c744ecb215cf3edb05\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x18365d42e5d139ae2551ce0f35dcde75802a3eda6db726aa72646c32aa48b06b,\\n            0x0358462dec754b7f358d5d44f054e85d7b483b7981c31d71c0e34e050516f883\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x2445645ddd0bb89a1b83c6bc74bc94175ba1a3fdc368be74b21faf93f953923a,\\n            0x1dbc5b237083262425c4f63ec5e2de6b0d807f1d88303cb56d0bc75fc1d24de3\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x0382797ba8eeae1e57f130278c885572af26cf07809ab1a4f3080741b58315b7,\\n            0x0c19775cf8c7824578c02f43762c93c1e8063d23dc28e5ee228d49f75f8f9802\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x1d503a4bc5cf164dc76889f8fcef13908867d216c414799ab865073903947ab7,\\n            0x1b3732c3f461e604fadf69e7e8f0fde8b573e495cfebb8d15ccfd7572f6bc69c\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x00b44c0c88c5895e9531f7d45503407e8b30183ecf8fdaf1c0e3b97779730635,\\n            0x08034399d230d4ead30357c8b6ea5fdf0e65c17effa024e94d173cb9332d2327\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x2ffc4b46e96a7912cf417c2a1696fd8eab251671a03899dbd72e9720fadad9fc,\\n            0x110f44b9dec1efe1e0a8d9408ebc351f2e9e3a4e6781b6c3b328976758c85103\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1d6b5368111d3c6606742131dd1da0c5073cc89b76bd3c0add22696c595cb06e,\\n            0x089e09860171419290337f07117448b94d27f130fedd09085e2715bdee19c42a\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x07f2bec19bb75acebd6b16086b56bcf9c1c6126e3fd82f96394ae9c18b453fc6,\\n            0x1160ac59ecfa2c6a48358aa36dab56a14c9e8fc58d16a9a58601e0c35f77fcde\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x1baf42bafdd5b65227b33f9e5bacde59eef0f9fbe28944955bc4bf1efb9f5da1,\\n            0x1d834ac270c6effa5bdf5f37b6ea7f86fd87dee8d400d174ace30af27a59ba8a\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x1a6aa64fef657595bea54736fd917459791f0b6f55c5890f4e6c6b0183c59ce6,\\n            0x18a8823190b856bd14505c3686155379165a6f8d7b2f0380ac72ceeb170f0605\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkBlock30() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 4194304;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x18c95f1ae6514e11a1b30fd7923947c5ffcec5347f16e91b4dd654168326bede);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x0a51ea80462128f55936990b8ebad4b3ac03ca598ef10e322af9c6016efa21f0,\\n            0x02ee47d84772cde7ffc322cf3704bc9689d6f99d14c3fa6744b971bdb31d541b\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x0b3364c30428840ec9663c6001c69ab340f32e33fb22b6e63ce2b2d7ab6dc39e,\\n            0x229706225a2e22e40e1b80f04501479ccf805cbb886728e65d3fd522ae8d0593\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x04a7cabf8ee567036ae78405df03ec6b90b2b80c6f0b62d6129e967a37d9ed24,\\n            0x0a1f7e2229541b50175945e32e192f6b9073499fa30ce9ac13d542e7bbba2d92\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x063f7fdcf4ca3fa2c3ce085e644c693d2a6a6451a0737c1a34b530c98ad0eab7,\\n            0x305bf32b20d102ecc65ec1ae0cb6a2ec70e8850a0c525ba75484211a33d6909e\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x10bca91f25c1d27ad6422450f449b4e88ab95bb880fff20d7726f0f54ddd1cc3,\\n            0x1cad88f1e381964ce4c9b50ec63040fbbbd7a1586859d50c6ae994fe5bb942a4\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x12895c715afa08dda4b2e64b452c5cebfba509c44a5ec40c7fc60822d8cfc71b,\\n            0x2fd6fd651ee440047e75ba856d1d9c905f87a5af94a9c91287359bdd650358c7\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x14502af4737adff4bd0a1bf368195b66c6025ad8fe931133c257654044b7cd67,\\n            0x1ea1a2da257a5cfb992e804552948b55eb8828e772f4ba8145b906c1c6429c56\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x17fa690797738baba8441cc20310332e104ecab06c3cb7afee26db16d6552e00,\\n            0x1067e3dfc8e17a65831b6adc15597b774dc31731a8c8c678dd643c3f3bee91f8\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2e6f8cb6126d8cfb2d52beffb11ada8e9befc68d07c17fcaa6160d4272537c14,\\n            0x2a47f9f8e4e541455aa6bb2fa5c9e33a6a4b8af8ba2487b6d225918d151aaf4e\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x2e82c35689283a51014da92a2e9f1d72b12975fdae0bd5660eb1de27149465ab,\\n            0x199a725575c46e1bd25cbead965e3cbd98d40556d67b970319fae3d486327ed1\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x23f09b8c571bf69633a3a6261ac520bbed2202847a631e6938e1cdacac0b2107,\\n            0x12478416bcee6d8cf02659b663455edb2f7417b70eef27d28c2223f06807712d\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkBlock74() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 8388608;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1283ba6f4b7b1a76ba2008fe823128bea4adb9269cbfd7c41c223be65bc60863);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x23f18047e7f13452e2fd9ff957f64a480c7d39e3dddd6079048476e73682fc78,\\n            0x034bf29d128cebebdce82cae0ecaa822ad727fe128ba23017478d96f8c0c1cda\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x2a6dbbd7a2a0022f89ff9a4550eac7aae746332acdad833065c6a5ced0e061b5,\\n            0x02079d7199cb75dc81964bfde2b0a7007d5236206fa4f97032ecd53939b3f4e1\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x21a7754b681171ab2bc0bee630fb97df3bd053d3eae6e6986902c456b9636952,\\n            0x2352c0647771039b72c45e6acdbfb63efb8c2f8c56ed5b33860ddf7d83c4229f\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x2e3f3c1c2cb9870562fc94585c5fb476aab0ffc46ed93475c4c768baac92e474,\\n            0x0d4417fc21e876e586a469ffa678f155b6c5938eab7d7eb40de203ddeb44d53c\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x2887217f1bf98c084ad1e722ade570ea3b2de97ae19d373be759c3eaf256cde1,\\n            0x0c7a85ba1ac4bb3be0dedbc2658b7d71eb5435897783a2f2dfde027555cca62c\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x21de0db0c7c54c6936eb1d1a45d6ce6fc8904156a257c09416e11a18e68608af,\\n            0x236e692ab84cd24a4f644fe6b535a6869c4630fe179ea283fc7c0b888da407f8\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x119208094200a6ad766c323002f1031525a0e149b0333de6fe6cf64f787d12f3,\\n            0x06fd9bcad5f4a874cebfd1f23f8d68151144c0915c7bd4e8dfa8947d2567189c\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x05ea8d7091eac4933a595bb32a337ea26c1bfafcea43a8497357c9c6e72b083f,\\n            0x298b58844cfe7381cae17b7a137617a59d221842e24b5864c86483978ce808f0\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2a9b4734ec68c7e90b2e4849932dd3a62876535f60038248634abcae143d5c8a,\\n            0x2bdf3e61783efba973e021f9110836e9f04566eb3dc4c5e84701870443b6a010\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x267a8cc6e5401bd2e4f9fb6949e62928193c9aad21eaaf14f7c9af1d091a8ae3,\\n            0x0174ee0780a86c7d4397f5daf156f8c0433bdc9cd2ede24406f36aa5f0acbf48\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x09945ca4449fa736821cf90aecd390ea930ba95e9b98b7bfebfb8f5dd1cb1735,\\n            0x2e691bb27e7151439e354b8a24a7dec8a01545f2219f96d852969c61a87000c5\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkBlock150() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 16777216;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x0a1a1f5d6db6e9dc584ffff3c212be26a3785b68a61cf237dfd16ffee921e6a9,\\n            0x00db9a67e6958d30a212bfe4a0e5861380d1ca1055419ebfb484a66353f16d53\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x20ede8e875ef8380ddacd6dc0d31713107ae0ef39e142852a9808d42ccbdb0c1,\\n            0x08b74e0afc5bf083725f9939568a5581967241a01d5a890e47687089069a7a76\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x057c51ca8cd775db79adc63e82e09a60324fcc95ed13986218b74ba952a18573,\\n            0x138e5712b1617a9323cb9a6c97a52d454130929d3ca727fbdaf8a18c9f43b55c\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x0bb0efb7375a13e88080e8ee7b9a5163def75d815a0aec53cab077f0b38caa67,\\n            0x2d9e82fb4d502732ad4babe1877e80e38054f35e5524bf3c24f2e625588fbf21\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x12f1d4a8f4609473250e641ae0b11f10affa18a769ba175caea3fe785edec2ce,\\n            0x04277b64397307db55f58c20a3d6864003c768fd4e4aab83e26b9963f2e9a002\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x2edfaa6e36baf1c55b177582366264a5866a4cabf98eb3d84a1aedeedecf2a43,\\n            0x0180c206de268ef3fdf701ca3e3b1c96c5a98649ec3b01b9730f34ffc1a8f7e5\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x0cae0664fdfa45215ec9c98e225557292f71e42b7ee486f6cdbde0aefc015945,\\n            0x2b661a5b9c3f6130ac77d5d665baf3e286f068a181fb0bf957e850f00156e5e8\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x0f5c9bfacd0cee94b84ff62cc3f26e18b89fb69910a41231b4eef3ad516afd5c,\\n            0x2379fed7c329f84d7655e6b1145f6f0b428ed8a8df76f62f97b8804ebd3daea0\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2b3b2d6831f0220f5893c002ecd9e382cf2fbc27da2d3c040ce50d0ed83991ed,\\n            0x0e245126c4ddab15ae6be4d8db7ea7dd6f94593ed7152ecd73d6b7961decff32\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x0baaf7842b4d13ed569cb4a2bf11f16dc6008259efce1052022b6cb479c47fb7,\\n            0x0e51f02a004492b8c24c6bb5726725785709c96b00a1b87a97d45b13fd1722a5\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2fe999258c8a8d18bc545bf57158cac51f94a35be73aed66c03a26c136a1fbd4,\\n            0x2ce032cd81cc7523a896574f44398de4de8564f24abd860dbeba3e25fbd4be61\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkBlock334() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 33554432;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0d94d63997367c97a8ed16c17adaae39262b9af83acb9e003f94c217303dd160);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x16b621799bf874320688bdc6001550d974e69b48b8fd5ff9c8fbbd0d23119ae0,\\n            0x018892a23a02980d9ba2f26cafedc01a7ba5363072328c783c8206f7745a8d79\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x27b747297b97efae9364dc38e7552fbf4ec4fc2c4b3123799eebc75823e75c2f,\\n            0x1b46cb39ec8c92fae4fa6b31cd2689ef1d80b6e6c2074d45ee90957dc658030f\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x1f634cc98ae4ab87a57423fff29f26c72efeb515805d813755e1c36f6697550c,\\n            0x0e7f592ab203c92e05ce28548b7508a768f447ddc4d6308340fa197d72654a68\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x150ff91c94a3206cf64fb5b4e59487859fc588dfd6506ae6e358dcd0817412fb,\\n            0x17d93c2b5f623ef8a68ab03d4cdf85b413cf63aa0e608f3280d2d3ef4f7e2619\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x1fc89917557fbd11b0ee52a13e9f148b096290ef5dff078da0bbcf7871744ec0,\\n            0x29b444286b18e4a76c624fe1bbccfb730a520d990ad56bffcccfd96f47a7a833\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x0d927553dba7ecf854a7111868d7f8622f2ba196c21e0bfbe5f8af9f185ba442,\\n            0x1469ca794af0355e04a88189de9776a9cf04fb425dc21b779c6b3e08b854a64c\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x122655733fe0f8653789bfe96c957d6265b7ee6f0b501f3c9adc880f2a637bb0,\\n            0x0ec03051e54b61a4ad505bc6af98662301c0d8fd403a7f8e6b826bb53e79dd1e\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x2a7ebc7776d4fa15b8651eae44fab392aba9ff7073f3edfd7b848706ef3bfd6f,\\n            0x03111f951e32e99ef940b10b2c75b04049c11fbe6990da12e03388ca8a187ba2\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2da022e2195e92fb26c2ec848d996c57ee9e7cca9c409aef7fc5111d97127793,\\n            0x24d8182529c20362cf46237298d73d0febd7b01706d34f735b7594c1eddd035b\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x1b30ed4b4068fd5794d74b2eb76b0952e29d7cabaaa7bb5cd8afd985b3634293,\\n            0x09d86602575fd10ceba20e6cd98c182def2a5552978df02ebc6c48a18a5261f8\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2e8236c1267534ac088b251270ba9e5762a203cb025b636410fb4067096ae9c9,\\n            0x19c47b480290e45b9eaf9c878372922f3c805d369e072423adfdab846a6b77da\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkBlock678() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 67108864;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1dba8b5bdd64ef6ce29a9039aca3c0e524395c43b9227b96c75090cc6cc7ec97);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x12e523281c5e083564f87ebf71e8bcb5615596e8f755056c258341173ef633f8,\\n            0x0ff470566f5d737f92d3bd33ae407a1bf679804debe1dc33a3f86da8eacdfbd4\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x123af186f997895949cbba9f961b2d012723c8d04eca90d048a66dbdc01cab18,\\n            0x0a8a416e550417bd7977e51126c7a9af80cd65567eb5ffb4195f17501abe1a9e\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x0091717cac476948a386ff3043b0461f0d0b368cb369586b546b07bb84ce91dd,\\n            0x20486d6fb751acc889ec358a2df637b966677ccbea9d39de97db1e4f405cf2cd\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x021b1b727fc6b7e0f5f77d11417afb20f6cd492ba086770e88907d6bf56bd4a4,\\n            0x22b06a74279272942459b65e888f1bc6444a3a15710257ebaa7da25bf17436ea\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x268ebe620f72bf02b32256f1aec10c3214457bcb6c0864a5a3a71f8198a599df,\\n            0x1d8ba556f2a807f4454c043749cfca65a70bb92e01b3bed01f5ae999b85817f5\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x0c7b608ac4b3a18f55eeffb1e1f6f720b3d9bd7835a120a8d5df60050a157b4a,\\n            0x2e6acf782b67806832f1a258b0e5f9e7c4ac1de83e9cab49509b9f035f5e9dbb\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x219c6272cbc3ae7d9e8d366e379673414bdf283beed79a959f2e8181cd064144,\\n            0x06e93645439a57524c4836188cebb6369ae36267e6a9665156c13ae317e0ad4c\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x13626ee4cb40e8783c91c9f55272c1f970df3486b98a39d7caf67b188de9109d,\\n            0x12bf400879bbdb556fda31f1d604df9b48dfe27d9429e4e55a034c2858261eec\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x246b842ca3eeee58b21a59e43c1b9e2da2e697378d79d4260325258b831feeba,\\n            0x2c9ce5bad6dc5d16cd0a8e9c7c7b9da64cba83fe277cde913497c9eac2aaafc7\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x2b45db9668ca0695cdd74e41bfce4c676f3786d6ff94d4151c80edabe8cdce3a,\\n            0x0b01705505015831057a6d28285a10f315767904df5cf474e2ad0692eb8c5868\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x245a71570a6a716912e304ea15e1365ea7eb378df8d70665525113ebda0202de,\\n            0x28003d8b4b1c49b127363f05ff2ea2faa0bac2f722f0d51c9e4b26ab8b6438bf\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkExit() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 262144;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0f60c8fe0414cb9379b2d39267945f6bd60d06a05216231b26a9fcf88ddbfebe);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x117ebe939b7336d17b69b05d5530e30326af39da45a989b078bb3d607707bf3e,\\n            0x18b16095a1c814fe2980170ff34490f1fd454e874caa87df2f739fb9c8d2e902\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x05ac70a10fc569cc8358bfb708c184446966c6b6a3e0d7c25183ded97f9e7933,\\n            0x0f6152282854e153588d45e784d216a423a624522a687741492ee0b807348e71\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x03cfa9d8f9b40e565435bee3c5b0e855c8612c5a89623557cc30f4588617d7bd,\\n            0x2292bb95c2cc2da55833b403a387e250a9575e32e4ce7d6caa954f12e6ce592a\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x04d04f495c69127b6cc6ecbfd23f77f178e7f4e2d2de3eab3e583a4997744cd9,\\n            0x09dcf5b3db29af5c5eef2759da26d3b6959cb8d80ada9f9b086f7cc39246ad2b\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x01ebab991522d407cfd4e8a1740b64617f0dfca50479bba2707c2ec4159039fc,\\n            0x2c8bd00a44c6120bbf8e57877013f2b5ee36b53eef4ea3b6748fd03568005946\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x07a7124d1fece66bd5428fcce25c22a4a9d5ceaa1e632565d9a062c39f005b5e,\\n            0x2044ae5306f0e114c48142b9b97001d94e3f2280db1b01a1e47ac1cf6bd5f99e\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x1dd1549a639f052c4fbc95b7b7a40acf39928cad715580ba2b38baa116dacd9c,\\n            0x0f8e712990da1ce5195faaf80185ef0d5e430fdec9045a20af758cc8ecdac2e5\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x0026b64066e39a22739be37fed73308ace0a5f38a0e2292dcc2309c818e8c89c,\\n            0x285101acca358974c2c7c9a8a3936e08fbd86779b877b416d9480c91518cb35b\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2159265ac6fcd4d0257673c3a85c17f4cf3ea13a3c9fb51e404037b13778d56f,\\n            0x25bf73e568ba3406ace2137195bb2176d9de87a48ae42520281aaef2ac2ef937\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x068f29af99fc8bbf8c00659d34b6d34e4757af6edc10fc7647476cbd0ea9be63,\\n            0x2ef759b20cabf3da83d7f578d9e11ed60f7015440e77359db94475ddb303144d\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x22793db6e98b9e37a1c5d78fcec67a2d8c527d34c5e9c8c1ff15007d30a4c133,\\n            0x1b683d60fd0750b3a45cdee5cbc4057204a02bd428e8071c92fe6694a40a5c1f\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n\\n}\\n\"\r\n    },\r\n    \"contracts/PlonkCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.7.0;\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod-2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint[2] X;\\n        uint[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod);\\n        require(y < q_mod);\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs);\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return G2Point(\\n            [0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n            0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed],\\n            [0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n            0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa]\\n        );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2)\\n    internal view returns (G1Point memory r)\\n    {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2)\\n    internal view\\n    {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(G1Point memory p1, G1Point memory p2, G1Point memory dest)\\n    internal view\\n    {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2)\\n    internal view\\n    {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(G1Point memory p1, G1Point memory p2, G1Point memory dest)\\n    internal view\\n    {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s)\\n    internal view returns (G1Point memory r)\\n    {\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s)\\n    internal view\\n    {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(G1Point memory p, Fr memory s, G1Point memory dest)\\n    internal view\\n    {\\n        uint[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2)\\n    internal view returns (bool)\\n    {\\n        require(p1.length == p2.length);\\n        uint elements = p1.length;\\n        uint inputSize = elements * 6;\\n        uint[] memory input = new uint[](inputSize);\\n        for (uint i = 0; i < elements; i++)\\n        {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n        }\\n        uint[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(G1Point memory a1, G2Point memory a2, G1Point memory b1, G2Point memory b2)\\n    internal view returns (bool)\\n    {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\\nlibrary TranscriptLibrary {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns(PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNext {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant STATE_WIDTH = 4;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\\n\\n    struct VerificationKey {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[STATE_WIDTH+2] selector_commitments; // STATE_WIDTH for witness + multiplication + constant\\n        PairingsBn254.G1Point[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] next_step_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH-1] permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\\n        PairingsBn254.G1Point grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\\n        PairingsBn254.Fr grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH-1] permutation_polynomials_at_z;\\n\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function batch_evaluate_lagrange_poly_out_of_domain(\\n        uint256[] memory poly_nums,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\\n        vanishing_at_z.sub_assign(one);\\n        // we can not have random point z be in domain\\n        require(vanishing_at_z.value != 0);\\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\\n        // numerators in a form omega^i * (z^n - 1)\\n        // denoms in a form (z - omega^i) * N\\n        for (uint i = 0; i < poly_nums.length; i++) {\\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\\n            nums[i].assign(vanishing_at_z);\\n            nums[i].mul_assign(tmp_1);\\n\\n            dens[i].assign(at); // (X - omega^i) * N\\n            dens[i].sub_assign(tmp_1);\\n            dens[i].mul_assign(tmp_2); // mul by domain size\\n        }\\n\\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\\n        partial_products[0].assign(PairingsBn254.new_fr(1));\\n        for (uint i = 1; i < dens.length - 1; i++) {\\n            partial_products[i].assign(dens[i-1]);\\n            partial_products[i].mul_assign(dens[i]);\\n        }\\n\\n        tmp_2.assign(partial_products[partial_products.length - 1]);\\n        tmp_2.mul_assign(dens[dens.length - 1]);\\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\\n\\n        for (uint i = dens.length - 1; i < dens.length; i--) {\\n            dens[i].assign(tmp_2); // all inversed\\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\\n            tmp_2.mul_assign(dens[i]);\\n        }\\n\\n        for (uint i = 0; i < nums.length; i++) {\\n            nums[i].mul_assign(dens[i]);\\n        }\\n\\n        return nums;\\n    }\\n\\n    function evaluate_vanishing(\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            rhs.add_assign(tmp);\\n        }\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function reconstruct_d(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^(6..8) * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^9 (z(x) - z(z*omega)) <- we need this power\\n        // + v^10 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n        // we pay a little for a few arithmetic operations to not introduce another constant\\n        uint256 power_for_z_omega_opening = 1 + 1 + STATE_WIDTH + STATE_WIDTH - 1;\\n        res = PairingsBn254.copy_g1(vk.selector_commitments[STATE_WIDTH + 1]);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            tmp_g1 = vk.selector_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.selector_commitments[STATE_WIDTH].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.next_step_selector_commitments[0].point_mul(proof.wire_values_at_z_omega[0]);\\n        res.point_add_assign(tmp_g1);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i+1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(state.alpha);\\n        tmp_fr.mul_assign(state.alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        PairingsBn254.Fr memory grand_product_part_at_z_omega = state.v.pow(power_for_z_omega_opening);\\n        grand_product_part_at_z_omega.mul_assign(state.u);\\n\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(state.alpha);\\n\\n        // add to the linearization\\n        tmp_g1 = proof.grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        res.point_mul_assign(state.v);\\n\\n        res.point_add_assign(proof.grand_product_commitment.point_mul(grand_product_part_at_z_omega));\\n    }\\n\\n    function verify_commitments(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.G1Point memory d = reconstruct_d(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint i = 0; i < vk.permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        return PairingsBn254.pairingProd2(pair_with_generator, PairingsBn254.P2(), pair_with_x, vk.g2_x);\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs >= 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n\\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain(\\n            lagrange_poly_numbers,\\n            vk.domain_size,\\n            vk.omega, state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        PartialVerifierState memory state;\\n\\n        bool valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = verify_commitments(state, proof, vk);\\n\\n        return valid;\\n    }\\n}\\n\\ncontract VerifierWithDeserialize is Plonk4VerifierWithAccessToDNext {\\n    uint256 constant SERIALIZED_PROOF_LENGTH = 33;\\n\\n    function deserialize_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof\\n    ) internal pure returns(Proof memory proof) {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        proof.grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        proof.grand_product_at_z_omega = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"}],\"name\":\"BlockCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"}],\"name\":\"BlockVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"totalBlocksVerified\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"totalBlocksCommitted\",\"type\":\"uint32\"}],\"name\":\"BlocksRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"franklinBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"DepositCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ExodusMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fact\",\"type\":\"bytes\"}],\"name\":\"FactAuth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"franklinBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"FullExitCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"serialId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enum Operations.OpType\",\"name\":\"opType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"}],\"name\":\"NewPriorityRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OnchainDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"OnchainWithdrawal\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"EMPTY_STRING_KECCAK\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"authFacts\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes22\",\"name\":\"\",\"type\":\"bytes22\"}],\"name\":\"balancesToWithdraw\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"balanceToWithdraw\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"gasReserveValue\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"committedAtBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"chunks\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawalsDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_n\",\"type\":\"uint64\"}],\"name\":\"cancelOutstandingDepositsForExodusMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_feeAccount\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_newBlockInfo\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_publicData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_ethWitness\",\"type\":\"bytes\"},{\"internalType\":\"uint32[]\",\"name\":\"_ethWitnessSizes\",\"type\":\"uint32[]\"}],\"name\":\"commitBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_n\",\"type\":\"uint32\"}],\"name\":\"completeWithdrawals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint104\",\"name\":\"_amount\",\"type\":\"uint104\"},{\"internalType\":\"address\",\"name\":\"_franklinAddr\",\"type\":\"address\"}],\"name\":\"depositERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_franklinAddr\",\"type\":\"address\"}],\"name\":\"depositETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"exited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exodusMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPendingWithdrawalIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPriorityRequestId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"fullExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"getBalanceToWithdraw\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getNoticePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initializationParameters\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"isReadyForUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfPendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"priorityRequests\",\"outputs\":[{\"internalType\":\"enum Operations.OpType\",\"name\":\"opType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"pubData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_maxBlocksToRevert\",\"type\":\"uint32\"}],\"name\":\"revertBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubkey_hash\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"}],\"name\":\"setAuthPubkeyHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBlocksCommitted\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBlocksVerified\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCommittedPriorityRequests\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOpenPriorityRequests\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerExodusIfNeeded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"upgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradeCanceled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradeFinishes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradeNoticePeriodStarted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradePreparationActivationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradePreparationActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradePreparationLockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradePreparationStarted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_withdrawalsData\",\"type\":\"bytes\"}],\"name\":\"verifyBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxAmount\",\"type\":\"uint128\"}],\"name\":\"withdrawERC20Guarded\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"withdrawnAmount\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ZkSync","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}