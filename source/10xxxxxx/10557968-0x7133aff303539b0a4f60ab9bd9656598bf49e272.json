{"status":"1","message":"OK","result":[{"SourceCode":"/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: EtherCollateral.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/EtherCollateral.sol\n* Docs: https://docs.synthetix.io/contracts/EtherCollateral\n*\n* Contract Dependencies: \n*\t- IAddressResolver\n*\t- IEtherCollateral\n*\t- MixinResolver\n*\t- Owned\n*\t- Pausable\n*\t- ReentrancyGuard\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n/* ===============================================\n* Flattened with Solidifier by Coinage\n* \n* https://solidifier.coina.ge\n* ===============================================\n*/\n\n\npragma solidity ^0.5.16;\n\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    constructor() internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsStale() external view returns (bool anyRateStale);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesStale(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsStale);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsStale(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsStale);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function liquidateDelinquentAccount(address account, uint susdAmount, address liquidator) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/AddressResolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            repository[names[i]] = destinations[i];\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/MixinResolver\ncontract MixinResolver is Owned {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    bytes32[] public resolverAddressesRequired;\n\n    uint public constant MAX_ADDRESSES_FROM_RESOLVER = 24;\n\n    constructor(address _resolver, bytes32[MAX_ADDRESSES_FROM_RESOLVER] memory _addressesToCache) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        for (uint i = 0; i < _addressesToCache.length; i++) {\n            if (_addressesToCache[i] != bytes32(0)) {\n                resolverAddressesRequired.push(_addressesToCache[i]);\n            } else {\n                // End early once an empty item is found - assumes there are no empty slots in\n                // _addressesToCache\n                break;\n            }\n        }\n        resolver = AddressResolver(_resolver);\n        // Do not sync the cache as addresses may not be in the resolver yet\n    }\n\n    /* ========== SETTERS ========== */\n    function setResolverAndSyncCache(AddressResolver _resolver) external onlyOwner {\n        resolver = _resolver;\n\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            bytes32 name = resolverAddressesRequired[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            addressCache[name] = resolver.requireAndGetAddress(name, \"Resolver missing target\");\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function requireAndGetAddress(bytes32 name, string memory reason) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    // Note: this could be made external in a utility contract if addressCache was made public\n    // (used for deployment)\n    function isResolverCached(AddressResolver _resolver) external view returns (bool) {\n        if (resolver != _resolver) {\n            return false;\n        }\n\n        // otherwise, check everything\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            bytes32 name = resolverAddressesRequired[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Note: can be made external into a utility contract (used for deployment)\n    function getResolverAddressesRequired()\n        external\n        view\n        returns (bytes32[MAX_ADDRESSES_FROM_RESOLVER] memory addressesRequired)\n    {\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            addressesRequired[i] = resolverAddressesRequired[i];\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n    function appendToAddressCache(bytes32 name) internal {\n        resolverAddressesRequired.push(name);\n        require(resolverAddressesRequired.length < MAX_ADDRESSES_FROM_RESOLVER, \"Max resolver cache size met\");\n        // Because this is designed to be called internally in constructors, we don't\n        // check the address exists already in the resolver\n        addressCache[name] = resolver.getAddress(name);\n    }\n}\n\n\ninterface IEtherCollateral {\n    // Views\n    function totalIssuedSynths() external view returns (uint256);\n\n    function totalLoansCreated() external view returns (uint256);\n\n    function totalOpenLoanCount() external view returns (uint256);\n\n    // Mutative functions\n    function openLoan() external payable returns (uint256 loanID);\n\n    function closeLoan(uint256 loanID) external;\n\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\n\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    // Restricted functions\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\ninterface IFeePool {\n    // Views\n    function getExchangeFeeRateForSynth(bytes32 synthKey) external view returns (uint);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    // Restricted: used internally to Synthetix\n    function appendAccountIssuanceRecord(\n        address account,\n        uint lockedAmount,\n        uint debtEntryIndex\n    ) external;\n\n    function recordFeePaid(uint sUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\ninterface IDepot {\n\n    // Views\n    function fundsWallet() external view returns (address payable);\n\n    function maxEthPurchase() external view returns (uint);\n\n    function minimumDepositAmount() external view returns (uint);\n\n    function synthsReceivedForEther(uint amount) external view returns (uint);\n\n    function totalSellableDeposits() external view returns (uint);\n\n    // Mutative functions\n    function depositSynths(uint amount) external;\n\n    function exchangeEtherForSynths() external payable returns (uint);\n\n    function exchangeEtherForSynthsAtRate(uint guaranteedRate) external payable returns (uint);\n\n    function withdrawMyDepositedSynths() external;\n\n    // Note: On mainnet no SNX has been deposited. The following functions are kept alive for testnet SNX faucets.\n    function exchangeEtherForSNX() external payable returns (uint);\n\n    function exchangeEtherForSNXAtRate(uint guaranteedRate, uint guaranteedSynthetixRate) external payable returns (uint);\n\n    function exchangeSynthsForSNX(uint synthAmount) external returns (uint);\n\n    function synthetixReceivedForEther(uint amount) external view returns (uint);\n\n    function synthetixReceivedForSynths(uint amount) external view returns (uint);\n\n    function withdrawSynthetix(uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/IExchangeRates\ninterface IExchangeRates {\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function anyRateIsStale(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint value);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function inversePricing(bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint entryPoint,\n            uint upperLimit,\n            uint lowerLimit,\n            bool frozen\n        );\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\n        external\n        view\n        returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndStaleForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory, bool);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/EtherCollateral\ncontract EtherCollateral is Owned, Pausable, ReentrancyGuard, MixinResolver, IEtherCollateral {\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    // ========== CONSTANTS ==========\n    uint256 internal constant ONE_THOUSAND = 1e18 * 1000;\n    uint256 internal constant ONE_HUNDRED = 1e18 * 100;\n\n    uint256 internal constant SECONDS_IN_A_YEAR = 31536000; // Common Year\n\n    // Where fees are pooled in sUSD.\n    address internal constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    // ========== SETTER STATE VARIABLES ==========\n\n    // The ratio of Collateral to synths issued\n    uint256 public collateralizationRatio = SafeDecimalMath.unit() * 125; // SCCP-27\n\n    // If updated, all outstanding loans will pay this interest rate in on closure of the loan. Default 5%\n    uint256 public interestRate = (5 * SafeDecimalMath.unit()) / 100;\n    uint256 public interestPerSecond = interestRate.div(SECONDS_IN_A_YEAR);\n\n    // Minting fee for issuing the synths. Default 50 bips.\n    uint256 public issueFeeRate = (5 * SafeDecimalMath.unit()) / 1000;\n\n    // Maximum amount of sETH that can be issued by the EtherCollateral contract. Default 5000\n    uint256 public issueLimit = SafeDecimalMath.unit() * 5000;\n\n    // Minimum amount of ETH to create loan preventing griefing and gas consumption. Min 1ETH = 0.8 sETH\n    uint256 public minLoanSize = SafeDecimalMath.unit() * 1;\n\n    // Maximum number of loans an account can create\n    uint256 public accountLoanLimit = 50;\n\n    // If true then any wallet addres can close a loan not just the loan creator.\n    bool public loanLiquidationOpen = false;\n\n    // Time when remaining loans can be liquidated\n    uint256 public liquidationDeadline;\n\n    // ========== STATE VARIABLES ==========\n\n    // The total number of synths issued by the collateral in this contract\n    uint256 public totalIssuedSynths;\n\n    // Total number of loans ever created\n    uint256 public totalLoansCreated;\n\n    // Total number of open loans\n    uint256 public totalOpenLoanCount;\n\n    // Synth loan storage struct\n    struct SynthLoanStruct {\n        //  Acccount that created the loan\n        address account;\n        //  Amount (in collateral token ) that they deposited\n        uint256 collateralAmount;\n        //  Amount (in synths) that they issued to borrow\n        uint256 loanAmount;\n        // When the loan was created\n        uint256 timeCreated;\n        // ID for the loan\n        uint256 loanID;\n        // When the loan was paidback (closed)\n        uint256 timeClosed;\n    }\n\n    // Users Loans by address\n    mapping(address => SynthLoanStruct[]) public accountsSynthLoans;\n\n    // Account Open Loan Counter\n    mapping(address => uint256) public accountOpenLoanCounter;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_SYNTHSETH = \"SynthsETH\";\n    bytes32 private constant CONTRACT_SYNTHSUSD = \"SynthsUSD\";\n    bytes32 private constant CONTRACT_DEPOT = \"Depot\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n\n    bytes32[24] private addressesToCache = [\n        CONTRACT_SYSTEMSTATUS,\n        CONTRACT_SYNTHSETH,\n        CONTRACT_SYNTHSUSD,\n        CONTRACT_DEPOT,\n        CONTRACT_EXRATES\n    ];\n\n    // ========== CONSTRUCTOR ==========\n    constructor(address _owner, address _resolver)\n        public\n        Owned(_owner)\n        Pausable()\n        MixinResolver(_resolver, addressesToCache)\n    {\n        liquidationDeadline = now + 92 days; // Time before loans can be liquidated\n    }\n\n    // ========== SETTERS ==========\n\n    function setCollateralizationRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= ONE_THOUSAND, \"Too high\");\n        require(ratio >= ONE_HUNDRED, \"Too low\");\n        collateralizationRatio = ratio;\n        emit CollateralizationRatioUpdated(ratio);\n    }\n\n    function setInterestRate(uint256 _interestRate) external onlyOwner {\n        require(_interestRate > SECONDS_IN_A_YEAR, \"Interest rate cannot be less that the SECONDS_IN_A_YEAR\");\n        require(_interestRate <= SafeDecimalMath.unit(), \"Interest cannot be more than 100% APR\");\n        interestRate = _interestRate;\n        interestPerSecond = _interestRate.div(SECONDS_IN_A_YEAR);\n        emit InterestRateUpdated(interestRate);\n    }\n\n    function setIssueFeeRate(uint256 _issueFeeRate) external onlyOwner {\n        issueFeeRate = _issueFeeRate;\n        emit IssueFeeRateUpdated(issueFeeRate);\n    }\n\n    function setIssueLimit(uint256 _issueLimit) external onlyOwner {\n        issueLimit = _issueLimit;\n        emit IssueLimitUpdated(issueLimit);\n    }\n\n    function setMinLoanSize(uint256 _minLoanSize) external onlyOwner {\n        minLoanSize = _minLoanSize;\n        emit MinLoanSizeUpdated(minLoanSize);\n    }\n\n    function setAccountLoanLimit(uint256 _loanLimit) external onlyOwner {\n        uint256 HARD_CAP = 1000;\n        require(_loanLimit < HARD_CAP, \"Owner cannot set higher than HARD_CAP\");\n        accountLoanLimit = _loanLimit;\n        emit AccountLoanLimitUpdated(accountLoanLimit);\n    }\n\n    function setLoanLiquidationOpen(bool _loanLiquidationOpen) external onlyOwner {\n        require(now > liquidationDeadline, \"Before liquidation deadline\");\n        loanLiquidationOpen = _loanLiquidationOpen;\n        emit LoanLiquidationOpenUpdated(loanLiquidationOpen);\n    }\n\n    // ========== PUBLIC VIEWS ==========\n\n    function getContractInfo()\n        external\n        view\n        returns (\n            uint256 _collateralizationRatio,\n            uint256 _issuanceRatio,\n            uint256 _interestRate,\n            uint256 _interestPerSecond,\n            uint256 _issueFeeRate,\n            uint256 _issueLimit,\n            uint256 _minLoanSize,\n            uint256 _totalIssuedSynths,\n            uint256 _totalLoansCreated,\n            uint256 _totalOpenLoanCount,\n            uint256 _ethBalance,\n            uint256 _liquidationDeadline,\n            bool _loanLiquidationOpen\n        )\n    {\n        _collateralizationRatio = collateralizationRatio;\n        _issuanceRatio = issuanceRatio();\n        _interestRate = interestRate;\n        _interestPerSecond = interestPerSecond;\n        _issueFeeRate = issueFeeRate;\n        _issueLimit = issueLimit;\n        _minLoanSize = minLoanSize;\n        _totalIssuedSynths = totalIssuedSynths;\n        _totalLoansCreated = totalLoansCreated;\n        _totalOpenLoanCount = totalOpenLoanCount;\n        _ethBalance = address(this).balance;\n        _liquidationDeadline = liquidationDeadline;\n        _loanLiquidationOpen = loanLiquidationOpen;\n    }\n\n    // returns value of 100 / collateralizationRatio.\n    // e.g. 100/125 = 0.8\n    // or in wei 100000000000000000000/125000000000000000000 = 800000000000000000\n    function issuanceRatio() public view returns (uint256) {\n        // this Rounds so you get slightly more rather than slightly less\n        // 4999999999999999995000\n        return ONE_HUNDRED.divideDecimalRound(collateralizationRatio);\n    }\n\n    function loanAmountFromCollateral(uint256 collateralAmount) public view returns (uint256) {\n        return collateralAmount.multiplyDecimal(issuanceRatio());\n    }\n\n    function collateralAmountForLoan(uint256 loanAmount) external view returns (uint256) {\n        return loanAmount.multiplyDecimal(collateralizationRatio.divideDecimalRound(ONE_HUNDRED));\n    }\n\n    function currentInterestOnLoan(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        uint256 loanLifeSpan = _loanLifeSpan(synthLoan);\n        return accruedInterestOnLoan(synthLoan.loanAmount, loanLifeSpan);\n    }\n\n    function accruedInterestOnLoan(uint256 _loanAmount, uint256 _seconds) public view returns (uint256 interestAmount) {\n        // Simple interest calculated per second\n        // Interest = Principal * rate * time\n        interestAmount = _loanAmount.multiplyDecimalRound(interestPerSecond.mul(_seconds));\n    }\n\n    function calculateMintingFee(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        return _calculateMintingFee(synthLoan);\n    }\n\n    function openLoanIDsByAccount(address _account) external view returns (uint256[] memory) {\n        SynthLoanStruct[] memory synthLoans = accountsSynthLoans[_account];\n\n        uint256[] memory _openLoanIDs = new uint256[](synthLoans.length);\n        uint256 _counter = 0;\n\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].timeClosed == 0) {\n                _openLoanIDs[_counter] = synthLoans[i].loanID;\n                _counter++;\n            }\n        }\n        // Create the fixed size array to return\n        uint256[] memory _result = new uint256[](_counter);\n\n        // Copy loanIDs from dynamic array to fixed array\n        for (uint256 j = 0; j < _counter; j++) {\n            _result[j] = _openLoanIDs[j];\n        }\n        // Return an array with list of open Loan IDs\n        return _result;\n    }\n\n    function getLoan(address _account, uint256 _loanID)\n        external\n        view\n        returns (\n            address account,\n            uint256 collateralAmount,\n            uint256 loanAmount,\n            uint256 timeCreated,\n            uint256 loanID,\n            uint256 timeClosed,\n            uint256 interest,\n            uint256 totalFees\n        )\n    {\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        account = synthLoan.account;\n        collateralAmount = synthLoan.collateralAmount;\n        loanAmount = synthLoan.loanAmount;\n        timeCreated = synthLoan.timeCreated;\n        loanID = synthLoan.loanID;\n        timeClosed = synthLoan.timeClosed;\n        interest = accruedInterestOnLoan(synthLoan.loanAmount, _loanLifeSpan(synthLoan));\n        totalFees = interest.add(_calculateMintingFee(synthLoan));\n    }\n\n    function loanLifeSpan(address _account, uint256 _loanID) external view returns (uint256 loanLifeSpanResult) {\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        loanLifeSpanResult = _loanLifeSpan(synthLoan);\n    }\n\n    // ========== PUBLIC FUNCTIONS ==========\n\n    function openLoan() external payable notPaused nonReentrant sETHRateNotStale returns (uint256 loanID) {\n        systemStatus().requireIssuanceActive();\n\n        // Require ETH sent to be greater than minLoanSize\n        require(msg.value >= minLoanSize, \"Not enough ETH to create this loan. Please see the minLoanSize\");\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Each account is limted to creating 50 (accountLoanLimit) loans\n        require(accountsSynthLoans[msg.sender].length < accountLoanLimit, \"Each account is limted to 50 loans\");\n\n        // Calculate issuance amount\n        uint256 loanAmount = loanAmountFromCollateral(msg.value);\n\n        // Require sETH to mint does not exceed cap\n        require(totalIssuedSynths.add(loanAmount) < issueLimit, \"Loan Amount exceeds the supply cap.\");\n\n        // Get a Loan ID\n        loanID = _incrementTotalLoansCounter();\n\n        // Create Loan storage object\n        SynthLoanStruct memory synthLoan = SynthLoanStruct({\n            account: msg.sender,\n            collateralAmount: msg.value,\n            loanAmount: loanAmount,\n            timeCreated: now,\n            loanID: loanID,\n            timeClosed: 0\n        });\n\n        // Record loan in mapping to account in an array of the accounts open loans\n        accountsSynthLoans[msg.sender].push(synthLoan);\n\n        // Increment totalIssuedSynths\n        totalIssuedSynths = totalIssuedSynths.add(loanAmount);\n\n        // Issue the synth\n        synthsETH().issue(msg.sender, loanAmount);\n\n        // Tell the Dapps a loan was created\n        emit LoanCreated(msg.sender, loanID, loanAmount);\n    }\n\n    function closeLoan(uint256 loanID) external nonReentrant sETHRateNotStale {\n        _closeLoan(msg.sender, loanID);\n    }\n\n    // Liquidation of an open loan available for anyone\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external nonReentrant sETHRateNotStale {\n        require(loanLiquidationOpen, \"Liquidation is not open\");\n        // Close the creators loan and send collateral to the closer.\n        _closeLoan(_loanCreatorsAddress, _loanID);\n        // Tell the Dapps this loan was liquidated\n        emit LoanLiquidated(_loanCreatorsAddress, _loanID, msg.sender);\n    }\n\n    // ========== PRIVATE FUNCTIONS ==========\n\n    function _closeLoan(address account, uint256 loanID) private {\n        systemStatus().requireIssuanceActive();\n\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(account, loanID);\n\n        require(synthLoan.loanID > 0, \"Loan does not exist\");\n        require(synthLoan.timeClosed == 0, \"Loan already closed\");\n        require(\n            IERC20(address(synthsETH())).balanceOf(msg.sender) >= synthLoan.loanAmount,\n            \"You do not have the required Synth balance to close this loan.\"\n        );\n\n        // Record loan as closed\n        _recordLoanClosure(synthLoan);\n\n        // Decrement totalIssuedSynths\n        totalIssuedSynths = totalIssuedSynths.sub(synthLoan.loanAmount);\n\n        // Calculate and deduct interest(5%) and minting fee(50 bips) in ETH\n        uint256 interestAmount = accruedInterestOnLoan(synthLoan.loanAmount, _loanLifeSpan(synthLoan));\n        uint256 mintingFee = _calculateMintingFee(synthLoan);\n        uint256 totalFeeETH = interestAmount.add(mintingFee);\n\n        // Burn all Synths issued for the loan\n        synthsETH().burn(msg.sender, synthLoan.loanAmount);\n\n        // Fee Distribution. Purchase sUSD with ETH from Depot\n        require(\n            IERC20(address(synthsUSD())).balanceOf(address(depot())) >= depot().synthsReceivedForEther(totalFeeETH),\n            \"The sUSD Depot does not have enough sUSD to buy for fees\"\n        );\n        depot().exchangeEtherForSynths.value(totalFeeETH)();\n\n        // Transfer the sUSD to distribute to SNX holders.\n        IERC20(address(synthsUSD())).transfer(FEE_ADDRESS, IERC20(address(synthsUSD())).balanceOf(address(this)));\n\n        // Send remainder ETH to caller\n        address(msg.sender).transfer(synthLoan.collateralAmount.sub(totalFeeETH));\n\n        // Tell the Dapps\n        emit LoanClosed(account, loanID, totalFeeETH);\n    }\n\n    function _getLoanFromStorage(address account, uint256 loanID) private view returns (SynthLoanStruct memory) {\n        SynthLoanStruct[] memory synthLoans = accountsSynthLoans[account];\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].loanID == loanID) {\n                return synthLoans[i];\n            }\n        }\n    }\n\n    function _recordLoanClosure(SynthLoanStruct memory synthLoan) private {\n        // Get storage pointer to the accounts array of loans\n        SynthLoanStruct[] storage synthLoans = accountsSynthLoans[synthLoan.account];\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].loanID == synthLoan.loanID) {\n                // Record the time the loan was closed\n                synthLoans[i].timeClosed = now;\n            }\n        }\n\n        // Reduce Total Open Loans Count\n        totalOpenLoanCount = totalOpenLoanCount.sub(1);\n    }\n\n    function _incrementTotalLoansCounter() private returns (uint256) {\n        // Increase the total Open loan count\n        totalOpenLoanCount = totalOpenLoanCount.add(1);\n        // Increase the total Loans Created count\n        totalLoansCreated = totalLoansCreated.add(1);\n        // Return total count to be used as a unique ID.\n        return totalLoansCreated;\n    }\n\n    function _calculateMintingFee(SynthLoanStruct memory synthLoan) private view returns (uint256 mintingFee) {\n        mintingFee = synthLoan.loanAmount.multiplyDecimalRound(issueFeeRate);\n    }\n\n    function _loanLifeSpan(SynthLoanStruct memory synthLoan) private view returns (uint256 loanLifeSpanResult) {\n        // Get time loan is open for, and if closed from the timeClosed\n        bool loanClosed = synthLoan.timeClosed > 0;\n        // Calculate loan life span in seconds as (Now - Loan creation time)\n        loanLifeSpanResult = loanClosed ? synthLoan.timeClosed.sub(synthLoan.timeCreated) : now.sub(synthLoan.timeCreated);\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS, \"Missing SystemStatus address\"));\n    }\n\n    function synthsETH() internal view returns (ISynth) {\n        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSETH, \"Missing SynthsETH address\"));\n    }\n\n    function synthsUSD() internal view returns (ISynth) {\n        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD, \"Missing SynthsUSD address\"));\n    }\n\n    function depot() internal view returns (IDepot) {\n        return IDepot(requireAndGetAddress(CONTRACT_DEPOT, \"Missing Depot address\"));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES, \"Missing ExchangeRates address\"));\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier sETHRateNotStale() {\n        require(!exchangeRates().rateIsStale(\"sETH\"), \"Blocked as sETH rate is stale\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n\n    event CollateralizationRatioUpdated(uint256 ratio);\n    event InterestRateUpdated(uint256 interestRate);\n    event IssueFeeRateUpdated(uint256 issueFeeRate);\n    event IssueLimitUpdated(uint256 issueLimit);\n    event MinLoanSizeUpdated(uint256 minLoanSize);\n    event AccountLoanLimitUpdated(uint256 loanLimit);\n    event LoanLiquidationOpenUpdated(bool loanLiquidationOpen);\n    event LoanCreated(address indexed account, uint256 loanID, uint256 amount);\n    event LoanClosed(address indexed account, uint256 loanID, uint256 feesPaid);\n    event LoanLiquidated(address indexed account, uint256 loanID, address liquidator);\n}\n\n\n    ","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanLimit\",\"type\":\"uint256\"}],\"name\":\"AccountLoanLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"CollateralizationRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"}],\"name\":\"InterestRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"IssueFeeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueLimit\",\"type\":\"uint256\"}],\"name\":\"IssueLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesPaid\",\"type\":\"uint256\"}],\"name\":\"LoanClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LoanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"LoanLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"LoanLiquidationOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLoanSize\",\"type\":\"uint256\"}],\"name\":\"MinLoanSizeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ADDRESSES_FROM_RESOLVER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountLoanLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountOpenLoanCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsSynthLoans\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"accruedInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"calculateMintingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"closeLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"}],\"name\":\"collateralAmountForLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"currentInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralizationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issuanceRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minLoanSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalIssuedSynths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLoansCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalOpenLoanCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getLoan\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[24]\",\"name\":\"addressesRequired\",\"type\":\"bytes32[24]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"liquidateUnclosedLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"loanAmountFromCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"loanLifeSpan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanLifeSpanResult\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanLiquidationOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minLoanSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"openLoanIDsByAccount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanLimit\",\"type\":\"uint256\"}],\"name\":\"setAccountLoanLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"setCollateralizationRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"setIssueFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"}],\"name\":\"setIssueLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"setLoanLiquidationOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minLoanSize\",\"type\":\"uint256\"}],\"name\":\"setMinLoanSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setResolverAndSyncCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuedSynths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLoansCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOpenLoanCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EtherCollateral","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000de910777c787903f78c89e7a0bf7f4c435cbb1fe00000000000000000000000061166014e3f04e40c953fe4eab9d9e40863c83ae","EVMVersion":"Default","Library":"SafeDecimalMath:84d626b2bb4d0f064067e4bf80fce7055d8f3e7b","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}