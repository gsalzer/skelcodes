{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/PriceOracleInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Interface of the price oracle.\r\n */\r\ninterface PriceOracleInterface {\r\n    /**\r\n     * @dev Returns `true`if oracle is working.\r\n     */\r\n    function isWorking() external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the latest id. The id start from 1 and increments by 1.\r\n     */\r\n    function latestId() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the last updated price. Decimals is 8.\r\n     **/\r\n    function latestPrice() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of the last updated price.\r\n     */\r\n    function latestTimestamp() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the historical price specified by `id`. Decimals is 8.\r\n     */\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of historical price specified by `id`.\r\n     */\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/AggregatorInterfaceV2.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n// https://etherscan.io/address/0xfd38a152dddf1f9cf5ec9b23599c6d5f080d6aff#code\r\ninterface AggregatorInterfaceV2 {\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    function latestTimestamp() external view returns (uint256);\r\n\r\n    function latestRound() external view returns (uint256);\r\n\r\n    function getAnswer(uint256 roundId) external view returns (int256);\r\n\r\n    function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // getRoundData and latestRoundData should both raise \"No data present\"\r\n    // if they do not have data to report, instead of returning unset values\r\n    // which could be misinterpreted as actual reported values.\r\n    function getRoundData(uint80 _roundId)\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\n// File: contracts/ChainlinkPriceOracleV2.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice PriceOracle wrapping AggregatorInterface by Chainlink.\r\n */\r\ncontract ChainlinkPriceOracleV2 is PriceOracleInterface {\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    uint256 private constant SECONDS_IN_DAY = 60 * 60 * 24;\r\n    uint8 private constant DECIMALS = 8;\r\n    int256 private constant FLUCTUATION_THRESHOLD = 8; // 800%\r\n\r\n    AggregatorInterfaceV2 public immutable aggregator;\r\n    bool public healthFlag = true;\r\n\r\n    event HealthCheck(bool indexed success);\r\n\r\n    constructor(AggregatorInterfaceV2 aggregatorAddress) public {\r\n        aggregator = aggregatorAddress;\r\n    }\r\n\r\n    //\r\n    // Implementation of PriceOracleInterface\r\n    //\r\n    /**\r\n     * @notice Returns `true` if the price is updated correctly within last 24 hours.\r\n     * @dev Returns `false` if any exception was thrown in function calls to aggregator.\r\n     */\r\n    function isWorking() external override returns (bool) {\r\n        return\r\n            healthFlag &&\r\n            _isNotDestructed() &&\r\n            _isLatestAnswerProper() &&\r\n            _isDecimalNotChanged();\r\n    }\r\n\r\n    /**\r\n     * @dev See {PriceOracleInterface-latestId}.\r\n     */\r\n    function latestId() external override returns (uint256) {\r\n        return aggregator.latestRound();\r\n    }\r\n\r\n    /**\r\n     * @dev See {PriceOracleInterface-latestPrice}.\r\n     */\r\n    function latestPrice() external override returns (uint256) {\r\n        int256 price = aggregator.latestAnswer();\r\n        return uint256(price);\r\n    }\r\n\r\n    /**\r\n     * @dev See {PriceOracleInterface-latestTimestamp}.\r\n     */\r\n    function latestTimestamp() external override returns (uint256) {\r\n        return aggregator.latestTimestamp();\r\n    }\r\n\r\n    /**\r\n     * @dev See {PriceOracleInterface-getPrice}.\r\n     */\r\n    function getPrice(uint256 id) public override returns (uint256) {\r\n        int256 price = aggregator.getAnswer(id);\r\n        if (price == 0) {\r\n            return getPrice(id.sub(1));\r\n        }\r\n        return uint256(price);\r\n    }\r\n\r\n    /**\r\n     * @dev See {PriceOracleInterface-getTimestamp}.\r\n     */\r\n    function getTimestamp(uint256 id) public override returns (uint256) {\r\n        uint256 timestamp = aggregator.getTimestamp(id);\r\n        if (timestamp == 0) {\r\n            return getTimestamp(id.sub(1));\r\n        }\r\n        return timestamp;\r\n    }\r\n\r\n    function healthCheck() external returns (bool r) {\r\n        r = isHealth();\r\n        if (!r) {\r\n            healthFlag = false;\r\n        }\r\n        emit HealthCheck(r);\r\n        return r;\r\n    }\r\n\r\n    function isHealth() public view returns (bool r) {\r\n        try aggregator.latestRound() returns (uint256 latestRound) {\r\n            if (latestRound < 25) {\r\n                return r;\r\n            }\r\n            for (uint256 id = latestRound - 23; id <= latestRound; id++) {\r\n                if (!areAnswersProperAt(uint80(id))) {\r\n                    return r;\r\n                }\r\n            }\r\n            if (!areAnswersProperThoroughly(uint80(latestRound))) {\r\n                return r;\r\n            }\r\n            r = true;\r\n        } catch {}\r\n    }\r\n\r\n    function areAnswersProperThoroughly(uint80 startId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        (, int256 checkAnswer, , uint256 checkTimestamp, ) = aggregator\r\n            .getRoundData(uint80(startId - 24));\r\n        int256 answer;\r\n        uint256 timestamp;\r\n        bool areAnswersSame = true;\r\n        bool areTimestampsSame = true;\r\n        for (uint256 id = startId - 23; id < startId; id++) {\r\n            (, answer, , timestamp, ) = aggregator.getRoundData(uint80(id));\r\n            if (areAnswersSame && answer != checkAnswer) {\r\n                areAnswersSame = false;\r\n            }\r\n            if (areTimestampsSame && timestamp != checkTimestamp) {\r\n                areTimestampsSame = false;\r\n            }\r\n        }\r\n        return !(areAnswersSame || areTimestampsSame);\r\n    }\r\n\r\n    function areAnswersProperAt(uint80 id) public view returns (bool r) {\r\n        uint80 prev = id - 1;\r\n        try aggregator.getRoundData(uint80(id)) returns (\r\n            uint80,\r\n            int256 firstAnswer,\r\n            uint256,\r\n            uint256 firstTimestamp,\r\n            uint80\r\n        ) {\r\n            try aggregator.getRoundData(prev) returns (\r\n                uint80,\r\n                int256 secondAnswer,\r\n                uint256,\r\n                uint256 secondTimestamp,\r\n                uint80\r\n            ) {\r\n                return (_isProperAnswers(firstAnswer, secondAnswer) &&\r\n                    _isProperTimestamps(firstTimestamp, secondTimestamp));\r\n            } catch {}\r\n        } catch {}\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the aggregator is not self destructed.\r\n     * After a contract is destructed, size of the code at the address becomes 0.\r\n     */\r\n    function _isNotDestructed() private view returns (bool) {\r\n        address aggregatorAddr = address(aggregator);\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(aggregatorAddr)\r\n        }\r\n        return size != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the aggregator's latest price value is proper.\r\n     * Returns `false` when catch exception.\r\n     */\r\n    function _isLatestAnswerProper() private view returns (bool r) {\r\n        try aggregator.latestRoundData() returns (\r\n            uint80 latestRound,\r\n            int256 latestAnswer,\r\n            uint256,\r\n            uint256 updatedAt,\r\n            uint80\r\n        ) {\r\n            // check if `latestRound` is not 0 to avoid under flow on L 111.\r\n            if (latestRound == 0) {\r\n                return r;\r\n            }\r\n            try aggregator.getAnswer(latestRound - 1) returns (\r\n                int256 previousAnswer\r\n            ) {\r\n                return (_isProperAnswers(latestAnswer, previousAnswer) &&\r\n                    _isProperTimestamps(now, updatedAt));\r\n            } catch {}\r\n        } catch {}\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the aggregator returns 8 for the decimals.\r\n     * Returns `false` when catch exception.\r\n     * When the aggregator decimals() returns a different value,\r\n     * stop providing data and turn into Recovery phase.\r\n     */\r\n    function _isDecimalNotChanged() private view returns (bool) {\r\n        try aggregator.decimals() returns (uint8 d) {\r\n            return d == DECIMALS;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns `true` if the contiguous prices are proper.\r\n     * 1. More than 0.\r\n     * 2. Not too larger than the previous value.\r\n     * 3. Not too smaller than the previous value.\r\n     */\r\n    function _isProperAnswers(int256 firstAnswer, int256 secondAnswer)\r\n        private\r\n        pure\r\n        returns (bool r)\r\n    {\r\n        // 1. More than 0.\r\n        // check if the first price is more than 0.\r\n        if (firstAnswer <= 0) {\r\n            return r;\r\n        }\r\n        // 2. Not too larger than the previous value.\r\n        // check if the first price is not too larger than the second price.\r\n        if (firstAnswer > secondAnswer.mul(FLUCTUATION_THRESHOLD)) {\r\n            return r;\r\n        }\r\n        // 3. Not too smaller than the previous value.\r\n        // check if the first price is not too smaller than the second price.\r\n        if (firstAnswer.mul(FLUCTUATION_THRESHOLD) < secondAnswer) {\r\n            return r;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns `true` if the contiguous timestamp are proper.\r\n     */\r\n    function _isProperTimestamps(\r\n        uint256 firstTimestamp,\r\n        uint256 secondTimestamp\r\n    ) private pure returns (bool) {\r\n        //check if diff of timestamps is within 24 hours.\r\n        return firstTimestamp.sub(secondTimestamp) <= SECONDS_IN_DAY;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract AggregatorInterfaceV2\",\"name\":\"aggregatorAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"HealthCheck\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aggregator\",\"outputs\":[{\"internalType\":\"contract AggregatorInterfaceV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"id\",\"type\":\"uint80\"}],\"name\":\"areAnswersProperAt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"startId\",\"type\":\"uint80\"}],\"name\":\"areAnswersProperThoroughly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"healthCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"healthFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isHealth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWorking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChainlinkPriceOracleV2","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ed455007b3d8a6c9024931768431d8ad895f09a15e61241d62d235c790a60b59"}]}