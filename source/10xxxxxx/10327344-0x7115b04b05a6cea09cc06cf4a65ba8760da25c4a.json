{"status":"1","message":"OK","result":[{"SourceCode":"{\"MkpERC20.sol\":{\"content\":\"pragma solidity ^0.5.1;\\n\\nimport \\\"./Owned.sol\\\";\\n\\ncontract MkpERC20 is Owned {\\n    // Public variables of the token\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it\\n    uint256 public totalSupply;\\n\\n    mapping (address =\\u003e uint256) public balanceOf;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowance;\\n\\n    // Below are public events on the blockchain that will notify clients\\n\\t\\n\\t// This notifies clients about the tokens amount transfer between accounts \\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    \\n    // This notifies clients about the tokens amount approved to _spender to use on account _owner\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n    // This notifies clients about the tokens amount burnt\\n    event Burn(address indexed _from, uint256 _value);\\n\\t\\n\\t// This notifies clients about the tokens amount minted\\n    event Mint(address indexed _to, uint256 _value);\\n\\t\\n\\t// This notifies clients about contract account receives ether\\n    event EtherReceived(address _from, uint256 _value);\\n\\n    /**\\n     * Constructor function\\n     *\\n     * Initializes contract with initial supply tokens to the creator of the contract\\n\\t *\\n\\t * @param _initialSupply Total initial amount of tokens\\n     * @param _name full name of the token\\n\\t * @param _symbol short name of the token\\n     */\\n    constructor (\\n        uint256 _initialSupply,\\n        string memory _name,\\n        string memory _symbol\\n    ) public {\\n\\t\\trequire(_initialSupply\\u003e0);\\n        totalSupply = _initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\\n        balanceOf[address(this)] = totalSupply;                \\t\\t// Give the contract account all initial tokens\\n        name = _name;  \\n        symbol = _symbol;\\n    }\\n\\n    /**\\n     * Internal transfer, only can be called by this contract\\n     */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n\\t\\trequire(_from != address(0), \\\"transfer attempt from zero address\\\"); // Prevent transfer from 0x0 address.\\n        require(_to != address(0), \\\"transfer attempt to zero address\\\"); // Prevent transfer to 0x0 address.\\n        require(balanceOf[_from] \\u003e= _value, \\\"from address balance is not enough\\\");\\n        require(balanceOf[_to] + _value \\u003e= balanceOf[_to], \\\"destination address balance overflow\\\"); // Check for overflows\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n     * Transfer tokens\\n     *\\n     * Send `_value` tokens to `_to` from your account\\n     *\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token minimal units (10**(-18)) to send\\n     */\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Transfer tokens from other address\\n     *\\n     * Send `_value` tokens to `_to` on behalf of `_from`\\n     *\\n     * @param _from The address of the sender\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token minimal units (10**(-18)) to send\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n        require(_value \\u003c= allowance[_from][msg.sender], \\\"transfer not allowed\\\");     // Check allowance\\n        allowance[_from][msg.sender] -= _value;\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Set allowance for other address\\n     *\\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\\n     *\\n     * @param _spender The address authorized to spend\\n     * @param _value The max amount of token minimal units (10**(-18)) it can spend\\n     */\\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n\\t\\trequire(_spender != address(0));\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Destroy tokens from other account\\n     *\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\n     *\\n     * @param _from the address of the sender\\n     * @param _value the amount of token minimal units (10**(-18)) to burn\\n     */\\n    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool) {\\n        require(balanceOf[_from] \\u003e= _value, \\\"address balance is smaller, than amount to burn\\\");\\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\\n        totalSupply -= _value;                              // Update totalSupply\\n        emit Burn(_from, _value);\\n\\t\\tassert(totalSupply \\u003e= 0);\\n        return true;\\n    }\\n\\t\\n   /**\\n     * Destroy tokens\\n     *\\n     * Remove `_value` tokens from the system irreversibly\\n     *\\n     * @param _value the amount of token minimal units (10**(-18)) to burn\\n     */\\n    function burn(uint256 _value) public onlyOwner returns (bool) {\\n        return burnFrom(msg.sender, _value);\\n    }\\n\\t\\n    /**\\n     * Create nwew tokens to account\\n     *\\n     * Internal function, can be called from the contract and it\\u0027s children contracts only\\n     */\\n\\tfunction _mintToken(address _target, uint256 _mintAmount) internal {\\n\\t\\trequire(_target != address(0), \\\"mint attempt to zero address\\\"); // Prevent mint to 0x0 address.\\n\\t\\trequire(totalSupply + _mintAmount \\u003e totalSupply);\\n        balanceOf[_target] += _mintAmount;\\n        totalSupply += _mintAmount;\\n        emit Mint(_target, _mintAmount);\\n    }\\n\\t\\n\\t/**\\n     * Create tokens to account\\n     *\\n     * Create `_mintAmount` tokens  and set them to _target account.\\n     *\\n     * @param _target the address for new tokens\\n     * @param _mintAmount the amount of token minimal units (10**(-18)) to create\\n     */\\n\\tfunction mintToken(address _target, uint256 _mintAmount) public onlyOwner returns (bool) {\\n\\t\\t_mintToken(_target, _mintAmount);\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n     * Destroy contract\\n     *\\n\\t * @param _beneficiary Address to send all contract\\u0027s Ether balance\\n     */\\n\\tfunction destroy(address payable _beneficiary) public onlyOwner {\\n\\t\\trequire(_beneficiary != address(0), \\\"beneficiary is zero address\\\");\\n\\t\\tselfdestruct(_beneficiary);\\n\\t}\\n\\t\\n\\tfunction() external payable {\\n\\t\\temit EtherReceived(msg.sender, msg.value);\\n\\t}\\n}\"},\"MkpFull.sol\":{\"content\":\"pragma solidity ^0.5.1;\\r\\n\\r\\nimport \\\"./MkpERC20.sol\\\";\\r\\n\\r\\ncontract MkpFull is MkpERC20 {\\r\\n\\tuint256 public minEthers = 10 finney;\\r\\n\\t\\r\\n\\tconstructor(\\r\\n\\t\\tuint256 _initialSupply,\\r\\n        string memory _name,\\r\\n        string memory _symbol\\r\\n\\t\\t) public MkpERC20(_initialSupply, _name, _symbol) {}\\r\\n\\t\\r\\n\\t/**\\r\\n     * Set contract minimal wei balance to enable withdraw ethers\\r\\n     *\\r\\n\\t * @param weis Minimal contract balance in weis\\r\\n     */\\r\\n    function setMinEthers(uint256 weis) public onlyOwner {\\r\\n        minEthers = weis;\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * transfers all ethers from contract address to the owner address\\r\\n     *\\r\\n     */\\r\\n\\tfunction withdrawEther() public onlyOwner returns (bool success) {\\r\\n\\t\\tif (address(this).balance \\u003c minEthers) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t\\t//send ether from contract account\\r\\n\\t\\towner.transfer(address(this).balance);\\r\\n\\t\\treturn true;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * Send tokens from contract balance to client account\\r\\n     *\\r\\n     * Internal function, can be called from the contract and it\\u0027s children contracts only\\r\\n     */\\r\\n    function fundClient(address _client, uint256 _amount) internal {\\r\\n\\t\\tif(balanceOf[address(this)] \\u003e= _amount) {\\r\\n\\t\\t\\t_transfer(address(this), _client, _amount);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t_mintToken(_client, _amount);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * Send tokens from contract balance to client account\\r\\n     *\\r\\n     * @param _client account to send tokens\\r\\n\\t * @param _amount number of token minimal units (10**(-18)) to send\\r\\n     */\\r\\n    function buyDeal(address _client, uint256 _amount) public onlyOwner returns (bool success) {\\r\\n\\t\\tfundClient(_client, _amount);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * Send tokens to contract account\\r\\n     *\\r\\n\\t * @param _amount number of token minimal units (10**(-18)) to send\\r\\n     */\\r\\n    function sellDeal(uint256 _amount) public returns (bool success) {\\r\\n\\t\\t_transfer(msg.sender, address(this), _amount);\\r\\n        return true;\\r\\n\\t}\\r\\n}\"},\"Owned.sol\":{\"content\":\"pragma solidity ^0.5.1;\\r\\n\\r\\ncontract Owned {\\r\\n\\taddress payable internal owner;\\r\\n\\r\\n\\tconstructor() internal {\\r\\n\\t\\towner = msg.sender;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyOwner {\\r\\n\\t\\trequire(msg.sender == owner);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tfunction transferOwnership(address payable newOwner) public onlyOwner {\\r\\n\\t\\towner = newOwner;\\r\\n\\t}\\r\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellDeal\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minEthers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyDeal\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weis\",\"type\":\"uint256\"}],\"name\":\"setMinEthers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"}]","ContractName":"MkpFull","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000011466c616d6520455243323020746f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005466c616d65000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://81dd6470a68e4d91994effcafbb8bcea3c331305acee3f0f7cdb3d5f2c144930"}]}