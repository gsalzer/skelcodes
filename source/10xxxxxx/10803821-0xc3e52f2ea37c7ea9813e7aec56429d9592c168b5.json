{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20 {\r\n    function transfer(address _to, uint256 _value) public;\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\r\n}\r\n\r\ncontract SGCDEXEthTokenSwap {\r\n\r\n  using SafeMath for uint;\r\n\r\n  address public owner;\r\n  address payable exchangeFeeAddress;\r\n  uint256 exchangeFee;\r\n  uint256 SafeTime = 2 hours; \r\n\r\n  struct Swap {\r\n    address token;\r\n    bytes32 secret;\r\n    bytes20 secretHash;\r\n    uint256 createdAt;\r\n    uint256 balance;\r\n  }\r\n\r\n  mapping(address => mapping(address => Swap)) public swaps;\r\n\r\n  constructor () public {\r\n    owner = msg.sender;\r\n    exchangeFee = 1000;\r\n    exchangeFeeAddress = 0x7BC4E25bdB535294F59646ff6c31f356888d5053;\r\n  }\r\n\r\n  function updateExchangeFeeAddress (address payable newAddress) public returns (bool status) {\r\n    require(owner == msg.sender);\r\n    exchangeFeeAddress = newAddress;\r\n    return true;\r\n  }\r\n\r\n  function updateExchangeFee (uint256 newExchangeFee) public returns (bool status) {\r\n    require(owner == msg.sender);\r\n    exchangeFee = newExchangeFee;\r\n    return true;\r\n  }\r\n\r\n  event CreateSwap(uint256 createdAt);\r\n\r\n  function createSwap(bytes20 _secretHash, address _participantAddress, uint256 _value, address _token) public {\r\n    require(_value > 0);\r\n    require(swaps[msg.sender][_participantAddress].balance == uint256(0));\r\n    require(ERC20(_token).transferFrom(msg.sender, address(this), _value));\r\n\r\n    swaps[msg.sender][_participantAddress] = Swap(\r\n      _token,\r\n      bytes32(0),\r\n      _secretHash,\r\n      now,\r\n      _value\r\n    );\r\n\r\n    emit CreateSwap(now);\r\n  }\r\n\r\n  function getBalance(address _ownerAddress) public view returns (uint256) {\r\n    return swaps[_ownerAddress][msg.sender].balance;\r\n  }\r\n\r\n  event Withdraw();\r\n\r\n  function withdraw(bytes32 _secret, address _ownerAddress) public {\r\n    Swap memory swap = swaps[_ownerAddress][msg.sender];\r\n\r\n    require(swap.secretHash == ripemd160(abi.encodePacked(_secret)));\r\n    require(swap.balance > uint256(0));\r\n    require(swap.createdAt.add(SafeTime) > now);\r\n\r\n    require(swap.secretHash == ripemd160(abi.encodePacked(_secret)));\r\n    require(swap.balance > uint256(0));\r\n    require(swap.createdAt.add(SafeTime) > now);\r\n\r\n    uint256 actualValue = swap.balance;\r\n\r\n    uint256 tradeFee = actualValue.div(exchangeFee);\r\n    uint256 balanceAfterDeduction = actualValue.sub(tradeFee);\r\n\r\n    ERC20(swap.token).transfer(msg.sender, balanceAfterDeduction);\r\n    ERC20(swap.token).transfer(exchangeFeeAddress, tradeFee);\r\n    \r\n    swaps[_ownerAddress][msg.sender].balance = 0;\r\n    swaps[_ownerAddress][msg.sender].secret = _secret;\r\n\r\n    emit Withdraw();\r\n  }\r\n\r\n  function getSecret(address _participantAddress) public view returns (bytes32) {\r\n    return swaps[msg.sender][_participantAddress].secret;\r\n  }\r\n\r\n  event Refund();\r\n\r\n  function refund(address _participantAddress) public {\r\n    Swap memory swap = swaps[msg.sender][_participantAddress];\r\n\r\n    require(swap.balance > uint256(0));\r\n    require(swap.createdAt.add(SafeTime) < now);\r\n\r\n    ERC20(swap.token).transfer(msg.sender, swap.balance);\r\n    clean(msg.sender, _participantAddress);\r\n\r\n    emit Refund();\r\n  }\r\n\r\n  function clean(address _ownerAddress, address _participantAddress) internal {\r\n    delete swaps[_ownerAddress][_participantAddress];\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"name\":\"CreateSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes20\",\"name\":\"_secretHash\",\"type\":\"bytes20\"},{\"internalType\":\"address\",\"name\":\"_participantAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"createSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_participantAddress\",\"type\":\"address\"}],\"name\":\"getSecret\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_participantAddress\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"bytes20\",\"name\":\"secretHash\",\"type\":\"bytes20\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newExchangeFee\",\"type\":\"uint256\"}],\"name\":\"updateExchangeFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateExchangeFeeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SGCDEXEthTokenSwap","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f0027864b6f5fed6f554ce81c70238770121f15882539129c83f68d2352418a6"}]}