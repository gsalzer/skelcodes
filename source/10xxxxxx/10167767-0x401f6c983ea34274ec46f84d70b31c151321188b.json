{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == address(governance),\r\n            \"Only governance contract is authorized\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: solidity-rlp/contracts/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem item;   // Item that's being iterated over.\r\n        uint nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\r\n    * @param self The iterator.\r\n    * @return The next element in the iteration.\r\n    */\r\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\r\n        require(hasNext(self));\r\n\r\n        uint ptr = self.nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        self.nextPtr = ptr + itemLength;\r\n\r\n        return RLPItem(itemLength, ptr);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the iteration has more elements.\r\n    * @param self The iterator.\r\n    * @return true if the iteration has more elements.\r\n    */\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self.item;\r\n        return self.nextPtr < item.memPtr + item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @dev Create an iterator. Reverts if item is not a list.\r\n    * @param self The RLP item.\r\n    * @return An 'Iterator' over the item.\r\n    */\r\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\r\n        require(isList(self));\r\n\r\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\r\n        return Iterator(self, ptr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len - _payloadOffset(item.memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    // any non-zero byte is considered true\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    * Private Helpers\r\n    */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) private pure returns (uint) {\r\n        uint itemLen;\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            itemLen = 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            itemLen = byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            itemLen = byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ProxyStorage is Ownable {\r\n    address internal proxyTo;\r\n}\r\n\r\n// File: contracts/common/mixin/ChainIdMixin.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract ChainIdMixin {\r\n  bytes constant public networkId = hex\"89\";\r\n  uint256 constant public CHAINID = 137;\r\n}\r\n\r\n// File: contracts/root/RootChainStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\ncontract RootChainHeader {\r\n    event NewHeaderBlock(\r\n        address indexed proposer,\r\n        uint256 indexed headerBlockId,\r\n        uint256 indexed reward,\r\n        uint256 start,\r\n        uint256 end,\r\n        bytes32 root\r\n    );\r\n    // housekeeping event\r\n    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);\r\n    struct HeaderBlock {\r\n        bytes32 root;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 createdAt;\r\n        address proposer;\r\n    }\r\n}\r\n\r\n\r\ncontract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {\r\n    bytes32 public heimdallId;\r\n    uint8 public constant VOTE_TYPE = 2;\r\n\r\n    uint16 internal constant MAX_DEPOSITS = 10000;\r\n    uint256 public _nextHeaderBlock = MAX_DEPOSITS;\r\n    uint256 internal _blockDepositId = 1;\r\n    mapping(uint256 => HeaderBlock) public headerBlocks;\r\n    Registry internal registry;\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(uint256 validatorId, uint256 amount) external;\r\n\r\n    function confirmAuctionBid(\r\n        uint256 validatorId,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function stake(\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function supportsHistory() external pure returns (bool);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        bytes memory sigs\r\n    ) public returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes memory slashingInfoList) public returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/root/IRootChain.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IRootChain {\r\n    function slash() external;\r\n\r\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)\r\n        external;\r\n\r\n    function getLastChildBlock() external view returns (uint256);\r\n\r\n    function currentHeaderBlock() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/root/RootChain.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract RootChain is RootChainStorage, IRootChain {\r\n    using SafeMath for uint256;\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    modifier onlyDepositManager() {\r\n        require(msg.sender == registry.getDepositManagerAddress(), \"UNAUTHORIZED_DEPOSIT_MANAGER_ONLY\");\r\n        _;\r\n    }\r\n\r\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {\r\n        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi\r\n            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));\r\n        require(CHAINID == _borChainID, \"Invalid bor chain id\");\r\n\r\n        require(_buildHeaderBlock(proposer, start, end, rootHash), \"INCORRECT_HEADER_DATA\");\r\n\r\n        // check if it is better to keep it in local storage instead\r\n        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());\r\n        uint256 _reward = stakeManager.checkSignatures(\r\n            end.sub(start).add(1),\r\n            /**  \r\n                prefix 01 to data \r\n                01 represents positive vote on data and 00 is negative vote\r\n                malicious validator can try to send 2/3 on negative vote so 01 is appended\r\n             */\r\n            keccak256(abi.encodePacked(bytes(hex\"01\"), data)),\r\n            accountHash,\r\n            proposer,\r\n            sigs\r\n        );\r\n\r\n        require(_reward != 0, \"Invalid checkpoint\");\r\n        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);\r\n        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);\r\n        _blockDepositId = 1;\r\n    }\r\n\r\n    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {\r\n        depositId = currentHeaderBlock().add(_blockDepositId);\r\n        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)\r\n        _blockDepositId = _blockDepositId.add(numDeposits);\r\n        require(\r\n            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed\r\n            _blockDepositId <= MAX_DEPOSITS,\r\n            \"TOO_MANY_DEPOSITS\"\r\n        );\r\n    }\r\n\r\n    function getLastChildBlock() external view returns (uint256) {\r\n        return headerBlocks[currentHeaderBlock()].end;\r\n    }\r\n\r\n    function slash() external {\r\n        //TODO: future implementation\r\n    }\r\n\r\n    function currentHeaderBlock() public view returns (uint256) {\r\n        return _nextHeaderBlock.sub(MAX_DEPOSITS);\r\n    }\r\n\r\n    function _buildHeaderBlock(\r\n        address proposer,\r\n        uint256 start,\r\n        uint256 end,\r\n        bytes32 rootHash\r\n    ) private returns (bool) {\r\n        uint256 nextChildBlock;\r\n        /*\r\n    The ID of the 1st header block is MAX_DEPOSITS.\r\n    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0\r\n    */\r\n        if (_nextHeaderBlock > MAX_DEPOSITS) {\r\n            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;\r\n        }\r\n        if (nextChildBlock != start) {\r\n            return false;\r\n        }\r\n\r\n        HeaderBlock memory headerBlock = HeaderBlock({\r\n            root: rootHash,\r\n            start: nextChildBlock,\r\n            end: end,\r\n            createdAt: now,\r\n            proposer: proposer\r\n        });\r\n\r\n        headerBlocks[_nextHeaderBlock] = headerBlock;\r\n        return true;\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function setNextHeaderBlock(uint256 _value) public onlyOwner {\r\n        require(_value % MAX_DEPOSITS == 0, \"Invalid value\");\r\n        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {\r\n            delete headerBlocks[i];\r\n        }\r\n        _nextHeaderBlock = _value;\r\n        _blockDepositId = 1;\r\n        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function setHeimdallId(string memory _heimdallId) public onlyOwner {\r\n        heimdallId = keccak256(abi.encodePacked(_heimdallId));\r\n    }\r\n}\r\n\r\n// File: contracts/root/stateSyncer/StateSender.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract StateSender is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public counter;\r\n    mapping(address => address) public registrations;\r\n\r\n    event NewRegistration(\r\n        address indexed user,\r\n        address indexed sender,\r\n        address indexed receiver\r\n    );\r\n    event RegistrationUpdated(\r\n        address indexed user,\r\n        address indexed sender,\r\n        address indexed receiver\r\n    );\r\n    event StateSynced(\r\n        uint256 indexed id,\r\n        address indexed contractAddress,\r\n        bytes data\r\n    );\r\n\r\n    modifier onlyRegistered(address receiver) {\r\n        require(registrations[receiver] == msg.sender, \"Invalid sender\");\r\n        _;\r\n    }\r\n\r\n    function syncState(address receiver, bytes calldata data)\r\n        external\r\n        onlyRegistered(receiver)\r\n    {\r\n        counter = counter.add(1);\r\n        emit StateSynced(counter, receiver, data);\r\n    }\r\n\r\n    // register new contract for state sync\r\n    function register(address sender, address receiver) public {\r\n        require(\r\n            isOwner() || registrations[receiver] == msg.sender,\r\n            \"StateSender.register: Not authorized to register\"\r\n        );\r\n        registrations[receiver] = sender;\r\n        if (registrations[receiver] == address(0)) {\r\n            emit NewRegistration(msg.sender, sender, receiver);\r\n        } else {\r\n            emit RegistrationUpdated(msg.sender, sender, receiver);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Lockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Lockable is Governable {\r\n    bool public locked;\r\n\r\n    modifier onlyWhenUnlocked() {\r\n        require(!locked, \"Is Locked\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function lock() external onlyGovernance {\r\n        locked = true;\r\n    }\r\n\r\n    function unlock() external onlyGovernance {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n// File: contracts/root/depositManager/DepositManagerStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DepositManagerHeader {\r\n    event NewDepositBlock(address indexed owner, address indexed token, uint256 amountOrNFTId, uint256 depositBlockId);\r\n    event MaxErc20DepositUpdate(uint256 indexed oldLimit, uint256 indexed newLimit);\r\n\r\n    struct DepositBlock {\r\n        bytes32 depositHash;\r\n        uint256 createdAt;\r\n    }\r\n}\r\n\r\n\r\ncontract DepositManagerStorage is ProxyStorage, Lockable, DepositManagerHeader {\r\n    Registry public registry;\r\n    RootChain public rootChain;\r\n    StateSender public stateSender;\r\n\r\n    mapping(uint256 => DepositBlock) public deposits;\r\n\r\n    address public childChain;\r\n    uint256 public maxErc20Deposit = 100 * (10**18);\r\n}\r\n\r\n// File: contracts/common/misc/ERCProxy.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.5.2;\r\n\r\n// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\r\n\r\ninterface ERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId);\r\n    function implementation() external view returns (address codeAddr);\r\n}\r\n\r\n// File: contracts/common/misc/DelegateProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract DelegateProxy is ERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId) {\r\n        // Upgradeable proxy\r\n        proxyTypeId = 2;\r\n    }\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let result := delegatecall(\r\n                sub(gas, 10000),\r\n                _dst,\r\n                add(_calldata, 0x20),\r\n                mload(_calldata),\r\n                0,\r\n                0\r\n            )\r\n            let size := returndatasize\r\n\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/Proxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Proxy is ProxyStorage, DelegateProxy {\r\n    event ProxyUpdated(address indexed _new, address indexed _old);\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    constructor(address _proxyTo) public {\r\n        updateImplementation(_proxyTo);\r\n    }\r\n\r\n    function() external payable {\r\n        // require(currentContract != 0, \"If app code has not been set yet, do not call\");\r\n        // Todo: filter out some calls or handle in the end fallback\r\n        delegatedFwd(proxyTo, msg.data);\r\n    }\r\n\r\n    function implementation() external view returns (address) {\r\n        return proxyTo;\r\n    }\r\n\r\n    function updateImplementation(address _newProxyTo) public onlyOwner {\r\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\r\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\r\n        emit ProxyUpdated(_newProxyTo, proxyTo);\r\n        proxyTo = _newProxyTo;\r\n    }\r\n\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_target)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/root/depositManager/DepositManagerProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DepositManagerProxy is Proxy, DepositManagerStorage {\r\n    constructor(\r\n        address _proxyTo,\r\n        address _registry,\r\n        address _rootChain,\r\n        address _governance\r\n    ) public Proxy(_proxyTo) Lockable(_governance) {\r\n        registry = Registry(_registry);\r\n        rootChain = RootChain(_rootChain);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newProxyTo\",\"type\":\"address\"}],\"name\":\"updateImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"childChain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proxyTypeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IGovernance\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootChain\",\"outputs\":[{\"internalType\":\"contract RootChain\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"depositHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stateSender\",\"outputs\":[{\"internalType\":\"contract StateSender\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxErc20Deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rootChain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOrNFTId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositBlockId\",\"type\":\"uint256\"}],\"name\":\"NewDepositBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldLimit\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"MaxErc20DepositUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DepositManagerProxy","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d505c3822c787d51d5c2b1ae9adb943b2304eb2300000000000000000000000033a02e6cc863d393d6bf231b697b82f6e499ca7100000000000000000000000086e4dc95c7fbdbf52e33d563bbdb00823894c2870000000000000000000000006e7a5820bad6ceba8ef5ea69c0c92ebbdac9ce48","EVMVersion":"constantinople","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4e22673a649d3492096222588aa27dfd0c56e19f89115cbb72492f5046e6d60b"}]}