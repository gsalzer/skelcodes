{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\ncontract BrandContest {\r\n\r\n    //The allowed Votes that can be transfered\r\n    mapping(uint256 => uint256) private _allowedVotingAmounts;\r\n\r\n    //Keeps track of the current ERC721 Token addresses allowed for this votation (ARTE/ETRA)\r\n    mapping(address => bool) private _allowedTokenAddresses;\r\n\r\n    //Takes notes of how many votes received for any token id, for both Tokens (ARTE/ETRA)\r\n    mapping(address => mapping(uint256 => uint256)) private _votes;\r\n\r\n    //Takes notes of how many ethers received for any token id, for both Tokens (ARTE/ETRA)\r\n    mapping(address => mapping(uint256 => uint256)) private _ethers;\r\n\r\n    //Takes notes of the rewards anyone sends to vote, creators can redeem those at the end of the survey\r\n    mapping(address => uint256) private _rewards;\r\n    mapping(address => bool) private _redeemed;\r\n\r\n    //Il blocco di fine della votazione\r\n    uint256 private _surveyEndBlock;\r\n\r\n    //Event raised only the first time this NFT receives a vote\r\n    event FirstVote(address indexed tokenAddress, uint256 indexed tokenId);\r\n\r\n    //Event raised when someone votes for a specific NFT\r\n    event Vote(address indexed voter, address indexed tokenAddress, uint256 indexed tokenId, address creator, uint256 votes, uint256 amount);\r\n\r\n    //To let this Smart Contract work, you need to pass the ERC721 token addresses supported by this survey (ARTE/ETRA).\r\n    constructor(address[] memory allowedTokenAddresses, uint256 surveyEndBlock) public {\r\n        for(uint256 i = 0; i < allowedTokenAddresses.length; i++) {\r\n            _allowedTokenAddresses[allowedTokenAddresses[i]] = true;\r\n        }\r\n        _surveyEndBlock = surveyEndBlock;\r\n        _allowedVotingAmounts[4000000000000000] = 1;\r\n        _allowedVotingAmounts[30000000000000000] = 5;\r\n        _allowedVotingAmounts[100000000000000000] = 10;\r\n        _allowedVotingAmounts[300000000000000000] = 20;\r\n    }\r\n\r\n    //The concrete vote operation:\r\n    //You vote sending some ether to this call, specifing the ERC721 location and id you want to vote.\r\n    //The amount of ethers received will be registered as a vote for the chosen NFT and transfered to its creator\r\n    //The vote is to be considered valid if and only if the creator's address is the one who sent the original NFT to the wallet with address: 0x74Ef70357ef21BaD2b45795679F2727C48d501ED\r\n    function vote(address tokenAddress, uint256 tokenId, address payable creator) public payable {\r\n\r\n        //Are you still able to vote?\r\n        require(block.number < _surveyEndBlock, \"Survey ended!\");\r\n\r\n        //To vote you must provide some ethers, with a maximum of 3 eth\r\n        require(_allowedVotingAmounts[msg.value] > 0, \"Vote must be 0.004, 0.03, 0.1 or 0.3 ethers\");\r\n\r\n        //You can just vote one of the allowed NFTs (ARTE/ETRA)\r\n        require(_allowedTokenAddresses[tokenAddress], \"Unallowed Token Address!\");\r\n\r\n        //Check if tokenId and its owner are valid\r\n        require(IERC721(tokenAddress).ownerOf(tokenId) != address(0), \"Owner is nobody, maybe wrong tokenId?\");\r\n\r\n        //If this is the first time this NFT receives a vote, the FirstVote event will be raised\r\n        if(_votes[tokenAddress][tokenId] == 0) {\r\n            emit FirstVote(tokenAddress, tokenId);\r\n        }\r\n\r\n        //Update the votes and ethers amount for this NFT\r\n        _votes[tokenAddress][tokenId] = _votes[tokenAddress][tokenId] + _allowedVotingAmounts[msg.value];\r\n        _ethers[tokenAddress][tokenId] = _ethers[tokenAddress][tokenId] + msg.value;\r\n\r\n        //Collects the rewards that can be gived back to the creator at the end of the survey\r\n        _rewards[creator] = msg.value + _rewards[creator];\r\n\r\n        //Raise an event containing voting info, to let everyone grab this info off-chain\r\n        emit Vote(msg.sender, tokenAddress, tokenId, creator, _allowedVotingAmounts[msg.value], msg.value);\r\n    }\r\n\r\n    function getSurveyEndBlock() public view returns(uint256) {\r\n        return _surveyEndBlock;\r\n    }\r\n\r\n    //Every creator can redeem their rewards at the end of the survey\r\n    function redeemRewards() public {\r\n        require(block.number >= _surveyEndBlock, \"Survey is still running!\");\r\n        require(_rewards[msg.sender] > 0 && !_redeemed[msg.sender], \"No rewards for you or already redeemed!\");\r\n        payable(msg.sender).transfer(_rewards[msg.sender]);\r\n        _redeemed[msg.sender] = true;\r\n    }\r\n}\r\n\r\ninterface IERC721 {\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"allowedTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"surveyEndBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"FirstVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getSurveyEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"BrandContest","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000a1be4000000000000000000000000000000000000000000000000000000000000000020000000000000000000000008aa1b6d4005b69a7c41ab1ab3b6d86d9a3bd093a000000000000000000000000a0a5bb7b563461a586c1bd6d635ba9fde7315008","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2d1046d2643752251562ab0f533fa48360dafce7ef03dacfbeb96012033d6ed9"}]}