{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/loopring/impl/BrokerData.sol\r\n\r\npragma solidity ^0.5.7;\r\n\r\nlibrary BrokerData {\r\n\r\n  struct BrokerOrder {\r\n    address owner;\r\n    bytes32 orderHash;\r\n    uint fillAmountB;\r\n    uint requestedAmountS;\r\n    uint requestedFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n  /**\r\n   * The request wraps all broker orders that share the following overall fields. The perspective on these fields is\r\n   * the orders that are passed in. Meaning, `tokenB` is the token being RECEIVED by each owner and `tokenS` is the\r\n   * token being SPENT by each owner. Lastly, `totalRequestedFeeAmount` is the total `feeAmountS` for all brokered\r\n   * orders. If the fees are in `tokenB`, then this amount is always 0.\r\n   */\r\n  struct BrokerApprovalRequest {\r\n    BrokerOrder[] orders;\r\n    address tokenS;\r\n    address tokenB;\r\n    address feeToken;\r\n    uint totalFillAmountB;\r\n    uint totalRequestedAmountS;\r\n    uint totalRequestedFeeAmount;\r\n  }\r\n\r\n  struct BrokerInterceptorReport {\r\n    address owner;\r\n    address broker;\r\n    bytes32 orderHash;\r\n    address tokenB;\r\n    address tokenS;\r\n    address feeToken;\r\n    uint fillAmountB;\r\n    uint spentAmountS;\r\n    uint spentFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\r\n    }\r\n}\r\n\r\n// File: contracts/market-making/sources/uniswap/UniswapExchange.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IUniswapFactory {\r\n  event NewExchange(address indexed token, address indexed exchange);\r\n\r\n  function initializeFactory(address template) external;\r\n  function createExchange(address token) external returns (address payable);\r\n  function getExchange(address token) external view returns (address payable);\r\n  function getToken(address token) external view returns (address);\r\n  function getTokenWihId(uint256 token_id) external view returns (address);\r\n}\r\n\r\ninterface IUniswapExchange {\r\n  event TokenPurchase(address indexed buyer, uint256 indexed eth_sold, uint256 indexed tokens_bought);\r\n  event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought);\r\n  event AddLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\r\n  event RemoveLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\r\n\r\n  function () external payable;\r\n\r\n  function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) external view returns (uint256);\r\n\r\n  function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve) external view returns (uint256);\r\n\r\n  function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256);\r\n\r\n  function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns(uint256);\r\n\r\n  function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns(uint256);\r\n\r\n  function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256);\r\n\r\n  function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256);\r\n\r\n  function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256);\r\n\r\n  function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256);\r\n\r\n  function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256);\r\n\r\n  function tokenToTokenSwapInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address token_addr) \r\n    external returns (uint256);\r\n\r\n  function tokenToTokenTransferInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address token_addr) \r\n    external returns (uint256);\r\n\r\n  function tokenToTokenSwapOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address token_addr) \r\n    external returns (uint256);\r\n\r\n  function tokenToTokenTransferOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address token_addr) \r\n    external returns (uint256);\r\n\r\n  function tokenToExchangeSwapInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address exchange_addr) \r\n    external returns (uint256);\r\n\r\n  function tokenToExchangeTransferInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address exchange_addr) \r\n    external returns (uint256);\r\n\r\n  function tokenToExchangeSwapOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address exchange_addr) \r\n    external returns (uint256);\r\n\r\n  function tokenToExchangeTransferOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address exchange_addr) \r\n    external returns (uint256);\r\n\r\n  function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256);\r\n  function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256);\r\n  function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256);\r\n  function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256);\r\n\r\n  function tokenAddress() external view returns (address);\r\n  function factoryAddress() external view returns (address);\r\n\r\n  function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n  function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n}\r\n\r\ncontract UniswapExchange is IERC20 {\r\n\r\n  using SafeMath for uint;\r\n\r\n  /***********************************|\r\n  |        Variables && Events        |\r\n  |__________________________________*/\r\n\r\n  // Variables\r\n  bytes32 public name;         // Uniswap V1\r\n  bytes32 public symbol;       // UNI-V1\r\n  uint256 public decimals;     // 18\r\n  IERC20 token;                // address of the IERC20 token traded on this contract\r\n  IUniswapFactory factory;     // interface for the factory that created this contract\r\n\r\n  uint private _totalSupply;\r\n  mapping(address => uint) private _balances;\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n  \r\n  // Events\r\n  event TokenPurchase(address indexed buyer, uint256 indexed eth_sold, uint256 indexed tokens_bought);\r\n  event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought);\r\n  event AddLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\r\n  event RemoveLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\r\n\r\n\r\n  /***********************************|\r\n  |            Constsructor           |\r\n  |__________________________________*/\r\n\r\n  /**  \r\n   * @dev This function acts as a contract constructor which is not currently supported in contracts deployed\r\n   *      using create_with_code_of(). It is called once by the factory during contract creation.\r\n   */\r\n  function setup(address token_addr) public {\r\n    require( \r\n      address(factory) == address(0) && address(token) == address(0) && token_addr != address(0), \r\n      \"INVALID_ADDRESS\"\r\n    );\r\n    factory = IUniswapFactory(msg.sender);\r\n    token = IERC20(token_addr);\r\n    name = 0x556e697377617020563100000000000000000000000000000000000000000000;\r\n    symbol = 0x554e492d56310000000000000000000000000000000000000000000000000000;\r\n    decimals = 18;\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |        Exchange Functions         |\r\n  |__________________________________*/\r\n\r\n\r\n  /**\r\n   * @notice Convert ETH to Tokens.\r\n   * @dev User specifies exact input (msg.value).\r\n   * @dev User cannot specify minimum output or deadline.\r\n   */\r\n  function () external payable {\r\n    ethToTokenInput(msg.value, 1, block.timestamp, msg.sender, msg.sender);\r\n  }\r\n\r\n /**\r\n   * @dev Pricing function for converting between ETH && Tokens.\r\n   * @param input_amount Amount of ETH or Tokens being sold.\r\n   * @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n   * @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n   * @return Amount of ETH or Tokens bought.\r\n   */\r\n  function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) public view returns (uint256) {\r\n    require(input_reserve > 0 && output_reserve > 0, \"INVALID_VALUE\");\r\n    uint256 input_amount_with_fee = input_amount.mul(997);\r\n    uint256 numerator = input_amount_with_fee.mul(output_reserve);\r\n    uint256 denominator = input_reserve.mul(1000).add(input_amount_with_fee);\r\n    return numerator / denominator;\r\n  }\r\n\r\n /**\r\n   * @dev Pricing function for converting between ETH && Tokens.\r\n   * @param output_amount Amount of ETH or Tokens being bought.\r\n   * @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n   * @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n   * @return Amount of ETH or Tokens sold.\r\n   */\r\n  function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve) public view returns (uint256) {\r\n    require(input_reserve > 0 && output_reserve > 0);\r\n    uint256 numerator = input_reserve.mul(output_amount).mul(1000);\r\n    uint256 denominator = (output_reserve.sub(output_amount)).mul(997);\r\n    return (numerator / denominator).add(1);\r\n  }\r\n\r\n  function ethToTokenInput(uint256 eth_sold, uint256 min_tokens, uint256 deadline, address buyer, address recipient) private returns (uint256) {\r\n    require(deadline >= block.timestamp && eth_sold > 0 && min_tokens > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 tokens_bought = getInputPrice(eth_sold, address(this).balance.sub(eth_sold), token_reserve);\r\n    require(tokens_bought >= min_tokens);\r\n    require(token.transfer(recipient, tokens_bought));\r\n    emit TokenPurchase(buyer, eth_sold, tokens_bought);\r\n    return tokens_bought;\r\n  }\r\n\r\n  /** \r\n   * @notice Convert ETH to Tokens.\r\n   * @dev User specifies exact input (msg.value) && minimum output.\r\n   * @param min_tokens Minimum Tokens bought.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @return Amount of Tokens bought.\r\n   */ \r\n  function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) public payable returns (uint256) {\r\n    return ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, msg.sender);\r\n  }\r\n\r\n  /** \r\n   * @notice Convert ETH to Tokens && transfers Tokens to recipient.\r\n   * @dev User specifies exact input (msg.value) && minimum output\r\n   * @param min_tokens Minimum Tokens bought.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output Tokens.\r\n   * @return  Amount of Tokens bought.\r\n   */\r\n  function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) public payable returns(uint256) {\r\n    require(recipient != address(this) && recipient != address(0));\r\n    return ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, recipient);\r\n  }\r\n\r\n  function ethToTokenOutput(uint256 tokens_bought, uint256 max_eth, uint256 deadline, address payable buyer, address recipient) private returns (uint256) {\r\n    require(deadline >= block.timestamp && tokens_bought > 0 && max_eth > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 eth_sold = getOutputPrice(tokens_bought, address(this).balance.sub(max_eth), token_reserve);\r\n    // Throws if eth_sold > max_eth\r\n    uint256 eth_refund = max_eth.sub(eth_sold);\r\n    if (eth_refund > 0) {\r\n      buyer.transfer(eth_refund);\r\n    }\r\n    require(token.transfer(recipient, tokens_bought));\r\n    emit TokenPurchase(buyer, eth_sold, tokens_bought);\r\n    return eth_sold;\r\n  }\r\n\r\n  /** \r\n   * @notice Convert ETH to Tokens.\r\n   * @dev User specifies maximum input (msg.value) && exact output.\r\n   * @param tokens_bought Amount of tokens bought.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @return Amount of ETH sold.\r\n   */\r\n  function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) public payable returns(uint256) {\r\n    return ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, msg.sender);\r\n  }\r\n\r\n  /** \r\n   * @notice Convert ETH to Tokens && transfers Tokens to recipient.\r\n   * @dev User specifies maximum input (msg.value) && exact output.\r\n   * @param tokens_bought Amount of tokens bought.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output Tokens.\r\n   * @return Amount of ETH sold.\r\n   */\r\n  function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) public payable returns (uint256) {\r\n    require(recipient != address(this) && recipient != address(0));\r\n    return ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, recipient);\r\n  }\r\n\r\n  function tokenToEthInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address buyer, address payable recipient) private returns (uint256) {\r\n    require(deadline >= block.timestamp && tokens_sold > 0 && min_eth > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 eth_bought = getInputPrice(tokens_sold, token_reserve, address(this).balance);\r\n    uint256 wei_bought = eth_bought;\r\n    require(wei_bought >= min_eth);\r\n    recipient.transfer(wei_bought);\r\n    require(token.transferFrom(buyer, address(this), tokens_sold));\r\n    emit EthPurchase(buyer, tokens_sold, wei_bought);\r\n    return wei_bought;\r\n  }\r\n\r\n  /** \r\n   * @notice Convert Tokens to ETH.\r\n   * @dev User specifies exact input && minimum output.\r\n   * @param tokens_sold Amount of Tokens sold.\r\n   * @param min_eth Minimum ETH purchased.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @return Amount of ETH bought.\r\n   */\r\n  function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) public returns (uint256) {\r\n    return tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, msg.sender);\r\n  }\r\n\r\n  /** \r\n   * @notice Convert Tokens to ETH && transfers ETH to recipient.\r\n   * @dev User specifies exact input && minimum output.\r\n   * @param tokens_sold Amount of Tokens sold.\r\n   * @param min_eth Minimum ETH purchased.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output ETH.\r\n   * @return  Amount of ETH bought.\r\n   */\r\n  function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address payable recipient) public returns (uint256) {\r\n    require(recipient != address(this) && recipient != address(0));\r\n    return tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, recipient);\r\n  }\r\n\r\n  \r\n  function tokenToEthOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address buyer, address payable recipient) private returns (uint256) {\r\n    require(deadline >= block.timestamp && eth_bought > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 tokens_sold = getOutputPrice(eth_bought, token_reserve, address(this).balance);\r\n    // tokens sold is always > 0\r\n    require(max_tokens >= tokens_sold);\r\n    recipient.transfer(eth_bought);\r\n    require(token.transferFrom(buyer, address(this), tokens_sold));\r\n    emit EthPurchase(buyer, tokens_sold, eth_bought);\r\n    return tokens_sold;\r\n  }\r\n\r\n  /** \r\n   * @notice Convert Tokens to ETH.\r\n   * @dev User specifies maximum input && exact output.\r\n   * @param eth_bought Amount of ETH purchased.\r\n   * @param max_tokens Maximum Tokens sold.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @return Amount of Tokens sold.\r\n   */\r\n  function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) public returns (uint256) {\r\n    return tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens to ETH && transfers ETH to recipient.\r\n   * @dev User specifies maximum input && exact output.\r\n   * @param eth_bought Amount of ETH purchased.\r\n   * @param max_tokens Maximum Tokens sold.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output ETH.\r\n   * @return Amount of Tokens sold.\r\n   */\r\n  function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address payable recipient) public returns (uint256) {\r\n    require(recipient != address(this) && recipient != address(0));\r\n    return tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, recipient);\r\n  }\r\n\r\n  function tokenToTokenInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline,\r\n    address buyer, \r\n    address recipient, \r\n    address payable exchange_addr) \r\n    private returns (uint256) \r\n  {\r\n    require(deadline >= block.timestamp && tokens_sold > 0 && min_tokens_bought > 0 && min_eth_bought > 0);\r\n    require(exchange_addr != address(this) && exchange_addr != address(0));\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 eth_bought = getInputPrice(tokens_sold, token_reserve, address(this).balance);\r\n    uint256 wei_bought = eth_bought;\r\n    require(wei_bought >= min_eth_bought);\r\n    require(token.transferFrom(buyer, address(this), tokens_sold));\r\n    uint256 tokens_bought = IUniswapExchange(exchange_addr).ethToTokenTransferInput.value(wei_bought)(min_tokens_bought, deadline, recipient);\r\n    emit EthPurchase(buyer, tokens_sold, wei_bought);\r\n    return tokens_bought;\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (token_addr).\r\n   * @dev User specifies exact input && minimum output.\r\n   * @param tokens_sold Amount of Tokens sold.\r\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param token_addr The address of the token being purchased.\r\n   * @return Amount of Tokens (token_addr) bought.\r\n   */\r\n  function tokenToTokenSwapInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address token_addr) \r\n    public returns (uint256) \r\n  {\r\n    address payable exchange_addr = factory.getExchange(token_addr);\r\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (token_addr) && transfers\r\n   *         Tokens (token_addr) to recipient.\r\n   * @dev User specifies exact input && minimum output.\r\n   * @param tokens_sold Amount of Tokens sold.\r\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output ETH.\r\n   * @param token_addr The address of the token being purchased.\r\n   * @return Amount of Tokens (token_addr) bought.\r\n   */\r\n  function tokenToTokenTransferInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address token_addr) \r\n    public returns (uint256) \r\n  {\r\n    address payable exchange_addr = factory.getExchange(token_addr);\r\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr);\r\n  }\r\n\r\n  function tokenToTokenOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address buyer, \r\n    address recipient, \r\n    address payable exchange_addr) \r\n    private returns (uint256) \r\n  {\r\n    require(deadline >= block.timestamp && (tokens_bought > 0 && max_eth_sold > 0));\r\n    require(exchange_addr != address(this) && exchange_addr != address(0));\r\n    uint256 eth_bought = IUniswapExchange(exchange_addr).getEthToTokenOutputPrice(tokens_bought);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 tokens_sold = getOutputPrice(eth_bought, token_reserve, address(this).balance);\r\n    // tokens sold is always > 0\r\n    require(max_tokens_sold >= tokens_sold && max_eth_sold >= eth_bought);\r\n    require(token.transferFrom(buyer, address(this), tokens_sold));\r\n    uint256 eth_sold = IUniswapExchange(exchange_addr).ethToTokenTransferOutput.value(eth_bought)(tokens_bought, deadline, recipient);\r\n    emit EthPurchase(buyer, tokens_sold, eth_bought);\r\n    return tokens_sold;\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (token_addr).\r\n   * @dev User specifies maximum input && exact output.\r\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\r\n   * @param max_tokens_sold Maximum Tokens (token) sold.\r\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param token_addr The address of the token being purchased.\r\n   * @return Amount of Tokens (token) sold.\r\n   */\r\n  function tokenToTokenSwapOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address token_addr) \r\n    public returns (uint256) \r\n  {\r\n    address payable exchange_addr = factory.getExchange(token_addr);\r\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (token_addr) && transfers\r\n   *         Tokens (token_addr) to recipient.\r\n   * @dev User specifies maximum input && exact output.\r\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\r\n   * @param max_tokens_sold Maximum Tokens (token) sold.\r\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output ETH.\r\n   * @param token_addr The address of the token being purchased.\r\n   * @return Amount of Tokens (token) sold.\r\n   */\r\n  function tokenToTokenTransferOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address token_addr) \r\n    public returns (uint256) \r\n  {\r\n    address payable exchange_addr = factory.getExchange(token_addr);\r\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token).\r\n   * @dev Allows trades through contracts that were not deployed from the same factory.\r\n   * @dev User specifies exact input && minimum output.\r\n   * @param tokens_sold Amount of Tokens sold.\r\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param exchange_addr The address of the exchange for the token being purchased.\r\n   * @return Amount of Tokens (exchange_addr.token) bought.\r\n   */\r\n  function tokenToExchangeSwapInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address payable exchange_addr) \r\n    public returns (uint256) \r\n  {\r\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token) && transfers\r\n   *         Tokens (exchange_addr.token) to recipient.\r\n   * @dev Allows trades through contracts that were not deployed from the same factory.\r\n   * @dev User specifies exact input && minimum output.\r\n   * @param tokens_sold Amount of Tokens sold.\r\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\r\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output ETH.\r\n   * @param exchange_addr The address of the exchange for the token being purchased.\r\n   * @return Amount of Tokens (exchange_addr.token) bought.\r\n   */\r\n  function tokenToExchangeTransferInput(\r\n    uint256 tokens_sold, \r\n    uint256 min_tokens_bought, \r\n    uint256 min_eth_bought, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address payable exchange_addr) \r\n    public returns (uint256) \r\n  {\r\n    require(recipient != address(this));\r\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token).\r\n   * @dev Allows trades through contracts that were not deployed from the same factory.\r\n   * @dev User specifies maximum input && exact output.\r\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\r\n   * @param max_tokens_sold Maximum Tokens (token) sold.\r\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param exchange_addr The address of the exchange for the token being purchased.\r\n   * @return Amount of Tokens (token) sold.\r\n   */\r\n  function tokenToExchangeSwapOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address payable exchange_addr) \r\n    public returns (uint256) \r\n  {\r\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token) && transfers\r\n   *         Tokens (exchange_addr.token) to recipient.\r\n   * @dev Allows trades through contracts that were not deployed from the same factory.\r\n   * @dev User specifies maximum input && exact output.\r\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\r\n   * @param max_tokens_sold Maximum Tokens (token) sold.\r\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @param recipient The address that receives output ETH.\r\n   * @param exchange_addr The address of the exchange for the token being purchased.\r\n   * @return Amount of Tokens (token) sold.\r\n   */\r\n  function tokenToExchangeTransferOutput(\r\n    uint256 tokens_bought, \r\n    uint256 max_tokens_sold, \r\n    uint256 max_eth_sold, \r\n    uint256 deadline, \r\n    address recipient, \r\n    address payable exchange_addr) \r\n    public returns (uint256) \r\n  {\r\n    require(recipient != address(this));\r\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr);\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |         Getter Functions          |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @notice Public price function for ETH to Token trades with an exact input.\r\n   * @param eth_sold Amount of ETH sold.\r\n   * @return Amount of Tokens that can be bought with input ETH.\r\n   */\r\n  function getEthToTokenInputPrice(uint256 eth_sold) public view returns (uint256) {\r\n    require(eth_sold > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    return getInputPrice(eth_sold, address(this).balance, token_reserve);\r\n  }\r\n\r\n  /**\r\n   * @notice Public price function for ETH to Token trades with an exact output.\r\n   * @param tokens_bought Amount of Tokens bought.\r\n   * @return Amount of ETH needed to buy output Tokens.\r\n   */\r\n  function getEthToTokenOutputPrice(uint256 tokens_bought) public view returns (uint256) {\r\n    require(tokens_bought > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 eth_sold = getOutputPrice(tokens_bought, address(this).balance, token_reserve);\r\n    return eth_sold;\r\n  }\r\n\r\n  /**\r\n   * @notice Public price function for Token to ETH trades with an exact input.\r\n   * @param tokens_sold Amount of Tokens sold.\r\n   * @return Amount of ETH that can be bought with input Tokens.\r\n   */\r\n  function getTokenToEthInputPrice(uint256 tokens_sold) public view returns (uint256) {\r\n    require(tokens_sold > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 eth_bought = getInputPrice(tokens_sold, token_reserve, address(this).balance);\r\n    return eth_bought;\r\n  }\r\n\r\n  /**\r\n   * @notice Public price function for Token to ETH trades with an exact output.\r\n   * @param eth_bought Amount of output ETH.\r\n   * @return Amount of Tokens needed to buy output ETH.\r\n   */\r\n  function getTokenToEthOutputPrice(uint256 eth_bought) public view returns (uint256) {\r\n    require(eth_bought > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    return getOutputPrice(eth_bought, token_reserve, address(this).balance);\r\n  }\r\n\r\n  /** \r\n   * @return Address of Token that is sold on this exchange.\r\n   */\r\n  function tokenAddress() public view returns (address) {\r\n    return address(token);\r\n  }\r\n\r\n  /**\r\n   * @return Address of factory that created this exchange.\r\n   */\r\n  function factoryAddress() public view returns (address) {\r\n    return address(factory);\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |        Liquidity Functions        |\r\n  |__________________________________*/\r\n\r\n  /** \r\n   * @notice Deposit ETH && Tokens (token) at current ratio to mint UNI tokens.\r\n   * @dev min_liquidity does nothing when total UNI supply is 0.\r\n   * @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\r\n   * @param max_tokens Maximum number of tokens deposited. Deposits max amount if total UNI supply is 0.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @return The amount of UNI minted.\r\n   */\r\n  function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) public payable returns (uint256) {\r\n    require(deadline > block.timestamp && max_tokens > 0 && msg.value > 0, 'UniswapExchange#addLiquidity: INVALID_ARGUMENT');\r\n    uint256 total_liquidity = _totalSupply;\r\n\r\n    if (total_liquidity > 0) {\r\n      require(min_liquidity > 0, \"INVALID_MIN_LIQUIDITY\");\r\n      uint256 eth_reserve = address(this).balance.sub(msg.value);\r\n      uint256 token_reserve = token.balanceOf(address(this));\r\n      uint256 token_amount = (msg.value.mul(token_reserve) / eth_reserve).add(1);\r\n      uint256 liquidity_minted = msg.value.mul(total_liquidity) / eth_reserve;\r\n      require(max_tokens >= token_amount && liquidity_minted >= min_liquidity);\r\n      _balances[msg.sender] = _balances[msg.sender].add(liquidity_minted);\r\n      _totalSupply = total_liquidity.add(liquidity_minted);\r\n      require(token.transferFrom(msg.sender, address(this), token_amount));\r\n      emit AddLiquidity(msg.sender, msg.value, token_amount);\r\n      emit Transfer(address(0), msg.sender, liquidity_minted);\r\n      return liquidity_minted;\r\n\r\n    } else {\r\n      require(address(factory) != address(0) && address(token) != address(0) && msg.value >= 1000000000, \"INVALID_VALUE\");\r\n      require(factory.getExchange(address(token)) == address(this), \"INVALID_EXCHANGE\");\r\n      uint256 token_amount = max_tokens;\r\n      uint256 initial_liquidity = address(this).balance;\r\n      _totalSupply = initial_liquidity;\r\n      _balances[msg.sender] = initial_liquidity;\r\n      require(token.transferFrom(msg.sender, address(this), token_amount));\r\n      emit AddLiquidity(msg.sender, msg.value, token_amount);\r\n      emit Transfer(address(0), msg.sender, initial_liquidity);\r\n      return initial_liquidity;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Burn UNI tokens to withdraw ETH && Tokens at current ratio.\r\n   * @param amount Amount of UNI burned.\r\n   * @param min_eth Minimum ETH withdrawn.\r\n   * @param min_tokens Minimum Tokens withdrawn.\r\n   * @param deadline Time after which this transaction can no longer be executed.\r\n   * @return The amount of ETH && Tokens withdrawn.\r\n   */\r\n  function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) public returns (uint256, uint256) {\r\n    require(amount > 0 && deadline > block.timestamp && min_eth > 0 && min_tokens > 0);\r\n    uint256 total_liquidity = _totalSupply;\r\n    require(total_liquidity > 0);\r\n    uint256 token_reserve = token.balanceOf(address(this));\r\n    uint256 eth_amount = amount.mul(address(this).balance) / total_liquidity;\r\n    uint256 token_amount = amount.mul(token_reserve) / total_liquidity;\r\n    require(eth_amount >= min_eth && token_amount >= min_tokens);\r\n\r\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n    _totalSupply = total_liquidity.sub(amount);\r\n    msg.sender.transfer(eth_amount);\r\n    require(token.transfer(msg.sender, token_amount));\r\n    emit RemoveLiquidity(msg.sender, eth_amount, token_amount);\r\n    emit Transfer(msg.sender, address(0), amount);\r\n    return (eth_amount, token_amount);\r\n  }\r\n\r\n  function balanceOf(address owner) public view returns (uint) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  function totalSupply() public view returns (uint) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint) {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n    emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/IBrokerDelegate.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IBrokerDelegate {\r\n\r\n  /*\r\n   * Loopring requests an allowance be set on a given token for a specified amount. Order details\r\n   * are provided (tokenS, totalAmountS, tokenB, totalAmountB, orderTokenRecipient, extraOrderData)\r\n   * to aid in any calculations or on-chain exchange of assets that may be required. The last 4\r\n   * parameters concern the actual token approval being requested of the broker.\r\n   *\r\n   * @returns Whether or not onOrderFillReport should be called for orders using this broker\r\n   */\r\n  function brokerRequestAllowance(BrokerData.BrokerApprovalRequest calldata request) external returns (bool);\r\n\r\n  /*\r\n   * After Loopring performs all of the transfers necessary to complete all the submitted\r\n   * rings it will call this function for every order's brokerInterceptor (if set) passing\r\n   * along the final fill counts for tokenB, tokenS and feeToken. This allows actions to be\r\n   * performed on a per-order basis after all tokenS/feeToken funds have left the order owner's\r\n   * possession and the tokenB funds have been transferred to the order owner's intended recipient\r\n   */\r\n  function onOrderFillReport(BrokerData.BrokerInterceptorReport calldata fillReport) external;\r\n\r\n  /*\r\n   * Get the available token balance controlled by the broker on behalf of an address (owner)\r\n   */\r\n  function brokerBalanceOf(address owner, address token) external view returns (uint);\r\n}\r\n\r\n// File: contracts/dolomite-direct/DolomiteDirectV1.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n\r\n\r\n\r\npragma solidity ^0.5.7;\r\n\r\nlibrary Types {\r\n\r\n    struct RequestFee {\r\n        address feeRecipient;\r\n        address feeToken;\r\n        uint feeAmount;\r\n    }\r\n\r\n    struct RequestSignature {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    enum RequestType {Update, Transfer, Approve, Perform}\r\n\r\n    struct Request {\r\n        address owner;\r\n        address target;\r\n        RequestType requestType;\r\n        bytes payload;\r\n        uint nonce;\r\n        RequestFee fee;\r\n        RequestSignature signature;\r\n    }\r\n\r\n    struct TransferRequest {\r\n        address token;\r\n        address recipient;\r\n        uint amount;\r\n        bool unwrap;\r\n    }\r\n}\r\n\r\ninterface IDolomiteMarginTradingBroker {\r\n    function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n\r\n    function brokerMarginGetTrader(address owner, bytes calldata orderData) external view returns (address);\r\n}\r\n\r\ninterface IVersionable {\r\n\r\n    /*\r\n     * Is called by IDepositContractRegistry when this version\r\n     * is being upgraded to. Will call `versionEndUsage` on the\r\n     * old contract before calling this one\r\n     */\r\n    function versionBeginUsage(\r\n        address owner,\r\n        address payable depositAddress,\r\n        address oldVersion,\r\n        bytes calldata additionalData\r\n    ) external;\r\n\r\n    /*\r\n     * Is called by IDepositContractRegistry when this version is\r\n     * being upgraded from. IDepositContractRegistry will then call\r\n     * `versionBeginUsage` on the new contract\r\n     */\r\n    function versionEndUsage(\r\n        address owner,\r\n        address payable depositAddress,\r\n        address newVersion,\r\n        bytes calldata additionalData\r\n    ) external;\r\n}\r\n\r\ninterface IDepositContract {\r\n    function perform(\r\n        address addr,\r\n        string calldata signature,\r\n        bytes calldata encodedParams,\r\n        uint value\r\n    ) external returns (bytes memory);\r\n}\r\n\r\ninterface IDepositContractRegistry {\r\n    function depositAddressOf(address owner) external view returns (address payable);\r\n\r\n    function operatorOf(address owner, address operator) external returns (bool);\r\n}\r\n\r\nlibrary DepositContractHelper {\r\n\r\n    function wrapAndTransferToken(IDepositContract self, address token, address recipient, uint amount, address wethAddress) internal {\r\n        if (token == wethAddress) {\r\n            uint etherBalance = address(self).balance;\r\n            if (etherBalance > 0) wrapEth(self, token, etherBalance);\r\n        }\r\n        transferToken(self, token, recipient, amount);\r\n    }\r\n\r\n    function transferToken(IDepositContract self, address token, address recipient, uint amount) internal {\r\n        self.perform(token, \"transfer(address,uint256)\", abi.encode(recipient, amount), 0);\r\n    }\r\n\r\n    function transferEth(IDepositContract self, address recipient, uint amount) internal {\r\n        self.perform(recipient, \"\", abi.encode(), amount);\r\n    }\r\n\r\n    function approveToken(IDepositContract self, address token, address broker, uint amount) internal {\r\n        self.perform(token, \"approve(address,uint256)\", abi.encode(broker, amount), 0);\r\n    }\r\n\r\n    function wrapEth(IDepositContract self, address wethToken, uint amount) internal {\r\n        self.perform(wethToken, \"deposit()\", abi.encode(), amount);\r\n    }\r\n\r\n    function unwrapWeth(IDepositContract self, address wethToken, uint amount) internal {\r\n        self.perform(wethToken, \"withdraw(uint256)\", abi.encode(amount), 0);\r\n    }\r\n\r\n    function setDydxOperator(IDepositContract self, address dydxContract, address operator) internal {\r\n        bytes memory encodedParams = abi.encode(\r\n            bytes32(0x0000000000000000000000000000000000000000000000000000000000000020),\r\n            bytes32(0x0000000000000000000000000000000000000000000000000000000000000001),\r\n            operator,\r\n            bytes32(0x0000000000000000000000000000000000000000000000000000000000000001)\r\n        );\r\n        self.perform(dydxContract, \"setOperators((address,bool)[])\", encodedParams, 0);\r\n    }\r\n}\r\n\r\nlibrary RequestHelper {\r\n\r\n    bytes constant personalPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    function getSigner(Types.Request memory self) internal pure returns (address) {\r\n        bytes32 messageHash = keccak256(abi.encode(\r\n                self.owner,\r\n                self.target,\r\n                self.requestType,\r\n                self.payload,\r\n                self.nonce,\r\n                abi.encode(self.fee.feeRecipient, self.fee.feeToken, self.fee.feeAmount)\r\n            ));\r\n\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(personalPrefix, messageHash));\r\n        return ecrecover(prefixedHash, self.signature.v, self.signature.r, self.signature.s);\r\n    }\r\n\r\n    function decodeTransferRequest(Types.Request memory self)\r\n    internal\r\n    pure\r\n    returns (Types.TransferRequest memory transferRequest)\r\n    {\r\n        require(self.requestType == Types.RequestType.Transfer, \"INVALID_REQUEST_TYPE\");\r\n\r\n        (\r\n        transferRequest.token,\r\n        transferRequest.recipient,\r\n        transferRequest.amount,\r\n        transferRequest.unwrap\r\n    ) = abi.decode(self.payload, (address, address, uint, bool));\r\n    }\r\n}\r\n\r\ncontract Requestable {\r\n    using RequestHelper for Types.Request;\r\n\r\n    mapping(address => uint) nonces;\r\n\r\n    function validateRequest(Types.Request memory request) internal {\r\n        require(request.target == address(this), \"INVALID_TARGET\");\r\n        require(request.getSigner() == request.owner, \"INVALID_SIGNATURE\");\r\n        require(nonces[request.owner] + 1 == request.nonce, \"INVALID_NONCE\");\r\n\r\n        if (request.fee.feeAmount > 0) {\r\n            require(balanceOf(request.owner, request.fee.feeToken) >= request.fee.feeAmount, \"INSUFFICIENT_FEE_BALANCE\");\r\n        }\r\n\r\n        nonces[request.owner] += 1;\r\n    }\r\n\r\n    function completeRequest(Types.Request memory request) internal {\r\n        if (request.fee.feeAmount > 0) {\r\n            _payRequestFee(request.owner, request.fee.feeToken, request.fee.feeRecipient, request.fee.feeAmount);\r\n        }\r\n    }\r\n\r\n    function nonceOf(address owner) public view returns (uint) {\r\n        return nonces[owner];\r\n    }\r\n\r\n    // Abtract functions\r\n    function balanceOf(address owner, address token) public view returns (uint);\r\n\r\n    function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal;\r\n}\r\n\r\n/**\r\n * @title DolomiteDirectV1\r\n * @author Zack Rubenstein from Dolomite\r\n *\r\n * Interfaces with the IDepositContractRegistry and individual \r\n * IDepositContracts to enable smart-wallet functionality as well\r\n * as spot and margin trading on Dolomite (through Loopring & dYdX)\r\n */\r\ncontract DolomiteDirectV1 is Requestable, IVersionable, IDolomiteMarginTradingBroker {\r\n    using DepositContractHelper for IDepositContract;\r\n    using SafeMath for uint;\r\n\r\n    IDepositContractRegistry public registry;\r\n    address public loopringDelegate;\r\n    address public dolomiteMarginProtocolAddress;\r\n    address public dydxProtocolAddress;\r\n    address public wethTokenAddress;\r\n\r\n    constructor(\r\n        address _depositContractRegistry,\r\n        address _loopringDelegate,\r\n        address _dolomiteMarginProtocol,\r\n        address _dydxProtocolAddress,\r\n        address _wethTokenAddress\r\n    ) public {\r\n        registry = IDepositContractRegistry(_depositContractRegistry);\r\n        loopringDelegate = _loopringDelegate;\r\n        dolomiteMarginProtocolAddress = _dolomiteMarginProtocol;\r\n        dydxProtocolAddress = _dydxProtocolAddress;\r\n        wethTokenAddress = _wethTokenAddress;\r\n    }\r\n\r\n    /*\r\n     * Returns the available balance for an owner that this contract manages.\r\n     * If the token is WETH, it returns the sum of the ETH and WETH balance,\r\n     * as ETH is automatically wrapped upon transfers (unless the unwrap option is\r\n     * set to true in the transfer request)\r\n     */\r\n    function balanceOf(address owner, address token) public view returns (uint) {\r\n        address depositAddress = registry.depositAddressOf(owner);\r\n        uint tokenBalance = IERC20(token).balanceOf(depositAddress);\r\n        if (token == wethTokenAddress) tokenBalance = tokenBalance.add(depositAddress.balance);\r\n        return tokenBalance;\r\n    }\r\n\r\n    /*\r\n     * Send up a signed transfer request and the given amount tokens\r\n     * is transferred to the specified recipient.\r\n     */\r\n    function transfer(Types.Request memory request) public {\r\n        validateRequest(request);\r\n\r\n        Types.TransferRequest memory transferRequest = request.decodeTransferRequest();\r\n        address payable depositAddress = registry.depositAddressOf(request.owner);\r\n\r\n        _transfer(\r\n            transferRequest.token,\r\n            depositAddress,\r\n            transferRequest.recipient,\r\n            transferRequest.amount,\r\n            transferRequest.unwrap\r\n        );\r\n\r\n        completeRequest(request);\r\n    }\r\n\r\n    // =============================\r\n\r\n    function _transfer(address token, address payable depositAddress, address recipient, uint amount, bool unwrap) internal {\r\n        IDepositContract depositContract = IDepositContract(depositAddress);\r\n\r\n        if (token == wethTokenAddress && unwrap) {\r\n            if (depositAddress.balance < amount) {\r\n                depositContract.unwrapWeth(wethTokenAddress, amount.sub(depositAddress.balance));\r\n            }\r\n\r\n            depositContract.transferEth(recipient, amount);\r\n            return;\r\n        }\r\n\r\n        depositContract.wrapAndTransferToken(token, recipient, amount, wethTokenAddress);\r\n    }\r\n\r\n    // -----------------------------\r\n    // Loopring Broker Delegate\r\n\r\n    function brokerRequestAllowance(BrokerData.BrokerApprovalRequest memory request) public returns (bool) {\r\n        require(msg.sender == loopringDelegate);\r\n\r\n        BrokerData.BrokerOrder[] memory mergedOrders = new BrokerData.BrokerOrder[](request.orders.length);\r\n        uint numMergedOrders = 1;\r\n\r\n        mergedOrders[0] = request.orders[0];\r\n\r\n        if (request.orders.length > 1) {\r\n            for (uint i = 1; i < request.orders.length; i++) {\r\n                bool isDuplicate = false;\r\n\r\n                for (uint b = 0; b < numMergedOrders; b++) {\r\n                    if (request.orders[i].owner == mergedOrders[b].owner) {\r\n                        mergedOrders[b].requestedAmountS += request.orders[i].requestedAmountS;\r\n                        mergedOrders[b].requestedFeeAmount += request.orders[i].requestedFeeAmount;\r\n                        isDuplicate = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!isDuplicate) {\r\n                    mergedOrders[numMergedOrders] = request.orders[i];\r\n                    numMergedOrders += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (uint j = 0; j < numMergedOrders; j++) {\r\n            BrokerData.BrokerOrder memory order = mergedOrders[j];\r\n            address payable depositAddress = registry.depositAddressOf(order.owner);\r\n\r\n            _transfer(request.tokenS, depositAddress, address(this), order.requestedAmountS, false);\r\n            if (order.requestedFeeAmount > 0) _transfer(request.feeToken, depositAddress, address(this), order.requestedFeeAmount, false);\r\n        }\r\n\r\n        return false;\r\n        // Does not use onOrderFillReport\r\n    }\r\n\r\n    function onOrderFillReport(BrokerData.BrokerInterceptorReport memory fillReport) public {\r\n        // Do nothing\r\n    }\r\n\r\n    function brokerBalanceOf(address owner, address tokenAddress) public view returns (uint) {\r\n        return balanceOf(owner, tokenAddress);\r\n    }\r\n\r\n    // ----------------------------\r\n    // Dolomite Margin Trading Broker\r\n\r\n    function brokerMarginRequestApproval(address owner, address token, uint amount) public {\r\n        require(msg.sender == dolomiteMarginProtocolAddress || msg.sender == loopringDelegate, \"brokerMarginRequestApproval: INVALID_SENDER\");\r\n\r\n        address payable depositAddress = registry.depositAddressOf(owner);\r\n        _transfer(token, depositAddress, address(this), amount, false);\r\n    }\r\n\r\n    function brokerMarginGetTrader(address owner, bytes memory orderData) public view returns (address) {\r\n        return registry.depositAddressOf(owner);\r\n    }\r\n\r\n    // -----------------------------\r\n    // Requestable\r\n\r\n    function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal {\r\n        _transfer(feeToken, registry.depositAddressOf(owner), feeRecipient, feeAmount, false);\r\n    }\r\n\r\n    // -----------------------------\r\n    // Versionable\r\n\r\n    function versionBeginUsage(\r\n        address owner,\r\n        address payable depositAddress,\r\n        address oldVersion,\r\n        bytes calldata additionalData\r\n    ) external {\r\n        // Approve the DolomiteMarginProtocol as an operator for the deposit contract's dYdX account\r\n        IDepositContract(depositAddress).setDydxOperator(dydxProtocolAddress, dolomiteMarginProtocolAddress);\r\n    }\r\n\r\n    function versionEndUsage(\r\n        address owner,\r\n        address payable depositAddress,\r\n        address newVersion,\r\n        bytes calldata additionalData\r\n    ) external {/* do nothing */}\r\n\r\n\r\n    // =============================\r\n    // Administrative\r\n\r\n    /*\r\n     * Tokens are held in individual deposit contracts, the only time a trader's\r\n     * funds are held by this contract is when Loopring or dYdX requests a trader's\r\n     * tokens, and immediately upon this contract moving funds into itself, Loopring\r\n     * or dYdX will move the funds out and into themselves. Thus, we can open this\r\n     * function up for anyone to call to set or reset the approval for Loopring and\r\n     * dYdX for a given token. The reason these approvals are set globally and not\r\n     * on an as-needed (per fill) basis is to reduce gas costs.\r\n     */\r\n    function enableTrading(address token) public {\r\n        IERC20(token).approve(loopringDelegate, 10 ** 70);\r\n        IERC20(token).approve(dolomiteMarginProtocolAddress, 10 ** 70);\r\n    }\r\n\r\n    function enableTrading(address[] calldata tokens) external {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            enableTrading(tokens[i]);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\n// File: contracts/libs/SafeEther.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary SafeEther {\r\n\r\n    function safeTransferEther(address recipient, uint amount) internal {\r\n        safeTransferEther(recipient, amount, \"CANNOT_TRANSFER_ETHER\");\r\n    }\r\n\r\n    function safeTransferEther(address recipient, uint amount, string memory errorMessage) internal {\r\n        (bool success,) = address(uint160(recipient)).call.value(amount)(\"\");\r\n        require(success, errorMessage);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/market-making/helper/MakerBrokerBase.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev The base contract for any ownable contract is used for permissioned market making with either open liquidity\r\n *      pools, like Uniswap, or permissioned ones like Dolomite Options.\r\n */\r\ncontract MakerBrokerBase {\r\n\r\n    using SafeEther for address payable;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0x0), \"ZERO_ADDRESS\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function withdrawDust(address token) external {\r\n        _withdrawDust(token, msg.sender);\r\n    }\r\n\r\n    function withdrawDust(address token, address recipient) external {\r\n        _withdrawDust(token, recipient);\r\n    }\r\n\r\n    function withdrawEthDust() external {\r\n        _withdrawEthDust(msg.sender);\r\n    }\r\n\r\n    function withdrawEthDust(address payable recipient) external {\r\n        _withdrawEthDust(recipient);\r\n    }\r\n\r\n    function _withdrawDust(address token, address recipient) internal {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        IERC20(token).safeTransfer(\r\n            msg.sender,\r\n            IERC20(token).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function _withdrawEthDust(address payable recipient) internal {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        recipient.safeTransferEther(address(this).balance);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/misc/interfaces/IWETH.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\ninterface IWETH {\r\n  event Deposit(address indexed src, uint wad);\r\n  event Withdraw(address indexed src, uint wad);\r\n\r\n  function deposit() external payable;\r\n  function withdraw(uint wad) external;\r\n}\r\n\r\n// File: contracts/market-making/UniswapMakerBroker.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary UniswapFactoryHelper {\r\n    function exchangeOf(IUniswapFactory self, address token) internal returns (IUniswapExchange) {\r\n        return IUniswapExchange(self.getExchange(token));\r\n    }\r\n}\r\n\r\n/*\r\n * Inherits Loopring's IBrokerDelegate and sources liquidity from Uniswap\r\n * when the Loopring protocol requests a token approval. Because the Loopring\r\n * protocol expects the taker order to precede maker orders, and non-brokered\r\n * transfers occur before before brokered transfers, it is guaranteed that this\r\n * broker contract will receive the necessary tokens to trade, right before it\r\n * sets the approval and the Loopring protocol transfers the tokens out. Thus,\r\n * liquidity can be sourced on-chain with no money down!\r\n */\r\ncontract UniswapMakerBroker is MakerBrokerBase {\r\n    using UniswapFactoryHelper for IUniswapFactory;\r\n\r\n    address public wethTokenAddress;\r\n    address public loopringDelegate;\r\n    IUniswapFactory public uniswapFactory;\r\n\r\n    mapping(address => address) public tokenToExchange;\r\n    mapping(address => bool) public tokenToIsSetup;\r\n\r\n    constructor(address _loopringDelegate, address _uniswapFactory, address _wethTokenAddress) public {\r\n        loopringDelegate = _loopringDelegate;\r\n        wethTokenAddress = _wethTokenAddress;\r\n        uniswapFactory = IUniswapFactory(_uniswapFactory);\r\n    }\r\n\r\n    function setupToken(address token, bool setupExchange) public {\r\n        if (setupExchange) {\r\n            IUniswapExchange exchange = uniswapFactory.exchangeOf(token);\r\n            ERC20(token).approve(address(exchange), uint(-1));\r\n            tokenToExchange[token] = address(exchange);\r\n        }\r\n        ERC20(token).approve(loopringDelegate, uint(-1));\r\n        tokenToIsSetup[token] = true;\r\n    }\r\n\r\n    function setupTokens(address[] calldata tokens, bool[] calldata setupExchanges) external {\r\n        require(tokens.length == setupExchanges.length, \"lengths do not match\");\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            setupToken(tokens[i], setupExchanges[i]);\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        // No op, but accepts ETH being sent to this contract.\r\n    }\r\n\r\n    // --------------------------------\r\n    // Loopring Broker Delegate\r\n\r\n    function brokerRequestAllowance(BrokerData.BrokerApprovalRequest memory request) public returns (bool) {\r\n        require(msg.sender == loopringDelegate, \"Uniswap MakerBroker: Unauthorized caller\");\r\n        require(tokenToIsSetup[request.tokenS], \"Uniswap MakerBroker: tokenS is not setup yet\");\r\n\r\n        for (uint i = 0; i < request.orders.length; i++) {\r\n            require(request.orders[i].tokenRecipient == address(this), \"Uniswap MakerBroker: Order tokenRecipient must be this broker\");\r\n            require(request.orders[i].owner == owner, \"Uniswap MakerBroker: Order owner must be the owner of this contract\");\r\n        }\r\n\r\n        if (request.tokenB == wethTokenAddress) {\r\n            // We need to convert WETH to ETH to 1) avoid double fee payment on Uniswap and 2) get the best price on Uniswap\r\n            IWETH(wethTokenAddress).withdraw(request.totalFillAmountB);\r\n        }\r\n\r\n        // perform exchange\r\n        bool isTokenBExchangeWrapper = abi.decode(request.orders[0].extraData, (bool));\r\n        IUniswapExchange exchange;\r\n        if (isTokenBExchangeWrapper) {\r\n            exchange = IUniswapExchange(address(uint160(tokenToExchange[request.tokenB])));\r\n        } else {\r\n            exchange = IUniswapExchange(address(uint160(tokenToExchange[request.tokenS])));\r\n        }\r\n\r\n        (bool success, bytes memory result) = address(this).call(\r\n            abi.encodePacked(\r\n//                keccak256(\"performSwap(address,((address,bytes32,uint,uint,uint,address,bytes)[],address,address,address,uint,uint,uint),bool\"),\r\n                this.performSwap.selector,\r\n                abi.encode(exchange, request, isTokenBExchangeWrapper)\r\n            )\r\n        );\r\n        require(success, \"Uniswap MakerBroker: Uniswap matching failed\");\r\n        uint exchangeAmount = abi.decode(result, (uint));\r\n\r\n        if (request.tokenS == wethTokenAddress) {\r\n            // Orders on Dolomite require we use WETH instead of ETH, so we must convert it back\r\n            IWETH(wethTokenAddress).deposit.value(exchangeAmount)();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function performSwap(\r\n        IUniswapExchange exchange,\r\n        BrokerData.BrokerApprovalRequest memory request,\r\n        bool isTokenBExchangeWrapper\r\n    ) public returns (uint exchangeAmount) {\r\n        // This fn is public so we can get access to the #selector with type-safety.\r\n        require(msg.sender == address(this) || msg.sender == loopringDelegate, \"INVALID_SENDER\");\r\n\r\n        uint deadline = block.timestamp + 1;\r\n        if (request.tokenS == wethTokenAddress) {\r\n            exchangeAmount = exchange.tokenToEthSwapInput(\r\n                request.totalFillAmountB,\r\n                request.totalRequestedAmountS,\r\n                deadline\r\n            );\r\n        } else if (request.tokenB == wethTokenAddress) {\r\n            exchangeAmount = exchange.ethToTokenSwapInput.value(request.totalFillAmountB)(\r\n                request.totalRequestedAmountS,\r\n                deadline\r\n            );\r\n        } else {\r\n            // Pure token to token\r\n            address tokenToBuy;\r\n            if (isTokenBExchangeWrapper) {\r\n                request.tokenS;\r\n            } else {\r\n                request.tokenB;\r\n            }\r\n            exchangeAmount = exchange.tokenToTokenSwapInput(\r\n                request.totalFillAmountB,\r\n                request.totalRequestedAmountS,\r\n            /* minEthBoughtInWei */ 1, // We don't care about the token <-> ETH exchange rate as long as we get enough tokenB\r\n                deadline,\r\n                tokenToBuy\r\n            );\r\n        }\r\n\r\n        return exchangeAmount;\r\n    }\r\n\r\n    function onOrderFillReport(BrokerData.BrokerInterceptorReport memory fillReport) public {\r\n        // No op\r\n    }\r\n\r\n    /*\r\n     * Balance is unknown as it is entirely dependent on the offer in Uniswap being filled.\r\n     * Thus we send down a very large number to ensure the relay/matching engine believes\r\n     * orders from this broker have enough of a balance for trades to be filled.\r\n     */\r\n    function brokerBalanceOf(address owner, address tokenAddress) public view returns (uint) {\r\n        return uint(-1);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loopringDelegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"brokerBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct BrokerData.BrokerOrder[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalFillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRequestedAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRequestedFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BrokerData.BrokerApprovalRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"brokerRequestAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loopringDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"broker\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spentAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spentFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct BrokerData.BrokerInterceptorReport\",\"name\":\"fillReport\",\"type\":\"tuple\"}],\"name\":\"onOrderFillReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IUniswapExchange\",\"name\":\"exchange\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct BrokerData.BrokerOrder[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalFillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRequestedAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRequestedFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BrokerData.BrokerApprovalRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isTokenBExchangeWrapper\",\"type\":\"bool\"}],\"name\":\"performSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"exchangeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"setupExchange\",\"type\":\"bool\"}],\"name\":\"setupToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"setupExchanges\",\"type\":\"bool[]\"}],\"name\":\"setupTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToIsSetup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"contract IUniswapFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEthDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawEthDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapMakerBroker","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e2466deb9536a69bf8131ecd0c267ee41dd1cda0000000000000000000000000c0a47dfe034b400b47bdad5fecda2621de6c4d95000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"istanbul","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://289d0c7ea8ac3745c5ac408fb41c8c593c056ad8ac2427a2e4bdfba1f67f4df9"}]}