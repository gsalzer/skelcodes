{"status":"1","message":"OK","result":[{"SourceCode":"/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: EtherCollateralsUSD.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/EtherCollateralsUSD.sol\n* Docs: https://docs.synthetix.io/contracts/EtherCollateralsUSD\n*\n* Contract Dependencies: \n*\t- IAddressResolver\n*\t- IEtherCollateralsUSD\n*\t- MixinResolver\n*\t- Owned\n*\t- Pausable\n*\t- ReentrancyGuard\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    constructor() internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/AddressResolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            repository[names[i]] = destinations[i];\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/MixinResolver\ncontract MixinResolver is Owned {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    bytes32[] public resolverAddressesRequired;\n\n    uint public constant MAX_ADDRESSES_FROM_RESOLVER = 24;\n\n    constructor(address _resolver, bytes32[MAX_ADDRESSES_FROM_RESOLVER] memory _addressesToCache) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        for (uint i = 0; i < _addressesToCache.length; i++) {\n            if (_addressesToCache[i] != bytes32(0)) {\n                resolverAddressesRequired.push(_addressesToCache[i]);\n            } else {\n                // End early once an empty item is found - assumes there are no empty slots in\n                // _addressesToCache\n                break;\n            }\n        }\n        resolver = AddressResolver(_resolver);\n        // Do not sync the cache as addresses may not be in the resolver yet\n    }\n\n    /* ========== SETTERS ========== */\n    function setResolverAndSyncCache(AddressResolver _resolver) external onlyOwner {\n        resolver = _resolver;\n\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            bytes32 name = resolverAddressesRequired[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            addressCache[name] = resolver.requireAndGetAddress(name, \"Resolver missing target\");\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function requireAndGetAddress(bytes32 name, string memory reason) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    // Note: this could be made external in a utility contract if addressCache was made public\n    // (used for deployment)\n    function isResolverCached(AddressResolver _resolver) external view returns (bool) {\n        if (resolver != _resolver) {\n            return false;\n        }\n\n        // otherwise, check everything\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            bytes32 name = resolverAddressesRequired[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Note: can be made external into a utility contract (used for deployment)\n    function getResolverAddressesRequired()\n        external\n        view\n        returns (bytes32[MAX_ADDRESSES_FROM_RESOLVER] memory addressesRequired)\n    {\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            addressesRequired[i] = resolverAddressesRequired[i];\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n    function appendToAddressCache(bytes32 name) internal {\n        resolverAddressesRequired.push(name);\n        require(resolverAddressesRequired.length < MAX_ADDRESSES_FROM_RESOLVER, \"Max resolver cache size met\");\n        // Because this is designed to be called internally in constructors, we don't\n        // check the address exists already in the resolver\n        addressCache[name] = resolver.getAddress(name);\n    }\n}\n\n\ninterface IEtherCollateralsUSD {\n    // Views\n    function totalIssuedSynths() external view returns (uint256);\n\n    function totalLoansCreated() external view returns (uint256);\n\n    function totalOpenLoanCount() external view returns (uint256);\n\n    // Mutative functions\n    function openLoan(uint256 _loanAmount) external payable returns (uint256 loanID);\n\n    function closeLoan(uint256 loanID) external;\n\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external;\n\n    function depositCollateral(address account, uint256 loanID) external payable;\n\n    function withdrawCollateral(uint256 loanID, uint256 withdrawAmount) external;\n\n    function repayLoan(\n        address _loanCreatorsAddress,\n        uint256 _loanID,\n        uint256 _repayAmount\n    ) external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\n\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    // Restricted functions\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    // Restricted: used internally to Synthetix\n    function appendAccountIssuanceRecord(\n        address account,\n        uint lockedAmount,\n        uint debtEntryIndex\n    ) external;\n\n    function recordFeePaid(uint sUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/IExchangeRates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    struct InversePricing {\n        uint entryPoint;\n        uint upperLimit;\n        uint lowerLimit;\n        bool frozenAtUpperLimit;\n        bool frozenAtLowerLimit;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\n\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint value);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function inversePricing(bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint entryPoint,\n            uint upperLimit,\n            uint lowerLimit,\n            bool frozenAtUpperLimit,\n            bool frozenAtLowerLimit\n        );\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\n        external\n        view\n        returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    // Mutative functions\n    function freezeRate(bytes32 currencyKey) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// ETH Collateral v0.3 (sUSD)\n// https://docs.synthetix.io/contracts/EtherCollateralsUSD\ncontract EtherCollateralsUSD is Owned, Pausable, ReentrancyGuard, MixinResolver, IEtherCollateralsUSD {\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    bytes32 internal constant ETH = \"ETH\";\n\n    // ========== CONSTANTS ==========\n    uint256 internal constant ONE_THOUSAND = 1e18 * 1000;\n    uint256 internal constant ONE_HUNDRED = 1e18 * 100;\n\n    uint256 internal constant SECONDS_IN_A_YEAR = 31536000; // Common Year\n\n    // Where fees are pooled in sUSD.\n    address internal constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\n\n    uint256 internal constant ACCOUNT_LOAN_LIMIT_CAP = 1000;\n    bytes32 private constant sUSD = \"sUSD\";\n    bytes32 public constant COLLATERAL = \"ETH\";\n\n    // ========== SETTER STATE VARIABLES ==========\n\n    // The ratio of Collateral to synths issued\n    uint256 public collateralizationRatio = SafeDecimalMath.unit() * 150;\n\n    // If updated, all outstanding loans will pay this interest rate in on closure of the loan. Default 5%\n    uint256 public interestRate = (5 * SafeDecimalMath.unit()) / 100;\n    uint256 public interestPerSecond = interestRate.div(SECONDS_IN_A_YEAR);\n\n    // Minting fee for issuing the synths. Default 50 bips.\n    uint256 public issueFeeRate = (5 * SafeDecimalMath.unit()) / 1000;\n\n    // Maximum amount of sUSD that can be issued by the EtherCollateral contract. Default 10MM\n    uint256 public issueLimit = SafeDecimalMath.unit() * 10000000;\n\n    // Minimum amount of ETH to create loan preventing griefing and gas consumption. Min 1ETH\n    uint256 public minLoanCollateralSize = SafeDecimalMath.unit() * 1;\n\n    // Maximum number of loans an account can create\n    uint256 public accountLoanLimit = 50;\n\n    // If true then any wallet addres can close a loan not just the loan creator.\n    bool public loanLiquidationOpen = false;\n\n    // Time when remaining loans can be liquidated\n    uint256 public liquidationDeadline;\n\n    // Liquidation ratio when loans can be liquidated\n    uint256 public liquidationRatio = (150 * SafeDecimalMath.unit()) / 100; // 1.5 ratio\n\n    // Liquidation penalty when loans are liquidated. default 10%\n    uint256 public liquidationPenalty = SafeDecimalMath.unit() / 10;\n\n    // ========== STATE VARIABLES ==========\n\n    // The total number of synths issued by the collateral in this contract\n    uint256 public totalIssuedSynths;\n\n    // Total number of loans ever created\n    uint256 public totalLoansCreated;\n\n    // Total number of open loans\n    uint256 public totalOpenLoanCount;\n\n    // Synth loan storage struct\n    struct SynthLoanStruct {\n        //  Acccount that created the loan\n        address payable account;\n        //  Amount (in collateral token ) that they deposited\n        uint256 collateralAmount;\n        //  Amount (in synths) that they issued to borrow\n        uint256 loanAmount;\n        // Minting Fee\n        uint256 mintingFee;\n        // When the loan was created\n        uint256 timeCreated;\n        // ID for the loan\n        uint256 loanID;\n        // When the loan was paidback (closed)\n        uint256 timeClosed;\n        // Applicable Interest rate\n        uint256 loanInterestRate;\n        // interest amounts accrued\n        uint256 accruedInterest;\n        // last timestamp interest amounts accrued\n        uint40 lastInterestAccrued;\n    }\n\n    // Users Loans by address\n    mapping(address => SynthLoanStruct[]) public accountsSynthLoans;\n\n    // Account Open Loan Counter\n    mapping(address => uint256) public accountOpenLoanCounter;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_SYNTHSUSD = \"SynthsUSD\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n\n    bytes32[24] private addressesToCache = [CONTRACT_SYSTEMSTATUS, CONTRACT_SYNTHSUSD, CONTRACT_EXRATES, CONTRACT_FEEPOOL];\n\n    // ========== CONSTRUCTOR ==========\n    constructor(address _owner, address _resolver)\n        public\n        Owned(_owner)\n        Pausable()\n        MixinResolver(_resolver, addressesToCache)\n    {\n        liquidationDeadline = block.timestamp + 92 days; // Time before loans can be open for liquidation to end the trial contract\n    }\n\n    // ========== SETTERS ==========\n\n    function setCollateralizationRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= ONE_THOUSAND, \"Too high\");\n        require(ratio >= ONE_HUNDRED, \"Too low\");\n        collateralizationRatio = ratio;\n        emit CollateralizationRatioUpdated(ratio);\n    }\n\n    function setInterestRate(uint256 _interestRate) external onlyOwner {\n        require(_interestRate > SECONDS_IN_A_YEAR, \"Interest rate cannot be less that the SECONDS_IN_A_YEAR\");\n        require(_interestRate <= SafeDecimalMath.unit(), \"Interest cannot be more than 100% APR\");\n        interestRate = _interestRate;\n        interestPerSecond = _interestRate.div(SECONDS_IN_A_YEAR);\n        emit InterestRateUpdated(interestRate);\n    }\n\n    function setIssueFeeRate(uint256 _issueFeeRate) external onlyOwner {\n        issueFeeRate = _issueFeeRate;\n        emit IssueFeeRateUpdated(issueFeeRate);\n    }\n\n    function setIssueLimit(uint256 _issueLimit) external onlyOwner {\n        issueLimit = _issueLimit;\n        emit IssueLimitUpdated(issueLimit);\n    }\n\n    function setMinLoanCollateralSize(uint256 _minLoanCollateralSize) external onlyOwner {\n        minLoanCollateralSize = _minLoanCollateralSize;\n        emit MinLoanCollateralSizeUpdated(minLoanCollateralSize);\n    }\n\n    function setAccountLoanLimit(uint256 _loanLimit) external onlyOwner {\n        require(_loanLimit < ACCOUNT_LOAN_LIMIT_CAP, \"Owner cannot set higher than ACCOUNT_LOAN_LIMIT_CAP\");\n        accountLoanLimit = _loanLimit;\n        emit AccountLoanLimitUpdated(accountLoanLimit);\n    }\n\n    function setLoanLiquidationOpen(bool _loanLiquidationOpen) external onlyOwner {\n        require(block.timestamp > liquidationDeadline, \"Before liquidation deadline\");\n        loanLiquidationOpen = _loanLiquidationOpen;\n        emit LoanLiquidationOpenUpdated(loanLiquidationOpen);\n    }\n\n    function setLiquidationRatio(uint256 _liquidationRatio) external onlyOwner {\n        require(_liquidationRatio > SafeDecimalMath.unit(), \"Ratio less than 100%\");\n        liquidationRatio = _liquidationRatio;\n        emit LiquidationRatioUpdated(liquidationRatio);\n    }\n\n    // ========== PUBLIC VIEWS ==========\n\n    function getContractInfo()\n        external\n        view\n        returns (\n            uint256 _collateralizationRatio,\n            uint256 _issuanceRatio,\n            uint256 _interestRate,\n            uint256 _interestPerSecond,\n            uint256 _issueFeeRate,\n            uint256 _issueLimit,\n            uint256 _minLoanCollateralSize,\n            uint256 _totalIssuedSynths,\n            uint256 _totalLoansCreated,\n            uint256 _totalOpenLoanCount,\n            uint256 _ethBalance,\n            uint256 _liquidationDeadline,\n            bool _loanLiquidationOpen\n        )\n    {\n        _collateralizationRatio = collateralizationRatio;\n        _issuanceRatio = issuanceRatio();\n        _interestRate = interestRate;\n        _interestPerSecond = interestPerSecond;\n        _issueFeeRate = issueFeeRate;\n        _issueLimit = issueLimit;\n        _minLoanCollateralSize = minLoanCollateralSize;\n        _totalIssuedSynths = totalIssuedSynths;\n        _totalLoansCreated = totalLoansCreated;\n        _totalOpenLoanCount = totalOpenLoanCount;\n        _ethBalance = address(this).balance;\n        _liquidationDeadline = liquidationDeadline;\n        _loanLiquidationOpen = loanLiquidationOpen;\n    }\n\n    // returns value of 100 / collateralizationRatio.\n    // e.g. 100/150 = 0.6666666667\n    function issuanceRatio() public view returns (uint256) {\n        // this rounds so you get slightly more rather than slightly less\n        return ONE_HUNDRED.divideDecimalRound(collateralizationRatio);\n    }\n\n    function loanAmountFromCollateral(uint256 collateralAmount) public view returns (uint256) {\n        // a fraction more is issued due to rounding\n        return collateralAmount.multiplyDecimal(issuanceRatio()).multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n    }\n\n    function collateralAmountForLoan(uint256 loanAmount) external view returns (uint256) {\n        return\n            loanAmount\n                .multiplyDecimal(collateralizationRatio.divideDecimalRound(exchangeRates().rateForCurrency(ETH)))\n                .divideDecimalRound(ONE_HUNDRED);\n    }\n\n    // compound accrued interest with remaining loanAmount * (now - lastTimestampInterestPaid)\n    function currentInterestOnLoan(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        uint256 currentInterest = accruedInterestOnLoan(\n            synthLoan.loanAmount.add(synthLoan.accruedInterest),\n            _timeSinceInterestAccrual(synthLoan)\n        );\n        return synthLoan.accruedInterest.add(currentInterest);\n    }\n\n    function accruedInterestOnLoan(uint256 _loanAmount, uint256 _seconds) public view returns (uint256 interestAmount) {\n        // Simple interest calculated per second\n        // Interest = Principal * rate * time\n        interestAmount = _loanAmount.multiplyDecimalRound(interestPerSecond.mul(_seconds));\n    }\n\n    function totalFeesOnLoan(address _account, uint256 _loanID)\n        external\n        view\n        returns (uint256 interestAmount, uint256 mintingFee)\n    {\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        uint256 loanAmountWithAccruedInterest = synthLoan.loanAmount.add(synthLoan.accruedInterest);\n        interestAmount = synthLoan.accruedInterest.add(\n            accruedInterestOnLoan(loanAmountWithAccruedInterest, _timeSinceInterestAccrual(synthLoan))\n        );\n        mintingFee = synthLoan.mintingFee;\n    }\n\n    function getMintingFee(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        return synthLoan.mintingFee;\n    }\n\n    /**\n     * r = target issuance ratio\n     * D = debt balance\n     * V = Collateral\n     * P = liquidation penalty\n     * Calculates amount of synths = (D - V * r) / (1 - (1 + P) * r)\n     */\n    function calculateAmountToLiquidate(uint debtBalance, uint collateral) public view returns (uint) {\n        uint unit = SafeDecimalMath.unit();\n        uint ratio = liquidationRatio;\n\n        uint dividend = debtBalance.sub(collateral.divideDecimal(ratio));\n        uint divisor = unit.sub(unit.add(liquidationPenalty).divideDecimal(ratio));\n\n        return dividend.divideDecimal(divisor);\n    }\n\n    function openLoanIDsByAccount(address _account) external view returns (uint256[] memory) {\n        SynthLoanStruct[] memory synthLoans = accountsSynthLoans[_account];\n\n        uint256[] memory _openLoanIDs = new uint256[](synthLoans.length);\n        uint256 _counter = 0;\n\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].timeClosed == 0) {\n                _openLoanIDs[_counter] = synthLoans[i].loanID;\n                _counter++;\n            }\n        }\n        // Create the fixed size array to return\n        uint256[] memory _result = new uint256[](_counter);\n\n        // Copy loanIDs from dynamic array to fixed array\n        for (uint256 j = 0; j < _counter; j++) {\n            _result[j] = _openLoanIDs[j];\n        }\n        // Return an array with list of open Loan IDs\n        return _result;\n    }\n\n    function getLoan(address _account, uint256 _loanID)\n        external\n        view\n        returns (\n            address account,\n            uint256 collateralAmount,\n            uint256 loanAmount,\n            uint256 timeCreated,\n            uint256 loanID,\n            uint256 timeClosed,\n            uint256 accruedInterest,\n            uint256 totalFees\n        )\n    {\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n        account = synthLoan.account;\n        collateralAmount = synthLoan.collateralAmount;\n        loanAmount = synthLoan.loanAmount;\n        timeCreated = synthLoan.timeCreated;\n        loanID = synthLoan.loanID;\n        timeClosed = synthLoan.timeClosed;\n        accruedInterest = synthLoan.accruedInterest.add(\n            accruedInterestOnLoan(synthLoan.loanAmount.add(synthLoan.accruedInterest), _timeSinceInterestAccrual(synthLoan))\n        );\n        totalFees = accruedInterest.add(synthLoan.mintingFee);\n    }\n\n    function getLoanCollateralRatio(address _account, uint256 _loanID) external view returns (uint256 loanCollateralRatio) {\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n\n        (loanCollateralRatio, , ) = _loanCollateralRatio(synthLoan);\n    }\n\n    function _loanCollateralRatio(SynthLoanStruct memory _loan)\n        internal\n        view\n        returns (\n            uint256 loanCollateralRatio,\n            uint256 collateralValue,\n            uint256 interestAmount\n        )\n    {\n        // Any interest accrued prior is rolled up into loan amount\n        uint256 loanAmountWithAccruedInterest = _loan.loanAmount.add(_loan.accruedInterest);\n\n        interestAmount = accruedInterestOnLoan(loanAmountWithAccruedInterest, _timeSinceInterestAccrual(_loan));\n\n        collateralValue = _loan.collateralAmount.multiplyDecimal(exchangeRates().rateForCurrency(COLLATERAL));\n\n        loanCollateralRatio = collateralValue.divideDecimal(loanAmountWithAccruedInterest.add(interestAmount));\n    }\n\n    function timeSinceInterestAccrualOnLoan(address _account, uint256 _loanID) external view returns (uint256) {\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_account, _loanID);\n\n        return _timeSinceInterestAccrual(synthLoan);\n    }\n\n    // ========== PUBLIC FUNCTIONS ==========\n\n    function openLoan(uint256 _loanAmount)\n        external\n        payable\n        notPaused\n        nonReentrant\n        ETHRateNotInvalid\n        returns (uint256 loanID)\n    {\n        systemStatus().requireIssuanceActive();\n\n        // Require ETH sent to be greater than minLoanCollateralSize\n        require(\n            msg.value >= minLoanCollateralSize,\n            \"Not enough ETH to create this loan. Please see the minLoanCollateralSize\"\n        );\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Each account is limited to creating 50 (accountLoanLimit) loans\n        require(accountsSynthLoans[msg.sender].length < accountLoanLimit, \"Each account is limited to 50 loans\");\n\n        // Calculate issuance amount based on issuance ratio\n        uint256 maxLoanAmount = loanAmountFromCollateral(msg.value);\n\n        // Require requested _loanAmount to be less than maxLoanAmount\n        // Issuance ratio caps collateral to loan value at 150%\n        require(_loanAmount <= maxLoanAmount, \"Loan amount exceeds max borrowing power\");\n\n        uint256 mintingFee = _calculateMintingFee(_loanAmount);\n        uint256 loanAmountMinusFee = _loanAmount.sub(mintingFee);\n\n        // Require sUSD loan to mint does not exceed cap\n        require(totalIssuedSynths.add(_loanAmount) <= issueLimit, \"Loan Amount exceeds the supply cap.\");\n\n        // Get a Loan ID\n        loanID = _incrementTotalLoansCounter();\n\n        // Create Loan storage object\n        SynthLoanStruct memory synthLoan = SynthLoanStruct({\n            account: msg.sender,\n            collateralAmount: msg.value,\n            loanAmount: _loanAmount,\n            mintingFee: mintingFee,\n            timeCreated: block.timestamp,\n            loanID: loanID,\n            timeClosed: 0,\n            loanInterestRate: interestRate,\n            accruedInterest: 0,\n            lastInterestAccrued: 0\n        });\n\n        // Fee distribution. Mint the sUSD fees into the FeePool and record fees paid\n        if (mintingFee > 0) {\n            synthsUSD().issue(FEE_ADDRESS, mintingFee);\n            feePool().recordFeePaid(mintingFee);\n        }\n\n        // Record loan in mapping to account in an array of the accounts open loans\n        accountsSynthLoans[msg.sender].push(synthLoan);\n\n        // Increment totalIssuedSynths\n        totalIssuedSynths = totalIssuedSynths.add(_loanAmount);\n\n        // Issue the synth (less fee)\n        synthsUSD().issue(msg.sender, loanAmountMinusFee);\n\n        // Tell the Dapps a loan was created\n        emit LoanCreated(msg.sender, loanID, _loanAmount);\n    }\n\n    function closeLoan(uint256 loanID) external nonReentrant ETHRateNotInvalid {\n        _closeLoan(msg.sender, loanID, false);\n    }\n\n    // Add ETH collateral to an open loan\n    function depositCollateral(address account, uint256 loanID) external payable notPaused {\n        require(msg.value > 0, \"Deposit amount must be greater than 0\");\n\n        systemStatus().requireIssuanceActive();\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(account, loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(synthLoan);\n\n        uint256 totalCollateral = synthLoan.collateralAmount.add(msg.value);\n\n        _updateLoanCollateral(synthLoan, totalCollateral);\n\n        // Tell the Dapps collateral was added to loan\n        emit CollateralDeposited(account, loanID, msg.value, totalCollateral);\n    }\n\n    // Withdraw ETH collateral from an open loan\n    function withdrawCollateral(uint256 loanID, uint256 withdrawAmount) external notPaused nonReentrant ETHRateNotInvalid {\n        require(withdrawAmount > 0, \"Amount to withdraw must be greater than 0\");\n\n        systemStatus().requireIssuanceActive();\n\n        // Require loanLiquidationOpen to be false or we are in liquidation phase\n        require(loanLiquidationOpen == false, \"Loans are now being liquidated\");\n\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(msg.sender, loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(synthLoan);\n\n        uint256 collateralAfter = synthLoan.collateralAmount.sub(withdrawAmount);\n\n        SynthLoanStruct memory loanAfter = _updateLoanCollateral(synthLoan, collateralAfter);\n\n        // require collateral ratio after to be above the liquidation ratio\n        (uint256 collateralRatioAfter, , ) = _loanCollateralRatio(loanAfter);\n\n        require(collateralRatioAfter > liquidationRatio, \"Collateral ratio below liquidation after withdraw\");\n\n        // transfer ETH to msg.sender\n        msg.sender.transfer(withdrawAmount);\n\n        // Tell the Dapps collateral was added to loan\n        emit CollateralWithdrawn(msg.sender, loanID, withdrawAmount, loanAfter.collateralAmount);\n    }\n\n    function repayLoan(\n        address _loanCreatorsAddress,\n        uint256 _loanID,\n        uint256 _repayAmount\n    ) external ETHRateNotInvalid {\n        systemStatus().requireSystemActive();\n\n        // check msg.sender has sufficient sUSD to pay\n        require(IERC20(address(synthsUSD())).balanceOf(msg.sender) >= _repayAmount, \"Not enough sUSD balance\");\n\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_loanCreatorsAddress, _loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(synthLoan);\n\n        // Any interest accrued prior is rolled up into loan amount\n        uint256 loanAmountWithAccruedInterest = synthLoan.loanAmount.add(synthLoan.accruedInterest);\n        uint256 interestAmount = accruedInterestOnLoan(loanAmountWithAccruedInterest, _timeSinceInterestAccrual(synthLoan));\n\n        // repay any accrued interests first\n        // and repay principal loan amount with remaining amounts\n        uint256 accruedInterest = synthLoan.accruedInterest.add(interestAmount);\n\n        (\n            uint256 interestPaid,\n            uint256 loanAmountPaid,\n            uint256 accruedInterestAfter,\n            uint256 loanAmountAfter\n        ) = _splitInterestLoanPayment(_repayAmount, accruedInterest, synthLoan.loanAmount);\n\n        // burn sUSD from msg.sender for repaid amount\n        synthsUSD().burn(msg.sender, _repayAmount);\n\n        // Send interest paid to fee pool and record loan amount paid\n        _processInterestAndLoanPayment(interestPaid, loanAmountPaid);\n\n        // update loan with new total loan amount, record accrued interests\n        _updateLoan(synthLoan, loanAmountAfter, accruedInterestAfter, block.timestamp);\n\n        emit LoanRepaid(_loanCreatorsAddress, _loanID, _repayAmount, loanAmountAfter);\n    }\n\n    // Liquidate loans at or below issuance ratio\n    function liquidateLoan(\n        address _loanCreatorsAddress,\n        uint256 _loanID,\n        uint256 _debtToCover\n    ) external nonReentrant ETHRateNotInvalid {\n        systemStatus().requireSystemActive();\n\n        // check msg.sender (liquidator's wallet) has sufficient sUSD\n        require(IERC20(address(synthsUSD())).balanceOf(msg.sender) >= _debtToCover, \"Not enough sUSD balance\");\n\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(_loanCreatorsAddress, _loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(synthLoan);\n\n        (uint256 collateralRatio, uint256 collateralValue, uint256 interestAmount) = _loanCollateralRatio(synthLoan);\n\n        require(collateralRatio < liquidationRatio, \"Collateral ratio above liquidation ratio\");\n\n        // calculate amount to liquidate to fix ratio including accrued interest\n        uint256 liquidationAmount = calculateAmountToLiquidate(\n            synthLoan.loanAmount.add(synthLoan.accruedInterest).add(interestAmount),\n            collateralValue\n        );\n\n        // cap debt to liquidate\n        uint256 amountToLiquidate = liquidationAmount < _debtToCover ? liquidationAmount : _debtToCover;\n\n        // burn sUSD from msg.sender for amount to liquidate\n        synthsUSD().burn(msg.sender, amountToLiquidate);\n\n        (uint256 interestPaid, uint256 loanAmountPaid, uint256 accruedInterestAfter, ) = _splitInterestLoanPayment(\n            amountToLiquidate,\n            synthLoan.accruedInterest.add(interestAmount),\n            synthLoan.loanAmount\n        );\n\n        // Send interests paid to fee pool and record loan amount paid\n        _processInterestAndLoanPayment(interestPaid, loanAmountPaid);\n\n        // Collateral value to redeem\n        uint256 collateralRedeemed = exchangeRates().effectiveValue(sUSD, amountToLiquidate, COLLATERAL);\n\n        // Add penalty\n        uint256 totalCollateralLiquidated = collateralRedeemed.multiplyDecimal(\n            SafeDecimalMath.unit().add(liquidationPenalty)\n        );\n\n        // update remaining loanAmount less amount paid and update accrued interests less interest paid\n        _updateLoan(synthLoan, synthLoan.loanAmount.sub(loanAmountPaid), accruedInterestAfter, block.timestamp);\n\n        // update remaining collateral on loan\n        _updateLoanCollateral(synthLoan, synthLoan.collateralAmount.sub(totalCollateralLiquidated));\n\n        // Send liquidated ETH collateral to msg.sender\n        msg.sender.transfer(totalCollateralLiquidated);\n\n        // emit loan liquidation event\n        emit LoanPartiallyLiquidated(\n            _loanCreatorsAddress,\n            _loanID,\n            msg.sender,\n            amountToLiquidate,\n            totalCollateralLiquidated\n        );\n    }\n\n    function _splitInterestLoanPayment(\n        uint256 _paymentAmount,\n        uint256 _accruedInterest,\n        uint256 _loanAmount\n    )\n        internal\n        pure\n        returns (\n            uint256 interestPaid,\n            uint256 loanAmountPaid,\n            uint256 accruedInterestAfter,\n            uint256 loanAmountAfter\n        )\n    {\n        uint256 remainingPayment = _paymentAmount;\n\n        // repay any accrued interests first\n        accruedInterestAfter = _accruedInterest;\n        if (remainingPayment > 0 && _accruedInterest > 0) {\n            // Max repay is the accruedInterest amount\n            interestPaid = remainingPayment > _accruedInterest ? _accruedInterest : remainingPayment;\n            accruedInterestAfter = accruedInterestAfter.sub(interestPaid);\n            remainingPayment = remainingPayment.sub(interestPaid);\n        }\n\n        // Remaining amounts - pay down loan amount\n        loanAmountAfter = _loanAmount;\n        if (remainingPayment > 0) {\n            loanAmountAfter = loanAmountAfter.sub(remainingPayment);\n            loanAmountPaid = remainingPayment;\n        }\n    }\n\n    function _processInterestAndLoanPayment(uint256 interestPaid, uint256 loanAmountPaid) internal {\n        // Fee distribution. Mint the sUSD fees into the FeePool and record fees paid\n        if (interestPaid > 0) {\n            synthsUSD().issue(FEE_ADDRESS, interestPaid);\n            feePool().recordFeePaid(interestPaid);\n        }\n\n        // Decrement totalIssuedSynths\n        if (loanAmountPaid > 0) {\n            totalIssuedSynths = totalIssuedSynths.sub(loanAmountPaid);\n        }\n    }\n\n    // Liquidation of an open loan available for anyone\n    function liquidateUnclosedLoan(address _loanCreatorsAddress, uint256 _loanID) external nonReentrant ETHRateNotInvalid {\n        require(loanLiquidationOpen, \"Liquidation is not open\");\n        // Close the creators loan and send collateral to the closer.\n        _closeLoan(_loanCreatorsAddress, _loanID, true);\n        // Tell the Dapps this loan was liquidated\n        emit LoanLiquidated(_loanCreatorsAddress, _loanID, msg.sender);\n    }\n\n    // ========== PRIVATE FUNCTIONS ==========\n\n    function _closeLoan(\n        address account,\n        uint256 loanID,\n        bool liquidation\n    ) private {\n        systemStatus().requireIssuanceActive();\n\n        // Get the loan from storage\n        SynthLoanStruct memory synthLoan = _getLoanFromStorage(account, loanID);\n\n        // Check loan exists and is open\n        _checkLoanIsOpen(synthLoan);\n\n        // Calculate and deduct accrued interest (5%) for fee pool\n        // Accrued interests (captured in loanAmount) + new interests\n        uint256 interestAmount = accruedInterestOnLoan(\n            synthLoan.loanAmount.add(synthLoan.accruedInterest),\n            _timeSinceInterestAccrual(synthLoan)\n        );\n        uint256 repayAmount = synthLoan.loanAmount.add(interestAmount);\n\n        uint256 totalAccruedInterest = synthLoan.accruedInterest.add(interestAmount);\n\n        require(\n            IERC20(address(synthsUSD())).balanceOf(msg.sender) >= repayAmount,\n            \"You do not have the required Synth balance to close this loan.\"\n        );\n\n        // Record loan as closed\n        _recordLoanClosure(synthLoan);\n\n        // Decrement totalIssuedSynths\n        // subtract the accrued interest from the loanAmount\n        totalIssuedSynths = totalIssuedSynths.sub(synthLoan.loanAmount.sub(synthLoan.accruedInterest));\n\n        // Burn all Synths issued for the loan + the fees\n        synthsUSD().burn(msg.sender, repayAmount);\n\n        // Fee distribution. Mint the sUSD fees into the FeePool and record fees paid\n        synthsUSD().issue(FEE_ADDRESS, totalAccruedInterest);\n        feePool().recordFeePaid(totalAccruedInterest);\n\n        uint256 remainingCollateral = synthLoan.collateralAmount;\n\n        if (liquidation) {\n            // Send liquidator redeemed collateral + 10% penalty\n            uint256 collateralRedeemed = exchangeRates().effectiveValue(sUSD, repayAmount, COLLATERAL);\n\n            // add penalty\n            uint256 totalCollateralLiquidated = collateralRedeemed.multiplyDecimal(\n                SafeDecimalMath.unit().add(liquidationPenalty)\n            );\n\n            // ensure remaining ETH collateral sufficient to cover collateral liquidated\n            // will revert if the liquidated collateral + penalty is more than remaining collateral\n            remainingCollateral = remainingCollateral.sub(totalCollateralLiquidated);\n\n            // Send liquidator CollateralLiquidated\n            msg.sender.transfer(totalCollateralLiquidated);\n        }\n\n        // Send remaining collateral to loan creator\n        synthLoan.account.transfer(remainingCollateral);\n\n        // Tell the Dapps\n        emit LoanClosed(account, loanID, totalAccruedInterest);\n    }\n\n    function _getLoanFromStorage(address account, uint256 loanID) private view returns (SynthLoanStruct memory) {\n        SynthLoanStruct[] memory synthLoans = accountsSynthLoans[account];\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].loanID == loanID) {\n                return synthLoans[i];\n            }\n        }\n    }\n\n    function _updateLoan(\n        SynthLoanStruct memory _synthLoan,\n        uint256 _newLoanAmount,\n        uint256 _newAccruedInterest,\n        uint256 _lastInterestAccrued\n    ) private {\n        // Get storage pointer to the accounts array of loans\n        SynthLoanStruct[] storage synthLoans = accountsSynthLoans[_synthLoan.account];\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].loanID == _synthLoan.loanID) {\n                synthLoans[i].loanAmount = _newLoanAmount;\n                synthLoans[i].accruedInterest = _newAccruedInterest;\n                synthLoans[i].lastInterestAccrued = uint40(_lastInterestAccrued);\n            }\n        }\n    }\n\n    function _updateLoanCollateral(SynthLoanStruct memory _synthLoan, uint256 _newCollateralAmount)\n        private\n        returns (SynthLoanStruct memory)\n    {\n        // Get storage pointer to the accounts array of loans\n        SynthLoanStruct[] storage synthLoans = accountsSynthLoans[_synthLoan.account];\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].loanID == _synthLoan.loanID) {\n                synthLoans[i].collateralAmount = _newCollateralAmount;\n                return synthLoans[i];\n            }\n        }\n    }\n\n    function _recordLoanClosure(SynthLoanStruct memory synthLoan) private {\n        // Get storage pointer to the accounts array of loans\n        SynthLoanStruct[] storage synthLoans = accountsSynthLoans[synthLoan.account];\n        for (uint256 i = 0; i < synthLoans.length; i++) {\n            if (synthLoans[i].loanID == synthLoan.loanID) {\n                // Record the time the loan was closed\n                synthLoans[i].timeClosed = block.timestamp;\n            }\n        }\n\n        // Reduce Total Open Loans Count\n        totalOpenLoanCount = totalOpenLoanCount.sub(1);\n    }\n\n    function _incrementTotalLoansCounter() private returns (uint256) {\n        // Increase the total Open loan count\n        totalOpenLoanCount = totalOpenLoanCount.add(1);\n        // Increase the total Loans Created count\n        totalLoansCreated = totalLoansCreated.add(1);\n        // Return total count to be used as a unique ID.\n        return totalLoansCreated;\n    }\n\n    function _calculateMintingFee(uint256 _loanAmount) private view returns (uint256 mintingFee) {\n        mintingFee = _loanAmount.multiplyDecimalRound(issueFeeRate);\n    }\n\n    function _timeSinceInterestAccrual(SynthLoanStruct memory _synthLoan) private view returns (uint256 timeSinceAccrual) {\n        // The last interest accrued timestamp for the loan\n        // If lastInterestAccrued timestamp is not set (0), use loan timeCreated\n        uint256 lastInterestAccrual = _synthLoan.lastInterestAccrued > 0\n            ? uint256(_synthLoan.lastInterestAccrued)\n            : _synthLoan.timeCreated;\n\n        // diff between last interested accrued and now\n        // use loan's timeClosed if loan is closed\n        timeSinceAccrual = _synthLoan.timeClosed > 0\n            ? _synthLoan.timeClosed.sub(lastInterestAccrual)\n            : block.timestamp.sub(lastInterestAccrual);\n    }\n\n    function _checkLoanIsOpen(SynthLoanStruct memory _synthLoan) internal pure {\n        require(_synthLoan.loanID > 0, \"Loan does not exist\");\n        require(_synthLoan.timeClosed == 0, \"Loan already closed\");\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS, \"Missing SystemStatus address\"));\n    }\n\n    function synthsUSD() internal view returns (ISynth) {\n        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD, \"Missing SynthsUSD address\"));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES, \"Missing ExchangeRates address\"));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL, \"Missing FeePool address\"));\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier ETHRateNotInvalid() {\n        require(!exchangeRates().rateIsInvalid(COLLATERAL), \"Blocked as ETH rate is invalid\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n\n    event CollateralizationRatioUpdated(uint256 ratio);\n    event LiquidationRatioUpdated(uint256 ratio);\n    event InterestRateUpdated(uint256 interestRate);\n    event IssueFeeRateUpdated(uint256 issueFeeRate);\n    event IssueLimitUpdated(uint256 issueLimit);\n    event MinLoanCollateralSizeUpdated(uint256 minLoanCollateralSize);\n    event AccountLoanLimitUpdated(uint256 loanLimit);\n    event LoanLiquidationOpenUpdated(bool loanLiquidationOpen);\n    event LoanCreated(address indexed account, uint256 loanID, uint256 amount);\n    event LoanClosed(address indexed account, uint256 loanID, uint256 feesPaid);\n    event LoanLiquidated(address indexed account, uint256 loanID, address liquidator);\n    event LoanPartiallyLiquidated(\n        address indexed account,\n        uint256 loanID,\n        address liquidator,\n        uint256 liquidatedAmount,\n        uint256 liquidatedCollateral\n    );\n    event CollateralDeposited(address indexed account, uint256 loanID, uint256 collateralAmount, uint256 collateralAfter);\n    event CollateralWithdrawn(address indexed account, uint256 loanID, uint256 amountWithdrawn, uint256 collateralAfter);\n    event LoanRepaid(address indexed account, uint256 loanID, uint256 repaidAmount, uint256 newLoanAmount);\n}\n\n    ","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanLimit\",\"type\":\"uint256\"}],\"name\":\"AccountLoanLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAfter\",\"type\":\"uint256\"}],\"name\":\"CollateralDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAfter\",\"type\":\"uint256\"}],\"name\":\"CollateralWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"CollateralizationRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"}],\"name\":\"InterestRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"IssueFeeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issueLimit\",\"type\":\"uint256\"}],\"name\":\"IssueLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"LiquidationRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesPaid\",\"type\":\"uint256\"}],\"name\":\"LoanClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LoanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"LoanLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"LoanLiquidationOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatedCollateral\",\"type\":\"uint256\"}],\"name\":\"LoanPartiallyLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repaidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLoanAmount\",\"type\":\"uint256\"}],\"name\":\"LoanRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLoanCollateralSize\",\"type\":\"uint256\"}],\"name\":\"MinLoanCollateralSizeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ADDRESSES_FROM_RESOLVER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountLoanLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountOpenLoanCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsSynthLoans\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"lastInterestAccrued\",\"type\":\"uint40\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"accruedInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"debtBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"calculateAmountToLiquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"closeLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"}],\"name\":\"collateralAmountForLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"currentInterestOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralizationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issuanceRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minLoanCollateralSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalIssuedSynths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLoansCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalOpenLoanCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getLoan\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeClosed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getLoanCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanCollateralRatio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"getMintingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[24]\",\"name\":\"addressesRequired\",\"type\":\"bytes32[24]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtToCover\",\"type\":\"uint256\"}],\"name\":\"liquidateLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"liquidateUnclosedLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"loanAmountFromCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanLiquidationOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minLoanCollateralSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"}],\"name\":\"openLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"openLoanIDsByAccount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanCreatorsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanLimit\",\"type\":\"uint256\"}],\"name\":\"setAccountLoanLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"setCollateralizationRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueFeeRate\",\"type\":\"uint256\"}],\"name\":\"setIssueFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_issueLimit\",\"type\":\"uint256\"}],\"name\":\"setIssueLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidationRatio\",\"type\":\"uint256\"}],\"name\":\"setLiquidationRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_loanLiquidationOpen\",\"type\":\"bool\"}],\"name\":\"setLoanLiquidationOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minLoanCollateralSize\",\"type\":\"uint256\"}],\"name\":\"setMinLoanCollateralSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setResolverAndSyncCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"timeSinceInterestAccrualOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanID\",\"type\":\"uint256\"}],\"name\":\"totalFeesOnLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintingFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuedSynths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLoansCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOpenLoanCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherCollateralsUSD","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000de910777c787903f78c89e7a0bf7f4c435cbb1fe00000000000000000000000061166014e3f04e40c953fe4eab9d9e40863c83ae","EVMVersion":"Default","Library":"SafeDecimalMath:84d626b2bb4d0f064067e4bf80fce7055d8f3e7b","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}