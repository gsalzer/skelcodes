{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-06-28\r\n*/\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IMasterAware.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface IMasterAware {\r\n\r\n  function changeDependentContractAddress() external;\r\n\r\n  function changeMasterAddress(address _masterAddress) external;\r\n}\r\n\r\n// File: contracts/interfaces/INXMMaster.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface INXMMaster {\r\n\r\n  function delegateCallBack(bytes32 myid) external;\r\n\r\n  function masterInitialized() external view returns (bool);\r\n\r\n  function isInternal(address _add) external view returns (bool);\r\n\r\n  function isPause() external view returns (bool check);\r\n\r\n  function isOwner(address _add) external view returns (bool);\r\n\r\n  function isMember(address _add) external view returns (bool);\r\n\r\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\r\n\r\n  function updatePauseTime(uint _time) external;\r\n\r\n  function dAppLocker() external view returns (address _add);\r\n\r\n  function dAppToken() external view returns (address _add);\r\n\r\n  function tokenAddress() external view returns (address);\r\n\r\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\r\n}\r\n\r\n// File: contracts/abstract/MasterAware.sol\r\n\r\n/*\r\n    Copyright (C) 2020 NexusMutual.io\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/\r\n*/\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\ncontract MasterAware is IMasterAware {\r\n\r\n  INXMMaster public master;\r\n\r\n  modifier onlyMember {\r\n    require(master.isMember(msg.sender), \"Caller is not a member\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyInternal {\r\n    require(master.isInternal(msg.sender), \"Caller is not an internal contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyMaster {\r\n    if (address(master) != address(0)) {\r\n      require(address(master) == msg.sender, \"Not master\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyGovernance {\r\n    require(\r\n      master.checkIsAuthToGoverned(msg.sender),\r\n      \"Caller is not authorized to govern\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused {\r\n    require(master.isPause(), \"System is not paused\");\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused {\r\n    require(!master.isPause(), \"System is paused\");\r\n    _;\r\n  }\r\n\r\n  function changeMasterAddress(address masterAddress) public onlyMaster {\r\n    master = INXMMaster(masterAddress);\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/abstract/NXMToken.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n/*\r\n * This file and directory exists because interface inheritance is not allowed in solidity 0.5\r\n * This was implemented in solidity > 0.6.1\r\n */\r\n\r\ncontract NXMToken is IERC20 {\r\n\r\n  function burn(uint256 amount) public returns (bool);\r\n\r\n  function burnFrom(address from, uint256 value) public returns (bool);\r\n\r\n  function mint(address account, uint256 amount) public;\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface ITokenController {\r\n\r\n  function mint(address _member, uint256 _amount) external;\r\n  function addToWhitelist(address _member) external;\r\n\r\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\r\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\r\n\r\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/interfaces/IMemberRoles.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface IMemberRoles {\r\n\r\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\r\n\r\n  function memberAtIndex(uint _memberRoleId, uint index) external returns (address, bool);\r\n\r\n  function membersLength(uint _memberRoleId) external returns (uint);\r\n}\r\n\r\n// File: contracts/interfaces/ITokenFunctions.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface ITokenFunctions {\r\n    function _deprecated_unlockableBeforeBurningAndCanBurn(\r\n        address stakerAdd,\r\n        address stakedAdd,\r\n        uint stakerIndex\r\n    )\r\n    external\r\n    view\r\n    returns\r\n    (uint amount, uint canBurn);\r\n\r\n    function _deprecated_getStakerUnlockableTokensOnSmartContract (\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n    external\r\n    view\r\n    returns\r\n    (uint amount);\r\n}\r\n\r\n// File: contracts/interfaces/ITokenData.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface ITokenData {\r\n\r\n    function members(uint _memberRoleId) external view returns(uint, address[] memory memberArray);\r\n\r\n    function getStakerStakedContractLength(\r\n        address _stakerAddress\r\n    )\r\n    external\r\n    view\r\n    returns (uint length);\r\n\r\n    function getStakerStakedContractByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n    external\r\n    view\r\n    returns (address stakedContractAddress);\r\n\r\n    function getStakerStakedContractIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n    external\r\n    view\r\n    returns (uint scIndex);\r\n\r\n    function pushBurnedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    ) external;\r\n\r\n    struct Stake {\r\n        address stakedContractAddress;\r\n        uint stakedContractIndex;\r\n        uint dateAdd;\r\n        uint stakeAmount;\r\n        uint unlockedAmount;\r\n        uint burnedAmount;\r\n        uint unLockableBeforeLastBurn;\r\n    }\r\n\r\n    function scValidDays() external view returns (uint);\r\n    function stakerStakedContracts(\r\n        address staker,\r\n        uint index)\r\n    external\r\n    view\r\n    returns (address,uint256,uint256,uint256, uint256,uint256,uint256);\r\n\r\n    /**\r\n     * @dev to get the staker's unlocked tokens which were staked\r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return amount\r\n     */\r\n    function getStakerUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n    external\r\n    view\r\n    returns (uint amount);\r\n\r\n\r\n    function lastCompletedStakeCommission(address _stakerAddress) external view returns (uint);\r\n\r\n    function setUnlockableBeforeLastBurnTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    ) external;\r\n\r\n    function pushUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    ) external;\r\n\r\n\r\n    function getStakerTotalEarnedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n    external\r\n    view\r\n    returns (uint totalCommissionEarned);\r\n\r\n    function getStakerTotalReedmedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n    external\r\n    view\r\n    returns(uint totalCommissionRedeemed);\r\n}\r\n\r\n// File: contracts/interfaces/IClaimsReward.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface IClaimsReward {\r\n\r\n  function _claimStakeCommission(uint _records, address _user) external;\r\n}\r\n\r\n// File: contracts/PooledStaking.sol\r\n\r\n/*\r\n    Copyright (C) 2020 NexusMutual.io\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/\r\n*/\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PooledStaking is MasterAware {\r\n  using SafeMath for uint;\r\n\r\n  /* Data types */\r\n\r\n  struct Staker {\r\n    uint deposit; // total amount of deposit nxm\r\n    uint reward; // total amount that is ready to be claimed\r\n    address[] contracts; // list of contracts the staker has staked on\r\n\r\n    // staked amounts for each contract\r\n    mapping(address => uint) stakes;\r\n\r\n    // amount pending to be subtracted after all unstake requests will be processed\r\n    mapping(address => uint) pendingUnstakeRequestsTotal;\r\n\r\n    // flag to indicate the presence of this staker in the array of stakers of each contract\r\n    mapping(address => bool) isInContractStakers;\r\n  }\r\n\r\n  struct Burn {\r\n    uint amount;\r\n    uint burnedAt;\r\n    address contractAddress;\r\n  }\r\n\r\n  struct Reward {\r\n    uint amount;\r\n    uint rewardedAt;\r\n    address contractAddress;\r\n  }\r\n\r\n  struct UnstakeRequest {\r\n    uint amount;\r\n    uint unstakeAt;\r\n    address contractAddress;\r\n    address stakerAddress;\r\n    uint next; // id of the next unstake request in the linked list\r\n  }\r\n\r\n  /* Events */\r\n\r\n  // deposits\r\n  event Deposited(address indexed staker, uint amount);\r\n  event Withdrawn(address indexed staker, uint amount);\r\n\r\n  // stakes\r\n  event Staked(address indexed contractAddress, address indexed staker, uint amount);\r\n  event UnstakeRequested(address indexed contractAddress, address indexed staker, uint amount, uint unstakeAt);\r\n  event Unstaked(address indexed contractAddress, address indexed staker, uint amount);\r\n\r\n  // burns\r\n  event BurnRequested(address indexed contractAddress, uint amount);\r\n  event Burned(address indexed contractAddress, uint amount, uint contractStakeBeforeBurn);\r\n\r\n  // rewards\r\n  event RewardRequested(address indexed contractAddress, uint amount);\r\n  event Rewarded(address indexed contractAddress, uint amount, uint contractStake);\r\n  event RewardWithdrawn(address indexed staker, uint amount);\r\n\r\n  // pending actions processing\r\n  event PendingActionsProcessed(bool finished);\r\n\r\n  /* Storage variables */\r\n\r\n  bool public initialized;\r\n\r\n  NXMToken public token;\r\n  ITokenController public tokenController;\r\n\r\n  uint public MIN_STAKE;         // Minimum allowed stake per contract\r\n  uint public MAX_EXPOSURE;      // Stakes sum must be less than the deposit amount times this\r\n  uint public MIN_UNSTAKE;       // Forbid unstake of small amounts to prevent spam\r\n  uint public UNSTAKE_LOCK_TIME; // Lock period in seconds before unstaking takes place\r\n\r\n  mapping(address => Staker) stakers;     // stakerAddress => Staker\r\n\r\n  // temporary variables\r\n  uint contractStaked;   // used when processing burns and rewards\r\n  uint contractBurned;   // used when processing burns\r\n  uint contractRewarded; // used when processing rewards\r\n\r\n  // list of stakers for all contracts\r\n  mapping(address => address[]) contractStakers;\r\n\r\n  // there can be only one pending burn\r\n  Burn public burn;\r\n\r\n  mapping(uint => Reward) public rewards; // reward id => Reward\r\n  uint public firstReward;\r\n  uint public lastRewardId;\r\n\r\n  mapping(uint => UnstakeRequest) public unstakeRequests; // unstake id => UnstakeRequest\r\n  // firstUnstakeRequest is stored at unstakeRequests[0].next\r\n  uint public lastUnstakeRequestId;\r\n\r\n  uint public processedToStakerIndex; // we processed the action up this staker\r\n  bool public isContractStakeCalculated; // flag to indicate whether staked amount is up to date or not\r\n\r\n  /* Modifiers */\r\n\r\n  modifier noPendingActions {\r\n    require(!hasPendingActions(), 'Unable to execute request with unprocessed actions');\r\n    _;\r\n  }\r\n\r\n  modifier noPendingBurns {\r\n    require(!hasPendingBurns(), 'Unable to execute request with unprocessed burns');\r\n    _;\r\n  }\r\n\r\n  modifier noPendingUnstakeRequests {\r\n    require(!hasPendingUnstakeRequests(), 'Unable to execute request with unprocessed unstake requests');\r\n    _;\r\n  }\r\n\r\n  modifier noPendingRewards {\r\n    require(!hasPendingRewards(), 'Unable to execute request with unprocessed rewards');\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPausedAndInitialized {\r\n    require(!master.isPause(), \"System is paused\");\r\n    require(initialized, \"Contract is not initialized\");\r\n    _;\r\n  }\r\n\r\n  /* Getters and view functions */\r\n\r\n  function contractStakerCount(address contractAddress) external view returns (uint) {\r\n    return contractStakers[contractAddress].length;\r\n  }\r\n\r\n  function contractStakerAtIndex(address contractAddress, uint stakerIndex) external view returns (address) {\r\n    return contractStakers[contractAddress][stakerIndex];\r\n  }\r\n\r\n  function contractStakersArray(address contractAddress) external view returns (address[] memory _stakers) {\r\n    return contractStakers[contractAddress];\r\n  }\r\n\r\n  function contractStake(address contractAddress) public view returns (uint) {\r\n\r\n    address[] storage _stakers = contractStakers[contractAddress];\r\n    uint stakerCount = _stakers.length;\r\n    uint stakedOnContract;\r\n\r\n    for (uint i = 0; i < stakerCount; i++) {\r\n      Staker storage staker = stakers[_stakers[i]];\r\n      uint deposit = staker.deposit;\r\n      uint stake = staker.stakes[contractAddress];\r\n\r\n      // add the minimum of the two\r\n      stake = deposit < stake ? deposit : stake;\r\n      stakedOnContract = stakedOnContract.add(stake);\r\n    }\r\n\r\n    return stakedOnContract;\r\n  }\r\n\r\n  function stakerContractCount(address staker) external view returns (uint) {\r\n    return stakers[staker].contracts.length;\r\n  }\r\n\r\n  function stakerContractAtIndex(address staker, uint contractIndex) external view returns (address) {\r\n    return stakers[staker].contracts[contractIndex];\r\n  }\r\n\r\n  function stakerContractsArray(address staker) external view returns (address[] memory) {\r\n    return stakers[staker].contracts;\r\n  }\r\n\r\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint) {\r\n    uint stake = stakers[staker].stakes[contractAddress];\r\n    uint deposit = stakers[staker].deposit;\r\n    return stake < deposit ? stake : deposit;\r\n  }\r\n\r\n  function stakerContractPendingUnstakeTotal(address staker, address contractAddress) external view returns (uint) {\r\n    return stakers[staker].pendingUnstakeRequestsTotal[contractAddress];\r\n  }\r\n\r\n  function stakerReward(address staker) external view returns (uint) {\r\n    return stakers[staker].reward;\r\n  }\r\n\r\n  function stakerDeposit(address staker) external view returns (uint) {\r\n    return stakers[staker].deposit;\r\n  }\r\n\r\n  function stakerMaxWithdrawable(address stakerAddress) public view returns (uint) {\r\n\r\n    Staker storage staker = stakers[stakerAddress];\r\n    uint deposit = staker.deposit;\r\n    uint totalStaked;\r\n    uint maxStake;\r\n\r\n    for (uint i = 0; i < staker.contracts.length; i++) {\r\n\r\n      address contractAddress = staker.contracts[i];\r\n      uint initialStake = staker.stakes[contractAddress];\r\n      uint stake = deposit < initialStake ? deposit : initialStake;\r\n      totalStaked = totalStaked.add(stake);\r\n\r\n      if (stake > maxStake) {\r\n        maxStake = stake;\r\n      }\r\n    }\r\n\r\n    uint minRequired = totalStaked.div(MAX_EXPOSURE);\r\n    uint locked = maxStake > minRequired ? maxStake : minRequired;\r\n\r\n    return deposit.sub(locked);\r\n  }\r\n\r\n  function unstakeRequestAtIndex(uint unstakeRequestId) external view returns (\r\n    uint amount, uint unstakeAt, address contractAddress, address stakerAddress, uint next\r\n  ) {\r\n    UnstakeRequest storage unstakeRequest = unstakeRequests[unstakeRequestId];\r\n    amount = unstakeRequest.amount;\r\n    unstakeAt = unstakeRequest.unstakeAt;\r\n    contractAddress = unstakeRequest.contractAddress;\r\n    stakerAddress = unstakeRequest.stakerAddress;\r\n    next = unstakeRequest.next;\r\n  }\r\n\r\n  function hasPendingActions() public view returns (bool) {\r\n    return hasPendingBurns() || hasPendingUnstakeRequests() || hasPendingRewards();\r\n  }\r\n\r\n  function hasPendingBurns() public view returns (bool) {\r\n    return burn.burnedAt != 0;\r\n  }\r\n\r\n  function hasPendingUnstakeRequests() public view returns (bool){\r\n\r\n    uint nextRequestIndex = unstakeRequests[0].next;\r\n\r\n    if (nextRequestIndex == 0) {\r\n      return false;\r\n    }\r\n\r\n    return unstakeRequests[nextRequestIndex].unstakeAt <= now;\r\n  }\r\n\r\n  function hasPendingRewards() public view returns (bool){\r\n    return rewards[firstReward].rewardedAt != 0;\r\n  }\r\n\r\n  /* State-changing functions */\r\n\r\n  function depositAndStake(\r\n    uint amount,\r\n    address[] calldata _contracts,\r\n    uint[] calldata _stakes\r\n  ) external whenNotPausedAndInitialized onlyMember noPendingActions {\r\n\r\n    Staker storage staker = stakers[msg.sender];\r\n    uint oldLength = staker.contracts.length;\r\n\r\n    require(\r\n      _contracts.length >= oldLength,\r\n      \"Staking on fewer contracts is not allowed\"\r\n    );\r\n\r\n    require(\r\n      _contracts.length == _stakes.length,\r\n      \"Contracts and stakes arrays should have the same length\"\r\n    );\r\n\r\n    uint totalStaked;\r\n\r\n    // cap old stakes to this amount\r\n    uint oldDeposit = staker.deposit;\r\n    uint newDeposit = oldDeposit.add(amount);\r\n\r\n    staker.deposit = newDeposit;\r\n    token.transferFrom(msg.sender, address(this), amount);\r\n\r\n    for (uint i = 0; i < _contracts.length; i++) {\r\n\r\n      address contractAddress = _contracts[i];\r\n\r\n      for (uint j = 0; j < i; j++) {\r\n        require(_contracts[j] != contractAddress, \"Contracts array should not contain duplicates\");\r\n      }\r\n\r\n      uint initialStake = staker.stakes[contractAddress];\r\n      uint oldStake = oldDeposit < initialStake ? oldDeposit : initialStake;\r\n      uint newStake = _stakes[i];\r\n      bool isNewStake = i >= oldLength;\r\n\r\n      if (!isNewStake) {\r\n        require(contractAddress == staker.contracts[i], \"Unexpected contract order\");\r\n        require(oldStake <= newStake, \"New stake is less than previous stake\");\r\n      } else {\r\n        require(newStake > 0, \"New stakes should be greater than 0\");\r\n        staker.contracts.push(contractAddress);\r\n      }\r\n\r\n      if (oldStake == newStake) {\r\n\r\n        // if there were burns but the stake was not updated, update it now\r\n        if (initialStake != newStake) {\r\n          staker.stakes[contractAddress] = newStake;\r\n        }\r\n\r\n        totalStaked = totalStaked.add(newStake);\r\n\r\n        // no other changes to this contract\r\n        continue;\r\n      }\r\n\r\n      require(newStake >= MIN_STAKE, \"Minimum stake amount not met\");\r\n      require(newStake <= newDeposit, \"Cannot stake more than deposited\");\r\n\r\n      if (isNewStake || !staker.isInContractStakers[contractAddress]) {\r\n        staker.isInContractStakers[contractAddress] = true;\r\n        contractStakers[contractAddress].push(msg.sender);\r\n      }\r\n\r\n      staker.stakes[contractAddress] = newStake;\r\n      totalStaked = totalStaked.add(newStake);\r\n      uint increase = newStake.sub(oldStake);\r\n\r\n      emit Staked(contractAddress, msg.sender, increase);\r\n    }\r\n\r\n    require(\r\n      totalStaked <= staker.deposit.mul(MAX_EXPOSURE),\r\n      \"Total stake exceeds maximum allowed\"\r\n    );\r\n\r\n    if (amount > 0) {\r\n      emit Deposited(msg.sender, amount);\r\n    }\r\n\r\n    // cleanup zero-amount contracts\r\n    uint lastContractIndex = _contracts.length - 1;\r\n\r\n    for (uint i = oldLength; i > 0; i--) {\r\n      if (_stakes[i - 1] == 0) {\r\n        staker.contracts[i - 1] = staker.contracts[lastContractIndex];\r\n        staker.contracts.pop();\r\n        --lastContractIndex;\r\n      }\r\n    }\r\n  }\r\n\r\n  function withdraw(uint amount) external whenNotPausedAndInitialized onlyMember noPendingBurns {\r\n    uint limit = stakerMaxWithdrawable(msg.sender);\r\n    require(limit >= amount, \"Requested amount exceeds max withdrawable amount\");\r\n    stakers[msg.sender].deposit = stakers[msg.sender].deposit.sub(amount);\r\n    token.transfer(msg.sender, amount);\r\n    emit Withdrawn(msg.sender, amount);\r\n  }\r\n\r\n  function requestUnstake(\r\n    address[] calldata _contracts,\r\n    uint[] calldata _amounts,\r\n    uint _insertAfter // unstake request id after which the new unstake request will be inserted\r\n  ) external whenNotPausedAndInitialized onlyMember {\r\n\r\n    require(\r\n      _contracts.length == _amounts.length,\r\n      \"Contracts and amounts arrays should have the same length\"\r\n    );\r\n\r\n    require(_insertAfter <= lastUnstakeRequestId, 'Invalid unstake request id provided');\r\n\r\n    Staker storage staker = stakers[msg.sender];\r\n    uint deposit = staker.deposit;\r\n    uint previousId = _insertAfter;\r\n    uint unstakeAt = now.add(UNSTAKE_LOCK_TIME);\r\n\r\n    UnstakeRequest storage previousRequest = unstakeRequests[previousId];\r\n\r\n    // Forbid insertion after an empty slot when there are non-empty slots\r\n    // previousId != 0 allows inserting on the first position (in case lock time has been reduced)\r\n    if (previousId != 0) {\r\n      require(previousRequest.unstakeAt != 0, \"Provided unstake request id should not be an empty slot\");\r\n    }\r\n\r\n    for (uint i = 0; i < _contracts.length; i++) {\r\n\r\n      address contractAddress = _contracts[i];\r\n      uint stake = staker.stakes[contractAddress];\r\n\r\n      if (stake > deposit) {\r\n        stake = deposit;\r\n      }\r\n\r\n      uint pendingUnstakeAmount = staker.pendingUnstakeRequestsTotal[contractAddress];\r\n      uint requestedAmount = _amounts[i];\r\n      uint max = pendingUnstakeAmount > stake ? 0 : stake.sub(pendingUnstakeAmount);\r\n\r\n      require(max > 0, \"Nothing to unstake on this contract\");\r\n      require(requestedAmount <= max, \"Cannot unstake more than staked\");\r\n\r\n      // To prevent spam, small stakes and unstake requests are not allowed\r\n      // However, we allow the user to unstake the entire amount\r\n      if (requestedAmount != max) {\r\n        require(requestedAmount >= MIN_UNSTAKE, \"Unstaked amount cannot be less than minimum unstake amount\");\r\n        require(max.sub(requestedAmount) >= MIN_STAKE, \"Remaining stake cannot be less than minimum unstake amount\");\r\n      }\r\n\r\n      require(\r\n        unstakeAt >= previousRequest.unstakeAt,\r\n        \"Unstake request time must be greater or equal to previous unstake request\"\r\n      );\r\n\r\n      if (previousRequest.next != 0) {\r\n        UnstakeRequest storage nextRequest = unstakeRequests[previousRequest.next];\r\n        require(\r\n          nextRequest.unstakeAt > unstakeAt,\r\n          \"Next unstake request time must be greater than new unstake request time\"\r\n        );\r\n      }\r\n\r\n      // Note: We previously had an `id` variable that was assigned immediately to `previousId`.\r\n      //   It was removed in order to save some memory and previousId used instead.\r\n      //   This makes the next section slightly harder to read but you can read \"previousId\" as \"newId\" instead.\r\n\r\n      // get next available unstake request id. our new unstake request becomes previous for the next loop\r\n      previousId = ++lastUnstakeRequestId;\r\n\r\n      unstakeRequests[previousId] = UnstakeRequest(\r\n        requestedAmount,\r\n        unstakeAt,\r\n        contractAddress,\r\n        msg.sender,\r\n        previousRequest.next\r\n      );\r\n\r\n      // point to our new unstake request\r\n      previousRequest.next = previousId;\r\n\r\n      emit UnstakeRequested(contractAddress, msg.sender, requestedAmount, unstakeAt);\r\n\r\n      // increase pending unstake requests total so we keep track of final stake\r\n      uint newPending = staker.pendingUnstakeRequestsTotal[contractAddress].add(requestedAmount);\r\n      staker.pendingUnstakeRequestsTotal[contractAddress] = newPending;\r\n\r\n      // update the reference to the unstake request at target index for the next loop\r\n      previousRequest = unstakeRequests[previousId];\r\n    }\r\n  }\r\n\r\n  function withdrawReward(address stakerAddress) external whenNotPausedAndInitialized {\r\n\r\n    uint amount = stakers[stakerAddress].reward;\r\n    stakers[stakerAddress].reward = 0;\r\n\r\n    token.transfer(stakerAddress, amount);\r\n\r\n    emit RewardWithdrawn(stakerAddress, amount);\r\n  }\r\n\r\n  function pushBurn(\r\n    address contractAddress, uint amount\r\n  ) public onlyInternal whenNotPausedAndInitialized noPendingBurns {\r\n\r\n    burn.amount = amount;\r\n    burn.burnedAt = now;\r\n    burn.contractAddress = contractAddress;\r\n\r\n    emit BurnRequested(contractAddress, amount);\r\n  }\r\n\r\n  function pushReward(address contractAddress, uint amount) external onlyInternal whenNotPausedAndInitialized {\r\n\r\n    rewards[++lastRewardId] = Reward(amount, now, contractAddress);\r\n\r\n    if (firstReward == 0) {\r\n      firstReward = lastRewardId;\r\n    }\r\n\r\n    emit RewardRequested(contractAddress, amount);\r\n  }\r\n\r\n  function processPendingActions(uint maxIterations) public whenNotPausedAndInitialized returns (bool) {\r\n\r\n    uint iterationsLeft = maxIterations;\r\n    bool finished;\r\n\r\n    while (true) {\r\n\r\n      uint firstUnstakeRequestIndex = unstakeRequests[0].next;\r\n      UnstakeRequest storage unstakeRequest = unstakeRequests[firstUnstakeRequestIndex];\r\n      Reward storage reward = rewards[firstReward];\r\n\r\n      // read storage and cache in memory\r\n      uint burnedAt = burn.burnedAt;\r\n      uint rewardedAt = reward.rewardedAt;\r\n      uint unstakeAt = unstakeRequest.unstakeAt;\r\n\r\n      bool canUnstake = firstUnstakeRequestIndex > 0 && unstakeAt <= now;\r\n      bool canBurn = burnedAt != 0;\r\n      bool canReward = firstReward != 0;\r\n\r\n      if (!canBurn && !canUnstake && !canReward) {\r\n        // everything is processed\r\n        break;\r\n      }\r\n\r\n      if (\r\n        canBurn &&\r\n        (!canUnstake || burnedAt < unstakeAt) &&\r\n        (!canReward || burnedAt < rewardedAt)\r\n      ) {\r\n\r\n        (finished, iterationsLeft) = _processBurn(iterationsLeft);\r\n\r\n        if (!finished) {\r\n          emit PendingActionsProcessed(false);\r\n          return false;\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        canUnstake &&\r\n        (!canReward || unstakeAt < rewardedAt)\r\n      ) {\r\n\r\n        // _processFirstUnstakeRequest is O(1) so we'll handle the iteration checks here\r\n        if (iterationsLeft == 0) {\r\n          emit PendingActionsProcessed(false);\r\n          return false;\r\n        }\r\n\r\n        _processFirstUnstakeRequest();\r\n        --iterationsLeft;\r\n        continue;\r\n      }\r\n\r\n      (finished, iterationsLeft) = _processFirstReward(iterationsLeft);\r\n\r\n      if (!finished) {\r\n        emit PendingActionsProcessed(false);\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // everything is processed!\r\n    emit PendingActionsProcessed(true);\r\n    return true;\r\n  }\r\n\r\n  function _processBurn(uint maxIterations) internal returns (bool finished, uint iterationsLeft) {\r\n\r\n    iterationsLeft = maxIterations;\r\n\r\n    address _contractAddress = burn.contractAddress;\r\n    uint _stakedOnContract;\r\n\r\n    (_stakedOnContract, finished, iterationsLeft) = _calculateContractStake(_contractAddress, iterationsLeft);\r\n\r\n    if (!finished) {\r\n      return (false, iterationsLeft);\r\n    }\r\n\r\n    address[] storage _contractStakers = contractStakers[_contractAddress];\r\n    uint _stakerCount = _contractStakers.length;\r\n\r\n    uint _totalBurnAmount = burn.amount;\r\n    uint _actualBurnAmount = contractBurned;\r\n\r\n    if (_totalBurnAmount > _stakedOnContract) {\r\n      _totalBurnAmount = _stakedOnContract;\r\n    }\r\n\r\n    for (uint i = processedToStakerIndex; i < _stakerCount; i++) {\r\n\r\n      if (iterationsLeft == 0) {\r\n        contractBurned = _actualBurnAmount;\r\n        processedToStakerIndex = i;\r\n        return (false, iterationsLeft);\r\n      }\r\n\r\n      --iterationsLeft;\r\n\r\n      Staker storage staker = stakers[_contractStakers[i]];\r\n      uint _stakerBurnAmount;\r\n      uint _newStake;\r\n\r\n      (_stakerBurnAmount, _newStake) = _burnStaker(staker, _contractAddress, _stakedOnContract, _totalBurnAmount);\r\n      _actualBurnAmount = _actualBurnAmount.add(_stakerBurnAmount);\r\n\r\n      if (_newStake != 0) {\r\n        continue;\r\n      }\r\n\r\n      // if we got here, the stake is explicitly set to 0\r\n      // the staker is removed from the contract stakers array\r\n      // and we will add the staker back if he stakes again\r\n      staker.isInContractStakers[_contractAddress] = false;\r\n      _contractStakers[i] = _contractStakers[_stakerCount - 1];\r\n      _contractStakers.pop();\r\n\r\n      // i-- might underflow to MAX_UINT\r\n      // but that's fine since it will be incremented back to 0 on the next loop\r\n      i--;\r\n      _stakerCount--;\r\n    }\r\n\r\n    delete burn;\r\n    contractBurned = 0;\r\n    processedToStakerIndex = 0;\r\n    isContractStakeCalculated = false;\r\n\r\n    token.burn(_actualBurnAmount);\r\n    emit Burned(_contractAddress, _actualBurnAmount, _stakedOnContract);\r\n\r\n    return (true, iterationsLeft);\r\n  }\r\n\r\n  function _burnStaker(\r\n    Staker storage staker, address _contractAddress, uint _stakedOnContract, uint _totalBurnAmount\r\n  ) internal returns (\r\n    uint _stakerBurnAmount, uint _newStake\r\n  ) {\r\n\r\n    uint _currentDeposit;\r\n    uint _currentStake;\r\n\r\n    // silence compiler warning\r\n    _newStake = 0;\r\n\r\n    // do we need a storage read?\r\n    if (_stakedOnContract != 0) {\r\n      _currentDeposit = staker.deposit;\r\n      _currentStake = staker.stakes[_contractAddress];\r\n\r\n      if (_currentStake > _currentDeposit) {\r\n        _currentStake = _currentDeposit;\r\n      }\r\n    }\r\n\r\n    if (_stakedOnContract != _totalBurnAmount) {\r\n      // formula: staker_burn = staker_stake / total_contract_stake * contract_burn\r\n      // reordered for precision loss prevention\r\n      _stakerBurnAmount = _currentStake.mul(_totalBurnAmount).div(_stakedOnContract);\r\n      _newStake = _currentStake.sub(_stakerBurnAmount);\r\n    } else {\r\n      // it's the whole stake\r\n      _stakerBurnAmount = _currentStake;\r\n    }\r\n\r\n    if (_stakerBurnAmount != 0) {\r\n      staker.deposit = _currentDeposit.sub(_stakerBurnAmount);\r\n    }\r\n\r\n    staker.stakes[_contractAddress] = _newStake;\r\n  }\r\n\r\n  function _calculateContractStake(\r\n    address _contractAddress, uint maxIterations\r\n  ) internal returns (\r\n    uint _stakedOnContract, bool finished, uint iterationsLeft\r\n  ) {\r\n\r\n    iterationsLeft = maxIterations;\r\n\r\n    if (isContractStakeCalculated) {\r\n      // use previously calculated staked amount\r\n      return (contractStaked, true, iterationsLeft);\r\n    }\r\n\r\n    address[] storage _contractStakers = contractStakers[_contractAddress];\r\n    uint _stakerCount = _contractStakers.length;\r\n    uint startIndex = processedToStakerIndex;\r\n\r\n    if (startIndex != 0) {\r\n      _stakedOnContract = contractStaked;\r\n    }\r\n\r\n    // calculate amount staked on contract\r\n    for (uint i = startIndex; i < _stakerCount; i++) {\r\n\r\n      if (iterationsLeft == 0) {\r\n        processedToStakerIndex = i;\r\n        contractStaked = _stakedOnContract;\r\n        return (_stakedOnContract, false, iterationsLeft);\r\n      }\r\n\r\n      --iterationsLeft;\r\n\r\n      Staker storage staker = stakers[_contractStakers[i]];\r\n      uint deposit = staker.deposit;\r\n      uint stake = staker.stakes[_contractAddress];\r\n      stake = deposit < stake ? deposit : stake;\r\n      _stakedOnContract = _stakedOnContract.add(stake);\r\n    }\r\n\r\n    contractStaked = _stakedOnContract;\r\n    isContractStakeCalculated = true;\r\n    processedToStakerIndex = 0;\r\n\r\n    return (_stakedOnContract, true, iterationsLeft);\r\n  }\r\n\r\n  function _processFirstUnstakeRequest() internal {\r\n\r\n    uint firstRequest = unstakeRequests[0].next;\r\n    UnstakeRequest storage unstakeRequest = unstakeRequests[firstRequest];\r\n    address stakerAddress = unstakeRequest.stakerAddress;\r\n    Staker storage staker = stakers[stakerAddress];\r\n\r\n    address contractAddress = unstakeRequest.contractAddress;\r\n    uint deposit = staker.deposit;\r\n    uint initialStake = staker.stakes[contractAddress];\r\n    uint stake = deposit < initialStake ? deposit : initialStake;\r\n\r\n    uint requestedAmount = unstakeRequest.amount;\r\n    uint actualUnstakedAmount = stake < requestedAmount ? stake : requestedAmount;\r\n    staker.stakes[contractAddress] = stake.sub(actualUnstakedAmount);\r\n\r\n    uint pendingUnstakeRequestsTotal = staker.pendingUnstakeRequestsTotal[contractAddress];\r\n    staker.pendingUnstakeRequestsTotal[contractAddress] = pendingUnstakeRequestsTotal.sub(requestedAmount);\r\n\r\n    // update pointer to first unstake request\r\n    unstakeRequests[0].next = unstakeRequest.next;\r\n    delete unstakeRequests[firstRequest];\r\n\r\n    emit Unstaked(contractAddress, stakerAddress, requestedAmount);\r\n  }\r\n\r\n  function _processFirstReward(uint maxIterations) internal returns (bool finished, uint iterationsLeft) {\r\n\r\n    iterationsLeft = maxIterations;\r\n\r\n    Reward storage reward = rewards[firstReward];\r\n    address _contractAddress = reward.contractAddress;\r\n    uint _totalRewardAmount = reward.amount;\r\n\r\n    uint _stakedOnContract;\r\n\r\n    (_stakedOnContract, finished, iterationsLeft) = _calculateContractStake(_contractAddress, iterationsLeft);\r\n\r\n    if (!finished) {\r\n      return (false, iterationsLeft);\r\n    }\r\n\r\n    address[] storage _contractStakers = contractStakers[_contractAddress];\r\n    uint _stakerCount = _contractStakers.length;\r\n    uint _actualRewardAmount = contractRewarded;\r\n\r\n    for (uint i = processedToStakerIndex; i < _stakerCount; i++) {\r\n\r\n      if (iterationsLeft == 0) {\r\n        contractRewarded = _actualRewardAmount;\r\n        processedToStakerIndex = i;\r\n        return (false, iterationsLeft);\r\n      }\r\n\r\n      --iterationsLeft;\r\n\r\n      address _stakerAddress = _contractStakers[i];\r\n\r\n      (uint _stakerRewardAmount, uint _stake) = _rewardStaker(\r\n        _stakerAddress, _contractAddress, _totalRewardAmount, _stakedOnContract\r\n      );\r\n\r\n      // remove 0-amount stakers, similar to what we're doing when processing burns\r\n      if (_stake == 0) {\r\n\r\n        // mark the user as not present in contract stakers array\r\n        Staker storage staker = stakers[_stakerAddress];\r\n        staker.isInContractStakers[_contractAddress] = false;\r\n\r\n        // remove the staker from the contract stakers array\r\n        _contractStakers[i] = _contractStakers[_stakerCount - 1];\r\n        _contractStakers.pop();\r\n        i--;\r\n        _stakerCount--;\r\n\r\n        // since the stake is 0, there's no reward to give\r\n        continue;\r\n      }\r\n\r\n      _actualRewardAmount = _actualRewardAmount.add(_stakerRewardAmount);\r\n    }\r\n\r\n    delete rewards[firstReward];\r\n    contractRewarded = 0;\r\n    processedToStakerIndex = 0;\r\n    isContractStakeCalculated = false;\r\n\r\n    if (++firstReward > lastRewardId) {\r\n      firstReward = 0;\r\n    }\r\n\r\n    tokenController.mint(address(this), _actualRewardAmount);\r\n    emit Rewarded(_contractAddress, _actualRewardAmount, _stakedOnContract);\r\n\r\n    return (true, iterationsLeft);\r\n  }\r\n\r\n  function _rewardStaker(\r\n    address stakerAddress, address contractAddress, uint totalRewardAmount, uint totalStakedOnContract\r\n  ) internal returns (uint rewardedAmount, uint stake) {\r\n\r\n    Staker storage staker = stakers[stakerAddress];\r\n    uint deposit = staker.deposit;\r\n    stake = staker.stakes[contractAddress];\r\n\r\n    if (stake > deposit) {\r\n      stake = deposit;\r\n    }\r\n\r\n    // prevent division by zero and set stake to zero\r\n    if (totalStakedOnContract == 0 || stake == 0) {\r\n      staker.stakes[contractAddress] = 0;\r\n      return (0, 0);\r\n    }\r\n\r\n    // reward = staker_stake / total_contract_stake * total_reward\r\n    rewardedAmount = totalRewardAmount.mul(stake).div(totalStakedOnContract);\r\n    staker.reward = staker.reward.add(rewardedAmount);\r\n  }\r\n\r\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\r\n\r\n    if (code == \"MIN_STAK\") {\r\n      MIN_STAKE = value;\r\n      return;\r\n    }\r\n\r\n    if (code == \"MAX_EXPO\") {\r\n      MAX_EXPOSURE = value;\r\n      return;\r\n    }\r\n\r\n    if (code == \"MIN_UNST\") {\r\n      MIN_UNSTAKE = value;\r\n      return;\r\n    }\r\n\r\n    if (code == \"UNST_LKT\") {\r\n      UNSTAKE_LOCK_TIME = value;\r\n      return;\r\n    }\r\n  }\r\n\r\n  function initialize() internal {\r\n\r\n    require(!initialized, \"Contract is already initialized\");\r\n\r\n    tokenController.addToWhitelist(address(this));\r\n\r\n    MIN_STAKE = 20 ether;\r\n    MIN_UNSTAKE = 20 ether;\r\n    MAX_EXPOSURE = 10;\r\n    UNSTAKE_LOCK_TIME = 90 days;\r\n  }\r\n\r\n  event StakersMigrationCompleted(\r\n    bool completed,\r\n    uint memberIndex,\r\n    uint stakeIndex\r\n  );\r\n\r\n  event MigratedMember(\r\n    address member,\r\n    uint memberIndex\r\n  );\r\n\r\n  function migrateStakers(uint maxIterations) external returns (bool){\r\n\r\n    require(!initialized, \"Migration already completed\");\r\n\r\n    ITokenFunctions tokenFunctions = ITokenFunctions(master.getLatestAddress(\"TF\"));\r\n    ITokenData tokenData = ITokenData(master.getLatestAddress(\"TD\"));\r\n    IClaimsReward claimsReward = IClaimsReward(master.getLatestAddress(\"CR\"));\r\n    IMemberRoles memberRoles = IMemberRoles(master.getLatestAddress(\"MR\"));\r\n\r\n    uint iterationsLeft = maxIterations;\r\n    uint membersLength = memberRoles.membersLength(uint(IMemberRoles.Role.Member));\r\n\r\n    for (uint memberIndex = processedToStakerIndex; memberIndex < membersLength; memberIndex++) {\r\n\r\n      (address member, bool isActive) = memberRoles.memberAtIndex(uint(IMemberRoles.Role.Member), memberIndex);\r\n\r\n      if (!isActive) {\r\n        continue;\r\n      }\r\n\r\n      uint stakedContractsCount = tokenData.getStakerStakedContractLength(member);\r\n      uint commissionsLeftToProcess = tokenData.getStakerTotalEarnedStakeCommission(member)\r\n        .sub(tokenData.getStakerTotalReedmedStakeCommission(member));\r\n\r\n      if (commissionsLeftToProcess > 0) {\r\n        claimsReward._claimStakeCommission(stakedContractsCount, member);\r\n      }\r\n\r\n      // we're reusing firstReward storage variable in order to avoid\r\n      // declaration of variables that will only be used for the migration\r\n      for (uint i = firstReward; i < stakedContractsCount; i++) {\r\n\r\n        if (iterationsLeft == 0) {\r\n          processedToStakerIndex = memberIndex;\r\n          firstReward = i;\r\n          emit StakersMigrationCompleted(false, memberIndex, i);\r\n          return false;\r\n        }\r\n\r\n        --iterationsLeft;\r\n\r\n        address contractAddress = tokenData.getStakerStakedContractByIndex(member, i);\r\n        uint stakerContractIndex = tokenData.getStakerStakedContractIndex(member, i);\r\n\r\n        unlockStakerUnlockableTokensForContract(\r\n          tokenData, tokenFunctions, member, contractAddress, stakerContractIndex, i\r\n        );\r\n\r\n        (, uint stakedAmount) = tokenFunctions._deprecated_unlockableBeforeBurningAndCanBurn(member, contractAddress, i);\r\n\r\n        if (stakedAmount > 0) {\r\n          stakeForMemberOnContract(tokenData, member, contractAddress, stakedAmount, stakerContractIndex, i);\r\n        }\r\n      }\r\n\r\n      emit MigratedMember(member, memberIndex);\r\n\r\n      // reset start index for the next iteration\r\n      firstReward = 0;\r\n    }\r\n\r\n    initialized = true;\r\n\r\n    // reset migration indexes\r\n    processedToStakerIndex = 0;\r\n    firstReward = 0;\r\n    emit StakersMigrationCompleted(true, processedToStakerIndex, firstReward);\r\n\r\n    return true;\r\n  }\r\n\r\n  function stakeForMemberOnContract(\r\n    ITokenData tokenData,\r\n    address stakerAddress,\r\n    address contractAddress,\r\n    uint stakedAmount,\r\n    uint stakerContractIndex,\r\n    uint i\r\n  ) internal {\r\n\r\n    Staker storage staker = stakers[stakerAddress];\r\n    staker.deposit = staker.deposit.add(stakedAmount);\r\n    staker.stakes[contractAddress] = staker.stakes[contractAddress].add(stakedAmount);\r\n\r\n    emit Staked(contractAddress, stakerAddress, stakedAmount);\r\n    emit Deposited(stakerAddress, stakedAmount);\r\n\r\n    tokenData.pushBurnedTokens(stakerAddress, i, stakedAmount);\r\n    bytes32 lockReason = keccak256(abi.encodePacked(\"UW\", stakerAddress, contractAddress, stakerContractIndex));\r\n    tokenController.burnLockedTokens(stakerAddress, lockReason, stakedAmount);\r\n\r\n    if (!staker.isInContractStakers[contractAddress]) {\r\n      staker.contracts.push(contractAddress);\r\n      staker.isInContractStakers[contractAddress] = true;\r\n      contractStakers[contractAddress].push(stakerAddress);\r\n    }\r\n\r\n    tokenController.mint(address(this), stakedAmount);\r\n  }\r\n\r\n  function unlockStakerUnlockableTokensForContract(\r\n    ITokenData tokenData,\r\n    ITokenFunctions tokenFunctions,\r\n    address stakerAddress,\r\n    address contractAddress,\r\n    uint stakerContractIndex,\r\n    uint i\r\n  ) internal {\r\n\r\n    uint unlockableAmount = tokenFunctions._deprecated_getStakerUnlockableTokensOnSmartContract(\r\n      stakerAddress, contractAddress, stakerContractIndex\r\n    );\r\n\r\n    tokenData.setUnlockableBeforeLastBurnTokens(stakerAddress, i, 0);\r\n    tokenData.pushUnlockedStakedTokens(stakerAddress, i, unlockableAmount);\r\n\r\n    bytes32 lockReason = keccak256(abi.encodePacked(\"UW\", stakerAddress, contractAddress, stakerContractIndex));\r\n    tokenController.releaseLockedTokens(stakerAddress, lockReason, unlockableAmount);\r\n  }\r\n\r\n  function changeDependentContractAddress() public {\r\n\r\n    token = NXMToken(master.tokenAddress());\r\n    tokenController = ITokenController(master.getLatestAddress(\"TC\"));\r\n\r\n    if (!initialized) {\r\n      initialize();\r\n    }\r\n  }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractStakeBeforeBurn\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memberIndex\",\"type\":\"uint256\"}],\"name\":\"MigratedMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"name\":\"PendingActionsProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractStake\",\"type\":\"uint256\"}],\"name\":\"Rewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memberIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"StakersMigrationCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakeAt\",\"type\":\"uint256\"}],\"name\":\"UnstakeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_EXPOSURE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_UNSTAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNSTAKE_LOCK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnedAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"contractStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakerIndex\",\"type\":\"uint256\"}],\"name\":\"contractStakerAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"contractStakerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"contractStakersArray\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_stakers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_stakes\",\"type\":\"uint256[]\"}],\"name\":\"depositAndStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasPendingActions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasPendingBurns\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasPendingRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasPendingUnstakeRequests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractStakeCalculated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUnstakeRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxIterations\",\"type\":\"uint256\"}],\"name\":\"migrateStakers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxIterations\",\"type\":\"uint256\"}],\"name\":\"processPendingActions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"processedToStakerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pushBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pushReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_insertAfter\",\"type\":\"uint256\"}],\"name\":\"requestUnstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardedAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"contractIndex\",\"type\":\"uint256\"}],\"name\":\"stakerContractAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"stakerContractCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"stakerContractPendingUnstakeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"stakerContractStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"stakerContractsArray\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"stakerDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"stakerMaxWithdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"stakerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract NXMToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenController\",\"outputs\":[{\"internalType\":\"contract ITokenController\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeRequestId\",\"type\":\"uint256\"}],\"name\":\"unstakeRequestAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"next\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unstakeRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"next\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"code\",\"type\":\"bytes8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateUintParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PooledStaking","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://79e3d24ba303648ad0734e4b678f8a82fd7214b1a4726525caee8fe4e1ead088"}]}