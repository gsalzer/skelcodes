{"status":"1","message":"OK","result":[{"SourceCode":"// Dependency file: contracts/interface/IERC20.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n\r\n// Dependency file: contracts/interface/ERC2917-Interface.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.6.6;\r\n// import 'contracts/interface/IERC20.sol';\r\n\r\ninterface IERC2917 is IERC20 {\r\n\r\n    /// @dev This emit when interests amount per block is changed by the owner of the contract.\r\n    /// It emits with the old interests amount and the new interests amount.\r\n    event InterestsPerBlockChanged (uint oldValue, uint newValue);\r\n\r\n    /// @dev This emit when a users' productivity has changed\r\n    /// It emits with the user's address and the the value after the change.\r\n    event ProductivityIncreased (address indexed user, uint value);\r\n\r\n    /// @dev This emit when a users' productivity has changed\r\n    /// It emits with the user's address and the the value after the change.\r\n    event ProductivityDecreased (address indexed user, uint value);\r\n\r\n    \r\n    /// @dev Return the current contract's interests rate per block.\r\n    /// @return The amount of interests currently producing per each block.\r\n    function interestsPerBlock() external view returns (uint);\r\n\r\n    /// @notice Change the current contract's interests rate.\r\n    /// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\r\n    /// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestsPerBlockChanged event.\r\n    function changeInterestsPerBlock(uint value) external returns (bool);\r\n\r\n    /// @notice It will get the productivity of given user.\r\n    /// @dev it will return 0 if user has no productivity proved in the contract.\r\n    /// @return user's productivity and overall productivity.\r\n    function getProductivity(address user) external view returns (uint, uint);\r\n\r\n    /// @notice increase a user's productivity.\r\n    /// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\r\n    /// @return true to confirm that the productivity added success.\r\n    function increaseProductivity(address user, uint value) external returns (uint);\r\n\r\n    /// @notice decrease a user's productivity.\r\n    /// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\r\n    /// @return true to confirm that the productivity removed success.\r\n    function decreaseProductivity(address user, uint value) external returns (uint);\r\n\r\n    /// @notice take() will return the interests that callee will get at current block height.\r\n    /// @dev it will always calculated by block.number, so it will change when block height changes.\r\n    /// @return amount of the interests that user are able to mint() at current block height.\r\n    function take() external view returns (uint);\r\n\r\n    /// @notice similar to take(), but with the block height joined to calculate return.\r\n    /// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\r\n    /// @return amount of interests and the block height.\r\n    function takeWithBlock() external view returns (uint, uint);\r\n\r\n    /// @notice mint the avaiable interests to callee.\r\n    /// @dev once it mint, the amount of interests will transfer to callee's address.\r\n    /// @return the amount of interests minted.\r\n    function mint(address to) external returns (uint);\r\n}\r\n\r\n\r\n// Dependency file: contracts/libraries/Upgradable.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.5.16;\r\n\r\ncontract UpgradableProduct {\r\n    address public impl;\r\n\r\n    event ImplChanged(address indexed _oldImpl, address indexed _newImpl);\r\n\r\n    constructor() public {\r\n        impl = msg.sender;\r\n    }\r\n\r\n    modifier requireImpl() {\r\n        require(msg.sender == impl, 'FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    function upgradeImpl(address _newImpl) public requireImpl {\r\n        require(_newImpl != address(0), 'INVALID_ADDRESS');\r\n        require(_newImpl != impl, 'NO_CHANGE');\r\n        address lastImpl = impl;\r\n        impl = _newImpl;\r\n        emit ImplChanged(lastImpl, _newImpl);\r\n    }\r\n}\r\n\r\ncontract UpgradableGovernance {\r\n    address public governor;\r\n\r\n    event GovernorChanged(address indexed _oldGovernor, address indexed _newGovernor);\r\n\r\n    constructor() public {\r\n        governor = msg.sender;\r\n    }\r\n\r\n    modifier requireGovernor() {\r\n        require(msg.sender == governor, 'FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    function upgradeGovernance(address _newGovernor) public requireGovernor {\r\n        require(_newGovernor != address(0), 'INVALID_ADDRESS');\r\n        require(_newGovernor != governor, 'NO_CHANGE');\r\n        address lastGovernor = governor;\r\n        governor = _newGovernor;\r\n        emit GovernorChanged(lastGovernor, _newGovernor);\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/libraries/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Dependency file: contracts/WasabiToken.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.6.6;\r\n\r\n// import 'contracts/interface/ERC2917-Interface.sol';\r\n// import 'contracts/libraries/Upgradable.sol';\r\n// import 'contracts/libraries/SafeMath.sol';\r\n\r\n/*\r\n    The Objective of ERC2917 Demo is to implement a decentralized staking mechanism, which calculates users' share\r\n    by accumulating productiviy * time. And calculates users revenue from anytime t0 to t1 by the formula below:\r\n\r\n        user_accumulated_productivity(time1) - user_accumulated_productivity(time0)\r\n       _____________________________________________________________________________  * (gross_product(t1) - gross_product(t0))\r\n       total_accumulated_productivity(time1) - total_accumulated_productivity(time0)\r\n\r\n*/\r\ncontract WasabiToken is IERC2917, UpgradableProduct, UpgradableGovernance {\r\n    using SafeMath for uint;\r\n    uint public constant version = 2;\r\n    uint public mintCumulation;\r\n    uint public maxMintCumulation;\r\n\r\n    uint private unlocked = 1;\r\n    uint public wasabiPerBlock;\r\n\r\n    modifier lock() {\r\n        require(unlocked == 1, 'Locked');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    uint public nounce;\r\n\r\n    function incNounce() public {\r\n        nounce ++;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint amount;     // How many LP tokens the user has provided.\r\n        uint rewardDebt; // Reward debt. \r\n    }\r\n\r\n    mapping(address => UserInfo) public users;\r\n\r\n    // implementation of ERC20 interfaces.\r\n    string override public name;\r\n    string override public symbol;\r\n    uint8 override public decimals = 18;\r\n    uint override public totalSupply;\r\n\r\n    mapping(address => uint) override public balanceOf;\r\n    mapping(address => mapping(address => uint)) override public allowance;\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        require(balanceOf[from] >= value, 'ERC20Token: INSUFFICIENT_BALANCE');\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        if (to == address(0)) { // burn\r\n            totalSupply = totalSupply.sub(value);\r\n        }\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        require(allowance[from][msg.sender] >= value, 'ERC20Token: INSUFFICIENT_ALLOWANCE');\r\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    // end of implementation of ERC20\r\n\r\n    // creation of the interests token.\r\n    constructor(uint _initAmount, address _initAddress, uint _interestsRate, uint _maxMintCumulation) UpgradableProduct() UpgradableGovernance() public {\r\n        name        = \"Wasabi Token\";\r\n        symbol      = \"WASABI\";\r\n        decimals    = 18;\r\n\r\n        wasabiPerBlock          = _interestsRate;\r\n        totalSupply             = _initAmount;\r\n        balanceOf[_initAddress] = _initAmount;\r\n        mintCumulation          = _initAmount;\r\n\r\n        maxMintCumulation       = _maxMintCumulation;\r\n    }\r\n\r\n    // External function call\r\n    // This function adjust how many token will be produced by each block, eg:\r\n    // changeAmountPerBlock(100)\r\n    // will set the produce rate to 100/block.\r\n    function changeInterestsPerBlock(uint value) external override requireGovernor returns (bool) {\r\n        uint old = wasabiPerBlock;\r\n        require(value != old, 'AMOUNT_PER_BLOCK_NO_CHANGE');\r\n\r\n        update();\r\n        wasabiPerBlock = value;\r\n\r\n        emit InterestsPerBlockChanged(old, value);\r\n        return true;\r\n    }\r\n\r\n    uint lastRewardBlock;\r\n    uint totalProductivity;\r\n    uint accAmountPerShare;\r\n\r\n        // Update reward variables of the given pool to be up-to-date.\r\n    function update() internal \r\n    {\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n\r\n        if (totalProductivity == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = block.number.sub(lastRewardBlock);\r\n        uint256 reward = multiplier.mul(wasabiPerBlock);\r\n\r\n        if(reward + totalSupply > maxMintCumulation) reward = maxMintCumulation.sub(totalSupply);\r\n\r\n        balanceOf[address(this)] = balanceOf[address(this)].add(reward);\r\n        totalSupply = totalSupply.add(reward);\r\n\r\n        accAmountPerShare = accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        lastRewardBlock = block.number;\r\n    }\r\n\r\n    // External function call\r\n    // This function increase user's productivity and updates the global productivity.\r\n    // the users' actual share percentage will calculated by:\r\n    // Formula:     user_productivity / global_productivity\r\n    function increaseProductivity(address user, uint value) external override requireImpl returns (uint) {\r\n        if(mintCumulation >= maxMintCumulation)\r\n            return 0;\r\n\r\n        require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO');\r\n\r\n        UserInfo storage userInfo = users[user];\r\n        update();\r\n        if (userInfo.amount > 0) {\r\n            uint pending = userInfo.amount.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n            if(pending + mintCumulation > maxMintCumulation) pending = maxMintCumulation.sub(mintCumulation);\r\n            _transfer(address(this), user, pending);\r\n            mintCumulation = mintCumulation.add(pending);\r\n        }\r\n\r\n        totalProductivity = totalProductivity.add(value);\r\n\r\n        userInfo.amount = userInfo.amount.add(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        emit ProductivityIncreased(user, value);\r\n        return userInfo.amount;\r\n    }\r\n\r\n    // External function call \r\n    // This function will decreases user's productivity by value, and updates the global productivity\r\n    // it will record which block this is happenning and accumulates the area of (productivity * time)\r\n    function decreaseProductivity(address user, uint value) external override requireImpl returns (uint) {\r\n        if(mintCumulation >= maxMintCumulation)\r\n            return 0;\r\n\r\n        require(value > 0, 'INSUFFICIENT_PRODUCTIVITY');\r\n        \r\n        UserInfo storage userInfo = users[user];\r\n        require(userInfo.amount >= value, \"WASABI: FORBIDDEN\");\r\n        update();\r\n        uint pending = userInfo.amount.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n        if(pending + mintCumulation > maxMintCumulation) pending = maxMintCumulation.sub(mintCumulation);\r\n        _transfer(address(this), user, pending);\r\n        mintCumulation = mintCumulation.add(pending);\r\n        userInfo.amount = userInfo.amount.sub(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        totalProductivity = totalProductivity.sub(value);\r\n\r\n        emit ProductivityDecreased(user, value);\r\n        return pending;\r\n    }\r\n\r\n    function take() external override view returns (uint) {\r\n        if(mintCumulation >= maxMintCumulation)\r\n            return 0;\r\n\r\n        UserInfo storage userInfo = users[msg.sender];\r\n        uint _accAmountPerShare = accAmountPerShare;\r\n        // uint256 lpSupply = totalProductivity;\r\n        if (block.number > lastRewardBlock && totalProductivity != 0) {\r\n            uint multiplier = block.number.sub(lastRewardBlock);\r\n            uint reward = multiplier.mul(wasabiPerBlock);\r\n            _accAmountPerShare = _accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        }\r\n        uint pending = userInfo.amount.mul(_accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n        if(pending + mintCumulation > maxMintCumulation) pending = maxMintCumulation.sub(mintCumulation);\r\n        return pending;\r\n    }\r\n\r\n    function takeWithAddress(address user) external view returns (uint) {\r\n        if(mintCumulation >= maxMintCumulation)\r\n            return 0;\r\n\r\n        UserInfo storage userInfo = users[user];\r\n        uint _accAmountPerShare = accAmountPerShare;\r\n        // uint256 lpSupply = totalProductivity;\r\n        if (block.number > lastRewardBlock && totalProductivity != 0) {\r\n            uint multiplier = block.number.sub(lastRewardBlock);\r\n            uint reward = multiplier.mul(wasabiPerBlock);\r\n            _accAmountPerShare = _accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        }\r\n        uint pending = userInfo.amount.mul(_accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n        if(pending + mintCumulation > maxMintCumulation) pending = maxMintCumulation.sub(mintCumulation);\r\n        return pending;\r\n    }\r\n\r\n    // Returns how much a user could earn plus the giving block number.\r\n    function takeWithBlock() external override view returns (uint, uint) {\r\n        if(mintCumulation >= maxMintCumulation)\r\n            return (0, block.number);\r\n\r\n        UserInfo storage userInfo = users[msg.sender];\r\n        uint _accAmountPerShare = accAmountPerShare;\r\n        // uint256 lpSupply = totalProductivity;\r\n        if (block.number > lastRewardBlock && totalProductivity != 0) {\r\n            uint multiplier = block.number.sub(lastRewardBlock);\r\n            uint reward = multiplier.mul(wasabiPerBlock);\r\n            _accAmountPerShare = _accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        }\r\n        uint pending = userInfo.amount.mul(_accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n        if(pending + mintCumulation > maxMintCumulation) pending = maxMintCumulation.sub(mintCumulation);\r\n        return (pending, block.number);\r\n        // return (userInfo.amount.mul(_accAmountPerShare).div(1e12).sub(userInfo.rewardDebt), block.number);\r\n    }\r\n\r\n\r\n    // External function call\r\n    // When user calls this function, it will calculate how many token will mint to user from his productivity * time\r\n    // Also it calculates global token supply from last time the user mint to this time.\r\n    function mint(address to) external override lock returns (uint) {\r\n        require(to != address(0), '');\r\n        return 0;\r\n    }\r\n\r\n    // Returns how many productivity a user has and global has.\r\n    function getProductivity(address user) external override view returns (uint, uint) {\r\n        return (users[user].amount, totalProductivity);\r\n    }\r\n\r\n    // Returns the current gorss product rate.\r\n    function interestsPerBlock() external override view returns (uint) {\r\n        return accAmountPerShare;\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/libraries/TransferHelper.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity >=0.6.0;\r\n\r\nlibrary SushiHelper {\r\n    function deposit(address masterChef, uint256 pid, uint256 amount) internal {\r\n        (bool success, bytes memory data) = masterChef.call(abi.encodeWithSelector(0xe2bbb158, pid, amount));\r\n        require(success && data.length == 0, \"SushiHelper: DEPOSIT FAILED\");\r\n    }\r\n\r\n    function withdraw(address masterChef, uint256 pid, uint256 amount) internal {\r\n        (bool success, bytes memory data) = masterChef.call(abi.encodeWithSelector(0x441a3e70, pid, amount));\r\n        require(success && data.length == 0, \"SushiHelper: WITHDRAW FAILED\");\r\n    }\r\n\r\n    function pendingSushi(address masterChef, uint256 pid, address user) internal returns (uint256 amount) {\r\n        (bool success, bytes memory data) = masterChef.call(abi.encodeWithSelector(0x195426ec, pid, user));\r\n        require(success && data.length != 0, \"SushiHelper: WITHDRAW FAILED\");\r\n        amount = abi.decode(data, (uint256));\r\n    }\r\n\r\n    uint public constant _nullID = 0xffffffffffffffffffffffffffffffff;\r\n    function nullID() internal pure returns(uint) {\r\n        return _nullID;\r\n    }\r\n}\r\n\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/interface/IWasabi.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IWasabi {\r\n    function getOffer(address  _lpToken,  uint index) external view returns (address offer);\r\n    function getOfferLength(address _lpToken) external view returns (uint length);\r\n    function pool(address _token) external view returns (uint);\r\n    function increaseProductivity(uint amount) external;\r\n    function decreaseProductivity(uint amount) external;\r\n    function decreaseProductivityAll() external;\r\n    function tokenAddress() external view returns(address);\r\n    function addTakerOffer(address _offer, address _user) external returns (uint);\r\n    function getUserOffer(address _user, uint _index) external view returns (address);\r\n    function getUserOffersLength(address _user) external view returns (uint length);\r\n    function getTakerOffer(address _user, uint _index) external view returns (address);\r\n    function getTakerOffersLength(address _user) external view returns (uint length);\r\n    function offerStatus() external view returns(uint amountIn, address masterChef, uint sushiPid);\r\n    function cancel(address _from, address _sushi, uint amountWasabi) external ;\r\n    function take(address taker,uint amountWasabi) external;\r\n    function payback(address _from) external;\r\n    function close(address _from, uint8 _state, address _sushi) external  returns (address tokenToOwner, address tokenToTaker, uint amountToOwner, uint amountToTaker);\r\n    function upgradeGovernance(address _newGovernor) external;\r\n    function acceptToken() external view returns(address);\r\n    function rewardAddress() external view returns(address);\r\n    function getTokensLength() external view returns (uint);\r\n    function tokens(uint _index) external view returns(address);\r\n    function offers(address _offer) external view returns(address tokenIn, address tokenOut, uint amountIn, uint amountOut, uint expire, uint interests, uint duration);\r\n    function getRateForOffer(address _offer) external view returns (uint offerFeeRate, uint offerInterestrate);\r\n}\r\n\r\n\r\n// Dependency file: contracts/WasabiOffer.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// pragma solidity >=0.5.16;\r\n// import \"contracts/libraries/SafeMath.sol\";\r\n// import \"contracts/libraries/TransferHelper.sol\";\r\n// import \"contracts/interface/IERC20.sol\";\r\n// import \"contracts/interface/IWasabi.sol\";\r\n// import \"contracts/WasabiToken.sol\";\r\n\r\ninterface IMasterChef {\r\n    function pendingSushi(uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function poolLength() external view returns (uint256);\r\n}\r\n\r\ncontract Offer {\r\n    using SafeMath for uint256;\r\n    //\r\n    enum OfferState {Created, Opened, Taken, Paidback, Expired, Closed}\r\n    address public wasabi;\r\n    address public owner;\r\n    address public taker;\r\n    address public sushi;\r\n\r\n    uint8 public state = 0;\r\n\r\n    event StateChange(\r\n        uint256 _prev,\r\n        uint256 _curr,\r\n        address from,\r\n        address to,\r\n        address indexed token,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    constructor() public {\r\n        wasabi = msg.sender;\r\n    }\r\n\r\n    function getState() public view returns (uint256 _state) {\r\n        _state = uint256(state);\r\n    }\r\n\r\n    function transferToken(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        require(msg.sender == wasabi, \"WASABI OFFER : TRANSFER PERMISSION DENY\");\r\n        TransferHelper.safeTransfer(token, to, amount);\r\n    }\r\n\r\n    function initialize(\r\n        address _owner,\r\n        address _sushi,\r\n        uint256 sushiPid,\r\n        address tokenIn,\r\n        address masterChef,\r\n        uint256 amountIn\r\n    ) external {\r\n        require(msg.sender == wasabi, \"WASABI OFFER : INITIALIZE PERMISSION DENY\");\r\n        require(state == 0);\r\n        owner = _owner;\r\n        sushi = _sushi;\r\n        state = 1;\r\n        if (sushiPid != SushiHelper.nullID()) {\r\n            TransferHelper.safeApprove(tokenIn, masterChef, amountIn);\r\n            SushiHelper.deposit(masterChef, sushiPid, amountIn);\r\n        }\r\n    }\r\n\r\n    function cancel() public returns (uint256 amount) {\r\n        require(msg.sender == owner, \"WASABI OFFER : CANCEL SENDER IS OWNER\");\r\n        (uint256 _amount, address _masterChef, uint256 _sushiPid) = IWasabi(\r\n            wasabi\r\n        )\r\n            .offerStatus();\r\n        state = 5;\r\n        if (_sushiPid != SushiHelper.nullID()) {\r\n            SushiHelper.withdraw(_masterChef, _sushiPid, _amount);\r\n        }\r\n        \r\n        IWasabi(wasabi).cancel(msg.sender, sushi, amount);\r\n    }\r\n\r\n    function take() external {\r\n        require(state == 1, \"WASABI OFFER : TAKE STATE ERROR\");\r\n        require(msg.sender != owner, \"WASABI OFFER : TAKE SENDER IS OWNER\");\r\n        state = 2;\r\n        address tokenAddress = IWasabi(wasabi).tokenAddress();\r\n        uint256 amountWasabi = WasabiToken(tokenAddress).mint(address(this));\r\n        IWasabi(wasabi).take(msg.sender, amountWasabi);\r\n        taker = msg.sender;\r\n    }\r\n\r\n    function payback() external {\r\n        require(state == 2, \"WASABI: payback\");\r\n        state = 3;\r\n        IWasabi(wasabi).payback(msg.sender);\r\n\r\n        (uint256 _amount, address _masterChef, uint256 _sushiPid) = IWasabi(\r\n            wasabi\r\n        )\r\n            .offerStatus();\r\n\r\n        if (_sushiPid != SushiHelper.nullID()) {\r\n            SushiHelper.withdraw(_masterChef, _sushiPid, _amount);\r\n        }\r\n        uint8 oldState = state;\r\n        state = 5;\r\n        \r\n        IWasabi(wasabi).close(msg.sender, oldState, sushi);\r\n    }\r\n\r\n    function close()\r\n        external\r\n        returns (\r\n            address,\r\n            address,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        require(state != 5, \"WASABI OFFER : TAKE STATE ERROR\");\r\n        (uint256 _amount, address _masterChef, uint256 _sushiPid) = IWasabi(\r\n            wasabi\r\n        )\r\n            .offerStatus();\r\n        if (_sushiPid != SushiHelper.nullID()) {\r\n            SushiHelper.withdraw(_masterChef, _sushiPid, _amount);\r\n        }\r\n        uint8 oldState = state;\r\n        state = 5;\r\n        return IWasabi(wasabi).close(msg.sender, oldState, sushi);\r\n    }\r\n\r\n    function getEstimatedWasabi() external view returns (uint256 amount) {\r\n        address tokenAddress = IWasabi(wasabi).tokenAddress();\r\n        amount = WasabiToken(tokenAddress).take();\r\n    }\r\n\r\n    function getEstimatedSushi() external view returns (uint256 amount) {\r\n        (, address _masterChef, uint256 _sushiPid) = IWasabi(wasabi)\r\n            .offerStatus();\r\n        if(_sushiPid < IMasterChef(_masterChef).poolLength())\r\n        {\r\n            amount = IMasterChef(_masterChef).pendingSushi(\r\n                _sushiPid,\r\n                address(this)\r\n            );    \r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Root file: contracts/Wasabi.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.5.16;\r\n// import 'contracts/interface/IERC20.sol';\r\n// import 'contracts/WasabiToken.sol';\r\n// import 'contracts/WasabiOffer.sol';\r\n// import 'contracts/libraries/TransferHelper.sol';\r\n\r\ncontract Wasabi is UpgradableGovernance\r\n{\r\n    using SafeMath for uint;\r\n    uint public constant version = 2;\r\n    address public rewardAddress;\r\n    address public tokenAddress;\r\n    address public sushiAddress;\r\n    address public teamAddress;\r\n    address public masterChef;\r\n    address public acceptToken;\r\n    bytes32 public contractCodeHash;\r\n    mapping(address => address[]) public allOffers;\r\n    uint public feeRate;\r\n    uint public interestRate;\r\n    uint public startBlock;\r\n\r\n    struct SushiStruct {\r\n        uint val;\r\n        bool isValid;\r\n    }\r\n    \r\n    mapping(address => uint) public offerStats;\r\n    mapping(address => address[]) public userOffers;\r\n    mapping(address => uint) public pool;\r\n    mapping(address => address[]) public takerOffers;\r\n    mapping(address => SushiStruct) public sushiPids;\r\n    address[] public tokens;\r\n  \r\n    struct OfferStruct {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint amountIn;\r\n        uint amountOut;\r\n        uint expire;\r\n        uint interests;\r\n        uint duration;\r\n        uint feeRate;\r\n        uint interestrate;\r\n        address owner;\r\n        address taker;\r\n        address masterChef;\r\n        uint sushiPid;\r\n        uint productivity;\r\n    }\r\n    \r\n    mapping(address => OfferStruct) public offers;\r\n\r\n    function setPoolShare(address _token, uint _share) requireGovernor public {\r\n        if (pool[_token] == 0) {\r\n            tokens.push(_token);\r\n        }\r\n        pool[_token] = _share;\r\n    }\r\n\r\n    function setTeamAddress(address _newAddress) requireGovernor public {\r\n        teamAddress = _newAddress;\r\n    }\r\n\r\n    function migrateToken(address _offer, address _tokenCollateral) requireGovernor public {\r\n        offers[_offer].tokenIn = _tokenCollateral;\r\n    }\r\n\r\n    function getTokens() external view returns (address[] memory) {\r\n        return tokens;\r\n    }\r\n\r\n    function getTokensLength() external view returns (uint) {\r\n        return tokens.length;\r\n    }\r\n\r\n    function setFeeRate(uint _feeRate) requireGovernor public  {\r\n        feeRate = _feeRate;\r\n    }\r\n\r\n    function setInterestRate(uint _interestRate) requireGovernor public  {\r\n        interestRate = _interestRate;\r\n    }\r\n\r\n    function setStartBlock(uint _startBlock) requireGovernor public  {\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    function setSushiPid(address _token, uint _pid) requireGovernor public  {\r\n        sushiPids[_token].val = _pid;\r\n        sushiPids[_token].isValid = (_pid != SushiHelper.nullID()) ? true : false;\r\n    }\r\n\r\n    function getRateForOffer(address _offer) external view returns (uint offerFeeRate, uint offerInterestrate) {\r\n        OfferStruct memory offer = offers[_offer];\r\n        offerFeeRate = offer.feeRate;\r\n        offerInterestrate = offer.interestrate;\r\n    }\r\n\r\n    event OfferCreated(address indexed _tokenIn, address indexed _tokenOut, uint _amountIn, uint _amountOut, uint _duration, uint _interests, address indexed _offer);\r\n    event OfferChanged(address indexed _offer, uint _state);\r\n\r\n    constructor(address _rewardAddress, address _wasabiTokenAddress, address _sushiAddress, address _masterChef, address _acceptToken, address _teamAddress) public  {\r\n        rewardAddress = _rewardAddress;\r\n        teamAddress = _teamAddress;\r\n        tokenAddress = _wasabiTokenAddress;\r\n        sushiAddress = _sushiAddress;\r\n        masterChef = _masterChef;\r\n        feeRate = 100;\r\n        interestRate = 1000;\r\n        acceptToken = _acceptToken;\r\n    }\r\n\r\n    function createOffer(\r\n        address[2] memory _addrs,\r\n        uint[4] memory _uints) public returns(address offer, uint productivity) \r\n    {\r\n        require(_addrs[0] != _addrs[1],     \"WASABI: INVALID TOKEN IN&OUT\");\r\n        require(_uints[3] < _uints[1],      \"WASABI: INVALID INTERESTS\");\r\n        require(pool[_addrs[0]] > 0,        \"WASABI: INVALID TOKEN\");\r\n        require(_uints[1] > 0,              \"WASABI: INVALID AMOUNT OUT\");\r\n        // require(_tokenOut == 0xdAC17F958D2ee523a2206206994597C13D831ec7, \"only support USDT by now.\");\r\n        require(_addrs[1] == acceptToken,   \"WASABI: ONLY USDT SUPPORTED\");\r\n        require(block.number >= startBlock, \"WASABI: NOT READY\");\r\n\r\n        bytes memory bytecode = type(Offer).creationCode;\r\n        if (uint(contractCodeHash) == 0) {\r\n            contractCodeHash = keccak256(bytecode);\r\n        }\r\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, _addrs[0], _addrs[1], _uints[0], _uints[1], _uints[2], _uints[3], block.number));\r\n        assembly {\r\n            offer := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        productivity = pool[_addrs[0]] * _uints[0];\r\n        uint sushiPid = sushiPids[_addrs[0]].isValid ? sushiPids[_addrs[0]].val : SushiHelper.nullID();\r\n\r\n        offers[offer] = OfferStruct({\r\n            productivity    : productivity,\r\n            tokenIn         : _addrs[0],\r\n            tokenOut        : _addrs[1],\r\n            amountIn        : _uints[0],\r\n            amountOut       : _uints[1],\r\n            expire          : 0,\r\n            interests       : _uints[3],\r\n            duration        : _uints[2],\r\n            feeRate         : feeRate,\r\n            interestrate    : interestRate,\r\n            owner           : msg.sender,\r\n            taker           : address(0),\r\n            masterChef      : masterChef,\r\n            sushiPid        : sushiPid\r\n        });\r\n\r\n        WasabiToken(tokenAddress).increaseProductivity(offer, productivity);\r\n        TransferHelper.safeTransferFrom(_addrs[0], msg.sender, offer, _uints[0]);\r\n        offerStats[offer] = 1;\r\n        Offer(offer).initialize(msg.sender, sushiAddress, sushiPid, _addrs[0], masterChef, _uints[0]);\r\n        \r\n        allOffers[_addrs[0]].push(offer);\r\n    \r\n        userOffers[msg.sender].push(offer);\r\n\r\n        emit OfferCreated(_addrs[0], _addrs[1], _uints[0], _uints[1], _uints[2], _uints[3], offer);\r\n    }\r\n    \r\n    function cancel(address _from, address sushi, uint amountWasabi) external {\r\n        require(offerStats[msg.sender] != 0, \"WASABI: CANCEL OFFER NOT FOUND\");\r\n        OfferStruct storage offer = offers[msg.sender];\r\n\r\n        // send mined WASABI to owner.\r\n        if (offer.productivity > 0) {\r\n            amountWasabi = WasabiToken(tokenAddress).decreaseProductivity(msg.sender, offer.productivity);\r\n            uint amountWasabiTeam = amountWasabi.mul(1).div(10);\r\n            Offer(msg.sender).transferToken(tokenAddress, teamAddress, amountWasabiTeam);\r\n            Offer(msg.sender).transferToken(tokenAddress, offer.owner, amountWasabi - amountWasabiTeam);\r\n        }\r\n\r\n        // send mined SUSHI to owner.\r\n        if(offer.sushiPid != SushiHelper.nullID() && IERC20(sushi).balanceOf(msg.sender) > 0) {\r\n            Offer(msg.sender).transferToken(sushi, _from, IERC20(sushi).balanceOf(msg.sender));\r\n        }\r\n\r\n        // send collateral to owner.\r\n        Offer(msg.sender).transferToken(offer.tokenIn, offer.owner, IERC20(offer.tokenIn).balanceOf(address(msg.sender)));\r\n        \r\n        OfferChanged(msg.sender, Offer(msg.sender).state());\r\n    }\r\n    \r\n    function take(address _from, uint amountWasabi) external {\r\n        require(offerStats[msg.sender] != 0, \"WASABI: TAKE OFFER NOT FOUND\");\r\n        OfferStruct storage offer = offers[msg.sender];\r\n        offer.taker = _from;\r\n        offer.expire = offer.duration.add(block.number);\r\n\r\n        // send fees to reward address.\r\n        uint platformFee = offer.amountOut.mul(offer.feeRate).div(10000); \r\n        uint feeAmount = platformFee.add(offer.interests.mul(offer.interestrate).div(10000)); \r\n        TransferHelper.safeTransferFrom(offer.tokenOut, _from, rewardAddress, feeAmount);\r\n        \r\n        // send lend money to owner.\r\n        uint amountToOwner = offer.amountOut.sub(offer.interests.add(platformFee));\r\n        TransferHelper.safeTransferFrom(offer.tokenOut, _from, offer.owner, amountToOwner); \r\n        \r\n        // send the rest the the contract.\r\n        TransferHelper.safeTransferFrom(offer.tokenOut, _from, msg.sender, offer.amountOut.sub(amountToOwner).sub(feeAmount));        \r\n\r\n        // mint WASABI to the owner and cut 1/10 to the reward address.\r\n        if (offer.productivity > 0) {\r\n            amountWasabi = WasabiToken(tokenAddress).decreaseProductivity(msg.sender, offer.productivity);\r\n            uint amountWasabiTeam = amountWasabi.mul(1).div(10);\r\n            Offer(msg.sender).transferToken(tokenAddress, teamAddress, amountWasabiTeam);\r\n            Offer(msg.sender).transferToken(tokenAddress, offer.owner, amountWasabi - amountWasabiTeam);\r\n        }\r\n        \r\n        addTakerOffer(msg.sender, _from);\r\n        OfferChanged(msg.sender, Offer(msg.sender).state());\r\n    }\r\n    \r\n\r\n    function payback(address _from) external {\r\n        require(offerStats[msg.sender] != 0, \"WASABI: PAYBACK OFFER NOT FOUND\");\r\n        OfferStruct storage offer = offers[msg.sender];\r\n        TransferHelper.safeTransferFrom(offer.tokenOut, _from, msg.sender, offer.amountOut);\r\n        OfferChanged(msg.sender, Offer(msg.sender).state());\r\n    }\r\n    \r\n    function close(address _from, uint8 _state, address sushi) external returns (address tokenToOwner, address tokenToTaker, uint amountToOwner, uint amountToTaker) {\r\n        require(offerStats[msg.sender] != 0, \"WASABI: CLOSE OFFER NOT FOUND\");\r\n        OfferStruct storage offer = offers[msg.sender];\r\n        require(_state == 3 || block.number >= offer.expire, \"WASABI: INVALID STATE\");\r\n        require(_from == offer.owner || _from == offer.taker, \"WASABI: INVALID CALLEE\");\r\n\r\n        // if paid back.\r\n        if(_state == 3) {\r\n            amountToTaker = offer.amountOut.add(offer.interests.sub(offer.interests.mul(offer.interestrate).div(10000)));\r\n            tokenToTaker = offer.tokenOut;\r\n            Offer(msg.sender).transferToken(tokenToTaker,  offer.taker, amountToTaker);\r\n            amountToOwner = IERC20(offer.tokenIn).balanceOf(address(msg.sender));\r\n            tokenToOwner = offer.tokenIn;\r\n            Offer(msg.sender).transferToken(tokenToOwner, offer.owner, amountToOwner);\r\n            if(offer.sushiPid != SushiHelper.nullID())\r\n                Offer(msg.sender).transferToken(sushi, offer.owner, IERC20(sushi).balanceOf(msg.sender));\r\n        }\r\n        // deal with if the offer expired.\r\n        else if(block.number >= offer.expire) {\r\n            amountToTaker = IERC20(offer.tokenIn).balanceOf(address(msg.sender));\r\n            tokenToTaker = offer.tokenIn;\r\n            Offer(msg.sender).transferToken(tokenToTaker, offer.taker, amountToTaker);\r\n\r\n            uint  amountRest = IERC20(offer.tokenOut).balanceOf(msg.sender);\r\n            Offer(msg.sender).transferToken(offer.tokenOut, offer.taker, amountRest);\r\n            if(offer.sushiPid != SushiHelper.nullID())\r\n                Offer(msg.sender).transferToken(sushi, offer.taker, IERC20(sushi).balanceOf(msg.sender));\r\n        }\r\n        OfferChanged(msg.sender, Offer(msg.sender).state());\r\n    }\r\n    \r\n    function offerStatus() external view returns(uint amountIn, address _masterChef, uint sushiPid) {\r\n        OfferStruct storage offer = offers[msg.sender];\r\n        amountIn = offer.amountIn;\r\n        _masterChef = offer.masterChef;\r\n        sushiPid = offer.sushiPid;\r\n    }\r\n    \r\n \r\n    function  getOffer(address  _lpToken,  uint index) external view returns (address offer) {\r\n        offer = allOffers[_lpToken][index];\r\n    }\r\n\r\n    function getOfferLength(address _lpToken) external view returns (uint length) {\r\n        length = allOffers[_lpToken].length;\r\n    }\r\n\r\n    function getUserOffer(address _user, uint _index) external view returns (address) {\r\n        return userOffers[_user][_index];\r\n    }\r\n\r\n    function getUserOffersLength(address _user) external view returns (uint length) {\r\n        length = userOffers[_user].length;\r\n    }\r\n\r\n    function addTakerOffer(address _offer, address _user) public returns (uint) {\r\n        require(msg.sender == _offer, 'WASABI: FORBIDDEN');\r\n        takerOffers[_user].push(_offer);\r\n        return takerOffers[_user].length;\r\n    }\r\n\r\n    function getTakerOffer(address _user, uint _index) external view returns (address) {\r\n        return takerOffers[_user][_index];\r\n    }\r\n\r\n    function getTakerOffersLength(address _user) external view returns (uint length) {\r\n        length = takerOffers[_user].length;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wasabiTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_masterChef\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acceptToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_offer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_state\",\"type\":\"uint256\"}],\"name\":\"OfferChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interests\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_offer\",\"type\":\"address\"}],\"name\":\"OfferCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_offer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addTakerOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allOffers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sushi\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWasabi\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_state\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sushi\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenToOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenToTaker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToOwner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToTaker\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"_addrs\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_uints\",\"type\":\"uint256[4]\"}],\"name\":\"createOffer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"offer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"productivity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOffer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"offer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"getOfferLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_offer\",\"type\":\"address\"}],\"name\":\"getRateForOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"offerFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerInterestrate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTakerOffer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTakerOffersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserOffer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserOffersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterChef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_offer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenCollateral\",\"type\":\"address\"}],\"name\":\"migrateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"offerStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offerStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_masterChef\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sushiPid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"offers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expire\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interests\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestrate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"masterChef\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sushiPid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productivity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"payback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRate\",\"type\":\"uint256\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_share\",\"type\":\"uint256\"}],\"name\":\"setPoolShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"setSushiPid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setTeamAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sushiPids\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWasabi\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"takerOffers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"upgradeGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userOffers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Wasabi","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000095c673d34034332f0dc74d3484eb9524d1318e500000000000000000000000075019407b9f8f30f2b1fd3e4905a0a39ecc148170000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe2000000000000000000000000c2edad668740f1aa35e4d8f227fb8e17dca888cd000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000006290f0d9345db83efb106178379a0ee4c4a0c64c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a2b98bdef8d5beece67c54b2f94df976f3b76b324be29912c99bd7bf6f16689f"}]}