{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n/*\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address payable public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address payable _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address payable _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\nlibrary ERC20SafeTransfer {\r\n    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\r\n        (success,) = _tokenAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _value));\r\n        require(success, \"Transfer failed\");\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        (success,) = _tokenAddress.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _from, _to, _value));\r\n        require(success, \"Transfer From failed\");\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\r\n        (success,) = _tokenAddress.call(abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _value));\r\n        require(success,  \"Approve failed\");\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function fetchReturnData() internal pure returns (bool success){\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 {\r\n                success := 1\r\n            }\r\n            case 32 {\r\n                returndatacopy(0, 0, 32)\r\n                success := mload(0)\r\n            }\r\n            default {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/// @title A contract which allows its owner to withdraw any ether which is contained inside\r\ncontract Withdrawable is Ownable {\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _token The address of the token that the user wants to withdraw\r\n    /// @param _amount The amount of tokens that the caller wants to withdraw\r\n    /// @return bool value indicating whether the transfer was successful\r\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\r\n        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\r\n    }\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _amount The amount of ether that the caller wants to withdraw\r\n    function withdrawETH(uint256 _amount) external onlyOwner {\r\n        owner.transfer(_amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"Contract is paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused, \"Contract not paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function decimals() public view returns (uint256);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/lib/TokenTransferProxy.sol\r\n\r\n/*\r\n\r\n  Copyright 2018 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\r\n/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\r\ncontract TokenTransferProxy is Ownable {\r\n\r\n    /// @dev Only authorized addresses can invoke functions with this modifier.\r\n    modifier onlyAuthorized {\r\n        require(authorized[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier targetAuthorized(address target) {\r\n        require(authorized[target]);\r\n        _;\r\n    }\r\n\r\n    modifier targetNotAuthorized(address target) {\r\n        require(!authorized[target]);\r\n        _;\r\n    }\r\n\r\n    mapping (address => bool) public authorized;\r\n    address[] public authorities;\r\n\r\n    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\r\n    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n\r\n    /// @dev Authorizes an address.\r\n    /// @param target Address to authorize.\r\n    function addAuthorizedAddress(address target)\r\n        public\r\n        onlyOwner\r\n        targetNotAuthorized(target)\r\n    {\r\n        authorized[target] = true;\r\n        authorities.push(target);\r\n        emit LogAuthorizedAddressAdded(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Removes authorizion of an address.\r\n    /// @param target Address to remove authorization from.\r\n    function removeAuthorizedAddress(address target)\r\n        public\r\n        onlyOwner\r\n        targetAuthorized(target)\r\n    {\r\n        delete authorized[target];\r\n        for (uint i = 0; i < authorities.length; i++) {\r\n            if (authorities[i] == target) {\r\n                authorities[i] = authorities[authorities.length - 1];\r\n                authorities.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        emit LogAuthorizedAddressRemoved(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\r\n    /// @param token Address of token to transfer.\r\n    /// @param from Address to transfer token from.\r\n    /// @param to Address to transfer token to.\r\n    /// @param value Amount of token to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value)\r\n        public\r\n        onlyAuthorized\r\n        returns (bool)\r\n    {\r\n        require(ERC20SafeTransfer.safeTransferFrom(token, from, to, value));\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Public view functions\r\n     */\r\n\r\n    /// @dev Gets all authorized addresses.\r\n    /// @return Array of authorized addresses.\r\n    function getAuthorizedAddresses()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return authorities;\r\n    }\r\n}\r\n\r\n/*\r\n    Modified Util contract as used by Kyber Network\r\n*/\r\n\r\nlibrary Utils {\r\n\r\n    uint256 constant internal PRECISION = (10**18);\r\n    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint256 constant internal MAX_DECIMALS = 18;\r\n    uint256 constant internal ETH_DECIMALS = 18;\r\n    uint256 constant internal MAX_UINT = 2**256-1;\r\n    address constant internal ETH_ADDRESS = address(0x0);\r\n\r\n    // Currently constants can't be accessed from other contracts, so providing functions to do that here\r\n    function precision() internal pure returns (uint256) { return PRECISION; }\r\n    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\r\n    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\r\n    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\r\n    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\r\n    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\r\n    function eth_address() internal pure returns (address) { return ETH_ADDRESS; }\r\n\r\n    /// @notice Retrieve the number of decimals used for a given ERC20 token\r\n    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\r\n    /// ensure that an exception doesn't cause transaction failure\r\n    /// @param token the token for which we should retrieve the decimals\r\n    /// @return decimals the number of decimals in the given token\r\n    function getDecimals(address token)\r\n        internal\r\n        returns (uint256 decimals)\r\n    {\r\n        bytes4 functionSig = bytes4(keccak256(\"decimals()\"));\r\n\r\n        /// @dev Using assembly due to issues with current solidity `address.call()`\r\n        /// implementation: https://github.com/ethereum/solidity/issues/2884\r\n        assembly {\r\n            // Pointer to next free memory slot\r\n            let ptr := mload(0x40)\r\n            // Store functionSig variable at ptr\r\n            mstore(ptr,functionSig)\r\n            let functionSigLength := 0x04\r\n            let wordLength := 0x20\r\n\r\n            let success := call(\r\n                                gas, // Amount of gas\r\n                                token, // Address to call\r\n                                0, // ether to send\r\n                                ptr, // ptr to input data\r\n                                functionSigLength, // size of data\r\n                                ptr, // where to store output data (overwrite input)\r\n                                wordLength // size of output data (32 bytes)\r\n                               )\r\n\r\n            switch success\r\n            case 0 {\r\n                decimals := 0 // If the token doesn't implement `decimals()`, return 0 as default\r\n            }\r\n            case 1 {\r\n                decimals := mload(ptr) // Set decimals to return data from call\r\n            }\r\n            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\r\n        }\r\n    }\r\n\r\n    /// @dev Checks that a given address has its token allowance and balance set above the given amount\r\n    /// @param tokenOwner the address which should have custody of the token\r\n    /// @param tokenAddress the address of the token to check\r\n    /// @param tokenAmount the amount of the token which should be set\r\n    /// @param addressToAllow the address which should be allowed to transfer the token\r\n    /// @return bool true if the allowance and balance is set, false if not\r\n    function tokenAllowanceAndBalanceSet(\r\n        address tokenOwner,\r\n        address tokenAddress,\r\n        uint256 tokenAmount,\r\n        address addressToAllow\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\r\n            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\r\n        );\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal returns (uint) {\r\n        return calcDstQty(srcAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal returns (uint) {\r\n        return calcSrcQty(destAmount, getDecimals(address(src)), getDecimals(address(dest)), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns (uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n}\r\n\r\ncontract PartnerRegistry is Ownable, Pausable {\r\n\r\n    address target;\r\n    mapping(address => bool) partnerContracts;\r\n    address payable public companyBeneficiary;\r\n    uint256 public basePercentage;\r\n    PartnerRegistry public previousRegistry;\r\n\r\n    event PartnerRegistered(address indexed creator, address indexed beneficiary, address partnerContract);\r\n\r\n    constructor(PartnerRegistry _previousRegistry, address _target, address payable _companyBeneficiary, uint256 _basePercentage) public {\r\n        previousRegistry = _previousRegistry;\r\n        target = _target;\r\n        companyBeneficiary = _companyBeneficiary;\r\n        basePercentage = _basePercentage;\r\n    }\r\n\r\n    function registerPartner(address payable partnerBeneficiary, uint256 partnerPercentage) whenNotPaused external {\r\n        Partner newPartner = Partner(createClone());\r\n        newPartner.init(this,address(0x0000000000000000000000000000000000000000), 0, partnerBeneficiary, partnerPercentage);\r\n        partnerContracts[address(newPartner)] = true;\r\n        emit PartnerRegistered(address(msg.sender), partnerBeneficiary, address(newPartner));\r\n    }\r\n\r\n    function overrideRegisterPartner(\r\n        address payable _companyBeneficiary,\r\n        uint256 _companyPercentage,\r\n        address payable partnerBeneficiary,\r\n        uint256 partnerPercentage\r\n    ) external onlyOwner {\r\n        Partner newPartner = Partner(createClone());\r\n        newPartner.init(PartnerRegistry(0x0000000000000000000000000000000000000000), _companyBeneficiary, _companyPercentage, partnerBeneficiary, partnerPercentage);\r\n        partnerContracts[address(newPartner)] = true;\r\n        emit PartnerRegistered(address(msg.sender), partnerBeneficiary, address(newPartner));\r\n    }\r\n\r\n    function deletePartner(address _partnerAddress) external onlyOwner {\r\n        partnerContracts[_partnerAddress] = false;\r\n    }\r\n\r\n    function createClone() internal returns (address payable result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n\r\n    function isValidPartner(address partnerContract) external view returns(bool) {\r\n        return partnerContracts[partnerContract] || previousRegistry.isValidPartner(partnerContract);\r\n    }\r\n\r\n    function updateCompanyInfo(address payable newCompanyBeneficiary, uint256 newBasePercentage) external onlyOwner {\r\n        companyBeneficiary = newCompanyBeneficiary;\r\n        basePercentage = newBasePercentage;\r\n    }\r\n}\r\n\r\ncontract Partner {\r\n\r\n    address payable public partnerBeneficiary;\r\n    uint256 public partnerPercentage; //This is out of 1 ETH, e.g. 0.5 ETH is 50% of the fee\r\n\r\n    uint256 public overrideCompanyPercentage;\r\n    address payable public overrideCompanyBeneficiary;\r\n\r\n    PartnerRegistry public registry;\r\n\r\n    event LogPayout(\r\n        address[] tokens,\r\n        uint256[] amount\r\n    );\r\n\r\n    function init(\r\n        PartnerRegistry _registry,\r\n        address payable _overrideCompanyBeneficiary,\r\n        uint256 _overrideCompanyPercentage,\r\n        address payable _partnerBeneficiary,\r\n        uint256 _partnerPercentage\r\n    ) public {\r\n        require(registry == PartnerRegistry(0x0000000000000000000000000000000000000000) &&\r\n          overrideCompanyBeneficiary == address(0x0) && partnerBeneficiary == address(0x0)\r\n        );\r\n        overrideCompanyBeneficiary = _overrideCompanyBeneficiary;\r\n        overrideCompanyPercentage = _overrideCompanyPercentage;\r\n        partnerBeneficiary = _partnerBeneficiary;\r\n        partnerPercentage = _partnerPercentage;\r\n        overrideCompanyPercentage = _overrideCompanyPercentage;\r\n        registry = _registry;\r\n    }\r\n\r\n    function payout(\r\n        address[] memory tokens,\r\n        uint256[] memory amounts\r\n    ) public {\r\n        uint totalFeePercentage = getTotalFeePercentage();\r\n        address payable companyBeneficiary = companyBeneficiary();\r\n        // Payout both the partner and the company at the same time\r\n        for(uint256 index = 0; index<tokens.length; index++){\r\n            uint256 partnerAmount = SafeMath.div(SafeMath.mul(amounts[index], partnerPercentage), getTotalFeePercentage());\r\n            uint256 companyAmount = amounts[index] - partnerAmount;\r\n            if(tokens[index] == Utils.eth_address()){\r\n                partnerBeneficiary.transfer(partnerAmount);\r\n                companyBeneficiary.transfer(companyAmount);\r\n            } else {\r\n                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\r\n                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\r\n            }\r\n        }\r\n\temit LogPayout(tokens,amounts);\r\n    }\r\n\r\n    function getTotalFeePercentage() public view returns (uint256){\r\n        return partnerPercentage + companyPercentage();\r\n    }\r\n\r\n    function companyPercentage() public view returns (uint256){\r\n        if(registry != PartnerRegistry(0x0000000000000000000000000000000000000000)){\r\n            return Math.max(registry.basePercentage(), partnerPercentage);\r\n        } else {\r\n            return overrideCompanyPercentage;\r\n        }\r\n    }\r\n\r\n    function companyBeneficiary() public view returns (address payable) {\r\n        if(registry != PartnerRegistry(0x0000000000000000000000000000000000000000)){\r\n            return registry.companyBeneficiary();\r\n        } else {\r\n            return overrideCompanyBeneficiary;\r\n        }    \r\n    }\r\n\r\n    function() external payable {\r\n\r\n    }\r\n}\r\n\r\nlibrary TokenBalanceLibrary {\r\n    struct TokenBalance {\r\n        address tokenAddress;\r\n        uint256 balance;\r\n    }\r\n\r\n    function findToken(TokenBalance[20] memory balances, address token)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        for (uint256 index = 0; index < balances.length; index++) {\r\n            if (balances[index].tokenAddress == token) {\r\n                return index;\r\n            } else if (\r\n                index != 0 && balances[index].tokenAddress == address(0x0)\r\n            ) {\r\n                balances[index] = TokenBalance(token, 0);\r\n                return index;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addBalance(\r\n        TokenBalance[20] memory balances,\r\n        address tokenAddress,\r\n        uint256 amountToAdd\r\n    ) internal pure {\r\n        uint256 tokenIndex = findToken(balances, tokenAddress);\r\n        addBalance(balances, tokenIndex, amountToAdd);\r\n    }\r\n\r\n    function addBalance(\r\n        TokenBalance[20] memory balances,\r\n        uint256 balanceIndex,\r\n        uint256 amountToAdd\r\n    ) internal pure {\r\n        balances[balanceIndex].balance += amountToAdd;\r\n    }\r\n\r\n    function removeBalance(\r\n        TokenBalance[20] memory balances,\r\n        address tokenAddress,\r\n        uint256 amountToRemove\r\n    ) internal pure {\r\n        uint256 tokenIndex = findToken(balances, tokenAddress);\r\n        removeBalance(balances, tokenIndex, amountToRemove);\r\n    }\r\n\r\n    function removeBalance(\r\n        TokenBalance[20] memory balances,\r\n        uint256 balanceIndex,\r\n        uint256 amountToRemove\r\n    ) internal pure {\r\n        balances[balanceIndex].balance -= amountToRemove;\r\n    }\r\n}\r\n\r\n/* import \"../lib/Logger.sol\"; */\r\n\r\n/// @title Interface for all exchange handler contracts\r\ncontract ExchangeHandler is Withdrawable, Pausable {\r\n\r\n    /*\r\n    *   State Variables\r\n    */\r\n\r\n    /* Logger public logger; */\r\n    /*\r\n    *   Modifiers\r\n    */\r\n\r\n    function performOrder(\r\n        bytes memory genericPayload,\r\n        uint256 availableToSpend,\r\n        uint256 targetAmount,\r\n        bool targetAmountIsSource\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder);\r\n\r\n}\r\n\r\ninterface IGST2 {\r\n    function freeUpTo(uint256) external returns (uint256);\r\n}\r\n\r\n\r\n/// @title The primary contract for Totle\r\ncontract TotlePrimary is Withdrawable, Pausable {\r\n    /*\r\n     *   State Variables\r\n     */\r\n\r\n    IGST2 public constant GAS_TOKEN = IGST2(\r\n        0x0000000000b3F879cb30FE243b4Dfee438691c04\r\n    );\r\n    TokenTransferProxy public tokenTransferProxy;\r\n    mapping(address => bool) public signers;\r\n    uint256 public MIN_REFUND_GAS_PRICE = 20000000000;\r\n    /*\r\n     *   Types\r\n     */\r\n\r\n    // Structs\r\n    struct Order {\r\n        address payable exchangeHandler;\r\n        bytes encodedPayload;\r\n        uint256 minSourceAmount;\r\n        uint256 maxSourceAmount;\r\n    }\r\n\r\n    struct Trade {\r\n        address sourceToken;\r\n        address destinationToken;\r\n        uint256 amount;\r\n        bool isSourceAmount; //true if amount is sourceToken, false if it's destinationToken\r\n        Order[] orders;\r\n    }\r\n\r\n    struct Swap {\r\n        Trade[] trades;\r\n        uint256 minimumExchangeRate;\r\n        uint256 minimumDestinationAmount;\r\n        uint256 sourceAmount;\r\n        uint256 tradeToTakeFeeFrom;\r\n        bool takeFeeFromSource; //Takes the fee before the trade if true, takes it after if false\r\n        address payable redirectAddress;\r\n        bool required;\r\n    }\r\n\r\n    struct SwapCollection {\r\n        Swap[] swaps;\r\n        address payable partnerContract;\r\n        uint256 expirationBlock;\r\n        bytes32 id;\r\n        uint256 maxGasPrice;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /*\r\n     *   Events\r\n     */\r\n\r\n    event LogSwapCollection(\r\n        bytes32 indexed id,\r\n        address indexed partnerContract,\r\n        address indexed user\r\n    );\r\n\r\n    event LogSwap(\r\n        bytes32 indexed id,\r\n        address sourceAsset,\r\n        address destinationAsset,\r\n        uint256 sourceAmount,\r\n        uint256 destinationAmount,\r\n        address feeAsset,\r\n        uint256 feeAmount\r\n    );\r\n\r\n    /// @notice Constructor\r\n    /// @param _tokenTransferProxy address of the TokenTransferProxy\r\n    /// @param _signer the suggester's address that signs the payloads. More can be added with add/removeSigner functions\r\n    constructor(address _tokenTransferProxy, address _signer) public {\r\n        tokenTransferProxy = TokenTransferProxy(_tokenTransferProxy);\r\n        signers[_signer] = true;\r\n    }\r\n\r\n    /*\r\n     *   Public functions\r\n     */\r\n\r\n    modifier notExpired(SwapCollection memory swaps) {\r\n        require(swaps.expirationBlock > block.number, \"Expired\");\r\n        _;\r\n    }\r\n\r\n    modifier validSignature(SwapCollection memory swaps) {\r\n        bytes32 hash = keccak256(\r\n            abi.encode(\r\n                swaps.swaps,\r\n                swaps.partnerContract,\r\n                swaps.expirationBlock,\r\n                swaps.id,\r\n                swaps.maxGasPrice,\r\n                msg.sender\r\n            )\r\n        );\r\n        require(\r\n            signers[ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n                ),\r\n                swaps.v,\r\n                swaps.r,\r\n                swaps.s\r\n            )],\r\n            \"Invalid signature\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier notAboveMaxGas(SwapCollection memory swaps) {\r\n        require(tx.gasprice <= swaps.maxGasPrice, \"Gas price too high\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Performs the requested set of swaps\r\n    /// @param swaps The struct that defines the collection of swaps to perform\r\n    function performSwapCollection(SwapCollection memory swaps)\r\n        public\r\n        payable\r\n        whenNotPaused\r\n        notExpired(swaps)\r\n        validSignature(swaps)\r\n        notAboveMaxGas(swaps)\r\n    {\r\n        uint256 startingGas = 0;\r\n        if (tx.gasprice >= MIN_REFUND_GAS_PRICE) {\r\n            startingGas = gasleft();\r\n        }\r\n\r\n\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances;\r\n        balances[0] = TokenBalanceLibrary.TokenBalance(\r\n            address(Utils.eth_address()),\r\n            msg.value\r\n        );\r\n        for (\r\n            uint256 swapIndex = 0;\r\n            swapIndex < swaps.swaps.length;\r\n            swapIndex++\r\n        ) {\r\n            performSwap(\r\n                swaps.id,\r\n                swaps.swaps[swapIndex],\r\n                balances,\r\n                swaps.partnerContract\r\n            );\r\n        }\r\n        emit LogSwapCollection(swaps.id, swaps.partnerContract, msg.sender);\r\n        transferAllTokensToUser(balances);\r\n        if (startingGas > 0) {\r\n            refundGas(startingGas);\r\n        }\r\n    }\r\n\r\n    function refundGas(uint256 startingGas) internal {\r\n        uint256 gasRemaining = gasleft();\r\n        uint256 gasSpent = startingGas - gasRemaining;\r\n        uint256 tokensToFree = Math.min(\r\n            (gasSpent + 14154) / 41130,\r\n            (gasRemaining - 27710) / (1148 + 5722 + 150)\r\n        );\r\n        GAS_TOKEN.freeUpTo(tokensToFree);\r\n    }\r\n\r\n    function addSigner(address newSigner) public onlyOwner {\r\n        signers[newSigner] = true;\r\n    }\r\n\r\n    function removeSigner(address signer) public onlyOwner {\r\n        signers[signer] = false;\r\n    }\r\n\r\n    function updateMinRefundGasPrice(uint256 newMinRefundGasPrice)\r\n        external\r\n        onlyOwner\r\n    {\r\n        MIN_REFUND_GAS_PRICE = newMinRefundGasPrice;\r\n    }\r\n\r\n    /*\r\n     *   Internal functions\r\n     */\r\n\r\n    function performSwap(\r\n        bytes32 swapCollectionId,\r\n        Swap memory swap,\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances,\r\n        address payable partnerContract\r\n    ) internal {\r\n        if (\r\n            !transferFromSenderDifference(\r\n                balances,\r\n                swap.trades[0].sourceToken,\r\n                swap.sourceAmount\r\n            )\r\n        ) {\r\n            if (swap.required) {\r\n                revert(\"Failed to get tokens for swap\");\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n        uint256 amountSpentFirstTrade = 0;\r\n        uint256 amountReceived = 0;\r\n        uint256 feeAmount = 0;\r\n        for (\r\n            uint256 tradeIndex = 0;\r\n            tradeIndex < swap.trades.length;\r\n            tradeIndex++\r\n        ) {\r\n            if (\r\n                tradeIndex == swap.tradeToTakeFeeFrom && swap.takeFeeFromSource\r\n            ) {\r\n                feeAmount = takeFee(\r\n                    balances,\r\n                    swap.trades[tradeIndex].sourceToken,\r\n                    partnerContract,\r\n                    tradeIndex == 0 ? swap.sourceAmount : amountReceived\r\n                );\r\n            }\r\n            uint256 tempSpent;\r\n            (tempSpent, amountReceived) = performTrade(\r\n                swap.trades[tradeIndex],\r\n                balances,\r\n                Utils.min(\r\n                    tradeIndex == 0 ? swap.sourceAmount : amountReceived,\r\n                    balances[TokenBalanceLibrary.findToken(\r\n                        balances,\r\n                        swap.trades[tradeIndex].sourceToken\r\n                    )]\r\n                        .balance\r\n                )\r\n            );\r\n            if (\r\n                !swap.trades[tradeIndex].isSourceAmount &&\r\n                amountReceived < swap.trades[tradeIndex].amount\r\n            ) {\r\n                if (swap.required) {\r\n                    revert(\"Not enough destination amount\");\r\n                }\r\n                return;\r\n            }\r\n            if (tradeIndex == 0) {\r\n                amountSpentFirstTrade = tempSpent;\r\n                if (feeAmount != 0) {\r\n                    amountSpentFirstTrade += feeAmount;\r\n                }\r\n            }\r\n            if (\r\n                tradeIndex == swap.tradeToTakeFeeFrom && !swap.takeFeeFromSource\r\n            ) {\r\n                feeAmount = takeFee(\r\n                    balances,\r\n                    swap.trades[tradeIndex].destinationToken,\r\n                    partnerContract,\r\n                    amountReceived\r\n                );\r\n                amountReceived -= feeAmount;\r\n            }\r\n        }\r\n        emit LogSwap(\r\n            swapCollectionId,\r\n            swap.trades[0].sourceToken,\r\n            swap.trades[swap.trades.length - 1].destinationToken,\r\n            amountSpentFirstTrade,\r\n            amountReceived,\r\n            swap.takeFeeFromSource\r\n                ? swap.trades[swap.tradeToTakeFeeFrom].sourceToken\r\n                : swap.trades[swap.tradeToTakeFeeFrom].destinationToken,\r\n            feeAmount\r\n        );\r\n\r\n        if (amountReceived < swap.minimumDestinationAmount) {\r\n            revert(\"Got less than minimumDestinationAmount\");\r\n        } else if (\r\n            minimumRateFailed(\r\n                swap.trades[0].sourceToken,\r\n                swap.trades[swap.trades.length - 1].destinationToken,\r\n                swap.sourceAmount,\r\n                amountReceived,\r\n                swap.minimumExchangeRate\r\n            )\r\n        ) {\r\n            revert(\"Minimum exchange rate not met\");\r\n        }\r\n        if (\r\n            swap.redirectAddress != msg.sender &&\r\n            swap.redirectAddress != address(0x0)\r\n        ) {\r\n            uint256 destinationTokenIndex = TokenBalanceLibrary.findToken(\r\n                balances,\r\n                swap.trades[swap.trades.length - 1].destinationToken\r\n            );\r\n            uint256 amountToSend = Math.min(\r\n                amountReceived,\r\n                balances[destinationTokenIndex].balance\r\n            );\r\n            transferTokens(\r\n                balances,\r\n                destinationTokenIndex,\r\n                swap.redirectAddress,\r\n                amountToSend\r\n            );\r\n            TokenBalanceLibrary.removeBalance(\r\n                balances,\r\n                swap.trades[swap.trades.length - 1].destinationToken,\r\n                amountToSend\r\n            );\r\n        }\r\n    }\r\n\r\n    function performTrade(\r\n        Trade memory trade,\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances,\r\n        uint256 availableToSpend\r\n    ) internal returns (uint256 totalSpent, uint256 totalReceived) {\r\n        uint256 tempSpent = 0;\r\n        uint256 tempReceived = 0;\r\n        uint256 missingSpend = 0; // This is the amount that we expected to have spent, but didn't. Not to be confused with the total amount left to spend\r\n        uint256 totalRemainingExcess = getTotalExcess(trade);\r\n        for (\r\n            uint256 orderIndex = 0;\r\n            orderIndex < trade.orders.length;\r\n            orderIndex++\r\n        ) {\r\n            if ((availableToSpend - totalSpent) * 10000 < availableToSpend) {\r\n                break;\r\n            } else if (trade.isSourceAmount && tempSpent == trade.amount) {\r\n                break;\r\n            }\r\n            uint256 targetSpend = getTargetSpend(\r\n                trade.orders[orderIndex].minSourceAmount,\r\n                trade.orders[orderIndex].maxSourceAmount,\r\n                totalRemainingExcess,\r\n                missingSpend);\r\n            (tempSpent, tempReceived) = performOrder(\r\n                trade.orders[orderIndex],\r\n                availableToSpend - totalSpent,\r\n                trade.isSourceAmount,\r\n                trade.sourceToken,\r\n                balances\r\n            );\r\n            totalRemainingExcess -= (trade.orders[orderIndex].maxSourceAmount -\r\n                trade.orders[orderIndex].minSourceAmount);\r\n            if (tempSpent < trade.orders[orderIndex].minSourceAmount) {\r\n                missingSpend += (targetSpend - tempSpent);\r\n            }\r\n            totalSpent += tempSpent;\r\n            totalReceived += tempReceived;\r\n        }\r\n        TokenBalanceLibrary.addBalance(\r\n            balances,\r\n            trade.destinationToken,\r\n            totalReceived\r\n        );\r\n        TokenBalanceLibrary.removeBalance(\r\n            balances,\r\n            trade.sourceToken,\r\n            totalSpent\r\n        );\r\n    }\r\n\r\n    function performOrder(\r\n        Order memory order,\r\n        uint256 targetAmount,\r\n        bool isSourceAmount,\r\n        address tokenToSpend,\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances\r\n    ) internal returns (uint256 spent, uint256 received) {\r\n        if (tokenToSpend == Utils.eth_address()) {\r\n            (spent, received) = ExchangeHandler(order.exchangeHandler)\r\n                .performOrder\r\n                .value(targetAmount)(\r\n                order.encodedPayload,\r\n                targetAmount,\r\n                targetAmount,\r\n                isSourceAmount\r\n            );\r\n        } else {\r\n            transferTokens(\r\n                balances,\r\n                TokenBalanceLibrary.findToken(balances, tokenToSpend),\r\n                order.exchangeHandler,\r\n                targetAmount\r\n            );\r\n            (spent, received) = ExchangeHandler(order.exchangeHandler)\r\n                .performOrder(\r\n                order.encodedPayload,\r\n                targetAmount,\r\n                targetAmount,\r\n                isSourceAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    function getTargetSpend(\r\n        uint256 minOrderAmount,\r\n        uint256 maxOrderAmount,\r\n        uint256 totalRemainingExcess,\r\n        uint256 missingSpend\r\n    ) internal returns (uint256 targetSpend) {\r\n        if (missingSpend == 0 || minOrderAmount == maxOrderAmount) {\r\n            return minOrderAmount;\r\n        } else {\r\n            return\r\n                ((maxOrderAmount - minOrderAmount) * missingSpend) /\r\n                totalRemainingExcess;\r\n        }\r\n    }\r\n\r\n    function getTotalExcess(Trade memory trade)\r\n        internal\r\n        returns (uint256 totalExcess)\r\n    {\r\n        for (uint8 index = 0; index < trade.orders.length; index++) {\r\n            totalExcess +=\r\n                trade.orders[index].maxSourceAmount -\r\n                trade.orders[index].minSourceAmount;\r\n        }\r\n        return totalExcess;\r\n    }\r\n\r\n    function minimumRateFailed(\r\n        address sourceToken,\r\n        address destinationToken,\r\n        uint256 sourceAmount,\r\n        uint256 destinationAmount,\r\n        uint256 minimumExchangeRate\r\n    ) internal returns (bool failed) {\r\n        uint256 sourceDecimals = sourceToken == Utils.eth_address()\r\n            ? 18\r\n            : Utils.getDecimals(sourceToken);\r\n        uint256 destinationDecimals = destinationToken == Utils.eth_address()\r\n            ? 18\r\n            : Utils.getDecimals(destinationToken);\r\n        uint256 rateGot = Utils.calcRateFromQty(\r\n            sourceAmount,\r\n            destinationAmount,\r\n            sourceDecimals,\r\n            destinationDecimals\r\n        );\r\n        return rateGot < minimumExchangeRate;\r\n    }\r\n\r\n    function takeFee(\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances,\r\n        address token,\r\n        address payable partnerContract,\r\n        uint256 amountTraded\r\n    ) internal returns (uint256 feeAmount) {\r\n        Partner partner = Partner(partnerContract);\r\n        uint256 feePercentage = partner.getTotalFeePercentage();\r\n        feeAmount = calculateFee(amountTraded, feePercentage);\r\n        transferTokens(\r\n            balances,\r\n            TokenBalanceLibrary.findToken(balances, token),\r\n            partnerContract,\r\n            feeAmount\r\n        );\r\n        TokenBalanceLibrary.removeBalance(\r\n            balances,\r\n            TokenBalanceLibrary.findToken(balances, token),\r\n            feeAmount\r\n        );\r\n        return feeAmount;\r\n    }\r\n\r\n    function transferFromSenderDifference(\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances,\r\n        address token,\r\n        uint256 sourceAmount\r\n    ) internal returns (bool) {\r\n        if (token == Utils.eth_address()) {\r\n            if (sourceAmount > balances[0].balance) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        uint256 tokenIndex = TokenBalanceLibrary.findToken(balances, token);\r\n        if (sourceAmount > balances[tokenIndex].balance) {\r\n            bool success;\r\n            (success, ) = address(tokenTransferProxy).call(\r\n                abi.encodeWithSignature(\r\n                    \"transferFrom(address,address,address,uint256)\",\r\n                    token,\r\n                    msg.sender,\r\n                    address(this),\r\n                    sourceAmount - balances[tokenIndex].balance\r\n                )\r\n            );\r\n            if (success) {\r\n                balances[tokenIndex].balance = sourceAmount;\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferAllTokensToUser(\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances\r\n    ) internal {\r\n        for (\r\n            uint256 balanceIndex = 0;\r\n            balanceIndex < balances.length;\r\n            balanceIndex++\r\n        ) {\r\n            if (\r\n                balanceIndex != 0 &&\r\n                balances[balanceIndex].tokenAddress == address(0x0)\r\n            ) {\r\n                return;\r\n            }\r\n            transferTokens(\r\n                balances,\r\n                balanceIndex,\r\n                msg.sender,\r\n                balances[balanceIndex].balance\r\n            );\r\n        }\r\n    }\r\n\r\n    function transferTokens(\r\n        TokenBalanceLibrary.TokenBalance[20] memory balances,\r\n        uint256 tokenIndex,\r\n        address payable destination,\r\n        uint256 tokenAmount\r\n    ) internal {\r\n        if (tokenAmount > 0) {\r\n            if (balances[tokenIndex].tokenAddress == Utils.eth_address()) {\r\n                destination.transfer(tokenAmount);\r\n            } else {\r\n                require(\r\n                    ERC20SafeTransfer.safeTransfer(\r\n                        balances[tokenIndex].tokenAddress,\r\n                        destination,\r\n                        tokenAmount\r\n                    ),\r\n                    \"Transfer failed\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // @notice Calculates the fee amount given a fee percentage and amount\r\n    // @param amount the amount to calculate the fee based on\r\n    // @param fee the percentage, out of 1 eth (e.g. 0.01 ETH would be 1%)\r\n    function calculateFee(uint256 amount, uint256 fee)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(amount, fee), 1 ether);\r\n    }\r\n\r\n    /*\r\n     *   Payable fallback function\r\n     */\r\n\r\n    /// @notice payable fallback to allow handler or exchange contracts to return ether\r\n    /// @dev only accounts containing code (ie. contracts) can send ether to contract\r\n    function() external payable whenNotPaused {\r\n        // Check in here that the sender is a contract! (to stop accidents)\r\n        uint256 size;\r\n        address sender = msg.sender;\r\n        assembly {\r\n            size := extcodesize(sender)\r\n        }\r\n        if (size == 0) {\r\n            revert(\"EOA cannot send ether to primary fallback\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTransferProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"name\":\"sourceToken\",\"type\":\"address\"},{\"name\":\"destinationToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"isSourceAmount\",\"type\":\"bool\"},{\"components\":[{\"name\":\"exchangeHandler\",\"type\":\"address\"},{\"name\":\"encodedPayload\",\"type\":\"bytes\"},{\"name\":\"minSourceAmount\",\"type\":\"uint256\"},{\"name\":\"maxSourceAmount\",\"type\":\"uint256\"}],\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"trades\",\"type\":\"tuple[]\"},{\"name\":\"minimumExchangeRate\",\"type\":\"uint256\"},{\"name\":\"minimumDestinationAmount\",\"type\":\"uint256\"},{\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"name\":\"tradeToTakeFeeFrom\",\"type\":\"uint256\"},{\"name\":\"takeFeeFromSource\",\"type\":\"bool\"},{\"name\":\"redirectAddress\",\"type\":\"address\"},{\"name\":\"required\",\"type\":\"bool\"}],\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"name\":\"partnerContract\",\"type\":\"address\"},{\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"type\":\"tuple\"}],\"name\":\"performSwapCollection\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"signers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_REFUND_GAS_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinRefundGasPrice\",\"type\":\"uint256\"}],\"name\":\"updateMinRefundGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"addSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenTransferProxy\",\"type\":\"address\"},{\"name\":\"_signer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"partnerContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogSwapCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sourceAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destinationAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"destinationAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"LogSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TotlePrimary","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"00000000000000000000000074758acfce059f503a7e6b0fc2c8737600f9f2c4000000000000000000000000c2d7cf95645d33006175b78989035c7c9061d3f9","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d09795012e055d1cfd702eaaeb55e806c72224a35210229d4f10c77970a15603"}]}