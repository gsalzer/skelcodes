{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n██╗     ███████╗██╗  ██╗                         \r\n██║     ██╔════╝╚██╗██╔╝                         \r\n██║     █████╗   ╚███╔╝                          \r\n██║     ██╔══╝   ██╔██╗                          \r\n███████╗███████╗██╔╝ ██╗                         \r\n╚══════╝╚══════╝╚═╝  ╚═╝                         \r\n██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗ \r\n██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗\r\n██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝\r\n██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗\r\n███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║\r\n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\r\nDEAR MSG.SENDER(S):\r\n\r\n/ LXL is a project in beta.\r\n// Please audit and use at your own risk.\r\n/// Entry into LXL shall not create an attorney/client relationship.\r\n//// Likewise, LXL should not be construed as legal advice or replacement for professional counsel.\r\n///// STEAL THIS C0D3SL4W \r\n\r\n~presented by Open, ESQ || LexDAO LLC\r\n*/\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract Context { // describes current contract execution context / openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath { // wrappers over solidity arithmetic operations with added overflow checks\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Address { // helper function for address type / openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\ninterface IERC20 { // brief interface for erc20 token txs\r\n    function balanceOf(address who) external view returns (uint256);\r\n    \r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\nlibrary SafeERC20 { // wrappers around erc20 token txs that throw on failure (when the token contract returns false) / openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n   function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWETH { // brief interface for ether wrapping contract \r\n    function deposit() payable external;\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n}\r\n\r\ncontract LexLocker is Context { // digital deal deposits w/ embedded arbitration via lexDAO (lexdao.org)\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    /** ADR Wrapper **/\r\n    address public judgeAccessToken;\r\n    address public judgmentRewardToken;\r\n    address payable public lexDAO;\r\n    uint256 public judgeAccessBalance;\r\n    uint256 public judgmentRate;\r\n    uint256 public judgmentReward;\r\n\r\n    /** <$> LXL <$> **/\r\n    address private locker = address(this);\r\n    address public wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // wrapping contract for raw payable ether\r\n    uint256 public lockerIndex;\r\n    bytes32 public lexStamp;\r\n    mapping(uint256 => Deposit) public deposits; \r\n\r\n    struct Deposit {  \r\n        address client; \r\n        address provider;\r\n        address token;\r\n        uint8 locked;\r\n        uint256 amount;\r\n        uint256 cap;\r\n        uint256 judgmentRate;\r\n        uint256 released;\r\n        uint256 termination;\r\n        bytes32 details; \r\n    }\r\n    \t\r\n    event DepositToken(address indexed client, address indexed provider, uint256 indexed index);  \r\n    event Release(uint256 indexed index, uint256 indexed milestone); \r\n    event Withdraw(uint256 indexed index, uint256 indexed remainder);\r\n    event Lock(address indexed sender, uint256 indexed index, bytes32 indexed details);\r\n    event Resolve(address indexed resolver, uint256 indexed clientAward, uint256 indexed providerAward, uint256 index, bytes32 details); \r\n    event PayLexDAO(address indexed sender, uint256 indexed payment, bytes32 indexed details);\r\n    event UpdateGovernance(address indexed _judgeAccessToken, address indexed _judgmentRewardToken, address indexed _lexDAO, uint256 _judgeAccessBalance, uint256 _judgmentRate, uint256 _judgmentReward, bytes32 _lexStamp);\r\n    \r\n    constructor(\r\n        address _judgeAccessToken, \r\n        address _judgmentRewardToken, \r\n        address payable _lexDAO, \r\n        uint256 _judgeAccessBalance, \r\n        uint256 _judgmentRate,\r\n        uint256 _judgmentReward,\r\n        bytes32 _lexStamp) public { \r\n        judgeAccessToken = _judgeAccessToken;\r\n        judgmentRewardToken = _judgmentRewardToken;\r\n        lexDAO = _lexDAO;\r\n        judgeAccessBalance = _judgeAccessBalance;\r\n        judgmentRate = _judgmentRate;\r\n        judgmentReward = _judgmentReward;\r\n        lexStamp = _lexStamp;\r\n    } \r\n    \r\n    /***************\r\n    LOCKER FUNCTIONS\r\n    ***************/\r\n    function depositToken( // register lexlocker and deposit token \r\n        address provider,\r\n        address token,\r\n        uint256 amount, \r\n        uint256 cap,\r\n        uint256 termination,\r\n        bytes32 details) payable external {\r\n        require(amount <= cap, \"amount exeeds cap\"); \r\n        \r\n        if (token == wETH && msg.value > 0) {\r\n            require(msg.value == cap, \"insufficient ETH\");\r\n            IWETH(wETH).deposit();\r\n            (bool success, ) = wETH.call.value(msg.value)(\"\");\r\n            require(success, \"transfer failed\");\r\n            IWETH(wETH).transfer(locker, msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(msg.sender, locker, cap);\r\n        }\r\n\r\n        uint256 index = lockerIndex+1;\r\n        lockerIndex = lockerIndex+1;\r\n        \r\n        deposits[index] = Deposit( \r\n            _msgSender(), \r\n            provider,\r\n            token,\r\n            0,\r\n            amount,\r\n            cap,\r\n            judgmentRate,\r\n            0,\r\n            termination,\r\n            details);\r\n        \r\n        emit DepositToken(_msgSender(), provider, lockerIndex); \r\n    }\r\n\r\n    function release(uint256 index) external { // client transfers deposit amount (milestone) to provider\r\n    \tDeposit storage deposit = deposits[index];\r\n\t    \r\n\t    require(deposit.locked == 0, \"deposit locked\");\r\n\t    require(deposit.cap > deposit.released, \"deposit released\");\r\n    \trequire(_msgSender() == deposit.client, \"not deposit client\"); \r\n        \r\n        uint256 milestone = deposit.amount;  \r\n        \r\n        IERC20(deposit.token).safeTransfer(deposit.provider, milestone);\r\n        \r\n        deposit.released = deposit.released.add(milestone);\r\n        \r\n\t    emit Release(index, milestone); \r\n    }\r\n    \r\n    function withdraw(uint256 index) external { // withdraw deposit remainder to client if termination time passes and no lock\r\n    \tDeposit storage deposit = deposits[index];\r\n        \r\n        require(deposit.locked == 0, \"deposit locked\");\r\n        require(deposit.cap > deposit.released, \"deposit released\");\r\n        require(now > deposit.termination, \"termination time pending\");\r\n        \r\n        uint256 remainder = deposit.cap.sub(deposit.released); \r\n        \r\n        IERC20(deposit.token).safeTransfer(deposit.client, remainder);\r\n        \r\n        deposit.released = deposit.released.add(remainder); \r\n        \r\n\t    emit Withdraw(index, remainder); \r\n    }\r\n    \r\n    /************\r\n    ADR FUNCTIONS\r\n    ************/\r\n    function lock(uint256 index, bytes32 details) external { // client or provider can lock deposit for lexDAO resolution during locker period / update details\r\n        Deposit storage deposit = deposits[index]; \r\n        \r\n        require(deposit.cap > deposit.released, \"deposit released\");\r\n        require(now < deposit.termination, \"termination time passed\"); \r\n        require(_msgSender() == deposit.client || _msgSender() == deposit.provider, \"not deposit party\"); \r\n        \r\n\t    deposit.locked = 1; \r\n\t    \r\n\t    emit Lock(_msgSender(), index, details);\r\n    }\r\n    \r\n    function resolve(uint256 index, uint256 clientAward, uint256 providerAward, bytes32 details) external { // lexDAO judge resolves locked deposit remainder \r\n        Deposit storage deposit = deposits[index];\r\n        \r\n        uint256 remainder = deposit.cap.sub(deposit.released); \r\n\t    uint256 resolutionFee = remainder.div(deposit.judgmentRate); // calculates lexDAO dispute resolution fee\r\n\t    \r\n\t    require(deposit.locked == 1, \"deposit not locked\"); \r\n\t    require(deposit.cap > deposit.released, \"cap released\");\r\n\t    require(_msgSender() != deposit.client, \"cannot be deposit party\");\r\n\t    require(_msgSender() != deposit.provider, \"cannot be deposit party\");\r\n\t    require(clientAward.add(providerAward) == remainder.sub(resolutionFee), \"resolution must match deposit\"); \r\n\t    require(IERC20(judgeAccessToken).balanceOf(_msgSender()) >= judgeAccessBalance, \"judgeAccessToken insufficient\");\r\n        \r\n        IERC20(deposit.token).safeTransfer(lexDAO, resolutionFee);\r\n        IERC20(deposit.token).safeTransfer(deposit.client, clientAward);\r\n        IERC20(deposit.token).safeTransfer(deposit.provider, providerAward);\r\n\t    IERC20(judgmentRewardToken).safeTransfer(_msgSender(), judgmentReward);\r\n\t    \r\n\t    deposit.released = deposit.released.add(remainder); \r\n\t    \r\n\t    emit Resolve(_msgSender(), clientAward, providerAward, index, details);\r\n    }\r\n    \r\n    /***************\r\n    LEXDAO FUNCTIONS\r\n    ***************/\r\n    function payLexDAO(bytes32 details) payable external { // attach ether (Ξ) with details to lexDAO\r\n        (bool success, ) = lexDAO.call.value(msg.value)(\"\");\r\n        require(success, \"transfer failed\");\r\n        \r\n        emit PayLexDAO(_msgSender(), msg.value, details);\r\n    }\r\n    \r\n    function updateGovernance(\r\n        address _judgeAccessToken, \r\n        address _judgmentRewardToken,\r\n        address payable _lexDAO,\r\n        uint256 _judgeAccessBalance, \r\n        uint256 _judgmentRate, \r\n        uint256 _judgmentReward,\r\n        bytes32 _lexStamp) external {\r\n        require(_msgSender() == lexDAO, \"caller not lexDAO\");\r\n        \r\n        judgeAccessToken = _judgeAccessToken; \r\n        judgmentRewardToken = _judgmentRewardToken;\r\n        lexDAO = _lexDAO;\r\n        judgeAccessBalance = _judgeAccessBalance; \r\n        judgmentRate = _judgmentRate; \r\n        judgmentReward = _judgmentReward;\r\n        lexStamp = _lexStamp;\r\n        \r\n        emit UpdateGovernance(_judgeAccessToken, _judgmentRewardToken, _lexDAO, _judgeAccessBalance, _judgmentRate, _judgmentReward, _lexStamp);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_judgeAccessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_judgmentRewardToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_lexDAO\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_judgeAccessBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_judgmentRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_judgmentReward\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_lexStamp\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DepositToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"PayLexDAO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"milestone\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"providerAward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"Resolve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_judgeAccessToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_judgmentRewardToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_lexDAO\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_judgeAccessBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_judgmentRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_judgmentReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lexStamp\",\"type\":\"bytes32\"}],\"name\":\"UpdateGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"remainder\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"locked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"judgmentRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgeAccessBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgeAccessToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgmentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgmentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgmentRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lexDAO\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lexStamp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"payLexDAO\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providerAward\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"resolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_judgeAccessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_judgmentRewardToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_lexDAO\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_judgeAccessBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_judgmentRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_judgmentReward\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_lexStamp\",\"type\":\"bytes32\"}],\"name\":\"updateGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LexLocker","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b4659d8907cdd36e36d0037f62ef8be696e4ce1600000000000000000000000091ea83d652e83cafabf49e6c602f2ebd3f6eead900000000000000000000000006153608b799a3da838bf7c95fe21309d2e33b5300000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000de0b6b3a76400006c65786c6f636b65722e6c657864616f2e657468000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c95337016460917b21442c5949f84a288fade3c257a33588e8adfc6865a83c47"}]}