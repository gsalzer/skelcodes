{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract MatrixErc20 {\r\n    using SafeMath for uint;\r\n    address public ownerWallet;\r\n\r\n    struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        mapping (address => uint256) tokenRewards;\r\n        mapping (address => uint) referrerID; //Token address to Referrer ID\r\n        mapping (address => address[]) referral; //Token address to list of addresses\r\n        mapping(address => mapping(uint => uint)) levelExpired; //Token address to level number to expiration date\r\n    }\r\n\r\n    uint REFERRER_1_LEVEL_LIMIT = 5;\r\n    uint PERIOD_LENGTH = 180 days;\r\n    uint ADMIN_FEE_PERCENTAGE = 10;\r\n    mapping(address => mapping(uint => uint)) public LEVEL_PRICE; //Token address to level number to price\r\n    mapping (address => UserStruct) public users;\r\n    mapping (uint => address) public userList;\r\n    uint public currUserID = 0;\r\n    \r\n    mapping (address => bool) public tokens;\r\n    \r\n    mapping (address => uint256) public ownerFees;\r\n\r\n    event regLevelEvent(address indexed _user, address indexed _referrer, uint _time, address _token);\r\n    event buyLevelEvent(address indexed _user, uint _level, uint _time, address _token);\r\n    event prolongateLevelEvent(address indexed _user, uint _level, uint _time, address _token);\r\n    event getMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, address _token);\r\n    event lostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, address _token);\r\n    \r\n    function setPeriodLength(uint _periodLength) public onlyOwner {\r\n        PERIOD_LENGTH = _periodLength;\r\n    }\r\n\r\n    function setAdminFeePercentage(uint _adminFeePercentage) public onlyOwner {\r\n        require (_adminFeePercentage >= 0 && _adminFeePercentage <= 100, \"Fee must be between 0 and 100\");\r\n        \r\n        ADMIN_FEE_PERCENTAGE = _adminFeePercentage;\r\n    }\r\n    \r\n    function toggleToken(address _token, bool _enabled) public onlyOwner {\r\n        tokens[_token] = _enabled;\r\n        \r\n        if (_enabled) {\r\n            for(uint i = 1; i <= 10; i++) {\r\n                users[ownerWallet].levelExpired[_token][i] = 55555555555;\r\n            }\r\n            \r\n            users[ownerWallet].referrerID[_token] = 0;\r\n        }\r\n    }\r\n    \r\n    function setTokenPrice(address _token, uint[10] memory _prices) public onlyOwner {\r\n        require(_prices.length == 10, \"Specify only 10 prices\");\r\n        \r\n        LEVEL_PRICE[_token][1] = _prices[0];\r\n        LEVEL_PRICE[_token][2] = _prices[1];\r\n        LEVEL_PRICE[_token][3] = _prices[2];\r\n        LEVEL_PRICE[_token][4] = _prices[3];\r\n        LEVEL_PRICE[_token][5] = _prices[4];\r\n        LEVEL_PRICE[_token][6] = _prices[5];\r\n        LEVEL_PRICE[_token][7] = _prices[6];\r\n        LEVEL_PRICE[_token][8] = _prices[7];\r\n        LEVEL_PRICE[_token][9] = _prices[8];\r\n        LEVEL_PRICE[_token][10] = _prices[9];\r\n        \r\n        if (!tokens[_token]) {\r\n            toggleToken(_token, true);\r\n        }\r\n    }\r\n\r\n    constructor() public {\r\n        ownerWallet = msg.sender;\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n        \r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID\r\n        });\r\n        users[ownerWallet] = userStruct;\r\n        userList[currUserID] = ownerWallet;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == ownerWallet, 'caller must be the owner');\r\n        _;\r\n    }\r\n    \r\n    //Use this before going live to avoid issues\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), 'new owner is the zero address');\r\n        require(!users[newOwner].isExist, 'new owner needs to be a new address');\r\n        \r\n        UserStruct memory userStruct = UserStruct({\r\n            isExist: true,\r\n            id: 1\r\n        });\r\n        \r\n        users[newOwner] = userStruct;\r\n        userList[1] = newOwner;\r\n\r\n        delete users[ownerWallet];\r\n        ownerWallet = newOwner;\r\n    }\r\n\r\n    function regUser(address _token, uint _referrerID) public payable {\r\n        require(tokens[_token], \"Token is not enabled\");\r\n        require(!users[msg.sender].isExist, 'User exist');\r\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\r\n        \r\n        IERC20 token = IERC20(_token);\r\n        require(token.transferFrom(msg.sender, address(this), LEVEL_PRICE[_token][1]), \"Couldn't take the tokens from the sender\");\r\n\r\n        if(users[userList[_referrerID]].referral[_token].length >= REFERRER_1_LEVEL_LIMIT) _referrerID = users[findFreeReferrer(_token, userList[_referrerID])].id;\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID\r\n        });\r\n        \r\n        users[msg.sender] = userStruct;\r\n        users[msg.sender].referrerID[_token] = _referrerID;\r\n        userList[currUserID] = msg.sender;\r\n\r\n        users[msg.sender].levelExpired[_token][1] = now + PERIOD_LENGTH;\r\n\r\n        users[userList[_referrerID]].referral[_token].push(msg.sender);\r\n\r\n        payForLevel(_token, 1, msg.sender);\r\n\r\n        emit regLevelEvent(msg.sender, userList[_referrerID], now, _token);\r\n    }\r\n\r\n    function buyLevel(address _token, uint _level) public payable {\r\n        require(users[msg.sender].isExist, 'User not exist'); \r\n        require(_level > 0 && _level <= 10, 'Incorrect level');\r\n        require(tokens[_token], \"Token is not enabled\");\r\n        \r\n        IERC20 token = IERC20(_token);\r\n        require(token.transferFrom(msg.sender, address(this), LEVEL_PRICE[_token][_level]), \"Couldn't take the tokens from the sender\");\r\n\r\n        if(_level == 1) {\r\n            users[msg.sender].levelExpired[_token][1] += PERIOD_LENGTH;\r\n        }\r\n        else {\r\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpired[_token][l] >= now, 'Buy the previous level');\r\n\r\n            if(users[msg.sender].levelExpired[_token][_level] == 0) users[msg.sender].levelExpired[_token][_level] = now + PERIOD_LENGTH;\r\n            else users[msg.sender].levelExpired[_token][_level] += PERIOD_LENGTH;\r\n        }\r\n\r\n        payForLevel(_token, _level, msg.sender);\r\n\r\n        emit buyLevelEvent(msg.sender, _level, now, _token);\r\n    }\r\n    \r\n    function getRefererInTree(address _token, uint _level, address _user) internal view returns(address) {\r\n        address referer;\r\n        address referer1;\r\n        address referer2;\r\n        address referer3;\r\n        address referer4;\r\n\r\n        if(_level == 1 || _level == 6) {\r\n            referer = userList[users[_user].referrerID[_token]];\r\n        }\r\n        else if(_level == 2 || _level == 7) {\r\n            referer1 = userList[users[_user].referrerID[_token]];\r\n            referer = userList[users[referer1].referrerID[_token]];\r\n        }\r\n        else if(_level == 3 || _level == 8) {\r\n            referer1 = userList[users[_user].referrerID[_token]];\r\n            referer2 = userList[users[referer1].referrerID[_token]];\r\n            referer = userList[users[referer2].referrerID[_token]];\r\n        }\r\n        else if(_level == 4 || _level == 9) {\r\n            referer1 = userList[users[_user].referrerID[_token]];\r\n            referer2 = userList[users[referer1].referrerID[_token]];\r\n            referer3 = userList[users[referer2].referrerID[_token]];\r\n            referer = userList[users[referer3].referrerID[_token]];\r\n        }\r\n        else if(_level == 5 || _level == 10) {\r\n            referer1 = userList[users[_user].referrerID[_token]];\r\n            referer2 = userList[users[referer1].referrerID[_token]];\r\n            referer3 = userList[users[referer2].referrerID[_token]];\r\n            referer4 = userList[users[referer3].referrerID[_token]];\r\n            referer = userList[users[referer4].referrerID[_token]];\r\n        }\r\n\r\n        if(!users[referer].isExist) referer = userList[1];\r\n        \r\n        return referer;\r\n    }\r\n    \r\n    function payForLevel(address _token, uint _level, address _user) internal {\r\n        address referer = getRefererInTree(_token, _level, _user);\r\n\r\n        if(users[referer].levelExpired[_token][_level] >= now) {\r\n            uint levelPrice = LEVEL_PRICE[_token][_level];\r\n            uint payToOwner = levelPrice.mul(ADMIN_FEE_PERCENTAGE).div(100);\r\n            uint payToReferrer = levelPrice.sub(payToOwner);\r\n            users[address(uint160(referer))].tokenRewards[_token] = users[address(uint160(referer))].tokenRewards[_token].add(payToReferrer);\r\n            ownerFees[_token] = ownerFees[_token].add(payToOwner);\r\n\r\n            emit getMoneyForLevelEvent(referer, msg.sender, _level, _token);\r\n        }\r\n        else {\r\n            emit lostMoneyForLevelEvent(referer, msg.sender, _level, now, _token);\r\n\r\n            payForLevel(_token, _level, referer);\r\n        }\r\n    }\r\n\r\n    function findFreeReferrer(address _token, address _user) public view returns(address) {\r\n        if(users[_user].referral[_token].length < REFERRER_1_LEVEL_LIMIT) return _user;\r\n\r\n        address[] memory referrals = new address[](315);\r\n        referrals[0] = users[_user].referral[_token][0];\r\n        referrals[1] = users[_user].referral[_token][1];\r\n        referrals[2] = users[_user].referral[_token][2];\r\n        referrals[3] = users[_user].referral[_token][3];\r\n        referrals[4] = users[_user].referral[_token][4];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n            if(users[referrals[i]].referral[_token].length == REFERRER_1_LEVEL_LIMIT) {\r\n                if(i < 155) {\r\n                    referrals[(i+1)*2] = users[referrals[i]].referral[_token][0];\r\n                    referrals[(i+1)*2+1] = users[referrals[i]].referral[_token][2];\r\n                    referrals[(i+1)*2+2] = users[referrals[i]].referral[_token][3];\r\n                    referrals[(i+1)*2+3] = users[referrals[i]].referral[_token][4];\r\n                    referrals[(i+1)*2+4] = users[referrals[i]].referral[_token][5];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n    \r\n    function withdraw(address _token) public {\r\n        uint256 total = users[msg.sender].tokenRewards[_token];\r\n        require(total > 0, \"Nothing to withdraw\");\r\n        users[msg.sender].tokenRewards[_token] = 0;\r\n        IERC20 token = IERC20(_token);\r\n        require(token.transfer(msg.sender, total), \"Couldn't send the tokens\");\r\n    }\r\n    \r\n    function _withdrawFees(address _token) public onlyOwner {\r\n        uint256 total = ownerFees[_token];\r\n        require(total > 0, \"Nothing to withdraw\");\r\n        ownerFees[_token] = 0;\r\n        IERC20 token = IERC20(_token);\r\n        require(token.transfer(msg.sender, total), \"Couldn't send the tokens\");\r\n    }\r\n\r\n    function viewUserReferral(address _token, address _user) public view returns(address[] memory) {\r\n        return users[_user].referral[_token];\r\n    }\r\n\r\n    function viewUserReferrer(address _token, address _user) public view returns(uint256) {\r\n        return users[_user].referrerID[_token];\r\n    }\r\n\r\n    function viewUserLevelExpired(address _token, address _user, uint _level) public view returns(uint) {\r\n        return users[_user].levelExpired[_token][_level];\r\n    }\r\n\r\n    function viewUserIsExist(address _user) public view returns(bool) {\r\n        return users[_user].isExist;\r\n    }\r\n\r\n    function viewUserRewards(address _user, address _token) public view returns(uint256) {\r\n        return users[_user].tokenRewards[_token];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n    function _close(address payable _to) public onlyOwner { \r\n        selfdestruct(_to);  \r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"buyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"lostMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"prolongateLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"regLevelEvent\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"_close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"_withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_adminFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setAdminFeePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_periodLength\",\"type\":\"uint256\"}],\"name\":\"setPeriodLength\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256[10]\",\"name\":\"_prices\",\"type\":\"uint256[10]\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"toggleToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserIsExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"viewUserRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MatrixErc20","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c1a1455fbd22e61dd79a166175355c7135a3b704d8780aca39e75a1806a4d29a"}]}