{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n//https://gfc.asia/\r\ncontract Ownable {\r\n\taddress private _owner;\r\n\taddress private nextOwner;\r\n\r\n\tconstructor () internal {\r\n\t\t_owner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isOwner() public view returns (bool) {\r\n\t\treturn msg.sender == _owner;\r\n\t}\r\n\r\n\tfunction approveNextOwner(address _nextOwner) external onlyOwner {\r\n\t\trequire(_nextOwner != _owner, \"Cannot approve current owner.\");\r\n\t\tnextOwner = _nextOwner;\r\n\t}\r\n\r\n\tfunction acceptNextOwner() external {\r\n\t\trequire(msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n\t\t_owner = nextOwner;\r\n\t}\r\n}\r\n\r\nlibrary Roles {\r\n\tstruct Role {\r\n\t\tmapping(address => bool) bearer;\r\n\t}\r\n\r\n\tfunction add(Role storage role, address account) internal {\r\n\t\trequire(!has(role, account), \"Roles: account already has role.\");\r\n\t\trole.bearer[account] = true;\r\n\t}\r\n\r\n\tfunction remove(Role storage role, address account) internal {\r\n\t\trequire(has(role, account), \"Roles: account does not have role.\");\r\n\t\trole.bearer[account] = false;\r\n\t}\r\n\r\n\tfunction has(Role storage role, address account) internal view returns (bool) {\r\n\t\trequire(account != address(0), \"Roles: account is the zero address.\");\r\n\t\treturn role.bearer[account];\r\n\t}\r\n}\r\n\r\ncontract WhitelistAdminRole is Ownable {\r\n\tusing Roles for Roles.Role;\r\n\r\n\tRoles.Role private _whitelistAdmins;\r\n\r\n\tconstructor () internal {\r\n\t}\r\n\tmodifier onlyWhitelistAdmin() {\r\n\t\trequire(isWhitelistAdmin(msg.sender) || isOwner(), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isWhitelistAdmin(address account) public view returns (bool) {\r\n\t\treturn _whitelistAdmins.has(account) || isOwner();\r\n\t}\r\n\r\n\tfunction addWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.add(account);\r\n\t}\r\n\r\n\tfunction removeWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.remove(account);\r\n\t}\r\n}\r\n\r\ncontract GFC is WhitelistAdminRole {\r\n\tusing SafeMath for *;\r\n\t\r\n\taddress  private devAddr = address(0xd67318a2022796eB685aFc84A68EAD8577d65a22);\r\n\taddress  private devCon  = address(0xab6C0807b522d5196027fa89Af1980d490D622A7);   \r\n\taddress  private comfort = address(0x98043DE2ACb248D768885C681373129b4e7eBA46);\r\n\taddress  private luck    = address(0x51227Bc3fbaad4e3af3926D7A76EE3Cc9769ABEF);\r\n\taddress  private cream   = address(0x0D65611F211cBeC27acff8EcfBA248b3c4c85441);\r\n\r\n\tstruct User {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tuint frozenAmount;\r\n\t\tuint freezeAmount;\r\n\t\tuint freeAmount;\r\n\t\tuint inviteAmonut;\r\n\t\tuint bonusAmount;\r\n\t\tuint dayBonAmount;\r\n\t\tuint dayInvAmount;\r\n\t\tuint level;\r\n\t\tuint resTime;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint lastRwTime;\r\n\t\tuint investTimes;\r\n\t\tuint lineAll;\r\n\t\tuint cn;\r\n\t\tuint cn500;\r\n\t\tuint cn5;\r\n\t}\r\n\r\n\tstruct UserGlobal {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint status;\r\n\t}\r\n    ILock _iLock = ILock(0x41645D2E0778C7A9B27B7d7F3887e5e92532c32d);\r\n    IUSD  usdT = IUSD(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n\tuint startTime;\r\n\tmapping(uint => uint) rInvestCount;\r\n\tmapping(uint => uint) rInvestMoney;\r\n\tuint period = 1 days;\r\n\tuint uid;\r\n\tuint rid = 1;\r\n\tmapping(uint => mapping(address => User)) userRoundMapping;\r\n\tmapping(address => UserGlobal) userMapping;\r\n\tmapping(string => address) addressMapping;\r\n\tmapping(uint => address) indexMapping;\r\n\tuint bonuslimit = 3000*10**6;\r\n\tuint sendLimit = 20000*10**6;\r\n\tuint withdrawLimit = 3000*10**6;\r\n\tuint canSetStartTime = 1;\r\n\tuint maxAmount = 1900*10**6;\r\n\tuint public erc20BeginTime;\r\n\r\n\tmodifier isHuman() {\r\n\t\taddress addr = msg.sender;\r\n\t\tuint codeLength;\r\n\t\tassembly {codeLength := extcodesize(addr)}\r\n\t\trequire(codeLength == 0, \"sorry, humans only\");\r\n\t\trequire(tx.origin == msg.sender, \"sorry, humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor (address _addr, string memory inviteCode) public {\r\n\t\tplant(_addr, inviteCode, \"\");\r\n\t}\r\n\r\n\tfunction() external payable {\r\n\t}\r\n\r\n\tfunction cause(uint time) external onlyOwner {\r\n\t\trequire(canSetStartTime == 1, \"can not set start time again\");\r\n\t\trequire(time > now, \"invalid game start time\");\r\n\t\tstartTime = time;\r\n\t\tcanSetStartTime = 0;\r\n\t}\r\n\r\n\tfunction version(address _dev,address _devT,address _com,address _comT,address _cream) external onlyOwner {\r\n\t\tdevAddr = _dev; devCon  = _devT; comfort = _com; luck = _comT; cream = _cream;\r\n\t}\r\n    \r\n    function review(address _lock) external onlyOwner {\r\n        _iLock = ILock(_lock);\r\n\t}\r\n    \r\n\tfunction dispose() public view returns (bool) {\r\n\t\treturn startTime != 0 && now > startTime;\r\n\t}\r\n\r\n\tfunction follow(uint bonus, uint send, uint withdraw,uint maxWad) external onlyOwner {\r\n\t\trequire(bonus >= 3000*10**6 && send >= 10000*10**6 && withdraw >= 3000*10**6 && maxWad>= 1900*10**6, \"invalid amount\");\r\n\t\tbonuslimit = bonus;\r\n\t\tsendLimit = send;\r\n\t\twithdrawLimit = withdraw;\r\n\t\tmaxAmount = maxWad;\r\n\t}\r\n\r\n\tfunction attitude(address addr, uint status) external onlyWhitelistAdmin {\r\n\t\trequire(status == 0 || status == 1 || status == 2, \"bad parameter status\");\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuserGlobal.status = status;\r\n\t}\r\n    \r\n\tfunction gain(string calldata inviteCode, string calldata beCode,uint _value) external isHuman() {\r\n\t\trequire(dispose(), \"game is not start\");\r\n\t\trequire(usdT.balanceOf(msg.sender) >= _value,\"insufficient balance\");\r\n\t\tusdT.transferFrom(msg.sender, address(this), _value);\r\n\t\tUserGlobal storage userGlobal = userMapping[msg.sender];\r\n\t\tif (userGlobal.id == 0) {\r\n\t\t\trequire(!UtilGFC.rely(inviteCode, \"      \") && bytes(inviteCode).length == 6, \"invalid invite code\");\r\n\t\t\taddress beCodeAddr = addressMapping[beCode];\r\n\t\t\trequire(revenue(beCode), \"beCode not exist\");\r\n\t\t\trequire(beCodeAddr != msg.sender, \"beCodeAddr can't be self\");\r\n\t\t\trequire(!revenue(inviteCode), \"invite code is used\");\r\n\t\t\tplant(msg.sender, inviteCode, beCode);\r\n\t\t}\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\tuint allWad = user.freezeAmount.add(_value).add(user.frozenAmount);\r\n\t\trequire(allWad <= maxAmount && allWad >= 100*10**6, \"value is larger than max\");\r\n\t\trequire(allWad == allWad.div(10**8).mul(10**8), \"invalid msg value\");\r\n\t\tuint feeAmount = _value;\r\n\t\tif (user.id != 0) {\r\n\t\t\tif (user.freezeAmount == 0) {\r\n\t\t\t\tuser.lastRwTime = now;\r\n\t\t\t\tfeeAmount = _value.add(user.frozenAmount);\r\n\t\t\t}\r\n\t\t\tif(allWad.mul(3).div(10) > user.frozenAmount){\r\n\t\t\t    user.freezeAmount=allWad.mul(7).div(10);\r\n\t\t\t    user.frozenAmount = allWad.mul(3).div(10);\r\n\t\t\t}else{\r\n\t\t\t    user.freezeAmount = user.freezeAmount.add(_value);\r\n\t\t\t}\r\n\t\t\tuser.level = UtilGFC.science(allWad);\r\n\t\t} else {\r\n\t\t\tuser.id = userGlobal.id;\r\n\t\t\tuser.userAddress = msg.sender;\r\n\t\t\tuser.freezeAmount = _value.mul(7).div(10);\r\n\t\t\tuser.frozenAmount = _value.mul(3).div(10);\r\n\t\t\tuser.level = UtilGFC.science(_value);\r\n\t\t\tuser.inviteCode = userGlobal.inviteCode;\r\n\t\t\tuser.beCode = userGlobal.beCode;\r\n\t\t\tuser.resTime = now;\r\n\t\t\tuser.lastRwTime = now;\r\n\t\t\taddress beCodeAddr = addressMapping[userGlobal.beCode];\r\n\t\t\tUser storage calUser = userRoundMapping[rid][beCodeAddr];\r\n\t\t\tif (calUser.id != 0) {\r\n\t\t\t\tcalUser.cn += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\trInvestCount[rid] = rInvestCount[rid].add(1);\r\n\t\trInvestMoney[rid] = rInvestMoney[rid].add(_value);\r\n\t\tgreen(feeAmount);\r\n\t\tsweden(user.userAddress,_value); \r\n\t\tuint ercWad = loss(feeAmount,msg.sender);\r\n\t\t_iLock.conTransfer(msg.sender,ercWad);\r\n\t}\r\n    function loss(uint allAmount,address _addr) private view returns(uint ercWad)  {\r\n        uint times = now.sub(erc20BeginTime).div(2 days);\r\n        uint result = 1*10**6;\r\n        if(times < 800){\r\n            for(uint i=0; i < times; i++){\r\n                result = result.mul(99).div(100);\r\n             }\r\n        }else{\r\n            result = 0;\r\n        }\r\n        User storage user = userRoundMapping[rid][_addr];\r\n        ercWad = allAmount.div(10**6).div(20).mul(result).mul(1.add(user.cn5.mul(1).div(10)));\r\n    }\r\n    \r\n    function sweden(address _userAddr,uint wad) private {\r\n\t\tUser storage user = userRoundMapping[rid][_userAddr];\r\n\t\tif (user.id == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuser.dayBonAmount = user.freezeAmount.add(user.frozenAmount).div(100);\r\n\t\tuser.investTimes = 0;\r\n\t\tstring memory tem = user.beCode;\r\n\t\tuint allWad = user.freezeAmount.add(user.frozenAmount);\r\n\t\tuint myWad = user.freeAmount.add(allWad).add(user.lineAll);\r\n\t\tfor (uint i = 1; i <= 30; i++) {\r\n\t\t\tif (UtilGFC.rely(tem, \"\")) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\taddress tmpAddr = addressMapping[tem];\r\n\t\t\tUser storage cUser = userRoundMapping[rid][tmpAddr];\r\n\t\t\tif(cUser.id == 0){\r\n\t\t\t    break;\r\n\t\t\t}\r\n\t\t\tuint cAllWad = cUser.freeAmount.add(cUser.freezeAmount).add(cUser.frozenAmount).add(cUser.lineAll);\r\n\t\t\tcUser.lineAll = cUser.lineAll.add(wad);\r\n\t\t    if(cAllWad.add(wad) >= 10**11 && cAllWad < 10**11){\r\n\t\t        address nAddr = addressMapping[cUser.beCode];\r\n    \t\t\tUser storage nUser = userRoundMapping[rid][nAddr];\r\n    \t\t\tif (nUser.id != 0) {\r\n    \t\t\t\tnUser.cn500 += 1;\r\n    \t\t\t}\r\n\t\t\t}\r\n\t\t\ttem = cUser.beCode;\r\n\t\t}\r\n\t\tif(allWad >= 1000*10**6 && allWad.sub(wad) < 1000*10**6 ){\r\n\t\t    address cAddr = addressMapping[user.beCode];\r\n\t\t\tUser storage cUser = userRoundMapping[rid][cAddr];\r\n\t\t\tif (cUser.id != 0) {\r\n\t\t\t\tcUser.cn5 += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(myWad >= 10**11 && myWad.sub(wad) < 10**11 ){\r\n\t\t    address cAddr = addressMapping[user.beCode];\r\n\t\t\tUser storage cUser = userRoundMapping[rid][cAddr];\r\n\t\t\tif (cUser.id != 0) {\r\n    \t\t\tcUser.cn500 += 1;\r\n    \t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tfunction course() external isHuman() {\r\n\t\trequire(dispose(), \"game is not start\");\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\trequire(user.freeAmount >= 60*10**6, \"user has no freeAmount\");\r\n\t\tuint resWad = reform(user.freeAmount);\r\n\r\n\t\tif (resWad > 0 && resWad <= withdrawLimit) {\r\n\t\t\tstalks(msg.sender, resWad);\r\n\t\t\tuint allWad = user.freezeAmount.add(user.frozenAmount).add(user.freeAmount);\r\n\t\t\tuint myWad = allWad.add(user.lineAll);\r\n\t\t\tuint wad = user.freeAmount;\r\n\t\t\tuser.freeAmount = 0;\r\n\t\t\tstring memory tem = user.beCode;\r\n    \t\tfor (uint i = 1; i <= 30; i++) {\r\n    \t\t\taddress tmpAddr = addressMapping[tem];\r\n    \t\t\tUser storage cUser = userRoundMapping[rid][tmpAddr];\r\n    \t\t\tif(cUser.id == 0){\r\n    \t\t\t    break;\r\n    \t\t\t}\r\n    \t\t\tuint cAllWad = cUser.freeAmount.add(cUser.freezeAmount).add(cUser.frozenAmount).add(cUser.lineAll);\r\n    \t\t\tif(cUser.lineAll >= wad){\r\n    \t\t\t   cUser.lineAll = cUser.lineAll.sub(wad); \r\n    \t\t\t}\r\n\t\t\t    if(cAllWad >= 10**11 && cAllWad.sub(wad) < 10**11){\r\n    \t\t        address nAddr = addressMapping[cUser.beCode];\r\n        \t\t\tUser storage nUser = userRoundMapping[rid][nAddr];\r\n        \t\t\tif (nUser.id != 0 && nUser.cn500 >= 1) {\r\n        \t\t\t    nUser.cn500 -= 1;\r\n        \t\t    }\r\n\t\t    \t}\r\n    \t\t\ttem = cUser.beCode;\r\n    \t\t}\r\n    \t\tif(allWad >= 1000*10**6 && allWad.sub(wad) < 1000*10**6 ){\r\n    \t\t    address cAddr = addressMapping[user.beCode];\r\n    \t\t\tUser storage cUser = userRoundMapping[rid][cAddr];\r\n    \t\t\tif (cUser.id != 0 && cUser.cn5 >= 1) {\r\n    \t\t\t\tcUser.cn5 -= 1;\r\n    \t\t   \t}\r\n    \t    }\r\n    \t    if(myWad >= 10**11 && myWad.sub(wad) < 10**11 ){\r\n    \t\t    address cAddr = addressMapping[user.beCode];\r\n    \t\t\tUser storage cUser = userRoundMapping[rid][cAddr];\r\n    \t\t\tif (cUser.id != 0 && cUser.cn500 >= 1) {\r\n    \t\t\t\tcUser.cn500 -= 1;\r\n    \t\t   \t}\r\n    \t    }\r\n\t\t}\r\n\t}\r\n\r\n\tfunction watch() external isHuman {\r\n\t\trapid(msg.sender);\r\n\t}\r\n\r\n\tfunction merchandise(uint start, uint end) external onlyWhitelistAdmin {\r\n\t\tfor (uint i = end; i >= start; i--) {\r\n\t\t\taddress userAddr = indexMapping[i];\r\n\t\t\trapid(userAddr);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction rapid(address addr) private {\r\n\t\trequire(dispose(), \"game is not start\");\r\n\t\tUser storage user = userRoundMapping[rid][addr];\r\n\t\tUserGlobal memory userGlobal = userMapping[addr];\r\n\t\tif (isWhitelistAdmin(msg.sender)) {\r\n\t\t\tif (now.sub(user.lastRwTime) <= 23 hours.add(58 minutes) || user.id == 0 || userGlobal.id == 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\trequire(user.id > 0, \"Users of the game are not betting in this round\");\r\n\t\t\trequire(now.sub(user.lastRwTime) >= 23 hours.add(58 minutes), \"Can only be extracted once in 24 hours\");\r\n\t\t}\r\n\t\tuser.lastRwTime = now;\r\n\t\tif (userGlobal.status == 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint awardSend = 0;\r\n\t\tuint freezeAmount = user.freezeAmount.add(user.frozenAmount);\r\n\t\tuint dayBon = 0;\r\n\t\tif (user.freezeAmount >= 60*10**6 && freezeAmount >= 100*10**6 && freezeAmount <= bonuslimit) {\r\n\t\t\tif (user.investTimes < 5) {\r\n\t\t\t\tawardSend = awardSend.add(user.dayBonAmount);\r\n\t\t\t\tdayBon = user.dayBonAmount;\r\n\t\t\t\tuser.bonusAmount = user.bonusAmount.add(user.dayBonAmount);\r\n\t\t\t\tuser.investTimes = user.investTimes.add(1);\r\n\t\t\t}\r\n\t\t\tif (user.investTimes >= 5) {\r\n\t\t\t\tuser.freeAmount = user.freeAmount.add(user.freezeAmount);\r\n\t\t\t\tuser.freezeAmount = 0;\r\n\t\t\t\tuser.dayBonAmount = 0;\r\n\t\t\t\tuser.level = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (awardSend == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (userGlobal.status == 0) {\r\n\t\t\tawardSend = awardSend.add(user.dayInvAmount);\r\n\t\t\tuser.inviteAmonut = user.inviteAmonut.add(user.dayInvAmount);\r\n\t\t}\r\n\t\tif (awardSend > 0 && awardSend <= sendLimit) {\r\n\t\t\tcare(awardSend,dayBon,addr);\r\n\t\t\tif (user.dayInvAmount > 0) {\r\n\t\t\t\tuser.dayInvAmount = 0;\r\n\t\t\t}\r\n\t\t\tif(userGlobal.status == 0) {\r\n\t\t\t\tsolve(user.beCode, freezeAmount);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction solve(string memory beCode, uint money) private {\r\n\t\tstring memory tmp = beCode;\r\n\t\tfor (uint i = 1; i <= 30; i++) {\r\n\t\t\tif (UtilGFC.rely(tmp, \"\")) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\taddress tmpaddr = addressMapping[tmp];\r\n\t\t\tUserGlobal storage global = userMapping[tmpaddr];\r\n\t\t\tUser storage cUser = userRoundMapping[rid][tmpaddr];\r\n\r\n\t\t\tif (global.status != 0 || cUser.freezeAmount == 0) {\r\n\t\t\t\ttmp = global.beCode;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tuint recommendSc = aerial(cUser.level,cUser.cn500,cUser.cn5,cUser.cn,i);\r\n\t\t\tuint moneyResult = 0;\r\n\t\t\tif (money <= cUser.freezeAmount.add(cUser.frozenAmount)) {\r\n\t\t\t\tmoneyResult = money;\r\n\t\t\t} else {\r\n\t\t\t\tmoneyResult = cUser.freezeAmount.add(cUser.frozenAmount);\r\n\t\t\t}\r\n\t\t\tif (recommendSc != 0) {\r\n\t\t\t\tuint dynamic = moneyResult.mul(recommendSc).div(10000);\r\n\t\t\t\tcUser.dayInvAmount = cUser.dayInvAmount.add(dynamic);\r\n\t\t\t}\r\n\t\t\ttmp = global.beCode;\r\n\t\t}\r\n\t}\r\n\tfunction aerial(uint level,uint sn500,uint sn5,uint sn,uint index) private pure returns (uint){\r\n\t\tif(level == 3 && sn5 >= 6){\r\n\t\t    if (sn500 >= 3) {\r\n\t\t    \tlevel = 6;\r\n    \t\t}else if (sn500 >= 2) {\r\n    \t\t\tlevel = 5;\r\n    \t\t}else if (sn500 >= 1) {\r\n    \t\t\tlevel = 4;\r\n    \t\t}\r\n\t\t}\r\n\t\treturn UtilGFC.rather(level,sn5,sn, index);\r\n\t}\r\n    \r\n\tfunction care(uint _send,uint dayBon,address addr) private {\r\n\t\tuint result = reform(_send);\r\n\t\tif (result > 0 && result <= sendLimit) {\r\n\t\t\tif(result > dayBon){\r\n\t\t\t    uint rand = uint256(keccak256(abi.encodePacked(block.number, now))).mod(10).add(1);\r\n\t\t\t   \tuint confort = result.sub(dayBon).div(100).mul(rand); \r\n    \t\t\tstalks(comfort, confort.mul(3).div(5));\r\n    \t\t\tstalks(luck, confort.mul(1).div(5));\r\n    \t\t\tstalks(cream, confort.mul(1).div(5));\r\n    \t\t\tresult = result.sub(confort);\r\n\t\t\t}\r\n\t\t\tstalks(addr, result);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reform(uint sendMoney) private view returns (uint) {\r\n\t\tif ( usdT.balanceOf(address(this)) >= sendMoney) {\r\n\t\t\treturn sendMoney;\r\n\t\t} else {\r\n\t\t\treturn usdT.balanceOf(address(this));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction green(uint amount) private {\r\n\t\tusdT.transfer(devAddr,amount.div(50));\r\n\t\tusdT.transfer(devCon,amount.div(50));\r\n\t}\r\n    \r\n\tfunction stalks(address userAddress, uint money) private {\r\n\t\tif (money > 0) {\r\n\t\t\tusdT.transfer(userAddress,money);\r\n\t\t}\r\n\t}\r\n    \r\n    function plant(address addr, string memory inviteCode, string memory beCode) private {\r\n        if(uid == 1){\r\n            erc20BeginTime = now;\r\n        }\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuid++;\r\n\t\tuserGlobal.id = uid;\r\n\t\tuserGlobal.userAddress = addr;\r\n\t\tuserGlobal.inviteCode = inviteCode;\r\n\t\tuserGlobal.beCode = beCode;\r\n\r\n\t\taddressMapping[inviteCode] = addr;\r\n\t\tindexMapping[uid] = addr;\r\n\t}\r\n\r\n\tfunction against() external onlyOwner {\r\n\t\trequire(usdT.balanceOf(address(this)) < 100*10**6, \"contract balance must be lower than 100*10**6\");\r\n\t\trid++;\r\n\t\tstartTime = now.add(period).div(1 days).mul(1 days);\r\n\t\tcanSetStartTime = 1;\r\n\t}\r\n        \r\n\tfunction circuit() public view returns (uint, uint, uint, uint, uint, uint, uint, uint, uint,uint) {\r\n\t\treturn (\r\n\t\trid,\r\n\t\tuid,\r\n\t\tstartTime,\r\n\t\trInvestCount[rid],\r\n\t\trInvestMoney[rid],\r\n\t\tbonuslimit,\r\n\t\tsendLimit,\r\n\t\twithdrawLimit,\r\n\t\tcanSetStartTime,\r\n\t\tmaxAmount\r\n\t\t);\r\n\t}\r\n        \r\n\tfunction chip(address addr, uint roundId) public view returns (uint[17] memory info, string memory inviteCode, string memory beCode) {\r\n\t\trequire(isWhitelistAdmin(msg.sender) || msg.sender == addr, \"Permission denied for view user's privacy\");\r\n\r\n\t\tif (roundId == 0) {\r\n\t\t\troundId = rid;\r\n\t\t}\r\n\r\n\t\tUserGlobal memory userGlobal = userMapping[addr];\r\n\t\tUser memory user = userRoundMapping[roundId][addr];\r\n\t\tinfo[0] = userGlobal.id;\r\n\t\tinfo[1] = user.freezeAmount;\r\n\t\tinfo[2] = user.inviteAmonut;\r\n\t\tinfo[3] = user.bonusAmount;\r\n\t\tinfo[4] = user.dayBonAmount;\r\n\t\tinfo[5] = user.level;\r\n\t\tinfo[6] = user.dayInvAmount;\r\n\t\tinfo[7] = user.lastRwTime;\r\n\t\tinfo[8] = userGlobal.status;\r\n\t\tinfo[9] = user.freeAmount;\r\n\t\tinfo[10] = user.cn;\r\n\t\tinfo[11] = user.investTimes;\r\n\t\tinfo[12] = user.resTime;\r\n\t\tinfo[13] = user.lineAll;\r\n\t\tinfo[14] = user.frozenAmount;\r\n\t\tinfo[15] = user.cn500;\r\n\t\tinfo[16] = user.cn5;\r\n\t\treturn (info, userGlobal.inviteCode, userGlobal.beCode);\r\n\t}\r\n\r\n\tfunction revenue(string memory code) public view returns (bool) {\r\n\t\taddress addr = addressMapping[code];\r\n\t\treturn uint(addr) != 0;\r\n\t}\r\n\r\n\tfunction material(string memory code) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\treturn addressMapping[code];\r\n\t}\r\n\r\n\tfunction loopback(uint id) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender));\r\n\t\treturn indexMapping[id];\r\n\t}\r\n}\r\n\r\nlibrary UtilGFC {\r\n\tfunction science(uint value) public pure  returns (uint) {\r\n\t\tif (value >= 100*10**6 && value < 1000*10**6) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (value >= 1000*10**6 && value < 2000*10**6) {\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t\tif (value >= 2000*10**6 && value <= 3000*10**6) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\tfunction rather(uint level,uint sn5, uint sn,uint times) public pure returns (uint) {\r\n\t\tif(level >= 1){\r\n\t\t    if(times == 1){\r\n\t\t        return 100;\r\n\t\t    }\r\n\t\t    if(sn >= 2 && times == 2){\r\n\t\t        return 50;\r\n\t\t    }\r\n\t\t    if(sn >= 3 && times == 3){\r\n\t\t        return 30;\r\n\t\t    }\r\n\t\t}\r\n\t\tif(level >= 2){\r\n\t\t    if(sn5 >= 3 && times >= 4 && times <= 10){\r\n\t\t        return 10;\r\n\t\t    }\r\n\t\t}\r\n\t\tif(level >= 3){\r\n\t\t    if(sn5 >= 6 && times >= 11 && times <= 20){\r\n\t\t        return 5;\r\n\t\t    }\r\n\t\t}\r\n\t\tif(level >= 4){\r\n\t\t    if( times >= 21 && times <= 30){\r\n\t\t        return 1;\r\n\t\t    }\r\n\t\t}\r\n\t    if(level >= 5){\r\n\t\t    if(times >= 21 && times <= 30){\r\n\t\t        return 2;\r\n\t\t    }\r\n\t\t}\r\n\t\tif(level >= 6){\r\n\t\t    if(times >= 21 && times <= 30){\r\n\t\t        return 3;\r\n\t\t    }\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\tfunction rely(string memory _str, string memory str) public pure returns (bool) {\r\n\t\tif (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"mul overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b > 0, \"div zero\");\r\n\t\tuint256 c = a / b;\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a, \"lower sub bigger\");\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0, \"mod zero\");\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a > b ? b : a;\r\n\t}\r\n}\r\ninterface ILock {\r\n    function conTransfer(address _addr,uint wad) external;\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\ninterface IUSD {\r\n    function transfer(address recipient, uint256 amount) external;\r\n    function transferFrom(address sender, address recipient, uint256 amount) external;\r\n    function balanceOf(address account) external view returns (uint256);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sn5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"rather\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_str\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"rely\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"science\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"UtilGFC","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://29ac1d8c5ed8ae8e0cae385752f8dbc1540681c9aee744343fed7596ca795db9"}]}