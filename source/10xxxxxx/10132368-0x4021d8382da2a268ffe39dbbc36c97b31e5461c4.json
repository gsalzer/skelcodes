{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\ncontract tERC20 {\r\n    function transferFrom(address _from, address _to, uint256 _value) public;\r\n}\r\n\r\n\r\ncontract Pcontract {\r\n    function () payable external {}\r\n    function callContract(address _contract, uint256 _EthAmount, bytes calldata _data) external;\r\n    function approve(address _contract, uint256 _amount) external;\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n    \r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Sender Must be Owner\");\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    \r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n    \r\n    \r\n}\r\n\r\ncontract Signs {\r\n    \r\n    constructor() public {}\r\n    \r\n    \r\n    function getSigner(string memory _func, address _to, uint256 _EthAmount, uint256 _amount, string memory _ticker, string memory _feeTicker, uint256 _nonce, bool _parent, bytes memory _cdata, bytes memory _sign) public view returns (address){\r\n        bytes32 typedData = keccak256(\r\n            abi.encodePacked( byte(0x19), byte(0x01), \r\n                keccak256(abi.encode(\r\n                    keccak256(abi.encodePacked(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")),\r\n                    keccak256(\"MetaTransact\"), //dappName\r\n                    keccak256(\"1.2\"), //version\r\n                    1, // network\r\n                    this, \r\n                    0x6572776572776c48385a7978356c7430556b5554324c47664b6331756b364e53\r\n                )),\r\n                keccak256(abi.encode( keccak256(abi.encodePacked(\"MetaTransact(string Method,address Address,uint256 EthAmount,uint256 Amount,string Ticker,string FeeTicker,uint256 Nonce,bool IsParent,bytes InputData)\")) ,\r\n                    keccak256(bytes(_func)), _to, _EthAmount, _amount, keccak256(bytes(_ticker)), keccak256(bytes(_feeTicker)), _nonce, _parent, keccak256(_cdata)\r\n                ))\r\n            )\r\n        );\r\n        \r\n        return recover(typedData, _sign);\r\n    }\r\n    \r\n    \r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address){\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        (v, r, s) = splitSignature(signature);\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            // solium-disable-next-line arg-overflow\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n    \r\n    \r\n    function splitSignature(bytes memory sig) internal pure returns (uint8, bytes32, bytes32){\r\n        require(sig.length == 65);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        return (v, r, s);\r\n    }\r\n}\r\n\r\n\r\ncontract metaTransact is Owned, Signs {\r\n    using SafeMath for uint256;\r\n    \r\n    \r\n    address public proxyContract;\r\n    \r\n    mapping(string  => address) public tickers;\r\n    mapping(address => uint256) public tickerFee;\r\n    \r\n    mapping(address => uint256) public currentNonce;\r\n    mapping(address => address payable) public userProxy;\r\n    mapping(address => address) public parantAddress;\r\n    \r\n    mapping(address => addressMeta) metaAddresses;\r\n    \r\n    \r\n    struct addressMeta {\r\n        uint currIndex;\r\n        mapping(uint => address) childAddresses;\r\n        mapping(address => mapping(address => uint256)) allowances;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    constructor() public {}\r\n    \r\n    \r\n    function interactDappUProxy(address _dapp, uint256 _EthAmount, uint256 _amount, string calldata _feeTicker, uint256 _nonce, bytes calldata _sign, bytes calldata _calldata, address _relayer) external {\r\n        require(tickers[_feeTicker] != address(0x0));\r\n        \r\n        address cAddress = getSigner(\"interactDappUProxy\", _dapp, _EthAmount, _amount, \"\", _feeTicker, _nonce, false, _calldata, _sign);\r\n        address payable cpAddress = userProxy[cAddress];\r\n        \r\n        require(cpAddress != address(0x0));\r\n        require(currentNonce[cpAddress] == _nonce);\r\n        currentNonce[cpAddress] = currentNonce[cpAddress].add(1);\r\n        \r\n        internalTransfer(cpAddress, _relayer, _amount, false, tickers[_feeTicker], address(0x0), address(0x0));\r\n        Pcontract(cpAddress).callContract(_dapp, _EthAmount, _calldata);\r\n    }\r\n    \r\n    \r\n    function interactDapp(address _dapp, uint256 _EthAmount, uint256 _amount, string calldata _feeTicker, uint256 _nonce, bytes calldata _sign, bytes calldata _calldata, address _relayer) external {\r\n        require(tickers[_feeTicker] != address(0x0));\r\n        \r\n        address cAddress = getSigner(\"interactDapp\", _dapp, _EthAmount, _amount, \"\", _feeTicker, _nonce, false, _calldata, _sign);\r\n        address payable cpAddress = userProxy[cAddress];\r\n        \r\n        require(cpAddress != address(0x0));\r\n        require(currentNonce[cAddress] == _nonce);\r\n        currentNonce[cAddress] = currentNonce[cAddress].add(1);\r\n        \r\n        internalTransfer(cAddress, _relayer, _amount, false, tickers[_feeTicker], address(0x0), address(0x0));\r\n        Pcontract(cpAddress).callContract(_dapp, _EthAmount, _calldata);\r\n    }\r\n    \r\n    \r\n    function processTxn(address _to, uint256 _amount, string calldata _ticker, string calldata _feeTicker, uint256 _nonce, bool _isParent, bytes calldata _sign, address _relayer) external {\r\n        address cAddress = getSigner(\"processTxn\", _to, 0, _amount, _ticker, _feeTicker, _nonce, _isParent, bytes(\"\"), _sign);\r\n        address tickerAddress = tickers[_ticker];\r\n        address feeTickerAddress;\r\n        \r\n        if(keccak256(abi.encodePacked(_ticker)) == keccak256(abi.encodePacked(_feeTicker))){\r\n            feeTickerAddress = tickerAddress;\r\n            require(tickerAddress != address(0x0));\r\n        } else {\r\n            feeTickerAddress = tickers[_feeTicker];\r\n            require(tickerAddress != address(0x0) && feeTickerAddress != address(0x0));\r\n        }\r\n        \r\n        \r\n        if(_isParent){\r\n            address pAddress = parantAddress[cAddress];\r\n            require(pAddress != address(0x0));\r\n            \r\n            addressMeta storage am = metaAddresses[pAddress];\r\n            \r\n            require(am.allowances[cAddress][tickerAddress] >= _amount);\r\n            am.allowances[cAddress][tickerAddress] = am.allowances[cAddress][tickerAddress].sub(_amount);\r\n            \r\n            if(tickerAddress != feeTickerAddress){\r\n                uint256 _fee = tickerFee[feeTickerAddress];\r\n                require(am.allowances[cAddress][feeTickerAddress] >= _fee);\r\n                am.allowances[cAddress][feeTickerAddress] = am.allowances[cAddress][feeTickerAddress].sub(_fee);\r\n            }\r\n            \r\n            cAddress = pAddress;\r\n        } \r\n        \r\n        require(currentNonce[cAddress] == _nonce);\r\n        currentNonce[cAddress] = currentNonce[cAddress].add(1);\r\n        \r\n        internalTransfer(cAddress, _to, _amount, true, tickerAddress, feeTickerAddress, _relayer);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function internalTransfer(address _from, address _to, uint256 _amount, bool _payfee, address _tickerAddress, address _feeTickerAddress, address _relayer) internal {\r\n        if(_payfee){\r\n            uint256 _fee = tickerFee[_feeTickerAddress];\r\n            if(_fee > 0){\r\n                if(_tickerAddress == _feeTickerAddress){\r\n                    require(_amount > _fee);\r\n                    _amount = _amount.sub(_fee);\r\n                }\r\n                \r\n                tERC20(_feeTickerAddress).transferFrom(_from, _relayer, _fee);\r\n            }\r\n        }\r\n        \r\n        if(_amount > 0){\r\n            tERC20(_tickerAddress).transferFrom(_from, _to, _amount);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function createProxy(address _address) external {\r\n        require(proxyContract != address(0x0));\r\n        require(userProxy[_address] == address(0x0));\r\n        \r\n        address payable _proxyAddress;\r\n        bytes20 targetBytes = bytes20(proxyContract);\r\n        \r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            _proxyAddress := create(0, clone, 0x37)\r\n        }\r\n        \r\n        userProxy[_address] = address(_proxyAddress);\r\n    }\r\n    \r\n    \r\n    function createProxyUT(address _address, uint256 _amount, string calldata _feeTicker, uint256 _nonce, bytes calldata _sign, address _relayer) external {\r\n        address cAddress = getSigner(\"createProxyUT\", _address, 0, _amount, \"\", _feeTicker, _nonce, false, bytes(\"\"), _sign);\r\n        \r\n        require(proxyContract != address(0x0));\r\n        require(userProxy[_address] == address(0x0));\r\n        require(tickers[_feeTicker] != address(0x0));\r\n        \r\n        require(currentNonce[cAddress] == _nonce);\r\n        currentNonce[cAddress] = currentNonce[cAddress].add(1);\r\n        \r\n        internalTransfer(cAddress, _relayer, _amount, false, tickers[_feeTicker], address(0x0), address(0x0));\r\n        \r\n        address payable _proxyAddress;\r\n        bytes20 targetBytes = bytes20(proxyContract);\r\n        \r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            _proxyAddress := create(0, clone, 0x37)\r\n        }\r\n        \r\n        userProxy[_address] = address(_proxyAddress);\r\n    }\r\n    \r\n    \r\n    \r\n    function pApprove(address _address, string calldata _ticker, uint256 _amount) external {\r\n        require(tickers[_ticker] != address(0x0));\r\n        require(userProxy[_address] != address(0x0));\r\n        \r\n        Pcontract(userProxy[_address]).approve(tickers[_ticker], _amount);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    //  ----------------------------------------------------------------------------\r\n    \r\n    \r\n    function getTotalChild(address _address) public view returns (uint) {\r\n        addressMeta storage am = metaAddresses[_address];\r\n        return am.currIndex;\r\n    }\r\n    \r\n    \r\n    function getChildAddressAtIndex(address _parent, uint _index) public view returns (address) {\r\n        addressMeta storage am = metaAddresses[_parent];\r\n        return am.childAddresses[_index];\r\n    }\r\n    \r\n    \r\n    function getChildAllowance(address _parent, address _childAddress, string memory _ticker) public view returns (uint) {\r\n        addressMeta storage am = metaAddresses[_parent];\r\n        return am.allowances[_childAddress][tickers[_ticker]];\r\n    }\r\n    \r\n    \r\n    // ----------------------------------------------------------------------------\r\n    \r\n    function addChildAddress(address _child) external {\r\n        require(parantAddress[_child] == address(0x0));\r\n        \r\n        addressMeta storage am = metaAddresses[msg.sender];\r\n        am.childAddresses[am.currIndex] = _child;\r\n        am.currIndex = (am.currIndex).add(1);\r\n        \r\n        parantAddress[_child] = msg.sender;\r\n    }\r\n    \r\n    \r\n    function addChildAddressUT(address _child, string calldata _feeTicker, uint256 _nonce, bytes calldata _sign, address _relayer) external {\r\n        require(parantAddress[_child] == address(0x0));\r\n        address cAddress = getSigner(\"addChildAddressUT\", _child, 0, 0, \"\", _feeTicker, _nonce, false, bytes(\"\"), _sign);\r\n        \r\n        \r\n        require(currentNonce[cAddress] == _nonce);\r\n        currentNonce[cAddress] = currentNonce[cAddress].add(1);\r\n        \r\n        address feeTickerAddress = tickers[_feeTicker];\r\n        require(feeTickerAddress != address(0x0));\r\n        \r\n        internalTransfer(cAddress, _relayer, tickerFee[feeTickerAddress], false, feeTickerAddress, address(0x0), address(0x0));\r\n        \r\n        \r\n        addressMeta storage am = metaAddresses[cAddress];\r\n        am.childAddresses[am.currIndex] = _child;\r\n        am.currIndex = (am.currIndex).add(1);\r\n        \r\n        parantAddress[_child] = cAddress;\r\n    }\r\n    \r\n    \r\n    // -------------------------------\r\n    \r\n    \r\n    function _childAllowance(address _parent, address _child, address _tickerAddress, uint256 _allowance) internal {\r\n        addressMeta storage am = metaAddresses[_parent];\r\n        am.allowances[_child][_tickerAddress] = _allowance;\r\n    }\r\n    \r\n    \r\n    \r\n    function childAllowance(address _child, uint256 _allowance, string calldata _ticker) external {\r\n        address tickerAddress = tickers[_ticker];\r\n        require(tickerAddress != address(0x0));\r\n        require(parantAddress[_child] == msg.sender);\r\n        \r\n        addressMeta storage am = metaAddresses[msg.sender];\r\n        am.allowances[_child][tickerAddress] = _allowance;\r\n    }\r\n    \r\n    \r\n    function childAllowanceUT(address _child, uint256 _allowance, string calldata _ticker, string calldata _feeTicker, uint256 _nonce, bytes calldata _sign, address _relayer) external {\r\n        address cAddress = getSigner(\"childAllowanceUT\", _child, 0, _allowance, _ticker, _feeTicker, _nonce, false, bytes(\"\"), _sign);\r\n        \r\n        require(parantAddress[_child] == cAddress);\r\n        require(currentNonce[cAddress] == _nonce);\r\n        currentNonce[cAddress] = currentNonce[cAddress].add(1);\r\n        \r\n        \r\n        address tickerAddress = tickers[_ticker];\r\n        address feeTickerAddress = tickers[_feeTicker];\r\n        require(tickerAddress != address(0x0) && feeTickerAddress != address(0x0));\r\n        \r\n        internalTransfer(cAddress, _relayer, tickerFee[feeTickerAddress], false, feeTickerAddress, address(0x0), address(0x0));\r\n        _childAllowance(cAddress, _child, tickerAddress, _allowance);\r\n    }\r\n    \r\n    \r\n    // ----------------------------------------------------------------------------\r\n    \r\n    \r\n    function destroyNonce() external {\r\n        currentNonce[msg.sender] = currentNonce[msg.sender].add(1);\r\n    }\r\n    \r\n    \r\n    // ------------->\r\n    \r\n    function _addTicker(string calldata _ticker, address _tickerAddress, uint256 _fee) external onlyOwner {\r\n        require(tickers[_ticker] == address(0x0) && _tickerAddress != address(0x0));\r\n        \r\n        tickers[_ticker] = _tickerAddress;\r\n        tickerFee[_tickerAddress] = _fee;\r\n    }\r\n    \r\n    \r\n    function _removeTicker(string calldata _ticker) external onlyOwner {\r\n        require(tickers[_ticker] != address(0x0));\r\n        \r\n        delete tickerFee[tickers[_ticker]];\r\n        delete tickers[_ticker];\r\n    }\r\n    \r\n    \r\n    function _updateTickerFee(string calldata _ticker, uint256 _fee) external onlyOwner {\r\n        require(tickers[_ticker] != address(0x0));\r\n        \r\n        tickerFee[tickers[_ticker]] = _fee;\r\n    }\r\n    \r\n    \r\n    function _setProxyContract(address _address) external onlyOwner {\r\n        require(proxyContract == address(0x0));\r\n        \r\n        proxyContract = _address;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_tickerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"_addTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"_removeTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_setProxyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"_updateTickerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_child\",\"type\":\"address\"}],\"name\":\"addChildAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_child\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_feeTicker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"addChildAddressUT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_child\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allowance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"childAllowance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_child\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allowance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_feeTicker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"childAllowanceUT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"createProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_feeTicker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"createProxyUT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyNonce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getChildAddressAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_childAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"getChildAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_func\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_EthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_feeTicker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_parent\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_cdata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTotalChild\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_EthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_feeTicker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"interactDapp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_EthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_feeTicker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"interactDappUProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"parantAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_feeTicker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isParent\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"processTxn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tickerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"tickers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userProxy\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"metaTransact","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://98c8c17901ebf7096508a3ac03ce5da1d780e454f6dd372599893190c7d79c34"}]}