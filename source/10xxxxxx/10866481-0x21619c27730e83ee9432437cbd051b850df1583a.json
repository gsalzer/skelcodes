{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  function totalSupply() pure public returns (uint256 supply);\r\n  function balanceOf(address _owner) pure public returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) pure public returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract TimeFarmerPool is Ownable {\r\n    \r\n  uint256 constant public TOKEN_PRECISION = 1e6;\r\n  uint256 constant private PRECISION = 1e12;  \r\n  uint256 constant private REBASE_TIME = 1 hours; \r\n\t\r\n  Token public liqudityToken;\r\n  Token public farmToken;\r\n  \r\n  struct User {\r\n        uint256 liqudityBalance;\r\n        uint256 appliedFarmTokenCirculation;\r\n  }\r\n    \r\n  struct Info {\r\n        uint256 totalFarmSupply;\r\n        \r\n        mapping(address => User) users;\r\n        address admin;\r\n        \r\n        uint256 coinWorkingTime;\r\n        uint256 coinCreationTime;\r\n  }\r\n    \r\n  Info private info;\r\n\r\n  address public liqudityTokenAddress;\r\n  address public farmTokenAddress;\r\n  uint256 public VaultCreation = now;\r\n  \r\n  constructor() public{\r\n      \r\n    info.coinWorkingTime = now;\r\n\tinfo.coinCreationTime = now;\r\n\t\r\n\tliqudityTokenAddress = 0x608903534527B0623fe0b0bd81a2F29BC5b50D32;\r\n\tfarmTokenAddress = 0x63A6da104C6a08dfeB50D13a7488F67bC98Cc41f;\r\n\t    \r\n    liqudityToken = Token(liqudityTokenAddress); \r\n    farmToken = Token(farmTokenAddress);\r\n    \r\n    info.totalFarmSupply = 0;\r\n  } \r\n  \r\n  function joinFarmPool(uint256 liqudityTokenToFarm) public payable {\r\n      \r\n    uint256 userBalance = liqudityToken.balanceOf(msg.sender);\r\n   \r\n    require(userBalance >= liqudityTokenToFarm, \"Insufficient tokens\");\r\n    \r\n    bool isNewUser = info.users[msg.sender].liqudityBalance == 0;\r\n\r\n\tif(isNewUser)\r\n\t{\r\n\t    adjustTime();\r\n\t    info.users[msg.sender].appliedFarmTokenCirculation = info.totalFarmSupply;\r\n\t}\r\n\telse\r\n\t{\r\n\t     claimTokens();\r\n\t}\r\n\t\r\n    liqudityToken.transferFrom(msg.sender, address(this), liqudityTokenToFarm);\r\n    \r\n    info.users[msg.sender].liqudityBalance += liqudityTokenToFarm;\r\n  }\r\n  \r\n  function leaveFarmPool(uint256 liqudityTokenFromFarm) public payable {\r\n      \r\n    uint256 userBalanceInPool = info.users[msg.sender].liqudityBalance;\r\n   \r\n    require(userBalanceInPool >= liqudityTokenFromFarm, \"Insufficient tokens\");\r\n    \r\n    claimTokens();\r\n    \r\n    liqudityToken.transfer(msg.sender, liqudityTokenFromFarm); \r\n    \r\n    info.users[msg.sender].liqudityBalance -= liqudityTokenFromFarm;\r\n  }\r\n  \r\n  \r\n  function claimTokens() public payable {\r\n    adjustTime();\r\n    \r\n    uint256 missingPoolToClaim = info.totalFarmSupply - info.users[msg.sender].appliedFarmTokenCirculation;\r\n    uint256 farmTokenToClaim = ((missingPoolToClaim * info.users[msg.sender].liqudityBalance) / liqudityToken.balanceOf(address(this)));\r\n\r\n    farmToken.transfer(msg.sender, farmTokenToClaim); \r\n    \r\n    info.users[msg.sender].appliedFarmTokenCirculation = info.totalFarmSupply;\r\n  }\r\n  \r\n  function adjustTime() private {\r\n    if(info.coinWorkingTime + REBASE_TIME < now)\r\n    {\r\n        uint256 countOfCoinsToAdd = ((now - info.coinCreationTime) / REBASE_TIME);\r\n        info.coinWorkingTime = now;\r\n        info.totalFarmSupply = (countOfCoinsToAdd * TOKEN_PRECISION); \r\n    }\r\n  }\r\n  \r\n  // Views\r\n  \r\n  function tokensToClaim(address _user)  public view returns (uint256 tokensToTake) {\r\n     uint256 countOfCoinsToAdd = ((now - info.coinCreationTime) / REBASE_TIME);\r\n      \r\n     uint256 realTotalSupply = (countOfCoinsToAdd * TOKEN_PRECISION); \r\n        \r\n     uint256 missingPoolToClaim = realTotalSupply - info.users[_user].appliedFarmTokenCirculation;\r\n     uint256 adjustedAddressBalance = ((missingPoolToClaim * info.users[_user].liqudityBalance) / liqudityToken.balanceOf(address(this)));\r\n    \r\n     return adjustedAddressBalance;\r\n  }\r\n  \r\n   function allMintedTokens()  public view returns (uint256 mintedTokens) {\r\n      uint256 countOfCoinsToAdd = ((now - info.coinCreationTime) / REBASE_TIME);\r\n      \r\n      uint256 allMintedTokensFromFarm = (countOfCoinsToAdd * TOKEN_PRECISION); \r\n        \r\n      return allMintedTokensFromFarm;\r\n  }\r\n  \r\n  function allInfoFor(address _user) public view returns (\r\n      uint256 totalFarmSupply,\r\n      uint256 allFarmTokens, \r\n      uint256 allLiquidityTokens,\r\n      uint256 myLiqudityInContract,\r\n      uint256 allFarmTokensContract, \r\n      uint256 allLiquidityTokensontract,\r\n      uint256 lockedLiqudityInContract\r\n      ) {\r\n\treturn (\r\n\tinfo.totalFarmSupply, \r\n\tfarmToken.balanceOf(_user), //metamask\r\n\tliqudityToken.balanceOf(_user), //metamask\r\n\tinfo.users[_user].liqudityBalance, //locked in contract\r\n\tfarmToken.balanceOf(address(this)), //contract farm tokens\r\n\tliqudityToken.balanceOf(address(this)), //liqudity tokens\r\n\tinfo.users[address(this)].liqudityBalance\r\n\t);\r\n  }\r\n\t\r\n\t\r\n  // Liqudity tokens dropped to contract not using functions so it lock itself\r\n  // Farm tokens dropped to contract not using functions so it lock itself\r\n  \r\n  function refundAll() onlyOwner public{\r\n    require(now > VaultCreation + 365 days); \r\n    farmToken.transfer(owner(), farmToken.balanceOf(this));  \r\n    liqudityToken.transfer(owner(), liqudityToken.balanceOf(this)); \r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"liqudityTokenToFarm\",\"type\":\"uint256\"}],\"name\":\"joinFarmPool\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liqudityTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"liqudityTokenFromFarm\",\"type\":\"uint256\"}],\"name\":\"leaveFarmPool\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"tokensToClaim\",\"outputs\":[{\"name\":\"tokensToTake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"allInfoFor\",\"outputs\":[{\"name\":\"totalFarmSupply\",\"type\":\"uint256\"},{\"name\":\"allFarmTokens\",\"type\":\"uint256\"},{\"name\":\"allLiquidityTokens\",\"type\":\"uint256\"},{\"name\":\"myLiqudityInContract\",\"type\":\"uint256\"},{\"name\":\"allFarmTokensContract\",\"type\":\"uint256\"},{\"name\":\"allLiquidityTokensontract\",\"type\":\"uint256\"},{\"name\":\"lockedLiqudityInContract\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VaultCreation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allMintedTokens\",\"outputs\":[{\"name\":\"mintedTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"farmTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"farmToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRECISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liqudityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TimeFarmerPool","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://476b2d3f12e26d3ae056abec13cb56ebeba9bb7f388faa8ef38fb00ac151ea99"}]}