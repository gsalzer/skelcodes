{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n\r\n/**\r\n * Game Credits ERC20 Token Contract\r\n * https://www.gamecredits.org\r\n * (c) 2020 GAME Credits. All Rights Reserved. This code is not open source.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface iERC20 {\r\n\r\n  /**\r\n    * @dev Returns the amount of tokens in existence.\r\n    */\r\n  function totalSupply() external view returns (uint);\r\n\r\n  /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n  function balanceOf(address account) external view returns (uint);\r\n\r\n  /**\r\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n  /**\r\n    * @dev Returns the remaining number of tokens that `spender` will be\r\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n    * zero by default.\r\n    *\r\n    * This value changes when {approve} or {transferFrom} are called.\r\n    */\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n    * that someone may use both the old and the new allowance by unfortunate\r\n    * transaction ordering. One possible solution to mitigate this race\r\n    * condition is to first reduce the spender's allowance to 0 and set the\r\n    * desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    *\r\n    * Emits an {Approval} event.\r\n    */\r\n  function approve(address spender, uint amount) external returns (bool);\r\n\r\n  /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller's\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n\r\n  /**\r\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n    * another (`to`).\r\n    *\r\n    * Note that `value` may be zero.\r\n    */\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  /**\r\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n    * a call to {approve}. `value` is the new allowance.\r\n    */\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n// @title iERC20Contract\r\n// @dev The interface for cross-contract calls to the ERC20 contract\r\n// @author GAME Credits Platform (https://www.gamecredits.org)\r\n// (c) 2020 GAME Credits. All Rights Reserved. This code is not open source.\r\ncontract iERC20Contract {\r\n  function isOfficialAccount(address account) external view returns(bool);\r\n}\r\n\r\n\r\n// @title ERC20Access\r\n// @dev ERC20Access contract for controlling access to ERC20 contract functions\r\n// @author GAME Credits Platform (https://www.gamecredits.org)\r\n// (c) 2020 GAME Credits. All Rights Reserved. This code is not open source.\r\ncontract ERC20Access is iERC20, iERC20Contract {\r\n\r\n  event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n  // The Owner can perform all admin tasks, including setting the recovery account.\r\n  address public owner;\r\n\r\n  // The Recovery account can change the Owner account.\r\n  address public recoveryAddress;\r\n\r\n\r\n  // @dev The original `owner` of the contract is the contract creator.\r\n  // @dev Internal constructor to ensure this contract can't be deployed alone\r\n  constructor()\r\n    internal\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  // @dev Access control modifier to limit access to the Owner account\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"sender must be owner\");\r\n    _;\r\n  }\r\n\r\n  // @dev Access control modifier to limit access to the Recovery account\r\n  modifier onlyRecovery() {\r\n    require(msg.sender == recoveryAddress, \"sender must be recovery\");\r\n    _;\r\n  }\r\n\r\n  // @dev Access control modifier to limit access to the Owner or Recovery account\r\n  modifier ownerOrRecovery() {\r\n    require(msg.sender == owner || msg.sender == recoveryAddress, \"sender must be owner or recovery\");\r\n    _;\r\n  }\r\n\r\n  // Used to check if an account is treated as official by this contract\r\n  // @param _account - the account to check\r\n  // @returns true if _account equals the owner or recoveryAccount, false otherwise\r\n  function isOfficialAccount(address _account)\r\n    external\r\n    view\r\n  returns(bool)\r\n  {\r\n    return _account == owner || _account == recoveryAddress;\r\n  }\r\n\r\n  // @dev Assigns a new address to act as the Owner.\r\n  // @notice Can only be called by the recovery account\r\n  // @param _newOwner The address of the new Owner\r\n  function setOwner(address _newOwner)\r\n    external\r\n    onlyRecovery\r\n  {\r\n    require(_newOwner != address(0), \"new owner must be a non-zero address\");\r\n    require(_newOwner != recoveryAddress, \"new owner can't be the recovery address\");\r\n\r\n    owner = _newOwner;\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n  }\r\n\r\n  // @dev Assigns a new address to act as the Recovery address.\r\n  // @notice Can only be called by the Owner account\r\n  // @param _newRecovery The address of the new Recovery account\r\n  function setRecovery(address _newRecovery)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_newRecovery != address(0), \"new owner must be a non-zero address\");\r\n    require(_newRecovery != owner, \"new recovery can't be the owner address\");\r\n\r\n    recoveryAddress = _newRecovery;\r\n  }\r\n\r\n  // @dev allows recovery of ERC20 tokens accidentally sent to this address\r\n  // @param tokenAddress - The address of the erc20 token\r\n  // @param tokens - The number of tokens to transfer\r\n  function transferAnyERC20Token(address tokenAddress, uint tokens)\r\n    public\r\n    ownerOrRecovery\r\n  returns (bool success)\r\n  {\r\n    return iERC20(tokenAddress).transfer(owner, tokens);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    *\r\n    * _Available since v2.4.0._\r\n    */\r\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    require(b <= a, errorMessage);\r\n    uint c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    *\r\n    * _Available since v2.4.0._\r\n    */\r\n  function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint a, uint b) internal pure returns (uint) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts with custom message when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    *\r\n    * _Available since v2.4.0._\r\n    */\r\n  function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {iERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {iERC20-approve}.\r\n */\r\ncontract ERC20Base is ERC20Access {\r\n  using SafeMath for uint;\r\n\r\n  mapping (address => uint) private _balances;\r\n\r\n  mapping (address => mapping (address => uint)) private _allowances;\r\n\r\n  uint private _totalSupply;\r\n\r\n  /**\r\n   * @dev Internal constructor to ensure this contract can't be deployed alone\r\n   */\r\n  constructor() internal{ }\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply()\r\n    public\r\n    view\r\n  returns (uint)\r\n  {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account)\r\n    public\r\n    view\r\n  returns (uint)\r\n  {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `recipient` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address recipient, uint amount)\r\n    public\r\n  returns (bool)\r\n  {\r\n    _transfer(msg.sender, recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n  returns (uint)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint amount)\r\n    public\r\n  returns (bool)\r\n  {\r\n    _approve(msg.sender, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {ERC20};\r\n   *\r\n   * Requirements:\r\n   * - `sender` and `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for `sender`'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint amount)\r\n    public\r\n  returns (bool)\r\n  {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {iERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n  function increaseAllowance(address spender, uint addedValue)\r\n    public\r\n  returns (bool)\r\n  {\r\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {iERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    * - `spender` must have allowance for the caller of at least\r\n    * `subtractedValue`.\r\n    */\r\n  function decreaseAllowance(address spender, uint subtractedValue)\r\n    public\r\n  returns (bool)\r\n  {\r\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n    *\r\n    * This is internal function is equivalent to {transfer}, and can be used to\r\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `sender` cannot be the zero address.\r\n    * - `recipient` cannot be the zero address.\r\n    * - `sender` must have a balance of at least `amount`.\r\n    */\r\n  function _transfer(address sender, address recipient, uint amount)\r\n    internal\r\n  {\r\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n    * the total supply.\r\n    *\r\n    * Emits a {Transfer} event with `from` set to the zero address.\r\n    *\r\n    * Requirements\r\n    *\r\n    * - `to` cannot be the zero address.\r\n    */\r\n  function _mint(address account, uint amount)\r\n    internal\r\n  {\r\n    require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n    * @dev Destroys `amount` tokens from `account`, reducing the\r\n    * total supply.\r\n    *\r\n    * Emits a {Transfer} event with `to` set to the zero address.\r\n    *\r\n    * Requirements\r\n    *\r\n    * - `account` cannot be the zero address.\r\n    * - `account` must have at least `amount` tokens.\r\n    */\r\n  function _burn(address account, uint amount)\r\n    internal\r\n  {\r\n    require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n    _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n    *\r\n    * This is internal function is equivalent to `approve`, and can be used to\r\n    * e.g. set automatic allowances for certain subsystems, etc.\r\n    *\r\n    * Emits an {Approval} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `owner` cannot be the zero address.\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n  function _approve(address owner, address spender, uint amount)\r\n    internal\r\n  {\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n}\r\n\r\n\r\n\r\n// @title iSupportContract\r\n// @dev The interface for cross-contract calls to Support contracts\r\n// @author GAME Credits Platform (https://www.gamecredits.org)\r\n// (c) 2020 GAME Credits. All Rights Reserved. This code is not open source.\r\ncontract iSupportContract {\r\n\r\n  function isSupportContract() external pure returns(bool);\r\n\r\n  function getGameAccountSupport(uint _game, address _account) external view returns(uint);\r\n  function updateSupport(uint _game, address _account, uint _supportAmount) external;\r\n  function fundRewardsPool(uint _amount, uint _startWeek, uint _numberOfWeeks) external;\r\n\r\n  function receiveGameCredits(uint _game, address _account, uint _tokenId, uint _payment, bytes32 _data) external;\r\n  function receiveLoyaltyPayment(uint _game, address _account, uint _tokenId, uint _payment, bytes32 _data) external;\r\n  function contestEntry(uint _game, address _account, uint _tokenId, uint _contestId, uint _payment, bytes32 _data) external;\r\n\r\n  event GameCreditsPayment(uint indexed _game, address indexed account, uint indexed _tokenId, uint _payment, bytes32 _data);\r\n  event LoyaltyPayment(uint indexed _game, address indexed account, uint indexed _tokenId, uint _payment, bytes32 _data);\r\n  event EnterContest(uint indexed _game, address indexed account, uint _tokenId, uint indexed _contestId, uint _payment, bytes32 _data);\r\n}\r\n\r\n\r\n// @title Game Credits ERC20 Token Contract\r\n// @dev Contract for managing the GAME ERC20 token\r\n// @author GAME Credits Platform (https://www.gamecredits.org)\r\n// (c) 2020 GAME Credits. All Rights Reserved. This code is not open source.\r\ncontract GameCredits is ERC20Base {\r\n\r\n  string public url = \"https://www.gamecredits.org\";\r\n  string public name = \"GAME Credits\";\r\n  string public symbol = \"GAME\";\r\n  uint8 public decimals = 18;\r\n\r\n  // Listing of all the support contracts registered to this contract\r\n  // @notice Support contracts can be added, but cannot be removed. If an erroneous one\r\n  //   is added, it is up to users to not call it\r\n  mapping (address => iSupportContract) supportContracts;\r\n\r\n  event SupportContractAdded(address indexed supportContract);\r\n\r\n  // @notice The constructor mints 200 million GAME tokens to the contract creator\r\n  //   There is no other way to create GAME tokens, capping supply at 200 million\r\n  constructor()\r\n    public\r\n  {\r\n    _mint(msg.sender, 200 * 10 ** 24);\r\n  }\r\n\r\n  // @notice The fallback function reverts\r\n  function ()\r\n    external\r\n    payable\r\n  {\r\n    revert(\"this contract is not payable\");\r\n  }\r\n\r\n  // @dev Used to set the support contract reference for this contract\r\n  // @param _supportContract - the address of the support contract\r\n  // @notice This is a one-shot function. Once the address is set, it's locked\r\n  function setSupportContract(address _supportContract)\r\n    external\r\n    ownerOrRecovery\r\n  {\r\n    iSupportContract supportContract = iSupportContract(_supportContract);\r\n    require(supportContract.isSupportContract(), \"Must implement isSupportContract\");\r\n    supportContracts[_supportContract] = supportContract;\r\n    emit SupportContractAdded(_supportContract);\r\n  }\r\n\r\n  // @dev Lets any user add funds to the supporting pool spread over a period of weeks\r\n  // @param _rewardsContract - the contract that will be funded\r\n  // @param _amount - the total amount of GAME tokens to add to the support pool\r\n  // @param _startWeek - the first week in which tokens will be added to the support pool\r\n  // @param _numberOfWeeks - the number of weeks over which the _amount will be spread\r\n  // @notice - The _amount must be exactly divisible by the _numberOfWeeks\r\n  function fundRewardsContract(address _rewardsContract, uint _amount, uint _startWeek, uint _numberOfWeeks)\r\n    external\r\n  {\r\n    iSupportContract rewardsContract = _getSupportContract(_rewardsContract);\r\n    _transfer(msg.sender, address(rewardsContract), _amount);\r\n    rewardsContract.fundRewardsPool(_amount, _startWeek, _numberOfWeeks);\r\n  }\r\n\r\n  // @dev Sets the sender's support on a game to the specific value\r\n  // @param _rewardsContract - the contract that will set support\r\n  // @param _game - the game to be supported\r\n  // @param _increase - the amount support to be added\r\n  // @notice - this will throw if the user has insufficient tokens available\r\n  // @notice - this does not throw on an _amount of 0\r\n  function setSupport(address _rewardsContract, uint _game, uint _amount) public {\r\n    iSupportContract rewardsContract = _getSupportContract(_rewardsContract);\r\n    _setSupport(rewardsContract, msg.sender, _game, _amount);\r\n  }\r\n\r\n  // @dev Increases the sender's support on a game\r\n  // @param _rewardsContract - the contract that will increase support\r\n  // @param _game - the game to be supported\r\n  // @param _increase - the amount support to be added\r\n  // @notice - this will throw if the user has insufficient tokens available\r\n  // @notice - this will throw if an increase of 0 is requested\r\n  function increaseSupport(address _rewardsContract, uint _game, uint _increase) public {\r\n    iSupportContract rewardsContract = _getSupportContract(_rewardsContract);\r\n    uint supportBalance = rewardsContract.getGameAccountSupport(_game, msg.sender);\r\n    require(_increase > 0, \"can't increase by 0\");\r\n    _setSupport(rewardsContract, msg.sender, _game, supportBalance.add(_increase));\r\n  }\r\n\r\n  // @dev Reduces the sender's support on a game\r\n  // @param _rewardsContract - the contract that will decrease support\r\n  // @param _game - the game to be supported\r\n  // @param _decrease - the amount support to be reduced\r\n  // @notice - this will throw if the user has fewer tokens support\r\n  // @notice - this will throw if a decrease of 0 is requested\r\n  function decreaseSupport(address _rewardsContract, uint _game, uint _decrease) public {\r\n    iSupportContract rewardsContract = _getSupportContract(_rewardsContract);\r\n    uint supportBalance = rewardsContract.getGameAccountSupport(_game, msg.sender);\r\n    require(_decrease > 0, \"can't decrease by 0\");\r\n    _setSupport(rewardsContract, msg.sender, _game, supportBalance.sub(_decrease));\r\n  }\r\n\r\n  // @dev Transfers tokens to a set of user accounts, and sets their support for them\r\n  // @param _rewardsContract - the contract that will set the support\r\n  // @param _recipients - the accounts to receive the tokens\r\n  // @param _games - the games to be supported\r\n  // @param _amounts - the amount of tokens to be transferred\r\n  // @notice - this function is designed for air dropping by/to a game\r\n  function airDropAndSupport(\r\n    address _rewardsContract,\r\n    address[] calldata _recipients,\r\n    uint[] calldata _games,\r\n    uint[] calldata _amounts\r\n  )\r\n    external\r\n  {\r\n    iSupportContract rewardsContract = _getSupportContract(_rewardsContract);\r\n    require(_recipients.length == _games.length, \"must be equal number of recipients and games\");\r\n    require(_recipients.length == _amounts.length, \"must be equal number of recipients and amounts\");\r\n    for (uint i = 0; i < _recipients.length; i++) {\r\n      require(_recipients[i] != msg.sender, \"can't airDrop to your own account\");\r\n      uint supportBalance = rewardsContract.getGameAccountSupport(_games[i], _recipients[i]);\r\n      uint supportAmount = _amounts[i].add(supportBalance);\r\n      _transfer(msg.sender, _recipients[i], _amounts[i]);\r\n      _setSupport(rewardsContract, _recipients[i], _games[i], supportAmount);\r\n    }\r\n  }\r\n\r\n  // @dev Pays an amount of game credits to a given support contract.\r\n  //   The support contract will often route the payment to multiple destinations.\r\n  //   The exact functionality will depend on the support contract in question.\r\n  //   Not all support contracts will implement the receiveGameCredits function\r\n  // @param _supportContract - the support contract to be called\r\n  // @param _game - a field to enter a game Id if it is required by the support contract\r\n  // @param _tokenId - a field to enter a token Id if it is required by the support contract\r\n  // @param _payment - the amount of GAME Credits that will be paid\r\n  // @param _data - a field to enter additional data if it is required by the support contract\r\n  function payGameCredits(\r\n    address _supportContract,\r\n    uint _game,\r\n    uint _tokenId,\r\n    uint _payment,\r\n    bytes32 _data\r\n  )\r\n    external\r\n  {\r\n    iSupportContract supportContract = _getSupportContract(_supportContract);\r\n\r\n    _transfer(msg.sender, _supportContract, _payment);\r\n    supportContract.receiveGameCredits(_game, msg.sender, _tokenId, _payment, _data);\r\n  }\r\n\r\n  // @dev Requests a payment of an amount of Loyalty Points in the sidechain.\r\n  //   The payment is made on the sidechain by the oracle.\r\n  //   There is no error checking, other than ensuring the game exists.\r\n  //   The exact functionality will depend on the oracle, and the sidechain contract in question.\r\n  //   Not all support contracts will implement the payLoyaltyPoints function, and even\r\n  //     if they do, the oracle might not pick it up.\r\n  // @param _supportContract - the support contract to be called\r\n  // @param _game - a field to enter a game Id if it is required by the support contract\r\n  // @param _tokenId - a field to enter a token Id if it is required by the support contract\r\n  // @param _payment - the amount of Loyalty Points requested to be paid\r\n  // @param _data - a field to enter additional data if it is required by the support contract\r\n  function payLoyaltyPoints(\r\n    address _supportContract,\r\n    uint _game,\r\n    uint _tokenId,\r\n    uint _loyaltyPayment,\r\n    bytes32 _data\r\n  )\r\n    external\r\n  {\r\n    iSupportContract supportContract = _getSupportContract(_supportContract);\r\n    supportContract.receiveLoyaltyPayment(_game, msg.sender, _tokenId, _loyaltyPayment, _data);\r\n  }\r\n\r\n  // @dev Pays an amount of game credits to a given support contract.\r\n  //   The support contract will often route the payment to multiple destinations.\r\n  //   The exact functionality will depend on the support contract in question.\r\n  //   Not all support contracts will implement the contestEntry function\r\n  // @param _supportContract - the support contract to be called\r\n  // @param _game - a field to enter a game Id if it is required by the support contract\r\n  // @param _tokenId - a field to enter a token Id if it is required by the support contract\r\n  // @param _contestId - a field to enter a contest Id if it is required by the support contract\r\n  // @param _payment - the amount of GAME Credits that will be paid\r\n  // @param _data - a field to enter additional data if it is required by the support contract\r\n  function enterContest(\r\n    address _supportContract,\r\n    uint _game,\r\n    uint _tokenId,\r\n    uint _contestId,\r\n    uint _payment,\r\n    bytes32 _data\r\n  )\r\n    external\r\n  {\r\n    iSupportContract supportContract = _getSupportContract(_supportContract);\r\n    _transfer(msg.sender, _supportContract, _payment);\r\n    supportContract.contestEntry(_game, msg.sender, _tokenId, _contestId, _payment, _data);\r\n  }\r\n\r\n  // @dev returns the iSupportContract for the input address. Throws if it doesn't exist.\r\n  // @param _contractAddress - the address to test\r\n  // @returns iSupportContract - the support contract address, typed as iSupportContract\r\n  function _getSupportContract(address _contractAddress)\r\n    internal\r\n    view\r\n  returns (iSupportContract)\r\n  {\r\n    iSupportContract supportContract = supportContracts[_contractAddress];\r\n    require(address(supportContract) != address(0), \"support contract must be valid\");\r\n    return supportContract;\r\n  }\r\n\r\n  // @dev Sends the new support level to the rewards contract; transfers tokens to the\r\n  //   contract (for increased support) or from the contract (for decreased support)\r\n  // @param iSupportContract - the contract that will set the support\r\n  // @param _supporter - the account doing the supporting\r\n  // @param _game - the game to be supported\r\n  // @param _amount - the amount of tokens to set the support to\r\n  function _setSupport(iSupportContract rewardsContract, address _supporter, uint _game, uint _amount)\r\n    internal\r\n  {\r\n    // get user's balance from rewards contract\r\n    uint supportBalance = rewardsContract.getGameAccountSupport(_game, _supporter);\r\n\r\n    if (_amount == supportBalance) {\r\n      return;\r\n    } else if (_amount > supportBalance) {\r\n      // transfer diff to rewards contract\r\n      _transfer(_supporter, address(rewardsContract), _amount.sub(supportBalance));\r\n    } else if (_amount < supportBalance) {\r\n      // transfer diff to account\r\n      _transfer(address(rewardsContract), _supporter, supportBalance.sub(_amount));\r\n    }\r\n    rewardsContract.updateSupport(_game, _supporter, _amount);\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supportContract\",\"type\":\"address\"}],\"name\":\"SupportContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_games\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"airDropAndSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decrease\",\"type\":\"uint256\"}],\"name\":\"decreaseSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_supportContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_contestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"enterContest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startWeek\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfWeeks\",\"type\":\"uint256\"}],\"name\":\"fundRewardsContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_increase\",\"type\":\"uint256\"}],\"name\":\"increaseSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOfficialAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_supportContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"payGameCredits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_supportContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_loyaltyPayment\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"payLoyaltyPoints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recoveryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRecovery\",\"type\":\"address\"}],\"name\":\"setRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_supportContract\",\"type\":\"address\"}],\"name\":\"setSupportContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"url\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GameCredits","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://59b2f161fb565df3de098e17041856adb29475dc29d79c6974f781c1c63ba6fb"}]}