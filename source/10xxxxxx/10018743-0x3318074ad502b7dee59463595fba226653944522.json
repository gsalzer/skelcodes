{"status":"1","message":"OK","result":[{"SourceCode":"{\"EscapeVerifier.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\nimport \\\"IFactRegistry.sol\\\";\\n\\n/*\\n  An escapeVerifier is a fact registry contract for claims of the form:\\n  (starkKey, tokenId, quantizedAmount) is the leaf in index vaultId of a Merkle tree with\\n  specific height and root.\\n*/\\ncontract EscapeVerifier is IFactRegistry {\\n\\n    // Note that those values are hardcoded in the assembly.\\n    uint256 constant internal N_TABLES = 63;\\n\\n    address[N_TABLES] lookupTables;\\n    constructor(address[N_TABLES] memory tables)\\n        public {\\n        lookupTables = tables;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            if gt(lookupTables_slot, 0) {\\n                // The address of the lookupTables must be 0.\\n                // This is guaranteed by the ABI, as long as it is the first storage variable.\\n                // This is an assumption in the implementation, and can be removed if\\n                // the lookup table address is taken into account.\\n                revert(0, 0)\\n            }\\n\\n        }\\n    }\\n\\n    /**\\n      Verifies that the contents of a vault belong to a certain Merkle commitment (root).\\n\\n      The Merkle commitment uses the Pedersen hash variation described next:\\n\\n      - **Hash constants:** A sequence :math:`p_i` of 504 points on an elliptic curve and an additional :math:`ec_{shift}` point\\n      - **Input:** A vector of 504 bits :math:`b_i`\\n      - **Output:** The 252 bits x coordinate of :math:`(ec_{shift} + \\\\sum_i b_i*p_i)`\\n\\n      The following table describes the expected `escapeProof` format. Note that unlike a standard\\n      Merkle proof, the `escapeProof` contains both the nodes along the Merkle path and their\\n      siblings. The proof ends with the expected root and the ID of the vault for which the proof is\\n      submitted (which implies the location of the nodes within the Merkle tree).\\n\\n          +-------------------------------+---------------------------+-----------+\\n          | starkKey (252)                | tokenId (252)             | zeros (8) |\\n          +-------------------------------+---------------------------+-----------+\\n          | hash(starkKey, tokenId) (252) | quantizedAmount (252)     | zeros (8) |\\n          +-------------------------------+---------------------------+-----------+\\n          | left_node_0 (252)             | right_node_0 (252)        | zeros (8) |\\n          +-------------------------------+---------------------------+-----------+\\n          | ...                                                                   |\\n          +-------------------------------+---------------------------+-----------+\\n          | left_node_n (252)             | right_node_n (252)        | zeros (8) |\\n          +-------------------------------+-----------+---------------+-----------+\\n          | root (252)                    | zeros (4) | vaultId (248) | zeros (8) |\\n          +-------------------------------+-----------+---------------+-----------+\\n\\n      If the proof is accepted, this is registered under the following claim hash that may later\\n      be queried for validity:\\n\\n        `claimHash = keccak256(starkKey, tokenId, quantizedAmount, vaultRoot, treeHeight, vaultId)`\\n\\n      For information about when this module is to be used, see :sol:mod:`Escapes`.\\n\\n    */\\n    /*\\n      Implementation details:\\n      The EC sum required for the hash computation is computed using lookup tables and EC additions.\\n      There are 63 lookup tables and each table contains all the possible subset sums of the\\n      corresponding 8 EC points in the hash definition.\\n\\n      Both the full subset sum and the tables are shifted to avoid a special case for the 0 point.\\n      lookupTables[0] uses the offset 2^62*ec_shift and lookupTables[k] for k \\u003e 0 uses\\n      the offset 2^(62-k)*(-ec_shift).\\n      Note that the sum of the shifts of all the tables is exactly the shift required for the\\n      hash. Moreover, the partial sums of those shifts are never 0.\\n\\n      The calls to the lookup table contracts are batched to save on gas cost.\\n      We allocate a table of N_HASHES by N_TABLES EC elements.\\n      Fill the i\\u0027th row by calling the i\\u0027th lookup contract to lookup the i\\u0027th byte in each hash and\\n      then compute the j\\u0027th hash by summing the j\\u0027th column.\\n\\n                  N_HASHES\\n              --------------\\n              |            |\\n              |            |\\n              |            |\\n              |            | N_TABLES\\n              |            |\\n              |            |\\n              |            |\\n              |            |\\n              --------------\\n\\n      The batched lookup is facilitated by the fact that the escapeProof includes nodes along the\\n      Merkle path.\\n      However having this redundant information requires us to do consistency checks\\n      to ensure we indeed verify a coherent authentication path:\\n\\n          hash((left_node_{i-1}, right_node_{i-1})) ==\\n            (vaultId \\u0026 (1\\u003c\\u003ci)) == 0 ? left_node_i : right_node_i.\\n    */\\n    function verifyEscape(uint256[] calldata escapeProof) external {\\n        uint256 proofLength = escapeProof.length;\\n\\n        // The minimal supported proof length is for a tree height of 31 in a 68 word representation as follows:\\n        // 1. 2 word pairs representing the vault contents + one hash of the 1st pair.\\n        // 2. 31  word pairs representing the authentication path.\\n        // 3. 1 word pair representing the root and the leaf index.\\n        require(proofLength \\u003e= 68, \\\"Proof too short.\\\");\\n\\n        // The contract supports verification paths of lengths up to 97 in a 200 word representation as described above.\\n        // This limitation is imposed in order to avoid potential attacks.\\n        require(proofLength \\u003c 200, \\\"Proof too long.\\\");\\n\\n        // Ensure proofs are always a series of word pairs.\\n        require((proofLength \\u0026 1) == 0, \\\"Proof length must be even.\\\");\\n\\n        // Each hash takes 2 256bit words and the last two words are the root and vaultId.\\n        uint256 nHashes = (proofLength - 2) / 2;\\n\\n        // We use 2 hashes to compute the leaf.\\n        uint256 height = nHashes - 2;\\n\\n        // Note that it is important to limit the range of vault id, to make sure\\n        // we use the node = Merkle_root in the last iteration of the loop below.\\n        uint256 vaultId = escapeProof[proofLength - 1] \\u003e\\u003e 8;\\n        require(vaultId \\u003c 2**height, \\\"vaultId not in tree.\\\");\\n\\n        uint256 rowSize = (2 * nHashes) * 0x20;\\n        uint256[] memory proof = escapeProof;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            // Skip the length of the proof array.\\n            proof := add(proof, 0x20)\\n\\n            function raise_error(message, msg_len) {\\n                // Solidity generates reverts with reason that look as follows:\\n                // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b\\u0027Error(string)\\u0027)[:4]).\\n                // 2. 32 bytes offset bytes (typically 0x20).\\n                // 3. 32 bytes with the length of the revert reason.\\n                // 4. Revert reason string.\\n\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x4, 0x20)\\n                mstore(0x24, msg_len)\\n                mstore(0x44, message)\\n                revert(0, add(0x44, msg_len))\\n            }\\n\\n            let starkKey := shr(4, mload(proof))\\n            let tokenId := and(mload(add(proof, 0x1f)),\\n                               0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n\\n            let primeMinusOne := 0x800000000000011000000000000000000000000000000000000000000000000\\n            if or(gt(starkKey, primeMinusOne), gt(tokenId, primeMinusOne)) {\\n                raise_error(\\\"Bad starkKey or tokenId.\\\", 24)\\n            }\\n\\n            // hash(starkKey, tokenId) is on the left of the second hash.\\n            let nodeSelectors := shl(1, vaultId)\\n\\n            // Allocate EC points table with dimensions N_TABLES by N_HASHES.\\n            let table := mload(0x40)\\n            let tableEnd := add(table, mul(rowSize, /*N_TABLES*/63))\\n\\n            // for i = 0..N_TABLES-1, fill the i\\u0027th row in the table.\\n            for { let i := 0 } lt(i, 63) { i := add(i, 1)} {\\n                if iszero(staticcall(gas, sload(i), add(proof, i), rowSize,\\n                                     add(table, mul(i, rowSize)), rowSize)) {\\n                   returndatacopy(0, 0, returndatasize)\\n                   revert(0, returndatasize)\\n                }\\n            }\\n\\n            // The following variables are allocated above PRIME to avoid the stack too deep error.\\n            // Byte offset used to access the table and proof.\\n            let offset := 0\\n            let ptr\\n            let aZ\\n\\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\\n\\n            // For k = 0..HASHES-1, Compute the k\\u0027th hash by summing the k\\u0027th column in table.\\n            // Instead of k we use offset := k * sizeof(EC point).\\n            // Additonally we use ptr := offset + j * rowSize to ge over the EC points we want\\n            // to sum.\\n            for { } lt(offset, rowSize) { } {\\n                // Init (aX, aY, aZ) to the first value in the current column and sum over the\\n                // column.\\n                ptr := add(table, offset)\\n                aZ := 1\\n                let aX := mload(ptr)\\n                let aY := mload(add(ptr, 0x20))\\n\\n                for { ptr := add(ptr, rowSize) } lt(ptr, tableEnd)\\n                    { ptr:= add(ptr, rowSize) } {\\n\\n                    let bX := mload(ptr)\\n                    let bY := mload(add(ptr, 0x20))\\n\\n                    // Set (aX, aY, aZ) to be the sum of the EC points (aX, aY, aZ) and (bX, bY, 1).\\n                    let minusAZ := sub(PRIME, aZ)\\n                    // Slope = sN/sD =  {(aY/aZ) - (bY/1)} / {(aX/aZ) - (bX/1)}.\\n                    // sN = aY - bY * aZ.\\n                    let sN := addmod(aY, mulmod(minusAZ, bY, PRIME), PRIME)\\n\\n                    let minusAZBX := mulmod(minusAZ, bX, PRIME)\\n                    // sD = aX - bX * aZ.\\n                    let sD := addmod(aX, minusAZBX, PRIME)\\n\\n                    let sSqrD := mulmod(sD, sD, PRIME)\\n\\n                    // Compute the (affine) x coordinate of the result as xN/xD.\\n\\n                    // (xN/xD) = ((sN)^2/(sD)^2) - (aX/aZ) - (bX/1).\\n                    // xN = (sN)^2 * aZ - aX * (sD)^2 - bX * (sD)^2 * aZ.\\n                    // = (sN)^2 * aZ + (sD^2) (bX * (-aZ) - aX).\\n                    let xN := addmod(mulmod(mulmod(sN, sN, PRIME), aZ, PRIME),\\n                                    mulmod(sSqrD,\\n                                            add(minusAZBX, sub(PRIME, aX)),\\n                                            PRIME),\\n                                    PRIME)\\n\\n                    // xD = (sD)^2 * aZ.\\n                    let xD := mulmod(sSqrD, aZ, PRIME)\\n\\n                    // Compute (aX\\u0027, aY\\u0027, aZ\\u0027) for the next iteration and assigning them to (aX, aY, aZ).\\n                    // (y/z) = (sN/sD) * {(bX/1) - (xN/xD)} - (bY/1).\\n                    // aZ\\u0027 = sD*xD.\\n                    aZ := mulmod(sD, xD, PRIME)\\n                    // aY\\u0027 = sN*(bX * xD - xN) - bY*z = -bY * z + sN * (-xN + xD*bX).\\n                    aY := addmod(sub(PRIME, mulmod(bY, aZ, PRIME)),\\n                                    mulmod(sN,\\n                                    add(sub(PRIME, xN),\\n                                        mulmod(xD, bX, PRIME)),\\n                                    PRIME),\\n                                PRIME)\\n\\n                    // As the value of the affine x coordinate is xN/xD and z=sD*xD,\\n                    // the projective x coordinate is xN*sD.\\n                    aX := mulmod(xN, sD, PRIME)\\n                }\\n\\n                // At this point proof[offset + 0x40] holds the next input to be hashed.\\n                // This input is typically in the form left_node||right_node||0 and\\n                // we need to extract the relevent node for the consistent check below.\\n                // Note that the same logic is reused for the leaf computation and\\n                // for the consistent check with the final root.\\n                offset := add(offset, 0x40)\\n\\n                // Init expected_hash to left_node.\\n                // It will be replaced by right_node if necessary.\\n                let expected_hash := shr(4, mload(add(proof, offset)))\\n\\n                let other_node := and(  // right_node\\n                    mload(add(proof, add(offset, 0x1f))),\\n                    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n\\n                // Make sure both nodes are in the range [0, PRIME - 1].\\n                if or(gt(expected_hash, primeMinusOne), gt(other_node, primeMinusOne)) {\\n                    raise_error(\\\"Value out of range.\\\", 19)\\n                }\\n\\n                if and(nodeSelectors, 1) {\\n                    expected_hash := other_node\\n                }\\n\\n                // Make sure the result is consistent with the Merkle path.\\n                // I.e (aX/aZ) == expected_hash,\\n                // where expected_hash = (nodeSelectors \\u0026 1) == 0 ? left_node : right_node.\\n                // We also make sure aZ is not 0. I.e. during the summation we never tried\\n                // to add two points with the same x coordinate.\\n                // This is not strictly necessary because knowing how to trigger this condition\\n                // implies knowing a non-trivial linear equation on the random points defining the\\n                // hash function.\\n                if iszero(aZ) {\\n                   raise_error(\\\"aZ is zero.\\\", 11)\\n                }\\n\\n                if sub(aX, mulmod(expected_hash, aZ, PRIME))/*!=0*/ {\\n                   raise_error(\\\"Bad Merkle path.\\\", 16)\\n                }\\n                nodeSelectors := shr(1, nodeSelectors)\\n            }\\n\\n            mstore(0, starkKey)\\n            mstore(0x20,  tokenId)\\n            mstore(0x40,  // quantizedAmount\\n                   and(mload(add(proof, 0x5f)),\\n                       0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))\\n            mstore(0x60, shr(4, mload(add(proof, rowSize)))) // vaultRoot\\n            mstore(0x80, height)\\n            mstore(0xa0, vaultId)\\n\\n            // claimHash := keccak256(\\n            //      starkKey, tokenId, quantizedAmount, vaultRoot, height, vaultId).\\n            // storage[claimHash] := 1.\\n            sstore(keccak256(0, 0xc0), 1)\\n        }\\n    }\\n\\n\\n    /*\\n      Checks the validity status of the claim corresponding to:\\n      keccak256(abi.encode(starkKey, tokenId, quantizedAmount, root, height, vaultId)).\\n    */\\n    function isValid(bytes32 hash)\\n    external view returns(bool val)\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            val := sload(hash)\\n        }\\n    }\\n}\\n\"},\"IFactRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\n/*\\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\\n  business logic of the contract flow.\\n\\n  A fact registry holds a hash table of verified \\\"facts\\\" which are represented by a hash of claims\\n  that the registry hash check and found valid. This table may be queried by accessing the\\n  isValid() function of the registry with a given hash.\\n\\n  In addition, each fact registry exposes a registry specific function for submitting new claims\\n  together with their proofs. The information submitted varies from one registry to the other\\n  depending of the type of fact requiring verification.\\n\\n  For further reading on the Fact Registry design pattern see this\\n  `StarkWare blog post \\u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\\u003e`_.\\n*/\\ncontract IFactRegistry {\\n    /*\\n      Returns true if the given fact was previously registered in the contract.\\n    */\\n    function isValid(bytes32 fact)\\n        external view\\n        returns(bool);\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[63]\",\"name\":\"tables\",\"type\":\"address[63]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"isValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"escapeProof\",\"type\":\"uint256[]\"}],\"name\":\"verifyEscape\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EscapeVerifier","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"0000000000000000000000003325e8c5d390aec436ff225779dcdd4d12314f270000000000000000000000005429509172710e58bb5bcacc550f3f980c9922330000000000000000000000007f7cb4b506ed8f17de6d35d3a33d8976d67ecdd20000000000000000000000001f396a7f8695247cf59fa20a8712776723831a4e000000000000000000000000d2724cff92e4fb9d268ace4b935316f863d254a1000000000000000000000000d5dcdadded0967dfd142c6fed9f7042703a088d40000000000000000000000008f91a4214b618b01c9594bd24bdee2ef317232890000000000000000000000009e6d164fa1aac396f9e43e2be487aae7c30be280000000000000000000000000022b47e37a3010688343e55d603fa6283b896690000000000000000000000000ad91e3112f771423a2541492e7c448640022319d000000000000000000000000f37de395d4542b2569d7ee29d9cc95d3052c3d3b0000000000000000000000005a7fa37f1579d0c01008a5f58d5620d3a63a55c40000000000000000000000003f4794a3965f074139157c58bae2a430335e99db000000000000000000000000541f7350cd28596de8952b5b589bc787d15dcc980000000000000000000000003511627d93a82d674ee31d13b66797362ef02b8600000000000000000000000084ab3eeade82519965f9025ff3eb7c8a766188af00000000000000000000000021f9214709b8c27f97aff3579b50f958f9acfc61000000000000000000000000b63b81a06eee9a8a26f1d06ce1405fce83cded6a0000000000000000000000005cffd98cab9044e2793b103f5a0624178862c2610000000000000000000000001a14602619d1d2a74cb585d51dd4b21d85224b7100000000000000000000000091dbd50021d130fe238564aa5fb12738b37ad4bc000000000000000000000000c5f6ccd88f63830e081ec4bd731d6831c9b3b1160000000000000000000000006b930261955b33389a77dfe32150e2cba337a3ca000000000000000000000000e63adecc2e13844a7ba7538682bead0dc8462fbd000000000000000000000000a5c893e8625010bc1540c6531a870e62f78c0eb70000000000000000000000009d3fd9b24a206c680b52f154727a5ddd56aa39a000000000000000000000000018e80fa7802af0a3f3e95616be44dd4d0fcc7939000000000000000000000000a01c0c4eb0ed14f58d69be4f91ba72ebc8348e1f000000000000000000000000f82e395916a96e6a8030eed1553dc138d955bb4b00000000000000000000000012048d9d1f7b349517c139f513ec7a935fdc63c40000000000000000000000008344be5293e810659460d39dee509cf9d269fa4200000000000000000000000038870cd26e79d1f254d8af368286e0ae3286636400000000000000000000000007e3fe674bb6fccd7c1f3ee4789df50be0c6f0d6000000000000000000000000d6a561e177a3052cdc16d872522b70eefcfa27be00000000000000000000000040066a2bdaae99474e675ed77ba5a720b20c4a30000000000000000000000000fc7e6df14d65b7d4a3ffb9bd6064332733cb0479000000000000000000000000069fe848b2648a66bf058f7118e7e6bee447770f000000000000000000000000cb1ff41b7bece607c2ca2619381342f01510864e00000000000000000000000084253ec1578affd76453479be335be65375625400000000000000000000000002c8ff23e595849e3a4b303e80efe8a5ec9779cab000000000000000000000000974eae262de47bef42670c8e854aab4cabbb35d90000000000000000000000003770f554f9604c7f1730762501a38bc4fe82a2db000000000000000000000000287df1a8c699cc3b14d31d9351fd34ecb349938b000000000000000000000000f90860ceaee3dbbcd48b3368308644a9d868fc6a00000000000000000000000086c7a6a07b6e9152ad68b0906da997aa868db9c7000000000000000000000000701b4b446a297382078167d63911734c2b021e2d000000000000000000000000d3b06ab11b1fa5786d1dc1c9db5bab5febbba55e000000000000000000000000610787b7b8be9077f2f67cd2467c3b6942ed1a2a00000000000000000000000050e37c5497a56eb99d32e77206157663ae14e2c3000000000000000000000000d6828b1436a83fdd783400975f631f46beaa14a80000000000000000000000007a3f5179721c7c15719a39b82ec86bd57afd57c20000000000000000000000008d089b74b48afe95e2265dd8088b851ef186e5d40000000000000000000000000d04eb7393ed549bc910faa9e9033de7a3aad3ba00000000000000000000000062ef96151942fcc6da68e1d56161e3dc607a314b0000000000000000000000009a53b25feac3a46ea3caf7fba7f6bc9543678e9c00000000000000000000000081c14cc73ed4a51370c2b2648b28d71d595f38190000000000000000000000006cbb47ab221f20949b17b17524b31d20f2822452000000000000000000000000069d1fc7d0b8104f2804626c6d568a17ebc28b55000000000000000000000000ada2274efb1afc76634db2de873e10ab5e5b9988000000000000000000000000d94ff8b17e8c03ba24b1d36a09eb0df72dcf07ec00000000000000000000000040c47f7013630ae10ae6548de678bd701dfbf6ff000000000000000000000000e778e3cea2b42a0286667e6882947ec9ac928dc20000000000000000000000009e65312260907d5a66c6d0f407aa29e761d9bd5e","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c6fa013898236c938c498ba3fa8914387a41e68c8437ad5c255aef7840eb74b4"}]}