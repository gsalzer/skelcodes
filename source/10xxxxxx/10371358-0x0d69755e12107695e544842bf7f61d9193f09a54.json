{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\ninterface ISynth {\r\n    function currencyKey() external view returns (bytes32);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n}\r\n\r\ninterface ISynthetix {\r\n    function availableSynths(uint index) external view returns (ISynth);\r\n    function availableSynthCount() external view returns (uint);\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\r\n}\r\n\r\ninterface IExchangeRates {\r\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\r\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\r\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\r\n    external\r\n    view\r\n    returns (uint);\r\n}\r\n\r\ninterface IAddressResolver {\r\n    function getAddress(bytes32 name) external view returns (address);\r\n    function getSynth(bytes32 key) external view returns (address);\r\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\r\n}\r\n\r\ncontract SynthSummaryUtil {\r\n\r\n    IAddressResolver public addressResolverProxy;\r\n\r\n    bytes32 internal constant CONTRACT_SYNTHETIX = \"Synthetix\";\r\n    bytes32 internal constant CONTRACT_EXRATES = \"ExchangeRates\";\r\n    bytes32 internal constant SUSD = \"sUSD\";\r\n\r\n    constructor(address resolver) public {\r\n        addressResolverProxy = IAddressResolver(resolver);\r\n    }\r\n\r\n    function _synthetix() internal view returns (ISynthetix) {\r\n        return ISynthetix(addressResolverProxy.requireAndGetAddress(CONTRACT_SYNTHETIX, \"Missing Synthetix address\"));\r\n    }\r\n\r\n    function _exchangeRates() internal view returns (IExchangeRates) {\r\n        return IExchangeRates(addressResolverProxy.requireAndGetAddress(CONTRACT_EXRATES, \"Missing ExchangeRates address\"));\r\n    }\r\n\r\n    function totalSynthsInKey(address account, bytes32 currencyKey) external view returns (uint total) {\r\n        ISynthetix synthetix = _synthetix();\r\n        IExchangeRates exchangeRates = _exchangeRates();\r\n        uint numSynths = synthetix.availableSynthCount();\r\n        for (uint i = 0; i < numSynths; i++) {\r\n            ISynth synth = synthetix.availableSynths(i);\r\n            total += exchangeRates.effectiveValue(synth.currencyKey(), synth.balanceOf(account), currencyKey);\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function synthsBalances(address account) external view returns (bytes32[] memory, uint[] memory,  uint[] memory) {\r\n        ISynthetix synthetix = _synthetix();\r\n        IExchangeRates exchangeRates = _exchangeRates();\r\n        uint numSynths = synthetix.availableSynthCount();\r\n        bytes32[] memory currencyKeys = new bytes32[](numSynths);\r\n        uint[] memory balances = new uint[](numSynths);\r\n        uint[] memory sUSDBalances = new uint[](numSynths);\r\n        for (uint i = 0; i < numSynths; i++) {\r\n            ISynth synth = synthetix.availableSynths(i);\r\n            currencyKeys[i] = synth.currencyKey();\r\n            balances[i] = synth.balanceOf(account);\r\n            sUSDBalances[i] = exchangeRates.effectiveValue(currencyKeys[i], balances[i], SUSD);\r\n        }\r\n        return (currencyKeys, balances, sUSDBalances);\r\n    }\r\n\r\n    function frozenSynths() external view returns (bytes32[] memory) {\r\n        ISynthetix synthetix = _synthetix();\r\n        IExchangeRates exchangeRates = _exchangeRates();\r\n        uint numSynths = synthetix.availableSynthCount();\r\n        bytes32[] memory frozenSynthsKeys = new bytes32[](numSynths);\r\n        for (uint i = 0; i < numSynths; i++) {\r\n            ISynth synth = synthetix.availableSynths(i);\r\n            if (exchangeRates.rateIsFrozen(synth.currencyKey())) {\r\n                frozenSynthsKeys[i] = synth.currencyKey();\r\n            }\r\n\r\n        }\r\n        return frozenSynthsKeys;\r\n    }\r\n\r\n    function synthsRates() external view returns (bytes32[] memory, uint[] memory) {\r\n        bytes32[] memory currencyKeys = _synthetix().availableCurrencyKeys();\r\n        return (currencyKeys, _exchangeRates().ratesForCurrencies(currencyKeys));\r\n    }\r\n\r\n    function synthsTotalSupplies()\r\n        external\r\n        view\r\n        returns (bytes32[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n        ISynthetix synthetix = _synthetix();\r\n        IExchangeRates exchangeRates = _exchangeRates();\r\n\r\n        uint256 numSynths = synthetix.availableSynthCount();\r\n        bytes32[] memory currencyKeys = new bytes32[](numSynths);\r\n        uint256[] memory balances = new uint256[](numSynths);\r\n        uint256[] memory sUSDBalances = new uint256[](numSynths);\r\n        for (uint256 i = 0; i < numSynths; i++) {\r\n            ISynth synth = synthetix.availableSynths(i);\r\n            currencyKeys[i] = synth.currencyKey();\r\n            balances[i] = synth.totalSupply();\r\n            sUSDBalances[i] = exchangeRates.effectiveValue(\r\n                currencyKeys[i],\r\n                balances[i],\r\n                SUSD\r\n            );\r\n        }\r\n        return (currencyKeys, balances, sUSDBalances);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressResolverProxy\",\"outputs\":[{\"internalType\":\"contract IAddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenSynths\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"synthsBalances\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsRates\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsTotalSupplies\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"totalSynthsInKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SynthSummaryUtil","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004e3b31eb0e5cb73641ee1e65e7dcefe520ba3ef2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://439a157c6868a57ffcee5b88f5fbd0ab384cb4e422a4061bf88c8353db7d9fac"}]}