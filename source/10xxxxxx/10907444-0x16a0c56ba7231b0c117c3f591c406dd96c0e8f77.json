{"status":"1","message":"OK","result":[{"SourceCode":"{\"ABDKMath64x64.sol\":{\"content\":\"/* ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\\r\\n * Author: Mikhail Vladimirov \\u003cmikhail.vladimirov@gmail.com\\u003e\\r\\n *\\r\\n * SPDX-License-Identifier: BSD 4-Clause \\\"Original\\\" or \\\"Old\\\" License\\r\\n * Copyright (c) 2019, ABDK Consulting\\r\\n * \\r\\n * All rights reserved.\\r\\n * \\r\\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\r\\n * \\r\\n *  - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\r\\n *  - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\r\\n *  - All advertising materials mentioning features or use of this software must display the following acknowledgement: This product includes software developed by ABDK Consulting.\\r\\n *  - Neither the name of ABDK Consulting nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\r\\n * \\r\\n * THIS SOFTWARE IS PROVIDED BY ABDK CONSULTING \\u0027\\u0027AS IS\\u0027\\u0027 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ABDK CONSULTING BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\r\\n */\\r\\npragma solidity ^0.5.0 || ^0.6.0;\\r\\n\\r\\n/**\\r\\n * Smart contract library of mathematical functions operating with signed\\r\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\r\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\r\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\r\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\r\\n * represented by int128 type holding only the numerator.\\r\\n */\\r\\nlibrary ABDKMath64x64 {\\r\\n  /**\\r\\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\r\\n\\r\\n  /**\\r\\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n  /**\\r\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function fromInt (int256 x) internal pure returns (int128) {\\r\\n    require (x \\u003e= -0x8000000000000000 \\u0026\\u0026 x \\u003c= 0x7FFFFFFFFFFFFFFF);\\r\\n    return int128 (x \\u003c\\u003c 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\r\\n   * rounding down.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64-bit integer number\\r\\n   */\\r\\n  function toInt (int128 x) internal pure returns (int64) {\\r\\n    return int64 (x \\u003e\\u003e 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\r\\n    require (x \\u003c= 0x7FFFFFFFFFFFFFFF);\\r\\n    return int128 (x \\u003c\\u003c 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\r\\n   * number rounding down.  Revert on underflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return unsigned 64-bit integer number\\r\\n   */\\r\\n  function toUInt (int128 x) internal pure returns (uint64) {\\r\\n    require (x \\u003e= 0);\\r\\n    return uint64 (x \\u003e\\u003e 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\r\\n   * number rounding down.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 128.128-bin fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function from128x128 (int256 x) internal pure returns (int128) {\\r\\n    int256 result = x \\u003e\\u003e 64;\\r\\n    require (result \\u003e= MIN_64x64 \\u0026\\u0026 result \\u003c= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\r\\n   * number.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 128.128 fixed point number\\r\\n   */\\r\\n  function to128x128 (int128 x) internal pure returns (int256) {\\r\\n    return int256 (x) \\u003c\\u003c 64;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x + y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) + y;\\r\\n    require (result \\u003e= MIN_64x64 \\u0026\\u0026 result \\u003c= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x - y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) - y;\\r\\n    require (result \\u003e= MIN_64x64 \\u0026\\u0026 result \\u003c= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) * y \\u003e\\u003e 64;\\r\\n    require (result \\u003e= MIN_64x64 \\u0026\\u0026 result \\u003c= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\r\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 256-bit integer number\\r\\n   */\\r\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\r\\n    if (x == MIN_64x64) {\\r\\n      require (y \\u003e= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF \\u0026\\u0026\\r\\n        y \\u003c= 0x1000000000000000000000000000000000000000000000000);\\r\\n      return -y \\u003c\\u003c 63;\\r\\n    } else {\\r\\n      bool negativeResult = false;\\r\\n      if (x \\u003c 0) {\\r\\n        x = -x;\\r\\n        negativeResult = true;\\r\\n      }\\r\\n      if (y \\u003c 0) {\\r\\n        y = -y; // We rely on overflow behavior here\\r\\n        negativeResult = !negativeResult;\\r\\n      }\\r\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\r\\n      if (negativeResult) {\\r\\n        require (absoluteResult \\u003c=\\r\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\r\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\r\\n      } else {\\r\\n        require (absoluteResult \\u003c=\\r\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n        return int256 (absoluteResult);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\r\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 256-bit integer number\\r\\n   */\\r\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\r\\n    if (y == 0) return 0;\\r\\n\\r\\n    require (x \\u003e= 0);\\r\\n\\r\\n    uint256 lo = (uint256 (x) * (y \\u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) \\u003e\\u003e 64;\\r\\n    uint256 hi = uint256 (x) * (y \\u003e\\u003e 128);\\r\\n\\r\\n    require (hi \\u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    hi \\u003c\\u003c= 64;\\r\\n\\r\\n    require (hi \\u003c=\\r\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\r\\n    return hi + lo;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    int256 result = (int256 (x) \\u003c\\u003c 64) / y;\\r\\n    require (result \\u003e= MIN_64x64 \\u0026\\u0026 result \\u003c= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    bool negativeResult = false;\\r\\n    if (x \\u003c 0) {\\r\\n      x = -x; // We rely on overflow behavior here\\r\\n      negativeResult = true;\\r\\n    }\\r\\n    if (y \\u003c 0) {\\r\\n      y = -y; // We rely on overflow behavior here\\r\\n      negativeResult = !negativeResult;\\r\\n    }\\r\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\r\\n    if (negativeResult) {\\r\\n      require (absoluteResult \\u003c= 0x80000000000000000000000000000000);\\r\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    } else {\\r\\n      require (absoluteResult \\u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    uint128 result = divuu (x, y);\\r\\n    require (result \\u003c= uint128 (MAX_64x64));\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate -x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function neg (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return -x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate |x|.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function abs (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return x \\u003c 0 ? -x : x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function inv (int128 x) internal pure returns (int128) {\\r\\n    require (x != 0);\\r\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\r\\n    require (result \\u003e= MIN_64x64 \\u0026\\u0026 result \\u003c= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\r\\n    return int128 ((int256 (x) + int256 (y)) \\u003e\\u003e 1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\r\\n   * Revert on overflow or in case x * y is negative.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 m = int256 (x) * int256 (y);\\r\\n    require (m \\u003e= 0);\\r\\n    require (m \\u003c\\r\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\r\\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) \\u003e\\u003e 1));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\r\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y uint256 value\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\r\\n    uint256 absoluteResult;\\r\\n    bool negativeResult = false;\\r\\n    if (x \\u003e= 0) {\\r\\n      absoluteResult = powu (uint256 (x) \\u003c\\u003c 63, y);\\r\\n    } else {\\r\\n      // We rely on overflow behavior here\\r\\n      absoluteResult = powu (uint256 (uint128 (-x)) \\u003c\\u003c 63, y);\\r\\n      negativeResult = y \\u0026 1 \\u003e 0;\\r\\n    }\\r\\n\\r\\n    absoluteResult \\u003e\\u003e= 63;\\r\\n\\r\\n    if (negativeResult) {\\r\\n      require (absoluteResult \\u003c= 0x80000000000000000000000000000000);\\r\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    } else {\\r\\n      require (absoluteResult \\u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate sqrt (x) rounding down.  Revert if x \\u003c 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function sqrt (int128 x) internal pure returns (int128) {\\r\\n    require (x \\u003e= 0);\\r\\n    return int128 (sqrtu (uint256 (x) \\u003c\\u003c 64, 0x10000000000000000));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate binary logarithm of x.  Revert if x \\u003c= 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function log_2 (int128 x) internal pure returns (int128) {\\r\\n    require (x \\u003e 0);\\r\\n\\r\\n    int256 msb = 0;\\r\\n    int256 xc = x;\\r\\n    if (xc \\u003e= 0x10000000000000000) { xc \\u003e\\u003e= 64; msb += 64; }\\r\\n    if (xc \\u003e= 0x100000000) { xc \\u003e\\u003e= 32; msb += 32; }\\r\\n    if (xc \\u003e= 0x10000) { xc \\u003e\\u003e= 16; msb += 16; }\\r\\n    if (xc \\u003e= 0x100) { xc \\u003e\\u003e= 8; msb += 8; }\\r\\n    if (xc \\u003e= 0x10) { xc \\u003e\\u003e= 4; msb += 4; }\\r\\n    if (xc \\u003e= 0x4) { xc \\u003e\\u003e= 2; msb += 2; }\\r\\n    if (xc \\u003e= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n    int256 result = msb - 64 \\u003c\\u003c 64;\\r\\n    uint256 ux = uint256 (x) \\u003c\\u003c 127 - msb;\\r\\n    for (int256 bit = 0x8000000000000000; bit \\u003e 0; bit \\u003e\\u003e= 1) {\\r\\n      ux *= ux;\\r\\n      uint256 b = ux \\u003e\\u003e 255;\\r\\n      ux \\u003e\\u003e= 127 + b;\\r\\n      result += bit * int256 (b);\\r\\n    }\\r\\n\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate natural logarithm of x.  Revert if x \\u003c= 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function ln (int128 x) internal pure returns (int128) {\\r\\n    require (x \\u003e 0);\\r\\n\\r\\n    return int128 (\\r\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF \\u003e\\u003e 128);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate binary exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp_2 (int128 x) internal pure returns (int128) {\\r\\n    require (x \\u003c 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x \\u003c -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    uint256 result = 0x80000000000000000000000000000000;\\r\\n\\r\\n    if (x \\u0026 0x8000000000000000 \\u003e 0)\\r\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x4000000000000000 \\u003e 0)\\r\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x2000000000000000 \\u003e 0)\\r\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x1000000000000000 \\u003e 0)\\r\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x800000000000000 \\u003e 0)\\r\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x400000000000000 \\u003e 0)\\r\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x200000000000000 \\u003e 0)\\r\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x100000000000000 \\u003e 0)\\r\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x80000000000000 \\u003e 0)\\r\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x40000000000000 \\u003e 0)\\r\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x20000000000000 \\u003e 0)\\r\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x10000000000000 \\u003e 0)\\r\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x8000000000000 \\u003e 0)\\r\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x4000000000000 \\u003e 0)\\r\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x2000000000000 \\u003e 0)\\r\\n      result = result * 0x1000162E525EE054754457D5995292026 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x1000000000000 \\u003e 0)\\r\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x800000000000 \\u003e 0)\\r\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x400000000000 \\u003e 0)\\r\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x200000000000 \\u003e 0)\\r\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x100000000000 \\u003e 0)\\r\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x80000000000 \\u003e 0)\\r\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x40000000000 \\u003e 0)\\r\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x20000000000 \\u003e 0)\\r\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x10000000000 \\u003e 0)\\r\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x8000000000 \\u003e 0)\\r\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x4000000000 \\u003e 0)\\r\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x2000000000 \\u003e 0)\\r\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x1000000000 \\u003e 0)\\r\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x800000000 \\u003e 0)\\r\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x400000000 \\u003e 0)\\r\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x200000000 \\u003e 0)\\r\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x100000000 \\u003e 0)\\r\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x80000000 \\u003e 0)\\r\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x40000000 \\u003e 0)\\r\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x20000000 \\u003e 0)\\r\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x10000000 \\u003e 0)\\r\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x8000000 \\u003e 0)\\r\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x4000000 \\u003e 0)\\r\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x2000000 \\u003e 0)\\r\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x1000000 \\u003e 0)\\r\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x800000 \\u003e 0)\\r\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x400000 \\u003e 0)\\r\\n      result = result * 0x100000000002C5C85FDF477B662B26945 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x200000 \\u003e 0)\\r\\n      result = result * 0x10000000000162E42FEFA3AE53369388C \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x100000 \\u003e 0)\\r\\n      result = result * 0x100000000000B17217F7D1D351A389D40 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x80000 \\u003e 0)\\r\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x40000 \\u003e 0)\\r\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x20000 \\u003e 0)\\r\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x10000 \\u003e 0)\\r\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x8000 \\u003e 0)\\r\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x4000 \\u003e 0)\\r\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x2000 \\u003e 0)\\r\\n      result = result * 0x1000000000000162E42FEFA39F02B772C \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x1000 \\u003e 0)\\r\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x800 \\u003e 0)\\r\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x400 \\u003e 0)\\r\\n      result = result * 0x100000000000002C5C85FDF473DEA871F \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x200 \\u003e 0)\\r\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x100 \\u003e 0)\\r\\n      result = result * 0x100000000000000B17217F7D1CF79E949 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x80 \\u003e 0)\\r\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x40 \\u003e 0)\\r\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x20 \\u003e 0)\\r\\n      result = result * 0x100000000000000162E42FEFA39EF366F \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x10 \\u003e 0)\\r\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x8 \\u003e 0)\\r\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x4 \\u003e 0)\\r\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x2 \\u003e 0)\\r\\n      result = result * 0x1000000000000000162E42FEFA39EF358 \\u003e\\u003e 128;\\r\\n    if (x \\u0026 0x1 \\u003e 0)\\r\\n      result = result * 0x10000000000000000B17217F7D1CF79AB \\u003e\\u003e 128;\\r\\n\\r\\n    result \\u003e\\u003e= 63 - (x \\u003e\\u003e 64);\\r\\n    require (result \\u003c= uint256 (MAX_64x64));\\r\\n\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate natural exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp (int128 x) internal pure returns (int128) {\\r\\n    require (x \\u003c 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x \\u003c -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    return exp_2 (\\r\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 \\u003e\\u003e 128));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 64.64-bit fixed point number\\r\\n   */\\r\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    uint256 result;\\r\\n\\r\\n    if (x \\u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      result = (x \\u003c\\u003c 64) / y;\\r\\n    else {\\r\\n      uint256 msb = 192;\\r\\n      uint256 xc = x \\u003e\\u003e 192;\\r\\n      if (xc \\u003e= 0x100000000) { xc \\u003e\\u003e= 32; msb += 32; }\\r\\n      if (xc \\u003e= 0x10000) { xc \\u003e\\u003e= 16; msb += 16; }\\r\\n      if (xc \\u003e= 0x100) { xc \\u003e\\u003e= 8; msb += 8; }\\r\\n      if (xc \\u003e= 0x10) { xc \\u003e\\u003e= 4; msb += 4; }\\r\\n      if (xc \\u003e= 0x4) { xc \\u003e\\u003e= 2; msb += 2; }\\r\\n      if (xc \\u003e= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n      result = (x \\u003c\\u003c 255 - msb) / ((y - 1 \\u003e\\u003e msb - 191) + 1);\\r\\n      require (result \\u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 hi = result * (y \\u003e\\u003e 128);\\r\\n      uint256 lo = result * (y \\u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 xh = x \\u003e\\u003e 192;\\r\\n      uint256 xl = x \\u003c\\u003c 64;\\r\\n\\r\\n      if (xl \\u003c lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n      lo = hi \\u003c\\u003c 128;\\r\\n      if (xl \\u003c lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n\\r\\n      assert (xh == hi \\u003e\\u003e 128);\\r\\n\\r\\n      result += xl / y;\\r\\n    }\\r\\n\\r\\n    require (result \\u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    return uint128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\\r\\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x unsigned 129.127-bit fixed point number\\r\\n   * @param y uint256 value\\r\\n   * @return unsigned 129.127-bit fixed point number\\r\\n   */\\r\\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\\r\\n    if (y == 0) return 0x80000000000000000000000000000000;\\r\\n    else if (x == 0) return 0;\\r\\n    else {\\r\\n      int256 msb = 0;\\r\\n      uint256 xc = x;\\r\\n      if (xc \\u003e= 0x100000000000000000000000000000000) { xc \\u003e\\u003e= 128; msb += 128; }\\r\\n      if (xc \\u003e= 0x10000000000000000) { xc \\u003e\\u003e= 64; msb += 64; }\\r\\n      if (xc \\u003e= 0x100000000) { xc \\u003e\\u003e= 32; msb += 32; }\\r\\n      if (xc \\u003e= 0x10000) { xc \\u003e\\u003e= 16; msb += 16; }\\r\\n      if (xc \\u003e= 0x100) { xc \\u003e\\u003e= 8; msb += 8; }\\r\\n      if (xc \\u003e= 0x10) { xc \\u003e\\u003e= 4; msb += 4; }\\r\\n      if (xc \\u003e= 0x4) { xc \\u003e\\u003e= 2; msb += 2; }\\r\\n      if (xc \\u003e= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n      int256 xe = msb - 127;\\r\\n      if (xe \\u003e 0) x \\u003e\\u003e= xe;\\r\\n      else x \\u003c\\u003c= -xe;\\r\\n\\r\\n      uint256 result = 0x80000000000000000000000000000000;\\r\\n      int256 re = 0;\\r\\n\\r\\n      while (y \\u003e 0) {\\r\\n        if (y \\u0026 1 \\u003e 0) {\\r\\n          result = result * x;\\r\\n          y -= 1;\\r\\n          re += xe;\\r\\n          if (result \\u003e=\\r\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\r\\n            result \\u003e\\u003e= 128;\\r\\n            re += 1;\\r\\n          } else result \\u003e\\u003e= 127;\\r\\n          if (re \\u003c -127) return 0; // Underflow\\r\\n          require (re \\u003c 128); // Overflow\\r\\n        } else {\\r\\n          x = x * x;\\r\\n          y \\u003e\\u003e= 1;\\r\\n          xe \\u003c\\u003c= 1;\\r\\n          if (x \\u003e=\\r\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\r\\n            x \\u003e\\u003e= 128;\\r\\n            xe += 1;\\r\\n          } else x \\u003e\\u003e= 127;\\r\\n          if (xe \\u003c -127) return 0; // Underflow\\r\\n          require (xe \\u003c 128); // Overflow\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (re \\u003e 0) result \\u003c\\u003c= re;\\r\\n      else if (re \\u003c 0) result \\u003e\\u003e= -re;\\r\\n\\r\\n      return result;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\r\\n   * number.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return unsigned 128-bit integer number\\r\\n   */\\r\\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\\r\\n    if (x == 0) return 0;\\r\\n    else {\\r\\n      require (r \\u003e 0);\\r\\n      while (true) {\\r\\n        uint256 rr = x / r;\\r\\n        if (r == rr || r + 1 == rr) return uint128 (r);\\r\\n        else if (r == rr + 1) return uint128 (rr);\\r\\n        r = r + rr + 1 \\u003e\\u003e 1;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\"},\"ACOStrategy1.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\u0027./BlackScholes.sol\\u0027;\\r\\nimport \\u0027./IACOStrategy.sol\\u0027;\\r\\nimport \\u0027./AggregatorV3Interface.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ACOStrategy1\\r\\n * @dev The contract is to set the strategy for an ACO Pool.\\r\\n * This strategy is only to selling ACO tokens.\\r\\n */\\r\\ncontract ACOStrategy1 is Ownable, IACOStrategy {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the order size factors has been changed.\\r\\n     * orderSizePenaltyFactor * order size percentage ^ orderSizeDampingFactor\\r\\n     * @param oldOrderSizePenaltyFactor Value of the previous order size penalty factor.\\r\\n     * @param oldOrderSizeDampingFactor Value of the previous order size damping factor.\\r\\n     * @param newOrderSizePenaltyFactor Value of the new order size penalty factor.\\r\\n     * @param newOrderSizeDampingFactor Value of the new order size damping factor.\\r\\n     */\\r\\n    event SetOrderSizeFactors(uint256 oldOrderSizePenaltyFactor, uint256 oldOrderSizeDampingFactor, uint256 newOrderSizePenaltyFactor, uint256 newOrderSizeDampingFactor);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the underlying price percentage adjust has been changed.\\r\\n     * @param oldUnderlyinPriceAdjustPercentage Value of the previous percentage adjust on the underlying price to calculate the option price.\\r\\n     * @param newUnderlyingPriceAdjustPercentage Value of the new percentage adjust on the underlying price to calculate the option price.\\r\\n     */\\r\\n    event SetUnderlyingPriceAdjustPercentage(uint256 oldUnderlyinPriceAdjustPercentage, uint256 newUnderlyingPriceAdjustPercentage);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the minimum percentage for the option price calculation has been changed.\\r\\n     * @param oldMinOptionPricePercentage Value of the previous minimum percentage for the option price calculation.\\r\\n     * @param newMinOptionPricePercentage Value of the new minimum percentage for the option price calculation.\\r\\n     */\\r\\n\\tevent SetMinOptionPricePercentage(uint256 oldMinOptionPricePercentage, uint256 newMinOptionPricePercentage);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the tolerance percentage for the underlying price on the Oracle has been changed.\\r\\n     * @param oldTolerancePercentageToOraclePrice Value of the previous tolerance percentage for the underlying price on the Oracle.\\r\\n     * @param newTolerancePercentageToOraclePrice Value of the new tolerance percentage for the underlying price on the Oracle.\\r\\n     */\\r\\n\\tevent SetTolerancePercentageToOraclePrice(uint256 oldTolerancePercentageToOraclePrice, uint256 newTolerancePercentageToOraclePrice);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the Oracle aggregator data has been changed.\\r\\n     * @param underlying Address of the underlying asset.\\r\\n     * @param strikeAsset Address of the strike asset.\\r\\n     * @param previousAggregator Address of the previous Oracle aggregator.\\r\\n     * @param newAggregator Address of the new Oracle aggregator.\\r\\n     */\\r\\n    event SetAggregator(address indexed underlying, address indexed strikeAsset, address previousAggregator, address newAggregator);\\r\\n    \\r\\n    /**\\r\\n     * @dev The percentage precision. (100000 = 100%)\\r\\n     */\\r\\n    uint256 internal constant PERCENTAGE_PRECISION = 100000;\\r\\n    \\r\\n    /**\\r\\n     * @dev Struct to store the Oracle aggregator data.\\r\\n     */\\r\\n    struct AggregatorData {\\r\\n        /**\\r\\n         * @dev Address of the Oracle aggregator.\\r\\n         */\\r\\n        address aggregator;\\r\\n        \\r\\n        /**\\r\\n         * @dev Oracle aggregator precision. (8 decimals = 100000000)\\r\\n         */\\r\\n        uint256 precision;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev The percentage adjust on the underlying price to calculate the option price.\\r\\n     */\\r\\n    uint256 public underlyingPriceAdjustPercentage;\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev The minimum percentage for the option price calculation.\\r\\n     */\\r\\n\\tuint256 public minOptionPricePercentage;\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev The order size penalty factor.\\r\\n     */\\r\\n    uint256 public orderSizePenaltyFactor;\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev The order size damping factor.\\r\\n     */\\r\\n    uint256 public orderSizeDampingFactor;\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev The tolerance percentage for the underlying price on the Oracle.\\r\\n     */\\r\\n    uint256 public tolerancePercentageToOraclePrice;\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev The Oracle aggregators data. (underlying =\\u003e strikeAsset =\\u003e AggregatorData)\\r\\n     */\\r\\n    mapping(address =\\u003e mapping(address =\\u003e AggregatorData)) public aggregators; \\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev The asset precision. (6 decimals = 1000000)\\r\\n     */\\r\\n    mapping(address =\\u003e uint256) public assetPrecision;\\r\\n    \\r\\n\\t/**\\r\\n     * @dev The order size divider factor used on the calculation.\\r\\n     */\\r\\n    uint256 internal orderSizeDivFactor;\\r\\n    \\r\\n    constructor(\\r\\n        uint256 _underlyingPriceAdjustPercentage,\\r\\n\\t\\tuint256 _minOptionPricePercentage,\\r\\n\\t\\tuint256 _tolerancePercentageToOraclePrice,\\r\\n        uint256 _orderSizePenaltyFactor,\\r\\n        uint256 _orderSizeDampingFactor\\r\\n    ) public {\\r\\n\\t\\tsuper.init();\\r\\n\\t\\t\\r\\n        _setUnderlyingPriceAdjustPercentage(_underlyingPriceAdjustPercentage);\\r\\n\\t\\t_setMinOptionPricePercentage(_minOptionPricePercentage);\\r\\n\\t\\t_setTolerancePercentageToOraclePrice(_tolerancePercentageToOraclePrice);\\r\\n        _setOrderSizeFactors(_orderSizePenaltyFactor, _orderSizeDampingFactor);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the percentage adjust on the underlying price to calculate the option price.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param _underlyingPriceAdjustPercentage Value of the new percentage adjust on the underlying price to calculate the option price.\\r\\n     */\\r\\n    function setUnderlyingPriceAdjustPercentage(uint256 _underlyingPriceAdjustPercentage) onlyOwner public {\\r\\n        _setUnderlyingPriceAdjustPercentage(_underlyingPriceAdjustPercentage);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to set the minimum percentage for the option price calculation.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param _minOptionPricePercentage Value of the new  minimum percentage for the option price calculation.\\r\\n     */\\r\\n\\tfunction setMinOptionPricePercentage(uint256 _minOptionPricePercentage) onlyOwner public {\\r\\n        _setMinOptionPricePercentage(_minOptionPricePercentage);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the tolerance percentage for the underlying price on the Oracle.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param _tolerancePercentageToOraclePrice Value of the tolerance percentage for the underlying price on the Oracle.\\r\\n     */\\r\\n    function setTolerancePercentageToOraclePrice(uint256 _tolerancePercentageToOraclePrice) onlyOwner public {\\r\\n        _setTolerancePercentageToOraclePrice(_tolerancePercentageToOraclePrice);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the the order size factors.\\r\\n     * orderSizePenaltyFactor * order size percentage ^ orderSizeDampingFactor\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param _orderSizePenaltyFactor Value of the new order size penalty factor.\\r\\n     * @param _orderSizeDampingFactor Value of the new order size damping factor.\\r\\n     */\\r\\n    function setOrderSizeFactors(uint256 _orderSizePenaltyFactor, uint256 _orderSizeDampingFactor) onlyOwner public {\\r\\n        _setOrderSizeFactors(_orderSizePenaltyFactor, _orderSizeDampingFactor);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the the Oracle aggregator data.\\r\\n\\t * Only can be called by the admin.\\r\\n     * @param underlying Address of the underlying.\\r\\n     * @param strikeAsset Address of the strike asset.\\r\\n\\t * @param aggregator Address of the Oracle aggregator.\\r\\n     */\\r\\n    function setAgreggator(address underlying, address strikeAsset, address aggregator) onlyOwner public {\\r\\n        require(underlying != strikeAsset, \\\"ACOStrategy1:: Invalid assets\\\");\\r\\n        require(underlying == address(0) || underlying.isContract(), \\\"ACOStrategy1:: Invalid underlying\\\");\\r\\n        require(strikeAsset == address(0) || strikeAsset.isContract(), \\\"ACOStrategy1:: Invalid strike asset\\\");\\r\\n        require(aggregator.isContract(), \\\"ACOStrategy1:: Invalid aggregator\\\");\\r\\n        \\r\\n        _setAssetPrecision(underlying);\\r\\n        _setAssetPrecision(strikeAsset);\\r\\n        \\r\\n        uint256 aggregatorDecimals = uint256(AggregatorV3Interface(aggregator).decimals());\\r\\n        emit SetAggregator(underlying, strikeAsset, aggregators[underlying][strikeAsset].aggregator, aggregator);\\r\\n        aggregators[underlying][strikeAsset] = AggregatorData(aggregator, (10 ** aggregatorDecimals));\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get the underlying price on the Oracle aggregator.\\r\\n     * @param underlying Address of the underlying.\\r\\n     * @param strikeAsset Address of the strike asset.\\r\\n\\t * @return The underlying price with the strike asset precision.\\r\\n     */\\r\\n    function getUnderlyingPrice(address underlying, address strikeAsset) external override view returns(uint256) {\\r\\n        return _getAggregatorPrice(underlying, strikeAsset);   \\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get an acceptable underlying price to swap the related assets.\\r\\n\\t * Reading the underlying price on the Oracle aggregator, the value read is adjusted to a maximum acceptable price slippage.\\r\\n     * @param underlying Address of the underlying.\\r\\n     * @param strikeAsset Address of the strike asset.\\r\\n     * @param isBuying True if is buying, otherwise is selling.\\r\\n\\t * @return The acceptable underlying price to swap the related assets.\\r\\n     */\\r\\n    function getAcceptableUnderlyingPriceToSwapAssets(address underlying, address strikeAsset, bool isBuying) external override view returns(uint256) {\\r\\n        uint256 underlyingPrice = _getAggregatorPrice(underlying, strikeAsset);\\r\\n        if (isBuying) {\\r\\n            return underlyingPrice.mul(PERCENTAGE_PRECISION.sub(tolerancePercentageToOraclePrice)).div(PERCENTAGE_PRECISION);\\r\\n        } else {\\r\\n            return underlyingPrice.mul(PERCENTAGE_PRECISION.add(tolerancePercentageToOraclePrice)).div(PERCENTAGE_PRECISION);    \\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to check the exercise data.\\r\\n\\t * This strategy only sells, so the exercise is not available.\\r\\n\\t * @return Whether the exercise is possible and the minimum intrinsic value to be exercise.\\r\\n     */\\r\\n    function checkExercise(CheckExercise calldata) external override view returns(bool, uint256) {\\r\\n        require(false, \\\"ACOStrategy1:: Strategy only for sell\\\");\\r\\n        return (false, 0);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to quote an option price.\\r\\n     * @param quoteData The quote data.\\r\\n\\t * @return The option price per token in strike asset.\\r\\n     */\\r\\n    function quote(OptionQuote calldata quoteData) external override view returns(uint256, uint256, uint256) {\\r\\n\\t\\trequire(quoteData.isSellingQuote, \\\"ACOStrategy1:: Strategy only for sell\\\");\\r\\n        require(quoteData.expiryTime \\u003e block.timestamp, \\\"ACOStrategy1:: Expired\\\");\\r\\n        uint256 underlyingPrice = _getAggregatorPrice(quoteData.underlying, quoteData.strikeAsset);\\r\\n        uint256 volatility = _getVolatility(quoteData);\\r\\n        uint256 price = _getOptionPrice(underlyingPrice, volatility, quoteData);\\r\\n        require(price \\u003e 0, \\\"ACOPool:: Invalid price\\\");\\r\\n        return (price, underlyingPrice, volatility);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get a volatility adjusted by the order size.\\r\\n     * @param quoteData The quote data.\\r\\n\\t * @return The volatility to be used on option price calculation.\\r\\n     */\\r\\n    function _getVolatility(OptionQuote memory quoteData) internal view returns(uint256) {\\r\\n        uint256 orderSizeAdjust = _getOrderSizeAdjust(quoteData);\\r\\n        return quoteData.baseVolatility.mul(orderSizeAdjust.add(PERCENTAGE_PRECISION)).div(PERCENTAGE_PRECISION);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get the option price through the Black-Scholes method.\\r\\n\\t * @param underlyingPrice The current underlying price.\\r\\n\\t * @param volatility The volatility percentage to be used on the calculation.\\r\\n     * @param quoteData The quote data.\\r\\n\\t * @return The option price per token in strike asset.\\r\\n     */\\r\\n    function _getOptionPrice(\\r\\n        uint256 underlyingPrice,\\r\\n        uint256 volatility,\\r\\n        OptionQuote memory quoteData\\r\\n    ) internal view returns(uint256) {\\r\\n        uint256 underlyingPriceForQuote = _getUnderlyingPriceForQuote(underlyingPrice, quoteData);\\r\\n        uint256 price = BlackScholes.getOptionPrice(\\r\\n            quoteData.isCallOption,\\r\\n            quoteData.strikePrice, \\r\\n            underlyingPriceForQuote,\\r\\n            assetPrecision[quoteData.strikeAsset],\\r\\n            quoteData.expiryTime - block.timestamp, \\r\\n            volatility,\\r\\n            0, \\r\\n            0,\\r\\n            PERCENTAGE_PRECISION\\r\\n        );\\r\\n        return _getValidPriceForQuote(price, underlyingPrice, quoteData);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get the order size adjustment percentage on the volatility.\\r\\n     * orderSizePenaltyFactor * order size percentage ^ orderSizeDampingFactor\\r\\n     * @param quoteData The quote data.\\r\\n\\t * @return The order size adjustment percentage on the volatility.\\r\\n     */\\r\\n    function _getOrderSizeAdjust(OptionQuote memory quoteData) internal view returns(uint256) {\\r\\n        uint256 orderSizePercentage = quoteData.collateralOrderAmount.mul(PERCENTAGE_PRECISION).div(quoteData.collateralAvailable);\\r\\n\\t\\trequire(orderSizePercentage \\u003c= PERCENTAGE_PRECISION, \\\"ACOStrategy1:: No liquidity\\\");\\r\\n        return (orderSizePercentage ** orderSizeDampingFactor).mul(orderSizePenaltyFactor).div(orderSizeDivFactor);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get a underlying price for a quote.\\r\\n     * @param underlyingPrice The current underlying price.\\r\\n     * @param quoteData The quote data.\\r\\n\\t * @return The underlying price for a quote.\\r\\n     */\\r\\n    function _getUnderlyingPriceForQuote(uint256 underlyingPrice, OptionQuote memory quoteData) internal view returns(uint256) {\\r\\n\\t\\tif (quoteData.isCallOption) {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get a valid option price on a quote.\\r\\n\\t * The minimum option price restriction is applied.\\r\\n     * @param price Calculated option price.\\r\\n     * @param underlyingPrice The current underlying price.\\r\\n     * @param quoteData The quote data.\\r\\n\\t * @return The valid option price considering the minimum price allowed.\\r\\n     */\\r\\n    function _getValidPriceForQuote(uint256 price, uint256 underlyingPrice, OptionQuote memory quoteData) internal view returns(uint256) {\\r\\n\\t\\tuint256 basePrice = quoteData.isCallOption ? underlyingPrice : quoteData.strikePrice;\\r\\n\\t\\tuint256 minPrice = basePrice.mul(minOptionPricePercentage).div(PERCENTAGE_PRECISION);\\r\\n\\t\\tif (minPrice \\u003e price) {\\r\\n\\t\\t\\treturn minPrice;\\r\\n\\t\\t}\\r\\n\\t\\treturn price;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to get the underlying price on the Oracle aggregator.\\r\\n     * @param underlying Address of the underlying.\\r\\n     * @param strikeAsset Address of the strike asset.\\r\\n\\t * @return The underlying price with the strike asset precision.\\r\\n     */\\r\\n    function _getAggregatorPrice(address underlying, address strikeAsset) internal view returns(uint256) {\\r\\n        AggregatorData storage data = aggregators[underlying][strikeAsset];\\r\\n        address _aggregator = data.aggregator;\\r\\n        require(_aggregator != address(0), \\\"ACOStrategy1:: No aggregator\\\");\\r\\n        \\r\\n        (,int256 answer,,,) = AggregatorV3Interface(_aggregator).latestRoundData();\\r\\n        \\r\\n        uint256 _aggregatorPrecision = data.precision;\\r\\n        uint256 _assetPrecision = assetPrecision[strikeAsset];\\r\\n        \\r\\n        if (_aggregatorPrecision \\u003e _assetPrecision) {\\r\\n            return uint256(answer).div(_aggregatorPrecision.div(_assetPrecision));\\r\\n        } else {\\r\\n            return uint256(answer).mul(_assetPrecision).div(_aggregatorPrecision);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the asset precision. (6 decimals = 1000000)\\r\\n     * @param asset Address of the asset.\\r\\n     */\\r\\n    function _setAssetPrecision(address asset) internal {\\r\\n        if (assetPrecision[asset] == 0) {\\r\\n            uint256 decimals = _getAssetDecimals(asset);\\r\\n            assetPrecision[asset] = (10 ** decimals);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the percentage adjust on the underlying price to calculate the option price.\\r\\n     * @param _underlyingPriceAdjustPercentage Value of the new percentage adjust on the underlying price to calculate the option price.\\r\\n     */\\r\\n    function _setUnderlyingPriceAdjustPercentage(uint256 _underlyingPriceAdjustPercentage) internal {\\r\\n        require(_underlyingPriceAdjustPercentage \\u003c= PERCENTAGE_PRECISION, \\\"ACOStrategy1:: Invalid underlying price adjust\\\");\\r\\n        emit SetUnderlyingPriceAdjustPercentage(underlyingPriceAdjustPercentage, _underlyingPriceAdjustPercentage);\\r\\n        underlyingPriceAdjustPercentage = _underlyingPriceAdjustPercentage;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the minimum percentage for the option price calculation.\\r\\n     * @param _minOptionPricePercentage Value of the new  minimum percentage for the option price calculation.\\r\\n     */\\r\\n\\tfunction _setMinOptionPricePercentage(uint256 _minOptionPricePercentage) internal {\\r\\n\\t\\trequire(_minOptionPricePercentage \\u003e 0 \\u0026\\u0026 _minOptionPricePercentage \\u003c PERCENTAGE_PRECISION, \\\"ACOStrategy1:: Invalid min option price percentage\\\");\\r\\n        emit SetMinOptionPricePercentage(minOptionPricePercentage, _minOptionPricePercentage);\\r\\n        minOptionPricePercentage = _minOptionPricePercentage;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to set the tolerance percentage for the underlying price on the Oracle.\\r\\n     * @param _tolerancePercentageToOraclePrice Value of the tolerance percentage for the underlying price on the Oracle.\\r\\n     */\\r\\n\\tfunction _setTolerancePercentageToOraclePrice(uint256 _tolerancePercentageToOraclePrice) internal {\\r\\n\\t\\trequire(_tolerancePercentageToOraclePrice \\u003c= PERCENTAGE_PRECISION, \\\"ACOStrategy1:: Invalid tolerance percentage\\\");\\r\\n        emit SetTolerancePercentageToOraclePrice(tolerancePercentageToOraclePrice, _tolerancePercentageToOraclePrice);\\r\\n        tolerancePercentageToOraclePrice = _tolerancePercentageToOraclePrice;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to set the the order size factors.\\r\\n     * @param _orderSizePenaltyFactor Value of the new order size penalty factor.\\r\\n     * @param _orderSizeDampingFactor Value of the new order size damping factor.\\r\\n     */\\r\\n    function _setOrderSizeFactors(uint256 _orderSizePenaltyFactor, uint256 _orderSizeDampingFactor) internal {\\r\\n        require(_orderSizePenaltyFactor \\u003c= 1000000, \\\"ACOStrategy1:: Invalid penalty factor\\\");\\r\\n        require(_orderSizeDampingFactor \\u003e 0 \\u0026\\u0026 _orderSizeDampingFactor \\u003c= 10, \\\"ACOStrategy1:: Invalid damping factor\\\");\\r\\n        emit SetOrderSizeFactors(orderSizePenaltyFactor, orderSizeDampingFactor, _orderSizePenaltyFactor, _orderSizeDampingFactor);\\r\\n        orderSizePenaltyFactor = _orderSizePenaltyFactor;\\r\\n        orderSizeDampingFactor = _orderSizeDampingFactor;\\r\\n        orderSizeDivFactor = (PERCENTAGE_PRECISION ** (_orderSizeDampingFactor - 1));\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint256) {\\r\\n        if (asset == address(0)) {\\r\\n            return uint256(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"ACOStrategy1::_getAssetDecimals\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"AggregatorV3Interface.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n  function description() external view returns (string memory);\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n}\\r\\n\"},\"BlackScholes.sol\":{\"content\":\"pragma solidity ^0.5.0 || ^0.6.0;\\r\\n\\r\\nimport \\u0027./ABDKMath64x64.sol\\u0027;\\r\\n\\r\\nlibrary BlackScholes {\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to get the option price using the Black-Sholes method.\\r\\n\\t * @param isCallOption True if the option type is CALL, false for PUT.\\r\\n\\t * @param strikePrice The strike price value with `pricePrecision`.\\r\\n\\t * @param currentPrice The current underlying price value with `pricePrecision`.\\r\\n\\t * @param pricePrecision The price precision, for example for an asset with 6 decimals it will be 1000000.\\r\\n\\t * @param secondsToExpire Seconds to the option expiry.\\r\\n\\t * @param annualVolatilityPercentage The annual volatility with `percentageDataPrecision`.\\r\\n\\t * @param annualInterestRate The annual interest rate with `percentageDataPrecision`.\\r\\n\\t * @param annualDividendYield The annual dividen yield with `percentageDataPrecision`.\\r\\n\\t * @param percentageDataPrecision The percentage precision, for example it must be 100000 wheter 100000=100%, 25000=25%, 250750=250.75% etc.\\r\\n     * @return The calculated option price with `pricePrecision`.\\r\\n     */\\r\\n    function getOptionPrice(\\r\\n        bool isCallOption,\\r\\n        uint256 strikePrice, \\r\\n        uint256 currentPrice,\\r\\n        uint256 pricePrecision,\\r\\n        uint256 secondsToExpire, \\r\\n        uint256 annualVolatilityPercentage,\\r\\n        uint256 annualInterestRate, \\r\\n        uint256 annualDividendYield,\\r\\n        uint256 percentageDataPrecision\\r\\n    ) internal pure returns (uint256) {\\r\\n        return ABDKMath64x64.mulu(\\r\\n            _blackScholesCalculation(\\r\\n                isCallOption, \\r\\n                ABDKMath64x64.divu(strikePrice, pricePrecision), \\r\\n                ABDKMath64x64.divu(currentPrice, pricePrecision), \\r\\n                ABDKMath64x64.divu(annualVolatilityPercentage, percentageDataPrecision), \\r\\n                ABDKMath64x64.divu(annualInterestRate, percentageDataPrecision), \\r\\n                ABDKMath64x64.divu(annualDividendYield, percentageDataPrecision), \\r\\n                ABDKMath64x64.divu(secondsToExpire, 0x1e13380)\\r\\n            ),\\r\\n            pricePrecision\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Private function to handle with the Black-Sholes calculation.\\r\\n\\t * @param isCallOption True if the option type is CALL, false for PUT.\\r\\n\\t * @param strikePrice The strike price normalized with `ABDKMath64x64` library.\\r\\n\\t * @param currentPrice The current underlying price normalized with `ABDKMath64x64` library.\\r\\n\\t * @param volatility The annual volatility normalized with `ABDKMath64x64` library.\\r\\n\\t * @param interestRate The annual interest rate normalized with `ABDKMath64x64` library.\\r\\n\\t * @param dividendYield The annual dividen yield normalized with `ABDKMath64x64` library.\\r\\n\\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\\r\\n     * @return The calculated option price normalized with `ABDKMath64x64` library.\\r\\n     */\\r\\n    function _blackScholesCalculation(\\r\\n        bool isCallOption,\\r\\n        int128 strikePrice, \\r\\n        int128 currentPrice,\\r\\n        int128 volatility,\\r\\n        int128 interestRate, \\r\\n        int128 dividendYield,\\r\\n        int128 expiration\\r\\n    ) private pure returns (int128) {\\r\\n        int128 dCalculationAux = ABDKMath64x64.mul(volatility, ABDKMath64x64.sqrt(expiration));\\r\\n        int128 d1 = _d1Calculation(strikePrice, currentPrice, expiration, volatility, interestRate, dividendYield, dCalculationAux);\\r\\n        int128 d2 = ABDKMath64x64.sub(d1, dCalculationAux);\\r\\n        return _priceCalculation(\\r\\n            isCallOption, \\r\\n            strikePrice, \\r\\n            currentPrice, \\r\\n            interestRate, \\r\\n            dividendYield, \\r\\n            expiration, \\r\\n            d1, \\r\\n            d2\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Private function to calculate the option price with the Black-Sholes method.\\r\\n\\t * @param isCallOption True if the option type is CALL, false for PUT.\\r\\n\\t * @param strikePrice The strike price normalized with `ABDKMath64x64` library.\\r\\n\\t * @param currentPrice The current underlying price normalized with `ABDKMath64x64` library.\\r\\n\\t * @param interestRate The annual interest rate normalized with `ABDKMath64x64` library.\\r\\n\\t * @param dividendYield The annual dividen yield normalized with `ABDKMath64x64` library.\\r\\n\\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\\r\\n\\t * @param d1 The D1 argument on Black-Sholes method normalized with `ABDKMath64x64` library.\\r\\n\\t * @param d2 The D2 argument on Black-Sholes method normalized with `ABDKMath64x64` library.\\r\\n     * @return The calculated option price normalized with `ABDKMath64x64` library.\\r\\n     */\\r\\n    function _priceCalculation(\\r\\n        bool isCallOption,\\r\\n        int128 strikePrice, \\r\\n        int128 currentPrice,\\r\\n        int128 interestRate, \\r\\n        int128 dividendYield,\\r\\n        int128 expiration,\\r\\n        int128 d1,\\r\\n        int128 d2\\r\\n    ) private pure returns (int128) {\\r\\n        int128 dividendYieldFactor = _getRateFactor(dividendYield, expiration);\\r\\n        int128 interestRateFactor = _getRateFactor(interestRate, expiration);\\r\\n        if (isCallOption) {\\r\\n            return ABDKMath64x64.sub(\\r\\n                ABDKMath64x64.mul(\\r\\n                    dividendYieldFactor,\\r\\n                    ABDKMath64x64.mul(\\r\\n                        currentPrice,\\r\\n                        _normalCummulativeDistribution(d1)\\r\\n                    )\\r\\n                ),\\r\\n                ABDKMath64x64.mul(\\r\\n                    interestRateFactor,\\r\\n                    ABDKMath64x64.mul(\\r\\n                        strikePrice,\\r\\n                        _normalCummulativeDistribution(d2)\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        } else {\\r\\n            return ABDKMath64x64.sub(\\r\\n                ABDKMath64x64.mul(\\r\\n                    interestRateFactor,\\r\\n                    ABDKMath64x64.mul(\\r\\n                        strikePrice,\\r\\n                        _normalCummulativeDistribution(ABDKMath64x64.neg(d2))\\r\\n                    )\\r\\n                ),\\r\\n                ABDKMath64x64.mul(\\r\\n                    dividendYieldFactor,\\r\\n                    ABDKMath64x64.mul(\\r\\n                        currentPrice,\\r\\n                        _normalCummulativeDistribution(ABDKMath64x64.neg(d1))\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Private function to calculate the normal cummulative distribution.\\r\\n\\t * @param x The value normalized with `ABDKMath64x64` library to be calculated.\\r\\n     * @return The normal cummulative distribution normalized with `ABDKMath64x64` library.\\r\\n     */\\r\\n    function _normalCummulativeDistribution(int128 x) private pure returns (int128) {\\r\\n        int128 z = ABDKMath64x64.div(x, 0x16a09e667f3bcc908);\\r\\n        int128 t = ABDKMath64x64.div(0x10000000000000000, ABDKMath64x64.add(0x10000000000000000, ABDKMath64x64.mul(0x53dd02a4f5ee2e46, ABDKMath64x64.abs(z))));\\r\\n        int128 erf = _getErf(z, t);\\r\\n        int128 nerf = erf;\\r\\n        if (z \\u003c 0) {\\r\\n            nerf = ABDKMath64x64.neg(erf);\\r\\n        }\\r\\n        return ABDKMath64x64.mul(0x8000000000000000, ABDKMath64x64.add(0x10000000000000000, nerf));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Private function to calculate the ERF.\\r\\n\\t * @param z The `z` argument normalized with `ABDKMath64x64` library.\\r\\n\\t * @param t The `t` argument normalized with `ABDKMath64x64` library.\\r\\n     * @return The ERF normalized with `ABDKMath64x64` library.\\r\\n     */\\r\\n    function _getErf(int128 z, int128 t) private pure returns (int128) {\\r\\n        int128 f = ABDKMath64x64.mul(t, ABDKMath64x64.add(0x16be1c55bae156b65, ABDKMath64x64.mul(t, ABDKMath64x64.add(-0x17401c57014c38f14, ABDKMath64x64.mul(t, 0x10fb844255a12d72e)))));\\r\\n        int128 f2 = ABDKMath64x64.add(0x413c831bb169f874, ABDKMath64x64.mul(t, ABDKMath64x64.add(-0x48d4c730f051a5fe, f)));\\r\\n        return ABDKMath64x64.sub(0x10000000000000000, ABDKMath64x64.mul(t, ABDKMath64x64.mul(f2, ABDKMath64x64.exp(ABDKMath64x64.mul(ABDKMath64x64.neg(z), z)))));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Private function to calculate the rate factor: e ^ (-rate * expiration).\\r\\n\\t * @param rate The rate normalized with `ABDKMath64x64` library.\\r\\n\\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\\r\\n     * @return The rate factor normalized with `ABDKMath64x64` library.\\r\\n     */\\r\\n    function _getRateFactor(int128 rate, int128 expiration) private pure returns (int128) {\\r\\n        int128 rateFactor = 0x10000000000000000;\\r\\n        if (rate \\u003e 0) {\\r\\n            rateFactor = ABDKMath64x64.exp(ABDKMath64x64.mul(ABDKMath64x64.neg(rate), expiration));\\r\\n        }\\r\\n        return rateFactor;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Private function to calculate the D1 data for the Black-Sholes method.\\r\\n\\t * @param strikePrice The strike price normalized with `ABDKMath64x64` library.\\r\\n\\t * @param currentPrice The current underlying price normalized with `ABDKMath64x64` library.\\r\\n\\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\\r\\n\\t * @param volatility The annual volatility normalized with `ABDKMath64x64` library.\\r\\n\\t * @param interestRate The annual interest rate normalized with `ABDKMath64x64` library.\\r\\n\\t * @param dividendYield The annual dividen yield normalized with `ABDKMath64x64` library.\\r\\n\\t * @param dCalculationAux The annual dividen yield normalized with `ABDKMath64x64` library.\\r\\n     * @return The D1 normalized with `ABDKMath64x64` library.\\r\\n     */\\r\\n    function _d1Calculation(\\r\\n        int128 strikePrice, \\r\\n        int128 currentPrice,\\r\\n        int128 expiration, \\r\\n        int128 volatility,\\r\\n        int128 interestRate, \\r\\n        int128 dividendYield,\\r\\n        int128 dCalculationAux\\r\\n    ) private pure returns (int128) {\\r\\n        return ABDKMath64x64.div(\\r\\n            ABDKMath64x64.add(\\r\\n                ABDKMath64x64.ln(ABDKMath64x64.div(currentPrice, strikePrice)), \\r\\n                ABDKMath64x64.mul(\\r\\n                    expiration, \\r\\n                    ABDKMath64x64.add(\\r\\n                        ABDKMath64x64.sub(interestRate, dividendYield), \\r\\n                        ABDKMath64x64.div(ABDKMath64x64.mul(volatility, volatility), 0x20000000000000000)\\r\\n                    )\\r\\n                )\\r\\n            ), \\r\\n            dCalculationAux\\r\\n        );\\r\\n    }\\r\\n}\"},\"IACOStrategy.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IACOStrategy {\\r\\n    \\r\\n    struct OptionQuote {\\r\\n        bool isSellingQuote;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCallOption;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 baseVolatility;\\r\\n        uint256 collateralOrderAmount;\\r\\n        uint256 collateralAvailable;\\r\\n        uint256 collateralTotalDeposited;\\r\\n        uint256 strikeAssetEarnedSelling;\\r\\n        uint256 strikeAssetSpentBuying;\\r\\n        uint256 amountPurchased;\\r\\n        uint256 amountSold;\\r\\n    }\\r\\n    \\r\\n    struct CheckExercise {\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCallOption;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 collateralAmount;\\r\\n        uint256 collateralAvailable;\\r\\n        uint256 amountPurchased;\\r\\n        uint256 amountSold;\\r\\n    }\\r\\n    \\r\\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 underlyingPrice, uint256 volatility);\\r\\n    function getUnderlyingPrice(address underlying, address strikeAsset) external view returns(uint256 underlyingPrice);\\r\\n    function getAcceptableUnderlyingPriceToSwapAssets(address underlying, address strikeAsset, bool isBuying) external view returns(uint256 acceptablePrice);\\r\\n    function checkExercise(CheckExercise calldata exerciseData) external view returns(bool canExercise, uint256 minIntrinsicValue);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Adapted from OpenZeppelin\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    function init() internal {\\r\\n        require(_owner == address(0), \\\"Ownable: Contract initialized\\\");\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlyingPriceAdjustPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tolerancePercentageToOraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_orderSizePenaltyFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_orderSizeDampingFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAggregator\",\"type\":\"address\"}],\"name\":\"SetAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinOptionPricePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinOptionPricePercentage\",\"type\":\"uint256\"}],\"name\":\"SetMinOptionPricePercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldOrderSizePenaltyFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldOrderSizeDampingFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newOrderSizePenaltyFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newOrderSizeDampingFactor\",\"type\":\"uint256\"}],\"name\":\"SetOrderSizeFactors\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTolerancePercentageToOraclePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTolerancePercentageToOraclePrice\",\"type\":\"uint256\"}],\"name\":\"SetTolerancePercentageToOraclePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldUnderlyinPriceAdjustPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newUnderlyingPriceAdjustPercentage\",\"type\":\"uint256\"}],\"name\":\"SetUnderlyingPriceAdjustPercentage\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"aggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"precision\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetPrecision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCallOption\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPurchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSold\",\"type\":\"uint256\"}],\"internalType\":\"struct IACOStrategy.CheckExercise\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"checkExercise\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuying\",\"type\":\"bool\"}],\"name\":\"getAcceptableUnderlyingPriceToSwapAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOptionPricePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderSizeDampingFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderSizePenaltyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isSellingQuote\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCallOption\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseVolatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralOrderAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTotalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetEarnedSelling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetSpentBuying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPurchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSold\",\"type\":\"uint256\"}],\"internalType\":\"struct IACOStrategy.OptionQuote\",\"name\":\"quoteData\",\"type\":\"tuple\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"setAgreggator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"}],\"name\":\"setMinOptionPricePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderSizePenaltyFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_orderSizeDampingFactor\",\"type\":\"uint256\"}],\"name\":\"setOrderSizeFactors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tolerancePercentageToOraclePrice\",\"type\":\"uint256\"}],\"name\":\"setTolerancePercentageToOraclePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_underlyingPriceAdjustPercentage\",\"type\":\"uint256\"}],\"name\":\"setUnderlyingPriceAdjustPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tolerancePercentageToOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingPriceAdjustPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ACOStrategy1","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000002ee00000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000004","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://84944aa31cdf1cf1f649a9854715176384336b05c24b1defe9fe9dfd07afb708"}]}