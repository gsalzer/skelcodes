{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/Atomex.sol\n\npragma solidity ^0.5.0;\n\n// From file: openzeppelin-contracts/contracts/math/SafeMath.sol\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"SafeMath add wrong value\");\n        return c;\n    }\n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"SafeMath sub wrong value\");\n        return a - b;\n    }\n}\n\n// File: openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        _notEntered = true;\n    }\n\n    modifier nonReentrant() {\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n}\n\ncontract Atomex is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    enum State { Empty, Initiated, Redeemed, Refunded }\n\n    struct Swap {\n        bytes32 hashedSecret;\n        address payable initiator;\n        address payable participant;\n        uint256 refundTimestamp;\n        uint256 countdown;\n        uint256 value;\n        uint256 payoff;\n        bool active;\n        State state;\n    }\n\n    event Initiated(\n        bytes32 indexed _hashedSecret,\n        address indexed _participant,\n        address _initiator,\n        uint256 _refundTimestamp,\n        uint256 _countdown,\n        uint256 _value,\n        uint256 _payoff,\n        bool _active\n    );\n\n    event Added(\n        bytes32 indexed _hashedSecret,\n        address _sender,\n        uint _value\n    );\n\n    event Activated(\n        bytes32 indexed _hashedSecret\n    );\n\n    event Redeemed(\n        bytes32 indexed _hashedSecret,\n        bytes32 _secret\n    );\n\n    event Refunded(\n        bytes32 indexed _hashedSecret\n    );\n\n    mapping(bytes32 => Swap) public swaps;\n\n    modifier onlyByInitiator(bytes32 _hashedSecret) {\n        require(msg.sender == swaps[_hashedSecret].initiator, \"sender is not the initiator\");\n        _;\n    }\n\n    modifier isInitiatable(bytes32 _hashedSecret, address _participant, uint256 _refundTimestamp, uint256 _countdown) {\n        require(_participant != address(0), \"invalid participant address\");\n        require(swaps[_hashedSecret].state == State.Empty, \"swap for this hash is already initiated\");\n        require(block.timestamp < _refundTimestamp, \"refundTimestamp has already come\");\n        require(_countdown < _refundTimestamp, \"countdown exceeds the refundTimestamp\");\n        _;\n    }\n\n    modifier isInitiated(bytes32 _hashedSecret) {\n        require(swaps[_hashedSecret].state == State.Initiated, \"swap for this hash is empty or already spent\");\n        _;\n    }\n\n    modifier isAddable(bytes32 _hashedSecret) {\n        require(block.timestamp < swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has already come\");\n        _;\n    }\n\n    modifier isActivated(bytes32 _hashedSecret) {\n        require(swaps[_hashedSecret].active, \"swap is not active\");\n        _;\n    }\n\n    modifier isNotActivated(bytes32 _hashedSecret) {\n        require(!swaps[_hashedSecret].active, \"swap is already activated\");\n        _;\n    }\n\n    modifier isRedeemable(bytes32 _hashedSecret, bytes32 _secret) {\n        require(block.timestamp < swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has already come\");\n        require(sha256(abi.encodePacked(sha256(abi.encodePacked(_secret)))) == _hashedSecret, \"secret is not correct\");\n        _;\n    }\n\n    modifier isRefundable(bytes32 _hashedSecret) {\n        require(block.timestamp >= swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has not come\");\n        _;\n    }\n\n\n    function initiate(\n        bytes32 _hashedSecret, address payable _participant, uint256 _refundTimestamp,\n        uint256 _countdown, uint256 _payoff, bool _active)\n        public payable nonReentrant isInitiatable(_hashedSecret, _participant, _refundTimestamp, _countdown)\n    {\n        swaps[_hashedSecret].value = msg.value.sub(_payoff);\n        swaps[_hashedSecret].hashedSecret = _hashedSecret;\n        swaps[_hashedSecret].participant = _participant;\n        swaps[_hashedSecret].initiator = msg.sender;\n        swaps[_hashedSecret].refundTimestamp = _refundTimestamp;\n        swaps[_hashedSecret].countdown = _countdown;\n        swaps[_hashedSecret].payoff = _payoff;\n        swaps[_hashedSecret].active = _active;\n        swaps[_hashedSecret].state = State.Initiated;\n\n        emit Initiated(\n            _hashedSecret,\n            _participant,\n            msg.sender,\n            _refundTimestamp,\n            _countdown,\n            msg.value.sub(_payoff),\n            _payoff,\n            _active\n        );\n    }\n\n    function add (bytes32 _hashedSecret)\n        public payable nonReentrant isInitiated(_hashedSecret) isAddable(_hashedSecret)\n    {\n        swaps[_hashedSecret].value = swaps[_hashedSecret].value.add(msg.value);\n\n        emit Added(\n            _hashedSecret,\n            msg.sender,\n            swaps[_hashedSecret].value\n        );\n    }\n\n    function activate (bytes32 _hashedSecret)\n        public isInitiated(_hashedSecret) isNotActivated(_hashedSecret) onlyByInitiator(_hashedSecret)\n    {\n        swaps[_hashedSecret].active = true;\n\n        emit Activated(\n            _hashedSecret\n        );\n    }\n\n    function redeem(bytes32 _hashedSecret, bytes32 _secret)\n        public nonReentrant isInitiated(_hashedSecret) isActivated(_hashedSecret) isRedeemable(_hashedSecret, _secret)\n    {\n        swaps[_hashedSecret].state = State.Redeemed;\n\n        emit Redeemed(\n            _hashedSecret,\n            _secret\n        );\n\n        if (block.timestamp > swaps[_hashedSecret].refundTimestamp.sub(swaps[_hashedSecret].countdown)) {\n            swaps[_hashedSecret].participant.transfer(swaps[_hashedSecret].value);\n            if (swaps[_hashedSecret].payoff > 0) {\n                msg.sender.transfer(swaps[_hashedSecret].payoff);\n            }\n        }\n        else {\n            swaps[_hashedSecret].participant.transfer(swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff));\n        }\n\n        delete swaps[_hashedSecret];\n    }\n\n    function refund(bytes32 _hashedSecret)\n        public isInitiated(_hashedSecret) isRefundable(_hashedSecret)\n    {\n        swaps[_hashedSecret].state = State.Refunded;\n\n        emit Refunded(\n            _hashedSecret\n        );\n\n        swaps[_hashedSecret].initiator.transfer(swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff));\n\n        delete swaps[_hashedSecret];\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"Activated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Added\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_participant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_refundTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_countdown\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_payoff\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"Initiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"add\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_participant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refundTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_countdown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payoff\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refundTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countdown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoff\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"enum Atomex.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Atomex","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}