{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/InterFaces/IAuctionRegistery.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract AuctionRegisteryContracts {\r\n    bytes32 internal constant MAIN_TOKEN = \"MAIN_TOKEN\";\r\n    bytes32 internal constant ETN_TOKEN = \"ETN_TOKEN\";\r\n    bytes32 internal constant STOCK_TOKEN = \"STOCK_TOKEN\";\r\n    bytes32 internal constant WHITE_LIST = \"WHITE_LIST\";\r\n    bytes32 internal constant AUCTION = \"AUCTION\";\r\n    bytes32 internal constant AUCTION_PROTECTION = \"AUCTION_PROTECTION\";\r\n    bytes32 internal constant LIQUIDITY = \"LIQUIDITY\";\r\n    bytes32 internal constant CURRENCY = \"CURRENCY\";\r\n    bytes32 internal constant VAULT = \"VAULT\";\r\n    bytes32 internal constant CONTRIBUTION_TRIGGER = \"CONTRIBUTION_TRIGGER\";\r\n    bytes32 internal constant COMPANY_FUND_WALLET = \"COMPANY_FUND_WALLET\";\r\n    bytes32 internal constant SMART_SWAP = \"SMART_SWAP\";\r\n    bytes32 internal constant SMART_SWAP_P2P = \"SMART_SWAP_P2P\";\r\n    bytes32 internal constant ESCROW = \"ESCROW\";\r\n}\r\n\r\ninterface IAuctionRegistery {\r\n    function getAddressOf(bytes32 _contractName)\r\n        external\r\n        view\r\n        returns (address payable);\r\n}\r\n\r\n// File: contracts/WhiteList/WhiteListStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ncontract WhiteListStorage {\r\n    \r\n    IAuctionRegistery public contractsRegistry;\r\n    \r\n    address payable public auctionAddress; \r\n    \r\n    \r\n    struct UserDetails {\r\n        uint256 flags; // bitmap, where each bit correspondent to some properties (additional flags can be added in future).\r\n        uint256 maxWallets;\r\n        address[] wallets;\r\n    }\r\n\r\n    // Whitelist rules\r\n    struct ReceivingRule {\r\n        uint256 mask; // bit-mask to select bits which will be checked by this rule\r\n        uint256 condition; // bit-sets which indicate the require bit status.\r\n        // for example, if rule require that the 1 and 4 bits should be '1' and 2 bit should be '0', then mask = 0x16 (10110 binary) and condition = 0x12 (10010 binary). I.e. '1' is set for bit which should be '1' and '0' - for bit which should be '0'\r\n    }\r\n\r\n    // Restriction rules\r\n    struct TransferringRule {\r\n        uint256 from_mask; // bit-mask to select bits which will be checked by this rule\r\n        uint256 from_condition; // bit-sets which indicate the require bit status.\r\n        uint256 to_mask; // bit-mask to select bits which will be checked by this rule\r\n        uint256 to_condition; // bit-sets which indicate the require bit status.\r\n        // if rule 'from' return 'true' and rule 'to' is true - the transfer disallowed.\r\n        // if rule 'from' return 'false' then don't check rule 'to'.\r\n    }\r\n\r\n    mapping(address => address) public address_belongs;\r\n    mapping(address => UserDetails) public user_details;\r\n\r\n    //Made this decision so that we can reuse the code\r\n\r\n    //0:main\r\n    //1:etn\r\n    //2:stock\r\n    mapping(uint8 => ReceivingRule) public tokenToReceivingRule;\r\n    mapping(uint8 => TransferringRule[]) public tokenToTransferringRuleArray;\r\n\r\n    //timestamp when hold back days are over\r\n    mapping(uint8 => uint256) public tokenToHoldBackDaysTimeStamp;\r\n    //timestamp when token matures\r\n    mapping(uint8 => uint256) public tokenToMaturityDaysTimeStamp;\r\n    \r\n    \r\n    uint256 public constant KYC = 1 << 0; //0x01\r\n    uint256 public constant AML = 1 << 1; //0x02\r\n    uint256 public constant ACCREDIATED_INVESTOR = 1 << 2;\r\n    uint256 public constant QUALIFIED_INVESTOR = 1 << 3;\r\n    uint256 public constant RETAIL_INVESTOR = 1 << 4;\r\n    uint256 public constant DECENTRALIZE_EXCHANGE = 1 << 5; // wallet of decentralize exchanges\r\n    uint256 public constant CENTRALIZE_EXCHANGE = 1 << 6; // wallet of centralize exchanges\r\n    uint256 public constant IS_ALLOWED_ETN = 1 << 7;\r\n    uint256 public constant IS_ALLOWED_STOCK = 1 << 8;\r\n    uint256 public constant FROM_USA = 1 << 9;\r\n    uint256 public constant FROM_CHINA = 1 << 10;\r\n    uint256 public constant FROM_EU = 1 << 11;\r\n    uint256 public constant IS_BYPASSED = 1 << 12;\r\n    uint256 public constant BANCOR_ADDRESS = 1 << 13;\r\n    uint256 public constant IS_ALLOWED_AUCTION = 1 << 14;\r\n    \r\n    event AccountWhiteListed(address indexed which, uint256 flags);\r\n    event WalletAdded(address indexed from, address indexed which);\r\n    event WalletRemoved(address indexed from, address indexed which);\r\n    event FlagsChanged(address indexed which, uint256 flags);\r\n\r\n    \r\n    \r\n}\r\n\r\n// File: contracts/common/Constant.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract Constant {\r\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\r\n\r\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\r\n\r\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\r\n\r\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\r\n\r\n    string constant ERR_SAME_ADDRESS = \"ERR_SAME_ADDRESS\";\r\n\r\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\r\n\r\n    modifier notOwnAddress(address _which) {\r\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // validates an address is not zero\r\n    modifier notZeroAddress(address _which) {\r\n        require(_which != address(0), ERR_ZERO_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThisAddress(address _which) {\r\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    modifier notZeroValue(uint256 _value) {\r\n        require(_value > 0, ERR_VALUE_IS_ZERO);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/common/ProxyOwnable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\ncontract ProxyOwnable is Constant {\r\n    \r\n    address public primaryOwner;\r\n\r\n    address public authorityAddress;\r\n\r\n    address public newAuthorityAddress;\r\n\r\n    address public systemAddress;\r\n    \r\n    bool public isOwnerInitialize = false;\r\n\r\n    event OwnershipTransferred(\r\n        string ownerType,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    \r\n    event AuthorityAddressChnageCall(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the `primaryOwner` and `systemAddress` and '_multisigAddress'\r\n     * account.\r\n     */\r\n\r\n    function initializeOwner(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress\r\n    ) internal notZeroAddress(_primaryOwner) notZeroAddress(_systemAddress) notZeroAddress(_authorityAddress) {\r\n        \r\n        require(!isOwnerInitialize,\"ERR_OWNER_INTIALIZED_ALREADY\");\r\n        \r\n        require(_primaryOwner != _systemAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_systemAddress != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_primaryOwner != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        primaryOwner = _primaryOwner;\r\n        systemAddress = _systemAddress;\r\n        authorityAddress = _authorityAddress;\r\n        isOwnerInitialize = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == primaryOwner, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender == systemAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOneOfOnwer() {\r\n        require(\r\n            msg.sender == primaryOwner || msg.sender == systemAddress,\r\n            ERR_AUTHORIZED_ADDRESS_ONLY\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == authorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev change primary ownership governance \r\n     */\r\n    function changePrimaryOwner()\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        emit OwnershipTransferred(\"PRIMARY_OWNER\", primaryOwner, authorityAddress);\r\n        primaryOwner = authorityAddress;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new system address\r\n     */\r\n    function changeSystemAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notThisAddress(_which)\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress &&\r\n                _which != primaryOwner,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        emit OwnershipTransferred(\"SYSTEM_ADDRESS\", systemAddress, _which);\r\n        systemAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new Authority address\r\n     */\r\n    function changeAuthorityAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        newAuthorityAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    function acceptAuthorityAddress() public returns (bool) {\r\n        require(msg.sender == newAuthorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        emit OwnershipTransferred(\r\n            \"AUTHORITY_ADDRESS\",\r\n            authorityAddress,\r\n            newAuthorityAddress\r\n        );\r\n        authorityAddress = newAuthorityAddress;\r\n        newAuthorityAddress = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/common/SafeMath.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 result;\r\n        assembly {\r\n            result := exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // calculates a^(1/n) to dp decimal places\r\n    // maxIts bounds the number of iterations performed\r\n    function nthRoot(\r\n        uint256 _a,\r\n        uint256 _n,\r\n        uint256 _dp,\r\n        uint256 _maxIts\r\n    ) internal pure returns (uint256) {\r\n        assert(_n > 1);\r\n\r\n        // The scale factor is a crude way to turn everything into integer calcs.\r\n        // Actually do (a * (10 ^ ((dp + 1) * n))) ^ (1/n)\r\n        // We calculate to one extra dp and round at the end\r\n        uint256 one = 10**(1 + _dp);\r\n        uint256 a0 = one**_n * _a;\r\n\r\n        // Initial guess: 1.0\r\n        uint256 xNew = one;\r\n        uint256 x;\r\n\r\n        uint256 iter = 0;\r\n        while (xNew != x && iter < _maxIts) {\r\n            x = xNew;\r\n            uint256 t0 = x**(_n - 1);\r\n            if (x * t0 > a0) {\r\n                xNew = x - (x - a0 / t0) / _n;\r\n            } else {\r\n                xNew = x + (a0 / t0 - x) / _n;\r\n            }\r\n            ++iter;\r\n        }\r\n\r\n        // Round to nearest in the last dp.\r\n        return (xNew + 5) / 10;\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/IRegistry.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title IRegistry\r\n * @dev This contract represents the interface of a registry contract\r\n */\r\ninterface IRegistry {\r\n    /**\r\n     * @dev This event will be emitted every time a new proxy is created\r\n     * @param proxy representing the address of the proxy created\r\n     */\r\n    event ProxyCreated(address proxy);\r\n\r\n    /**\r\n     * @dev This event will be emitted every time a new implementation is registered\r\n     * @param version representing the version name of the registered implementation\r\n     * @param implementation representing the address of the registered implementation\r\n     */\r\n    event VersionAdded(uint256 version, address implementation);\r\n\r\n    /**\r\n     * @dev Registers a new version with its implementation address\r\n     * @param version representing the version name of the new implementation to be registered\r\n     * @param implementation representing the address of the new implementation to be registered\r\n     */\r\n    function addVersion(uint256  version, address implementation)\r\n        external;\r\n\r\n    /**\r\n     * @dev Tells the address of the implementation for a given version\r\n     * @param version to query the implementation of\r\n     * @return address of the implementation registered for the given version\r\n     */\r\n    function getVersion(uint256 version)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/Proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n     * @dev Tells the address of the implementation where every call will be delegated.\r\n     * @return address of the implementation to which it will be delegated\r\n     */\r\n    function implementation() public view returns (address);\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    \r\n    function() external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0),\"ERR_IMPLEMENTEION_ZERO\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }  \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n}\r\n\r\n// File: contracts/Proxy/UpgradeabilityStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage is Proxy {\r\n    // Versions registry\r\n    IRegistry public registry;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/Upgradeable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title Upgradeable\r\n * @dev This contract holds all the minimum required functionality for a behavior to be upgradeable.\r\n * This means, required state variables for owned upgradeability purpose and simple initialization validation.\r\n */\r\ncontract Upgradeable is UpgradeabilityStorage {\r\n    /**\r\n     * @dev Validates the caller is the versions registry.\r\n     * THIS FUNCTION SHOULD BE OVERRIDDEN CALLING SUPER\r\n     */\r\n    function initialize() public view {\r\n        require(msg.sender == address(registry),\"ERR_ONLY_REGISTRERY_CAN_CALL\");\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IERC20Token.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: contracts/WhiteList/WhiteList.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface WhiteListInitializeInterface {\r\n    function initialize(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        uint256 _mainHoldBackDays,\r\n        uint256 _etnHoldBackDays,\r\n        uint256 _stockHoldBackDays,\r\n        uint256 _mainMaturityDays,\r\n        uint256 _etnMaturityDays,\r\n        uint256 _stockMaturityDays,\r\n        address _registryaddress\r\n    ) external;\r\n}\r\n\r\ncontract RegisteryWhiteList is ProxyOwnable,WhiteListStorage,AuctionRegisteryContracts {\r\n    \r\n\r\n    function updateRegistery(address _address)\r\n        external\r\n        onlyAuthorized()\r\n        notZeroAddress(_address)\r\n        returns (bool)\r\n    {\r\n        contractsRegistry = IAuctionRegistery(_address);\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n\r\n    function getAddressOf(bytes32 _contractName)\r\n        internal\r\n        view\r\n        returns (address payable)\r\n    {\r\n        return contractsRegistry.getAddressOf(_contractName);\r\n    }\r\n\r\n    /**@dev updates all the address from the registry contract\r\n    this decision was made to save gas that occurs from calling an external view function */\r\n\r\n    function _updateAddresses() internal {\r\n        auctionAddress = getAddressOf(AUCTION);\r\n    }\r\n\r\n     function updateAddresses() external returns (bool) {\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract WhiteList is\r\n    Upgradeable,\r\n    ProxyOwnable,\r\n    RegisteryWhiteList,\r\n    SafeMath,\r\n    WhiteListInitializeInterface\r\n{\r\n    \r\n    /**@dev converts _days into unix timestamp _days from now*/\r\n    function convertDaysToTimeStamp(uint256 _days)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //no need to check if days are set to zero see _isTransferAllowed L#327\r\n        if (_days == 0) return 0;\r\n        uint256 duration = safeMul(86400, _days);\r\n        return safeAdd(now, duration);\r\n    }\r\n\r\n    /**@dev since its a proxy contract this is what will work as a constructor*/\r\n    function initialize(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        uint256 _mainHoldBackDays,\r\n        uint256 _etnHoldBackDays,\r\n        uint256 _stockHoldBackDays,\r\n        uint256 _mainMaturityDays,\r\n        uint256 _etnMaturityDays,\r\n        uint256 _stockMaturityDays,\r\n        address _registryaddress\r\n    ) public {\r\n        super.initialize();\r\n\r\n        initializeOwner(_primaryOwner, _systemAddress, _authorityAddress);\r\n        contractsRegistry = IAuctionRegistery(_registryaddress);\r\n        \r\n        tokenToMaturityDaysTimeStamp[0] = convertDaysToTimeStamp(\r\n            _mainMaturityDays\r\n        );\r\n        tokenToMaturityDaysTimeStamp[1] = convertDaysToTimeStamp(\r\n            _etnMaturityDays\r\n        );\r\n        tokenToMaturityDaysTimeStamp[2] = convertDaysToTimeStamp(\r\n            _stockMaturityDays\r\n        );\r\n\r\n        tokenToHoldBackDaysTimeStamp[0] = convertDaysToTimeStamp(\r\n            _mainHoldBackDays\r\n        );\r\n        tokenToHoldBackDaysTimeStamp[1] = convertDaysToTimeStamp(\r\n            _etnHoldBackDays\r\n        );\r\n        tokenToHoldBackDaysTimeStamp[2] = convertDaysToTimeStamp(\r\n            _stockHoldBackDays\r\n        );\r\n        \r\n    }\r\n\r\n    /**@dev whitelists an address*/\r\n    function whiteListAccount(\r\n        address _which,\r\n        uint256 _flags,\r\n        uint256 _maxWallets\r\n    ) internal returns (bool) {\r\n        UserDetails storage details = user_details[_which];\r\n        details.flags = _flags;\r\n        details.maxWallets = _maxWallets;\r\n        address_belongs[_which] = _which;\r\n        emit AccountWhiteListed(_which, _flags);\r\n        return true;\r\n    }\r\n\r\n    /**@dev checks if address is bancor's*/\r\n    function _isBancorAddress(address _which) internal view returns (bool) {\r\n        address primaryAddress = address_belongs[_which];\r\n        uint256 flags = user_details[primaryAddress].flags;\r\n        return _checkRule(flags, BANCOR_ADDRESS, BANCOR_ADDRESS);\r\n    }\r\n\r\n    /**@dev checks if address is bypassed*/\r\n    function _isAddressByPassed(address _which) internal view returns (bool) {\r\n        address primaryAddress = address_belongs[_which];\r\n        uint256 flags = user_details[primaryAddress].flags;\r\n        return _checkRule(flags, IS_BYPASSED, IS_BYPASSED);\r\n    }\r\n\r\n    /**@dev checks if address is bypassed*/\r\n    function isAddressByPassed(address _which) external view returns (bool) {\r\n        return _isAddressByPassed(_which);\r\n    }\r\n\r\n    /**@dev returns if address is whitelisted*/\r\n    function _isWhiteListed(address _which) internal view returns (bool) {\r\n        if (address_belongs[_which] == address(0)) return false;\r\n        return true;\r\n    }\r\n\r\n    /**@dev returns if address is whitelisted*/\r\n    function isWhiteListed(address _which) external view returns (bool) {\r\n        return _isWhiteListed(_which);\r\n    }\r\n\r\n    /**@dev checks if address is allowed in auction or not */\r\n    function isAllowedInAuction(address _which) external view returns (bool) {\r\n        address primaryAddress = address_belongs[_which];\r\n        uint256 flags = user_details[primaryAddress].flags;\r\n        return _checkRule(flags, IS_ALLOWED_AUCTION, IS_ALLOWED_AUCTION);\r\n    }\r\n\r\n    \r\n\r\n    /**@dev checks if address is allowed in auction or not */\r\n    function checkRule(address _which, uint256 _condition)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        address primaryAddress = address_belongs[_which];\r\n        uint256 flags = user_details[primaryAddress].flags;\r\n        return _checkRule(flags, _condition, _condition);\r\n    }\r\n\r\n    /**@dev whitelists an address*/\r\n    function addNewWallet(\r\n        address _which,\r\n        uint256 _flags,\r\n        uint256 _maxWallets\r\n    ) public onlySystem() notZeroAddress(_which) returns (bool) {\r\n        require(!_isWhiteListed(_which), \"ERR_ACTION_NOT_ALLOWED\");\r\n        return whiteListAccount(_which, _flags, _maxWallets);\r\n    }\r\n    \r\n    \r\n    /**@dev whitelists an address*/\r\n    function isExchangeAddress(address _which) public view returns (bool) {\r\n        address primaryAddress = address_belongs[_which];\r\n        uint256 flags = user_details[primaryAddress].flags;\r\n        return _checkRule(flags,CENTRALIZE_EXCHANGE, CENTRALIZE_EXCHANGE);\r\n    }\r\n    \r\n\r\n    /**@dev updates the maximum wallets allowed for a primary whitelisted address*/\r\n    function updateMaxWallet(address _which, uint256 _maxWallets)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_isWhiteListed(_which), ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        UserDetails storage details = user_details[_which];\r\n        details.maxWallets = _maxWallets;\r\n        return true;\r\n    }\r\n\r\n    function _addMoreWallets(address _from,address _which) internal returns(bool){\r\n        \r\n        require(\r\n            address_belongs[_which] == address(0),\r\n            ERR_AUTHORIZED_ADDRESS_ONLY\r\n        );\r\n        address sender = _from;\r\n        address primaryAddress = address_belongs[sender];\r\n        require(\r\n            _isWhiteListed(primaryAddress) && sender == primaryAddress,\r\n            ERR_AUTHORIZED_ADDRESS_ONLY\r\n        );\r\n\r\n        UserDetails storage details = user_details[primaryAddress];\r\n        require(\r\n            details.maxWallets > details.wallets.length,\r\n            \"ERR_MAXIMUM_WALLET_LIMIT\"\r\n        );\r\n\r\n        address_belongs[_which] = primaryAddress;\r\n        details.wallets.push(_which);\r\n        emit WalletAdded(primaryAddress, _which);\r\n        return true;\r\n        \r\n    }\r\n\r\n    /**@dev allows primary whitelisted address to add wallet address controlled by them(reverts if maximum wallets is reached)*/\r\n    \r\n    function addMoreWallets(address _which)\r\n        public\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        return _addMoreWallets(msg.sender,_which);\r\n    }\r\n    \r\n    \r\n    \r\n    function addWalletBehalfExchange(address _mainWallet,address _subWallet)\r\n        public\r\n        notZeroAddress(_subWallet)\r\n        returns (bool)\r\n    {   \r\n        require(auctionAddress == msg.sender,\"ERR_ONLY_AUCTION_ADDRESS_ALLOWED\");\r\n        return _addMoreWallets(_mainWallet,_subWallet);\r\n    }\r\n\r\n\r\n    /**@dev allows system to chage flags associated with an address*/\r\n    function changeFlags(address _which, uint256 _flags)\r\n        public\r\n        onlySystem()\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(_isWhiteListed(_which), \"ERR_ACTION_NOT_ALLOWED\");\r\n        address primaryAddress = address_belongs[_which];\r\n        user_details[primaryAddress].flags = _flags;\r\n        emit FlagsChanged(_which, _flags);\r\n        return true;\r\n    }\r\n\r\n    /**@dev checks condition\r\n    @param _flags on which conditions are being checked on\r\n    @param _mask the bits we care about in a conditions\r\n    @param _condition the pattern of bits which should be exactly same in _flags to be true*/\r\n    function _checkRule(\r\n        uint256 _flags,\r\n        uint256 _mask,\r\n        uint256 _condition\r\n    ) internal pure returns (bool) {\r\n        uint256 flags = _flags & _mask;\r\n        flags = flags ^ _condition;\r\n        if (flags == 0) return true;\r\n        return false;\r\n    }\r\n\r\n    /**@dev adds ReceivingRule of the token*/\r\n    function _addReceivingRule(\r\n        uint256 _mask,\r\n        uint256 _condition,\r\n        uint8 _token\r\n    ) internal {\r\n        tokenToReceivingRule[_token] = ReceivingRule(_mask, _condition);\r\n    }\r\n\r\n    /**@dev adds transferring rule\r\n    if from has from_conditions bits set(i.e. is from usa) and to has to_condition bits set(i.e. is from china) then we don't allow*/\r\n    function _addTransferringRule(\r\n        uint256 from_mask,\r\n        uint256 from_condition,\r\n        uint256 to_mask,\r\n        uint256 to_condition,\r\n        uint8 token\r\n    ) internal {\r\n        tokenToTransferringRuleArray[token].push(\r\n            TransferringRule(from_mask, from_condition, to_mask, to_condition)\r\n        );\r\n    }\r\n\r\n    function _removeTransferingRule(uint256 _index, uint8 _token) internal {\r\n\r\n            TransferringRule[] storage transferringRules\r\n         = tokenToTransferringRuleArray[_token];\r\n\r\n        require(_index < transferringRules.length, \"CHECK_ARRAY_INDEX\");\r\n\r\n        transferringRules[_index] = transferringRules[safeSub(\r\n            transferringRules.length,\r\n            1\r\n        )]; //replace with last element\r\n        delete (transferringRules[safeSub(transferringRules.length, 1)]); //delete the last element\r\n        transferringRules.length = safeSub(transferringRules.length, 1);\r\n    }\r\n\r\n    /**@dev Check, if receiver is whitelisted (has all necessary flags). Require to pass all rules in the set*/\r\n    function _isReceiveAllowed(address user, uint8 token)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        address investor = address_belongs[user];\r\n        require(investor != address(0), \"ERR_TRANSFER_CHECK_WHITELIST\");\r\n        uint256 flags = user_details[investor].flags;\r\n        bool result;\r\n        result = _checkRule(\r\n            flags,\r\n            tokenToReceivingRule[token].mask,\r\n            tokenToReceivingRule[token].condition\r\n        );\r\n        if (!result) return false; // if rule don't passed - receiving token disallowed.\r\n        return true;\r\n    }\r\n\r\n    /**@dev checks if transfer is allowed with according transferringRules of a token*/\r\n    function _isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to,\r\n        uint8 token\r\n    ) internal view returns (bool) {\r\n        address to = address_belongs[_to];\r\n        address msgSender = address_belongs[_msgSender];\r\n        bool result;\r\n\r\n        //If transfer is happening to a bypassed address then check nothing\r\n        if (_isAddressByPassed(to)) {\r\n            return true;\r\n        }\r\n        //If a byPassed Address calls a transfer or transferFrom function then just check if _to is whitelisted and return\r\n        if (_isAddressByPassed(msgSender)) {\r\n            result = _isWhiteListed(to);\r\n            return result;\r\n        }\r\n        //Added to make sure that bancor addresses transfer to bypassed addresses only\r\n        //if a bancor address calls a transfer or transferFrom function then return true only if to is Bypassed a\r\n\r\n        if (_isBancorAddress(msgSender)) {\r\n            if (_isBancorAddress(to))\r\n                return _isBancorAddress(_from) || _isAddressByPassed(_from);\r\n            else if (_isAddressByPassed(to)) return true;\r\n            else return false;\r\n        } else if (_isBancorAddress(to)) return false;\r\n\r\n        result = _isReceiveAllowed(_to, token); // Check receiver at first\r\n        if (!result) return false; // if receiver disallowed the transfer disallowed too.\r\n        address from = address_belongs[_from];\r\n        require(from != address(0), \"ERR_TRANSFER_CHECK_WHITELIST\");\r\n        uint256 from_flags = user_details[from].flags;\r\n        uint256 to_flags = user_details[to].flags;\r\n        //makes sure that token is not mature\r\n        if (tokenToMaturityDaysTimeStamp[token] != 0)\r\n            require(\r\n                now < tokenToMaturityDaysTimeStamp[token],\r\n                \"ERR_TOKEN_MATURED\"\r\n            );\r\n        //makes sure that holdback days are over\r\n        if (tokenToHoldBackDaysTimeStamp[token] != 0)\r\n            require(\r\n                now >= tokenToHoldBackDaysTimeStamp[token],\r\n                \"ERR_TOKEN_HOLDBACK_NOT_OVER\"\r\n            );\r\n\r\n        for (\r\n            uint256 i = 0;\r\n            i < tokenToTransferringRuleArray[token].length;\r\n            i++\r\n        ) {\r\n            // check the sender for restriction.\r\n            result = _checkRule(\r\n                from_flags,\r\n                tokenToTransferringRuleArray[token][i].from_mask,\r\n                tokenToTransferringRuleArray[token][i].from_condition\r\n            );\r\n            // check receiver only in case when sender has restriction.\r\n            if (result) {\r\n                result = _checkRule(\r\n                    to_flags,\r\n                    tokenToTransferringRuleArray[token][i].to_mask,\r\n                    tokenToTransferringRuleArray[token][i].to_condition\r\n                );\r\n                if (result) return false; // if receiver is restricted, the transfer disallowed.\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**@dev adds ReceivingRule for main token*/\r\n    function addMainRecivingRule(uint256 mask, uint256 condition)\r\n        public\r\n        onlyOwner()\r\n    {\r\n        _addReceivingRule(mask, condition, 0);\r\n    }\r\n\r\n    /**@dev removes a specific rule from transferringRules for main token*/\r\n    function removeMainTransferingRules(uint256 _index) public onlyOwner() {\r\n        _removeTransferingRule(_index, 0);\r\n    }\r\n\r\n    /**@dev add transferringRule for main token*/\r\n    function addMainTransferringRule(\r\n        uint256 from_mask,\r\n        uint256 from_condition,\r\n        uint256 to_mask,\r\n        uint256 to_condition\r\n    ) public onlyOwner() {\r\n        _addTransferringRule(\r\n            from_mask,\r\n            from_condition,\r\n            to_mask,\r\n            to_condition,\r\n            0\r\n        );\r\n    }\r\n\r\n    /**@dev checks if address is allowed to recieve main token*/\r\n    function main_isReceiveAllowed(address user) public view returns (bool) {\r\n        return _isReceiveAllowed(user, 0);\r\n    }\r\n\r\n    /**@dev check if transferring is allowed for main*/\r\n    function main_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) public view returns (bool) {\r\n        return _isTransferAllowed(_msgSender, _from, _to, 0);\r\n    }\r\n\r\n    /**@dev check if transferring is allowed for etn*/\r\n    function etn_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) public view returns (bool) {\r\n        return _isTransferAllowed(_msgSender, _from, _to, 1);\r\n    }\r\n\r\n    /**@dev checks if address is allowed to recieve etn token*/\r\n    function etn_isReceiveAllowed(address user) public view returns (bool) {\r\n        return _isReceiveAllowed(user, 1);\r\n    }\r\n\r\n    /**@dev adds ReceivingRule for etn token*/\r\n    function addEtnTransferringRule(\r\n        uint256 from_mask,\r\n        uint256 from_condition,\r\n        uint256 to_mask,\r\n        uint256 to_condition\r\n    ) public onlyOwner() {\r\n        _addTransferringRule(\r\n            from_mask,\r\n            from_condition,\r\n            to_mask,\r\n            to_condition,\r\n            1\r\n        );\r\n    }\r\n\r\n    /**@dev removes a specific rule from transferringRules for etn token*/\r\n    function removeEtnTransferingRules(uint256 _index) public onlyOwner() {\r\n        _removeTransferingRule(_index, 1);\r\n    }\r\n\r\n    /**@dev adds ReceivingRule for etn token*/\r\n    function addEtnRecivingRule(uint256 mask, uint256 condition)\r\n        public\r\n        onlyOwner()\r\n    {\r\n        _addReceivingRule(mask, condition, 1);\r\n    }\r\n\r\n    /**@dev check if transferring is allowed for stock*/\r\n    function stock_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) public view returns (bool) {\r\n        return _isTransferAllowed(_msgSender, _from, _to, 2);\r\n    }\r\n\r\n    /**@dev checks if address is allowed to recieve stock token*/\r\n    function stock_isReceiveAllowed(address user) public view returns (bool) {\r\n        return _isReceiveAllowed(user, 2);\r\n    }\r\n\r\n    /**@dev add transferringRule for stock token*/\r\n    function addStockTransferringRule(\r\n        uint256 from_mask,\r\n        uint256 from_condition,\r\n        uint256 to_mask,\r\n        uint256 to_condition\r\n    ) public onlyOwner() {\r\n        _addTransferringRule(\r\n            from_mask,\r\n            from_condition,\r\n            to_mask,\r\n            to_condition,\r\n            2\r\n        );\r\n    }\r\n\r\n    //@dev removes a specific rule from transferringRules for stock token*/\r\n    function removeStockTransferingRules(uint256 _index) public onlyOwner() {\r\n        _removeTransferingRule(_index, 2);\r\n    }\r\n\r\n    /**@dev adds ReceivingRule for stock token*/\r\n    function addStockRecivingRule(uint256 mask, uint256 condition)\r\n        public\r\n        onlyOwner()\r\n    {\r\n        _addReceivingRule(mask, condition, 2);\r\n    }\r\n\r\n    /**@dev returns wallets associated with _whom */\r\n    function getUserWallets(address _which)\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        address primaryAddress = address_belongs[_which];\r\n        UserDetails storage details = user_details[primaryAddress];\r\n        return details.wallets;\r\n    }\r\n\r\n    function updateHoldBackDays(uint8 _token, uint256 _holdBackDay)\r\n        public\r\n        onlyAuthorized()\r\n        returns (bool)\r\n    {\r\n        tokenToHoldBackDaysTimeStamp[_token] = convertDaysToTimeStamp(\r\n            _holdBackDay\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function updateMaturityDays(uint8 _token, uint256 _maturityDays)\r\n        public\r\n        onlyAuthorized()\r\n        returns (bool)\r\n    {\r\n        tokenToMaturityDaysTimeStamp[_token] = convertDaysToTimeStamp(\r\n            _maturityDays\r\n        );\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeSystemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IS_BYPASSED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUALIFIED_INVESTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeMainTransferingRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FROM_EU\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"etn_isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IS_ALLOWED_STOCK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tokenToHoldBackDaysTimeStamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeEtnTransferingRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"stock_isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changePrimaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from_mask\",\"type\":\"uint256\"},{\"name\":\"from_condition\",\"type\":\"uint256\"},{\"name\":\"to_mask\",\"type\":\"uint256\"},{\"name\":\"to_condition\",\"type\":\"uint256\"}],\"name\":\"addEtnTransferringRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"stock_isReceiveAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"isExchangeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwnerInitialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeStockTransferingRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"etn_isReceiveAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"address_belongs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tokenToReceivingRule\",\"outputs\":[{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"condition\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primaryOwner\",\"type\":\"address\"},{\"name\":\"_systemAddress\",\"type\":\"address\"},{\"name\":\"_authorityAddress\",\"type\":\"address\"},{\"name\":\"_mainHoldBackDays\",\"type\":\"uint256\"},{\"name\":\"_etnHoldBackDays\",\"type\":\"uint256\"},{\"name\":\"_stockHoldBackDays\",\"type\":\"uint256\"},{\"name\":\"_mainMaturityDays\",\"type\":\"uint256\"},{\"name\":\"_etnMaturityDays\",\"type\":\"uint256\"},{\"name\":\"_stockMaturityDays\",\"type\":\"uint256\"},{\"name\":\"_registryaddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToTransferringRuleArray\",\"outputs\":[{\"name\":\"from_mask\",\"type\":\"uint256\"},{\"name\":\"from_condition\",\"type\":\"uint256\"},{\"name\":\"to_mask\",\"type\":\"uint256\"},{\"name\":\"to_condition\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"isAddressByPassed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"getUserWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ACCREDIATED_INVESTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"addMoreWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IS_ALLOWED_AUCTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"main_isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"condition\",\"type\":\"uint256\"}],\"name\":\"addMainRecivingRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mainWallet\",\"type\":\"address\"},{\"name\":\"_subWallet\",\"type\":\"address\"}],\"name\":\"addWalletBehalfExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tokenToMaturityDaysTimeStamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CENTRALIZE_EXCHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"},{\"name\":\"_maxWallets\",\"type\":\"uint256\"}],\"name\":\"updateMaxWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FROM_USA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FROM_CHINA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"main_isReceiveAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"},{\"name\":\"_flags\",\"type\":\"uint256\"},{\"name\":\"_maxWallets\",\"type\":\"uint256\"}],\"name\":\"addNewWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"uint8\"},{\"name\":\"_holdBackDay\",\"type\":\"uint256\"}],\"name\":\"updateHoldBackDays\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"},{\"name\":\"_condition\",\"type\":\"uint256\"}],\"name\":\"checkRule\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from_mask\",\"type\":\"uint256\"},{\"name\":\"from_condition\",\"type\":\"uint256\"},{\"name\":\"to_mask\",\"type\":\"uint256\"},{\"name\":\"to_condition\",\"type\":\"uint256\"}],\"name\":\"addStockTransferringRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RETAIL_INVESTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IS_ALLOWED_ETN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateRegistery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"isAllowedInAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from_mask\",\"type\":\"uint256\"},{\"name\":\"from_condition\",\"type\":\"uint256\"},{\"name\":\"to_mask\",\"type\":\"uint256\"},{\"name\":\"to_condition\",\"type\":\"uint256\"}],\"name\":\"addMainTransferringRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"condition\",\"type\":\"uint256\"}],\"name\":\"addStockRecivingRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_details\",\"outputs\":[{\"name\":\"flags\",\"type\":\"uint256\"},{\"name\":\"maxWallets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"},{\"name\":\"_flags\",\"type\":\"uint256\"}],\"name\":\"changeFlags\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"uint8\"},{\"name\":\"_maturityDays\",\"type\":\"uint256\"}],\"name\":\"updateMaturityDays\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AML\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECENTRALIZE_EXCHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"condition\",\"type\":\"uint256\"}],\"name\":\"addEtnRecivingRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"which\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"flags\",\"type\":\"uint256\"}],\"name\":\"AccountWhiteListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"which\",\"type\":\"address\"}],\"name\":\"WalletAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"which\",\"type\":\"address\"}],\"name\":\"WalletRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"which\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"flags\",\"type\":\"uint256\"}],\"name\":\"FlagsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerType\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AuthorityAddressChnageCall\",\"type\":\"event\"}]","ContractName":"WhiteList","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://337945221c09be1ef4e169d8824706875899e7555516ca0be57a0228e4b793ed"}]}