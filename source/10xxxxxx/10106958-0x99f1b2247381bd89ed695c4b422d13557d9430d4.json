{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.26;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface OrFeedInterface {\r\n  function getExchangeRate ( string fromSymbol, string toSymbol, string  venue, uint256 amount ) external view returns ( uint256 );\r\n  function getTokenDecimalCount ( address tokenAddress ) external view returns ( uint256 );\r\n  function getTokenAddress ( string  symbol ) external view returns ( address );\r\n  function getSynthBytes32 ( string  symbol ) external view returns ( bytes32 );\r\n  function getForexAddress ( string  symbol ) external view returns ( address );\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal view returns(uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal view returns(uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal view returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal view returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ArbCalc{\r\nOrFeedInterface orfeed = OrFeedInterface(0x8316b082621cfedab95bf4a44a1d4b64a6ffc336);\r\n   address owner;\r\n  \r\n\r\n\r\n\r\n\r\n      modifier onlyOwner() {\r\n            if (msg.sender != owner) {\r\n                throw;\r\n            }\r\n             _;\r\n        }\r\n\r\n      constructor() public payable {\r\n            owner = msg.sender;\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n   function kill() onlyOwner{\r\n       selfdestruct(owner);\r\n   }\r\n\r\n    function() payable{\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n     function arbCalc(uint8[] eOrder, string[] tOrder, uint256 amount, bool back ) public  constant returns (uint256){\r\n        uint256 final1 = eOrder.length -1;\r\n        uint lastSell = amount;\r\n        for(uint i =0; i<eOrder.length; i++){\r\n            uint256 next = i+1;\r\n            if(i < final1){\r\n               if(eOrder[i] ==1){\r\n                   //kyber buy\r\n                   lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[next], \"KYBERBYSYMBOLV1\", lastSell);\r\n               }\r\n               else if(eOrder[i] ==2){\r\n\r\n\r\n                            lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[next], \"UNISWAPBYSYMBOLV1\", lastSell);\r\n                    //lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[next], \"BUY-UNISWAP-EXCHANGE\", lastSell);\r\n               }\r\n               else if(eOrder[i] ==4){\r\n                          lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[next], \"UNISWAPBYSYMBOLV2\", lastSell);\r\n                 // lastSell = swapTokenOnUniswapCalc(tOrder[i], lastSell, tOrder[0]);\r\n               }\r\n               \r\n               else{\r\n                    lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[next], \"BANCOR\", lastSell);\r\n               }\r\n            }\r\n            else{\r\n                 //sell\r\n                if(back ==true){\r\n               if(eOrder[i] ==1){\r\n                   //kyber buy\r\n                    lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[0], \"KYBERBYSYMBOLV1\", lastSell);\r\n                   //lastSell = swapTokenOnKyberCalc(tOrder[i], lastSell, tOrder[0]);\r\n               }\r\n               else if(eOrder[i] ==2){\r\n                     lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[0], \"UNISWAPBYSYMBOLV1\", lastSell);\r\n                 // lastSell = swapTokenOnUniswapCalc(tOrder[i], lastSell, tOrder[0]);\r\n               }\r\n               else if(eOrder[i] ==4){\r\n                       lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[0], \"UNISWAPBYSYMBOLV2\", lastSell);\r\n                 // lastSell = swapTokenOnUniswapCalc(tOrder[i], lastSell, tOrder[0]);\r\n               }\r\n               \r\n               else{\r\n                   lastSell = orfeed.getExchangeRate(tOrder[i], tOrder[0], \"BANCOR\", lastSell);\r\n                 //lastSell = bancorConvert2Calc(tOrder[0], tOrder[i], lastSell);\r\n               }\r\n            }\r\n            }\r\n        }\r\n\r\n        return lastSell;\r\n    }\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eOrder\",\"type\":\"uint8[]\"},{\"name\":\"tOrder\",\"type\":\"string[]\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"back\",\"type\":\"bool\"}],\"name\":\"arbCalc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ArbCalc","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://fe53492d45758efec7fe28cdbc12f1ee56aad614e05291a1134b714c69fa1d6a"}]}