{"status":"1","message":"OK","result":[{"SourceCode":"/**\nSPDX-License-Identifier: UNLICENSED\nSee https://github.com/OpenZeppelin/openzeppelin-contracts/blob/2a0f2a8ba807b41360e7e092c3d5bb1bfbeb8b50/LICENSE and https://github.com/NovakDistributed/macroverse/blob/eea161aff5dba9d21204681a3b0f5dbe1347e54b/LICENSE\n*/\n\npragma solidity ^0.6.10;\n\n\n/**\n * This library contains utility functions for creating, parsing, and\n * manipulating Macroverse virtual real estate non-fungible token (NFT)\n * identifiers. The uint256 that identifies a piece of Macroverse virtual real\n * estate includes the type of object that is claimed and its location in the\n * macroverse world, as defined by this library.\n *\n * NFT tokens carry metadata about the object they describe, in the form of a\n * bit-packed keypath in the 192 low bits of a uint256. Form LOW to HIGH bits,\n * the fields are:\n *\n * - token type (5): sector (0), system (1), planet (2), moon (3),\n *   land on planet or moon at increasing granularity (4-31)\n * - sector x (16)\n * - sector y (16)\n * - sector z (16)\n * - star number (16) or 0 if a sector\n * - planet number (16) or 0 if a star\n * - moon number (16) or 0 if a planet, or -1 if land on a planet\n * - 0 to 27 trixel numbers, at 3 bits each\n *\n * More specific claims use more of the higher-value bits, producing larger\n * numbers in general.\n *\n * The \"trixel\" numbers refer to dubdivisions of the surface of a planet or\n * moon, or the area of an asteroid belt or ring. See the documentation for the\n * MacroverseUniversalRegistry for more information on the trixel system.\n *\n * Small functions in the library are internal, because inlining them will take\n * less space than a call.\n *\n * Larger functions are public.\n *\n */\nlibrary MacroverseNFTUtils {\n\n    //\n    // Code for working on token IDs\n    //\n    \n    // Define the types of tokens that can exist\n    uint256 constant TOKEN_TYPE_SECTOR = 0;\n    uint256 constant TOKEN_TYPE_SYSTEM = 1;\n    uint256 constant TOKEN_TYPE_PLANET = 2;\n    uint256 constant TOKEN_TYPE_MOON = 3;\n    // Land tokens are a range of type field values.\n    // Land tokens of the min type use one trixel field\n    uint256 constant TOKEN_TYPE_LAND_MIN = 4;\n    uint256 constant TOKEN_TYPE_LAND_MAX = 31;\n\n    // Define the packing format\n    uint8 constant TOKEN_SECTOR_X_SHIFT = 5;\n    uint8 constant TOKEN_SECTOR_X_BITS = 16;\n    uint8 constant TOKEN_SECTOR_Y_SHIFT = TOKEN_SECTOR_X_SHIFT + TOKEN_SECTOR_X_BITS;\n    uint8 constant TOKEN_SECTOR_Y_BITS = 16;\n    uint8 constant TOKEN_SECTOR_Z_SHIFT = TOKEN_SECTOR_Y_SHIFT + TOKEN_SECTOR_Y_BITS;\n    uint8 constant TOKEN_SECTOR_Z_BITS = 16;\n    uint8 constant TOKEN_SYSTEM_SHIFT = TOKEN_SECTOR_Z_SHIFT + TOKEN_SECTOR_Z_BITS;\n    uint8 constant TOKEN_SYSTEM_BITS = 16;\n    uint8 constant TOKEN_PLANET_SHIFT = TOKEN_SYSTEM_SHIFT + TOKEN_SYSTEM_BITS;\n    uint8 constant TOKEN_PLANET_BITS = 16;\n    uint8 constant TOKEN_MOON_SHIFT = TOKEN_PLANET_SHIFT + TOKEN_PLANET_BITS;\n    uint8 constant TOKEN_MOON_BITS = 16;\n    uint8 constant TOKEN_TRIXEL_SHIFT = TOKEN_MOON_SHIFT + TOKEN_MOON_BITS;\n    uint8 constant TOKEN_TRIXEL_EACH_BITS = 3;\n\n    // How many trixel fields are there\n    uint256 constant TOKEN_TRIXEL_FIELD_COUNT = 27;\n\n    // How many children does a trixel have?\n    uint256 constant CHILDREN_PER_TRIXEL = 4;\n    // And how many top level trixels does a world have?\n    uint256 constant TOP_TRIXELS = 8;\n\n    // We keep a bit mask of the high bits of all but the least specific trixel.\n    // None of these may be set in a valid token.\n    // We rely on it being left-shifted TOKEN_TRIXEL_SHIFT bits before being applied.\n    // Note that this has 26 1s, with one every 3 bits, except the last 3 bits are 0.\n    uint256 constant TOKEN_TRIXEL_HIGH_BIT_MASK = 0x124924924924924924920;\n\n    // Sentinel for no moon used (for land on a planet)\n    uint16 constant MOON_NONE = 0xFFFF;\n\n    /**\n     * Work out what type of real estate a token represents.\n     * Land claims of different granularities are different types.\n     */\n    function getTokenType(uint256 token) internal pure returns (uint256) {\n        // Grab off the low 5 bits\n        return token & 0x1F;\n    }\n\n    /**\n     * Modify the type of a token. Does not fix up the other fields to correspond to the new type\n     */\n    function setTokenType(uint256 token, uint256 newType) internal pure returns (uint256) {\n        assert(newType <= 31);\n        // Clear and replace the low 5 bits\n        return (token & ~uint256(0x1F)) | newType;\n    }\n\n    /**\n     * Get the 16 bits of the token, at the given offset from the low bit.\n     */\n    function getTokenUInt16(uint256 token, uint8 offset) internal pure returns (uint16) {\n        return uint16(token >> offset);\n    }\n\n    /**\n     * Set the 16 bits of the token, at the given offset from the low bit, to the given value.\n     */\n    function setTokenUInt16(uint256 token, uint8 offset, uint16 data) internal pure returns (uint256) {\n        // Clear out the bits we want to set, and then or in their values\n        return (token & ~(uint256(0xFFFF) << offset)) | (uint256(data) << offset);\n    }\n\n    /**\n     * Get the X, Y, and Z coordinates of a token's sector.\n     */\n    function getTokenSector(uint256 token) internal pure returns (int16 x, int16 y, int16 z) {\n        x = int16(getTokenUInt16(token, TOKEN_SECTOR_X_SHIFT));\n        y = int16(getTokenUInt16(token, TOKEN_SECTOR_Y_SHIFT));\n        z = int16(getTokenUInt16(token, TOKEN_SECTOR_Z_SHIFT));\n    }\n\n    /**\n     * Set the X, Y, and Z coordinates of the sector data in the given token.\n     */\n    function setTokenSector(uint256 token, int16 x, int16 y, int16 z) internal pure returns (uint256) {\n        return setTokenUInt16(setTokenUInt16(setTokenUInt16(token, TOKEN_SECTOR_X_SHIFT, uint16(x)),\n            TOKEN_SECTOR_Y_SHIFT, uint16(y)), TOKEN_SECTOR_Z_SHIFT, uint16(z));\n    }\n\n    /**\n     * Get the system number of a token.\n     */\n    function getTokenSystem(uint256 token) internal pure returns (uint16) {\n        return getTokenUInt16(token, TOKEN_SYSTEM_SHIFT);\n    }\n\n    /**\n     * Set the system number of a token.\n     */\n    function setTokenSystem(uint256 token, uint16 system) internal pure returns (uint256) {\n        return setTokenUInt16(token, TOKEN_SYSTEM_SHIFT, system);\n    }\n\n    /**\n     * Get the planet number of a token.\n     */\n    function getTokenPlanet(uint256 token) internal pure returns (uint16) {\n        return getTokenUInt16(token, TOKEN_PLANET_SHIFT);\n    }\n\n    /**\n     * Set the planet number of a token.\n     */\n    function setTokenPlanet(uint256 token, uint16 planet) internal pure returns (uint256) {\n        return setTokenUInt16(token, TOKEN_PLANET_SHIFT, planet);\n    }\n\n    /**\n     * Get the moon number of a token.\n     */\n    function getTokenMoon(uint256 token) internal pure returns (uint16) {\n        return getTokenUInt16(token, TOKEN_MOON_SHIFT);\n    }\n\n    /**\n     * Set the moon number of a token.\n     */\n    function setTokenMoon(uint256 token, uint16 moon) internal pure returns (uint256) {\n        return setTokenUInt16(token, TOKEN_MOON_SHIFT, moon);\n    }\n\n    /**\n     * Get the number of used trixel fields in a token. From 0 (not land) to 27.\n     */\n    function getTokenTrixelCount(uint256 token) internal pure returns (uint256) {\n        uint256 token_type = getTokenType(token);\n        if (token_type < TOKEN_TYPE_LAND_MIN) {\n            return 0;\n        }\n    \n        // Remember that at the min type one trixel is used.\n        return token_type - TOKEN_TYPE_LAND_MIN + 1;\n    }\n\n    /**\n     * Set the number of used trixel fields in a token. From 1 to 27.\n     * Automatically makes the token land type.\n     */\n    function setTokenTrixelCount(uint256 token, uint256 count) internal pure returns (uint256) {\n        assert(count > 0);\n        assert(count <= TOKEN_TRIXEL_FIELD_COUNT);\n        uint256 token_type = TOKEN_TYPE_LAND_MIN + count - 1;\n        return setTokenType(token, token_type);\n    }\n\n    /**\n     * Get the value of the trixel at the given index in the token. Index can be from 0 through 26.\n     * At trixel 0, values are 0-7. At other trixels, values are 0-3.\n     * Assumes the token is land and has sufficient trixels to query this one.\n     */\n    function getTokenTrixel(uint256 token, uint256 trixel_index) internal pure returns (uint256) {\n        assert(trixel_index < TOKEN_TRIXEL_FIELD_COUNT);\n        // Shift down to the trixel we want and get the low 3 bits.\n        return (token >> (TOKEN_TRIXEL_SHIFT + TOKEN_TRIXEL_EACH_BITS * trixel_index)) & 0x7;\n    }\n\n    /**\n     * Set the value of the trixel at the given index. Trixel indexes can be\n     * from 0 throug 26. Values can be 0-7 for the first trixel, and 0-3 for\n     * subsequent trixels.  Assumes the token trixel count will be updated\n     * separately if necessary.\n     */\n    function setTokenTrixel(uint256 token, uint256 trixel_index, uint256 value) internal pure returns (uint256) {\n        assert(trixel_index < TOKEN_TRIXEL_FIELD_COUNT);\n        if (trixel_index == 0) {\n            assert(value < TOP_TRIXELS);\n        } else {\n            assert(value < CHILDREN_PER_TRIXEL);\n        }\n        \n        // Compute the bit shift distance\n        uint256 trixel_shift = (TOKEN_TRIXEL_SHIFT + TOKEN_TRIXEL_EACH_BITS * trixel_index);\n    \n        // Clear out the field and then set it again\n        return (token & ~(uint256(0x7) << trixel_shift)) | (value << trixel_shift); \n    }\n\n    /**\n     * Return true if the given token number/bit-packed keypath corresponds to a land trixel, and false otherwise.\n     */\n    function tokenIsLand(uint256 token) internal pure returns (bool) {\n        uint256 token_type = getTokenType(token);\n        return (token_type >= TOKEN_TYPE_LAND_MIN && token_type <= TOKEN_TYPE_LAND_MAX); \n    }\n\n    /**\n     * Get the token number representing the parent of the given token (i.e. the system if operating on a planet, etc.).\n     * That token may or may not be currently owned.\n     * May return a token representing a sector; sectors can't be claimed.\n     * Will fail if called on a token that is a sector\n     */\n    function parentOfToken(uint256 token) internal pure returns (uint256) {\n        uint256 token_type = getTokenType(token);\n\n        assert(token_type != TOKEN_TYPE_SECTOR);\n\n        if (token_type == TOKEN_TYPE_SYSTEM) {\n            // Zero out the system and make it a sector token\n            return setTokenType(setTokenSystem(token, 0), TOKEN_TYPE_SECTOR);\n        } else if (token_type == TOKEN_TYPE_PLANET) {\n            // Zero out the planet and make it a system token\n            return setTokenType(setTokenPlanet(token, 0), TOKEN_TYPE_SYSTEM);\n        } else if (token_type == TOKEN_TYPE_MOON) {\n            // Zero out the moon and make it a planet token\n            return setTokenType(setTokenMoon(token, 0), TOKEN_TYPE_PLANET);\n        } else if (token_type == TOKEN_TYPE_LAND_MIN) {\n            // Move from top level trixel to planet or moon\n            if (getTokenMoon(token) == MOON_NONE) {\n                // It's land on a planet\n                // Make sure to zero out the moon field\n                return setTokenType(setTokenMoon(setTokenTrixel(token, 0, 0), 0), TOKEN_TYPE_PLANET);\n            } else {\n                // It's land on a moon. Leave the moon in.\n                return setTokenType(setTokenTrixel(token, 0, 0), TOKEN_TYPE_PLANET);\n            }\n        } else {\n            // It must be land below the top level\n            uint256 last_trixel = getTokenTrixelCount(token) - 1;\n            // Clear out the last trixel and pop it off\n            return setTokenTrixelCount(setTokenTrixel(token, last_trixel, 0), last_trixel);\n        }\n    }\n\n    /**\n     * If the token has a parent, get the token's index among all children of the parent.\n     * Planets have surface trixels and moons as children; the 8 surface trixels come first, followed by any moons. \n     * Fails if the token has no parent.\n     */\n    function childIndexOfToken(uint256 token) internal pure returns (uint256) {\n        uint256 token_type = getTokenType(token);\n\n        assert(token_type != TOKEN_TYPE_SECTOR);\n\n        if (token_type == TOKEN_TYPE_SYSTEM) {\n            // Get the system field of a system token\n            return getTokenSystem(token);\n        } else if (token_type == TOKEN_TYPE_PLANET) {\n            // Get the planet field of a planet token\n            return getTokenPlanet(token);\n        } else if (token_type == TOKEN_TYPE_MOON) {\n            // Get the moon field of a moon token. Offset it by the 0-7 top trixels of the planet's land.\n            return getTokenMoon(token) + TOP_TRIXELS;\n        } else if (token_type >= TOKEN_TYPE_LAND_MIN && token_type <= TOKEN_TYPE_LAND_MAX) {\n            // Get the value of the last trixel. Top-level trixels are the first children of planets.\n            uint256 last_trixel = getTokenTrixelCount(token) - 1;\n            return getTokenTrixel(token, last_trixel);\n        } else {\n            // We have an invalid token type somehow\n            assert(false);\n        }\n    }\n\n    /**\n     * If a token has a possible child for which childIndexOfToken would return the given index, returns that child.\n     * Fails otherwise.\n     * Index must not be wider than uint16 or it may be truncated.\n     */\n    function childTokenAtIndex(uint256 token, uint256 index) public pure returns (uint256) {\n        uint256 token_type = getTokenType(token);\n\n        assert(token_type != TOKEN_TYPE_LAND_MAX);\n\n        if (token_type == TOKEN_TYPE_SECTOR) {\n            // Set the system field and make it a system token\n            return setTokenType(setTokenSystem(token, uint16(index)), TOKEN_TYPE_SYSTEM);\n        } else if (token_type == TOKEN_TYPE_SYSTEM) {\n            // Set the planet field and make it a planet token\n            return setTokenType(setTokenPlanet(token, uint16(index)), TOKEN_TYPE_PLANET);\n        } else if (token_type == TOKEN_TYPE_PLANET) {\n            // Child could be a land or moon. The land trixels are first as 0-7\n            if (index < TOP_TRIXELS) {\n                // Make it land and set the first trixel\n                return setTokenType(setTokenTrixel(token, 0, uint16(index)), TOKEN_TYPE_LAND_MIN);\n            } else {\n                // Make it a moon\n                return setTokenType(setTokenMoon(token, uint16(index - TOP_TRIXELS)), TOKEN_TYPE_MOON);\n            }\n        } else if (token_type == TOKEN_TYPE_MOON) {\n            // Make it land and set the first trixel\n            return setTokenType(setTokenTrixel(token, 0, uint16(index)), TOKEN_TYPE_LAND_MIN);\n        } else if (token_type >= TOKEN_TYPE_LAND_MIN && token_type < TOKEN_TYPE_LAND_MAX) {\n            // Add another trixel with this value.\n            // Its index will be the *count* of existing trixels.\n            uint256 next_trixel = getTokenTrixelCount(token);\n            return setTokenTrixel(setTokenTrixelCount(token, next_trixel + 1), next_trixel, uint16(index));\n        } else {\n            // We have an invalid token type somehow\n            assert(false);\n        }\n    }\n\n    /**\n     * Not all uint256 values are valid tokens.\n     * Returns true if the token represents something that may exist in the Macroverse world.\n     * Only does validation of the bitstring representation (i.e. no extraneous set bits).\n     * We still need to check in with the generator to validate that the system/planet/moon actually exists.\n     */\n    function tokenIsCanonical(uint256 token) public pure returns (bool) {\n        \n        if (token >> (TOKEN_TRIXEL_SHIFT + TOKEN_TRIXEL_EACH_BITS * getTokenTrixelCount(token)) != 0) {\n            // There are bits set above the highest used trixel (for land) or in any trixel (for non-land)\n            return false;\n        }\n\n        if (tokenIsLand(token)) {\n            if (token & (TOKEN_TRIXEL_HIGH_BIT_MASK << TOKEN_TRIXEL_SHIFT) != 0) {\n                // A high bit in a trixel other than the first is set\n                return false;\n            }\n        }\n\n        uint256 token_type = getTokenType(token);\n\n        if (token_type == TOKEN_TYPE_MOON) {\n            if (getTokenMoon(token) == MOON_NONE) {\n                // Not a real moon\n                return false;\n            }\n        } else if (token_type < TOKEN_TYPE_MOON) {\n            if (getTokenMoon(token) != 0) {\n                // Moon bits need to be clear\n                return false;\n            }\n\n            if (token_type < TOKEN_TYPE_PLANET) {\n                if (getTokenPlanet(token) != 0) {\n                    // Planet bits need to be clear\n                    return false;\n                }\n\n                if (token_type < TOKEN_TYPE_SYSTEM) {\n                    if (getTokenSystem(token) != 0) {\n                        // System bits need to be clear\n                        return false;\n                    }\n                }\n            }\n        }\n\n        // We found no problems. Still might not exist, though. Could be an out of range sector or a non-present system, planet or moon.\n        return true;\n    }\n\n}\n\n// This code is part of Macroverse and is licensed: UNLICENSED","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"childTokenAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"tokenIsCanonical\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MacroverseNFTUtils","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}