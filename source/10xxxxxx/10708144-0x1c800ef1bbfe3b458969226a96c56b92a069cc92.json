{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ConnectorsInterface {\r\n  function chief(address) external view returns (bool);\r\n}\r\n\r\ninterface IndexInterface {\r\n  function master() external view returns (address);\r\n}\r\n\r\ncontract BytesHelper {\r\n  /**\r\n  * @dev Convert String to bytes32.\r\n  */\r\n  function stringToBytes32(string memory str) internal pure returns (bytes32 result) {\r\n    require(bytes(str).length != 0, \"String-Empty\");\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      result := mload(add(str, 32))\r\n    }\r\n  }\r\n}\r\n\r\ncontract Helpers is BytesHelper {\r\n  address public constant connectors = 0xD6A602C01a023B98Ecfb29Df02FBA380d3B21E0c;\r\n  address public constant instaIndex = 0x2971AdFa57b20E5a416aE5a708A8655A9c74f723;\r\n  uint public version = 1;\r\n\r\n  mapping (bytes32 => GaugeData) public gaugeMapping;\r\n\r\n  struct GaugeData {\r\n    address gaugeAddress;\r\n    bool rewardToken;\r\n  }\r\n\r\n  event LogAddGaugeMapping(\r\n    string gaugeName,\r\n    address gaugeAddress,\r\n    bool rewardToken\r\n  );\r\n\r\n  event LogRemoveGaugeMapping(\r\n    string gaugeName,\r\n    address gaugeAddress\r\n  );\r\n\r\n  modifier isChief virtual {\r\n    require(\r\n      ConnectorsInterface(connectors).chief(msg.sender) ||\r\n      IndexInterface(instaIndex).master() == msg.sender, \"not-Chief\");\r\n      _;\r\n  }\r\n\r\n  function _addGaugeMapping(\r\n    string memory gaugeName,\r\n    address gaugeAddress,\r\n    bool rewardToken\r\n  ) internal {\r\n    require(gaugeAddress != address(0), \"gaugeAddress-not-vaild\");\r\n    require(bytes(gaugeName).length <= 32, \"Length-exceeds\");\r\n    bytes32 gaugeType = stringToBytes32(gaugeName);\r\n    require(gaugeMapping[gaugeType].gaugeAddress == address(0), \"gaugePool-already-added\");\r\n\r\n    gaugeMapping[gaugeType].gaugeAddress = gaugeAddress;\r\n    gaugeMapping[gaugeType].rewardToken = rewardToken;\r\n\r\n    emit LogAddGaugeMapping(gaugeName, gaugeAddress, rewardToken);\r\n  }\r\n\r\n  function addGaugeMappings(\r\n    string[] memory gaugeNames,\r\n    address[] memory gaugeAddresses,\r\n    bool[] memory rewardTokens\r\n  ) public isChief {\r\n    require(gaugeNames.length == gaugeAddresses.length && gaugeAddresses.length == rewardTokens.length, \"length-not-match\");\r\n    for (uint32 i; i < gaugeNames.length; i++) {\r\n      _addGaugeMapping(gaugeNames[i], gaugeAddresses[i], rewardTokens[i]);\r\n    }\r\n  }\r\n\r\n  function removeGaugeMapping(string memory gaugeName, address gaugeAddress) public isChief {\r\n    require(gaugeAddress != address(0), \"gaugeAddress-not-vaild\");\r\n    bytes32 gaugeType = stringToBytes32(gaugeName);\r\n    require(gaugeMapping[gaugeType].gaugeAddress == gaugeAddress, \"different-gauge-pool\");\r\n\r\n    delete gaugeMapping[gaugeType];\r\n\r\n    emit LogRemoveGaugeMapping(\r\n      gaugeName,\r\n      gaugeAddress\r\n    );\r\n  }\r\n}\r\n\r\ncontract CurveGaugeMapping is Helpers {\r\n  string constant public name = \"Curve-Gauge-Mapping-v1\";\r\n\r\n  constructor (\r\n    string[] memory gaugeNames,\r\n    address[] memory gaugeAddresses,\r\n    bool[] memory rewardTokens\r\n  ) public {\r\n    require(gaugeNames.length == gaugeAddresses.length && gaugeAddresses.length == rewardTokens.length, \"length-not-match\");\r\n    for (uint32 i; i < gaugeNames.length; i++) {\r\n      _addGaugeMapping(gaugeNames[i], gaugeAddresses[i], rewardTokens[i]);\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"gaugeNames\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"gaugeAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"rewardTokens\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"gaugeName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gaugeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rewardToken\",\"type\":\"bool\"}],\"name\":\"LogAddGaugeMapping\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"gaugeName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gaugeAddress\",\"type\":\"address\"}],\"name\":\"LogRemoveGaugeMapping\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"gaugeNames\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"gaugeAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"rewardTokens\",\"type\":\"bool[]\"}],\"name\":\"addGaugeMappings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"gaugeMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gaugeAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"rewardToken\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instaIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"gaugeName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"gaugeAddress\",\"type\":\"address\"}],\"name\":\"removeGaugeMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CurveGaugeMapping","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000a67617567652d7375736400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000767617567652d7900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a67617567652d73627463000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000a90996896660decc6e997655e065b23788857849000000000000000000000000fa712ee4788c042e2b7bb55e6cb8ec569c4530c1000000000000000000000000705350c4bcd35c9441419ddd5d2f097d7a55410f0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8611a1face6aabd2f09789d0b856922132d76e5e52a0a0b7c775093b915591f1"}]}