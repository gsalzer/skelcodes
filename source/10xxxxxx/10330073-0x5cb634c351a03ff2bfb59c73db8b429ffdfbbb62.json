{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n    function recordExists(bytes32 node) external view returns (bool);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\ncontract Registrar {\r\n  function approve(address to, uint256 tokenId) public;\r\n  function transferFrom(address from, address to, uint256 tokenId) public;\r\n  function ownerOf(uint256 tokenId) public view returns (address owner);\r\n  function reclaim(uint256 id, address owner) external;\r\n}\r\n\r\ncontract Resolver {\r\n   function supportsInterface(bytes4 interfaceID) public pure returns (bool);\r\n   function addr(bytes32 node) public view returns (address);\r\n   function setAddr(bytes32 node, address addr) public;\r\n}\r\n\r\ncontract IMinion {\r\n  function moloch() public view returns (address);\r\n}\r\n\r\ncontract IMoloch {\r\n  function members(address) public view returns (address, uint256, uint256, bool, uint256, uint256);\r\n}\r\n\r\n/**\r\n * @dev Implements a ENS registrar that gives subdomains to Moloch members or requires a Minion to execute transactions for non-members\r\n * @author Peter Phillips, based off SubdomainRegistrar.sol by ENS https://github.com/ensdomains/subdomain-registrar/blob/master/contracts/SubdomainRegistrar.sol\r\n */\r\n\r\ncontract MinionSubdomainRegistrar {\r\n    // namehash('eth')\r\n    bytes32 constant public TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\r\n\r\n    ENS public ens;\r\n\r\n    address public registrar;\r\n    address public registrarOwner;\r\n    address public migration;\r\n    bool public stopped = false;\r\n\r\n    struct Domain {\r\n        string name;\r\n        address owner;\r\n        address minion;\r\n        address moloch;\r\n    }\r\n\r\n    mapping (bytes32 => Domain) domains;\r\n\r\n    modifier owner_only(bytes32 label) {\r\n        require(owner(label) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier not_stopped() {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n\r\n    modifier registrar_owner_only() {\r\n        require(msg.sender == registrarOwner);\r\n        _;\r\n    }\r\n\r\n    event TransferAddressSet(bytes32 indexed label, address addr);\r\n    event DomainTransferred(bytes32 indexed label, string name);\r\n    event OwnerChanged(bytes32 indexed label, address indexed oldOwner, address indexed newOwner);\r\n    event DomainConfigured(bytes32 indexed label, string domain, address indexed minion);\r\n    event DomainUnlisted(bytes32 indexed label);\r\n    event NewRegistration(bytes32 indexed label, string subdomain, address indexed owner);\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n        registrar = ens.owner(TLD_NODE);\r\n        registrarOwner = msg.sender;\r\n    }\r\n\r\n    /** Registar owner functions **/\r\n\r\n    function transferOwnership(address newOwner) public registrar_owner_only {\r\n        registrarOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address where domains are migrated to.\r\n     * @param _migration Address of the new registrar.\r\n     */\r\n    function setMigrationAddress(address _migration) public registrar_owner_only {\r\n        require(stopped);\r\n        migration = _migration;\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the registrar, disabling configuring of new domains.\r\n     */\r\n    function stop() public not_stopped registrar_owner_only {\r\n        stopped = true;\r\n    }\r\n\r\n    /** Domain owner functions **/\r\n\r\n    /**\r\n     * @dev Sets the resolver record for a name in ENS.\r\n     * @param name The name to set the resolver for.\r\n     * @param resolver The address of the resolver\r\n     */\r\n    function setResolver(string memory name, address resolver) public owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        bytes32 node = keccak256(abi.encodePacked(TLD_NODE, label));\r\n        ens.setResolver(node, resolver);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers internal control of a name to a new account. Does not update\r\n     *      ENS.\r\n     * @param name The name to transfer.\r\n     * @param newOwner The address of the new owner.\r\n     */\r\n    function transfer(string memory name, address newOwner) public owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        emit OwnerChanged(label, domains[label].owner, newOwner);\r\n        domains[label].owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Unlists a domain\r\n     * May only be called by the owner.\r\n     * @param name The name of the domain to unlist.\r\n     */\r\n    function unlistDomain(string memory name) public owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        Registrar(registrar).reclaim(uint256(label), domains[label].owner);\r\n        Registrar(registrar).transferFrom(address(this), domains[label].owner, uint256(label));\r\n        delete domains[label];\r\n        emit DomainUnlisted(label);\r\n    }\r\n\r\n    /** Add domain to registrar **/\r\n\r\n    /**\r\n     * @dev Configures a domain for sale.\r\n     * @param name The name to configure.\r\n     * @param minion The address of the Minion that will control subdomain permissions\r\n     */\r\n    function configureDomain(string memory name, address minion) public {\r\n        configureDomainFor(name, minion, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Configures a domain.\r\n     * @param name The name to configure.\r\n     * @param minion The address of the Minion who can assign subdomains\r\n     * @param _owner The address to assign ownership of this domain to.\r\n     */\r\n    function configureDomainFor(string memory name, address minion, address _owner) public not_stopped owner_only(keccak256(bytes(name))) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        Domain storage domain = domains[label];\r\n\r\n        if (Registrar(registrar).ownerOf(uint256(label)) != address(this)) {\r\n            Registrar(registrar).transferFrom(msg.sender, address(this), uint256(label));\r\n            Registrar(registrar).reclaim(uint256(label), address(this));\r\n        }\r\n\r\n        if (domain.owner != _owner) {\r\n            domain.owner = _owner;\r\n        }\r\n\r\n        if (keccak256(abi.encodePacked(domain.name)) != label) {\r\n            // New listing\r\n            domain.name = name;\r\n        }\r\n\r\n        domain.minion = minion;\r\n        domain.moloch = IMinion(minion).moloch();\r\n\r\n        emit DomainConfigured(label, name, minion);\r\n    }\r\n\r\n    /** Move domain to a new registrar **/\r\n\r\n    /**\r\n     * @dev Migrates the domain to a new registrar.\r\n     * @param name The name of the domain to migrate.\r\n     */\r\n    function migrate(string memory name) public owner_only(keccak256(bytes(name))) {\r\n        require(stopped);\r\n        require(migration != address(0x0));\r\n\r\n        bytes32 label = keccak256(bytes(name));\r\n        Domain storage domain = domains[label];\r\n\r\n        Registrar(registrar).approve(migration, uint256(label));\r\n\r\n        MinionSubdomainRegistrar(migration).configureDomainFor(\r\n            domain.name,\r\n            domain.minion,\r\n            domain.owner\r\n        );\r\n\r\n        delete domains[label];\r\n\r\n        emit DomainTransferred(label, name);\r\n    }\r\n\r\n    /** Register a subdomain **/\r\n\r\n    /**\r\n     * @dev Registers a subdomain.\r\n     * @param label The label hash of the domain to register a subdomain of.\r\n     * @param subdomain The desired subdomain label.\r\n     * @param _subdomainOwner The account that should own the newly configured subdomain.\r\n     */\r\n    function register(bytes32 label, string calldata subdomain, address _subdomainOwner, address resolver) external not_stopped {\r\n        address subdomainOwner = _subdomainOwner;\r\n        bytes32 domainNode = keccak256(abi.encodePacked(TLD_NODE, label));\r\n        bytes32 subdomainLabel = keccak256(bytes(subdomain));\r\n\r\n        // Subdomain must not be registered already.\r\n        require(ens.owner(keccak256(abi.encodePacked(domainNode, subdomainLabel))) == address(0));\r\n\r\n        Domain storage domain = domains[label];\r\n\r\n        // Domain must be available for registration\r\n        require(keccak256(abi.encodePacked(domain.name)) == label);\r\n\r\n        // Use msg.sender if _subdomainOwner is not set\r\n        if (subdomainOwner == address(0x0)) {\r\n            subdomainOwner = msg.sender;\r\n        }\r\n\r\n        // Domain can only be registered by Minion or by members (and only for members)\r\n        if (msg.sender != domain.minion) {\r\n          // If msg.sender is not minion check that the msg.sender and new owner are members\r\n          ( , uint256 ownerStakes, , , , ) = IMoloch(domain.moloch).members(subdomainOwner);\r\n          ( , uint256 senderStakes, , , , ) = IMoloch(domain.moloch).members(msg.sender);\r\n          require(senderStakes > 0 && ownerStakes > 0);\r\n        }\r\n\r\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\r\n\r\n        emit NewRegistration(label, subdomain, subdomainOwner);\r\n    }\r\n\r\n    function deregister(bytes32 label, string calldata subdomain, address resolver) external {\r\n        bytes32 domainNode = keccak256(abi.encodePacked(TLD_NODE, label));\r\n        bytes32 subdomainLabel = keccak256(bytes(subdomain));\r\n        address subdomainOwner = ens.owner(keccak256(abi.encodePacked(domainNode, subdomainLabel)));\r\n\r\n        // Subdomain must be registered already.\r\n        require(subdomainOwner != address(0));\r\n\r\n        Domain storage domain = domains[label];\r\n\r\n        // Domain must be available for registration\r\n        require(keccak256(abi.encodePacked(domain.name)) == label);\r\n        // Domain can only be deregistered by domain's Minion or subdomain owner\r\n        require(msg.sender == domain.minion || msg.sender == subdomainOwner);\r\n\r\n        doRegistration(domainNode, subdomainLabel, address(0), Resolver(resolver));\r\n\r\n        emit NewRegistration(label, subdomain, address(0));\r\n    }\r\n\r\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\r\n        // Get the subdomain so we can configure it\r\n        ens.setSubnodeOwner(node, label, address(this));\r\n\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        // Set the subdomain's resolver\r\n        ens.setResolver(subnode, address(resolver));\r\n\r\n        // Set the address record on the resolver\r\n        resolver.setAddr(subnode, subdomainOwner);\r\n\r\n        // Pass ownership of the new subdomain to the registrant\r\n        ens.setOwner(subnode, subdomainOwner);\r\n    }\r\n\r\n    /** View **/\r\n\r\n    /**\r\n     * @dev owner returns the address of the account that controls a domain.\r\n     *      Initially this is a null address. If the name has been\r\n     *      transferred to this contract, then the internal mapping is consulted\r\n     *      to determine who controls it. If the owner is not set,\r\n     *      the owner of the domain in the Registrar is returned.\r\n     * @param label The label hash of the deed to check.\r\n     * @return The address owning the deed.\r\n     */\r\n    function owner(bytes32 label) public view returns (address) {\r\n        if (domains[label].owner != address(0x0)) {\r\n            return domains[label].owner;\r\n        }\r\n\r\n        return Registrar(registrar).ownerOf(uint256(label));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"_ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minion\",\"type\":\"address\"}],\"name\":\"DomainConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"DomainTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainUnlisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"TransferAddressSet\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"TLD_NODE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"minion\",\"type\":\"address\"}],\"name\":\"configureDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"minion\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"configureDomainFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"deregister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migration\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_subdomainOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrarOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migration\",\"type\":\"address\"}],\"name\":\"setMigrationAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"unlistDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MinionSubdomainRegistrar","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8a178fd0c6dd4aee48614ea6b2496db36a57b1fd6b2d703cad9948ec60812212"}]}