{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ProxyStorage is Ownable {\r\n    address internal proxyTo;\r\n}\r\n\r\n// File: contracts/common/misc/ERCProxy.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.5.2;\r\n\r\n// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\r\n\r\ninterface ERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId);\r\n    function implementation() external view returns (address codeAddr);\r\n}\r\n\r\n// File: contracts/common/misc/DelegateProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract DelegateProxy is ERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId) {\r\n        // Upgradeable proxy\r\n        proxyTypeId = 2;\r\n    }\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let result := delegatecall(\r\n                sub(gas, 10000),\r\n                _dst,\r\n                add(_calldata, 0x20),\r\n                mload(_calldata),\r\n                0,\r\n                0\r\n            )\r\n            let size := returndatasize\r\n\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/UpgradableProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract UpgradableProxy is DelegateProxy {\r\n    event ProxyUpdated(address indexed _new, address indexed _old);\r\n    event OwnerUpdate(address _new, address _old);\r\n\r\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(\"matic.network.proxy.implementation\");\r\n    bytes32 constant OWNER_SLOT = keccak256(\"matic.network.proxy.owner\");\r\n\r\n    constructor(address _proxyTo) public {\r\n        setOwner(msg.sender);\r\n        setImplementation(_proxyTo);\r\n    }\r\n\r\n    function() external payable {\r\n        // require(currentContract != 0, \"If app code has not been set yet, do not call\");\r\n        // Todo: filter out some calls or handle in the end fallback\r\n        delegatedFwd(loadImplementation(), msg.data);\r\n    }\r\n\r\n    modifier onlyProxyOwner() {\r\n        require(loadOwner() == msg.sender, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    function owner() external view returns(address) {\r\n        return loadOwner();\r\n    }\r\n\r\n    function loadOwner() internal view returns(address) {\r\n        address _owner;\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            _owner := sload(position)\r\n        }\r\n        return _owner;\r\n    }\r\n\r\n    function implementation() external view returns (address) {\r\n        return loadImplementation();\r\n    }\r\n\r\n    function loadImplementation() internal view returns(address) {\r\n        address _impl;\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            _impl := sload(position)\r\n        }\r\n        return _impl;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnerUpdate(newOwner, loadOwner());\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    function setOwner(address newOwner) private {\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            sstore(position, newOwner)\r\n        }\r\n    }\r\n\r\n    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\r\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\r\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\r\n\r\n        emit ProxyUpdated(_newProxyTo, loadImplementation());\r\n        \r\n        setImplementation(_newProxyTo);\r\n    }\r\n\r\n    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\r\n        updateImplementation(_newProxyTo);\r\n\r\n        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    function setImplementation(address _newProxyTo) private {\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            sstore(position, _newProxyTo)\r\n        }\r\n    }\r\n    \r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_target)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == address(governance),\r\n            \"Only governance contract is authorized\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShareProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ValidatorShareProxy is UpgradableProxy {\r\n    constructor(address _registry) public UpgradableProxy(_registry) {}\r\n\r\n    function loadImplementation() internal view returns (address) {\r\n        return Registry(super.loadImplementation()).getValidatorShareAddress();\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: contracts/common/tokens/ERC20NonTransferable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ERC20NonTransferable is ERC20 {\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        revert(\"Disabled\");\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/BytesLib.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(\r\n                        add(tempBytes, lengthmod),\r\n                        mul(0x20, iszero(lengthmod))\r\n                    )\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(\r\n                            add(\r\n                                add(_bytes, lengthmod),\r\n                                mul(0x20, iszero(lengthmod))\r\n                            ),\r\n                            _start\r\n                        )\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    // Pad a bytes array to 32 bytes\r\n    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        // may underflow if bytes.length < 32. Hence using SafeMath.sub\r\n        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\r\n        return concat(newBytes, _bytes);\r\n    }\r\n\r\n    function toBytes32(bytes memory b) internal pure returns (bytes32) {\r\n        require(b.length >= 32, \"Bytes array should atleast be 32 bytes\");\r\n        bytes32 out;\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            out |= bytes32(b[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\r\n        assembly {\r\n            result := mload(add(b, 32))\r\n        }\r\n    }\r\n\r\n    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\r\n        bytes memory b = new bytes(32);\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\r\n        }\r\n        return b;\r\n    }\r\n\r\n    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\r\n        _ret = new bytes(32);\r\n        assembly {\r\n            mstore(add(_ret, 32), _num)\r\n        }\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n        assembly {\r\n            tempAddress := div(\r\n                mload(add(add(_bytes, 0x20), _start)),\r\n                0x1000000000000000000000000\r\n            )\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/ECVerify.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary ECVerify {\r\n    function ecrecovery(bytes32 hash, bytes memory sig)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65) {\r\n            return address(0x0);\r\n        }\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0x0);\r\n        }\r\n\r\n        // get address out of hash and signature\r\n        address result = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(result != address(0x0));\r\n\r\n        return result;\r\n    }\r\n\r\n    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        // get address out of hash and signature\r\n        address result = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(result != address(0x0), \"signature verification failed\");\r\n\r\n        return result;\r\n    }\r\n\r\n    function ecverify(bytes32 hash, bytes memory sig, address signer)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return signer == ecrecovery(hash, sig);\r\n    }\r\n}\r\n\r\n// File: contracts/staking/StakingInfo.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// dummy interface to avoid cyclic dependency\r\ncontract IStakeManagerLocal {\r\n    enum Status {Inactive, Active, Locked, Unstaked}\r\n\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n        Status status;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n    bytes32 public accountStateRoot;\r\n    uint256 public activeAmount; // delegation amount from validator contract\r\n    uint256 public validatorRewards;\r\n\r\n    function currentValidatorSetTotalStake() public view returns (uint256);\r\n\r\n    // signer to Validator mapping\r\n    function signerToValidator(address validatorAddress)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function isValidator(uint256 validatorId) public view returns (bool);\r\n}\r\n\r\n\r\ncontract StakingInfo is Ownable {\r\n    using SafeMath for uint256;\r\n    mapping(uint256 => uint256) public validatorNonce;\r\n\r\n    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\r\n    /// @param signer validator address.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param activationEpoch validator's first epoch as proposer.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    /// @param signerPubkey public key of the validator\r\n    event Staked(\r\n        address indexed signer,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 indexed activationEpoch,\r\n        uint256 amount,\r\n        uint256 total,\r\n        bytes signerPubkey\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    event Unstaked(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in '_unstake()'.\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param deactivationEpoch last epoch for validator.\r\n    /// @param amount staking amount.\r\n    event UnstakeInit(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 deactivationEpoch,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param oldSigner old address of the validator.\r\n    /// @param newSigner new address of the validator.\r\n    /// @param signerPubkey public key of the validator.\r\n    event SignerChange(\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        address indexed oldSigner,\r\n        address indexed newSigner,\r\n        bytes signerPubkey\r\n    );\r\n    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\r\n    event Jailed(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed exitEpoch,\r\n        address indexed signer\r\n    );\r\n    event UnJailed(uint256 indexed validatorId, address indexed signer);\r\n    event Slashed(uint256 indexed nonce, uint256 indexed amount);\r\n    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\r\n    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\r\n    event ProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    );\r\n\r\n    event RewardUpdate(uint256 newReward, uint256 oldReward);\r\n\r\n    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param newAmount the updated stake amount.\r\n    event StakeUpdate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed nonce,\r\n        uint256 indexed newAmount\r\n    );\r\n    event ClaimRewards(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed totalAmount\r\n    );\r\n    event StartAuction(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed auctionAmount\r\n    );\r\n    event ConfirmAuction(\r\n        uint256 indexed newValidatorId,\r\n        uint256 indexed oldValidatorId,\r\n        uint256 indexed amount\r\n    );\r\n    event TopUpFee(address indexed user, uint256 indexed fee);\r\n    event ClaimFee(address indexed user, uint256 indexed fee);\r\n    // Delegator events\r\n    event ShareMinted(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event ShareBurned(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event DelegatorClaimedRewards(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed rewards\r\n    );\r\n    event DelegatorRestaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed totalStaked\r\n    );\r\n    event DelegatorUnstaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n    event UpdateCommissionRate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed newCommissionRate,\r\n        uint256 indexed oldCommissionRate\r\n    );\r\n\r\n    Registry public registry;\r\n\r\n    modifier onlyValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        require(_contract == msg.sender,\r\n        \"Invalid sender, not validator\");\r\n        _;\r\n    }\r\n\r\n    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        address _stakeManager = registry.getStakeManagerAddress();\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\r\n            validatorId\r\n        );\r\n        require(_contract == msg.sender || _stakeManager == msg.sender,\r\n        \"Invalid sender, not stake manager or validator contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStakeManager() {\r\n        require(registry.getStakeManagerAddress() == msg.sender,\r\n        \"Invalid sender, not stake manager\");\r\n        _;\r\n    }\r\n    modifier onlySlashingManager() {\r\n        require(registry.getSlashingManagerAddress() == msg.sender,\r\n        \"Invalid sender, not slashing manager\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n    }\r\n\r\n    function updateNonce(\r\n        uint256[] calldata validatorIds,\r\n        uint256[] calldata nonces\r\n    ) external onlyOwner {\r\n        require(validatorIds.length == nonces.length, \"args length mismatch\");\r\n\r\n        for (uint256 i = 0; i < validatorIds.length; ++i) {\r\n            validatorNonce[validatorIds[i]] = nonces[i];\r\n        }\r\n    } \r\n\r\n    function logStaked(\r\n        address signer,\r\n        bytes memory signerPubkey,\r\n        uint256 validatorId,\r\n        uint256 activationEpoch,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit Staked(\r\n            signer,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            activationEpoch,\r\n            amount,\r\n            total,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logUnstaked(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        emit Unstaked(user, validatorId, amount, total);\r\n    }\r\n\r\n    function logUnstakeInit(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 deactivationEpoch,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit UnstakeInit(\r\n            user,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            deactivationEpoch,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function logSignerChange(\r\n        uint256 validatorId,\r\n        address oldSigner,\r\n        address newSigner,\r\n        bytes memory signerPubkey\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit SignerChange(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            oldSigner,\r\n            newSigner,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Restaked(validatorId, amount, total);\r\n    }\r\n\r\n    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Jailed(validatorId, exitEpoch, signer);\r\n    }\r\n\r\n    function logUnjailed(uint256 validatorId, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit UnJailed(validatorId, signer);\r\n    }\r\n\r\n    function logSlashed(uint256 nonce, uint256 amount)\r\n        public\r\n        onlySlashingManager\r\n    {\r\n        emit Slashed(nonce, amount);\r\n    }\r\n\r\n    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit ThresholdChange(newThreshold, oldThreshold);\r\n    }\r\n\r\n    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit DynastyValueChange(newDynasty, oldDynasty);\r\n    }\r\n\r\n    function logProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    ) public onlyStakeManager {\r\n        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\r\n    }\r\n\r\n    function logRewardUpdate(uint256 newReward, uint256 oldReward)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit RewardUpdate(newReward, oldReward);\r\n    }\r\n\r\n    function logStakeUpdate(uint256 validatorId)\r\n        public\r\n        StakeManagerOrValidatorContract(validatorId)\r\n    {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit StakeUpdate(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            totalValidatorStake(validatorId)\r\n        );\r\n    }\r\n\r\n    function logClaimRewards(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 totalAmount\r\n    ) public onlyStakeManager {\r\n        emit ClaimRewards(validatorId, amount, totalAmount);\r\n    }\r\n\r\n    function logStartAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 auctionAmount\r\n    ) public onlyStakeManager {\r\n        emit StartAuction(validatorId, amount, auctionAmount);\r\n    }\r\n\r\n    function logConfirmAuction(\r\n        uint256 newValidatorId,\r\n        uint256 oldValidatorId,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\r\n    }\r\n\r\n    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit TopUpFee(user, fee);\r\n    }\r\n\r\n    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit ClaimFee(user, fee);\r\n    }\r\n\r\n    function getStakerDetails(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 reward,\r\n            uint256 activationEpoch,\r\n            uint256 deactivationEpoch,\r\n            address signer,\r\n            uint256 _status\r\n        )\r\n    {\r\n        IStakeManagerLocal stakeManager = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        );\r\n        address _contract;\r\n        IStakeManagerLocal.Status status;\r\n        (\r\n            amount,\r\n            reward,\r\n            activationEpoch,\r\n            deactivationEpoch,\r\n            ,\r\n            signer,\r\n            _contract,\r\n            status\r\n        ) = stakeManager.validators(validatorId);\r\n        _status = uint256(status);\r\n        if (_contract != address(0x0)) {\r\n            reward += IStakeManagerLocal(_contract).validatorRewards();\r\n        }\r\n    }\r\n\r\n    function totalValidatorStake(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (uint256 validatorStake)\r\n    {\r\n        address contractAddress;\r\n        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        if (contractAddress != address(0x0)) {\r\n            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\r\n        }\r\n    }\r\n\r\n    function getAccountStateRoot()\r\n        public\r\n        view\r\n        returns (bytes32 accountStateRoot)\r\n    {\r\n        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\r\n            .accountStateRoot();\r\n    }\r\n\r\n    function getValidatorContractAddress(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (address ValidatorContract)\r\n    {\r\n        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n    }\r\n\r\n    // validator Share contract logging func\r\n    function logShareMinted(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareMinted(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logShareBurned(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareBurned(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logDelegatorClaimRewards(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 rewards\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorClaimedRewards(validatorId, user, rewards);\r\n    }\r\n\r\n    function logDelegatorRestaked(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 totalStaked\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorRestaked(validatorId, user, totalStaked);\r\n    }\r\n\r\n    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\r\n        public\r\n        onlyValidatorContract(validatorId)\r\n    {\r\n        emit DelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    function logUpdateCommissionRate(\r\n        uint256 validatorId,\r\n        uint256 newCommissionRate,\r\n        uint256 oldCommissionRate\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit UpdateCommissionRate(\r\n            validatorId,\r\n            newCommissionRate,\r\n            oldCommissionRate\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Lockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Lockable {\r\n    bool public locked;\r\n\r\n    modifier onlyWhenUnlocked() {\r\n        _assertUnlocked();\r\n        _;\r\n    }\r\n\r\n    function _assertUnlocked() private view {\r\n        require(!locked, \"locked\");\r\n    }\r\n\r\n    function lock() public {\r\n        locked = true;\r\n    }\r\n\r\n    function unlock() public {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/OwnableLockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract OwnableLockable is Lockable, Ownable {\r\n    function lock() public onlyOwner {\r\n        super.lock();\r\n    }\r\n\r\n    function unlock() public onlyOwner {\r\n        super.unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function stake(\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        bytes memory sigs\r\n    ) public returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes memory slashingInfoList) public returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/staking/validatorShare/IValidatorShare.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n// note this contract interface is only for stakeManager use\r\ncontract IValidatorShare {\r\n    function withdrawRewardsValidator() external returns (uint256);\r\n\r\n    function addProposerBonus(uint256 _rewards, uint256 valStake) public;\r\n\r\n    function withdrawRewards() public;\r\n\r\n    function unstakeClaimTokens() public;\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256);\r\n    \r\n    function getActiveAmount() external view returns (uint256);\r\n\r\n    function owner() public view returns (address);\r\n\r\n    function restake() public;\r\n\r\n    function updateRewards(\r\n        uint256 _reward,\r\n        uint256 _totalStake,\r\n        uint256 validatorStake\r\n    ) external returns (uint256);\r\n\r\n    function unlockContract() external returns (uint256);\r\n\r\n    function lockContract() external returns (uint256);\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function slash(uint256 valPow, uint256 totalAmountToSlash) external returns (uint256);\r\n\r\n    function updateDelegation(bool delegation) external;\r\n}\r\n\r\n// File: contracts/common/mixin/Initializable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Initializable {\r\n    bool inited = false;\r\n\r\n    modifier initializer() {\r\n        require(!inited, \"already inited\");\r\n        inited = true;\r\n        \r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShare.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ValidatorShare is IValidatorShare, ERC20NonTransferable, OwnableLockable, Initializable {\r\n    struct Delegator {\r\n        uint256 shares;\r\n        uint256 withdrawEpoch;\r\n    }\r\n\r\n    uint256 constant EXCHANGE_RATE_PRECISION = 100;\r\n    uint256 constant MAX_COMMISION_RATE = 100;\r\n    uint256 constant REWARD_PRECISION = 10**25;\r\n\r\n    StakingInfo public stakingLogger;\r\n    IStakeManager public stakeManager;\r\n    uint256 public validatorId;\r\n    uint256 public validatorRewards;\r\n    uint256 public commissionRate;\r\n    //last checkpoint where validator updated commission rate\r\n    uint256 public lastCommissionUpdate;\r\n    uint256 public minAmount = 10**18;\r\n\r\n    uint256 public totalStake;\r\n    uint256 public rewardPerShare;\r\n    uint256 public activeAmount;\r\n    bool public delegation = true;\r\n\r\n    uint256 public withdrawPool;\r\n    uint256 public withdrawShares;\r\n\r\n    mapping(address => uint256) public amountStaked;\r\n    mapping(address => Delegator) public delegators;\r\n    mapping(address => uint256) public initalRewardPerShare;\r\n\r\n    modifier onlyValidator() {\r\n        require(stakeManager.ownerOf(validatorId) == msg.sender, \"not validator\");\r\n        _;\r\n    }\r\n\r\n    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\r\n    function initialize(uint256 _validatorId, address _stakingLogger, address _stakeManager) external initializer  {\r\n        validatorId = _validatorId;\r\n        stakingLogger = StakingInfo(_stakingLogger);\r\n        stakeManager = IStakeManager(_stakeManager);\r\n        _transferOwnership(_stakeManager);\r\n\r\n        minAmount = 10**18;\r\n        delegation = true;\r\n    }\r\n\r\n    function updateCommissionRate(uint256 newCommissionRate) external onlyValidator {\r\n        uint256 epoch = stakeManager.epoch();\r\n        uint256 _lastCommissionUpdate = lastCommissionUpdate;\r\n\r\n        require( // withdrawalDelay == dynasty\r\n            (_lastCommissionUpdate.add(stakeManager.withdrawalDelay()) <= epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate\r\n            \"Commission rate update cooldown period\"\r\n        );\r\n\r\n        require(newCommissionRate <= MAX_COMMISION_RATE, \"Commission rate should be in range of 0-100\");\r\n        stakingLogger.logUpdateCommissionRate(validatorId, newCommissionRate, commissionRate);\r\n        commissionRate = newCommissionRate;\r\n        lastCommissionUpdate = epoch;\r\n    }\r\n\r\n    function updateRewards(uint256 reward, uint256 checkpointStakePower, uint256 validatorStake)\r\n        external\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        /**\r\n        restaking is simply buying more shares of pool\r\n        but those needs to be nonswapable/transferrable(to prevent https://en.wikipedia.org/wiki/Tragedy_of_the_commons)\r\n\r\n        - calculate rewards for validator stake + delgation\r\n        - keep the validator rewards aside\r\n        - take the commission out\r\n        - add rewards to pool rewards\r\n        - returns total active stake for validator\r\n        */\r\n        uint256 combinedStakePower = validatorStake.add(activeAmount); // validator + delegation stake power\r\n        uint256 rewards = combinedStakePower.mul(reward).div(checkpointStakePower);\r\n\r\n        _updateRewards(rewards, validatorStake, combinedStakePower);\r\n        return combinedStakePower;\r\n    }\r\n\r\n    function addProposerBonus(uint256 rewards, uint256 validatorStake) public onlyOwner {\r\n        uint256 combinedStakePower = validatorStake.add(activeAmount);\r\n        _updateRewards(rewards, validatorStake, combinedStakePower);\r\n    }\r\n\r\n    function _updateRewards(uint256 rewards, uint256 validatorStake, uint256 combinedStakePower) internal {\r\n        uint256 _validatorRewards = validatorStake.mul(rewards).div(combinedStakePower);\r\n\r\n        // add validator commission from delegation rewards\r\n        if (commissionRate > 0) {\r\n            _validatorRewards = _validatorRewards.add(\r\n                rewards.sub(_validatorRewards).mul(commissionRate).div(MAX_COMMISION_RATE)\r\n            );\r\n        }\r\n\r\n        validatorRewards = validatorRewards.add(_validatorRewards);\r\n\r\n        uint256 delegatorsRewards = rewards.sub(_validatorRewards);\r\n        uint256 totalShares = totalSupply();\r\n        if (totalShares > 0) {\r\n            rewardPerShare = rewardPerShare.add(\r\n                delegatorsRewards.mul(REWARD_PRECISION).div(totalShares)\r\n            );\r\n        }\r\n    }\r\n\r\n    function withdrawRewardsValidator() external onlyOwner returns (uint256) {\r\n        uint256 _validatorRewards = validatorRewards;\r\n        validatorRewards = 0;\r\n        return _validatorRewards;\r\n    }\r\n\r\n    function exchangeRate() public view returns (uint256) {\r\n        uint256 totalShares = totalSupply();\r\n        return\r\n            totalShares == 0\r\n                ? EXCHANGE_RATE_PRECISION\r\n                : activeAmount.mul(EXCHANGE_RATE_PRECISION).div(totalShares);\r\n    }\r\n\r\n    function withdrawExchangeRate() public view returns (uint256) {\r\n        uint256 _withdrawShares = withdrawShares;\r\n        return\r\n            _withdrawShares == 0\r\n                ? EXCHANGE_RATE_PRECISION\r\n                : withdrawPool.mul(EXCHANGE_RATE_PRECISION).div(_withdrawShares);\r\n    }\r\n\r\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public {\r\n        _withdrawAndTransferReward();\r\n        uint256 amountToDeposit = _buyShares(_amount, _minSharesToMint);\r\n        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), \"deposit failed\");\r\n    }\r\n\r\n    function restake() public {\r\n        uint256 liquidReward = _withdrawReward(msg.sender);\r\n        require(liquidReward >= minAmount, \"Too small rewards to restake\");\r\n\r\n        _buyShares(liquidReward, 0);\r\n\r\n        stakingLogger.logDelegatorRestaked(validatorId, msg.sender, amountStaked[msg.sender]);\r\n    }\r\n\r\n    function _buyShares(uint256 _amount, uint256 _minSharesToMint) private onlyWhenUnlocked returns(uint256) {\r\n        require(delegation, \"Delegation is disabled\");\r\n\r\n        uint256 rate = exchangeRate();\r\n        uint256 shares = _amount.mul(EXCHANGE_RATE_PRECISION).div(rate);\r\n        require(shares >= _minSharesToMint, \"Too much slippage\");\r\n        require(delegators[msg.sender].shares == 0, \"Ongoing exit\");\r\n\r\n        _mint(msg.sender, shares);\r\n\r\n        _amount = _amount.sub(_amount % rate.mul(shares).div(EXCHANGE_RATE_PRECISION));\r\n\r\n        totalStake = totalStake.add(_amount);\r\n        amountStaked[msg.sender] = amountStaked[msg.sender].add(_amount);\r\n\r\n        activeAmount = activeAmount.add(_amount);\r\n        stakeManager.updateValidatorState(validatorId, int256(_amount));\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareMinted(validatorId, msg.sender, _amount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function sellVoucher(uint256 _minClaimAmount) public {\r\n        uint256 shares = balanceOf(msg.sender);\r\n        require(shares > 0, \"Zero balance\");\r\n\r\n        uint256 rate = exchangeRate();\r\n        uint256 _amount = rate.mul(shares).div(EXCHANGE_RATE_PRECISION);\r\n        require(_amount >= _minClaimAmount, \"Too much slippage\");\r\n\r\n        _withdrawAndTransferReward();\r\n        _burn(msg.sender, shares);\r\n        stakeManager.updateValidatorState(validatorId, -int256(_amount));\r\n\r\n        activeAmount = activeAmount.sub(_amount);\r\n        uint256 _withdrawPoolShare = _amount.mul(EXCHANGE_RATE_PRECISION).div(withdrawExchangeRate());\r\n\r\n        withdrawPool = withdrawPool.add(_amount);\r\n        withdrawShares = withdrawShares.add(_withdrawPoolShare);\r\n        delegators[msg.sender] = Delegator({shares: _withdrawPoolShare, withdrawEpoch: stakeManager.epoch()});\r\n        amountStaked[msg.sender] = 0;\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareBurned(validatorId, msg.sender, _amount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function _withdrawReward(address user) private returns(uint256) {\r\n        uint256 liquidRewards = getLiquidRewards(user);\r\n        initalRewardPerShare[user] = rewardPerShare;\r\n        return liquidRewards;\r\n    }\r\n\r\n    function _withdrawAndTransferReward() private returns(uint256) {\r\n        uint256 liquidRewards = _withdrawReward(msg.sender);\r\n        if (liquidRewards > 0) {\r\n            require(stakeManager.transferFunds(validatorId, liquidRewards, msg.sender), \"Insufficent rewards\");\r\n            stakingLogger.logDelegatorClaimRewards(validatorId, msg.sender, liquidRewards);\r\n        }\r\n        return liquidRewards;\r\n    }\r\n\r\n    function withdrawRewards() public {\r\n        uint256 rewards = _withdrawAndTransferReward();\r\n        require(rewards >= minAmount, \"Too small rewards amount\");\r\n    }\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256) {\r\n        uint256 shares = balanceOf(user);\r\n        if (shares == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return rewardPerShare.sub(initalRewardPerShare[user]).mul(shares).div(REWARD_PRECISION);\r\n    }\r\n\r\n    function unstakeClaimTokens() public {\r\n        Delegator storage delegator = delegators[msg.sender];\r\n\r\n        uint256 shares = delegator.shares;\r\n        require(\r\n            delegator.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\r\n            \"Incomplete withdrawal period\"\r\n        );\r\n\r\n        uint256 _amount = withdrawExchangeRate().mul(shares).div(EXCHANGE_RATE_PRECISION);\r\n        withdrawShares = withdrawShares.sub(shares);\r\n        withdrawPool = withdrawPool.sub(_amount);\r\n\r\n        totalStake = totalStake.sub(_amount);\r\n\r\n        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), \"Insufficent rewards\");\r\n        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, _amount);\r\n        delete delegators[msg.sender];\r\n    }\r\n\r\n    function slash(uint256 valPow, uint256 totalAmountToSlash) external onlyOwner returns (uint256) {\r\n        uint256 _withdrawPool = withdrawPool;\r\n        uint256 delegationAmount = activeAmount.add(_withdrawPool);\r\n        if (delegationAmount == 0) {\r\n            return 0;\r\n        }\r\n        // total amount to be slashed from delegation pool (active + inactive)\r\n        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(valPow.add(delegationAmount));\r\n        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\r\n\r\n        // slash inactive pool\r\n        withdrawPool = _withdrawPool.sub(_amountToSlashWithdrawalPool);\r\n        activeAmount = activeAmount.sub(_amountToSlash.sub(_amountToSlashWithdrawalPool));\r\n        return _amountToSlash;\r\n    }\r\n\r\n    function updateDelegation(bool _delegation) external onlyOwner {\r\n        delegation = _delegation;\r\n    }\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        if (token == address(0x0)) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(destination, amount), \"Drain failed\");\r\n        }\r\n    }\r\n\r\n    function getActiveAmount() external view returns(uint256) {\r\n        return activeAmount;\r\n    }\r\n\r\n    function unlockContract() external onlyOwner returns (uint256) {\r\n        unlock();\r\n        return activeAmount;\r\n    }\r\n\r\n    function lockContract() external onlyOwner returns (uint256) {\r\n        lock();\r\n        return activeAmount;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShareFactory.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ValidatorShareFactory {\r\n    /**\r\n    - factory to create new validatorShare contracts\r\n   */\r\n    function create(uint256 validatorId, address loggerAddress, address registry) public returns (address) {\r\n        ValidatorShareProxy proxy = new ValidatorShareProxy(registry);\r\n\r\n        proxy.transferOwnership(msg.sender);\r\n\r\n        address proxyAddr = address(proxy);\r\n        (bool success, bytes memory data) = proxyAddr.call.gas(gasleft())(\r\n            abi.encodeWithSelector(\r\n                ValidatorShare(proxyAddr).initialize.selector, \r\n                validatorId, \r\n                loggerAddress, \r\n                msg.sender\r\n            )\r\n        );\r\n        require(success, string(data));\r\n\r\n        return proxyAddr;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"loggerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ValidatorShareFactory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0bfaa3cbd55896115b097dcb624663a0433d5ee69487e6ea3020a610a3cb8b10"}]}