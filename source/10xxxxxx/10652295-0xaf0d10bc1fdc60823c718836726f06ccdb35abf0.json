{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.0;\r\n// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n * Copyright Â© 2017-2019 Ramp Network sp. z o.o. All rights reserved (MIT License).\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\r\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\r\n * is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies\r\n * or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\r\n * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\n/**\r\n * A standard, simple transferrable contract ownership.\r\n */\r\nabstract contract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"ooc\");  // \"only the owner can call this\"\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnerChanged(msg.sender, _newOwner);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * A contract that can be stopped/restarted by its owner.\r\n */\r\nabstract contract Stoppable is Ownable {\r\n\r\n    bool public isActive = true;\r\n\r\n    event IsActiveChanged(bool _isActive);\r\n\r\n    modifier onlyActive() {\r\n        require(isActive, \"stp\");  // \"contract is stopped\"\r\n        _;\r\n    }\r\n\r\n    function setIsActive(bool _isActive) external onlyOwner {\r\n        if (_isActive == isActive) return;\r\n        isActive = _isActive;\r\n        emit IsActiveChanged(_isActive);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * A simple interface used by the escrows contract (precisely AssetAdapters) to interact\r\n * with the liquidity pools.\r\n */\r\nabstract contract RampInstantPoolInterface {\r\n\r\n    uint16 public ASSET_TYPE;  // solhint-disable-line var-name-mixedcase\r\n\r\n    function sendFundsToSwap(uint256 _amount)\r\n        public virtual /*onlyActive onlySwapsContract isWithinLimits*/ returns(bool success);\r\n\r\n}\r\n\r\nabstract contract RampInstantTokenPoolInterface is RampInstantPoolInterface {\r\n\r\n    address public token;\r\n\r\n}\r\n\r\n/**\r\n * An interface of the RampInstantEscrows functions that are used by the liquidity pool contracts.\r\n * See RampInstantEscrows.sol for more comments.\r\n */\r\nabstract contract RampInstantEscrowsPoolInterface {\r\n\r\n    uint16 public ASSET_TYPE;  // solhint-disable-line var-name-mixedcase\r\n\r\n    function release(\r\n        address _pool,\r\n        address payable _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    )\r\n        external virtual; /*statusAtLeast(Status.FINALIZE_ONLY) onlyOracleOrPool(_pool, _oracle)*/\r\n\r\n    function returnFunds(\r\n        address payable _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    )\r\n        external virtual; /*statusAtLeast(Status.RETURN_ONLY) onlyOracleOrPool(_pool, _oracle)*/\r\n\r\n}\r\n\r\n/**\r\n * An abstract Ramp Instant Liquidity Pool. A liquidity provider deploys an instance of this\r\n * contract, and sends his funds to it. The escrows contract later withdraws portions of these\r\n * funds to be locked. The owner can withdraw any part of the funds at any time, or temporarily\r\n * block creating new escrows by stopping the contract.\r\n *\r\n * The pool owner can set and update min/max swap amounts, with an upper limit of 2^240 wei/units\r\n * (see `AssetAdapterWithFees` for more info).\r\n *\r\n * The paymentDetailsHash parameters works the same as in the `RampInstantEscrows` contract, only\r\n * with 0 value and empty transfer title. It describes the bank account where the pool owner expects\r\n * to be paid, and can be used to validate that a created swap indeed uses the same account.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\nabstract contract RampInstantPool is Ownable, Stoppable, RampInstantPoolInterface {\r\n\r\n    uint256 constant private MAX_SWAP_AMOUNT_LIMIT = 1 << 240;\r\n\r\n    address payable public swapsContract;\r\n    uint256 public minSwapAmount;\r\n    uint256 public maxSwapAmount;\r\n    bytes32 public paymentDetailsHash;\r\n\r\n    event LimitsChanged(uint256 _minAmount, uint256 _maxAmount);\r\n    event SwapsContractChanged(address _oldAddress, address _newAddress);\r\n\r\n    constructor(\r\n        address payable _swapsContract,\r\n        uint256 _minSwapAmount,\r\n        uint256 _maxSwapAmount,\r\n        bytes32 _paymentDetailsHash,\r\n        uint16 _assetType\r\n    )\r\n        validateLimits(_minSwapAmount, _maxSwapAmount)\r\n        validateSwapsContract(_swapsContract, _assetType)\r\n    {\r\n        swapsContract = _swapsContract;\r\n        paymentDetailsHash = _paymentDetailsHash;\r\n        minSwapAmount = _minSwapAmount;\r\n        maxSwapAmount = _maxSwapAmount;\r\n        ASSET_TYPE = _assetType;\r\n    }\r\n\r\n    function availableFunds() public virtual view returns (uint256);\r\n\r\n    function withdrawFunds(address payable _to, uint256 _amount)\r\n        public virtual /*onlyOwner*/ returns (bool success);\r\n\r\n    function withdrawAllFunds(address payable _to) public virtual onlyOwner returns (bool success) {\r\n        return withdrawFunds(_to, availableFunds());\r\n    }\r\n\r\n    function setLimits(\r\n        uint256 _minAmount,\r\n        uint256 _maxAmount\r\n    ) public onlyOwner validateLimits(_minAmount, _maxAmount) {\r\n        minSwapAmount = _minAmount;\r\n        maxSwapAmount = _maxAmount;\r\n        emit LimitsChanged(_minAmount, _maxAmount);\r\n    }\r\n\r\n    function setSwapsContract(\r\n        address payable _swapsContract\r\n    ) public onlyOwner validateSwapsContract(_swapsContract, ASSET_TYPE) {\r\n        address oldSwapsContract = swapsContract;\r\n        swapsContract = _swapsContract;\r\n        emit SwapsContractChanged(oldSwapsContract, _swapsContract);\r\n    }\r\n\r\n    function sendFundsToSwap(uint256 _amount)\r\n        public virtual override /*onlyActive onlySwapsContract isWithinLimits*/\r\n        returns(bool success);\r\n\r\n    function releaseSwap(\r\n        address payable _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external onlyOwner {\r\n        RampInstantEscrowsPoolInterface(swapsContract).release(\r\n            payable(address(this)),\r\n            _receiver,\r\n            _oracle,\r\n            _assetData,\r\n            _paymentDetailsHash\r\n        );\r\n    }\r\n\r\n    function returnSwap(\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external onlyOwner {\r\n        RampInstantEscrowsPoolInterface(swapsContract).returnFunds(\r\n            payable(address(this)),\r\n            _receiver,\r\n            _oracle,\r\n            _assetData,\r\n            _paymentDetailsHash\r\n        );\r\n    }\r\n\r\n    modifier onlySwapsContract() {\r\n        require(msg.sender == swapsContract, \"scc\");  // \"only the swaps contract can call this\"\r\n        _;\r\n    }\r\n\r\n    modifier isWithinLimits(uint256 _amount) {\r\n        // \"amount outside limits\"\r\n        require(_amount >= minSwapAmount && _amount <= maxSwapAmount, \"lim\");\r\n        _;\r\n    }\r\n\r\n    modifier validateLimits(uint256 _minAmount, uint256 _maxAmount) {\r\n        require(_minAmount <= _maxAmount, \"vl1\");  // \"min limit over max limit\"\r\n        require(_maxAmount <= MAX_SWAP_AMOUNT_LIMIT, \"vl2\");  // \"maxAmount too high\"\r\n        _;\r\n    }\r\n\r\n    modifier validateSwapsContract(address payable _swapsContract, uint16 _assetType) {\r\n        require(_swapsContract != address(0), \"nsc\");  // \"null swaps contract address\"\r\n        require(\r\n            RampInstantEscrowsPoolInterface(_swapsContract).ASSET_TYPE() == _assetType,\r\n            \"pat\"  // \"pool asset type doesn't match swap contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title partial ERC-20 Token interface according to official documentation:\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n */\r\ninterface Erc20Token {\r\n\r\n    /**\r\n     * Send `_value` of tokens from `msg.sender` to `_to`\r\n     *\r\n     * @param _to The recipient address\r\n     * @param _value The amount of tokens to be transferred\r\n     * @return success Indication if the transfer was successful\r\n     */\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * Approve `_spender` to withdraw from sender's account multiple times, up to `_value`\r\n     * amount. If this function is called again it overwrites the current allowance with _value.\r\n     *\r\n     * @param _spender The address allowed to operate on sender's tokens\r\n     * @param _value The amount of tokens allowed to be transferred\r\n     * @return success Indication if the approval was successful\r\n     */\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * Transfer tokens on behalf of `_from`, provided it was previously approved.\r\n     *\r\n     * @param _from The transfer source address (tokens owner)\r\n     * @param _to The transfer destination address\r\n     * @param _value The amount of tokens to be transferred\r\n     * @return success Indication if the approval was successful\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    /**\r\n     * Returns the account balance of another account with address `_owner`.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// OPTIONAL in the standard\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n}\r\n\r\n/**\r\n * @dev a wrapper to call token.transfer, that allows us to be compatible with older tokens\r\n * that don't comply with the ERC-20 interface and don't return anything\r\n */\r\nabstract contract TokenTransferrer {\r\n\r\n    function doTokenTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (bool success) {\r\n        // selector is bytes4(keccak256(\"transfer(address,uint256)\"))\r\n        bytes memory callData = abi.encodeWithSelector(bytes4(0xa9059cbb), _to, _amount);\r\n        // overwrite callData with call results (either the revert reason or return value)\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (success, callData) = _token.call(callData);\r\n        // if call failed, revert with the same error (also works with plain revert())\r\n        require(success, string(callData));\r\n        // if the call succeeded, check its result data:\r\n        // * when no data is returned, assume the token reverts on failure, so the\r\n        //   transfer was successful\r\n        // * otherwise check the call returned a single nonzero word\r\n        //   (the value at callData is the offset to the first data byte, hence the add+mload)\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            success := or(\r\n                iszero(returndatasize()),\r\n                and(eq(returndatasize(), 32), gt(mload(add(callData, mload(callData))), 0))\r\n            )\r\n        }\r\n        require(success, \"ttf\");  // \"token transfer failed\"\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * A pool that implements handling of ERC-20-compatible token assets. See `RampInstantPool`.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract RampInstantTokenPool is RampInstantPool, TokenTransferrer {\r\n\r\n    uint16 internal constant TOKEN_TYPE_ID = 2;\r\n    Erc20Token public token;\r\n\r\n    constructor(\r\n        address payable _swapsContract,\r\n        uint256 _minSwapAmount,\r\n        uint256 _maxSwapAmount,\r\n        bytes32 _paymentDetailsHash,\r\n        address _tokenAddress\r\n    )\r\n        RampInstantPool(\r\n            _swapsContract, _minSwapAmount, _maxSwapAmount, _paymentDetailsHash, TOKEN_TYPE_ID\r\n        )\r\n    {\r\n        token = Erc20Token(_tokenAddress);\r\n    }\r\n\r\n    function availableFunds() public override view returns(uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function withdrawFunds(\r\n        address payable _to,\r\n        uint256 _amount\r\n    ) public override onlyOwner returns (bool success) {\r\n        return doTokenTransfer(address(token), _to, _amount);\r\n    }\r\n\r\n    function sendFundsToSwap(\r\n        uint256 _amount\r\n    ) public override onlyActive onlySwapsContract isWithinLimits(_amount) returns(bool success) {\r\n        return doTokenTransfer(address(token), swapsContract, _amount);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_swapsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minSwapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSwapAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"IsActiveChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"LimitsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"SwapsContractChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ASSET_TYPE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentDetailsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_assetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"releaseSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_assetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"returnSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendFundsToSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setIsActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_swapsContract\",\"type\":\"address\"}],\"name\":\"setSwapsContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapsContract\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract Erc20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawAllFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RampInstantTokenPool","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"420","ConstructorArguments":"00000000000000000000000054e1eb00b7978314d33e0dbb113e745eddd18ffe00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000069e10de76676d080000050e7a8f73570881293c81d5d9746a7f4fa42177b05ecb51396d5be254708eacf000000000000000000000000e3818504c1b32bf1557b16c238b2e01fd3149c17","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1fda1f975b4e5218ecca75ed830cad90dfd275ec70f4a5dc64574791b2a1d406"}]}