{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface iERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address, uint) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ninterface iBASE {\r\n    function secondsPerEra() external view returns (uint);\r\n    // function DAO() external view returns (iDAO);\r\n}\r\ninterface iUTILS {\r\n    function calcPart(uint bp, uint total) external pure returns (uint part);\r\n    function calcShare(uint part, uint total, uint amount) external pure returns (uint share);\r\n    function calcSwapOutput(uint x, uint X, uint Y) external pure returns (uint output);\r\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output);\r\n    function calcStakeUnits(uint a, uint A, uint v, uint S) external pure returns (uint units);\r\n    // function calcAsymmetricShare(uint s, uint T, uint A) external pure returns (uint share);\r\n    // function getPoolAge(address token) external view returns(uint age);\r\n    function getPoolShare(address token, uint units) external view returns(uint baseAmt, uint tokenAmt);\r\n    function getPoolShareAssym(address token, uint units, bool toBase) external view returns(uint baseAmt, uint tokenAmt, uint outputAmt);\r\n    function calcValueInBase(address token, uint amount) external view returns (uint value);\r\n    function calcValueInToken(address token, uint amount) external view returns (uint value);\r\n    function calcValueInBaseWithPool(address payable pool, uint amount) external view returns (uint value);\r\n}\r\ninterface iDAO {\r\n    function ROUTER() external view returns(address);\r\n    function UTILS() external view returns(iUTILS);\r\n    function FUNDS_CAP() external view returns(uint);\r\n}\r\n\r\n// SafeMath\r\nlibrary SafeMath {\r\n\r\n    function add(uint a, uint b) internal pure returns (uint)   {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Pool_Vether is iERC20 {\r\n    using SafeMath for uint;\r\n\r\n    address public BASE;\r\n    address public TOKEN;\r\n    iDAO public DAO;\r\n\r\n    uint public one = 10**18;\r\n\r\n    // ERC-20 Parameters\r\n    string _name; string _symbol;\r\n    uint public override decimals; uint public override totalSupply;\r\n    // ERC-20 Mappings\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint public genesis;\r\n    uint public baseAmt;\r\n    uint public tokenAmt;\r\n    uint public baseAmtStaked;\r\n    uint public tokenAmtStaked;\r\n    uint public fees;\r\n    uint public volume;\r\n    uint public txCount;\r\n    \r\n    // Only Router can execute\r\n    modifier onlyRouter() {\r\n        _isRouter();\r\n        _;\r\n    }\r\n\r\n    function _isRouter() internal view {\r\n        require(msg.sender == _DAO().ROUTER(), \"RouterErr\");\r\n    }\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return DAO;\r\n    }\r\n\r\n    constructor (address _base, address _token, iDAO _dao) public payable {\r\n\r\n        BASE = _base;\r\n        TOKEN = _token;\r\n        DAO = _dao;\r\n\r\n        string memory poolName = \"VetherPoolV1-\";\r\n        string memory poolSymbol = \"VPT1-\";\r\n\r\n        if(_token == address(0)){\r\n            _name = string(abi.encodePacked(poolName, \"Ethereum\"));\r\n            _symbol = string(abi.encodePacked(poolSymbol, \"ETH\"));\r\n        } else {\r\n            _name = string(abi.encodePacked(poolName, iERC20(_token).name()));\r\n            _symbol = string(abi.encodePacked(poolSymbol, iERC20(_token).symbol()));\r\n        }\r\n        \r\n        decimals = 18;\r\n        genesis = now;\r\n    }\r\n\r\n    function _checkApprovals() external onlyRouter{\r\n        if(iERC20(BASE).allowance(address(this), _DAO().ROUTER()) == 0){\r\n            if(TOKEN != address(0)){\r\n                iERC20(TOKEN).approve(_DAO().ROUTER(), (2**256)-1);\r\n            }\r\n        iERC20(BASE).approve(_DAO().ROUTER(), (2**256)-1);\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    //========================================iERC20=========================================//\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    // iERC20 Transfer function\r\n    function transfer(address to, uint value) public override returns (bool success) {\r\n        __transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n    // iERC20 Approve function\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        __approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function __approve(address owner, address spender, uint256 amount) internal virtual {\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    // iERC20 TransferFrom function\r\n    function transferFrom(address from, address to, uint value) public override returns (bool success) {\r\n        require(value <= _allowances[from][msg.sender], 'AllowanceErr');\r\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\r\n        __transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    // Internal transfer function\r\n    function __transfer(address _from, address _to, uint _value) private {\r\n        require(_balances[_from] >= _value, 'BalanceErr');\r\n        require(_balances[_to] + _value >= _balances[_to], 'BalanceErr');\r\n        _balances[_from] =_balances[_from].sub(_value);\r\n        _balances[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    // Router can mint\r\n    function _mint(address account, uint256 amount) external onlyRouter {\r\n        totalSupply = totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        _allowances[account][DAO.ROUTER()] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n    // Burn supply\r\n    function burn(uint256 amount) public virtual {\r\n        __burn(msg.sender, amount);\r\n    }\r\n    function burnFrom(address from, uint256 value) public virtual {\r\n        require(value <= _allowances[from][msg.sender], 'AllowanceErr');\r\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\r\n        __burn(from, value);\r\n    }\r\n    function __burn(address account, uint256 amount) internal virtual {\r\n        _balances[account] = _balances[account].sub(amount, \"BalanceErr\");\r\n        totalSupply = totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n\r\n    //==================================================================================//\r\n    // Extended Asset Functions\r\n\r\n    // TransferTo function\r\n    function transferTo(address recipient, uint256 amount) public returns (bool) {\r\n        __transfer(tx.origin, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    // ETH Transfer function\r\n    function transferETH(address payable to, uint value) public payable onlyRouter returns (bool success) {\r\n        to.call{value:value}(\"\"); \r\n        return true;\r\n    }\r\n\r\n    function sync() public {\r\n        if (TOKEN == address(0)) {\r\n            tokenAmt = address(this).balance;\r\n        } else {\r\n            tokenAmt = iERC20(TOKEN).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function add(address token, uint amount) public payable returns (bool success) {\r\n        if(token == BASE){\r\n            iERC20(BASE).transferFrom(msg.sender, address(this), amount);\r\n            baseAmt = baseAmt.add(amount);\r\n            return true;\r\n        } else if (token == TOKEN){\r\n            iERC20(TOKEN).transferFrom(msg.sender, address(this), amount);\r\n            tokenAmt = tokenAmt.add(amount); \r\n            return true;\r\n        } else if (token == address(0)){\r\n            require((amount == msg.value), \"InputErr\");\r\n            tokenAmt = tokenAmt.add(amount); \r\n        } else {\r\n            return false;\r\n        }\r\n    } \r\n\r\n    //==================================================================================//\r\n    // Data Model\r\n    function _incrementPoolBalances(uint _baseAmt, uint _tokenAmt)  external onlyRouter  {\r\n        baseAmt += _baseAmt;\r\n        tokenAmt += _tokenAmt;\r\n        baseAmtStaked += _baseAmt;\r\n        tokenAmtStaked += _tokenAmt; \r\n    }\r\n    function _setPoolBalances(uint _baseAmt, uint _tokenAmt, uint _baseAmtStaked, uint _tokenAmtStaked)  external onlyRouter  {\r\n        baseAmtStaked = _baseAmtStaked;\r\n        tokenAmtStaked = _tokenAmtStaked; \r\n        __setPool(_baseAmt, _tokenAmt);\r\n    }\r\n    function _setPoolAmounts(uint _baseAmt, uint _tokenAmt)  external onlyRouter  {\r\n        __setPool(_baseAmt, _tokenAmt); \r\n    }\r\n    function __setPool(uint _baseAmt, uint _tokenAmt) internal  {\r\n        baseAmt = _baseAmt;\r\n        tokenAmt = _tokenAmt; \r\n    }\r\n\r\n    function _decrementPoolBalances(uint _baseAmt, uint _tokenAmt)  external onlyRouter  {\r\n        uint _unstakedBase = _DAO().UTILS().calcShare(_baseAmt, baseAmt, baseAmtStaked);\r\n        uint _unstakedToken = _DAO().UTILS().calcShare(_tokenAmt, tokenAmt, tokenAmtStaked);\r\n        baseAmtStaked = baseAmtStaked.sub(_unstakedBase);\r\n        tokenAmtStaked = tokenAmtStaked.sub(_unstakedToken); \r\n        __decrementPool(_baseAmt, _tokenAmt); \r\n    }\r\n \r\n    function __decrementPool(uint _baseAmt, uint _tokenAmt) internal  {\r\n        baseAmt = baseAmt.sub(_baseAmt);\r\n        tokenAmt = tokenAmt.sub(_tokenAmt); \r\n    }\r\n\r\n    function _addPoolMetrics(uint _volume, uint _fee) external onlyRouter  {\r\n        txCount += 1;\r\n        volume += _volume;\r\n        fees += _fee;\r\n    }\r\n\r\n}\r\n\r\ncontract Router_Vether {\r\n\r\n    using SafeMath for uint;\r\n\r\n    address public BASE;\r\n    address public DEPLOYER;\r\n    iDAO public DAO;\r\n\r\n    // uint256 public currentEra;\r\n    // uint256 public nextEraTime;\r\n    // uint256 public reserve;\r\n\r\n    uint public totalStaked; \r\n    uint public totalVolume;\r\n    uint public totalFees;\r\n    uint public unstakeTx;\r\n    uint public stakeTx;\r\n    uint public swapTx;\r\n\r\n    address[] public arrayTokens;\r\n    mapping(address=>address payable) private mapToken_Pool;\r\n    mapping(address=>bool) public isPool;\r\n\r\n    event NewPool(address token, address pool, uint genesis);\r\n    event Staked(address member, uint inputBase, uint inputToken, uint unitsIssued);\r\n    event Unstaked(address member, uint outputBase, uint outputToken, uint unitsClaimed);\r\n    event Swapped(address tokenFrom, address tokenTo, uint inputAmount, uint transferAmount, uint outputAmount, uint fee, address recipient);\r\n    // event NewEra(uint256 currentEra, uint256 nextEraTime, uint256 reserve);\r\n\r\n// Only Deployer can execute\r\n    modifier onlyDeployer() {\r\n        require(msg.sender == DEPLOYER, \"DeployerErr\");\r\n        _;\r\n    }\r\n\r\n    constructor () public payable {\r\n        BASE = 0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279;\r\n        DEPLOYER = msg.sender;\r\n    }\r\n\r\n    receive() external payable {\r\n        buyTo(msg.value, address(0), msg.sender);\r\n    }\r\n\r\n    function setGenesisDao(address dao) public onlyDeployer {\r\n        DAO = iDAO(dao);\r\n    }\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return DAO;\r\n    }\r\n\r\n    function migrateRouterData(address payable oldRouter) public onlyDeployer {\r\n        totalStaked = Router_Vether(oldRouter).totalStaked();\r\n        totalVolume = Router_Vether(oldRouter).totalVolume();\r\n        totalFees = Router_Vether(oldRouter).totalFees();\r\n        unstakeTx = Router_Vether(oldRouter).unstakeTx();\r\n        stakeTx = Router_Vether(oldRouter).stakeTx();\r\n        swapTx = Router_Vether(oldRouter).swapTx();\r\n    }\r\n\r\n    function migrateTokenData(address payable oldRouter) public onlyDeployer {\r\n        uint tokenCount = Router_Vether(oldRouter).tokenCount();\r\n        for(uint i = 0; i<tokenCount; i++){\r\n            address token = Router_Vether(oldRouter).getToken(i);\r\n            address payable pool = Router_Vether(oldRouter).getPool(token);\r\n            isPool[pool] = true;\r\n            arrayTokens.push(token);\r\n            mapToken_Pool[token] = pool;\r\n        }\r\n    }\r\n\r\n    function purgeDeployer() public onlyDeployer {\r\n        DEPLOYER = address(0);\r\n    }\r\n\r\n    function createPool(uint inputBase, uint inputToken, address token) public payable returns(address payable pool){\r\n        require(getPool(token) == address(0), \"CreateErr\");\r\n        require(token != BASE, \"Must not be Base\");\r\n        require((inputToken > 0 && inputBase > 0), \"Must get tokens for both\");\r\n        Pool_Vether newPool = new Pool_Vether(BASE, token, DAO);\r\n        pool = payable(address(newPool));\r\n        uint _actualInputToken = _handleTransferIn(token, inputToken, pool);\r\n        uint _actualInputBase = _handleTransferIn(BASE, inputBase, pool);\r\n        mapToken_Pool[token] = pool;\r\n        arrayTokens.push(token);\r\n        isPool[pool] = true;\r\n        totalStaked += _actualInputBase;\r\n        stakeTx += 1;\r\n        uint units = _handleStake(pool, _actualInputBase, _actualInputToken, msg.sender);\r\n        emit NewPool(token, pool, now);\r\n        emit Staked(msg.sender, _actualInputBase, _actualInputToken, units);\r\n        return pool;\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Staking functions\r\n\r\n    function stake(uint inputBase, uint inputToken, address token) public payable returns (uint units) {\r\n        units = stakeForMember(inputBase, inputToken, token, msg.sender);\r\n        return units;\r\n    }\r\n\r\n    function stakeForMember(uint inputBase, uint inputToken, address token, address member) public payable returns (uint units) {\r\n        address payable pool = getPool(token);\r\n        uint _actualInputToken = _handleTransferIn(token, inputToken, pool);\r\n        uint _actualInputBase = _handleTransferIn(BASE, inputBase, pool);\r\n        totalStaked += _actualInputBase;\r\n        stakeTx += 1;\r\n        require(totalStaked <= DAO.FUNDS_CAP(), \"Must be less than Funds Cap\");\r\n        units = _handleStake(pool, _actualInputBase, _actualInputToken, member);\r\n        emit Staked(member, _actualInputBase, _actualInputToken, units);\r\n        return units;\r\n    }\r\n\r\n\r\n    function _handleStake(address payable pool, uint _baseAmt, uint _tokenAmt, address _member) internal returns (uint _units) {\r\n        Pool_Vether(pool)._checkApprovals();\r\n        uint _S = Pool_Vether(pool).baseAmt().add(_baseAmt);\r\n        uint _A = Pool_Vether(pool).tokenAmt().add(_tokenAmt);\r\n        Pool_Vether(pool)._incrementPoolBalances(_baseAmt, _tokenAmt);                                                  \r\n        _units = _DAO().UTILS().calcStakeUnits(_tokenAmt, _A, _baseAmt, _S);  \r\n        Pool_Vether(pool)._mint(_member, _units);\r\n        return _units;\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Unstaking functions\r\n\r\n    // Unstake % for self\r\n    function unstake(uint basisPoints, address token) public returns (bool success) {\r\n        require((basisPoints > 0 && basisPoints <= 10000), \"InputErr\");\r\n        uint _units = _DAO().UTILS().calcPart(basisPoints, iERC20(getPool(token)).balanceOf(msg.sender));\r\n        unstakeExact(_units, token);\r\n        return true;\r\n    }\r\n\r\n    // Unstake an exact qty of units\r\n    function unstakeExact(uint units, address token) public returns (bool success) {\r\n        address payable pool = getPool(token);\r\n        address payable member = msg.sender;\r\n        (uint _outputBase, uint _outputToken) = _DAO().UTILS().getPoolShare(token, units);\r\n        totalStaked = totalStaked.sub(_outputBase);\r\n        unstakeTx += 1;\r\n        _handleUnstake(pool, units, _outputBase, _outputToken, member);\r\n        emit Unstaked(member, _outputBase, _outputToken, units);\r\n        _handleTransferOut(token, _outputToken, pool, member);\r\n        _handleTransferOut(BASE, _outputBase, pool, member);\r\n        return true;\r\n    }\r\n\r\n    // // Unstake % Asymmetrically\r\n    function unstakeAsymmetric(uint basisPoints, bool toBase, address token) public returns (uint outputAmount){\r\n        uint _units = _DAO().UTILS().calcPart(basisPoints, iERC20(getPool(token)).balanceOf(msg.sender));\r\n        outputAmount = unstakeExactAsymmetric(_units, toBase, token);\r\n        return outputAmount;\r\n    }\r\n    // Unstake Exact Asymmetrically\r\n    function unstakeExactAsymmetric(uint units, bool toBase, address token) public returns (uint outputAmount){\r\n        address payable pool = getPool(token);\r\n        require(units < iERC20(pool).totalSupply(), \"InputErr\");\r\n        (uint _outputBase, uint _outputToken, uint _outputAmount) = _DAO().UTILS().getPoolShareAssym(token, units, toBase);\r\n        totalStaked = totalStaked.sub(_outputBase);\r\n        unstakeTx += 1;\r\n        _handleUnstake(pool, units, _outputBase, _outputToken, msg.sender);\r\n        emit Unstaked(msg.sender, _outputBase, _outputToken, units);\r\n        _handleTransferOut(token, _outputToken, pool, msg.sender);\r\n        _handleTransferOut(BASE, _outputBase, pool, msg.sender);\r\n        return _outputAmount;\r\n    }\r\n\r\n    function _handleUnstake(address payable pool, uint _units, uint _outputBase, uint _outputToken, address _member) internal returns (bool success) {\r\n        Pool_Vether(pool)._checkApprovals();\r\n        Pool_Vether(pool)._decrementPoolBalances(_outputBase, _outputToken);\r\n        Pool_Vether(pool).burnFrom(_member, _units);\r\n        return true;\r\n    } \r\n\r\n    //==================================================================================//\r\n    // Universal Swapping Functions\r\n\r\n    function buy(uint amount, address token) public payable returns (uint outputAmount, uint fee){\r\n        (outputAmount, fee) = buyTo(amount, token, msg.sender);\r\n        return (outputAmount, fee);\r\n    }\r\n    function buyTo(uint amount, address token, address payable member) public payable returns (uint outputAmount, uint fee) {\r\n        address payable pool = getPool(token);\r\n        Pool_Vether(pool)._checkApprovals();\r\n        uint _actualAmount = _handleTransferIn(BASE, amount, pool);\r\n        // uint _minusFee = _getFee(_actualAmount);\r\n        (outputAmount, fee) = _swapBaseToToken(pool, _actualAmount);\r\n        // addDividend(pool, outputAmount, fee);\r\n        totalStaked += _actualAmount;\r\n        totalVolume += _actualAmount;\r\n        totalFees += _DAO().UTILS().calcValueInBase(token, fee);\r\n        swapTx += 1;\r\n        _handleTransferOut(token, outputAmount, pool, member);\r\n        emit Swapped(BASE, token, _actualAmount, 0, outputAmount, fee, member);\r\n        return (outputAmount, fee);\r\n    }\r\n\r\n    // function _getFee(uint amount) private view returns(uint){\r\n    //     return amount\r\n    // }\r\n\r\n    function sell(uint amount, address token) public payable returns (uint outputAmount, uint fee){\r\n        (outputAmount, fee) = sellTo(amount, token, msg.sender);\r\n        return (outputAmount, fee);\r\n    }\r\n    function sellTo(uint amount, address token, address payable member) public payable returns (uint outputAmount, uint fee) {\r\n        address payable pool = getPool(token);\r\n        Pool_Vether(pool)._checkApprovals();\r\n        uint _actualAmount = _handleTransferIn(token, amount, pool);\r\n        (outputAmount, fee) = _swapTokenToBase(pool, _actualAmount);\r\n        // addDividend(pool, outputAmount, fee);\r\n        totalStaked = totalStaked.sub(outputAmount);\r\n        totalVolume += outputAmount;\r\n        totalFees += fee;\r\n        swapTx += 1;\r\n        _handleTransferOut(BASE, outputAmount, pool, member);\r\n        emit Swapped(token, BASE, _actualAmount, 0, outputAmount, fee, member);\r\n        return (outputAmount, fee);\r\n    }\r\n\r\n    function swap(uint inputAmount, address fromToken, address toToken) public payable returns (uint outputAmount, uint fee) {\r\n        require(fromToken != toToken, \"InputErr\");\r\n        address payable poolFrom = getPool(fromToken); address payable poolTo = getPool(toToken);\r\n        Pool_Vether(poolFrom)._checkApprovals();\r\n        Pool_Vether(poolTo)._checkApprovals();\r\n        uint _actualAmount = _handleTransferIn(fromToken, inputAmount, poolFrom);\r\n        uint _transferAmount = 0;\r\n        if(fromToken == BASE){\r\n            (outputAmount, fee) = _swapBaseToToken(poolFrom, _actualAmount);      // Buy to token\r\n            totalStaked += _actualAmount;\r\n            totalVolume += _actualAmount;\r\n            // addDividend(poolFrom, outputAmount, fee);\r\n        } else if(toToken == BASE) {\r\n            (outputAmount, fee) = _swapTokenToBase(poolFrom,_actualAmount);   // Sell to token\r\n            totalStaked = totalStaked.sub(outputAmount);\r\n            totalVolume += outputAmount;\r\n            // addDividend(poolFrom, outputAmount, fee);\r\n        } else {\r\n            (uint _yy, uint _feey) = _swapTokenToBase(poolFrom, _actualAmount);             // Sell to BASE\r\n            uint _actualYY = _handleTransferOver(BASE, poolFrom, poolTo, _yy);\r\n            totalStaked = totalStaked.add(_actualYY).sub(_actualAmount);\r\n            totalVolume += _yy; totalFees += _feey;\r\n            // addDividend(poolFrom, _yy, _feey);\r\n            (uint _zz, uint _feez) = _swapBaseToToken(poolTo, _actualYY);              // Buy to token\r\n            totalFees += _DAO().UTILS().calcValueInBase(toToken, _feez);\r\n            // addDividend(poolTo, _zz, _feez);\r\n            _transferAmount = _actualYY; outputAmount = _zz; \r\n            fee = _feez + _DAO().UTILS().calcValueInToken(toToken, _feey);\r\n        }\r\n        swapTx += 1;\r\n        _handleTransferOut(toToken, outputAmount, poolTo, msg.sender);\r\n        emit Swapped(fromToken, toToken, _actualAmount, _transferAmount, outputAmount, fee, msg.sender);\r\n        return (outputAmount, fee);\r\n    }\r\n\r\n    function _swapBaseToToken(address payable pool, uint _x) internal returns (uint _y, uint _fee){\r\n        uint _X = Pool_Vether(pool).baseAmt();\r\n        uint _Y = Pool_Vether(pool).tokenAmt();\r\n        _y =  _DAO().UTILS().calcSwapOutput(_x, _X, _Y);\r\n        _fee = _DAO().UTILS().calcSwapFee(_x, _X, _Y);\r\n        Pool_Vether(pool)._setPoolAmounts(_X.add(_x), _Y.sub(_y));\r\n        _updatePoolMetrics(pool, _y+_fee, _fee, false);\r\n        // _checkEmission();\r\n        return (_y, _fee);\r\n    }\r\n\r\n    function _swapTokenToBase(address payable pool, uint _x) internal returns (uint _y, uint _fee){\r\n        uint _X = Pool_Vether(pool).tokenAmt();\r\n        uint _Y = Pool_Vether(pool).baseAmt();\r\n        _y =  _DAO().UTILS().calcSwapOutput(_x, _X, _Y);\r\n        _fee = _DAO().UTILS().calcSwapFee(_x, _X, _Y);\r\n        Pool_Vether(pool)._setPoolAmounts(_Y.sub(_y), _X.add(_x));\r\n        _updatePoolMetrics(pool, _y+_fee, _fee, true);\r\n        // _checkEmission();\r\n        return (_y, _fee);\r\n    }\r\n\r\n    function _updatePoolMetrics(address payable pool, uint _txSize, uint _fee, bool _toBase) internal {\r\n        if(_toBase){\r\n            Pool_Vether(pool)._addPoolMetrics(_txSize, _fee);\r\n        } else {\r\n            uint _txBase = _DAO().UTILS().calcValueInBaseWithPool(pool, _txSize);\r\n            uint _feeBase = _DAO().UTILS().calcValueInBaseWithPool(pool, _fee);\r\n            Pool_Vether(pool)._addPoolMetrics(_txBase, _feeBase);\r\n        }\r\n    }\r\n\r\n\r\n    //==================================================================================//\r\n    // Revenue Functions\r\n\r\n    // Every swap, calculate fee, add to reserve\r\n    // Every era, send reserve to DAO\r\n\r\n    // function _checkEmission() private {\r\n    //     if (now >= nextEraTime) {                                                           // If new Era and allowed to emit\r\n    //         currentEra += 1;                                                               // Increment Era\r\n    //         nextEraTime = now + iBASE(BASE).secondsPerEra() + 100;                     // Set next Era time\r\n    //         uint reserve = iERC20(BASE).balanceOf(address(this));\r\n    //         iERC20(BASE).transfer(address(_DAO()), reserve);\r\n    //         emit NewEra(currentEra, nextEraTime, reserve);                               // Emit Event\r\n    //     }\r\n    // }\r\n\r\n    //==================================================================================//\r\n    // Token Transfer Functions\r\n\r\n    function _handleTransferIn(address _token, uint _amount, address _pool) internal returns(uint actual){\r\n        if(_amount > 0) {\r\n            if(_token == address(0)){\r\n                require((_amount == msg.value), \"InputErr\");\r\n                payable(_pool).call{value:_amount}(\"\"); \r\n                actual = _amount;\r\n            } else {\r\n                uint startBal = iERC20(_token).balanceOf(_pool); \r\n                iERC20(_token).transferFrom(msg.sender, _pool, _amount); \r\n                actual = iERC20(_token).balanceOf(_pool).sub(startBal);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _handleTransferOut(address _token, uint _amount, address _pool, address payable _recipient) internal {\r\n        if(_amount > 0) {\r\n            if (_token == address(0)) {\r\n                Pool_Vether(payable(_pool)).transferETH(_recipient, _amount);\r\n            } else {\r\n                iERC20(_token).transferFrom(_pool, _recipient, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _handleTransferOver(address _token, address _from, address _to, uint _amount) internal returns(uint actual){\r\n        if(_amount > 0) {\r\n            uint startBal = iERC20(_token).balanceOf(_to); \r\n            iERC20(_token).transferFrom(_from, _to, _amount); \r\n            actual = iERC20(_token).balanceOf(_to).sub(startBal);\r\n        }\r\n    }\r\n\r\n    //======================================HELPERS========================================//\r\n    // Helper Functions\r\n\r\n    function getPool(address token) public view returns(address payable pool){\r\n        return mapToken_Pool[token];\r\n    }\r\n\r\n    function tokenCount() public view returns(uint){\r\n        return arrayTokens.length;\r\n    }\r\n\r\n    function getToken(uint i) public view returns(address){\r\n        return arrayTokens[i];\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"genesis\",\"type\":\"uint256\"}],\"name\":\"NewPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsIssued\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsClaimed\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAO\",\"outputs\":[{\"internalType\":\"contract iDAO\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPLOYER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrayTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"buyTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"oldRouter\",\"type\":\"address\"}],\"name\":\"migrateRouterData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"oldRouter\",\"type\":\"address\"}],\"name\":\"migrateTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purgeDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"sellTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"setGenesisDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"stakeForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toBase\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unstakeAsymmetric\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unstakeExact\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toBase\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unstakeExactAsymmetric\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Router_Vether","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6c2a17678aaa877809175f89c7719f73d3d269cc79fb84d86de8207b993300aa"}]}