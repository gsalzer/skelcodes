{"status":"1","message":"OK","result":[{"SourceCode":"{\"BasicToken.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract BasicToken is ERC20Basic, Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    //Mapping keeps track of all token balances\\n    mapping(address =\\u003e uint256) balances;\\n\\n    /**\\n     * Modifier prevents short address attacks.\\n     * For more info check: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\\n     */\\n    modifier onlyPayloadSize(uint size) {\\n        require(msg.data.length \\u003e= size + 4);\\n        _;\\n    }\\n\\n    /**\\n     * Returns the balance of any given ETH address.\\n     *\\n     * @param _addr The address to be queried.\\n     */\\n    function balanceOf(address _addr) constant public returns (uint256) {\\n        return balances[_addr];\\n    }\\n\\n    /**\\n     * Transfers EEE tokens from one address to another, given that the address which \\n     * executes the transfer has enough tokens.\\n     *\\n     * @param _addr The address of the recipient. \\n     * @param _value The amount of tokens to be sent.\\n     */\\n    function transfer(address _addr, uint _value) public onlyPayloadSize(2 * 32) returns (bool) {\\n        require(_addr != 0x0 \\u0026\\u0026 _value \\u003e 0 \\u0026\\u0026 balances[msg.sender] \\u003e= _value);\\n        balances[_addr] = balances[_addr].add(_value);\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        Transfer(msg.sender, _addr, _value);\\n        return true;\\n    }\\n} \"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\ncontract ERC20 is ERC20Basic {\\n    function allowance(address _owner, address _spender) constant public returns(uint256);\\n    function transferFrom(address _from, address _to, uint256 _value) public  returns(bool);\\n    function approve(address _spender, uint256 _value) public returns(bool);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\ncontract ERC20Basic {\\n    uint256 public totalSupply;\\n    function balanceOf(address _addr) constant public returns(uint256);\\n    function transfer(address _to, uint256 _value) public returns(bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\"},\"ETHToken.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\nimport \\\"./MintableToken.sol\\\";\\n\\ncontract ETHToken is MintableToken {\\n\\n    uint8 public decimals;\\n    string public name;\\n    string public symbol;\\n\\n    /**\\n     * Constructor initializes the decimals to 18, the name to ETH Token and the \\n     * symbol to EEE.\\n     */\\n    function ETHToken() public {\\n        totalSupply = 0;\\n        decimals = 18;\\n        name = \\\"ETH Token\\\";\\n        symbol = \\\"EEE\\\";\\n    } \\n}\"},\"ICO.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\nimport \\\"./ETHToken.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract ICO is Ownable {\\n\\n    //allows to use the SafeMath functions on the uint256 data type.\\n    using SafeMath for uint256;\\n\\n    //EEE will be used to create a new instance of the token contract. \\n    ETHToken public EEE;    \\n\\n    //rate is for how many tokens 1 ETH equates to.\\n    uint256 public rate;  \\n\\n    //this will can be written as startTime = now, or now.add(x amount of seconds/minutes/hours/days/weeks/years).   \\n    uint256 public startTime; \\n\\n    //this can be written as endTime = startTime.add(y amount of seconds/minutes/hours/days/weeks/years).\\n    uint256 public endTime;\\n\\n    //tokensSold will be updated everytime new tokens are minted.\\n    uint256 public tokensSold;\\n\\n    //a maximum amount of tokens to be sold during the preICO. \\n    uint256 public tokensForPreIco;\\n\\n    //the maximum amount of tokens to be sold in total, this number should include the tokens for pre ICO and \\n    //should be \\u003e= tokensForPreIco.\\n    uint256 public totalTokensForSale;\\n\\n    //preIcoStages is an array with 4 indexes. In each index, a timestamp will be stored. For example:\\n    //week 1: preIcoStages[0] = now.add(7 days)  \\n    //week 2: preIcoStages[1] = now.add(14 days)\\n    //week 3: preIcoStages[2] = now.add(21 days)\\n    //week 4: preIcoStages[3] = now.add(28 days)\\n    uint256[4] public preIcoStages;\\n\\n    //IcoStages is also an array with 4 indexes. In each index, a timestamp that is greater than preIcoStages[3]\\n    //will be stored. For example:\\n    //week 1: icoStages[0] = now.add(35 days) and so on.\\n    uint256[4] public icoStages;\\n    \\n    event TokensPurchased(address indexed by, uint256 messageValue, uint256 tokens);\\n    event SoldOut();\\n\\n    /**\\n     * Constructor deploys new instance of the ETHToken contract, sets the\\n     * start time to 72 days from the moment of deployment, initializes the \\n     * end time to be 30 days after the start time, assigns a rate of 100\\n     * NCO per ETH and sets a soft and hard cap to 21686 - 27108 ETH.\\n     */\\n    function ICO() public {\\n\\n        //deploys the ETHToken contract and stores it in EEE.\\n        EEE = new ETHToken();\\n\\n        //mints 1,000,000 tokens to the owner.\\n        EEE.mintTokens(owner, 1000000e18); \\n\\n        //the pre ICO will begin as soon as the contract is deployed.\\n        startTime = now;\\n\\n        //total duration of the presale and ICO.\\n        endTime = startTime.add(60 days);\\n\\n        //1 ETH = 100 EEE tokens\\n        rate = 100;\\n\\n        //1,000,000 for pre ICO. Please note, e18 covers the decimals and is a nicer way \\n        //of writing 1000000* 10**18.\\n        tokensForPreIco = 1000000e18;\\n\\n        //3,000,000 tokens in total. This includes the tokensForPreIco. If not all\\n        //1,000,000 tokens are sold during the pre ICO, then they will still be available\\n        //for sale when the pre ICO duration has ended. \\n        totalTokensForSale = 3000000e18;\\n\\n        tokensSold = 0;\\n\\n        //sets the first stage of the pre sale to be 7 days long.\\n        preIcoStages[0] = startTime.add(7 days);\\n\\n        //sets every other pre ICO stage to be 7 days longer than the previous stage.\\n        for (uint i = 1; i \\u003c preIcoStages.length; i++) {\\n            preIcoStages[i] = preIcoStages[i - 1].add(7 days);\\n        }\\n\\n        //sets the ICOs first stage to be 7 days longer than the pre ICO\\u0027s last stage.\\n        icoStages[0] = preIcoStages[3].add(7 days);\\n\\n        //sets every other stage of the ICO to be 7 days longer than the previous stage.\\n        for (uint y = 1; y \\u003c icoStages.length; y++) {\\n            icoStages[y] = icoStages[y - 1].add(7 days);\\n        }\\n    }\\n\\n    /**\\n     * Fallback function calls the buy tokens function when ETH is sent to \\n     * the ICO address.\\n     */\\n    function() public payable {\\n        buyTokens(msg.sender);\\n    }\\n\\n    /**\\n     * Sends an appropriate amount of NCO tokens to a specified ETH address \\n     * by multiplying the rate by the amount of ETH that was sent to the \\n     * contract.\\n     *\\n     * This function will not continue to execute once the hard cap of 27108\\n     * ETH has been raised. It will also fail to execute if the ICO period \\n     * has not started yet, or if the 30 day duration is over. If anyone \\n     * attempts to send ETH during any of these circumstances, they will be\\n     * automatically refunded. \\n     *\\n     * @param _addr The address of the recipient. \\n     */\\n    function buyTokens(address _addr) public payable {\\n        //requirement ensures that the total tokens sold cannot exceed the totalTokensForSale\\n        require(tokensSold.add(msg.value.mul(getRateWithBonus())) \\u003c= totalTokensForSale);\\n        //requirement checks if the purchase is valid and that the address is not null\\n        require(validPurchase() \\u0026\\u0026 _addr != 0x0);\\n        //calculates the tokens to mint based on the msg.value * with the rate and current bonus.\\n        uint256 toMint = msg.value.mul(getRateWithBonus());\\n        //ensures that the total token sales during the presale does not exceed tokensForPreIco.\\n        if (now \\u003c= preIcoStages[3] \\u0026\\u0026 tokensSold.add(toMint) \\u003e tokensForPreIco) {\\n            //revert() is the same as throw, however throw is depricated in favour of revert() and assert()\\n            revert();\\n        }\\n        //invokes the mint function of ETHToken in the Mintable contract.\\n        EEE.mintTokens(_addr, toMint);\\n        //updates the total amount of tokens sold.\\n        tokensSold = tokensSold.add(toMint);\\n        //TokensPurchased event is triggered. \\n        TokensPurchased(_addr, msg.value, toMint);\\n        //the investment made is sent to the owner of the contract with forwardFunds().\\n        forwardFunds();\\n        //if all tokens have sold out, trigger the event SoldOut.\\n        if (tokensSold == totalTokensForSale) {\\n            SoldOut();\\n        }\\n    }\\n\\n    /**\\n     * Calculates the rate with the current bonus. In this example of the contract\\n     * the rate has been sent to 1 ETH = 100 tokens, so the prices for the 60 day\\n     * duration are as follows:\\n     *\\n     * ----------- PRE ICO ------------------\\n     * day 1  - 7  / week 1: 145 tokens / 45%\\n     * day 7  - 14 / week 2: 140 tokens / 40%\\n     * day 14 - 21 / week 3: 135 tokens / 35%\\n     * day 21 - 28 / week 4: 130 tokens / 30%\\n     * --------------------------------------\\n     *\\n     * -------------- ICO -------------------\\n     * day 28 - 35 / week 5: 120 tokens / 20%\\n     * day 35 - 42 / week 6: 115 tokens / 15%\\n     * day 42 - 49 / week 7: 110 tokens / 10%\\n     * day 49 - 56 / week 8: 105 tokens / 5%\\n     * day 56 - 60 / week 9: 100 tokens / 0%\\n     * --------------------------------------\\n     *\\n     * Please note that you can change the bonus percentages in the getPreIcoPercentage()\\n     * function and the getIcoPercentage() function.\\n     */\\n    function getRateWithBonus() internal returns (uint256) {\\n        //if the preIco has not ended and the token sales are less than tokensForPreIco.\\n        if (now \\u003c= preIcoStages[3] \\u0026\\u0026 tokensSold \\u003c tokensForPreIco) {\\n            //compute the current rate with bonus in the presale bonus stages.\\n            return rate.mul(getPreIcoBonusPercentage()).div(100).add(rate);\\n        }\\n        //if the preIco has ended and the token sales are less than the totalTokensForSale.\\n        if (now \\u003e preIcoStages[3] \\u0026\\u0026 tokensSold \\u003c totalTokensForSale) {\\n            //compute the current rate with bonus in the ICO bonus stages.\\n            return rate.mul(getIcoBonusPercentage()).div(100).add(rate);\\n        }\\n        //if none of the statements above are true, just return the rate without the bonus.\\n        return rate;\\n    }\\n\\n    /**\\n     * Function is called when the buy function is invoked  during pre sale and returns \\n     * the current bonus in percentage. In this example, the bonus starts at 45% and reduces by\\n     * 5% for every bonus period that has passed. \\n     *\\n     * day 1  - 7  / week 1: 45%\\n     * day 7  - 14 / week 2: 40%\\n     * day 14 - 21 / week 3: 35%\\n     * day 21 - 28 / week 4: 30%\\n     */\\n    function getPreIcoBonusPercentage() internal returns (uint256 _percent) {\\n        //first bonus is set to 45%\\n        _percent = 45;\\n        for (uint i = 0; i \\u003c preIcoStages.length; i++) {\\n            //if the current timestamp is less than preIcoStages[i] then break out of the loop \\n            if (now \\u003c= preIcoStages[i]) {\\n                break;\\n            } else {\\n                //subtract _percent by 5 with each iteration of the loop.\\n                _percent = _percent.sub(5);\\n            }\\n        }\\n        return _percent;\\n    }\\n\\n    /**\\n     * Function is called when the buy function is invoked  only after the pre sale duration and returns \\n     * the current bonus in percentage. In this example, the bonus starts at 20% and reduces by 5% for \\n     * every bonus period that has passed. After the 8th week, the bonus percentage will be set to 0.\\n     *\\n     * day 28 - 35   / week 5: 20%\\n     * day 35 - 42   / week 6: 15%\\n     * day 42 - 49   / week 7: 10%\\n     * day 49 - 56   / week 8:  5%\\n     * day 56 - 60   / week 9:  0%\\n     */\\n    function getIcoBonusPercentage() internal returns (uint256 _percent) {\\n        //if all bonus stages have passed, i.e more than 8 weeks, then _percent will be assigned 0.\\n        if (now \\u003e icoStages[3]) {\\n            _percent = 0;\\n        } else {\\n            //the percentage starts from 20.\\n            _percent = 20;\\n            for (uint i = 0; i \\u003c icoStages.length; i++) {\\n                //if the current timestamp is less than icoStages[i] then break out of the loop \\n                if (now \\u003c= icoStages[i]) {\\n                    break;\\n                } else {\\n                    //reduce _percent by 5 with each iteration of the loop.\\n                    _percent = _percent.sub(5);\\n                }\\n            }\\n        }\\n        return _percent;\\n    }\\n\\n    /**\\n     * Transfers the funds received to the owner of the contract in real time.\\n     */\\n    function forwardFunds() internal {\\n        owner.transfer(msg.value);\\n    }\\n\\n    /**\\n     * Invoked by the buyTokens() function to ensure that investments can only be made\\n     * during the pre sale and ICO period and that the total investment is greater than 0.\\n     */\\n    function validPurchase() internal view returns (bool) {\\n        bool withinPeriod = now \\u003e= startTime \\u0026\\u0026 now \\u003c= endTime;\\n        bool nonZeroPurchase = msg.value != 0;\\n        return withinPeriod \\u0026\\u0026 nonZeroPurchase;\\n    }\\n\\n    /**\\n     * This function has been added incase you would like to mint new tokens. The reason for\\n     * adding this here is because only the owner of the token contract can mint new tokens,\\n     * and the owner of the token contract is the ICO contract because the ICO contract is the \\n     * ETH address which deployed the token contract. You will also notice that the onlyOwner\\n     * modifier has been added in the method signature, this means that only the owner of the \\n     * ICO contract will be allowed to mint new tokens. When this function is invoked, the ICO \\n     * contract will then call the mintTokens function of the token contract and since the \\n     * ICO contract is the owner of the token contract, the function will execute successfully.\\n     *\\n     * @param _addr The address of the recipient.\\n     * @param _value The amount of tokens to be minted.\\n     */\\n    function mintTokens(address _addr, uint256 _value) public onlyOwner {\\n        require(_addr != 0x0 \\u0026\\u0026 _value \\u003e 0);\\n        //you could also include the commented lines of code to ensure the maximum supply is \\n        //never exceded when invoking this function: \\n        \\n        //require(tokensSold.add(_value) \\u003c= totalTokensForSale)\\n        //tokensSold = tokensSold.add(_value) \\n        // if (tokensSold == totalTokensForSale) {\\n        //     SoldOut();\\n        // }\\n        EEE.mintTokens(_addr, _value);\\n    }\\n\\n    /**\\n     * Terminates the minting period permanently. This function is restricted and can\\n     * only be executed by the owner of the contract given that the ICO duration has ended. \\n     */\\n    function finishMintingPeriod() public onlyOwner {\\n        require(now \\u003e endTime);\\n        EEE.finishMinting();\\n    }\\n\\n    /**\\n     * Returns the amount of tokens sold at any given time.\\n     */\\n    function tokensSold() public constant returns(uint256) {\\n        return tokensSold;\\n    }\\n}\\n\"},\"MintableToken.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\nimport \\\"./StandardToken.sol\\\";\\n\\ncontract MintableToken is StandardToken {\\n\\n    event TokensMinted(address indexed to , uint256 ammount);\\n    event MintingFinished();\\n\\n    bool public mintingFinished;\\n\\n    /**\\n     * Modifier makes a prerequisite check that the minting function and finish minting\\n     * function can be called prior to executing any of the code within the functions.\\n     */\\n    modifier canMint {\\n        require(!mintingFinished);\\n        _;\\n    }\\n\\n    /**\\n     * Constructor initializes the total supply to zero.\\n     */\\n    function MintableToken() public {\\n        mintingFinished = false;\\n    }\\n\\n    /**\\n     * Generates new tokens and sends them to a specified ETH address. This function is \\n     * restricted and can only be called by the owner of the contract. In this case, the \\n     * owner will be the ICO contract because it is the ICO contract which will deploy\\n     * the token contract. \\n     * \\n     * @param _addr The address of the recipient.\\n     * @param _value The amount of tokens to be minted.\\n     */\\n    function mintTokens(address _addr, uint256 _value) public onlyOwner canMint returns(bool){\\n        require(_addr != 0x0 \\u0026\\u0026 _value \\u003e 0);\\n        totalSupply = totalSupply.add(_value);\\n        balances[_addr] = balances[_addr].add(_value);\\n        Transfer(this, _addr, _value);\\n        TokensMinted (_addr, _value);\\n        return true;\\n    } \\n\\n    /**\\n     * Terminates the minting period permanently. This function is restricted and can\\n     * only be executed by the owner of the contract. \\n     */\\n    function finishMinting() public onlyOwner canMint returns(bool) {\\n        mintingFinished = true;\\n        MintingFinished();\\n        return true;\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed from, address indexed to);\\n\\n    /**\\n     * Constructor assigns ownership to the ETH address used to deploy the \\n     * contract.\\n     */\\n    function Ownable() internal {\\n       owner = msg.sender;\\n    }\\n\\n    /**\\n     * Modifier makes a prerequisite check that restricted functions can be \\n     * called given that it is the owner who is executing the functions.\\n     */\\n    modifier onlyOwner {\\n        require(owner == msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * Allows the owner of the contract to transfer ownership to another ETH\\n     * address. This function is restricted and can only be called by the \\n     * current owner.\\n     *\\n     * @param _addr The address which the ownership will be transferred to. \\n     */\\n    function transferOwnership(address _addr) public onlyOwner {\\n        require(_addr != 0x0);\\n        owner = _addr;\\n        OwnershipTransferred(msg.sender, _addr);\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\nlibrary SafeMath {\\n    \\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n      uint256 c = a * b;\\n      assert(a == 0 || c / a == b);\\n      return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n      // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n      uint256 c = a / b;\\n      // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n      return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\\n        uint256 c = a + b;\\n        assert(c \\u003e= a); //prevents overflow\\n        return c;\\n    }\\n}\"},\"StandardToken.sol\":{\"content\":\"pragma solidity ^0.4.17;\\n\\nimport \\\"./BasicToken.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract StandardToken is BasicToken, ERC20 {\\n\\n    //Mapping keeps a record of all allowances.\\n    mapping(address =\\u003e mapping (address =\\u003e uint256)) allowances;\\n\\n    /**\\n     * Returns the allowance from one ETH address to another.\\n     */\\n    function allowance( address _owner, address _spender) public constant returns(uint256) {\\n        return allowances[_owner][_spender];\\n    } \\n\\n    /**\\n     * Allows people to sent EEE tokens on behalf of the owner given that the owner has allowed\\n     * the spender to do so.\\n     *\\n     * @param _from The address of the owner.\\n     * @param _to The address of the recipient.\\n     * @param _value The total amount of tokens to be sent.\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns(bool) {\\n        require (_from != 0x0 \\u0026\\u0026 _to != 0x0 \\u0026\\u0026 _value \\u003e 0);\\n        require (allowances[_from][msg.sender] \\u003e= _value \\u0026\\u0026 balances[_from] \\u003e= _value);\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\\n        Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Allows people to approve others to spend tokens on their behalf.\\n     * \\n     * @param _spender The address of the spender.\\n     * @param _value The amount of tokens the spender will be allowed to spend.\\n     */\\n    function approve(address _spender, uint256 _value) public returns(bool) {\\n        require((_value == 0) || (allowances[msg.sender][_spender] == 0));\\n        allowances[msg.sender][_spender] = _value;\\n        Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Allows people to increase the amount of tokens others are allowed to spend on \\n     * their behalf.\\n     * \\n     * @param _spender The address of the spender.\\n     * @param _value The total extra amount the spender is allowed to spend.\\n     */\\n    function increaseApproval(address _spender, uint256 _value) public returns(bool) {\\n        require (_spender != 0x0 \\u0026\\u0026 _value \\u003e 0);\\n        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add(_value);\\n        Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\\n        return true;\\n\\n    }\\n\\n    /**\\n     * Allows people to decrease the amount of tokens others are allowed to spend on\\n     * their behalf.\\n     *\\n     * @param _spender The address of the spender.\\n     * @param _subtractedValue The total allowance that will be subtracted.\\n     */\\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\\n        uint256 oldValue = allowances[msg.sender][_spender];\\n        if (_subtractedValue \\u003e oldValue) {\\n            allowances[msg.sender][_spender] = 0;\\n        } else {\\n            allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\\n        return true;\\n    }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ammount\",\"type\":\"uint256\"}],\"name\":\"TokensMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintingFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"ETHToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a2ea2c2638af2bd95d58b2882299ac9c7b93bed68c54200c905555d0210de7f8"}]}