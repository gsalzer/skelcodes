{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Auditable.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\ncontract Auditable {\r\n    using Address for address;\r\n\r\n    address public auditor;\r\n    address public auditedContract;\r\n\r\n    // Indicates whether the audit has been completed and approved (true) or not (false)\r\n    bool public audited;\r\n\r\n    modifier isAudited() {\r\n        require(audited == true, \"Not audited\");\r\n        _;\r\n    }\r\n\r\n    // emitted when the contract has been audited and approved/opposed\r\n    event ApprovedAudit(address _auditor, address _contract, string _message);\r\n    event OpposedAudit(address _auditor, address _contract, string _message);\r\n\r\n    constructor(address _auditor, address _auditedContract) public {\r\n        auditor = _auditor;\r\n        auditedContract = _auditedContract;\r\n    }\r\n\r\n    function setAuditor(address _auditor) public {\r\n        require(msg.sender == auditor, \"Only the auditor ???\");\r\n        require(audited == false, \"Cannot change auditor post audit\");\r\n        // Can change the auditor if they bail, saves from having to redeploy and lose funds\r\n        auditor = _auditor;\r\n    }\r\n\r\n    // The auditor is approving the contract by switching the audit bool to true. \r\n    // This unlocks contract functionality via the isAudited modifier\r\n    function approveAudit() public {\r\n        require(msg.sender == auditor, \"Auditor only\");\r\n\r\n        audited = true;\r\n\r\n        // Inform everyone and use a user friendly message\r\n        emit ApprovedAudit(auditor, auditedContract, \"Contract approved, functionality unlocked\");\r\n    }\r\n\r\n    // The auditor is opposing the audit by switching the bool to false\r\n    function opposeAudit() public {\r\n        require(msg.sender == auditor, \"Auditor only\");\r\n        require(audited != true, \"Cannot destroy an approved contract\");\r\n        \r\n        // The default (unset) bool is set to false but do not rely on that; set to false to be sure.\r\n        audited = false;\r\n\r\n        // Inform everyone and use a user friendly message\r\n        emit OpposedAudit(auditor, auditedContract, \"Contract has failed the audit\");\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\ncontract Ownable {\r\n\r\n    address payable public owner;\r\n\r\n    event TransferredOwnership(address _previous, address _next, uint256 _time);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Owner only\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address payable _owner) public onlyOwner() {\r\n        address previousOwner = owner;\r\n        owner = _owner;\r\n        emit TransferredOwnership(previousOwner, owner, now);\r\n    }\r\n}\r\n\r\n// File: contracts/Donations.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n\r\ncontract Donations is Ownable, Auditable {\r\n\r\n    // the non-fungible token can be updated over time as newer versions are released\r\n    address public NFT;\r\n\r\n    event ChangedNFT(address _previous, address _next, uint256 _time);\r\n\r\n    constructor(address _auditor, address _NFT) Ownable() Auditable(_auditor, address(this)) public {\r\n        // Duplicated code for the setting of the NFT because we must set the NFT before anyone \r\n        // can donate however the setNFT function is another part of this contract that should not \r\n        // be available until the contract has been audited.\r\n        address previousNFT = NFT;\r\n        NFT = _NFT;\r\n        emit ChangedNFT(previousNFT, NFT, now);\r\n    }\r\n\r\n    function donate() public payable isAudited() {\r\n        // Accept any donation (including 0) but ...\r\n        // if donation >= 0.1 ether then mint the non-fungible token as a collectible\r\n        // and as a thank you\r\n        if(msg.value >= 100000000000000000) \r\n        {\r\n            // Call the mint function of the current NFT contract address\r\n            // keep in mind that you can keep donating but you will only ever have ONE\r\n            // NFT in total (per NFT type). This should not mint additional tokens\r\n            NFT.call(abi.encodeWithSignature(\"mint(address)\", msg.sender));\r\n        }\r\n\r\n        // Transfer the value to the owner\r\n        owner.transfer(msg.value);\r\n    }\r\n\r\n    function setNFT(address _NFT) public onlyOwner() isAudited() {\r\n        // Over time new iterations of (collectibles) NFTs shall be issued.\r\n\r\n        // For user convenience it would be better to inform the user instead of just changing\r\n        // the NFT. Exmaples include minimum time locks, total number of donations or a fund goal\r\n        address previousNFT = NFT;\r\n        NFT = _NFT;\r\n        emit ChangedNFT(previousNFT, NFT, now);\r\n    }\r\n\r\n    function destroyContract() public onlyOwner() {\r\n        // Need another function for the auditor which lets them destroy (WIP)\r\n        require(audited == false, \"Cannot destroy an audited contract\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auditor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_auditor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"ApprovedAudit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_previous\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_next\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"ChangedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_auditor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"OpposedAudit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_previous\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_next\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"TransferredOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveAudit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"audited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auditedContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auditor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opposeAudit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auditor\",\"type\":\"address\"}],\"name\":\"setAuditor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"}],\"name\":\"setNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Donations","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f28dcdf515e69da11ebd264163b09b1b30dc9dc8000000000000000000000000a6f638a1870213f7b2ff32946d75fe82045f0d4c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c719415bb0e8d910d4d956aa32ba29b497c32c8a541df22303be793e81429b74"}]}