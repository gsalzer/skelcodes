{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint _id) external returns (uint _num);\r\n    function setUint(uint _id, uint _val) external;\r\n}\r\n\r\ninterface EventInterface {\r\n    function emitEvent(uint connectorType, uint connectorID, bytes32 eventCode, bytes calldata eventData) external;\r\n}\r\n\r\ninterface TokenInterface {\r\n    function balanceOf(address) external view returns (uint);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaEvent Address.\r\n     */\r\n    function getEventAddr() internal pure returns (address) {\r\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Memory Variable Address\r\n     */\r\n    function getMemoryAddr() internal pure returns (address) {\r\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n    }\r\n\r\n    /**\r\n     * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) internal {\r\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n    }\r\n\r\n    /**\r\n     * @dev emit event on event contract\r\n     */\r\n    function emitEvent(bytes32 eventCode, bytes memory eventData) internal {\r\n        (uint model, uint id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(model, id, eventCode, eventData);\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details.\r\n     */\r\n    function connectorID() public pure returns(uint model, uint id) {\r\n        (model, id) = (1, 25);\r\n    }\r\n}\r\n\r\ncontract ImportHelper is Helpers {\r\n    /**\r\n     * @dev Return InstaDApp Mapping Address\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return CETH Address\r\n     */\r\n    function getCETHAddr() internal pure returns (address) {\r\n        return 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n   /**\r\n     * @dev enter compound market\r\n     */\r\n    function enterMarket(address[] memory cErc20) internal {\r\n        ComptrollerInterface(getComptrollerAddress()).enterMarkets(cErc20);\r\n    }\r\n}\r\n\r\ncontract ImportResolver is ImportHelper {\r\n    event LogImport(\r\n        address user,\r\n        uint times,\r\n        address[] cTokens,\r\n        uint[] cTknBals,\r\n        uint[] borrowBals\r\n    );\r\n\r\n    event LogImportPayback(\r\n        address user,\r\n        address token,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    );\r\n\r\n    function ctokenImport(address userAccount, CTokenInterface[] memory ctokenContracts, uint[] memory amts) private {\r\n        for (uint i = 0; i < ctokenContracts.length; i++) {\r\n            if (amts[i] > 0){\r\n                require(ctokenContracts[i].transferFrom(userAccount, address(this), amts[i]), \"allowance?\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function ctokenBorrowPaybackBehalf(address userAccount, CTokenInterface[] memory ctokenContracts, uint[] memory amts) private {\r\n        for (uint i = 0; i < ctokenContracts.length; i++) {\r\n            if (amts[i] > 0) {\r\n                require(CTokenInterface(ctokenContracts[i]).borrow(amts[i]) == 0, \"enough-supply?\");\r\n                getCETHAddr() != address(ctokenContracts[i]) ?\r\n                    require(CTokenInterface(ctokenContracts[i]).repayBorrowBehalf(userAccount, amts[i]) == 0, \"borrowed?-balance?\") :\r\n                    CETHInterface(address(ctokenContracts[i])).repayBorrowBehalf.value(amts[i])(userAccount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _import(\r\n        address userAccount,\r\n        CTokenInterface[] memory ctokenContracts,\r\n        uint[] memory splitBorrowAmts,\r\n        uint[] memory splitCtokensBal,\r\n        uint[] memory borrowAmts,\r\n        uint[] memory ctokensBal,\r\n        uint _length,\r\n        uint _times\r\n    ) internal {\r\n        for (uint i = 0; i < _times; i++) {\r\n            if (i < _times - 1) {\r\n                ctokenBorrowPaybackBehalf(userAccount, ctokenContracts, splitBorrowAmts);\r\n                ctokenImport(userAccount, ctokenContracts, splitCtokensBal);\r\n            } else {\r\n                uint[] memory _borrowAmts = new uint[](_length);\r\n                uint[] memory _ctokensBal = new uint[](_length);\r\n                for (uint j = 0; j < _length; j++) {\r\n                    _borrowAmts[j] = borrowAmts[j] > 0 ?\r\n                        ctokenContracts[j].borrowBalanceCurrent(userAccount) : 0;\r\n                    _ctokensBal[j] = ctokensBal[j] > 0 ?\r\n                        ctokenContracts[j].balanceOf(userAccount): 0;\r\n                }\r\n                ctokenBorrowPaybackBehalf(userAccount, ctokenContracts, _borrowAmts);\r\n                ctokenImport(userAccount, ctokenContracts, _ctokensBal);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Import Compound Position.\r\n    */\r\n    function importCompound(\r\n        address[] calldata tokens,\r\n        uint times\r\n    )\r\n        external\r\n        payable\r\n    {\r\n        address userAccount = msg.sender;\r\n        uint _length = tokens.length;\r\n        require(times > 0 && _length > 0, \"times-0-or-length-0\");\r\n        address[] memory ctokens = new address[](_length);\r\n        uint[] memory borrowAmts = new uint[](_length);\r\n        uint[] memory splitBorrowAmts = new uint[](_length);\r\n        uint[] memory ctokensBal = new uint[](_length);\r\n        uint[] memory splitCtokensBal = new uint[](_length);\r\n\r\n        CTokenInterface[] memory ctokenContracts = new CTokenInterface[](_length);\r\n        InstaMapping instaMap = InstaMapping(getMappingAddr());\r\n        for (uint i = 0; i < _length; i++) {\r\n            ctokens[i] = instaMap.cTokenMapping(tokens[i]);\r\n            require(ctokens[i] != address(0), \"adderss-0\");\r\n            ctokenContracts[i] = CTokenInterface(ctokens[i]);\r\n            ctokensBal[i] = ctokenContracts[i].balanceOf(userAccount);\r\n            splitCtokensBal[i] = ctokensBal[i] / times;\r\n            if (times != 1) {\r\n                borrowAmts[i] = ctokenContracts[i].borrowBalanceCurrent(userAccount);\r\n                if (ctokens[i] != getCETHAddr()) TokenInterface(tokens[i]).approve(ctokens[i], borrowAmts[i]);\r\n                splitBorrowAmts[i] = borrowAmts[i] / (times - 1);\r\n            }\r\n        }\r\n\r\n        enterMarket(ctokens);\r\n        times == 1 ? ctokenImport(userAccount, ctokenContracts, ctokensBal) : ctokenImport(userAccount, ctokenContracts, splitCtokensBal);\r\n\r\n        uint _times = times - 1;\r\n        _import(\r\n            userAccount,\r\n            ctokenContracts,\r\n            splitBorrowAmts,\r\n            splitCtokensBal,\r\n            borrowAmts,\r\n            ctokensBal,\r\n            _length,\r\n            _times\r\n        );\r\n\r\n        emit LogImport(userAccount, times, ctokens, ctokensBal, borrowAmts);\r\n        bytes32 _eventCode = keccak256(\"LogImport(address,uint256,address[],uint256[],uint256[])\");\r\n        bytes memory _eventParam = abi.encode(userAccount, times, ctokens, ctokensBal, borrowAmts);\r\n        emitEvent(_eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Payback User Account Compound Debt\r\n    */\r\n    function importPaybackBehalf(\r\n        address token,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable {\r\n        address userAccount = msg.sender;\r\n        uint _amt = getUint(getId, amt);\r\n        if (amt > 0) {\r\n            InstaMapping instaMap = InstaMapping(getMappingAddr());\r\n            address cToken = instaMap.cTokenMapping(token);\r\n            CTokenInterface ctokenContract = CTokenInterface(cToken);\r\n            require(cToken != address(0), \"adderss-0\");\r\n            _amt = amt == uint(-1) ?\r\n                ctokenContract.borrowBalanceCurrent(userAccount) : amt;\r\n            if (cToken != getCETHAddr()) {\r\n                TokenInterface(token).approve(cToken, _amt);\r\n                require(ctokenContract.repayBorrowBehalf(userAccount, _amt) == 0, \"borrowed?-balance?\");\r\n            } else {\r\n                CETHInterface(cToken).repayBorrowBehalf.value(_amt)(userAccount);\r\n            }\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogImportPayback(userAccount, token, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogImportPayback(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(userAccount, token, _amt, getId, setId);\r\n        emitEvent(_eventCode, _eventParam);\r\n    }\r\n\r\n}\r\n\r\ncontract ConnectCompoundImport is ImportResolver {\r\n    string public name = \"Import-v1.1\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"cTknBals\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"borrowBals\",\"type\":\"uint256[]\"}],\"name\":\"LogImport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogImportPayback\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"model\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"importCompound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"importPaybackBehalf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConnectCompoundImport","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8cdf05452ade4e63748141047bd2beda4344409e7e111541fa7b7fee2f729441"}]}