{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) external returns (bool success);\r\n    function approve(address spender, uint256 tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\r\n}\r\n\r\n\r\ninterface IYFKA {\r\n    function mint(address to, uint256 amount) external;\r\n    function transferOwnership(address newOwner) external;\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n}\r\n\r\ncontract YFKAController is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20[3] pools;\r\n    \r\n    mapping(uint8 => mapping(address => uint256)) public lastBlockWithdrawn;\r\n    mapping(uint8 => mapping(address => uint256)) public personalEmissions;\r\n\r\n\r\n    IYFKA public yfka = IYFKA(0x4086692D53262b2Be0b13909D804F0491FF6Ec3e);\r\n    \r\n    uint256 public multiplier = 2; \r\n    \r\n    mapping(uint8 => mapping(address => uint256)) public stakes;\r\n    mapping(uint8 => uint256) public totalStakes;\r\n    \r\n    // Current Emission Rate / \r\n    uint256 public emissionRate = 2 * (10 ** 18); // YFKA reward per YFKA staked per year\r\n    \r\n    uint256 public minimum_stake = 2 * (10**17); //0.2 YFKA required to stake\r\n    uint256 public blocks_per_year = 2372500;\r\n    \r\n    uint256 public decayPercent =  999998;\r\n    uint256 public decayDivisor = 1000000;\r\n    \r\n    uint256 public lastBlockUpdated = block.number;\r\n    \r\n    /*\r\n    SET TOKEN\r\n    Given an index and an address, this stores the ERC20 contract object of the token you want to support in your pool\r\n    Parameters:\r\n        idx: Index of the pool to set.\r\n        _addr: Address of the token you want to pool.\r\n    Returns:\r\n        None\r\n    \r\n    */\r\n    function setPool(uint8 idx, address _addr) public onlyOwner {\r\n        pools[idx] = IERC20(_addr);\r\n    }\r\n\r\n    function transferOwnershipOfYFKA(address _addr) public onlyOwner {\r\n        yfka.transferOwnership(_addr);\r\n    }\r\n\r\n    /*\r\n    GET POINTS FOR STAKE\r\n    Calculates the 'points' an owner has for a particular pool. Used to calculate how much of a reward to mint.\r\n    Parameters:\r\n        idx: Index of the pool to set.\r\n        stake: The amount of stake.\r\n    Returns:\r\n        points: Number of points\r\n    */\r\n    uint precision = 1000000;\r\n    function getPointsForStake(uint8 idx, uint256 stake) public view returns(uint points) {\r\n        uint percentOfLPStaked = stakes[idx][msg.sender].mul(precision).div(pools[idx].totalSupply());\r\n        \r\n        uint256 yfkaInPool = yfka.balanceOf(address(pools[idx]));\r\n        \r\n        // User tokens staked / total tokens available = % of supply staked\r\n        // Stake * yfkaInPool = YFKA staked\r\n\r\n        uint256 _yfkaStake = yfkaInPool.mul(percentOfLPStaked).div(precision);\r\n\r\n        return _yfkaStake;\r\n    }\r\n    \r\n\r\n    // Returns the pool with the highest stake amount\r\n    function getActivePool() public view returns (uint8 idx) {\r\n        uint256[3] memory maxStakes;\r\n        maxStakes[0] = getPointsForStake(0, pools[0].balanceOf(address(this)));\r\n        maxStakes[1] = getPointsForStake(1, pools[1].balanceOf(address(this)));\r\n        maxStakes[2] = getPointsForStake(2, pools[2].balanceOf(address(this)));\r\n        \r\n        if ((maxStakes[0] >= maxStakes[1]) && (maxStakes[0] >= maxStakes[2])) {\r\n            return 0;\r\n        }\r\n        else if ((maxStakes[1] >= maxStakes[0]) && (maxStakes[1] >= maxStakes[2])) {\r\n            return 1;\r\n        }\r\n        return 2;\r\n    }\r\n\r\n    // LOGIC CALLED WHEN STAKING / UNSTAKING / WITHDRAWING FROM A POOL\r\n\r\n    // Emission rate variables\r\n    function _getNextRateReduction() internal view returns(uint256) {\r\n        uint256 absoluteRate = emissionRate.mul(decayPercent).div(decayDivisor);\r\n        return emissionRate.sub(absoluteRate);\r\n    }\r\n\r\n    function _getBlocksSinceLastReduction() internal view returns(uint256) {\r\n        uint256 last = block.number.sub(lastBlockUpdated);\r\n        if (last > 5000) {\r\n            return 5000;\r\n        }\r\n        return last;\r\n        \r\n    }\r\n    \r\n    function _getTotalNextRateReduction() internal view returns(uint256) {\r\n        return _getNextRateReduction().mul(_getBlocksSinceLastReduction());\r\n    }\r\n    \r\n    // stake/ withdraw until 156 blocks have passed\r\n    function updateEmissionRate() internal {\r\n        if (_getTotalNextRateReduction() < emissionRate) {\r\n            emissionRate = emissionRate.sub(_getTotalNextRateReduction());\r\n            lastBlockUpdated = block.number;\r\n        }\r\n        \r\n    }\r\n    \r\n    function getPersonalEmissionRate(uint8 idx, address _addr) public view returns (uint256) {\r\n        return personalEmissions[idx][_addr];\r\n    }\r\n\r\n    function setPersonalEmissionRate(uint8 idx, address _addr) internal {\r\n        personalEmissions[idx][_addr] = emissionRate;\r\n    }\r\n\r\n    function increaseStake(uint8 idx, uint256 amount) internal {\r\n        pools[idx].transferFrom(msg.sender, address(this), amount);\r\n        stakes[idx][msg.sender] = stakes[idx][msg.sender].add(amount);\r\n        totalStakes[idx] = totalStakes[idx].add(amount);\r\n    }\r\n\r\n    function decreaseStake(uint8 idx, uint256 amount) internal {\r\n        totalStakes[idx] = totalStakes[idx].sub(amount);\r\n        stakes[idx][msg.sender] = stakes[idx][msg.sender].sub(amount);\r\n        pools[idx].transfer(msg.sender, amount);\r\n    }\r\n\r\n    function stake(uint8 idx, uint256 amount) onlyOwner public {\r\n        // If the emission rate has not been set, set it to the current rate\r\n        // 10**3 == MINIMUM_LIQUIDITY of the uniswap token \r\n        \r\n        require(amount > minimum_stake);\r\n        \r\n        amount = amount.sub(10**3);\r\n        \r\n        if (getPersonalEmissionRate(idx, msg.sender) == 0) {\r\n            setPersonalEmissionRate(idx, msg.sender);\r\n        }\r\n\r\n        // Mint before adding stake\r\n        mint(idx, false);\r\n        \r\n        // Add to stake\r\n        increaseStake(idx, amount);\r\n    }\r\n    \r\n    function unstake(uint8 idx, uint256 amount) public {\r\n        // Mint and update global and personal rate\r\n        amount = amount.sub(10**3);\r\n        \r\n        mint(idx, true);\r\n\r\n        // Subtract stake first before sending any tokens back. Will throw if invalid amount provided.\r\n        decreaseStake(idx, amount);\r\n    }\r\n    \r\n    // redeem idxs w/o unstaking\r\n    function redeem(uint8 idx) public {\r\n        // Mint and update global and personal rate\r\n        mint(idx, true);\r\n    }\r\n\r\n    /*\r\n    LAST BLOCK WITHDRAWN\r\n    Mapping of pool index and wallet public key to block number\r\n    This is used to determine the time between the last withdraw event and the current withdraw event.\r\n    The duration of time in blocks is then multiplied by the \r\n    */\r\n\r\n    function getLastBlockWithdrawn(uint8 idx) public view returns (uint256) {\r\n        uint256 lbw = lastBlockWithdrawn[idx][msg.sender];\r\n        if (lbw == 0) {\r\n            lbw = block.number;\r\n        }\r\n\r\n        return lbw;\r\n    }\r\n    \r\n    function setLastBlockWithdrawn(uint8 idx) internal {\r\n        lastBlockWithdrawn[idx][msg.sender] = block.number;\r\n    }\r\n    \r\n    function getCurrentReward(uint8 idx) public view returns (uint256 reward) {\r\n        uint256 blockDifference = block.number.sub(getLastBlockWithdrawn(idx));\r\n        uint amount = getPointsForStake(idx, stakes[idx][msg.sender]).mul(getPersonalEmissionRate(idx, msg.sender)).mul(blockDifference).div(blocks_per_year);\r\n        \r\n        if (idx == getActivePool()) {\r\n            amount = amount.mul(multiplier);\r\n        }\r\n        \r\n        return amount;\r\n\r\n    }\r\n    \r\n    function mint(uint8 idx, bool update) internal {\r\n        uint256 mintAmount = getCurrentReward(idx); \r\n        \r\n        // Apply mint\r\n        yfka.mint(msg.sender, mintAmount);\r\n        \r\n        if(emissionRate != 0){\r\n            updateEmissionRate();\r\n        }\r\n        \r\n        setLastBlockWithdrawn(idx);\r\n        if(update) {    \r\n           setPersonalEmissionRate(idx, msg.sender);\r\n        }\r\n        \r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocks_per_year\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decayDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decayPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActivePool\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"}],\"name\":\"getCurrentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"}],\"name\":\"getLastBlockWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPersonalEmissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"getPointsForStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlockUpdated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlockWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimum_stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"personalEmissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"transferOwnershipOfYFKA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"idx\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yfka\",\"outputs\":[{\"internalType\":\"contract IYFKA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"YFKAController","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://14303a54260b17df1f5030f50dd04f9dd60de01f7e9d70604797baac15039854"}]}