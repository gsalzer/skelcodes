{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/Interfaces/OracleInterface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\ninterface OracleInterface {\r\n    function latestPrice() external returns (uint256);\r\n\r\n    function getVolatility() external returns (uint256);\r\n\r\n    function latestId() external returns (uint256);\r\n}\r\n\r\n// File: contracts/Interfaces/SpreadCalculatorInterface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\ninterface SpreadCalculatorInterface {\r\n    function calculateCurrentSpread(\r\n        uint256 _maturity,\r\n        uint256 _strikePrice,\r\n        OracleInterface oracle\r\n    ) external returns (uint128);\r\n\r\n    function calculateSpreadByAssetVolatility(OracleInterface oracle)\r\n        external\r\n        returns (uint128);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Libraries/RateMath.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\nlibrary RateMath {\r\n    using SafeMath for uint256;\r\n    uint256 public constant RATE_POINT_MULTIPLIER = 1000000000000000000; // 10^18\r\n\r\n    function getRate(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a.mul(RATE_POINT_MULTIPLIER).div(b);\r\n    }\r\n\r\n    function divByRate(uint256 self, uint256 rate)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return self.mul(RATE_POINT_MULTIPLIER).div(rate);\r\n    }\r\n\r\n    function mulByRate(uint256 self, uint256 rate)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return self.mul(rate).div(RATE_POINT_MULTIPLIER);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SpreadCalculator.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SpreadCalculator is SpreadCalculatorInterface {\r\n    using RateMath for uint256;\r\n    using SafeMath for uint256;\r\n    using SafeCast for uint256;\r\n\r\n    uint256 public constant SPREAD_RATE = 3000000000000000; //= 0.3%\r\n    uint256 public constant DECIMAL = 1000000000000000000;\r\n    uint256 public constant TEN_DIGITS = 10000000000;\r\n    uint256\r\n        public constant MAX_RATIONAL_ORACLE_VALUE = 100000000000000000000000; // too much volatility or ETH price\r\n\r\n    // parameters of approximate expression of Black-Scholes equation that calculates LBT volatility\r\n    // 'X4' is unused parameter because minimum spread rate is 0.3 %\r\n    uint256 public constant ALPHA1 = 6085926862470381000;\r\n    uint256 public constant ALPHA2 = 2931875257585468700;\r\n    uint256 public constant MAX_EXECUTE_ACCOUNT = 5;\r\n    uint256 public constant ALPHA3 = 2218732501079067300;\r\n    int256 public constant BETA1 = 1406874237416828400;\r\n    int256 public constant BETA2 = 1756430504093997600;\r\n    int256 public constant BETA3 = 2434962998012975000;\r\n    uint256 public constant COEF1 = 226698973741174460000;\r\n    uint256 public constant COEF2 = 14143621388702120000;\r\n    uint256 public constant COEF3 = 3191869733673552600;\r\n    //uint256 public constant COEF4 = 194954040017071670;\r\n    uint256 public constant COEFSIG1 = 1332906524709810000000;\r\n    uint256 public constant COEFSIG2 = 39310196066041410000;\r\n    uint256 public constant COEFSIG3 = 7201026361442427000;\r\n    //uint256 public constant COEFSIG4 = 551672108932873900;\r\n    uint256 public constant INTERCEPT1 = 327997870106653860000;\r\n    uint256 public constant INTERCEPT2 = 28959220856904096000;\r\n    uint256 public constant INTERCEPT3 = 9723230176749988000;\r\n    //uint256 public constant INTERCEPT4 = 2425851354532068300;\r\n    uint256 public constant ROOTEDYEARINSECOND = 5615;\r\n    event CalculateSpread(\r\n        uint256 indexed price,\r\n        uint256 indexed volatility,\r\n        uint256 indexed spread\r\n    );\r\n\r\n    /**\r\n     * @notice Spread rate calculation\r\n     * @param maturity Maturity of option token\r\n     * @param strikePrice Strikeprice of option token\r\n     * @return spreadRate Spread rate of this option token\r\n     * @dev S/K is Price of ETH / strikeprice\r\n     * @dev Spread is difined by volatility of LBT which is approached by linear equation (intercept - coef * S/K - coefsig * vol * t^0.5)\r\n     * @dev Coefficient and intercept of linear equation are determined by S/K(and alpha - beta * vol * t^0.5)\r\n     **/\r\n    function calculateCurrentSpread(\r\n        uint256 maturity,\r\n        uint256 strikePrice,\r\n        OracleInterface oracle\r\n    ) external override returns (uint128) {\r\n        uint256 spreadRate = SPREAD_RATE;\r\n        if (address(oracle) == address(0)) {\r\n            emit CalculateSpread(0, 0, spreadRate);\r\n            return uint128(spreadRate);\r\n        }\r\n        uint256 ethPrice = oracle.latestPrice().mul(TEN_DIGITS);\r\n        uint256 volatility = oracle.getVolatility().mul(TEN_DIGITS);\r\n\r\n        if (\r\n            ethPrice > MAX_RATIONAL_ORACLE_VALUE ||\r\n            volatility > MAX_RATIONAL_ORACLE_VALUE\r\n        ) {\r\n            emit CalculateSpread(ethPrice, volatility, spreadRate);\r\n            return uint128(spreadRate);\r\n        }\r\n        uint256 time = (_sqrt(maturity - block.timestamp).mul(DECIMAL)).div(\r\n            ROOTEDYEARINSECOND\r\n        );\r\n        uint256 sigTime = volatility.mulByRate(time);\r\n        uint256 ratio = ethPrice.divByRate(strikePrice);\r\n        if (int256(ratio) <= BETA1 - int256(ALPHA1.mulByRate(sigTime))) {\r\n            spreadRate = (\r\n                SPREAD_RATE.mulByRate(\r\n                    _caluculateZ(COEF1, COEFSIG1, INTERCEPT1, ratio, sigTime)\r\n                )\r\n            );\r\n        } else if (int256(ratio) <= BETA2 - int256(ALPHA2.mulByRate(sigTime))) {\r\n            spreadRate = (\r\n                SPREAD_RATE.mulByRate(\r\n                    _caluculateZ(COEF2, COEFSIG2, INTERCEPT2, ratio, sigTime)\r\n                )\r\n            );\r\n        } else if (int256(ratio) <= BETA3 - int256(ALPHA3.mulByRate(sigTime))) {\r\n            spreadRate = (\r\n                SPREAD_RATE.mulByRate(\r\n                    _caluculateZ(COEF3, COEFSIG3, INTERCEPT3, ratio, sigTime)\r\n                )\r\n            );\r\n        }\r\n        emit CalculateSpread(ethPrice, volatility, spreadRate);\r\n        return spreadRate.toUint128();\r\n        // if S/K is under first tolerance difined by COEF4, COEFSIG4, INTERCEPT4, returns 0.3%\r\n        /*\r\n        else {\r\n            uint256 spreadRate = SPREAD_RATE.mulByRate(_caluculateZ(COEF4, COEFSIG4, INTERCEPT4, ratio, sigTime));\r\n            return uint64(spreadRate);\r\n        }\r\n        return uint64(SPREAD_RATE);\r\n        */\r\n    }\r\n\r\n    /**\r\n     * @notice If volatility of asset pair is over 200%, spread rate becomes variable\r\n     **/\r\n    function calculateSpreadByAssetVolatility(OracleInterface oracle)\r\n        external\r\n        override\r\n        returns (uint128)\r\n    {\r\n        if (address(oracle) == address(0)) {\r\n            return uint128(SPREAD_RATE);\r\n        }\r\n        uint256 volatility = oracle.getVolatility().mul(TEN_DIGITS);\r\n        if ((DECIMAL * 100) > volatility && (DECIMAL * 2) < volatility) {\r\n            return SPREAD_RATE.mulByRate(volatility).div(2).toUint128();\r\n        } else if (DECIMAL * 100 <= volatility) {\r\n            return uint128(SPREAD_RATE * 50);\r\n        }\r\n        return uint128(SPREAD_RATE);\r\n    }\r\n\r\n    /**\r\n     * @notice Approximate expression of option token volatility\r\n     * @param coef Coefficient of S/K in the linear equation\r\n     * @param coefsig Coefficient of vol * t^0.5 in the linear equation\r\n     * @param intercept Intercept in the linear equation\r\n     * @param ratio S/K\r\n     * @param sigTime vol * t^0.5\r\n     * @dev Spread is difined by volatility of LBT which is approached by linear equation (intercept - coef * S/K - coefsig * vol * t^0.5)\r\n     * @dev Coefficient and intercept of linear equation is determined by S/k(and alpha - beta * vol * t^0.5)\r\n     * @dev spread = 0.3 * v / 2\r\n     **/\r\n    function _caluculateZ(\r\n        uint256 coef,\r\n        uint256 coefsig,\r\n        uint256 intercept,\r\n        uint256 ratio,\r\n        uint256 sigTime\r\n    ) private pure returns (uint256) {\r\n        uint256 z = intercept.sub(ratio.mulByRate(coef)).sub(\r\n            sigTime.mulByRate(coefsig)\r\n        );\r\n        if (z <= 2 * DECIMAL) {\r\n            return DECIMAL;\r\n        } else if (z >= DECIMAL.mul(100)) {\r\n            return DECIMAL * 50;\r\n        }\r\n        return z.div(2);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate square root of uint\r\n     **/\r\n    function _sqrt(uint256 x) private pure returns (uint256 y) {\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"spread\",\"type\":\"uint256\"}],\"name\":\"CalculateSpread\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ALPHA1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ALPHA2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ALPHA3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BETA1\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BETA2\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BETA3\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COEF1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COEF2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COEF3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COEFSIG1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COEFSIG2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COEFSIG3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERCEPT1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERCEPT2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERCEPT3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EXECUTE_ACCOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RATIONAL_ORACLE_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOTEDYEARINSECOND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SPREAD_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEN_DIGITS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"contract OracleInterface\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"calculateCurrentSpread\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract OracleInterface\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"calculateSpreadByAssetVolatility\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SpreadCalculator","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c1dc4d57c5b2874a80d5914c847b6258f542785b6704670899e2a731ce21f094"}]}