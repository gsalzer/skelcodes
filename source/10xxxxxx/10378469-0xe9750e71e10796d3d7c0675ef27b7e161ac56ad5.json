{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/DivideContract.sol\r\n\r\npragma solidity >=0.5.10 <0.6.0;\r\n\r\n\r\n\r\ncontract DivideContract {\r\n  using SafeMath for uint256;\r\n\r\n  address owner;\r\n  mapping(address => bool) operators;\r\n  uint256 public NUM_RECIPIENTS = 2;\r\n  uint256 public PRECISION = 10000;\r\n  RecipientList recipientList;\r\n  address public nftAddress;\r\n\r\n  struct RecipientList {\r\n    address payable[] available_recipients;\r\n    uint256[] ratios;\r\n  }\r\n\r\n  event OperatorChanged(\r\n    address indexed operator,\r\n    bool action\r\n  );\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 amount,\r\n    uint256 totalAmount\r\n  );\r\n\r\n  event RecipientsInfoChanged(\r\n    bool action,\r\n    address payable[] recipients,\r\n    uint256[] ratios\r\n  );\r\n\r\n  modifier isOwner() {\r\n    require(msg.sender == owner, 'No permissions');\r\n    _;\r\n  }\r\n\r\n  modifier isOperator() {\r\n    require(operators[msg.sender] || msg.sender == owner, 'No permissions');\r\n    _;\r\n  }\r\n\r\n  constructor(address _nftAddress) public {\r\n    require(_nftAddress != address(0)); // Do not allow 0 addresses\r\n    owner = msg.sender;\r\n    nftAddress = _nftAddress;\r\n  }\r\n\r\n  // Calculate the sum of an array\r\n  function arraySum(uint256[] memory data) private pure returns (uint256) {\r\n    uint256 res;\r\n    for (uint256 i; i < data.length; i++) {\r\n      res = res.add(data[i]);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function getOwner() public view returns (address) {\r\n    return owner;\r\n  }\r\n\r\n  // Check if operator is in mapping for js tests\r\n  function operatorExists (address entity) public view returns (bool) {\r\n    return operators[entity];\r\n  }\r\n\r\n  function assignOperator (address entity) public isOwner() {\r\n    require(entity != address(0), 'Target is invalid addresses');\r\n    require(!operatorExists(entity), 'Target is already an operator');\r\n    emit OperatorChanged(entity, true);\r\n    operators[entity] = true;\r\n  }\r\n\r\n  function removeOperator (address entity) public isOwner() {\r\n    require(entity != address(0), 'Target is invalid addresses');\r\n    require(operatorExists(entity), 'Target is not an operator');\r\n    emit OperatorChanged(entity, false);\r\n    operators[entity] = false;\r\n  }\r\n\r\n  // Save all recipients and their corresponding ratios\r\n  // In: array of recipients, integer array of ratios\r\n  function registerRecipientsInfo (address payable[] memory recipients, uint256[] memory ratio) public isOperator() returns (bool) {\r\n    require(arraySum(ratio) == PRECISION, 'Total sum of ratio must be 100%');\r\n    require(recipients.length == ratio.length, 'Incorrect data size');\r\n    require(recipients.length == NUM_RECIPIENTS, 'Incorrect number of recipients');\r\n\r\n    recipientList = RecipientList(recipients, ratio);\r\n    emit RecipientsInfoChanged(true, recipients, ratio);\r\n    return true;\r\n  }\r\n\r\n  // Get info about nft platform recipients\r\n  // Out: nft platfor address, available recipients, ratios\r\n  function getRecipientsInfo() public view isOperator() returns (address, address payable[] memory, uint256[] memory) {\r\n    return (nftAddress, recipientList.available_recipients, recipientList.ratios);\r\n  }\r\n\r\n  function deleteRecipientsInfo () public isOperator() {\r\n    require(recipientList.available_recipients.length > 0, 'No recipients registered');\r\n    emit RecipientsInfoChanged(false, recipientList.available_recipients, recipientList.ratios);\r\n    delete recipientList;\r\n  }\r\n\r\n  function calculateAmount(uint256 fee_received, uint256 ratio) private view returns (uint256) {\r\n    return (fee_received.mul(ratio).div(PRECISION));\r\n  }\r\n\r\n\r\n  // Divides any ether coming to this contract by their ratios and send the amounts to each recipient.\r\n  // Last recipient gets also everything that was left by division errors\r\n  function () external payable {\r\n    require(recipientList.available_recipients.length == NUM_RECIPIENTS, 'No recipients registered');\r\n\r\n    uint256 amount1 = calculateAmount(msg.value, recipientList.ratios[0]);\r\n    address payable toWallet1 = recipientList.available_recipients[0];\r\n    toWallet1.transfer(amount1);\r\n    emit Transfer(msg.sender, toWallet1, amount1, msg.value);\r\n\r\n    // Send all what is left to last recipient to avoid stuck ether\r\n    uint256 amount2 = address(this).balance;\r\n    address payable toWallet2 = recipientList.available_recipients[1];\r\n    toWallet2.transfer(amount2);\r\n    emit Transfer(msg.sender, toWallet2, amount2, msg.value);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"action\",\"type\":\"bool\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"action\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ratios\",\"type\":\"uint256[]\"}],\"name\":\"RecipientsInfoChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"NUM_RECIPIENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"}],\"name\":\"assignOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deleteRecipientsInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecipientsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"}],\"name\":\"operatorExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratio\",\"type\":\"uint256[]\"}],\"name\":\"registerRecipientsInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DivideContract","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f915bbfbb6c097dc327e64eec55e9ef4d110d627","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3128306cf6dfcaf89045365687745679be52d6e2f5c586999c0fb4c312bfb622"}]}