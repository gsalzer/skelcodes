{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4 .25;\r\n\r\n/**\r\n *      /$$$$$                       /$$           /$$$$$$$                     \r\n *     |__  $$                      | $$          | $$__  $$                    \r\n *        | $$ /$$   /$$  /$$$$$$$ /$$$$$$        | $$  \\ $$ /$$   /$$ /$$$$$$$ \r\n *        | $$| $$  | $$ /$$_____/|_  $$_/        | $$$$$$$/| $$  | $$| $$__  $$\r\n *   /$$  | $$| $$  | $$|  $$$$$$   | $$          | $$__  $$| $$  | $$| $$  \\ $$\r\n *  | $$  | $$| $$  | $$ \\____  $$  | $$ /$$      | $$  \\ $$| $$  | $$| $$  | $$\r\n *  |  $$$$$$/|  $$$$$$/ /$$$$$$$/  |  $$$$/      | $$  | $$|  $$$$$$/| $$  | $$\r\n *   \\______/  \\______/ |_______/    \\___/        |__/  |__/ \\______/ |__/  |__/\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without \r\n * express written consent from the creators is prohibited.\r\n * Get touch with us justrunio2020@gmail.com\r\n * WARNING:  THIS PRODUCT IS HIGHLY ADDICTIVE.  IF YOU HAVE AN ADDICTIVE NATURE.  DO NOT PLAY.\r\n */\r\npragma solidity ^ 0.4 .24;\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    require(c / a == b, \"SafeMath mul failed\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    require(b <= a, \"SafeMath sub failed\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"SafeMath add failed\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev gives square root of given x.\r\n   */\r\n  function sqrt(uint256 x)\r\n  internal\r\n  pure\r\n  returns(uint256 y) {\r\n    uint256 z = ((add(x, 1)) / 2);\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = ((add((x / z), z)) / 2);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev gives square. multiplies x by x\r\n   */\r\n  function sq(uint256 x)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    return (mul(x, x));\r\n  }\r\n\r\n  /**\r\n   * @dev x to the power of y \r\n   */\r\n  function pwr(uint256 x, uint256 y)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    if (x == 0)\r\n      return (0);\r\n    else if (y == 0)\r\n      return (1);\r\n    else {\r\n      uint256 z = x;\r\n      for (uint256 i = 1; i < y; i++)\r\n        z = mul(z, x);\r\n      return (z);\r\n    }\r\n  }\r\n}\r\n\r\n\r\npragma solidity 0.4 .25;\r\n\r\nlibrary Data {\r\n\r\n  struct Player {\r\n\r\n    uint signInTime;\r\n\r\n    uint signInDay;\r\n\r\n    uint consume;\r\n\r\n    uint dynamicIncome;\r\n\r\n    uint totalEth;\r\n\r\n    uint sellIncome;\r\n\r\n    bool isNew;\r\n\r\n    bool isExist;\r\n\r\n    address superiorAddr;\r\n\r\n    address[] subordinateAddr;\r\n  }\r\n\r\n  struct PlayerData {\r\n\r\n    uint wallet;\r\n\r\n    uint runIncome;\r\n\r\n    uint withdrawnIncome;\r\n\r\n    uint totalPerformance;\r\n\r\n    uint settledLotteryIncome;\r\n  }\r\n\r\n  struct Run {\r\n\r\n    uint runPool;\r\n\r\n    uint endTime;\r\n\r\n    uint totalConsume;\r\n\r\n    uint record;\r\n\r\n    uint count;\r\n\r\n    uint num;\r\n\r\n    uint count2;\r\n\r\n    uint totalEth;\r\n\r\n    uint[] recordArr;\r\n\r\n    address lastAddr;\r\n\r\n    address[] lastAddrs;\r\n\r\n    mapping(address => uint) plyrMask;\r\n\r\n    mapping(address => uint) consumeMap;\r\n\r\n    mapping(address => uint) personalEth;\r\n  }\r\n\r\n  struct Scratch {\r\n\r\n    uint prizeNumber;\r\n\r\n    mapping(address => mapping(uint => uint)) roundIncome;\r\n\r\n    mapping(address => mapping(uint => uint[])) numberMap;\r\n\r\n    mapping(address => mapping(uint => uint[])) ethMap;\r\n\r\n    mapping(address => mapping(uint => uint[])) winMap;\r\n  }\r\n\r\n  struct Lottery {\r\n\r\n    uint lotteryPool;\r\n\r\n    uint unopenedBonus;\r\n\r\n    uint number;\r\n\r\n    uint time;\r\n\r\n    uint tokenNumber;\r\n\r\n    mapping(uint => uint[]) winNumber;\r\n\r\n    mapping(address => uint[]) lotteryMap;\r\n\r\n    mapping(uint => uint) awardAmount;\r\n  }\r\n\r\n  struct SaleQueue {\r\n\r\n    address addr;\r\n\r\n    uint tokenNumber;\r\n\r\n    uint remainingAmount;\r\n\r\n  }\r\n\r\n  struct PersonalSaleInfo {\r\n\r\n    uint tokenNumber;\r\n\r\n    uint saleNumber;\r\n  }\r\n\r\n  function rand(uint256 _length, uint256 num, uint256 salt) internal view returns(uint256) {\r\n    uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, num, salt)));\r\n    return random % _length;\r\n  }\r\n\r\n  function returnArray(uint len, uint range, uint number, uint salt) internal view returns(uint[]) {\r\n    uint[] memory numberArray = new uint[](len);\r\n    uint i = 0;\r\n    while (true) {\r\n      number = number + 9;\r\n      uint temp = rand(range, number, salt);\r\n      if (temp == 0) {\r\n        continue;\r\n      }\r\n      numberArray[i] = temp;\r\n      i++;\r\n      if (i == len) {\r\n        break;\r\n      }\r\n    }\r\n    return numberArray;\r\n  }\r\n\r\n  function generatePrizeNumber(uint256 seed, uint256 salt) internal view returns(uint) {\r\n    uint number = 0;\r\n    while (number < 10000) {\r\n      seed++;\r\n      number = rand(100000, seed, salt);\r\n    }\r\n    return number;\r\n  }\r\n}\r\n\r\n\r\ncontract JustRun {\r\n\r\n  address owner;\r\n  address exAddr;\r\n  address techAddr;\r\n  address lotteryAddr;\r\n  uint recordId = 0;\r\n  uint public rid = 1;\r\n  // uint timeInterval = 24 * 60 * 60;\r\n  uint timeInterval = 15 * 60;\r\n  bool active = false;\r\n  uint[] numArr;\r\n  address[] inVain = new address[](6);\r\n\r\n  TokenRun token;\r\n  ExRun ex;\r\n  LotteryRun lottery;\r\n\r\n  mapping(address => Data.PlayerData) dataMap;\r\n  mapping(uint => Data.Run) public runGame;\r\n  mapping(uint => uint) roundMask;\r\n\r\n  constructor(\r\n    address _ownerAddr,\r\n    address _tokenAddr,\r\n    address _exAddr,\r\n    address _techAddr\r\n  ) public {\r\n    owner = _ownerAddr;\r\n    token = TokenRun(_tokenAddr);\r\n    ex = ExRun(_exAddr);\r\n    exAddr = _exAddr;\r\n    techAddr = _techAddr;\r\n  }\r\n  /** Send ETH to join runGame (Make sure you have enough run token)\r\n   *\tSend 0eth withdraw your all ETH\r\n   */\r\n  function() public payable {\r\n    uint _eth = msg.value;\r\n    bool flag = isContract(msg.sender);\r\n    if (!flag) {\r\n      if (_eth > 0) {\r\n        participateCore(msg.sender, address(0x0), _eth);\r\n      } else {\r\n        withdrawCore(msg.sender, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  function isContract(address _addr) private view returns(bool) {\r\n    uint size;\r\n    assembly {\r\n      size: = extcodesize(_addr)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  /** Join Run core logic */\r\n  function participateCore(address addr, address superiorAddr, uint _eth) private {\r\n    require(_eth >= 10 ** 17, \"Participate in run at least 0.1eth\");\r\n    require(token.balanceOf(addr) >= token.calcTokenRequired(_eth), \"not enough token\");\r\n    ex.externalRegister(addr, superiorAddr);\r\n    uint _now = now;\r\n    if (_now < runGame[rid].endTime) {\r\n      /**Run core logic */\r\n      runCore(addr, _eth);\r\n    } else {\r\n      /**End the run and start one new run */\r\n      endRound(addr, _eth);\r\n    }\r\n  }\r\n\r\n  function calcAllIncome() private view returns(uint) {\r\n    uint totalIncome = 0;\r\n    for (uint i = 1; i <= rid; i++) {\r\n      uint totalEth = runGame[i].personalEth[msg.sender];\r\n      uint income = calcIncome(i);\r\n      totalEth = SafeMath.mul(totalEth, 2);\r\n      if (income > totalEth) {\r\n        totalIncome = SafeMath.add(totalIncome, totalEth);\r\n      } else {\r\n        totalIncome = SafeMath.add(totalIncome, income);\r\n      }\r\n    }\r\n\r\n    return totalIncome;\r\n  }\r\n\r\n  /** Calc player's Income */\r\n  function calcIncome(uint roundID) private view returns(uint) {\r\n    Data.Run storage run = runGame[roundID];\r\n    uint totalIncome = SafeMath.sub(SafeMath.mul(roundMask[roundID], run.consumeMap[msg.sender]), run.plyrMask[msg.sender]);\r\n    return totalIncome;\r\n  }\r\n\r\n  function getTotalIncome() private view returns(uint) {\r\n    Data.PlayerData storage pd = dataMap[msg.sender];\r\n    return SafeMath.add(calcAllIncome(), pd.wallet);\r\n  }\r\n\r\n  function withdrawCore(address addr, uint _eth) private {\r\n    Data.PlayerData storage pd = dataMap[addr];\r\n    uint lotteryIncome = lottery.getAllLotteryIncome(addr, true);\r\n    pd.settledLotteryIncome = SafeMath.add(pd.settledLotteryIncome, lotteryIncome);\r\n    pd.wallet = SafeMath.add(pd.wallet, lotteryIncome);\r\n    uint income = getTotalIncome();\r\n    income = SafeMath.sub(income, pd.withdrawnIncome);\r\n    require(income > _eth, \"balance Insufficient\");\r\n    if (_eth == 0) {\r\n      _eth = income;\r\n    }\r\n    uint handlingFee = lottery.deductionFee(addr, _eth);\r\n    pd.withdrawnIncome = SafeMath.add(pd.withdrawnIncome, _eth);\r\n    _eth = SafeMath.sub(_eth, handlingFee);\r\n    addr.transfer(_eth);\r\n  }\r\n\r\n  /**Run core logic */\r\n  function runCore(address addr, uint _eth) private {\r\n    Data.Run storage run = runGame[rid];\r\n    runOperation(addr, _eth);\r\n    address superiorAddr = ex.getSuperiorAddr(addr);\r\n    uint number = SafeMath.div(_eth, 10);\r\n    uint number3 = SafeMath.div(SafeMath.mul(_eth, 3), 100);\r\n    uint number7 = SafeMath.div(SafeMath.mul(_eth, 7), 100);\r\n    run.runPool = SafeMath.add(number, run.runPool);\r\n    ex.buyTokenByRun(address(0x0), number);\r\n    if (superiorAddr != address(0x0)) {\r\n      uint subEth = ex.getPlayerTotalEth(addr);\r\n      uint superEth = ex.getPlayerTotalEth(superiorAddr);\r\n      uint num = SafeMath.div(superEth * 10 ** 8, subEth);\r\n      if (num < 10000000) {\r\n        uint temp = number;\r\n        number = SafeMath.div(SafeMath.mul(num, number), 10 ** 7);\r\n        dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, SafeMath.sub(temp, number));\r\n      }\r\n      dataMap[superiorAddr].wallet = SafeMath.add(dataMap[superiorAddr].wallet, number);\r\n      ex.updateDynamicIncome(superiorAddr, number);\r\n    } else {\r\n      dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, number);\r\n    }\r\n\r\n    lottery.updateLotteryPool(number7);\r\n    dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, number3);\r\n\r\n  }\r\n\r\n  function runOperation(address addr, uint _eth) private {\r\n    Data.Run storage run = runGame[rid];\r\n    Data.PlayerData storage pd = dataMap[addr];\r\n    pd.totalPerformance = SafeMath.add(pd.totalPerformance, _eth);\r\n    run.totalEth = SafeMath.add(run.totalEth, _eth);\r\n    uint n = SafeMath.div(run.totalEth / 10 ** 18, 400);\r\n    if (n > 0 && n - run.count > 0) {\r\n      run.num = SafeMath.add(run.num, n - run.count);\r\n      run.count = n;\r\n    }\r\n\r\n    uint n1 = SafeMath.div(run.totalEth / 10 ** 16, run.num);\r\n    if (n1 > 0 && n1 - run.count2 > 0) {\r\n      uint temp = SafeMath.mul(n1 - run.count2, 100 * 10 ** 8);\r\n      run.totalConsume = SafeMath.sub(run.totalConsume, temp);\r\n      run.count2 = n1;\r\n    }\r\n\r\n    uint value = token.calcTokenRequired(_eth);\r\n    run.totalConsume = SafeMath.add(run.totalConsume, value);\r\n    run.consumeMap[addr] = SafeMath.add(run.consumeMap[addr], value);\r\n    run.record = run.record + 1;\r\n    run.personalEth[addr] = SafeMath.add(run.personalEth[addr], _eth);\r\n\r\n    uint amount = 0;\r\n    if (run.record > 0) {\r\n      amount = SafeMath.div(SafeMath.mul(_eth, 60), 100);\r\n      amount = SafeMath.div(amount, run.totalConsume);\r\n      roundMask[rid] = SafeMath.add(roundMask[rid], amount);\r\n      run.plyrMask[addr] = SafeMath.add(run.plyrMask[addr], SafeMath.mul(SafeMath.sub(roundMask[rid], amount), value));\r\n    }\r\n\r\n    token.burn(addr, value);\r\n    ex.updateTokenConsume(addr, value);\r\n\r\n    ex.updatePlayerEth(addr, _eth);\r\n\r\n    run.lastAddr = addr;\r\n    run.lastAddrs[recordId] = addr;\r\n    recordId++;\r\n    if (recordId > 5) {\r\n      recordId = 0;\r\n    }\r\n\r\n\r\n    timeExtended(_eth);\r\n  }\r\n\r\n  /**End the run and start one new run */\r\n  function endRound(address addr, uint _eth) private {\r\n    Data.Run storage run = runGame[rid];\r\n    uint lastPot = SafeMath.div(SafeMath.mul(run.runPool, 50), 100);\r\n    uint nextRoundFunds = SafeMath.div(SafeMath.mul(run.runPool, 20), 100);\r\n    uint reward = SafeMath.div(SafeMath.mul(run.runPool, 5), 100);\r\n\r\n    dataMap[run.lastAddr].wallet = SafeMath.add(dataMap[run.lastAddr].wallet, lastPot);\r\n    dataMap[run.lastAddr].runIncome = SafeMath.add(dataMap[run.lastAddr].runIncome, lastPot);\r\n\r\n    address superiorAddr = ex.getSuperiorAddr(run.lastAddr);\r\n    if (superiorAddr != address(0x0)) {\r\n      dataMap[superiorAddr].wallet = SafeMath.add(dataMap[superiorAddr].wallet, reward);\r\n      dataMap[superiorAddr].runIncome = SafeMath.add(dataMap[superiorAddr].runIncome, reward);\r\n    } else {\r\n      dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, reward);\r\n    }\r\n    dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, reward);\r\n    uint amount = SafeMath.div(nextRoundFunds, 5);\r\n    for (uint i = 0; i < run.lastAddrs.length; i++) {\r\n      if ((i + 1) % 6 == recordId) {\r\n        continue;\r\n      }\r\n      dataMap[run.lastAddrs[i]].wallet = SafeMath.add(dataMap[run.lastAddrs[i]].wallet, amount);\r\n      dataMap[run.lastAddrs[i]].runIncome = SafeMath.add(dataMap[run.lastAddrs[i]].runIncome, amount);\r\n    }\r\n    recordId = 0;\r\n    rid++;\r\n    runGame[rid] = Data.Run({\r\n      runPool: nextRoundFunds,\r\n      endTime: now + timeInterval,\r\n      totalConsume: 0,\r\n      record: 0,\r\n      num: 270,\r\n      count: 0,\r\n      count2: 0,\r\n      totalEth: 0,\r\n      recordArr: numArr,\r\n      lastAddr: address(0x0),\r\n      lastAddrs: inVain\r\n    });\r\n    runCore(addr, _eth);\r\n  }\r\n\r\n  /**Extend the Run end time */\r\n  function timeExtended(uint _eth) private {\r\n    Data.Run storage run = runGame[rid];\r\n    uint count = SafeMath.div(_eth, 10 ** 16);\r\n    uint nowTime = now;\r\n    if (run.endTime < nowTime) {\r\n      return;\r\n    }\r\n    uint laveTime = SafeMath.sub(run.endTime, nowTime);\r\n    // uint day = 24 * 60 * 60;\r\n    uint day = 15 * 60;\r\n    // uint minute = 10 * 60;\r\n    uint minute = 60;\r\n    if (_eth >= 10 ** 16) {\r\n      laveTime = SafeMath.add(laveTime, SafeMath.mul(minute, count));\r\n      if (laveTime <= day) {\r\n        run.endTime = SafeMath.add(nowTime, laveTime);\r\n      } else {\r\n        run.endTime = SafeMath.add(nowTime, day);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getEth() external {\r\n    require(owner == msg.sender, \"Insufficient permissions\");\r\n    owner.transfer(this.balance);\r\n  }\r\n\r\n  function getPlayerData(address addr) external view returns(uint, uint, uint, uint) {\r\n    // require(owner == msg.sender || addr == msg.sender, \"Insufficient permissions\");\r\n    Data.PlayerData storage pd = dataMap[addr];\r\n    return (pd.wallet, pd.runIncome, pd.withdrawnIncome, pd.totalPerformance);\r\n  }\r\n\r\n  /** Active Contract with lotteryAddr */\r\n  function activation(\r\n    address _lotteryAddr\r\n  ) external {\r\n    require(active == false, \"activated\");\r\n    require(owner == msg.sender, \"Insufficient permissions\");\r\n    runGame[rid] = Data.Run({\r\n      runPool: 0,\r\n      endTime: now + timeInterval,\r\n      totalConsume: 0,\r\n      record: 0,\r\n      num: 270,\r\n      count: 0,\r\n      count2: 0,\r\n      totalEth: 0,\r\n      recordArr: numArr,\r\n      lastAddr: address(0x0),\r\n      lastAddrs: inVain\r\n    });\r\n    lottery = LotteryRun(_lotteryAddr);\r\n    lotteryAddr = _lotteryAddr;\r\n    active = true;\r\n\r\n  }\r\n\r\n  function participateInRun(address superiorAddr) external payable {\r\n    participateCore(msg.sender, superiorAddr, msg.value);\r\n  }\r\n\r\n  function getLastAddrs(uint roundID) external view returns(address[]) {\r\n    return runGame[roundID].lastAddrs;\r\n  }\r\n\r\n  function getmask() external view returns(uint, uint) {\r\n    Data.Run storage run = runGame[rid];\r\n    return (roundMask[rid], run.plyrMask[msg.sender]);\r\n  }\r\n\r\n  /** get all return info */\r\n  function dividendInfo() external view returns(uint, uint, uint, uint) {\r\n    Data.Run storage run = runGame[rid];\r\n    uint totalEth = run.personalEth[msg.sender];\r\n    totalEth = SafeMath.mul(totalEth, 2);\r\n    uint totalIncome = calcIncome(rid);\r\n    uint number = totalIncome;\r\n    uint remainingNumber = 0;\r\n    uint exceedNumber = 0;\r\n    if (totalIncome > totalEth) {\r\n      number = totalEth;\r\n      exceedNumber = SafeMath.sub(totalIncome, totalEth);\r\n    } else {\r\n      remainingNumber = SafeMath.sub(totalEth, totalIncome);\r\n    }\r\n    return (run.personalEth[msg.sender], number, remainingNumber, exceedNumber);\r\n  }\r\n\r\n  /** get player income */\r\n  function getPlayerIncome() external view returns(uint, uint) {\r\n    Data.PlayerData storage pd = dataMap[msg.sender];\r\n    uint totalIncome = getTotalIncome();\r\n    totalIncome = SafeMath.sub(totalIncome, pd.settledLotteryIncome);\r\n    totalIncome = SafeMath.add(totalIncome, lottery.getAllLotteryIncome(msg.sender, false));\r\n    return (totalIncome, pd.withdrawnIncome);\r\n  }\r\n\r\n  function getVariousIncome() external view returns(uint, uint, uint, uint, uint) {\r\n    Data.PlayerData storage pd = dataMap[msg.sender];\r\n    uint dynamicIncome;\r\n    uint sellIncome;\r\n    (dynamicIncome, sellIncome) = ex.getIncome(msg.sender);\r\n    uint lotteryIncome = lottery.getAllLotteryIncome(msg.sender, false);\r\n    return (pd.runIncome, calcAllIncome(), dynamicIncome, sellIncome, lotteryIncome);\r\n  }\r\n\r\n  function withdraw() external {\r\n    withdrawCore(msg.sender, 0);\r\n  }\r\n\r\n  function balanceWithdraw(uint _eth) external {\r\n    withdrawCore(msg.sender, _eth);\r\n  }\r\n\r\n  function getRunPool() external view returns(uint) {\r\n    return runGame[rid].runPool;\r\n  }\r\n\r\n  /**  API for ExRun*/\r\n  function tokenDividend(uint _eth, uint pct) external {\r\n    require(msg.sender == exAddr, \"Insufficient permissions\");\r\n    uint lotteryPool = SafeMath.div(SafeMath.mul(_eth, 13), 100);\r\n    lottery.updateLotteryPool(lotteryPool);\r\n    uint runPool = SafeMath.div(SafeMath.mul(_eth, 20), 100);\r\n    Data.Run storage run = runGame[rid];\r\n    run.runPool = SafeMath.add(run.runPool, runPool);\r\n    timeExtended(runPool);\r\n    if (pct > 0) {\r\n      uint amount = SafeMath.div(SafeMath.mul(_eth, pct), 100);\r\n      dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, amount);\r\n    }\r\n\r\n\r\n  }\r\n  /**  API for ExRun*/\r\n  function updateWallet(address addr, uint _eth) external {\r\n    require(exAddr == msg.sender, \"Insufficient permissions\");\r\n    if (addr == address(0x0)) {\r\n      dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, _eth);\r\n    } else {\r\n      dataMap[addr].wallet = SafeMath.add(dataMap[addr].wallet, _eth);\r\n    }\r\n  }\r\n  /**  API for LotteryRun*/\r\n  function updateRunPool(address addr, uint _eth, bool flag) external {\r\n    require(lotteryAddr == msg.sender, \"Insufficient permissions\");\r\n    uint number3 = SafeMath.div(SafeMath.mul(_eth, 3), 100);\r\n    dataMap[techAddr].wallet = SafeMath.add(dataMap[techAddr].wallet, number3);\r\n\r\n    if (flag) {\r\n      uint number97 = SafeMath.sub(_eth, number3);\r\n      addr.transfer(number97);\r\n      runGame[rid].runPool = SafeMath.sub(runGame[rid].runPool, _eth);\r\n    } else {\r\n      runGame[rid].runPool = SafeMath.add(runGame[rid].runPool, SafeMath.sub(_eth, number3));\r\n      timeExtended(_eth);\r\n    }\r\n\r\n  }\r\n\r\n  function aaa(uint256 a, uint256 b) external pure returns (uint256) {\r\n      return a + b;\r\n  }\r\n\r\n  function bbb(uint256 a, uint256 b) external pure returns (uint256) {\r\n      return a - b;\r\n  }\r\n\r\n}\r\n\r\ncontract TokenRun {\r\n  function calcTokenRequired(uint _eth) external view returns(uint);\r\n\r\n  function burn(address addr, uint value) public;\r\n\r\n  function surplusSupply() public view returns(uint);\r\n\r\n  function getToken(address addr, uint value) external;\r\n\r\n  function balanceOf(address addr) public view returns(uint);\r\n}\r\n\r\ncontract ExRun {\r\n  function externalRegister(address addr, address superiorAddr) external;\r\n\r\n  function updateTokenConsume(address addr, uint value) external;\r\n\r\n  function getSuperiorAddr(address addr) external view returns(address);\r\n\r\n  function buyTokenByRun(address addr, uint _eth) external;\r\n\r\n  function updateDynamicIncome(address addr, uint _eth) external;\r\n\r\n  function getIncome(address addr) external view returns(uint, uint);\r\n\r\n  function updatePlayerEth(address addr, uint _eth) external;\r\n\r\n  function getPlayerTotalEth(address addr) external view returns(uint);\r\n}\r\n\r\ncontract LotteryRun {\r\n  function getAllLotteryIncome(address addr, bool flag) external view returns(uint);\r\n\r\n  function updateLotteryPool(uint value) external;\r\n\r\n  function deductionFee(address addr, uint _eth) external returns(uint);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getmask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"participateInRun\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRunPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"balanceWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"aaa\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotteryAddr\",\"type\":\"address\"}],\"name\":\"activation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVariousIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"updateRunPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"pct\",\"type\":\"uint256\"}],\"name\":\"tokenDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"getLastAddrs\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"bbb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"updateWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"runGame\",\"outputs\":[{\"name\":\"runPool\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"totalConsume\",\"type\":\"uint256\"},{\"name\":\"record\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"count2\",\"type\":\"uint256\"},{\"name\":\"totalEth\",\"type\":\"uint256\"},{\"name\":\"lastAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerAddr\",\"type\":\"address\"},{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"_exAddr\",\"type\":\"address\"},{\"name\":\"_techAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"JustRun","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000119eb8e686423e56b7cfc6f211c8cd4a9f71e3cc00000000000000000000000079dd747cb3d8f9c45805813d4b52e398b258c7d0000000000000000000000000d936fa73e41b8ff0d075b28e60b943271fd3d096000000000000000000000000725307b2d0e1e51917820ff299d2fb355e6d17e4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8a8f484d2440db33f5845fe47616076580f313d7c30ab3cf08f37f3e20fa362d"}]}