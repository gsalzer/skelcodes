{"status":"1","message":"OK","result":[{"SourceCode":"// File: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.01\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyPooBahsDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year >= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\r\n        if (year >= 1970 && month > 0 && month <= 12) {\r\n            uint daysInMonth = _getDaysInMonth(year, month);\r\n            if (day > 0 && day <= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour < 24 && minute < 60 && second < 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/vendor/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/vendor/ENSResolver.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract ENSResolver {\r\n  function addr(bytes32 node) public view virtual returns (address);\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/interfaces/PointerInterface.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface PointerInterface {\r\n  function getAddress() external view returns (address);\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/interfaces/ChainlinkRequestInterface.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface ChainlinkRequestInterface {\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 requestPrice,\r\n    bytes32 serviceAgreementID,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion, // Currently unused, always \"1\"\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) external;\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/interfaces/LinkTokenInterface.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/interfaces/ENSInterface.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface ENSInterface {\r\n\r\n  // Logged when the owner of a node assigns a new owner to a subnode.\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n  // Logged when the owner of a node transfers ownership to a new account.\r\n  event Transfer(bytes32 indexed node, address owner);\r\n\r\n  // Logged when the resolver for a node changes.\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n  // Logged when the TTL of a node changes\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address _owner) external;\r\n  function setResolver(bytes32 node, address _resolver) external;\r\n  function setOwner(bytes32 node, address _owner) external;\r\n  function setTTL(bytes32 node, uint64 _ttl) external;\r\n  function owner(bytes32 node) external view returns (address);\r\n  function resolver(bytes32 node) external view returns (address);\r\n  function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/vendor/Buffer.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary Buffer {\r\n  /**\r\n  * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n  *      a capacity. The capacity may be longer than the current value, in\r\n  *      which case it can be extended without the need to allocate more memory.\r\n  */\r\n  struct buffer {\r\n    bytes buf;\r\n    uint capacity;\r\n  }\r\n\r\n  /**\r\n  * @dev Initializes a buffer with an initial capacity.\r\n  * @param buf The buffer to initialize.\r\n  * @param capacity The number of bytes of space to allocate the buffer.\r\n  * @return The buffer, for chaining.\r\n  */\r\n  function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\r\n    if (capacity % 32 != 0) {\r\n      capacity += 32 - (capacity % 32);\r\n    }\r\n    // Allocate space for the buffer data\r\n    buf.capacity = capacity;\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      mstore(buf, ptr)\r\n      mstore(ptr, 0)\r\n      mstore(0x40, add(32, add(ptr, capacity)))\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Initializes a new buffer from an existing bytes object.\r\n  *      Changes to the buffer may mutate the original value.\r\n  * @param b The bytes object to initialize the buffer with.\r\n  * @return A new buffer.\r\n  */\r\n  function fromBytes(bytes memory b) internal pure returns(buffer memory) {\r\n    buffer memory buf;\r\n    buf.buf = b;\r\n    buf.capacity = b.length;\r\n    return buf;\r\n  }\r\n\r\n  function resize(buffer memory buf, uint capacity) private pure {\r\n    bytes memory oldbuf = buf.buf;\r\n    init(buf, capacity);\r\n    append(buf, oldbuf);\r\n  }\r\n\r\n  function max(uint a, uint b) private pure returns(uint) {\r\n    if (a > b) {\r\n      return a;\r\n    }\r\n    return b;\r\n  }\r\n\r\n  /**\r\n  * @dev Sets buffer length to 0.\r\n  * @param buf The buffer to truncate.\r\n  * @return The original buffer, for chaining..\r\n  */\r\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n    assembly {\r\n      let bufptr := mload(buf)\r\n      mstore(bufptr, 0)\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The start offset to write to.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to copy.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\r\n    require(len <= data.length);\r\n\r\n    if (off + len > buf.capacity) {\r\n      resize(buf, max(buf.capacity, len + off) * 2);\r\n    }\r\n\r\n    uint dest;\r\n    uint src;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Start address = buffer address + offset + sizeof(buffer length)\r\n      dest := add(add(bufptr, 32), off)\r\n      // Update buffer length if we're extending it\r\n      if gt(add(len, off), buflen) {\r\n        mstore(bufptr, add(len, off))\r\n      }\r\n      src := add(data, 32)\r\n    }\r\n\r\n    // Copy word-length chunks while possible\r\n    for (; len >= 32; len -= 32) {\r\n      assembly {\r\n        mstore(dest, mload(src))\r\n      }\r\n      dest += 32;\r\n      src += 32;\r\n    }\r\n\r\n    // Copy remaining bytes\r\n    uint mask = 256 ** (32 - len) - 1;\r\n    assembly {\r\n      let srcpart := and(mload(src), not(mask))\r\n      let destpart := and(mload(dest), mask)\r\n      mstore(dest, or(destpart, srcpart))\r\n    }\r\n\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to copy.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, len);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, data.length);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write the byte at.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\r\n    if (off >= buf.capacity) {\r\n      resize(buf, buf.capacity * 2);\r\n    }\r\n\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Address = buffer address + sizeof(buffer length) + off\r\n      let dest := add(add(bufptr, off), 32)\r\n      mstore8(dest, data)\r\n      // Update buffer length if we extended it\r\n      if eq(off, buflen) {\r\n        mstore(bufptr, add(buflen, 1))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\r\n    return writeUint8(buf, buf.buf.length, data);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n  *      exceed the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to write (left-aligned).\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint mask = 256 ** len - 1;\r\n    // Right-align data\r\n    data = data >> (8 * (32 - len));\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + sizeof(buffer length) + off + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\r\n    return write(buf, off, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chhaining.\r\n  */\r\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, 32);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to write (right-aligned).\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint mask = 256 ** len - 1;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + off + sizeof(buffer length) + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n    * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n    * exceed the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer.\r\n    */\r\n  function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\r\n    return writeInt(buf, buf.buf.length, data, len);\r\n  }\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/vendor/CBOR.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nlibrary CBOR {\r\n  using Buffer for Buffer.buffer;\r\n\r\n  uint8 private constant MAJOR_TYPE_INT = 0;\r\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n  uint8 private constant MAJOR_TYPE_STRING = 3;\r\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n  uint8 private constant MAJOR_TYPE_MAP = 5;\r\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n  function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\r\n    if(value <= 23) {\r\n      buf.appendUint8(uint8((major << 5) | value));\r\n    } else if(value <= 0xFF) {\r\n      buf.appendUint8(uint8((major << 5) | 24));\r\n      buf.appendInt(value, 1);\r\n    } else if(value <= 0xFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 25));\r\n      buf.appendInt(value, 2);\r\n    } else if(value <= 0xFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 26));\r\n      buf.appendInt(value, 4);\r\n    } else if(value <= 0xFFFFFFFFFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 27));\r\n      buf.appendInt(value, 8);\r\n    }\r\n  }\r\n\r\n  function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\r\n    buf.appendUint8(uint8((major << 5) | 31));\r\n  }\r\n\r\n  function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\r\n    encodeType(buf, MAJOR_TYPE_INT, value);\r\n  }\r\n\r\n  function encodeInt(Buffer.buffer memory buf, int value) internal pure {\r\n    if(value >= 0) {\r\n      encodeType(buf, MAJOR_TYPE_INT, uint(value));\r\n    } else {\r\n      encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\r\n    }\r\n  }\r\n\r\n  function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\r\n    encodeType(buf, MAJOR_TYPE_BYTES, value.length);\r\n    buf.append(value);\r\n  }\r\n\r\n  function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\r\n    encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\r\n    buf.append(bytes(value));\r\n  }\r\n\r\n  function startArray(Buffer.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n  }\r\n\r\n  function startMap(Buffer.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n  }\r\n\r\n  function endSequence(Buffer.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n  }\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/Chainlink.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Library for common Chainlink functions\r\n * @dev Uses imported CBOR library for encoding to buffer\r\n */\r\nlibrary Chainlink {\r\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\r\n\r\n  using CBOR for Buffer.buffer;\r\n\r\n  struct Request {\r\n    bytes32 id;\r\n    address callbackAddress;\r\n    bytes4 callbackFunctionId;\r\n    uint256 nonce;\r\n    Buffer.buffer buf;\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes a Chainlink request\r\n   * @dev Sets the ID, callback address, and callback function signature on the request\r\n   * @param self The uninitialized request\r\n   * @param _id The Job Specification ID\r\n   * @param _callbackAddress The callback address\r\n   * @param _callbackFunction The callback function signature\r\n   * @return The initialized request\r\n   */\r\n  function initialize(\r\n    Request memory self,\r\n    bytes32 _id,\r\n    address _callbackAddress,\r\n    bytes4 _callbackFunction\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Buffer.init(self.buf, defaultBufferSize);\r\n    self.id = _id;\r\n    self.callbackAddress = _callbackAddress;\r\n    self.callbackFunctionId = _callbackFunction;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\r\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\r\n   * @param self The initialized request\r\n   * @param _data The CBOR data\r\n   */\r\n  function setBuffer(Request memory self, bytes memory _data)\r\n    internal pure\r\n  {\r\n    Buffer.init(self.buf, _data.length);\r\n    Buffer.append(self.buf, _data);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a string value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The string value to add\r\n   */\r\n  function add(Request memory self, string memory _key, string memory _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeString(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a bytes value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The bytes value to add\r\n   */\r\n  function addBytes(Request memory self, string memory _key, bytes memory _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeBytes(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a int256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The int256 value to add\r\n   */\r\n  function addInt(Request memory self, string memory _key, int256 _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeInt(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a uint256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The uint256 value to add\r\n   */\r\n  function addUint(Request memory self, string memory _key, uint256 _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeUInt(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an array of strings to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _values The array of string values to add\r\n   */\r\n  function addStringArray(Request memory self, string memory _key, string[] memory _values)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.startArray();\r\n    for (uint256 i = 0; i < _values.length; i++) {\r\n      self.buf.encodeString(_values[i]);\r\n    }\r\n    self.buf.endSequence();\r\n  }\r\n}\r\n\r\n// File: https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.6/ChainlinkClient.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The ChainlinkClient contract\r\n * @notice Contract writers can inherit this contract in order to create requests for the\r\n * Chainlink network\r\n */\r\ncontract ChainlinkClient {\r\n  using Chainlink for Chainlink.Request;\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant internal LINK = 10**18;\r\n  uint256 constant private AMOUNT_OVERRIDE = 0;\r\n  address constant private SENDER_OVERRIDE = address(0);\r\n  uint256 constant private ARGS_VERSION = 1;\r\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\"link\");\r\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\r\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\r\n\r\n  ENSInterface private ens;\r\n  bytes32 private ensNode;\r\n  LinkTokenInterface private link;\r\n  ChainlinkRequestInterface private oracle;\r\n  uint256 private requestCount = 1;\r\n  mapping(bytes32 => address) private pendingRequests;\r\n\r\n  event ChainlinkRequested(bytes32 indexed id);\r\n  event ChainlinkFulfilled(bytes32 indexed id);\r\n  event ChainlinkCancelled(bytes32 indexed id);\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param _specId The Job Specification ID that the request will be created for\r\n   * @param _callbackAddress The callback address that the response will be sent to\r\n   * @param _callbackFunctionSignature The callback function signature to use for the callback address\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildChainlinkRequest(\r\n    bytes32 _specId,\r\n    address _callbackAddress,\r\n    bytes4 _callbackFunctionSignature\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\r\n   * @param _req The initialized Chainlink Request\r\n   * @param _payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequest(Chainlink.Request memory _req, uint256 _payment)\r\n    internal\r\n    returns (bytes32)\r\n  {\r\n    return sendChainlinkRequestTo(address(oracle), _req, _payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param _oracle The address of the oracle for the request\r\n   * @param _req The initialized Chainlink Request\r\n   * @param _payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment)\r\n    internal\r\n    returns (bytes32 requestId)\r\n  {\r\n    requestId = keccak256(abi.encodePacked(this, requestCount));\r\n    _req.nonce = requestCount;\r\n    pendingRequests[requestId] = _oracle;\r\n    emit ChainlinkRequested(requestId);\r\n    require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \"unable to transferAndCall to oracle\");\r\n    requestCount += 1;\r\n\r\n    return requestId;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a request to be cancelled if it has not been fulfilled\r\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\r\n   * Deletes the request from the `pendingRequests` mapping.\r\n   * Emits ChainlinkCancelled event.\r\n   * @param _requestId The request ID\r\n   * @param _payment The amount of LINK sent for the request\r\n   * @param _callbackFunc The callback function specified for the request\r\n   * @param _expiration The time of the expiration for the request\r\n   */\r\n  function cancelChainlinkRequest(\r\n    bytes32 _requestId,\r\n    uint256 _payment,\r\n    bytes4 _callbackFunc,\r\n    uint256 _expiration\r\n  )\r\n    internal\r\n  {\r\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]);\r\n    delete pendingRequests[_requestId];\r\n    emit ChainlinkCancelled(_requestId);\r\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle address\r\n   * @param _oracle The address of the oracle contract\r\n   */\r\n  function setChainlinkOracle(address _oracle) internal {\r\n    oracle = ChainlinkRequestInterface(_oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the LINK token address\r\n   * @param _link The address of the LINK token contract\r\n   */\r\n  function setChainlinkToken(address _link) internal {\r\n    link = LinkTokenInterface(_link);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the Chainlink token address for the public\r\n   * network as given by the Pointer contract\r\n   */\r\n  function setPublicChainlinkToken() internal {\r\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the LINK token\r\n   * @return The address of the LINK token\r\n   */\r\n  function chainlinkTokenAddress()\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(link);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the oracle contract\r\n   * @return The address of the oracle contract\r\n   */\r\n  function chainlinkOracleAddress()\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for a request which was created on another contract to be fulfilled\r\n   * on this contract\r\n   * @param _oracle The address of the oracle contract that will fulfill the request\r\n   * @param _requestId The request ID used for the response\r\n   */\r\n  function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)\r\n    internal\r\n    notPendingRequest(_requestId)\r\n  {\r\n    pendingRequests[_requestId] = _oracle;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\r\n   * @dev Accounts for subnodes having different resolvers\r\n   * @param _ens The address of the ENS contract\r\n   * @param _node The ENS node hash\r\n   */\r\n  function useChainlinkWithENS(address _ens, bytes32 _node)\r\n    internal\r\n  {\r\n    ens = ENSInterface(_ens);\r\n    ensNode = _node;\r\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\r\n    ENSResolver resolver = ENSResolver(ens.resolver(linkSubnode));\r\n    setChainlinkToken(resolver.addr(linkSubnode));\r\n    updateChainlinkOracleWithENS();\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle contract with the address resolved by ENS\r\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\r\n   */\r\n  function updateChainlinkOracleWithENS()\r\n    internal\r\n  {\r\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\r\n    ENSResolver resolver = ENSResolver(ens.resolver(oracleSubnode));\r\n    setChainlinkOracle(resolver.addr(oracleSubnode));\r\n  }\r\n\r\n  /**\r\n   * @notice Encodes the request to be sent to the oracle contract\r\n   * @dev The Chainlink node expects values to be in order for the request to be picked up. Order of types\r\n   * will be validated in the oracle contract.\r\n   * @param _req The initialized Chainlink Request\r\n   * @return The bytes payload for the `transferAndCall` method\r\n   */\r\n  function encodeRequest(Chainlink.Request memory _req)\r\n    private\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return abi.encodeWithSelector(\r\n      oracle.oracleRequest.selector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      _req.id,\r\n      _req.callbackAddress,\r\n      _req.callbackFunctionId,\r\n      _req.nonce,\r\n      ARGS_VERSION,\r\n      _req.buf.buf);\r\n  }\r\n\r\n  /**\r\n   * @notice Ensures that the fulfillment is valid for this contract\r\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  function validateChainlinkCallback(bytes32 _requestId)\r\n    internal\r\n    recordChainlinkFulfillment(_requestId)\r\n    // solhint-disable-next-line no-empty-blocks\r\n  {}\r\n\r\n  /**\r\n   * @dev Reverts if the sender is not the oracle of the request.\r\n   * Emits ChainlinkFulfilled event.\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  modifier recordChainlinkFulfillment(bytes32 _requestId) {\r\n    require(msg.sender == pendingRequests[_requestId],\r\n            \"Source must be the oracle of the request\");\r\n    delete pendingRequests[_requestId];\r\n    emit ChainlinkFulfilled(_requestId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the request is already pending\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  modifier notPendingRequest(bytes32 _requestId) {\r\n    require(pendingRequests[_requestId] == address(0), \"Request is already pending\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: browser/TestnetConsumer.sol\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n// Absolutely Proprietary Code\r\n\r\npragma solidity 0.6.10;\r\n\r\n// import \"@chainlink/contracts/src/v0.6/ChainlinkClient.sol\";\r\n// import \"@chainlink/contracts/src/v0.6/vendor/SafeMath.sol\";\r\n// import \"./DateTime.sol\";\r\n\r\n\r\n\r\n\r\nabstract contract ERC20Token {\r\n    function transferFrom(address from, address to, uint value) public virtual;\r\n    function transfer(address recipient, uint256 amount) public virtual;\r\n    function balanceOf(address account) external view virtual returns (uint256);\r\n    function stakedOf(address _user) public view virtual returns (uint256);\r\n    function dividendsOf(address _user) public view virtual returns (uint256);\r\n    function totalStaked() public view virtual returns (uint256);\r\n    function totalUnlockedSupply() public view virtual returns (uint256);\r\n    function transferFromEx(address from, address to, uint value) public virtual;\r\n}\r\n\r\n\r\n\r\ncontract S is ChainlinkClient {\r\nusing BokkyPooBahsDateTimeLibrary for uint;\r\n\r\n struct TradeMeta {\r\n    uint256 lastPrice;\r\n    bytes32 linkRequestId;\r\n    uint256 durationCap;\r\n    uint256 acceptedAt;\r\n }\r\n\r\n  struct Trade {\r\n    string ticker;\r\n    uint256 initPrice;\r\n    address buyer;\r\n    address seller;\r\n    uint amountStock;\r\n    uint256 fundsBuyer;\r\n    bool isClosed;\r\n    uint256 priceCreationReqTimeout;\r\n  }\r\n\r\n  // data\r\n  mapping(address => uint256[]) public addressTrades;\r\n  mapping(bytes32 => uint256) public linkRequestIdToTrade;\r\n  Trade[] public trades;\r\n  TradeMeta[] public tradesMeta;\r\n\r\n  // struct array workaround - trade showcase - public tradeInfo\r\n  bytes32[] trades_ticker;\r\n  uint256[] trades_dsellerPercentage;\r\n  uint256[] trades_maxAmountStock;\r\n  uint256[] trades_minAmountStock;\r\n  bool[] trades_isActive;\r\n  bool[] trades_isCancelled;\r\n  uint256[] trades_fundsSeller;\r\n  uint8[17][] afkHours;\r\n\r\n\r\n  uint256 public oraclePaymentDefault;\r\n  uint256 public linkToS;\r\n  address public owner;\r\n  address public DAI_token;\r\n  address public SToken;\r\n  uint256 public divPool;\r\n  mapping(address => bool) public oracles;\r\n\r\n\r\n  // events\r\n  event TradeClosed(uint256 tradeID, uint256 price);\r\n  event TradeConfirmed(uint256 tradeID, uint256 price);\r\n  event RequestTradeClosed(uint256 tradeID);\r\n  event OfferCreated(string ticker, uint256 maxAmountStock, uint256 minAmountStock,\r\n                     uint256 dsellerOfferPrice, address dseller);\r\n  event OfferAccepted(uint256 tradeID);\r\n  event OfferCancelled(uint256 tradeID);\r\n  event DaiDivsClaimed(address claimer);\r\n\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    setPublicChainlinkToken();\r\n    //switch it for mainnet\r\n    oraclePaymentDefault = LINK;\r\n    linkToS = 0;\r\n  }\r\n\r\n  // functions (administration)\r\n  function setPayment(uint256 _linkAmount, uint256 _linkToS) public\r\n  {\r\n    require(msg.sender == owner);\r\n    oraclePaymentDefault = _linkAmount;\r\n    linkToS = _linkToS;\r\n  }\r\n\r\n  function setDAIToken(address _token) public\r\n  {\r\n    //0xc2118d4d90b274016cB7a54c03EF52E6c537D957 for testnet\r\n    require(msg.sender == owner);\r\n    DAI_token = _token;\r\n  }\r\n\r\n function setSToken(address _token) public\r\n  {\r\n    require(msg.sender == owner);\r\n    SToken = _token;\r\n  }\r\n\r\n  function setOracle(address _oracle, bool _isCertified) public\r\n  {\r\n    //0xd3d4f566b8e0de2dcde877b1954c2d759cc395a6 for testnet\r\n    require(msg.sender == owner);\r\n    oracles[_oracle] = _isCertified;\r\n\r\n  }\r\n\r\n  // functions (UI)\r\n\r\n  function createDsellerOffer(uint256 _maxAmountStock, uint256 _minAmountStock,\r\n                             string memory _ticker, bytes32 _tickerBytes,\r\n                             uint256 _fundsSeller, uint256 _dsellerPercentage,\r\n                             uint8[17] memory _afkHours, uint256 _durationCap) public\r\n  {\r\n    trades.push(Trade(_ticker, 0, address(0x0), msg.sender, 0, 0, false, 0));\r\n    tradesMeta.push(TradeMeta(0,0, _durationCap, 0));\r\n    afkHours.push(_afkHours);\r\n    trades_ticker.push(_tickerBytes);\r\n    trades_maxAmountStock.push(_maxAmountStock);\r\n    trades_minAmountStock.push(_minAmountStock);\r\n    trades_dsellerPercentage.push(_dsellerPercentage);\r\n    //\r\n    trades_isActive.push(false);\r\n    trades_isCancelled.push(false);\r\n    //\r\n    addressTrades[msg.sender].push(trades.length-1);\r\n    //excess should be withdrawable\r\n    ERC20Token DAI = ERC20Token(DAI_token);\r\n    DAI.transferFrom(msg.sender, address(this), _fundsSeller);\r\n    trades_fundsSeller.push(_fundsSeller);\r\n    emit OfferCreated(_ticker, _maxAmountStock, _minAmountStock, _dsellerPercentage, msg.sender);\r\n  }\r\n\r\n  function cancelDsellerOffer(uint256 _tradeID) public\r\n  {\r\n    require(!trades_isActive[_tradeID], \"Trade already active\");\r\n    require(!trades[_tradeID].isClosed, \"Trade already closed\");\r\n    require(!trades_isCancelled[_tradeID], \"Trade has been cancelled\");\r\n    require(trades[_tradeID].seller == msg.sender);\r\n    require(trades[_tradeID].priceCreationReqTimeout == 0 || trades[_tradeID].priceCreationReqTimeout < block.timestamp);\r\n    trades_isCancelled[_tradeID] = true;\r\n    ERC20Token DAI = ERC20Token(DAI_token);\r\n    DAI.transfer( msg.sender, trades_fundsSeller[_tradeID]);\r\n    trades_fundsSeller[_tradeID] = 0;\r\n    emit OfferCancelled(_tradeID);\r\n  }\r\n\r\n  function ceil(uint a, uint m) view private  returns (uint ) {\r\n    return ((a + m - 1) / m) * m;\r\n  }\r\n\r\n  function acceptDsellerOffer(uint256 _tradeID, uint256 _amountStock, uint256 _fundsSeller,\r\n                             uint256 dsellerPercentage,\r\n                             address _oracle, bytes32 _jobId,\r\n                             uint256 _oraclePayment) public\r\n  {\r\n    require(!trades_isActive[_tradeID], \"Trade already active\");\r\n    require(!trades[_tradeID].isClosed, \"Trade already closed\");\r\n    require(!trades_isCancelled[_tradeID], \"Trade has been cancelled\");\r\n    require(trades[_tradeID].seller != msg.sender, \"Same party\");\r\n    require(trades[_tradeID].priceCreationReqTimeout == 0 || trades[_tradeID].priceCreationReqTimeout < block.timestamp, \"Trade has not expired\");\r\n    require(trades_fundsSeller[_tradeID] == _fundsSeller, \"Funds moved\");\r\n    require(trades_dsellerPercentage[_tradeID] == dsellerPercentage, \"Percentage changed\");\r\n    require(trades_minAmountStock[_tradeID] <= _amountStock, \"Under min stock amount\");\r\n    require(trades_maxAmountStock[_tradeID] >= _amountStock, \"Over max stock amount\");\r\n    //send price req\r\n    require(oracles[_oracle], \"Incorrect oracle address\");\r\n    uint8[17] memory _afkHours = afkHours[_tradeID];\r\n    uint256 currentHour = BokkyPooBahsDateTimeLibrary.getHour(block.timestamp);\r\n    for (uint i=0; i<_afkHours.length; i++) {\r\n      if (_afkHours[i] == currentHour) {\r\n        revert(\"Entering at AFK hour\");\r\n      }\r\n    }\r\n    uint256 payment;\r\n    if (_oraclePayment > oraclePaymentDefault) {\r\n      payment = oraclePaymentDefault;\r\n    } else {\r\n      payment = _oraclePayment;\r\n    }\r\n    if (linkToS != 0) {\r\n      fundWithLinkOrS(payment);\r\n    }\r\n    Chainlink.Request memory req = buildChainlinkRequest(_jobId, address(this), this._acceptDsellerOffer.selector);\r\n    req.add(\"ticker\", trades[_tradeID].ticker);\r\n    bytes32 reqId = sendChainlinkRequestTo(_oracle, req, payment);\r\n    linkRequestIdToTrade[reqId] = _tradeID;\r\n    //end sendpricereq\r\n    trades[_tradeID].buyer = msg.sender;\r\n    //set up 1 hour security timeout to prevent trade acceptance overwrite,\r\n    //and refuse fulfillments that come after timeout deadline\r\n    trades[_tradeID].priceCreationReqTimeout = block.timestamp.add(3600);\r\n    //ceil to remove fractional trading\r\n    trades[_tradeID].amountStock = ceil(_amountStock, 1000);\r\n    addressTrades[msg.sender].push(_tradeID);\r\n    emit OfferAccepted(_tradeID);\r\n  }\r\n\r\nfunction _acceptDsellerOffer(bytes32 _requestId, uint256 _price)\r\n  public\r\n  recordChainlinkFulfillment(_requestId)\r\n{\r\n  uint256 tradeID = linkRequestIdToTrade[_requestId];\r\n  Trade memory trade = trades[tradeID];\r\n  require(!trades_isActive[tradeID], \"Trade already active\");\r\n  require(!trade.isClosed, \"Trade already closed\");\r\n  require(!trades_isCancelled[tradeID], \"Trade has been cancelled\");\r\n  require(trade.priceCreationReqTimeout > block.timestamp, \"Request expired\");\r\n  //second div for fractional trading\r\n  uint256 presentValueBuyer = trade.amountStock.mul(_price.mul(trades_dsellerPercentage[tradeID]).div(100).div(1000));\r\n  trades[tradeID].fundsBuyer = presentValueBuyer;\r\n  ERC20Token DAI = ERC20Token(DAI_token);\r\n  DAI.transferFrom(trade.buyer, address(this), presentValueBuyer);\r\n  trades_isActive[tradeID] = true;\r\n  tradesMeta[tradeID].acceptedAt = block.timestamp;\r\n  trades[tradeID].initPrice = _price;\r\n  trades[tradeID].priceCreationReqTimeout = 0;\r\n  emit TradeConfirmed(tradeID, _price);\r\n}\r\n\r\nfunction fundWithLinkOrS(uint256 linkPayment) public {\r\n  ERC20Token ST = ERC20Token(SToken);\r\n  uint256 sBalance = ST.balanceOf(msg.sender);\r\n  uint256 sPayment = linkPayment.mul(linkToS).div(100);\r\n  if (sBalance >= sPayment) {\r\n    //S burned\r\n    ST.transferFromEx(msg.sender, address(this), sPayment);\r\n  } else {\r\n    LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());\r\n    require(link.transferFrom(msg.sender, address(this), linkPayment));\r\n  }\r\n}\r\n\r\nfunction closeTrade(uint256 _tradeID, address _oracle, bytes32 _jobId,\r\n                    uint256 _oraclePayment) public\r\n{\r\n  require(trades_isActive[_tradeID], \"Trade is not active\");\r\n  require(!trades[_tradeID].isClosed, \"Trade already closed\");\r\n  require(oracles[_oracle], \"Incorrect oracle address\");\r\n  bool calledByBuyer = trades[_tradeID].buyer == msg.sender;\r\n  bool calledBySeller = trades[_tradeID].seller == msg.sender;\r\n  if (!calledByBuyer && !calledBySeller) {\r\n    revert(\"Not a party\");\r\n  }\r\n  if (calledBySeller &&\r\n     (tradesMeta[_tradeID].acceptedAt.add(tradesMeta[_tradeID].durationCap) > block.timestamp ||\r\n      tradesMeta[_tradeID].durationCap == 0)) {\r\n    revert(\"Seller timelock pending\");\r\n  }\r\n  uint8[17] memory _afkHours = afkHours[_tradeID];\r\n  uint256 currentHour = BokkyPooBahsDateTimeLibrary.getHour(block.timestamp);\r\n  for (uint i=0; i<_afkHours.length; i++) {\r\n            if (_afkHours[i] == currentHour) {\r\n               revert(\"Closing at AFK hour\");\r\n      }\r\n  }\r\n  uint256 payment;\r\n  if (_oraclePayment > oraclePaymentDefault) {\r\n    payment = oraclePaymentDefault;\r\n  } else {\r\n    payment = _oraclePayment;\r\n  }\r\n  if (linkToS != 0) {\r\n    fundWithLinkOrS(payment);\r\n  }\r\n  trades[_tradeID].priceCreationReqTimeout = block.timestamp.add(3600);\r\n  Chainlink.Request memory req = buildChainlinkRequest(_jobId, address(this), this._closeTrade.selector);\r\n  req.add(\"ticker\", trades[_tradeID].ticker);\r\n  bytes32 reqId = sendChainlinkRequestTo(_oracle, req, payment);\r\n  linkRequestIdToTrade[reqId] = _tradeID;\r\n  emit RequestTradeClosed(_tradeID);\r\n}\r\n\r\n\r\nfunction _closeTrade(bytes32 _requestId, uint256 _price)\r\n  public\r\n  recordChainlinkFulfillment(_requestId)\r\n{\r\n  uint256 tradeID = linkRequestIdToTrade[_requestId];\r\n  Trade memory trade = trades[tradeID];\r\n  uint256 presentValue = trade.amountStock.mul(_price).div(1000);\r\n  uint256 initValue = trade.amountStock.mul(trade.initPrice.mul(trades_dsellerPercentage[tradeID]).div(100)).div(1000);\r\n  uint256 sendToBuyer;\r\n  uint256 sendToSeller;\r\n  if (presentValue > initValue) {\r\n      uint256 buyerProfit = presentValue.sub(initValue);\r\n      //imperative pattern\r\n      //capping due to undercollateralization\r\n      if (buyerProfit > trades_fundsSeller[tradeID]) {\r\n        buyerProfit = trades_fundsSeller[tradeID];\r\n      }\r\n      uint256 buyerProfitShare = buyerProfit.mul(95).div(100);\r\n      divPool = divPool.add(buyerProfit.mul(5).div(100));\r\n      sendToBuyer = trade.fundsBuyer.add(buyerProfitShare);\r\n      sendToSeller = trades_fundsSeller[tradeID].sub(buyerProfit);\r\n  }\r\n  if (presentValue <= initValue) {\r\n      uint256 sellerProfit = initValue.sub(presentValue);\r\n      sendToSeller = trades_fundsSeller[tradeID].add(sellerProfit);\r\n      sendToBuyer = trade.fundsBuyer.sub(sellerProfit);\r\n  }\r\n  trades_fundsSeller[tradeID] = 0;\r\n  trades[tradeID].fundsBuyer = 0;\r\n  ERC20Token DAI = ERC20Token(DAI_token);\r\n  if (sendToSeller > 0) {\r\n         DAI.transfer(trade.seller, sendToSeller);\r\n  }\r\n  if (sendToBuyer > 0) {\r\n         DAI.transfer(trade.buyer, sendToBuyer);\r\n  }\r\n  trades[tradeID].isClosed = true;\r\n  tradesMeta[tradeID].lastPrice = _price;\r\n  tradesMeta[tradeID].linkRequestId = _requestId;\r\n  trades[tradeID].priceCreationReqTimeout = 0;\r\n  emit TradeClosed(tradeID, _price);\r\n}\r\n\r\n  function daiDividends(address _forHolder) public view returns (uint256)\r\n  {\r\n      uint256 totalOpenPool = divPool;\r\n      ERC20Token ST = ERC20Token(SToken);\r\n      uint256 userSDividends = ST.dividendsOf(_forHolder);\r\n      uint256 totalUnlocked = ST.totalUnlockedSupply();\r\n      return totalOpenPool.mul(userSDividends).div(totalUnlocked);\r\n  }\r\n\r\n  function claimDaiDividends(address _forHolder, uint256 _dividends) public\r\n  {\r\n    require(msg.sender == SToken);\r\n    ERC20Token DAI = ERC20Token(DAI_token);\r\n    ERC20Token ST = ERC20Token(SToken);\r\n    uint256 totalOpenPool = divPool;\r\n    uint256 totalUnlocked = ST.totalUnlockedSupply();\r\n    uint256 divsDue = totalOpenPool.mul(_dividends).div(totalUnlocked);\r\n    divPool = divPool.sub(divsDue);\r\n    DAI.transfer(_forHolder, divsDue);\r\n    emit DaiDivsClaimed(msg.sender);\r\n  }\r\n   //direct access functions\r\n   function getTradePublic(uint256 i) public view returns (bytes32, uint256, uint256, uint256, bool, bool, uint256 ){\r\n     return(trades_ticker[i], trades_dsellerPercentage[i], trades_maxAmountStock[i],\r\n            trades_minAmountStock[i], trades_isActive[i], trades_isCancelled[i], trades_fundsSeller[i] );\r\n   }\r\n\r\n    function tradesLength() public view returns( uint256 ){\r\n        return trades.length;\r\n    }\r\n\r\n  function getAfkHoursForTrade(uint256 _tradeID) public view returns (uint8[17] memory )\r\n  {\r\n     return afkHours[_tradeID];\r\n  }\r\n\r\n    function getTradeTickers() public view returns( bytes32[] memory){\r\n        return trades_ticker;\r\n    }\r\n\r\n    function getTradeDsellerPercentage() public view returns( uint256[] memory){\r\n        return trades_dsellerPercentage;\r\n    }\r\n\r\n    function getTradeMaxAmountStock() public view returns( uint256[] memory){\r\n        return trades_maxAmountStock;\r\n    }\r\n\r\n    function getTradeMinAmountStock() public view returns( uint256[] memory){\r\n        return trades_minAmountStock;\r\n    }\r\n\r\n    function getTradeIsActive() public view returns( bool[] memory){\r\n        return trades_isActive;\r\n    }\r\n\r\n    function getTradeIsCancelled() public view returns( bool[] memory){\r\n        return trades_isCancelled;\r\n    }\r\n\r\n    function getTradeFundsSeller() public view returns( uint256[] memory){\r\n        return trades_fundsSeller;\r\n    }\r\n\r\n    function getAddressTrades(address _of) public view returns( uint256[] memory){\r\n        return addressTrades[_of];\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"DaiDivsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"OfferAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"OfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxAmountStock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmountStock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dsellerOfferPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dseller\",\"type\":\"address\"}],\"name\":\"OfferCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"RequestTradeClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"TradeClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"TradeConfirmed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAI_token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"_acceptDsellerOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"_closeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tradeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountStock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fundsSeller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dsellerPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_oraclePayment\",\"type\":\"uint256\"}],\"name\":\"acceptDsellerOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressTrades\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tradeID\",\"type\":\"uint256\"}],\"name\":\"cancelDsellerOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_forHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_dividends\",\"type\":\"uint256\"}],\"name\":\"claimDaiDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tradeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_oraclePayment\",\"type\":\"uint256\"}],\"name\":\"closeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAmountStock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountStock\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ticker\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_tickerBytes\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_fundsSeller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dsellerPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint8[17]\",\"name\":\"_afkHours\",\"type\":\"uint8[17]\"},{\"internalType\":\"uint256\",\"name\":\"_durationCap\",\"type\":\"uint256\"}],\"name\":\"createDsellerOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_forHolder\",\"type\":\"address\"}],\"name\":\"daiDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"divPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"linkPayment\",\"type\":\"uint256\"}],\"name\":\"fundWithLinkOrS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getAddressTrades\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tradeID\",\"type\":\"uint256\"}],\"name\":\"getAfkHoursForTrade\",\"outputs\":[{\"internalType\":\"uint8[17]\",\"name\":\"\",\"type\":\"uint8[17]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeDsellerPercentage\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeFundsSeller\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeIsActive\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeIsCancelled\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeMaxAmountStock\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeMinAmountStock\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getTradePublic\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeTickers\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"linkRequestIdToTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkToS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oraclePaymentDefault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setDAIToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCertified\",\"type\":\"bool\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_linkAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_linkToS\",\"type\":\"uint256\"}],\"name\":\"setPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setSToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trades\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"initPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountStock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundsBuyer\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isClosed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceCreationReqTimeout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tradesMeta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"linkRequestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"durationCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acceptedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"S","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0e67870a18cb9f13ed3d0a4806591b9b94528fb1074774072bff74d65b542fa4"}]}