{"status":"1","message":"OK","result":[{"SourceCode":"/**\n*\n*\n         dP                   dP                         dP                   \n         88                   88                         88                   \n.d8888b. 88 .d8888b. .d8888b. 88d888b. dP   .dP .d8888b. 88 dP    dP .d8888b. \nY8ooooo. 88 88'  `88 Y8ooooo. 88'  `88 88   d8' 88'  `88 88 88    88 88ooood8 \n      88 88 88.  .88       88 88    88 88 .88'  88.  .88 88 88.  .88 88.  ... \n`88888P' dP `88888P8 `88888P' dP    dP 8888P'   `88888P8 dP `88888P' `88888P' \n                                                                              \n*\n* \n* SlashValue\n* https://SlashValue.Com\n* \n**/\n\npragma solidity 0.5.16; \n\ncontract ERC20 {\n    function authorizedMint(address reciever, uint256 value) public returns(bool);\n    function transfer(address to, uint256 value) public returns(bool);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n}\n\n\ncontract ownerShip  \n{\n    //Global storage declaration\n    address public ownerWallet;\n    address private newOwner;\n    //Event defined for ownership transfered\n    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);\n\n    //Sets owner only on first run\n    constructor() public \n    {\n        //Set contract owner\n        ownerWallet = msg.sender;\n        emit OwnershipTransferredEv(address(0), msg.sender);\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner \n    {\n        newOwner = _newOwner;\n    }\n\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\n    function acceptOwnership() public \n    {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferredEv(ownerWallet, newOwner);\n        ownerWallet = newOwner;\n        newOwner = address(0);\n    }\n\n    //This will restrict function only for owner where attached\n    modifier onlyOwner() \n    {\n        require(msg.sender == ownerWallet);\n        _;\n    }\n\n}\n\n\ncontract SlashValue is ownerShip {\n    using SafeMath for uint256;\n    uint maxDownLimit = 2;\n    uint public lastIDCount = 0;\n    ERC20 public SVToken;\n    uint public svFee = 10 ether;\n    uint public svTokenMultiplier = 10000;\n\n    struct userInfo {\n        bool joined;\n        uint createdOn;\n        uint id;\n        uint sponsorID;\n        uint referrerID;\n        address[] referral;\n        mapping(uint => uint) levelExpired;\n    }\n\n    mapping(uint => uint) public priceOfLevel;\n\n    mapping (address => userInfo) public userInfos;\n    mapping (uint => address) public userAddressByID;\n\n\n    event regLevelEv(uint indexed _userID, address indexed _userWallet, uint indexed _referrerID, address _refererWallet, uint _originalReferrer, uint _time);\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\n    event paidForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\n    event lostForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\n\n    constructor(address _token) public {\n        SVToken = ERC20(_token);\n\n        priceOfLevel[1] = 0.05 ether;\n        priceOfLevel[2] = 0.10 ether;\n        priceOfLevel[3] = 0.20 ether;\n        priceOfLevel[4] = 0.50 ether;\n        priceOfLevel[5] = 1 ether;\n        priceOfLevel[6] = 2 ether;\n        priceOfLevel[7] = 3 ether;\n        priceOfLevel[8] = 4 ether;\n        priceOfLevel[9] = 5 ether;\n        priceOfLevel[10] = 7 ether;\n\n        userInfo memory UserInfo;\n        lastIDCount++;\n\n        UserInfo = userInfo({\n            joined: true,\n            createdOn: now,\n            id: lastIDCount,\n            sponsorID: 0,\n            referrerID: 0,\n            referral: new address[](0)\n        });\n        userInfos[ownerWallet] = UserInfo;\n        userAddressByID[lastIDCount] = ownerWallet;\n\n        for(uint i = 1; i <= 10; i++) {\n            userInfos[ownerWallet].levelExpired[i] = 99999999999;\n            emit paidForLevelEv(ownerWallet, address(0), i, priceOfLevel[i], now);\n            emit levelBuyEv(msg.sender, i, priceOfLevel[i], now);\n        }\n        \n        emit regLevelEv(lastIDCount, msg.sender, 0, address(0), 0, now);\n\n    }\n\n    function () external payable {\n        uint level;\n\n        if(msg.value == priceOfLevel[1]) level = 1;\n        else if(msg.value == priceOfLevel[2]) level = 2;\n        else if(msg.value == priceOfLevel[3]) level = 3;\n        else if(msg.value == priceOfLevel[4]) level = 4;\n        else if(msg.value == priceOfLevel[5]) level = 5;\n        else if(msg.value == priceOfLevel[6]) level = 6;\n        else if(msg.value == priceOfLevel[7]) level = 7;\n        else if(msg.value == priceOfLevel[8]) level = 8;\n        else if(msg.value == priceOfLevel[9]) level = 9;\n        else if(msg.value == priceOfLevel[10]) level = 10;\n        else revert('Incorrect Value send');\n\n        if(userInfos[msg.sender].joined) buyLevel(level);\n        else if(level == 1) {\n            uint refId = 1;\n            address referrer = bytesToAddress(msg.data);\n\n            if(userInfos[referrer].joined) refId = userInfos[referrer].id;\n\n            regUser(refId);\n        }\n        else revert('Please buy first level for 0.1 ETH');\n    }\n\n    function regUser(uint _referrerID) public payable {\n        uint originalReferrerID = _referrerID;\n        require(!userInfos[msg.sender].joined, 'User exist');\n        require(_referrerID > 0 && _referrerID <= lastIDCount, 'Incorrect referrer Id');\n        require(msg.value == priceOfLevel[1], 'Incorrect Value');\n        \n        uint _sponsorID = _referrerID;\n\n        if(userInfos[userAddressByID[_referrerID]].referral.length >= maxDownLimit) _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\n\n        userInfo memory UserInfo;\n        lastIDCount++;\n\n        UserInfo = userInfo({\n            joined: true,\n            createdOn: now,\n            id: lastIDCount,\n            sponsorID: _sponsorID,\n            referrerID: _referrerID,\n            referral: new address[](0)\n        });\n\n        userInfos[msg.sender] = UserInfo;\n        userAddressByID[lastIDCount] = msg.sender;\n\n        userInfos[msg.sender].levelExpired[1] = 99999999999;\n\n        userInfos[userAddressByID[_referrerID]].referral.push(msg.sender);\n        \n        uint256 mint = ((priceOfLevel[1]).mul(svTokenMultiplier));\n        SVToken.authorizedMint(msg.sender, mint);\n        \n        // 10%\n        mint = ((priceOfLevel[1]).mul((svTokenMultiplier.mul(uint(10).mul(10**18))).div(10**20)));\n        SVToken.authorizedMint(userAddressByID[userInfos[msg.sender].sponsorID], mint);\n        \n        address(uint160(ownerWallet)).send((priceOfLevel[1].mul(uint(10).mul(10**18))).div(10**20));\n\n        payForLevelUpline(1, msg.sender, false);\n        payForLevelSponsor(1,msg.sender, false);\n\n        emit regLevelEv(lastIDCount, msg.sender, _referrerID, userAddressByID[_referrerID], originalReferrerID, now);\n        emit levelBuyEv(msg.sender, 1, msg.value, now);\n    }\n\n    function buyLevel(uint _level) public payable {\n        require(userInfos[msg.sender].joined, 'User not exist'); \n        require(_level > 1 && _level <= 10, 'Incorrect level');\n        require(userInfos[msg.sender].levelExpired[_level] == 0, 'Level Already Active');\n        \n        //owner can buy levels without paying anything\n        if(msg.sender!=ownerWallet){\n            require(msg.value == priceOfLevel[_level], 'Incorrect Value');\n        }\n        \n        for(uint l =_level - 1; l > 0; l--) require(userInfos[msg.sender].levelExpired[l] > 0, 'Buy the previous level');\n\n        userInfos[msg.sender].levelExpired[_level] = 2**_level;\n\n        uint256 mint = ((priceOfLevel[_level]).mul(svTokenMultiplier));\n        SVToken.authorizedMint(msg.sender, mint);\n        \n        // 10%\n        mint = ((priceOfLevel[_level]).mul((svTokenMultiplier.mul(uint(10).mul(10**18))).div(10**20)));\n        SVToken.authorizedMint(userAddressByID[userInfos[msg.sender].sponsorID], mint);\n        \n        address(uint160(ownerWallet)).send((priceOfLevel[_level].mul(uint(10).mul(10**18))).div(10**20));\n        \n        payForLevelUpline(_level, msg.sender, false);\n        payForLevelSponsor(_level, msg.sender, false);\n\n        emit levelBuyEv(msg.sender, _level, msg.value, now);\n    }\n    \n\n    function payForLevelUpline(uint _level, address _user, bool _loop) internal {\n        address referer;\n        address nextReferrer;\n       if(!_loop){\n        if(_level == 1 || _level == 6) {\n            referer = userAddressByID[userInfos[_user].referrerID];\n        }\n        else if(_level == 2 || _level == 7) {\n            nextReferrer = userAddressByID[userInfos[_user].referrerID];\n            referer = userAddressByID[userInfos[nextReferrer].referrerID];\n        }\n        else if(_level == 3 || _level == 8) {\n            nextReferrer = userAddressByID[userInfos[_user].referrerID];\n            nextReferrer = userAddressByID[userInfos[nextReferrer].referrerID];\n            referer = userAddressByID[userInfos[nextReferrer].referrerID];\n        }\n        else if(_level == 4 || _level == 9) {\n            nextReferrer = userAddressByID[userInfos[_user].referrerID];\n            nextReferrer = userAddressByID[userInfos[nextReferrer].referrerID];\n            nextReferrer = userAddressByID[userInfos[nextReferrer].referrerID];\n            referer = userAddressByID[userInfos[nextReferrer].referrerID];\n        }\n        else if(_level == 5 || _level == 10) {\n            nextReferrer = userAddressByID[userInfos[_user].referrerID];\n            nextReferrer = userAddressByID[userInfos[nextReferrer].referrerID];\n            nextReferrer = userAddressByID[userInfos[nextReferrer].referrerID];\n            nextReferrer = userAddressByID[userInfos[nextReferrer].referrerID];\n            referer = userAddressByID[userInfos[nextReferrer].referrerID];\n        }\n       }\n        else \n         referer = userAddressByID[userInfos[_user].referrerID];\n\n        if(!userInfos[referer].joined) referer = userAddressByID[1];\n\n        if(userInfos[referer].levelExpired[_level] > 0) {\n            address(uint160(referer)).send((priceOfLevel[_level].mul(uint(44).mul(10**18))).div(10**20));\n            userInfos[referer].levelExpired[_level]--;\n            emit paidForLevelEv(referer, msg.sender, _level, msg.value, now);\n        }\n\n        else  {\n            emit lostForLevelEv(referer, msg.sender, _level, msg.value, now);\n            payForLevelUpline(_level,referer, true);\n        }\n       \n    }\n    \n     function payForLevelSponsor(uint _level, address _user, bool _loop) internal {\n        address sponsor;\n        address nextSponsor;\n        \n        if(!_loop){\n         if(_level == 1 || _level == 6) {\n            sponsor = userAddressByID[userInfos[_user].sponsorID];\n        }\n        if(_level == 2 || _level == 7) {\n            nextSponsor = userAddressByID[userInfos[_user].sponsorID];\n            sponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n        }\n        else if(_level == 3 || _level == 8) {\n            nextSponsor = userAddressByID[userInfos[_user].sponsorID];\n            nextSponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n            sponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n            \n        }\n        else if(_level == 4 || _level == 9) {\n            nextSponsor = userAddressByID[userInfos[_user].sponsorID];\n            nextSponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n            nextSponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n            sponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n        }\n        else if(_level == 5 || _level == 10) {\n            nextSponsor = userAddressByID[userInfos[_user].sponsorID];\n            nextSponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n            nextSponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n            nextSponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n            sponsor = userAddressByID[userInfos[nextSponsor].sponsorID];\n        }\n        }\n        else \n         sponsor = userAddressByID[userInfos[_user].sponsorID];\n\n        if(!userInfos[sponsor].joined) sponsor = userAddressByID[1];\n        \n        if(userInfos[sponsor].levelExpired[_level] > 0) {\n            address(uint160(sponsor)).send((priceOfLevel[_level].mul(uint(46).mul(10**18))).div(10**20));\n            emit paidForLevelEv(sponsor, msg.sender, _level, msg.value, now);\n        }\n\n        else  {\n            emit lostForLevelEv(sponsor, msg.sender, _level, msg.value, now);\n            payForLevelSponsor(_level, sponsor, true);\n        }\n       \n    }\n\n    function findFreeReferrer(address _user) public view returns(address) {\n        if(userInfos[_user].referral.length < maxDownLimit) return _user;\n\n        address[] memory referrals = new address[](126);\n        referrals[0] = userInfos[_user].referral[0];\n        referrals[1] = userInfos[_user].referral[1];\n\n        address freeReferrer;\n        bool noFreeReferrer = true;\n\n        for(uint i = 0; i < 126; i++) {\n            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\n                if(i < 62) {\n                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\n                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\n                }\n            }\n            else {\n                noFreeReferrer = false;\n                freeReferrer = referrals[i];\n                break;\n            }\n        }\n\n        require(!noFreeReferrer, 'No Free Referrer');\n\n        return freeReferrer;\n    }\n\n    function viewUserReferral(address _user) public view returns(address[] memory) {\n        return userInfos[_user].referral;\n    }\n\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\n        return userInfos[_user].levelExpired[_level];\n    }\n\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n    \n    function updateUserInfo(uint _id, uint _sponsorID, uint _referrerID) onlyOwner public{\n        userInfos[userAddressByID[_id]].id = _id;\n        userInfos[userAddressByID[_id]].sponsorID = _sponsorID;\n        userInfos[userAddressByID[_id]].referrerID = _referrerID;\n    }\n    \n    function updateUserLevelExpired(uint _id, uint _level, uint _expiry) onlyOwner public {\n        userInfos[userAddressByID[_id]].levelExpired[_level] = _expiry;\n    }\n    \n  \n    function updateInternals(uint _svFee, uint _tokenMultiplier, uint _level1Price, uint _level2Price, uint _level3Price, uint _level4Price, uint _level5Price, uint _level6Price, uint _level7Price, uint _level8Price, uint _level9Price, uint _level10Price) onlyOwner public {\n        svFee = _svFee;\n        svTokenMultiplier = _tokenMultiplier;\n        priceOfLevel[1] = _level1Price;\n        priceOfLevel[2] = _level2Price;\n        priceOfLevel[3] = _level3Price;\n        priceOfLevel[4] = _level4Price;\n        priceOfLevel[5] = _level5Price;\n        priceOfLevel[6] = _level6Price;\n        priceOfLevel[7] = _level7Price;\n        priceOfLevel[8] = _level8Price;\n        priceOfLevel[9] = _level9Price;\n        priceOfLevel[10] = _level10Price;\n    }\n    \n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferredEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lostForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paidForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_originalReferrer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"regLevelEv\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"SVToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"svFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"svTokenMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_svFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level1Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level2Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level3Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level4Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level5Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level6Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level7Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level8Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level9Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level10Price\",\"type\":\"uint256\"}],\"name\":\"updateInternals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sponsorID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"updateUserInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"updateUserLevelExpired\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"createdOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sponsorID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SlashValue","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000060cb90102c0d3b7d67a1962ae2eedbd664d3273c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}