{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/SafeMath.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/aave-helper/ILendingPool.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface ILendingPool {\r\n    function addressesProvider() external view returns (address);\r\n\r\n    function deposit(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint16 _referralCode\r\n    ) external payable;\r\n\r\n    function redeemUnderlying(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function borrow(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _interestRateMode,\r\n        uint16 _referralCode\r\n    ) external;\r\n\r\n    function repay(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        address _onBehalfOf\r\n    ) external payable;\r\n\r\n    function swapBorrowRateMode(address _reserve) external;\r\n\r\n    function rebalanceFixedBorrowRate(address _reserve, address _user) external;\r\n\r\n    function setUserUseReserveAsCollateral(\r\n        address _reserve,\r\n        bool _useAsCollateral\r\n    ) external;\r\n\r\n    function liquidationCall(\r\n        address _collateral,\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _purchaseAmount,\r\n        bool _receiveAToken\r\n    ) external payable;\r\n\r\n    function flashLoan(\r\n        address _receiver,\r\n        address _reserve,\r\n        uint256 _amount,\r\n        bytes calldata _params\r\n    ) external;\r\n\r\n    function getReserveConfigurationData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationDiscount,\r\n            address interestRateStrategyAddress,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool fixedBorrowRateEnabled,\r\n            bool isActive\r\n        );\r\n\r\n    function getReserveData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidity,\r\n            uint256 availableLiquidity,\r\n            uint256 totalBorrowsFixed,\r\n            uint256 totalBorrowsVariable,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 fixedBorrowRate,\r\n            uint256 averageFixedBorrowRate,\r\n            uint256 utilizationRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            address aTokenAddress,\r\n            uint40 lastUpdateTimestamp\r\n        );\r\n\r\n    function getUserAccountData(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityETH,\r\n            uint256 totalCollateralETH,\r\n            uint256 totalBorrowsETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function getUserReserveData(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentUnderlyingBalance,\r\n            uint256 currentBorrowBalance,\r\n            uint256 principalBorrowBalance,\r\n            uint256 borrowRateMode,\r\n            uint256 borrowRate,\r\n            uint256 liquidityRate,\r\n            uint256 originationFee,\r\n            uint256 variableBorrowIndex,\r\n            uint256 lastUpdateTimestamp,\r\n            bool usageAsCollateralEnabled\r\n        );\r\n\r\n    function getReserves() external view;\r\n}\r\n\r\n// File: contracts/aave-helper/ILendingPoolAddressesProvider.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n@title ILendingPoolAddressesProvider interface\r\n@notice provides the interface to fetch the LendingPoolCore address\r\n */\r\n\r\ncontract ILendingPoolAddressesProvider {\r\n    function getLendingPool() public view returns (address);\r\n\r\n    function setLendingPoolImpl(address _pool) public;\r\n\r\n    function getLendingPoolCore() public view returns (address payable);\r\n\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\r\n\r\n    function getLendingPoolConfigurator() public view returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\r\n\r\n    function getLendingPoolDataProvider() public view returns (address);\r\n\r\n    function setLendingPoolDataProviderImpl(address _provider) public;\r\n\r\n    function getLendingPoolParametersProvider() public view returns (address);\r\n\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider)\r\n        public;\r\n\r\n    function getTokenDistributor() public view returns (address);\r\n\r\n    function setTokenDistributor(address _tokenDistributor) public;\r\n\r\n    function getFeeProvider() public view returns (address);\r\n\r\n    function setFeeProviderImpl(address _feeProvider) public;\r\n\r\n    function getLendingPoolLiquidationManager() public view returns (address);\r\n\r\n    function setLendingPoolLiquidationManager(address _manager) public;\r\n\r\n    function getLendingPoolManager() public view returns (address);\r\n\r\n    function setLendingPoolManager(address _lendingPoolManager) public;\r\n\r\n    function getPriceOracle() public view returns (address);\r\n\r\n    function setPriceOracle(address _priceOracle) public;\r\n\r\n    function getLendingRateOracle() public view returns (address);\r\n\r\n    function setLendingRateOracle(address _lendingRateOracle) public;\r\n}\r\n\r\n// File: contracts/aave-helper/IFlashLoanReceiver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        bytes calldata _params\r\n    ) external;\r\n}\r\n\r\n// File: contracts/aave-helper/FlashloanReceiverBase.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract FlashLoanReceiverBase is IFlashLoanReceiver {\r\n    using SafeMath for uint256;\r\n\r\n    address constant ETHADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    ILendingPoolAddressesProvider public addressesProvider;\r\n\r\n    constructor(address _provider) internal {\r\n        addressesProvider = ILendingPoolAddressesProvider(_provider);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount)\r\n        internal\r\n    {\r\n        address payable core = addressesProvider.getLendingPoolCore();\r\n        transferInternal(core, _reserve, _amount);\r\n    }\r\n\r\n    function transferInternal(\r\n        address payable _destination,\r\n        address _reserve,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_reserve == ETHADDRESS) {\r\n            //solium-disable-next-line\r\n            _destination.call.value(_amount)(\"\");\r\n            return;\r\n        }\r\n\r\n        IERC20(_reserve).transfer(_destination, _amount);\r\n    }\r\n\r\n    function getBalanceInternal(address _target, address _reserve)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_reserve == ETHADDRESS) {\r\n            return _target.balance;\r\n        }\r\n\r\n        return IERC20(_reserve).balanceOf(_target);\r\n    }\r\n}\r\n\r\n// File: contracts/ContractWithFlashLoan.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract ContractWithFlashLoan is FlashLoanReceiverBase {\r\n    address AaveLendingPoolAddressProviderAddress;\r\n\r\n    constructor(address _provider) internal FlashLoanReceiverBase(_provider) {\r\n        AaveLendingPoolAddressProviderAddress = _provider;\r\n    }\r\n\r\n    function executeOperation(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        bytes calldata _params\r\n    ) external {\r\n        afterLoanSteps(_reserve, _amount, _fee, _params);\r\n\r\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\r\n    }\r\n\r\n    // Entry point\r\n    function initateFlashLoan(\r\n        address contractWithFlashLoan,\r\n        address assetToFlashLoan,\r\n        uint256 amountToLoan,\r\n        bytes memory _params\r\n    ) internal {\r\n        // Get Aave lending pool\r\n        ILendingPool lendingPool = ILendingPool(\r\n            ILendingPoolAddressesProvider(AaveLendingPoolAddressProviderAddress)\r\n                .getLendingPool()\r\n        );\r\n\r\n        // Ask for a flashloan\r\n        // LendingPool will now execute the `executeOperation` function above\r\n        lendingPool.flashLoan(\r\n            contractWithFlashLoan, // Which address to callback into, alternatively: address(this)\r\n            assetToFlashLoan,\r\n            amountToLoan,\r\n            _params\r\n        );\r\n    }\r\n\r\n    function afterLoanSteps(\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) internal {}\r\n}\r\n\r\n// File: contracts/creamfi-helper/ComptrollerInterface.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\ncontract ComptrollerInterface {\r\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\r\n    bool public constant isComptroller = true;\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cToken) external returns (uint);\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\r\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\r\n\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\r\n\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\r\n\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) external;\r\n\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint);\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external;\r\n\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n\r\n    function claimComp(address holder) public;\r\n    function claimComp(address holder, address[] memory cTokens) public;\r\n    function getCompAddress() public view returns (address);\r\n}\r\n\r\n// File: contracts/creamfi-helper/InterestRateModel.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title Compound's InterestRateModel Interface\r\n  * @author Compound\r\n  */\r\ncontract InterestRateModel {\r\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n    bool public constant isInterestRateModel = true;\r\n\r\n    /**\r\n      * @notice Calculates the current borrow interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amnount of reserves the market has\r\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\r\n\r\n    /**\r\n      * @notice Calculates the current supply interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amnount of reserves the market has\r\n      * @param reserveFactorMantissa The current reserve factor the market has\r\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\r\n\r\n}\r\n\r\n// File: contracts/creamfi-helper/CTokenInterfaces.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\ncontract CTokenStorage {\r\n    /**\r\n     * @dev Guard variable for re-entrancy checks\r\n     */\r\n    bool internal _notEntered;\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\r\n     */\r\n\r\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\r\n\r\n    /**\r\n     * @notice Maximum fraction of interest that can be set aside for reserves\r\n     */\r\n    uint internal constant reserveFactorMaxMantissa = 1e18;\r\n\r\n    /**\r\n     * @notice Administrator for this contract\r\n     */\r\n    address payable public admin;\r\n\r\n    /**\r\n     * @notice Pending administrator for this contract\r\n     */\r\n    address payable public pendingAdmin;\r\n\r\n    /**\r\n     * @notice Contract which oversees inter-cToken operations\r\n     */\r\n    ComptrollerInterface public comptroller;\r\n\r\n    /**\r\n     * @notice Model which tells what the current interest rate should be\r\n     */\r\n    InterestRateModel public interestRateModel;\r\n\r\n    /**\r\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\r\n     */\r\n    uint internal initialExchangeRateMantissa;\r\n\r\n    /**\r\n     * @notice Fraction of interest currently set aside for reserves\r\n     */\r\n    uint public reserveFactorMantissa;\r\n\r\n    /**\r\n     * @notice Block number that interest was last accrued at\r\n     */\r\n    uint public accrualBlockNumber;\r\n\r\n    /**\r\n     * @notice Accumulator of the total earned interest rate since the opening of the market\r\n     */\r\n    uint public borrowIndex;\r\n\r\n    /**\r\n     * @notice Total amount of outstanding borrows of the underlying in this market\r\n     */\r\n    uint public totalBorrows;\r\n\r\n    /**\r\n     * @notice Total amount of reserves of the underlying held in this market\r\n     */\r\n    uint public totalReserves;\r\n\r\n    /**\r\n     * @notice Total number of tokens in circulation\r\n     */\r\n    uint public totalSupply;\r\n\r\n    /**\r\n     * @notice Official record of token balances for each account\r\n     */\r\n    mapping (address => uint) internal accountTokens;\r\n\r\n    /**\r\n     * @notice Approved token transfer amounts on behalf of others\r\n     */\r\n    mapping (address => mapping (address => uint)) internal transferAllowances;\r\n\r\n    /**\r\n     * @notice Container for borrow balance information\r\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n     */\r\n    struct BorrowSnapshot {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Mapping of account addresses to outstanding borrow balances\r\n     */\r\n    mapping(address => BorrowSnapshot) internal accountBorrows;\r\n}\r\n\r\ncontract CTokenInterface is CTokenStorage {\r\n    /**\r\n     * @notice Indicator that this is a CToken contract (for inspection)\r\n     */\r\n    bool public constant isCToken = true;\r\n\r\n\r\n    /*** Market Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when interest is accrued\r\n     */\r\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when underlying is borrowed\r\n     */\r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is repaid\r\n     */\r\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is liquidated\r\n     */\r\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\r\n\r\n\r\n    /*** Admin Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is changed\r\n     */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\r\n     */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when comptroller is changed\r\n     */\r\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\r\n\r\n    /**\r\n     * @notice Event emitted when interestRateModel is changed\r\n     */\r\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserve factor is changed\r\n     */\r\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are added\r\n     */\r\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are reduced\r\n     */\r\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice EIP20 Transfer event\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @notice EIP20 Approval event\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /**\r\n     * @notice Failure event\r\n     */\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n\r\n    /*** User Interface ***/\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) public view returns (uint);\r\n    function exchangeRateCurrent() public returns (uint);\r\n    function exchangeRateStored() public view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() public returns (uint);\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\r\n    function _acceptAdmin() external returns (uint);\r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\r\n    function _reduceReserves(uint reduceAmount) external returns (uint);\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\r\n}\r\n\r\ncontract CErc20Storage {\r\n    /**\r\n     * @notice Underlying asset for this CToken\r\n     */\r\n    address public underlying;\r\n}\r\n\r\ncontract CErc20Interface is CErc20Storage {\r\n\r\n    /*** User Interface ***/\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _addReserves(uint addAmount) external returns (uint);\r\n}\r\n\r\ncontract CDelegationStorage {\r\n    /**\r\n     * @notice Implementation address for this contract\r\n     */\r\n    address public implementation;\r\n}\r\n\r\ncontract CDelegatorInterface is CDelegationStorage {\r\n    /**\r\n     * @notice Emitted when implementation is changed\r\n     */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\r\n}\r\n\r\ncontract CDelegateInterface is CDelegationStorage {\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @dev Should revert if any issues arise which make it unfit for delegation\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) public;\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() public;\r\n}\r\n\r\n// File: contracts/creamfi-helper/CEtherInterface.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\ncontract CEtherInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n}\r\n\r\n// File: contracts/Yielder.sol\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Yielder is ContractWithFlashLoan, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public constant ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    constructor(address _aaveLPProvider)\r\n        public\r\n        payable\r\n        ContractWithFlashLoan(_aaveLPProvider)\r\n    {}\r\n\r\n    function start(\r\n        address cTokenAddr,\r\n        uint256 flashLoanAmount,\r\n        bool isCEther,\r\n        bool windYield\r\n    ) public payable onlyOwner {\r\n        address loanToken;\r\n        if (isCEther) {\r\n            loanToken = ETHER;\r\n            // flashLoanAmount = msg.value;\r\n        } else {\r\n            loanToken = CErc20Interface(cTokenAddr).underlying();\r\n        }\r\n\r\n        bytes memory params = abi.encode(\r\n            msg.sender,\r\n            cTokenAddr,\r\n            isCEther,\r\n            windYield\r\n        );\r\n\r\n        initateFlashLoan(address(this), loanToken, flashLoanAmount, params);\r\n    }\r\n\r\n    function afterLoanSteps(\r\n        address loanedToken,\r\n        uint256 amount,\r\n        uint256 fees,\r\n        bytes memory params\r\n    ) internal {\r\n        address messageSender;\r\n        address cTokenAddr;\r\n        bool isCEther;\r\n        bool windYield;\r\n\r\n        (messageSender, cTokenAddr, isCEther, windYield) = abi.decode(\r\n            params,\r\n            (address, address, bool, bool)\r\n        );\r\n        require(owner() == messageSender, \"caller is not the owner\");\r\n\r\n        if (windYield) {\r\n            supplyToCream(cTokenAddr, amount, isCEther);\r\n            cTokenBorrow(cTokenAddr, amount);\r\n        } else {\r\n            repayBorrowedFromCream(cTokenAddr, amount, isCEther);\r\n            cTokenRedeemUnderlying(cTokenAddr, amount);\r\n        }\r\n\r\n        if (loanedToken == ETHER) {\r\n            return;\r\n        }\r\n\r\n        uint256 loanRepayAmount = amount.add(fees);\r\n        uint256 loanedTokenBalOfThis = IERC20(loanedToken).balanceOf(\r\n            address(this)\r\n        );\r\n        if (loanedTokenBalOfThis < loanRepayAmount) {\r\n            IERC20(loanedToken).transferFrom(\r\n                messageSender,\r\n                address(this),\r\n                loanRepayAmount - loanedTokenBalOfThis\r\n            );\r\n        }\r\n    }\r\n\r\n    function supplyToCream(\r\n        address cTokenAddr,\r\n        uint256 amount,\r\n        bool isCEther\r\n    ) public payable onlyOwner returns (bool) {\r\n        if (isCEther) {\r\n            CEtherInterface(cTokenAddr).mint.value(amount)();\r\n        } else {\r\n            address underlying = CErc20Interface(cTokenAddr).underlying();\r\n            checkBalThenTransferFrom(underlying, msg.sender, amount);\r\n            checkThenErc20Approve(underlying, cTokenAddr, amount);\r\n            cTokenMint(cTokenAddr, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function repayBorrowedFromCream(\r\n        address cTokenAddr,\r\n        uint256 amount,\r\n        bool isCEther\r\n    ) public payable onlyOwner returns (bool) {\r\n        if (isCEther) {\r\n            CEtherInterface(cTokenAddr).repayBorrow.value(amount)();\r\n        } else {\r\n            address underlying = CErc20Interface(cTokenAddr).underlying();\r\n            checkBalThenTransferFrom(underlying, msg.sender, amount);\r\n            checkThenErc20Approve(underlying, cTokenAddr, amount);\r\n            cTokenRepayBorrow(cTokenAddr, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function withdrawFromCream(address cTokenAddr, uint256 amount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return cTokenRedeemUnderlying(cTokenAddr, amount);\r\n    }\r\n\r\n    function borrowFromCream(address cTokenAddr, uint256 amount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return cTokenBorrow(cTokenAddr, amount);\r\n    }\r\n\r\n    function cTokenMint(address cToken, uint256 mintAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 err = CErc20Interface(cToken).mint(mintAmount);\r\n        require(err == 0, \"cToken mint failed\");\r\n        return true;\r\n    }\r\n\r\n    function cTokenRedeemUnderlying(address cToken, uint256 redeemAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 err = CErc20Interface(cToken).redeemUnderlying(redeemAmount);\r\n        require(err == 0, \"cToken redeem failed\");\r\n        return true;\r\n    }\r\n\r\n    function cTokenBorrow(address cToken, uint256 borrowAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 err = CErc20Interface(cToken).borrow(borrowAmount);\r\n        require(err == 0, \"cToken borrow failed\");\r\n        return true;\r\n    }\r\n\r\n    function cTokenRepayBorrow(address cToken, uint256 repayAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 err = CErc20Interface(cToken).repayBorrow(repayAmount);\r\n        require(err == 0, \"cToken repay failed\");\r\n        return true;\r\n    }\r\n\r\n    function claimCream(address comptroller) public onlyOwner {\r\n        ComptrollerInterface(comptroller).claimComp(address(this));\r\n    }\r\n\r\n    function claimAndTransferCream(address comptrollerAddr, address receiver)\r\n        public\r\n        onlyOwner\r\n    {\r\n        ComptrollerInterface comptroller = ComptrollerInterface(\r\n            comptrollerAddr\r\n        );\r\n        comptroller.claimComp(address(this));\r\n\r\n        IERC20 compToken = IERC20(comptroller.getCompAddress());\r\n        uint256 totalCompBalance = compToken.balanceOf(address(this));\r\n\r\n        require(\r\n            compToken.transfer(receiver, totalCompBalance),\r\n            \"cream transfer failed\"\r\n        );\r\n    }\r\n\r\n    function claimAndTransferCreamForCToken(\r\n        address comptrollerAddr,\r\n        address[] memory cTokens,\r\n        address receiver\r\n    ) public onlyOwner {\r\n        ComptrollerInterface comptroller = ComptrollerInterface(\r\n            comptrollerAddr\r\n        );\r\n        comptroller.claimComp(address(this), cTokens);\r\n\r\n        IERC20 compToken = IERC20(comptroller.getCompAddress());\r\n        uint256 totalCompBalance = compToken.balanceOf(address(this));\r\n\r\n        require(\r\n            compToken.transfer(receiver, totalCompBalance),\r\n            \"cream transfer failed\"\r\n        );\r\n    }\r\n\r\n    function checkBalThenTransferFrom(\r\n        address tokenAddress,\r\n        address user,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 balOfThis = IERC20(tokenAddress).balanceOf(address(this));\r\n        if (balOfThis < amount) {\r\n            IERC20(tokenAddress).transferFrom(user, address(this), amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function checkThenErc20Approve(\r\n        address tokenAddress,\r\n        address approveTo,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 allowance = IERC20(tokenAddress).allowance(\r\n            address(this),\r\n            approveTo\r\n        );\r\n        if (allowance < amount) {\r\n            IERC20(tokenAddress).approve(approveTo, uint256(-1));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferEth(address payable to, uint256 amount)\r\n        public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        return transferEthInternal(to, amount);\r\n    }\r\n\r\n    function transferEthInternal(address payable to, uint256 amount)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        to.transfer(amount);\r\n        return true;\r\n    }\r\n\r\n    function transferToken(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) public onlyOwner returns (bool success) {\r\n        return transferTokenInternal(token, to, amount);\r\n    }\r\n\r\n    function transferTokenInternal(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool success) {\r\n        IERC20(token).transfer(to, amount);\r\n        return true;\r\n    }\r\n\r\n    function supplyBalance(address cToken)\r\n        public\r\n        view\r\n        returns (uint256 supplyBalance)\r\n    {\r\n        uint256 cTokenBal = IERC20(cToken).balanceOf(address(this));\r\n        uint256 exchangeRateStored = CTokenInterface(cToken)\r\n            .exchangeRateStored();\r\n        supplyBalance = cTokenBal.mul(exchangeRateStored).div(1e18);\r\n    }\r\n\r\n    function borrowBalance(address cToken)\r\n        public\r\n        view\r\n        returns (uint256 borrowBalance)\r\n    {\r\n        borrowBalance = CTokenInterface(cToken).borrowBalanceStored(\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    function tokenBalance(address token) public view returns (uint256 balance) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function ethBalance() public view returns (uint256 balance) {\r\n        return address(this).balance;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aaveLPProvider\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressesProvider\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"borrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"borrowFromCream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptrollerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimAndTransferCream\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptrollerAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimAndTransferCreamForCToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"}],\"name\":\"claimCream\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCEther\",\"type\":\"bool\"}],\"name\":\"repayBorrowedFromCream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashLoanAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCEther\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"windYield\",\"type\":\"bool\"}],\"name\":\"start\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"supplyBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCEther\",\"type\":\"bool\"}],\"name\":\"supplyToCream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromCream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Yielder","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000024a42fd28c976a61df5d00d0599c34c4f90748c8","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0b44b1c0ac4107b5817a1067b0b49f3f7495b9b84d20c236afa71a7ed9759a0f"}]}