{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.6.6;\n\n\ncontract AddressSet {\n    struct Set\n    {\n        address[] addresses;\n        mapping (address => uint) positions;\n        uint count;\n    }\n    mapping (bytes32 => Set) private sets;\n\n    function addAddressToSet(\n        bytes32 key,\n        address addr,\n        bool maintainList\n        ) internal\n    {\n        Set storage set = sets[key];\n        require(set.positions[addr] == 0, \"ALREADY_IN_SET\");\n        \n        if (maintainList) {\n            require(set.addresses.length == set.count, \"PREVIOUSLY_NOT_MAINTAILED\");\n            set.addresses.push(addr);\n        } else {\n            require(set.addresses.length == 0, \"MUST_MAINTAIN\");\n        }\n\n        set.count += 1;\n        set.positions[addr] = set.count;\n    }\n\n    function removeAddressFromSet(\n        bytes32 key,\n        address addr\n        )\n        internal\n    {\n        Set storage set = sets[key];\n        uint pos = set.positions[addr];\n        require(pos != 0, \"NOT_IN_SET\");\n\n        delete set.positions[addr];\n        set.count -= 1;\n\n        if (set.addresses.length > 0) {\n            address lastAddr = set.addresses[set.count];\n            if (lastAddr != addr) {\n                set.addresses[pos - 1] = lastAddr;\n                set.positions[lastAddr] = pos;\n            }\n            set.addresses.pop();\n        }\n    }\n\n    function removeSet(bytes32 key)\n        internal\n    {\n        delete sets[key];\n    }\n\n    function isAddressInSet(\n        bytes32 key,\n        address addr\n        )\n        internal\n        view\n        returns (bool)\n    {\n        return sets[key].positions[addr] != 0;\n    }\n\n    function numAddressesInSet(bytes32 key)\n        internal\n        view\n        returns (uint)\n    {\n        Set storage set = sets[key];\n        return set.count;\n    }\n\n    function addressesInSet(bytes32 key)\n        internal\n        view\n        returns (address[] memory)\n    {\n        Set storage set = sets[key];\n        require(set.count == set.addresses.length, \"NOT_MAINTAINED\");\n        return sets[key].addresses;\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        virtual\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        override\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ninterface WalletRegistry {\n    function registerWallet(address wallet) external;\n    function isWalletRegistered(address addr) external view returns (bool);\n    function numOfWallets() external view returns (uint);\n}\n\ncontract WalletRegistryImpl is Claimable, AddressSet, WalletRegistry\n{\n    bytes32 internal constant WALLET = keccak256(\"__WALLET__\");\n\n    address internal factory;\n\n    event WalletRegistered      (address indexed wallet);\n    event WalletFactoryUpdated  (address indexed factory);\n\n    modifier onlyFactory()\n    {\n        require(msg.sender == factory, \"FACTORY_UNAUTHORIZED\");\n        _;\n    }\n\n    constructor() public Claimable() {}\n\n    function setWalletFactory(address _factory)\n        external\n        onlyOwner\n    {\n        require(_factory != address(0), \"ZERO_ADDRESS\");\n        factory = _factory;\n        emit WalletFactoryUpdated(factory);\n    }\n\n    function registerWallet(address wallet)\n        external\n        override\n        onlyFactory\n    {\n        addAddressToSet(WALLET, wallet, false);\n        emit WalletRegistered(wallet);\n    }\n\n    function isWalletRegistered(address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isAddressInSet(WALLET, addr);\n    }\n\n    function numOfWallets()\n        public\n        view\n        override\n        returns (uint)\n    {\n        return numAddressesInSet(WALLET);\n    }\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"WalletFactoryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"WalletRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isWalletRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfWallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"registerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setWalletFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WalletRegistryImpl","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}