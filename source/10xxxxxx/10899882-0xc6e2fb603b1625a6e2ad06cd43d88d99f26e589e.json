{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.1;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public totalBurnValue;\r\n    uint256 _totalSupply;\r\n    uint256 _totalDevSupply;\r\n    uint256 public devSupply;\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant distSupply = 100 * (10**6) * 10**decimals;   // 100m tokens for distribution\r\n    uint256 public constant devSupplyCap = 5 * (10**6) * 10**decimals;   // 5m tokens for community distribution\r\n    bool public hardCapAchieved;\r\n\r\n    mapping(address => uint256) _balances;\r\n    mapping(address => uint256) _burnBalances;\r\n\r\n    mapping(address => mapping(address => uint256)) _allowances;\r\n    mapping(address => mapping(address => uint256)) _burnAllowances;\r\n\r\n    event Purchase(address indexed from, uint256 ethValue, uint256 tokenValue);\r\n    event Claim(address indexed from, uint256 ethValue);\r\n    event Burn(address indexed from, uint256 tokenValue);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event CommunityTransfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed TokenOwner, address indexed spender, uint256 value);\r\n    event burnApproval(address indexed TokenOwner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() public virtual view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function totalDevSupply() public virtual view returns (uint256) {\r\n        return _totalDevSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public virtual view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function burnBalanceOf(address account) public virtual view returns (uint256) {\r\n        return _burnBalances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address TokenOwner, address spender) public virtual view returns (uint256) {\r\n        return _allowances[TokenOwner][spender];\r\n    }\r\n\r\n    function burnAllowance(address TokenOwner, address spender) public virtual view returns (uint256) {\r\n        return _burnAllowances[TokenOwner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function approveBurn(address spender, uint256 value) public virtual returns (bool) {\r\n        _approveBurn(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\r\n        require(_allowances[sender][msg.sender] >= amount,\"Insufficient balance in delegation.\");\r\n\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address sender, uint256 amount) public virtual returns (bool) {\r\n        require(_burnAllowances[sender][msg.sender] >= amount,\"Insufficient balance in delegation.\");\r\n\r\n        _burn(sender, amount);\r\n        _approveBurn(sender, msg.sender, _burnAllowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender,address recipient,uint256 amount) internal{\r\n        require(sender != address(0), \"Invalid sender address.\");\r\n        require(recipient != address(0), \"Invalid recipient address.\");\r\n        require(_balances[sender] >= amount, \"Insufficient balance.\");\r\n        require(amount >0, \"Invalid transfer amount.\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"Invalid recipient address.\");\r\n        require(hardCapAchieved==false, \"New tokens cannot be generated as contract hardcap is over.\");\r\n\r\n        if (_totalSupply.add(amount) >= distSupply) {\r\n            if (_totalSupply.add(amount) > distSupply) {\r\n                amount = distSupply.sub(_totalSupply); // calculate difference\r\n            }\r\n            hardCapAchieved=true; // no more mint is allowed\r\n        }\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n\r\n        if (devSupply != devSupplyCap) {\r\n            if (_totalSupply.div(10) < devSupplyCap) \r\n                devSupply = _totalSupply.div(10); // devSupply capped at 10% of totalSupply\r\n            else\r\n                devSupply = devSupplyCap;\r\n        }\r\n        \r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _mintForCommunity(address account, uint256 amount) internal {\r\n        require(account != address(0), \"Invalid recipient address.\");\r\n        require(amount >0,\"Please specefiy the amount of coins to be minted.\");\r\n        require(devSupply > _totalDevSupply, \"No Balance is left in community bucket for distribution.\");\r\n\r\n        if (_totalDevSupply.add(amount) > devSupply) {\r\n            amount = devSupply.sub(_totalDevSupply); // calculate difference\r\n        }\r\n\r\n        _totalDevSupply = _totalDevSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n\r\n        emit CommunityTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"Invalid account address.\");\r\n        require(hardCapAchieved==true, 'Burn is allowed only after the contract hardcap is achieved.');\r\n        require(_balances[account] >= value, \"Insufficient balance.\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        _burnBalances[account] = _burnBalances[account].add(value);\r\n        totalBurnValue = totalBurnValue.add(value);\r\n\r\n        emit Transfer(account, address(0), value);\r\n        emit Burn(account,value);\r\n    }\r\n\r\n    function _approve(address TokenOwner,address spender,uint256 value) internal {\r\n        require(TokenOwner != address(0),\"Invalid sender address.\");\r\n        require(spender != address(0), \"Invalid recipient address.\");\r\n\r\n        _allowances[TokenOwner][spender] = value;\r\n        emit Approval(TokenOwner, spender, value);\r\n    }\r\n\r\n    function _approveBurn(address TokenOwner,address spender,uint256 value) internal {\r\n        require(TokenOwner != address(0),\"Invalid sender address.\");\r\n        require(spender != address(0), \"Invalid recipient address.\");\r\n\r\n        _burnAllowances[TokenOwner][spender] = value;\r\n        emit burnApproval(TokenOwner, spender, value);\r\n    }\r\n}\r\n\r\ncontract NBTCToken is ERC20 {\r\n    address OwnerAddress;\r\n    uint256 public hardCapValidTime;\r\n\r\n    modifier isOwner() {\r\n        require(msg.sender == OwnerAddress);\r\n        _;\r\n    }\r\n\r\n    modifier isContractActive(){\r\n        require(hardCapAchieved == false,\"Contract is currently inactive as hardCap period/volume is over.\");\r\n        _;\r\n    }\r\n\r\n    function checkHardCap() public  {\r\n        if (block.timestamp > hardCapValidTime && hardCapAchieved==false) {\r\n            hardCapAchieved=true; // no more mint is allowed\r\n        }\r\n    }\r\n\r\n    constructor() {\r\n        OwnerAddress=msg.sender;\r\n        hardCapAchieved=false;\r\n        _totalSupply=0;\r\n        totalBurnValue=0;\r\n        devSupply=0;\r\n    } \r\n}\r\n\r\ncontract ReentrancyGuard {\r\n  bool private reentrancyLock = false;\r\n  \r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n}\r\n\r\ncontract NBTC is NBTCToken,ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => User) public users;\r\n    mapping (uint8 => Slab) public mulfact;\r\n    mapping (uint8 => uint8) public levelComm;\r\n    mapping (uint8 => uint256) public levelVolume;\r\n\r\n    uint256 public totalUsers;\r\n    uint8 public mfIndex;\r\n\r\n    struct User {\r\n        uint8 level;\r\n        uint256 directVolume;\r\n        uint256 indirectVolume;\r\n        uint32 directCount;\r\n        uint32 indirectCount;\r\n        uint256 claimed;  \r\n        address parent;\r\n        uint256 ethBalance; \r\n        uint256 ethInvest;\r\n    }\r\n\r\n    struct Slab {\r\n        uint256 saleVolume;\r\n        uint16 mulFactor;\r\n    }\r\n\r\n    constructor(string memory cName, string memory cSymbol,uint256 expireSeconds) {\r\n        name=cName;\r\n        symbol=cSymbol;\r\n\r\n        levelComm[1] = 50;\r\n        levelComm[2] = 60;\r\n        levelComm[3] = 65;\r\n        levelComm[4] = 70;\r\n        levelComm[5] = 75;\r\n        levelComm[6] = 80;\r\n        levelComm[7] = 85;\r\n        levelComm[8] = 90;\r\n        levelComm[9] = 95;\r\n        levelComm[10] = 100;\r\n\r\n        levelVolume[1] = 0;\r\n        levelVolume[2] = 1000 * 10**decimals; // 1k tokens\r\n        levelVolume[3] = 10000 * 10**decimals; // 10k lakh tokens\r\n        levelVolume[4] = 100000 * 10**decimals; // 1 lakh tokens\r\n        levelVolume[5] = 200000 * 10**decimals; // 2 lakh tokens\r\n        levelVolume[6] = 400000 * 10**decimals; // 4 lakh tokens\r\n        levelVolume[7] = 800000 * 10**decimals; // 8 lakh tokens\r\n        levelVolume[8] = 1600000 * 10**decimals; // 16 lakh tokens\r\n        levelVolume[9] = 3200000 * 10**decimals; // 32 lakh tokens\r\n        levelVolume[10] = 6400000 * 10**decimals; // 64 lakh tokens\r\n        \r\n        mulfact[1] = Slab({ saleVolume: 500000 * 10**decimals, mulFactor: 500 }); // 5 lakh token, 0.5 mil\r\n        mulfact[2] = Slab({ saleVolume: 2500000 * 10**decimals, mulFactor: 300 }); // 25 lakh token, 2.5 mil\r\n        mulfact[3] = Slab({ saleVolume: 5000000 * 10**decimals, mulFactor: 250 }); // 50 lakh token, 5 mil\r\n        mulfact[4] = Slab({ saleVolume: 10000000 * 10**decimals, mulFactor: 200 }); // 1 cr token, 10 mil\r\n        mulfact[5] = Slab({ saleVolume: 20000000 * 10**decimals, mulFactor: 175 }); // 2 cr token, 20 mil,\r\n        mulfact[6] = Slab({ saleVolume: 30000000 * 10**decimals, mulFactor: 150 }); // 3 cr token, 30 mil\r\n        mulfact[7] = Slab({ saleVolume: 40000000 * 10**decimals, mulFactor: 125 }); // 4 cr token, 40 mil\r\n        mulfact[8] = Slab({ saleVolume: 50000000 * 10**decimals, mulFactor: 100 }); // 5 cr token, 50 mil,\r\n        mulfact[9] = Slab({ saleVolume: 100000000 * 10**decimals, mulFactor: 50 }); // 10 cr token, 100 mil\r\n\r\n        mfIndex=1;\r\n        totalUsers=0;\r\n\r\n        hardCapValidTime = block.timestamp.add(expireSeconds);  // expire in one day ie in 86400 seconds\r\n\r\n        users[OwnerAddress] = User({\r\n        level: 10,\r\n        directVolume: 0,\r\n        indirectVolume: 0,\r\n        directCount:0,\r\n        indirectCount:0,\r\n        claimed:0,\r\n        parent: OwnerAddress,\r\n        ethBalance:0,\r\n        ethInvest:0\r\n        });\r\n    }\r\n\r\n    modifier userRegistered() {\r\n        require(users[msg.sender].level != 0, 'User does not exist');\r\n        _;\r\n    }\r\n\r\n    /* Dont accept eth*/  \r\n    receive() external payable {\r\n        revert(\"The contract does not accept direct payment, please use the purchase method with a referral address.\");\r\n    }\r\n\r\n    function mintForCommunity(address account, uint256 amount) public isOwner {\r\n        _mintForCommunity(account,amount) ;\r\n    }\r\n\r\n    function burn(uint256 amount) public returns (bool) {\r\n        require(balanceOf(msg.sender) >= amount,'Insufficient tokens to burn');\r\n        require(hardCapAchieved == true,\"You can not burn token as hardcap is not achieved.\");       \r\n\r\n        _burn(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    function withdraw(uint256 amount) external userRegistered nonReentrant{\r\n        require(users[msg.sender].ethBalance >=amount,'insufficient balance for withdrawl.');\r\n        require(amount > 0,'Invalid withdrawal amount.');\r\n    \r\n        users[msg.sender].ethBalance = users[msg.sender].ethBalance.sub(amount);\r\n        users[msg.sender].claimed = users[msg.sender].claimed.add(amount);\r\n        (bool success,  ) = msg.sender.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n        emit Claim(msg.sender,amount);\r\n    }\r\n\r\n    function purchase(address refAddress) external payable isContractActive {\r\n        require(refAddress != address(0), 'Referral Address is mandatory.');\r\n        require(users[refAddress].level != 0, 'Referral Address is not registered.');\r\n        require(msg.value >=100000000000000000,'Minimum purchase amount is 0.1 eth');\r\n        require(msg.value <=100000000000000000000,'Maximum purchase amount is 100 eth.');\r\n\r\n        bool isNewUser= false;\r\n        uint256 tokenVol;\r\n\r\n        uint commLeft;\r\n        uint commPer;\r\n        uint commGiven;\r\n        uint comm;\r\n        uint commVal;\r\n        address userAddr;\r\n        address parentAddr;\r\n\r\n        tokenVol= gettokenCount(msg.value); //msg.value.mul(100);\r\n\r\n        if (users[msg.sender].level == 0) {\r\n            register(refAddress);\r\n            isNewUser = true;\r\n        }\r\n        else\r\n            require(refAddress == users[msg.sender].parent, \"Sender belongs to different referral address\");\r\n\r\n        _mint(msg.sender, tokenVol);\r\n\r\n        // update eth balance and reserve 75 % \r\n        users[msg.sender].ethInvest = users[msg.sender].ethInvest.add(msg.value);\r\n        commLeft=100;\r\n        commGiven=0;\r\n        userAddr=msg.sender;\r\n\r\n        //distribute eth to parent heirarchy until level10\r\n        while (commLeft > 0) {\r\n            parentAddr=users[userAddr].parent;\r\n            commPer=levelComm[users[parentAddr].level];  // commission percentage at parent level\r\n            comm=commPer.sub(commGiven);              // comm to give  \r\n            commGiven=commGiven.add(comm);\r\n            commVal= msg.value.mul(comm).div(100);\r\n            users[parentAddr].ethBalance=users[parentAddr].ethBalance.add(commVal);\r\n            commLeft = commLeft.sub(comm);\r\n            userAddr=parentAddr;\r\n        }\r\n        \r\n        parentAddr=users[msg.sender].parent;\r\n\r\n        // add Volume to immediate parent node\r\n        users[parentAddr].directVolume=users[parentAddr].directVolume.add(tokenVol);\r\n        upgradelevel(parentAddr);\r\n        \r\n        //upgrade level and volume of the heirarchy till top node\r\n        userAddr = parentAddr;\r\n        \r\n        while (userAddr !=users[parentAddr].parent)\r\n        {\r\n            parentAddr=users[userAddr].parent;\r\n            users[parentAddr].indirectVolume=users[parentAddr].indirectVolume.add(tokenVol);\r\n            if (isNewUser)\r\n                users[parentAddr].indirectCount+=1;\r\n            upgradelevel(parentAddr);\r\n            userAddr=parentAddr;\r\n        }\r\n\r\n        checkHardCap();\r\n        emit Purchase(msg.sender,msg.value,tokenVol);\r\n    }\r\n\r\n    function upgradelevel(address refAddr) internal\r\n    {\r\n            uint256 totVolume;\r\n            uint8 idx;\r\n            \r\n            totVolume = users[refAddr].directVolume.add(users[refAddr].indirectVolume);\r\n            idx =users[refAddr].level;\r\n\r\n            while (idx <=10)\r\n            {\r\n                if(totVolume >= levelVolume[idx]) \r\n                    users[refAddr].level = idx;  \r\n                else    \r\n                    break;\r\n\r\n                idx++;\r\n            }\r\n    }\r\n\r\n    function register(address refAddr) internal\r\n    {\r\n        users[msg.sender] = User({\r\n            level: 1,\r\n            directVolume: 0,\r\n            indirectVolume: 0,\r\n            directCount:0,\r\n            indirectCount:0,\r\n            claimed:0,\r\n            parent: refAddr,\r\n            ethBalance:0,\r\n            ethInvest:0\r\n        });\r\n        \r\n        users[refAddr].directCount+=1;\r\n        totalUsers=totalUsers.add(1);\r\n    }\r\n    \r\n    function estimateTokenCount(uint256 ethVal) public view returns (uint256) {\r\n        require(ethVal >=100000000000000000,'Minimum estimation value is 0.1 ethereum.');\r\n        require(ethVal <=100000000000000000000,'Maximum estimation value is 100 ethereum.');\r\n\r\n        uint16 mf;\r\n        uint256 tokenCnt;\r\n        uint256 postSupply;\r\n        uint256 diff;\r\n        uint256 ethUsed;\r\n        uint256 ethLeft;\r\n        \r\n        mf = mulfact[mfIndex].mulFactor;\r\n        tokenCnt=ethVal.mul(mf);\r\n        postSupply=_totalSupply.add(tokenCnt);\r\n\r\n        if (postSupply > mulfact[mfIndex].saleVolume && mfIndex !=9)\r\n        {\r\n            diff = mulfact[mfIndex].saleVolume.sub(_totalSupply);\r\n            ethUsed= diff.div(mf);\r\n            ethLeft = ethVal.sub(ethUsed);\r\n            mf = mulfact[mfIndex+1].mulFactor;\r\n            tokenCnt=diff.add(ethLeft.mul(mf));\r\n            postSupply=_totalSupply.add(tokenCnt);\r\n        }\r\n\r\n        if (postSupply >distSupply) {\r\n            tokenCnt = distSupply.sub(_totalSupply);\r\n        }\r\n        return tokenCnt;\r\n    }\r\n\r\n    function gettokenCount(uint256 ethVal) internal returns (uint256) {\r\n        uint16 mf;\r\n        uint256 tokenCnt;\r\n        uint256 postSupply;\r\n        uint256 diff;\r\n        uint256 ethUsed;\r\n        uint256 ethLeft;\r\n        \r\n        mf = mulfact[mfIndex].mulFactor;\r\n        tokenCnt=ethVal.mul(mf);\r\n        postSupply=_totalSupply.add(tokenCnt);\r\n\r\n        if (postSupply > mulfact[mfIndex].saleVolume && mfIndex !=9)\r\n        {\r\n            diff = mulfact[mfIndex].saleVolume.sub(_totalSupply);\r\n            ethUsed= diff.div(mf);\r\n            ethLeft = ethVal.sub(ethUsed);\r\n            mf = mulfact[mfIndex+1].mulFactor;\r\n            tokenCnt=diff.add(ethLeft.mul(mf));\r\n            postSupply=_totalSupply.add(tokenCnt);\r\n            mfIndex +=1;\r\n        }\r\n\r\n        if (postSupply >distSupply) {\r\n            tokenCnt = distSupply.sub(_totalSupply);\r\n        }\r\n        return tokenCnt;\r\n    }\r\n\r\n    function calculateEthValue(uint256 tokenVal) public view returns (uint256) {\r\n        require(tokenVal >=5000000000000000000,'Minimum estimation value is 5 nbtc tokens.');\r\n        require(tokenVal <=50000000000000000000000,'Maximum estimation value is 50000 nbtc tokens.');\r\n\r\n        uint16 mf;\r\n        uint256 ethVal;\r\n        uint256 postSupply;\r\n        uint256 diff;\r\n        uint256 ethUsed;\r\n        uint256 tokenLeft;\r\n        \r\n        mf = mulfact[mfIndex].mulFactor;\r\n        ethVal=tokenVal.div(mf);\r\n        postSupply=_totalSupply.add(tokenVal);\r\n\r\n        if (postSupply > mulfact[mfIndex].saleVolume && mfIndex !=9) {\r\n            diff = mulfact[mfIndex].saleVolume.sub(_totalSupply);\r\n            ethUsed= diff.div(mf);\r\n            tokenLeft = tokenVal.sub(diff);\r\n            mf = mulfact[mfIndex+1].mulFactor;\r\n            ethVal= ethUsed.add(tokenLeft.div(mf));\r\n        }\r\n        \r\n        return ethVal;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"cSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expireSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"TokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenValue\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CommunityTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenValue\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"TokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnApproval\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"burnAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"burnBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenVal\",\"type\":\"uint256\"}],\"name\":\"calculateEthValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkHardCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devSupplyCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethVal\",\"type\":\"uint256\"}],\"name\":\"estimateTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardCapAchieved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardCapValidTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelComm\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mfIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintForCommunity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"mulfact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"saleVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"mulFactor\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refAddress\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDevSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"directVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indirectVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"directCount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"indirectCount\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethInvest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NBTC","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000001c75920000000000000000000000000000000000000000000000000000000000000000a4e6577426974436f696e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e42544300000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fb6ab35bb6da3b6fe91e6b3999bee5716e1e02d04b2660e04b40b0ca524226f2"}]}