{"status":"1","message":"OK","result":[{"SourceCode":"{\"EternalStorageData.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @author Quant Network\\n * @title EternalStorage\\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\\n */\\ncontract EternalStorage {\\n\\n  mapping(bytes32 =\\u003e bool) internal boolStorage;\\n  mapping(bytes32 =\\u003e address) internal addressStorage;\\n  mapping(bytes32 =\\u003e string) internal stringStorage;\\n  mapping(bytes32 =\\u003e bytes) internal bytesStorage;\\n\\n  mapping(bytes32 =\\u003e bytes1) internal bytes1Storage;\\n  mapping(bytes32 =\\u003e bytes2) internal bytes2Storage;\\n  mapping(bytes32 =\\u003e bytes4) internal bytes4Storage;\\n  mapping(bytes32 =\\u003e bytes8) internal bytes8Storage;\\n  mapping(bytes32 =\\u003e bytes16) internal bytes16Storage;\\n  mapping(bytes32 =\\u003e bytes32) internal bytes32Storage;\\n  \\n  mapping(bytes32 =\\u003e int8) internal int8Storage;\\n  mapping(bytes32 =\\u003e int16) internal int16Storage;\\n  mapping(bytes32 =\\u003e int32) internal int32Storage;\\n  mapping(bytes32 =\\u003e int64) internal int64Storage;\\n  mapping(bytes32 =\\u003e int128) internal int128Storage;\\n  mapping(bytes32 =\\u003e int256) internal int256Storage;\\n  \\n  mapping(bytes32 =\\u003e uint8) internal uint8Storage;\\n  mapping(bytes32 =\\u003e uint16) internal uint16Storage;\\n  mapping(bytes32 =\\u003e uint32) internal uint32Storage;\\n  mapping(bytes32 =\\u003e uint64) internal uint64Storage;\\n  mapping(bytes32 =\\u003e uint128) internal uint128Storage;\\n  mapping(bytes32 =\\u003e uint256) internal uint256Storage;\\n\\n\\n}\"},\"Treasury.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./TreasuryBase.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title This contract holds a specific treasury\\u0027s information\\n */\\ncontract Treasury is TreasuryBase {\\n\\n        // The addresses variables in the speed bump\\n        bytes constant private speedBumpAddresses1 = \\u00271.speedBump.addresses\\u0027;\\n        // The uint variables  in  the speed bump\\n        bytes constant private speedBumpUint16s1 = \\u00271.speedBump.uint16s\\u0027;\\n        // If this speed bump wants to pause the contract\\n        bytes constant private speedBumpCircuitBreaker1 = \\u00271.speedBump.circuitBreaker\\u0027;\\n        // What time this SpeedBump was created at\\n        bytes constant private speedBumpTimeCreated1 = \\u00271.speedBump.timeCreated\\u0027;\\n        // this contract\\u0027s pending speedBumpHours\\n        bytes constant private speedBumpNextSBHours1 = \\u00271.speedBump.nextSBHours\\u0027;\\n        // this contract\\u0027s current speed bump time period\\n        bytes constant private speedBumpCurrentSBHours1 = \\u00271.speedBump.currentSBHours\\u0027;\\n\\n        // The event fired when other contracts have been connected:\\n        event connectedContracts(address factory, address ruleList, address escrowedDeposit);\\n        // The event fired when the treasury\\u0027s variables have been updated:\\n        event updatedTreasuryVariables(uint16 mappDisputeFeeMultipler, uint16 commissionDivider, uint16 gatewayPenaltyMultipler, uint16 treasuryPenaltyMultipler);\\n        // The event fired when the treasury\\u0027s key variables have been updated:\\n        event updatedTreasuryMainVariables(address newWithdrawalAddress, address newOperator, bool circuitBreaker);\\n        // The event fired when new information on the verification has been added:\\n        event updatedTreasuryFunctionVerification(string verificationDetails, string locationOfDetails);\\n        // The event fired when a speed bump has been created:\\n        event updatedSpeedBump(uint speedBumpIndex,uint256 timeCreated,uint256 speedBumpHours);\\n        \\n        /**\\n         * All functions with this modifier can only be called by the current treasury operator\\n         */    \\n        modifier onlyOperator(){\\n            if (msg.sender != operatorAddress()){\\n                revert(\\\"Only the operator address of this contract can modify its associated storage\\\");\\n            } else {\\n                _; //means carry on with the computation\\n            }\\n        }\\n        \\n        /**\\n         * Sets the treasury\\u0027s initial variables\\n         * @param thisQNTAddress  - the QNT address associated to this contract (can be a cold wallet)\\n         * @param thisOperatorAddress  - the operator address of this contract\\n         * @param mappDisputeFee - the fee the mapp has to pay for any dispute raised, chargeable per gateway\\n         * @param commission - the commission divider charged for every mapp to gateway transaction. \\n         * The divider is used with the original fee of the function.\\n         * I.e a commission divider of 2 is equal to 50% commission\\n         * @param treasuryPenalty - the penalty multiplier the treasury has to pay if it has been found in breach of \\n         * one of its verification rules. The mulitipication is used with the original fee of the function.\\n         * I.e. a treasuryPenalty of 5 is equal to a 5x penalty\\n         * @param gatewayPenalty - the penalty multiplier a gateway has to pay if it has be found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function\\n         * I.e. a gatewayPenalty of 10 is equal to a 10x penalty.\\n         */ \\n        function initialize (address thisQNTAddress, address thisOperatorAddress, uint16 mappDisputeFee, uint16 commission, uint16 treasuryPenalty, uint16 gatewayPenalty, uint16 speedBumpTime) external {\\n            require(!initialized(),\\\"contract can only be initialised once\\\");\\n            QNTAddress(thisQNTAddress);\\n            operatorAddress(thisOperatorAddress);\\n            circuitBreakerOn(false);\\n            mappDisputeFeeMultipler(mappDisputeFee);\\n            commissionDivider(commission);\\n            treasuryPenaltyMultipler(treasuryPenalty);\\n            gatewayPenaltyMultipler(gatewayPenalty);\\n            speedBumpHours(speedBumpTime);\\n            //set the admin who can upgrade:\\n            addressStorage[keccak256(\\u0027proxy.admin\\u0027)] = thisOperatorAddress;\\n            initializeNow(); //sets this contract to initialized\\n        }\\n\\n        /**\\n         * Connect the treasury to its subcontracts, as detailed in speedBump[0], \\n         * which should have been added via the updateSpeedBump function below\\n         * param: speedBump[0].addresses[0] - the linked treasurysFactory contract\\n         * param: speedBump[0].addresses[1] - the linked treasurysRuleList contract\\n         * param: speedBump[0].addresses[2] - the linked treasuryDeposit contract\\n         */\\n        function updateTreasuryContracts() external onlyOperator() {\\n            uint8 sb = 0;\\n            uint256 sBTimeCreated = speedBumpTimeCreated(sb);\\n            require(sBTimeCreated \\u003e 0, \\\"Time created must be \\u003e0 (to stop replays of the speed bump)\\\");\\n            require(now \\u003e sBTimeCreated + (speedBumpCurrentSBHours(sb)*1 hours), \\\"The speed bump time period must have passed\\\");\\n            // make the key state changes\\n            treasurysFactory(speedBumpAddresses(sb, 0));\\n            treasurysRuleList(speedBumpAddresses(sb, 1));\\n            treasurysDeposit(speedBumpAddresses(sb, 2));\\n            // wipe the speed bump\\n            speedBumpAddresses(sb, 0, address(0));\\n            speedBumpAddresses(sb, 1, address(0));\\n            speedBumpAddresses(sb, 2, address(0));\\n            speedBumpTimeCreated(sb,0);\\n            speedBumpCurrentSBHours(sb,0);\\n            //emit event\\n            emit connectedContracts(treasurysFactory(), treasurysRuleList(), treasurysDeposit());\\n        }\\n        \\n        /**\\n         * Updates the treasury\\u0027s fee variables, as detailed in speedBump[1]\\n         * param: speedBump[1].uint16s[0] - the fee the mapp has to pay for any dispute raised, chargeable per gateway\\n         * param: speedBump[1].uint16s[1] - the commission divider charged for every mapp to gateway transaction. \\n         * param: speedBump[1].uint16s[2] - the penalty multiplier for the treasury has  to pay if it has be found in breach of one of its verification rules.\\n         * param: speedBump[1].uint16s[3] - the penalty multiplier a gateway has to pay if it has be found in breach of one of its verification rules. \\n         */\\n        function updateTreasuryFeeVariables() external onlyOperator() {\\n            uint8 sb = 1;\\n            uint256 sBTimeCreated = speedBumpTimeCreated(sb);\\n            require(sBTimeCreated \\u003e 0, \\\"Time created must be \\u003e0 (to stop replays of the speed bump)\\\");\\n            require(now \\u003e sBTimeCreated + (speedBumpCurrentSBHours(sb)*1 hours), \\\"The speed bump time period must have passed\\\");\\n            // make the key state changes\\n            mappDisputeFeeMultipler(speedBumpUint16s(sb, 0));\\n            commissionDivider(speedBumpUint16s(sb, 1));\\n            treasuryPenaltyMultipler(speedBumpUint16s(sb, 2));\\n            gatewayPenaltyMultipler(speedBumpUint16s(sb, 3));\\n            // wipe the speed bump\\n            speedBumpUint16s(sb, 0, 0);\\n            speedBumpUint16s(sb, 1, 0);\\n            speedBumpUint16s(sb, 2, 0);\\n            speedBumpUint16s(sb, 3, 0);\\n            speedBumpTimeCreated(sb,0);\\n            speedBumpCurrentSBHours(sb,0);\\n            //emit event\\n            emit updatedTreasuryVariables(mappDisputeFeeMultipler(),commissionDivider(),gatewayPenaltyMultipler(),treasuryPenaltyMultipler());\\n        }\\n        \\n        /**\\n         * Updates the treasury\\u0027s QNT address, operator and circuitBreaker, as detailed in speedBump[2]\\n         * param: speedBump[2].addresses[0] - the treasury\\u0027s new QNT Address\\n         * param: speedBump[2].addresses[1] - the treasury\\u0027s new operator address\\n         * param: speedBump[2].circuitBreaker - if this treasury circuitBreaker has been activated \\n         * param: speedBump[2].nextSBHours - the next speed bump time  to use\\n         */\\n        function updateTreasuryMainVariables() external onlyOperator() {\\n            uint8 sb = 2;\\n            uint256 sBTimeCreated = speedBumpTimeCreated(sb);\\n            require(sBTimeCreated \\u003e 0, \\\"Time created must be \\u003e0 (to stop replays of the speed bump)\\\");\\n            require(now \\u003e sBTimeCreated + (speedBumpCurrentSBHours(sb)*1 hours), \\\"The speed bump time period must have passed\\\");            \\n            //make the key state changes\\n            QNTAddress(speedBumpAddresses(sb, 0));\\n            operatorAddress(speedBumpAddresses(sb, 1));\\n            circuitBreakerOn(speedBumpCircuitBreaker(sb));\\n            speedBumpHours(speedBumpNextSBHours(sb));\\n            //wipe the speed bump\\n            speedBumpAddresses(sb, 0, address(0));\\n            speedBumpAddresses(sb, 1, address(0));\\n            speedBumpCircuitBreaker(sb,false);\\n            speedBumpTimeCreated(sb,0);\\n            speedBumpCurrentSBHours(sb,0);\\n            speedBumpNextSBHours(sb,0);\\n            //emit event\\n            emit updatedTreasuryMainVariables(QNTAddress(),operatorAddress(),circuitBreakerOn());\\n        }\\n\\n        /**\\n         * adds a new speed bump for the updateTreasuryMainVariables function\\n         * @param addresses - the address variables for the function (QNT address and operator)\\n         * @param newSpeedBumpHours - the new requested speed bump time \\n         * @param circuitBreaker - whether this treasury should pause operations\\n         */\\n        function speedBumpMain(address[] calldata addresses, uint16 newSpeedBumpHours, bool circuitBreaker) external onlyOperator() {\\n            uint8 sb = 2;\\n            addressStorage[keccak256(abi.encodePacked(speedBumpAddresses1,sb, int8(0)))] = addresses[0];\\n            addressStorage[keccak256(abi.encodePacked(speedBumpAddresses1,sb, int8(1)))] = addresses[1];\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpNextSBHours1,sb))] = newSpeedBumpHours;\\n            boolStorage[keccak256(abi.encodePacked(speedBumpCircuitBreaker1,sb))] = circuitBreaker;\\n            // set the time as now\\n            uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,sb))] = now;\\n            // set the speedBump hours as they are now\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpCurrentSBHours1,sb))] = speedBumpHours();\\n            // emit event\\n            emit updatedSpeedBump(sb,now,speedBumpHours());\\n        }\\n \\n        /**\\n         * adds a new speed bump for the updateTreasuryFeeVariables function\\n         * @param uint16s - the uint16s variables for the function (see function description for full list)\\n         */\\n        function speedBumpFee(uint16[] calldata uint16s) external onlyOperator() {\\n            uint8 sb = 1;\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpUint16s1,sb,int8(0)))] = uint16s[0];\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpUint16s1,sb,int8(1)))] = uint16s[1];\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpUint16s1,sb,int8(2)))] = uint16s[2];\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpUint16s1,sb,int8(3)))] = uint16s[3];\\n            // set the time as now\\n            uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,sb))] = now;\\n            // set the speedBump hours as they are now\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpCurrentSBHours1,sb))] = speedBumpHours();\\n            // emit event\\n            emit updatedSpeedBump(sb,now,speedBumpHours());\\n        }\\n        \\n        /**\\n         * adds a new speed bump for the updateTreasuryContracts function\\n         * @param addresses - the addresses of the new contracts (see function description for a full list)\\n         */\\n        function speedBumpContract(address[] calldata addresses) external onlyOperator() {\\n            uint8 sb = 0;\\n            addressStorage[keccak256(abi.encodePacked(speedBumpAddresses1,sb, int8(0)))] = addresses[0];\\n            addressStorage[keccak256(abi.encodePacked(speedBumpAddresses1,sb, int8(1)))] = addresses[1];\\n            addressStorage[keccak256(abi.encodePacked(speedBumpAddresses1,sb, int8(2)))] = addresses[2];\\n            // set the time as now\\n            uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,sb))] = now;\\n            // set the speedBump hours as they are now\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpCurrentSBHours1,sb))] = speedBumpHours();\\n            // emit event\\n            emit updatedSpeedBump(sb,now,speedBumpHours());\\n        }\\n        \\n        /**\\n         * Gets the function penalty multipler\\n         * @return - the penalty amount\\n         */\\n        function readFunctionPenaltyMultipler(bool gateway) external view returns (uint256) {\\n            if (gateway == true){\\n                return gatewayPenaltyMultipler();\\n            } else {\\n                return treasuryPenaltyMultipler();\\n            }\\n        }\\n        \\n        /**\\n        * Sets an address variable in a SpeedBump\\n        * @param index - the speed bump to modify\\n        * @param addressIndex - the address to modify\\n        * @param newAddress - the new address\\n         */        \\n        function speedBumpAddresses(uint8 index, uint8 addressIndex, address newAddress) internal {\\n            addressStorage[keccak256(abi.encodePacked(speedBumpAddresses1,index, addressIndex))] = newAddress;\\n        }\\n        \\n        /**\\n         * Sets an uint16 variable in a SpeedBump\\n         * @param index - the speed bump to modify \\n         * @param uint16Index - the uint16 to modify\\n         * @param newUint16 - the new uint16 to save\\n         */         \\n        function speedBumpUint16s(uint8 index, uint8 uint16Index, uint16 newUint16) internal {\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpUint16s1,index,uint16Index))] = newUint16;\\n        } \\n        \\n        /**\\n         * Sets the circuitBreaker variable in a SpeedBump\\n         * @param index - the speed bump to modify \\n         * @param newCircuitBreaker - the new circuitBreaker \\n         */       \\n        function speedBumpCircuitBreaker(uint8 index, bool newCircuitBreaker) internal {\\n            boolStorage[keccak256(abi.encodePacked(speedBumpCircuitBreaker1,index))] = newCircuitBreaker;\\n        } \\n        \\n        /**\\n         * Reads the time the speedBump was created at\\n         * @param index - the speed bump to modify\\n         * @param timeCreated - the time the speed bump was created\\n         */      \\n        function speedBumpTimeCreated(uint8 index, uint256 timeCreated) internal {\\n            uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,index))] = timeCreated;\\n        } \\n        \\n        /**\\n         * Sets the number of hours that this contract\\u0027s SpeedBump will be updated to\\n         * @param index - the speed bump to read\\n         * @param newSpeedBumpHours - the number of hours\\n         */       \\n        function speedBumpNextSBHours(uint8 index, uint16 newSpeedBumpHours) internal {\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpNextSBHours1,index))] = newSpeedBumpHours;\\n        }\\n\\n        /**\\n         * Sets the number of hours until the SpeedBump can be used\\n         * @param index - the speed bump to read\\n         * @param newCurrentSBHours - the number of hours\\n         */       \\n        function speedBumpCurrentSBHours(uint8 index, uint16 newCurrentSBHours) internal {\\n            uint16Storage[keccak256(abi.encodePacked(speedBumpCurrentSBHours1,index))] = newCurrentSBHours;\\n        }\\n        \\n        \\n        /**\\n        * Reads an address variable in a SpeedBump\\n        * @param index - the speed bump to read \\n        * @param addressIndex - the address to read\\n        * @return - the specific address\\n         */        \\n        function speedBumpAddresses(uint8 index, uint8 addressIndex) public view returns (address){\\n            return addressStorage[keccak256(abi.encodePacked(speedBumpAddresses1,index,addressIndex))];\\n        }\\n        \\n        /**\\n         * Reads an uint16 variable in a SpeedBump\\n         * @param index - the speed bump to read \\n         * @param uint16Index - the uint16 to read\\n         * @return - the specific uint16\\n         */     \\n        function speedBumpUint16s(uint8 index, uint8 uint16Index) public view returns (uint16){\\n            return uint16Storage[keccak256(abi.encodePacked(speedBumpUint16s1,index,uint16Index))];\\n        } \\n        \\n        /**\\n         * Reads the circuitBreaker variable in a SpeedBump\\n         * @param index - the speed bump to read \\n         * @return - the specific circuitBreaker \\n         */       \\n        function speedBumpCircuitBreaker(uint8 index) public view returns (bool){\\n            return boolStorage[keccak256(abi.encodePacked(speedBumpCircuitBreaker1,index))];\\n        } \\n\\n        /**\\n         * Reads the time the speedBump was created at\\n         * @param index - the speed bump to read\\n         * @return - the creation time\\n         */ \\n        function speedBumpTimeCreated(uint8 index) public view returns (uint256){\\n            return uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,index))];\\n        } \\n        \\n       /**\\n         * @return - this contract\\u0027s pending speedBumpHours\\n         */\\n        function speedBumpNextSBHours(uint8 index) public view returns (uint16){\\n            return uint16Storage[keccak256(abi.encodePacked(speedBumpNextSBHours1,index))];\\n        }\\n    \\n       /**\\n         * @return - the time this contract\\u0027s pending request was created\\n         */\\n        function speedBumpCurrentSBHours(uint8 index) public view returns (uint16){\\n            return uint16Storage[keccak256(abi.encodePacked(speedBumpCurrentSBHours1,index))];\\n        }\\n\\n}\"},\"TreasuryBase.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title TreasuryAbstract\\n * @dev Sets the main variables of a Treasury contract and allows other contracts to easily interface with a Treasury contract without knowing the whole code. \\n */\\ncontract TreasuryBase is UpgradeableProxy {\\n    \\n        // the connected factory of this treasury\\n        bytes constant private treasurysFactory1 = \\u00271.treasurysFactory\\u0027;\\n        // the connected rulelist of this treasury\\n        bytes constant private treasurysRuleList1 = \\u00271.treasurysRuleList\\u0027;\\n        // the treasury\\u0027s escrowed deposit\\n        bytes constant private treasurysDeposit1 = \\u00271.treasuryDeposit\\u0027;\\n        // the QNT address of this treasury (possible cold wallet)   \\n        bytes constant private QNTAddress1 = \\u00271.QNTAddress\\u0027;\\n        // the operator address of this treasury, which can call other smart contract functions on behalf of the treasury\\n        bytes constant private operatorAddress1 = \\u00271.operatorAddress\\u0027;\\n        // whether this treasury is currently paused (true) or active (false)\\n        bytes constant private circuitBreakerOn1 = \\u00271.circuitBreakerOn\\u0027;\\n        // the fee the MAPP has to pay for any dispute raised per gateway\\n        bytes constant private mappDisputeFeeMultipler1 = \\u00271.mappDisputeFeeMultipler\\u0027;\\n        // the commission divider charged for every mapp to gateway transaction. \\n        // The divider is used with the original fee of the function.\\n        // I.e a commission divider of 2 is equal to 50% commission\\n        bytes constant private commissionDivider1 = \\u00271.commissionDivider\\u0027;\\n        // the penalty multiplier the treasury has to pay if it has been found in breach of \\n        // one of its verification rules. The mulitipication is used with the original fee of the function.\\n        // I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n        bytes constant private  treasuryPenaltyMultipler1 = \\u00271.treasuryPenaltyMultipler\\u0027;\\n        // the penalty multiplier a gateway has to pay if it has be found in breach of\\n        // one of its verification rules. The mulitipication is used with the original fee of the function\\n        // I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n        bytes constant private gatewayPenaltyMultipler1 = \\u00271.gatewayPenaltyMultipler\\u0027;\\n\\n        /**\\n         * set a new factory for this treasury\\n         */        \\n        function treasurysFactory(address newTreasurysFactory) internal {\\n            addressStorage[keccak256(treasurysFactory1)] = newTreasurysFactory;\\n        } \\n        \\n        \\n        /**\\n         * set a new rulelist for this treasury\\n         */        \\n        function treasurysRuleList(address newTreasurysRuleList) internal {\\n            addressStorage[keccak256(treasurysRuleList1)] = newTreasurysRuleList;\\n        } \\n\\n        /**\\n         * set a new treasury deposit \\n         */        \\n        function treasurysDeposit(address newTreasuryDeposit) internal {\\n            addressStorage[keccak256(treasurysDeposit1)] = newTreasuryDeposit;\\n        }\\n        \\n        /**\\n         * set a new QNTAddress for this treasury\\n         */        \\n        function QNTAddress(address newQNTAddress) internal {\\n            addressStorage[keccak256(QNTAddress1)] = newQNTAddress;\\n        }\\n        \\n        /**\\n         * set a new operator for this treasury\\n         */        \\n        function operatorAddress(address newOperator) internal {\\n            addressStorage[keccak256(operatorAddress1)] = newOperator;\\n        }\\n        \\n        /**\\n         * set the circuitbreaker of this treasury\\n         */        \\n        function circuitBreakerOn(bool newCircuitBreakerOn) internal {\\n            boolStorage[keccak256(circuitBreakerOn1)] = newCircuitBreakerOn;\\n        }\\n        \\n        /**\\n         * set the mapp dispute fee multiplier\\n         */        \\n        function mappDisputeFeeMultipler(uint16 newMappDisputeFeeMultipler) internal {\\n            uint16Storage[keccak256(mappDisputeFeeMultipler1)] = newMappDisputeFeeMultipler;\\n        }\\n        \\n \\n        /**\\n         * set the commission divider\\n         */        \\n        function commissionDivider(uint16 neCommissionDivider) internal {\\n            uint16Storage[keccak256(commissionDivider1)] = neCommissionDivider;\\n        }\\n\\n        /**\\n         * set the treasury dispute multiplier\\n         */        \\n        function treasuryPenaltyMultipler(uint16 newTreasuryPenaltyMultipler) internal {\\n            uint16Storage[keccak256(treasuryPenaltyMultipler1)] = newTreasuryPenaltyMultipler;\\n        }\\n\\n        /**\\n         * set the gateway dispute multiplier\\n         */        \\n        function gatewayPenaltyMultipler(uint16 newGatewayPenaltyMultipler) internal {\\n            uint16Storage[keccak256(gatewayPenaltyMultipler1)] = newGatewayPenaltyMultipler;\\n        }\\n\\n      /**\\n       * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n       */\\n      function admin() public view returns (address) {\\n          return addressStorage[keccak256(\\u0027proxy.admin\\u0027)];   \\n      }\\n    \\n        /**\\n        * @return - the number of hours wait time for any critical update\\n        */        \\n        function speedBumpHours() public view returns (uint16){\\n            return uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)];\\n        }\\n     \\n        /**\\n         * @return - the connected factory of this treasury\\n         */        \\n        function treasurysFactory() public view returns (address){\\n            return addressStorage[keccak256(treasurysFactory1)];\\n        } \\n        \\n        /**\\n         * @return - the connected rulelist of this treasury\\n         */        \\n        function treasurysRuleList() public view returns (address){\\n            return addressStorage[keccak256(treasurysRuleList1)];\\n        } \\n\\n\\n        /**\\n         * @return - the treasury\\u0027s escrowed deposit\\n         */        \\n        function treasurysDeposit() public view returns (address){\\n            return addressStorage[keccak256(treasurysDeposit1)];\\n        }\\n        \\n        /**\\n         * @return - the withdrawal address of this treasury\\n         */        \\n        function QNTAddress() public view returns (address){\\n            return addressStorage[keccak256(QNTAddress1)];\\n        }\\n        \\n        /**\\n         * @return - the operator of this treasury\\n         */        \\n        function operatorAddress() public view returns (address){\\n            return addressStorage[keccak256(operatorAddress1)];\\n        }\\n        \\n        /**\\n         * @return - whether this treasury is currently active or not\\n         */        \\n        function circuitBreakerOn() public view returns (bool){\\n            return boolStorage[keccak256(circuitBreakerOn1)];\\n        }\\n        \\n        /**\\n         * @return - the fee the mapp has to pay for any dispute raised per gateway\\n         */        \\n        function mappDisputeFeeMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(mappDisputeFeeMultipler1)];\\n        }\\n        \\n \\n        /**\\n         * @return the commission divider charged for every mapp to gateway transaction.\\n         * The divider is used with the original fee of the function.\\n         * I.e a commission divider of 2 is equal to 50% commission\\n         */        \\n        function commissionDivider() public view returns (uint16){\\n            return uint16Storage[keccak256(commissionDivider1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier for the treasury has to pay if it has been found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function.\\n         * I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n         */        \\n        function treasuryPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(treasuryPenaltyMultipler1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier a gateway has to pay if it has be found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function\\n         * I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n         */        \\n        function gatewayPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(gatewayPenaltyMultipler1)];\\n        }\\n    \\n}\"},\"UpgradeableProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./EternalStorageData.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title UpgradeableProxy\\n * @dev This contract allows the proxy to be upgradeable and owned\\n */\\ncontract UpgradeableProxy is EternalStorage {\\n    \\n    /**\\n   * Sets the admin of the proxy. Only the admin address can change this\\n   */\\n  function setAdmin() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n        require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      //change storage\\n      addressStorage[keccak256(\\u0027proxy.admin\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)];\\n      //remove speed bump\\n       addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = address(0);\\n  }\\n  \\n    /**\\n   * Sets the implementation of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function setImplementation() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n      require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      addressStorage[keccak256(\\u0027proxy.implementation\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)]; \\n      addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = address(0); \\n  }\\n  \\n    /**\\n   * Adds a speed bump to change the admin or implementation. Only the admin address can change this\\n   */\\n  function changeProxyVariables(address nextAdmin, address nextImplementation) external {\\n      require(msg.sender == admin(), \\u0027only admin can call this function\\u0027);\\n        addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = nextAdmin;\\n        addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = nextImplementation;\\n        //note that admin and implementation functions are separate above to align with more upgradeability patterns\\n        uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)] = now + (speedBumpHours()*1 hours);\\n  }\\n\\n   /**\\n   * sets the contract as initialised\\n   */ \\n  function initializeNow() internal {\\n      boolStorage[keccak256(\\u0027proxy.initialized\\u0027)] = true;    \\n  }\\n  \\n    /**\\n    * set the speed bump time of this contract\\n    */        \\n    function speedBumpHours(uint16 newSpeedBumpHours) internal {\\n        uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)] = newSpeedBumpHours;\\n    }\\n  \\n  /**\\n   * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function admin() public view returns (address);\\n \\n  /**\\n   * @return - the address of the current smart contract logic\\n   */ \\n  function implementation() public view returns (address) {\\n      return addressStorage[keccak256(\\u0027proxy.implementation\\u0027)];    \\n  }\\n  \\n  /**\\n   * @return - whether the smart contract has  been initialized (true) or not (false)\\n   */ \\n  function initialized() public view returns (bool) {\\n      return boolStorage[keccak256(\\u0027proxy.initialized\\u0027)];    \\n  }\\n  \\n    /**\\n    * @return - the number of hours wait time for any critical update\\n    */        \\n    function speedBumpHours() public view returns (uint16);\\n  \\n    \\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ruleList\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"escrowedDeposit\",\"type\":\"address\"}],\"name\":\"connectedContracts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"speedBumpIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"speedBumpHours\",\"type\":\"uint256\"}],\"name\":\"updatedSpeedBump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"verificationDetails\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"locationOfDetails\",\"type\":\"string\"}],\"name\":\"updatedTreasuryFunctionVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWithdrawalAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"circuitBreaker\",\"type\":\"bool\"}],\"name\":\"updatedTreasuryMainVariables\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"mappDisputeFeeMultipler\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"commissionDivider\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"gatewayPenaltyMultipler\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"treasuryPenaltyMultipler\",\"type\":\"uint16\"}],\"name\":\"updatedTreasuryVariables\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"QNTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nextImplementation\",\"type\":\"address\"}],\"name\":\"changeProxyVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circuitBreakerOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionDivider\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gatewayPenaltyMultipler\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"thisQNTAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"thisOperatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"mappDisputeFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"commission\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"treasuryPenalty\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gatewayPenalty\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"speedBumpTime\",\"type\":\"uint16\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mappDisputeFeeMultipler\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"gateway\",\"type\":\"bool\"}],\"name\":\"readFunctionPenaltyMultipler\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"addressIndex\",\"type\":\"uint8\"}],\"name\":\"speedBumpAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"speedBumpCircuitBreaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"speedBumpContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"speedBumpCurrentSBHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"uint16s\",\"type\":\"uint16[]\"}],\"name\":\"speedBumpFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"speedBumpHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint16\",\"name\":\"newSpeedBumpHours\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"circuitBreaker\",\"type\":\"bool\"}],\"name\":\"speedBumpMain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"speedBumpNextSBHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"speedBumpTimeCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"uint16Index\",\"type\":\"uint8\"}],\"name\":\"speedBumpUint16s\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryPenaltyMultipler\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasurysDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasurysFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasurysRuleList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateTreasuryContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateTreasuryFeeVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateTreasuryMainVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Treasury","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://25e75cdf89481d0dcc6fec3d04272a1e9165f64a7e45d5860eefa9bc1f5e50de"}]}