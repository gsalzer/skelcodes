{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract ReentrancyGuard {\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        _guardCounter = 1;\n    }\n\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\ncontract Context {\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\ncontract ERC20Detailed is IERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    constructor (string memory _name, string memory _symbol, uint8 _decimals) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n}\n\ninterface EarningPoolInterface {\n    function deposit(address _beneficiary, uint256 _amount) external;\n    function withdraw(address _beneficiary, uint256 _amount) external returns (uint256);\n    function dispenseEarning() external returns (uint);\n    function dispenseReward() external returns (uint);\n    function underlyingToken() external view returns (address);\n    function rewardToken() external view returns (address);\n    function calcPoolValueInUnderlying() external view returns (uint);\n    function calcUndispensedEarningInUnderlying() external view returns(uint256);\n    function calcUndispensedProviderReward() external view returns(uint256);\n}\n\ninterface ManagedRewardPoolInterface {\n    function claim(address _account) external;\n    function mintShares(address _account, uint256 _amount) external;\n    function burnShares(address _account, uint256 _amount) external;\n}\n\n/**\n * @title nToken\n * @dev nToken are collateralized assets pegged to a specific value.\n *      Collaterals are EarningPool shares\n */\ncontract nToken is ERC20, ERC20Detailed, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    mapping(address => address) public underlyingToEarningPoolMap;\n    address[] public supportedUnderlyings;\n\n    ManagedRewardPoolInterface public managedRewardPool;\n\n    // mapping between underlying token and its paused state\n    // pause is used for mint and swap\n    mapping(address => bool) public paused;\n\n    event Minted(address indexed beneficiary, address indexed underlying, uint256 amount, address payer);\n    event Redeemed(address indexed beneficiary, address indexed underlying, uint256 amount, address payer);\n    event Swapped(address indexed beneficiary, address indexed underlyingFrom, uint256 amountFrom, address indexed underlyingTo, uint256 amountTo, address payer);\n    event EarningPoolAdded(address indexed earningPool, address indexed underlying);\n    event Pause(address indexed underlying);\n    event Unpause(address indexed underlying);\n\n    /**\n     * @dev nToken constructor\n     * @param _name Name of nToken\n     * @param _symbol Symbol of nToken\n     * @param _decimals Decimal place of nToken\n     * @param _earningPools List of earning pools to supply underlying token to\n     */\n    constructor (\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address[] memory _earningPools,\n        address _managedRewardPool\n    )\n        ERC20Detailed(_name, _symbol, _decimals)\n        public\n    {\n        require(_managedRewardPool != address(0), \"NTOKEN: reward pool address cannot be zero\");\n        managedRewardPool = ManagedRewardPoolInterface(_managedRewardPool);\n\n        for (uint i=0; i<_earningPools.length; i++) {\n            _addEarningPool(_earningPools[i]);\n        }\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the underlying is not paused.\n     */\n    modifier whenNotPaused(address _underlying) {\n      require(!paused[_underlying], \"NTOKEN: underlying is paused\");\n      _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused(address _underlying) {\n      require(paused[_underlying], \"NTOKEN: underlying is not paused\");\n      _;\n    }\n\n    /*** PUBLIC ***/\n\n    /**\n     * @dev Mint nToken using underlying\n     * @param _beneficiary Address of beneficiary\n     * @param _underlying Token supplied for minting\n     * @param _underlyingAmount Amount of _underlying\n     */\n    function mint(\n        address _beneficiary,\n        address _underlying,\n        uint _underlyingAmount\n    )\n        external\n        nonReentrant\n        whenNotPaused(_underlying)\n    {\n        _mintInternal(_beneficiary, _underlying, _underlyingAmount);\n    }\n\n    /**\n     * @dev Redeem nToken to underlying\n     * @param _beneficiary Address of beneficiary\n     * @param _underlying Token withdrawn for redeeming\n     * @param _underlyingAmount Amount of _underlying\n     */\n    function redeem(\n        address _beneficiary,\n        address _underlying,\n        uint _underlyingAmount\n    )\n        external\n        nonReentrant\n    {\n        _redeemInternal(_beneficiary, _underlying, _underlyingAmount);\n    }\n\n    /**\n     * @dev Swap from one underlying to another\n     * @param _beneficiary Address of beneficiary\n     * @param _underlyingFrom Token to swap from\n     * @param _amountFrom Amount of _underlyingFrom\n     * @param _underlyingTo Token to swap to\n     */\n    function swap(\n        address _beneficiary,\n        address _underlyingFrom,\n        uint _amountFrom,\n        address _underlyingTo\n    )\n        external\n        nonReentrant\n        whenNotPaused(_underlyingFrom)\n    {\n        require(_amountFrom > 0, \"NTOKEN: swap amountFrom must be greater than 0\");\n        require(isUnderlyingSupported(_underlyingFrom), \"NTOKEN: swap underlyingFrom is not supported\");\n        require(isUnderlyingSupported(_underlyingTo), \"NTOKEN: swap underlyingTo is not supported\");\n\n        // check if there is sufficient underlyingTo to swap\n        // currently there are no exchange rate between underlyings as only stable coins are supported\n        EarningPoolInterface underlyingToPool = EarningPoolInterface(underlyingToEarningPoolMap[_underlyingTo]);\n        uint amountTo = _scaleTokenAmount(_underlyingFrom, _amountFrom, _underlyingTo);\n        require(underlyingToPool.calcPoolValueInUnderlying() >= amountTo, \"NTOKEN: insufficient underlyingTo for swap\");\n\n        // transfer underlyingFrom from msg.sender and deposit into earnin pool\n        EarningPoolInterface underlyingFromPool = EarningPoolInterface(underlyingToEarningPoolMap[_underlyingFrom]);\n        IERC20(_underlyingFrom).safeTransferFrom(msg.sender, address(this), _amountFrom);\n        underlyingFromPool.deposit(address(this), _amountFrom);\n\n        // withdraw underlyingTo from earning pool to _beneficiary\n        uint256 actualAmountTo = underlyingToPool.withdraw(address(this), amountTo);\n        IERC20(_underlyingTo).safeTransfer(_beneficiary, actualAmountTo);\n\n        emit Swapped(_beneficiary, _underlyingFrom, _amountFrom, _underlyingTo, actualAmountTo, msg.sender);\n    }\n\n    /*** VIEW ***/\n\n    /**\n     * @dev Check if an underlying is supported\n     * @param _underlying Address of underlying token\n     */\n    function isUnderlyingSupported(address _underlying) public view returns (bool) {\n        return underlyingToEarningPoolMap[_underlying] != address(0);\n    }\n\n    /**\n     * @dev Get corresponding earning pool address of underlying\n     * @param _underlying Address of underlying token\n     */\n    function getUnderlyingEarningPool(address _underlying) public view returns (address) {\n        return underlyingToEarningPoolMap[_underlying];\n    }\n\n    /**\n     * @dev Get all supported underlyings\n     * @return address[] List of address of supported underlying token\n     */\n    function getAllSupportedUnderlyings() public view returns (address[] memory) {\n        return supportedUnderlyings;\n    }\n\n    /*** ADMIN ***/\n\n    /**\n     * @dev Add earning pool to nToken\n     * @param _earningPool Address of earning pool\n     */\n    function addEarningPool(address _earningPool)\n        external\n        onlyOwner\n    {\n        _addEarningPool(_earningPool);\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause(address _underlying)\n        public\n        onlyOwner\n        whenNotPaused(_underlying)\n    {\n        paused[_underlying] = true;\n        emit Pause(_underlying);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause(address _underlying)\n        public\n        onlyOwner\n        whenPaused(_underlying)\n    {\n        paused[_underlying] = false;\n        emit Unpause(_underlying);\n    }\n\n    /**\n     * @dev Set the name of token\n     * @param _name Name of token\n     */\n    function setName(string calldata _name)\n        external\n        onlyOwner\n    {\n        name = _name;\n    }\n\n    /**\n     * @dev Set the symbol of token\n     * @param _symbol Symbol of token\n     */\n    function setSymbol(string calldata _symbol)\n        external\n        onlyOwner\n    {\n        symbol = _symbol;\n    }\n\n    /*** INTERNAL ***/\n\n    function _mintInternal(address _beneficiary, address _underlying, uint _underlyingAmount) internal {\n        require(_underlyingAmount > 0, \"NTOKEN: mint must be greater than 0\");\n        require(isUnderlyingSupported(_underlying), \"NTOKEN: mint underlying is not supported\");\n\n        // transfer underlying from msg.sender into nToken and deposit into earning pool\n        EarningPoolInterface pool = EarningPoolInterface(underlyingToEarningPoolMap[_underlying]);\n        IERC20(_underlying).safeTransferFrom(msg.sender, address(this), _underlyingAmount);\n        pool.deposit(address(this), _underlyingAmount);\n\n        // mint nToken for _beneficiary\n        uint nTokenAmount = _scaleTokenAmount(_underlying, _underlyingAmount, address(this));\n        _mint(_beneficiary, nTokenAmount);\n\n        // mint shares in managedRewardPool for _beneficiary\n        managedRewardPool.mintShares(_beneficiary, nTokenAmount);\n\n        emit Minted(_beneficiary, _underlying, _underlyingAmount, msg.sender);\n    }\n\n    function _redeemInternal(address _beneficiary, address _underlying, uint _underlyingAmount) internal {\n        require(_underlyingAmount > 0, \"NTOKEN: redeem must be greater than 0\");\n        require(isUnderlyingSupported(_underlying), \"NTOKEN: redeem underlying is not supported\");\n\n        // burn msg.sender nToken\n        uint nTokenAmount = _scaleTokenAmount(_underlying, _underlyingAmount, address(this));\n        _burn(msg.sender, nTokenAmount);\n\n        // burn msg.sender shares from managedRewardPool\n        managedRewardPool.burnShares(msg.sender, nTokenAmount);\n\n        // withdraw underlying from earning pool and transfer to _beneficiary\n        EarningPoolInterface pool = EarningPoolInterface(underlyingToEarningPoolMap[_underlying]);\n        uint256 actualWithdrawnAmount = pool.withdraw(address(this), _underlyingAmount);\n        IERC20(_underlying).safeTransfer(_beneficiary, actualWithdrawnAmount);\n\n        emit Redeemed(_beneficiary, _underlying, actualWithdrawnAmount, msg.sender);\n    }\n\n    /**\n     * @dev Approve underlyings to earning pool\n     * @param _underlying Address of underlying token\n     * @param _pool Address of earning pool\n     */\n    function _approveUnderlyingToEarningPool(address _underlying, address _pool) internal {\n        IERC20(_underlying).safeApprove(_pool, uint(-1));\n    }\n\n    /**\n     * @dev Scale token amount from one decimal precision to another\n     * @param _from Address of token to convert from\n     * @param _fromAmount Amount of _from token\n     * @param _to Address of token to convert to\n     */\n    function _scaleTokenAmount(address _from, uint _fromAmount, address _to) internal view returns (uint) {\n        uint fromTokenDecimalPlace = uint(ERC20Detailed(_from).decimals());\n        uint toTokenDecimalPlace = uint(ERC20Detailed(_to).decimals());\n        uint toTokenAmount;\n        uint scaleFactor;\n        if (fromTokenDecimalPlace > toTokenDecimalPlace) {\n            scaleFactor = fromTokenDecimalPlace.sub(toTokenDecimalPlace);\n            toTokenAmount = _fromAmount.div(uint(10**scaleFactor)); // expect precision loss\n        } else if (toTokenDecimalPlace > fromTokenDecimalPlace) {\n            scaleFactor = toTokenDecimalPlace.sub(fromTokenDecimalPlace);\n            toTokenAmount = _fromAmount.mul(uint(10**(scaleFactor)));\n        } else {\n            toTokenAmount = _fromAmount;\n        }\n        return toTokenAmount;\n    }\n\n    /**\n     * @dev Add earning pool to nToken\n     * @param _earningPool Address of earning pool\n     */\n    function _addEarningPool(address _earningPool)\n        internal\n    {\n        EarningPoolInterface pool = EarningPoolInterface(_earningPool);\n\n        underlyingToEarningPoolMap[pool.underlyingToken()] = _earningPool;\n        supportedUnderlyings.push(pool.underlyingToken());\n        _approveUnderlyingToEarningPool(pool.underlyingToken(), _earningPool);\n\n        emit EarningPoolAdded(_earningPool, pool.underlyingToken());\n    }\n\n    /**\n     * @dev Overrides parent ERC20 _transfer function to update reward for sender and recipient\n     * @param _sender Sender of transfer\n     * @param _recipient Address to recieve transfer\n     * @param _amount Amount to transfer\n     * @return bool Is transfer successful\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount)\n        internal\n    {\n        managedRewardPool.burnShares(_sender, _amount);\n        managedRewardPool.mintShares(_recipient, _amount);\n        super._transfer(_sender, _recipient, _amount);\n    }\n}\n\n/**\n * @title nUSD\n * @dev nToken pegged to USD\n */\ncontract nUSD is nToken {\n    constructor (\n        address[] memory _initialEarningPools,\n        address _rewardPool\n    )\n        nToken (\n            \"Bretton USD\",\n            \"nUSD\",\n            18,\n            _initialEarningPools,\n            _rewardPool\n        )\n        public\n    {\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_initialEarningPools\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_rewardPool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"earningPool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"EarningPoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFrom\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_earningPool\",\"type\":\"address\"}],\"name\":\"addEarningPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllSupportedUnderlyings\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"}],\"name\":\"getUnderlyingEarningPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"}],\"name\":\"isUnderlyingSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managedRewardPool\",\"outputs\":[{\"internalType\":\"contract ManagedRewardPoolInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supportedUnderlyings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountFrom\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_underlyingTo\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"underlyingToEarningPoolMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"}],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"nUSD","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"50000","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000067b312c433f052bb71efae94632e1654011c42a300000000000000000000000000000000000000000000000000000000000000030000000000000000000000001da18f12111cfa7c9fb32a1062acb3b76d9263d300000000000000000000000009f8628f9e337f59dbacba6ccb30bfaeb2c9bce20000000000000000000000002f329997e62bc769c947d5b60c05c3e0adee404b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}