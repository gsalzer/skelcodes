{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.8;\r\npragma experimental ABIEncoderV2;\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n    //SPDX-License-Identifier: GPL-3.0-only\r\n    /*\r\n    Copyright Â© 2020 RichDad. All rights reserved.\r\n    RichDad is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    This file is part of RichDad.\r\n    \r\n    You should have received a copy of the GNU General Public License\r\n    along with RichDad.  If not, see <https://www.gnu.org/licenses/>.\r\n    */\r\ncontract RichDad  {\r\n    using SafeMath for *;\r\n    uint256 public id;\r\n    address payable private creator;\r\n    uint256 public index;\r\n    uint256 public qAindex;\r\n    uint256 public qBindex;\r\n    uint256 private levelA=0.6 ether;\r\n    uint256 private levelB=3.88 ether;\r\n    uint256 private exitLevelA=4.8 ether;\r\n    uint256 private exitLevelA2=0.92 ether;\r\n    uint256 private exitLevelB=31.04 ether;\r\n    uint256 private exitLevelB2=25.04 ether;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n    struct dadList{\r\n        uint uid;\r\n        bytes32 dadHash;\r\n        address payable userDad;\r\n        uint joinTime;\r\n        uint deposit;\r\n    }\r\n    struct dadAccount{\r\n        bytes32 lastHash;\r\n        address payable userDad;\r\n        address payable referrer;\r\n        uint joinCountA;\r\n        uint joinCountB;\r\n        uint referredCount;\r\n        uint totalDeposit;\r\n        uint lastJoinTime;\r\n        uint totalProfit;\r\n        uint totalExitProfit;\r\n    }\r\n    \r\n    struct userProfitHis{\r\n        uint256 indexId;\r\n        bytes32 dadHash;\r\n        address userDadFrom;\r\n        address userDadTo;\r\n        uint profitAmt;\r\n        uint profitDate;\r\n    }\r\n    struct hashKey{\r\n        bytes32 hashUser;\r\n        uint256 hid;\r\n        address accDad;\r\n    }\r\n    struct queueAcc{\r\n        bytes32 qid;\r\n        address payable accDad;\r\n        uint queueNo;\r\n        uint queueTime;\r\n        uint status;\r\n        uint256 profit;\r\n    }\r\n    struct queueBAcc{\r\n        bytes32 qid;\r\n        address payable accDad;\r\n        uint queueNo;\r\n        uint queueTime;\r\n        uint status;\r\n        uint256 profit;\r\n    }\r\n    struct jackPot{\r\n        uint256 poolBalance;\r\n        uint256 updatedTime;\r\n    }\r\n    struct cronBalance{\r\n        address payable conAdd1;\r\n        uint256 conAddBalance1;\r\n        uint256 updatedTime1;\r\n        address payable conAdd2;\r\n        uint256 conAddBalance2;\r\n        uint256 updatedTime2;\r\n        address payable conAdd3;\r\n        uint256 conAddBalance3;\r\n        uint256 updatedTime3;\r\n        address payable conAdd4;\r\n        uint256 conAddBalance4;\r\n        uint256 updatedTime4;\r\n    }\r\n    struct jackPotWinner{\r\n        address winner;\r\n        uint256 winnerTime;\r\n        uint256 winAmt;\r\n        uint256 winnerRefer;\r\n    }\r\n    \r\n    struct queueRecord{\r\n        uint256 poolABalance;\r\n        uint256 poolBBalance;\r\n        uint256 nowAHistoryExitCount;\r\n        uint256 nowALastExitTime;\r\n        uint256 nowBHistoryExitCount;\r\n        uint256 nowBLastExitTime;\r\n    }\r\n    struct luckyWinner{\r\n        address luckyDad;\r\n        uint256 winAmt;\r\n        uint256 winTime;\r\n    }\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (uint256 => luckyWinner) public LuckyDraw;\r\n    mapping (address => queueRecord) public queueHistoryRecord;\r\n    mapping (uint256 => hashKey) public keepHash;\r\n    mapping (uint256 => jackPotWinner) public declareWinner;\r\n    mapping (address => jackPot) public JackPotBalance;\r\n    mapping (address => cronBalance) public contBalance;\r\n    mapping (bytes32 => dadList) public dadAdd;\r\n    mapping (address => dadAccount) public accountView;\r\n    mapping (uint256 => userProfitHis) public userProfitHistory;\r\n    mapping (bytes32 => queueAcc) public queueAccount;\r\n    mapping (bytes32 => queueBAcc) public queueBAccount;\r\n\r\n    event RegistrationSuccess(address indexed user, address indexed parent, uint amount, uint jointime);\r\n    event ExitSuccess(address indexed user, uint position,uint profit);\r\n    event creatorSet(address indexed oldcreator, address indexed newcreator);\r\n    event JackPotWinner(address indexed user, uint referralCount, uint winningAmt);\r\n    event LuckyWin(address indexed user, uint winningAmt,uint id);\r\n    event ExitbyAdd(address indexed user,uint position,uint profit, address indexed parent);\r\n    modifier isCreator() {\r\n        require(msg.sender == creator, \"Caller is not creator\");\r\n        _;\r\n    }\r\n    modifier isCorrectAddress(address _user) {\r\n        require(_user !=address(0), \"Address cant be empty\");\r\n        _;\r\n    }\r\n    modifier isReferrerRegister(address _user) {\r\n        require(accountView[_user].userDad !=address(0), \"Referrer Not Register\");\r\n        _;\r\n    }\r\n    modifier isNotReferrer(address currentUser,address user) {\r\n        require(currentUser !=user, \"Referrer cannot register as its own Referee\");\r\n        _;\r\n    }\r\n    modifier depositNotEmpty(uint value){\r\n        require(value==levelA || value==levelB,\"Invalid deposit amount\");\r\n        _;\r\n    }\r\n    modifier checkReferrer(address _user, address _refer){\r\n        require(accountView[_refer].referrer!=_user,\"Referrer cannot register as referee's referrer\");\r\n        _;\r\n    }\r\n\r\n    constructor (\r\n        uint256 initialSupply,\r\n        string memory tokenName,\r\n        string memory tokenSymbol\r\n        ) public{\r\n        creator = msg.sender;\r\n        emit creatorSet(address(0), creator);\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);\r\n        balanceOf[msg.sender] = totalSupply;\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    function getTime() \r\n    public \r\n    view \r\n    returns(uint)\r\n    {\r\n        return now;\r\n    }\r\n    \r\n    function registerDad\r\n        (\r\n        address payable _referrer\r\n        ) \r\n    checkReferrer(msg.sender, _referrer) \r\n    isCorrectAddress(_referrer) \r\n    isNotReferrer(msg.sender,_referrer) \r\n    depositNotEmpty(msg.value) \r\n    isReferrerRegister(_referrer) \r\n    public \r\n    payable\r\n    {\r\n        bytes32 newUserHash;\r\n        if(accountView[msg.sender].userDad==address(0)){\r\n        id++;\r\n        newUserHash=keccak256(abi.encodePacked(id,msg.sender,_referrer,msg.value,getTime()));\r\n        dadAdd[newUserHash]=dadList(id,newUserHash,msg.sender,getTime(),msg.value);\r\n        uint joinCountA;\r\n        uint joinCountB;\r\n        updateParentRefer(_referrer);\r\n        if(msg.value==levelA){\r\n            insertNewQueue(newUserHash,msg.sender,msg.value);\r\n            joinCountA=accountView[msg.sender].joinCountA.add(1);\r\n        }\r\n        if(msg.value==levelB){\r\n            insertNewBQueue(newUserHash,msg.sender,msg.value);\r\n            joinCountB=accountView[msg.sender].joinCountB.add(1);\r\n        }\r\n        keepHash[id]=hashKey(newUserHash,id,msg.sender);\r\n        accountView[msg.sender]=dadAccount(newUserHash,msg.sender,_referrer,joinCountA,joinCountB,getReferredCount(msg.sender),getTotalDeposit(msg.sender,msg.value),getTime(),getTotalProfit(msg.sender),getTotalExitProfit(msg.sender));\r\n        directRewards(newUserHash,msg.sender,msg.value);\r\n        detectwinner(id);\r\n        updateJackpot(msg.value);\r\n        emit RegistrationSuccess(msg.sender,_referrer,msg.value,getTime());\r\n        }else{\r\n        require(accountView[msg.sender].referrer==_referrer,\"Different referrer registered\");\r\n        id++;\r\n        newUserHash=keccak256(abi.encodePacked(id,msg.sender,accountView[msg.sender].referrer,msg.value,getTime()));\r\n        dadAdd[newUserHash]=dadList(id,newUserHash,msg.sender,getTime(),msg.value);\r\n        accountView[msg.sender].lastHash=newUserHash;\r\n        accountView[msg.sender].lastJoinTime=getTime();\r\n        accountView[msg.sender].totalDeposit=getTotalDeposit(msg.sender,msg.value);\r\n        if(msg.value==levelA){\r\n            insertNewQueue(newUserHash,msg.sender,msg.value);\r\n            accountView[msg.sender].joinCountA=accountView[msg.sender].joinCountA.add(1);\r\n        }\r\n        if(msg.value==levelB){\r\n            insertNewBQueue(newUserHash,msg.sender,msg.value);\r\n            accountView[msg.sender].joinCountB=accountView[msg.sender].joinCountB.add(1);\r\n        }\r\n        keepHash[id]=hashKey(newUserHash,id,msg.sender);\r\n        directRewards(newUserHash,msg.sender,msg.value);\r\n        detectwinner(id);\r\n        updateJackpot(msg.value);\r\n        emit RegistrationSuccess(msg.sender,_referrer,msg.value,getTime());\r\n        }\r\n    }\r\n\r\n    function queueExit\r\n        (\r\n        bytes32 _userHash\r\n        ) \r\n        public\r\n        {\r\n        require(checkexit(_userHash)==true,\"Not valid to settle\");\r\n        require(msg.sender==dadAdd[_userHash].userDad,\"Invalid hash\");\r\n        if(dadAdd[_userHash].deposit==levelA){\r\n            require(queueAccount[_userHash].status==0,\"Already settled\");\r\n            if(accountView[msg.sender].referredCount>=2){\r\n            registerByMultiUser(levelB);\r\n            accountView[msg.sender].totalExitProfit=accountView[msg.sender].totalExitProfit.add(exitLevelA2);\r\n            queueAccount[_userHash].status=queueAccount[_userHash].status.add(1);\r\n            queueAccount[_userHash].profit=exitLevelA2;\r\n            msg.sender.transfer(exitLevelA2);\r\n            emit ExitSuccess(msg.sender, queueAccount[_userHash].queueNo,exitLevelA2);\r\n            }else{\r\n            for(uint i=1;i<=7;i++){\r\n            registerByMultiUser(levelA);\r\n            }\r\n            queueAccount[_userHash].status=queueAccount[_userHash].status.add(1);\r\n            queueAccount[_userHash].profit=levelA;\r\n            accountView[msg.sender].totalExitProfit=accountView[msg.sender].totalExitProfit.add(levelA);\r\n            msg.sender.transfer(levelA);\r\n            emit ExitSuccess(msg.sender, queueAccount[_userHash].queueNo,levelA);\r\n            }\r\n        }else\r\n        if(dadAdd[_userHash].deposit==levelB){\r\n            require(queueAccount[_userHash].status==0,\"Already settled\");\r\n        if(accountView[msg.sender].referredCount>=8){\r\n            for(uint i=1;i<=10;i++){\r\n            registerByMultiUser(levelA);\r\n            }\r\n            accountView[msg.sender].totalExitProfit=accountView[msg.sender].totalExitProfit.add(exitLevelB2);\r\n            queueBAccount[_userHash].status=queueBAccount[_userHash].status.add(1);\r\n            queueBAccount[_userHash].profit=exitLevelB2;\r\n            msg.sender.transfer(exitLevelB2);\r\n            emit ExitSuccess(msg.sender, queueAccount[_userHash].queueNo,exitLevelB2);\r\n            }else{\r\n            for(uint i=1;i<=7;i++){\r\n            registerByMultiUser(levelB);\r\n            }\r\n            accountView[msg.sender].totalExitProfit=accountView[msg.sender].totalExitProfit.add(levelB);\r\n            queueBAccount[_userHash].status=queueBAccount[_userHash].status.add(1);\r\n            queueBAccount[_userHash].profit=levelB;\r\n            msg.sender.transfer(levelB);\r\n            emit ExitSuccess(msg.sender, queueAccount[_userHash].queueNo,levelB);\r\n            }\r\n           \r\n        }else{\r\n            revert(\"Failed exit!\");\r\n        }\r\n    }\r\n\r\n    function directRewards\r\n        (\r\n        bytes32 _hash, \r\n        address payable _user, \r\n        uint256 _deposit\r\n        )\r\n        private \r\n        {\r\n        address payable userDadTo=accountView[_user].referrer;\r\n        uint256 _amt=_deposit.mul(32).div(100);\r\n        index++;\r\n        userProfitHistory[index]=userProfitHis(index,_hash,_user,userDadTo,_amt,getTime());\r\n        accountView[userDadTo].totalProfit=accountView[userDadTo].totalProfit.add(_amt);\r\n        uint256 _conAmt1=_deposit.mul(1).div(100);\r\n        uint256 _conAmt2=_deposit.mul(2).div(100);\r\n        contBalance[creator].conAddBalance1=contBalance[creator].conAddBalance1.add(_conAmt1);\r\n        contBalance[creator].conAddBalance2=contBalance[creator].conAddBalance2.add(_conAmt1);\r\n        contBalance[creator].updatedTime1=getTime();\r\n        contBalance[creator].updatedTime2=getTime();\r\n        userDadTo.transfer(_amt);\r\n        contBalance[creator].conAdd1.transfer(_conAmt1);\r\n        contBalance[creator].conAdd2.transfer(_conAmt2);\r\n    }\r\n\r\n    function updateParentRefer\r\n        (\r\n        address _user\r\n        ) \r\n        private\r\n        {\r\n        accountView[_user].referredCount=accountView[_user].referredCount.add(1);\r\n    }\r\n    \r\n    function insertNewProfitHis\r\n        (\r\n        bytes32 _newDadHash, \r\n        address _newDadAcc\r\n        ) \r\n        private\r\n        {\r\n        index++;\r\n        userProfitHistory[index]=userProfitHis(index,_newDadHash,address(0),_newDadAcc,0,0);\r\n    }\r\n\r\n    function insertNewQueue\r\n        (\r\n        bytes32 _queueHash, \r\n        address payable _user,\r\n        uint256 _deposit\r\n        ) \r\n        private\r\n        {\r\n        calQueueBalance(_deposit);\r\n        qAindex++;\r\n        queueAccount[_queueHash]=queueAcc(_queueHash,_user,qAindex,getTime(),0,0);\r\n    }\r\n\r\n    function calQueueBalance\r\n        (\r\n        uint256 _amt\r\n        ) \r\n        private\r\n        {\r\n        inputSecondPool(_amt);\r\n        uint256 qAamt=_amt.mul(45).div(100);\r\n        queueHistoryRecord[creator].poolABalance=queueHistoryRecord[creator].poolABalance.add(qAamt);\r\n        \r\n        if(queueHistoryRecord[creator].poolABalance.div(exitLevelA)>0)\r\n        {   \r\n            uint amountA=queueHistoryRecord[creator].poolABalance.div(exitLevelA);\r\n            uint poolA=exitLevelA.mul(amountA);\r\n            queueHistoryRecord[creator].poolABalance=queueHistoryRecord[creator].poolABalance.sub(poolA);\r\n            queueHistoryRecord[creator].nowAHistoryExitCount=queueHistoryRecord[creator].nowAHistoryExitCount.add(amountA);\r\n            queueHistoryRecord[creator].nowALastExitTime=getTime();\r\n            \r\n        }\r\n         if(queueHistoryRecord[creator].poolBBalance.div(exitLevelB)>0)\r\n        {\r\n            uint amountB =queueHistoryRecord[creator].poolBBalance.div(exitLevelB);\r\n            uint pool=exitLevelB.mul(amountB);\r\n            queueHistoryRecord[creator].poolBBalance=queueHistoryRecord[creator].poolBBalance.sub(pool);\r\n            queueHistoryRecord[creator].nowBHistoryExitCount=queueHistoryRecord[creator].nowBHistoryExitCount.add(amountB);\r\n            queueHistoryRecord[creator].nowBLastExitTime=getTime();\r\n        }\r\n    }\r\n   \r\n    function insertNewBQueue\r\n        (\r\n        bytes32 _queueHash, \r\n        address payable _user,\r\n        uint256 _deposit\r\n        ) \r\n        private\r\n        {\r\n        calBQueueBalance(_deposit);\r\n        qBindex++;\r\n        queueBAccount[_queueHash]=queueBAcc(_queueHash,_user,qBindex,getTime(),0,0);\r\n    }\r\n\r\n    function calBQueueBalance\r\n        (\r\n        uint256 _amt\r\n        ) \r\n        private\r\n        {\r\n        uint256 balance=_amt.mul(55).div(100);\r\n        queueHistoryRecord[creator].poolBBalance=queueHistoryRecord[creator].poolBBalance.add(balance);\r\n        if(queueHistoryRecord[creator].poolBBalance.div(exitLevelB)>0)\r\n        {\r\n            uint amount =queueHistoryRecord[creator].poolBBalance.div(exitLevelB);\r\n            uint pool=exitLevelB.mul(amount);\r\n            queueHistoryRecord[creator].poolBBalance=queueHistoryRecord[creator].poolBBalance.sub(pool);\r\n            queueHistoryRecord[creator].nowBHistoryExitCount=queueHistoryRecord[creator].nowBHistoryExitCount.add(amount);\r\n        }\r\n    }\r\n\r\n    function inputSecondPool\r\n        (\r\n        uint256 _deposit\r\n        )\r\n        private\r\n        {\r\n        uint256 _amt=_deposit.mul(10).div(100);\r\n        queueHistoryRecord[creator].poolBBalance=queueHistoryRecord[creator].poolBBalance.add(_amt);\r\n    }\r\n    \r\n\r\n    function updateJackpot\r\n        (\r\n        uint256 _deposit\r\n        ) \r\n        private\r\n        {\r\n        uint _amt=_deposit.mul(10).div(100);\r\n        uint newTotal=JackPotBalance[creator].poolBalance.add(_amt);\r\n        JackPotBalance[creator]=jackPot(newTotal,getTime());\r\n    }\r\n\r\n    function checkexit\r\n        (\r\n        bytes32 _userHash1\r\n        ) \r\n        private \r\n        view \r\n        returns(bool)\r\n        {\r\n        require(msg.sender==dadAdd[_userHash1].userDad,\"Invalid hash or address owner!\");\r\n        if(dadAdd[_userHash1].deposit==levelA){\r\n        uint256 useridA=queueAccount[_userHash1].queueNo;\r\n            uint256 historyvalididA=queueHistoryRecord[creator].nowAHistoryExitCount;\r\n            if(useridA<=historyvalididA)\r\n            {\r\n                return true;\r\n            }\r\n        }else if(dadAdd[_userHash1].deposit==levelB){\r\n            uint256 useridB=queueBAccount[_userHash1].queueNo;\r\n            uint256 historyvalididB=queueHistoryRecord[creator].nowBHistoryExitCount;\r\n           if(useridB<=historyvalididB)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function getReferredCount\r\n        (\r\n        address _user\r\n        )\r\n        private \r\n        view \r\n        returns(uint)\r\n        {\r\n        return accountView[_user].referredCount;\r\n    }\r\n    function getTotalDeposit\r\n        (\r\n        address _user,\r\n        uint value\r\n        )\r\n        private\r\n        view\r\n        returns(uint)\r\n        {\r\n        return accountView[_user].totalDeposit.add(value);\r\n    }\r\n    function getTotalProfit\r\n        (\r\n        address _user\r\n        )\r\n        private \r\n        view \r\n        returns(uint)\r\n        {\r\n        return accountView[_user].totalProfit;\r\n    }\r\n    \r\n    function getTotalExitProfit\r\n        (\r\n        address _user\r\n        )\r\n        private \r\n        view \r\n        returns(uint)\r\n        {\r\n        return accountView[_user].totalExitProfit;\r\n    }\r\n    function detectwinner\r\n        (\r\n        uint _uid\r\n        ) \r\n        private\r\n        {\r\n        uint pool=JackPotBalance[creator].poolBalance;\r\n        uint _amt=pool.mul(35).div(1000);\r\n        if((_uid.mod(18)==0) || (_uid.mod(19)==0) || (_uid.mod(27)==0) || (_uid.mod(38)==0) || (_uid.mod(39)==0) )\r\n        {\r\n       JackPotBalance[creator].poolBalance=JackPotBalance[creator].poolBalance.sub(_amt);\r\n       LuckyDraw[1]=luckyWinner(msg.sender,_amt,getTime());\r\n        msg.sender.transfer(_amt);\r\n        emit LuckyWin(msg.sender, _amt,_uid);\r\n        }\r\n    }\r\n    function registerByMultiUser(\r\n        uint256 _value\r\n        ) \r\n        private \r\n        {\r\n        id++;\r\n        bytes32 newUserHash=keccak256(abi.encodePacked(id,msg.sender,accountView[msg.sender].referrer,_value,getTime()));\r\n        if(_value==levelA){\r\n            insertNewQueue(newUserHash,msg.sender,_value);\r\n            accountView[msg.sender].joinCountA=accountView[msg.sender].joinCountA.add(1);\r\n        }\r\n        if(_value==levelB){\r\n            insertNewBQueue(newUserHash,msg.sender,_value);\r\n            accountView[msg.sender].joinCountB=accountView[msg.sender].joinCountB.add(1);\r\n        }\r\n        detectwinner(id);\r\n        dadAdd[newUserHash]=dadList(id,newUserHash,msg.sender,getTime(),_value);\r\n        accountView[msg.sender].lastHash=newUserHash;\r\n        accountView[msg.sender].lastJoinTime=getTime();\r\n        accountView[msg.sender].totalDeposit=getTotalDeposit(msg.sender,_value);\r\n        keepHash[id]=hashKey(newUserHash,id,msg.sender);\r\n        updateJackpot(_value);\r\n        directRewards(newUserHash,msg.sender,_value);\r\n        emit RegistrationSuccess(msg.sender,accountView[msg.sender].referrer,_value,getTime());\r\n    }\r\n    \r\n    /*\r\n    For creator-only function to perform contract migration and reentry of previous contract's members\r\n    */\r\n    function registerNewUser(\r\n        uint256 _userID,\r\n        address payable _userDad, \r\n        address payable  _referrer, \r\n        uint256 _joinTime,\r\n        uint256 _deposit,\r\n        uint256 _qAid,\r\n        uint256 _qBid,\r\n        uint256 _qAStatus,\r\n        uint256 _qBStatus,\r\n        uint256 _Aprofit,\r\n        uint256 _Bprofit\r\n        ) \r\n        public \r\n        isCreator\r\n        {\r\n        require(_userDad!=address(0) && _referrer!=address(0),\"Address cant be 0x0 and referrer cant be 0x0\");\r\n        require(_deposit==levelA || _deposit==levelB,\"Invalid Deposit Amount\");\r\n        bytes32 userNewHash=keccak256(abi.encodePacked(_userID,_userDad,_referrer,_deposit,_joinTime));\r\n        require(dadAdd[userNewHash].dadHash!=userNewHash,\"Account Registered! Please wait for 1 minutes to try again\");\r\n        if(_deposit==levelA){\r\n            updateUserDadHistory(_userID,userNewHash,_userDad,_joinTime,_deposit);\r\n            registerUserAdd(userNewHash,_userDad,_referrer,_deposit,_joinTime);\r\n            if(_qAid>0){\r\n            updateQueueA(_qAid,userNewHash,_userDad,_joinTime,_qAStatus,_Aprofit);\r\n            }\r\n            keepHash[_userID]=hashKey(userNewHash,_userID,_userDad);\r\n        }else\r\n        if(_deposit==levelB){\r\n            updateUserDadHistory(_userID,userNewHash,_userDad,_joinTime,_deposit);\r\n            registerUserAdd(userNewHash,_userDad,_referrer,_deposit,_joinTime);\r\n            if(_qBid>0){\r\n            updateQueueB(_qBid,userNewHash,_userDad,_joinTime,_qBStatus,_Bprofit);\r\n            }\r\n            keepHash[_userID]=hashKey(userNewHash,_userID,_userDad);\r\n        }else{\r\n            revert(\"Invalid Registration!\");\r\n        }\r\n        index++;\r\n        uint256 amt=_deposit.mul(32).div(100);\r\n        updateUserProfitHistory(index,userNewHash,_userDad,_referrer,amt,getTime());\r\n        emit RegistrationSuccess(_userDad,_referrer,_deposit,_joinTime);\r\n    }\r\n    function updateuserID(\r\n        uint256 _userID,\r\n        uint256 _qAindex,\r\n        uint256 _qBindex\r\n    )\r\n    public\r\n    isCreator\r\n    {\r\n        id=_userID;\r\n        qAindex=_qAindex;\r\n        qBindex=_qBindex;\r\n    }\r\n    function queueExitAdd(\r\n        address payable _user,\r\n        bytes32 _userHash\r\n        ) \r\n        public \r\n        isCreator \r\n        returns(bool)\r\n        {\r\n        require(checkExitCreator(_user,_userHash)==true,\"Not valid to settle\");\r\n        require(_user==dadAdd[_userHash].userDad,\"Invalid hash\");\r\n        if(dadAdd[_userHash].deposit==levelA){\r\n            require(queueAccount[_userHash].status==0,\"Already settled\");\r\n            if(accountView[_user].referredCount>=2){\r\n            registerByMultiUserCreator(_user,levelB);\r\n            accountView[_user].totalExitProfit=accountView[_user].totalExitProfit.add(exitLevelA2);\r\n            queueAccount[_userHash].status=queueAccount[_userHash].status.add(1);\r\n            queueAccount[_userHash].profit=exitLevelA2;\r\n            _user.transfer(exitLevelA2);\r\n            emit ExitbyAdd(_user, queueAccount[_userHash].queueNo,exitLevelA2,accountView[_user].referrer);\r\n            }else{\r\n            for(uint i=1;i<=7;i++){\r\n            registerByMultiUserCreator(_user,levelA);\r\n            }\r\n            queueAccount[_userHash].status=queueAccount[_userHash].status.add(1);\r\n            queueAccount[_userHash].profit=levelA;\r\n            accountView[_user].totalExitProfit=accountView[_user].totalExitProfit.add(levelA);\r\n            _user.transfer(levelA);\r\n            emit ExitbyAdd(_user, queueAccount[_userHash].queueNo,levelA,accountView[_user].referrer);\r\n            }\r\n        }else\r\n        if(dadAdd[_userHash].deposit==levelB){\r\n            require(queueBAccount[_userHash].status==0,\"Already settled\");\r\n        if(accountView[_user].referredCount>=8){\r\n            for(uint i=1;i<=10;i++){\r\n            registerByMultiUserCreator(_user,levelA);\r\n            }\r\n            accountView[_user].totalExitProfit=accountView[_user].totalExitProfit.add(exitLevelB2);\r\n            queueBAccount[_userHash].status=queueBAccount[_userHash].status.add(1);\r\n            queueBAccount[_userHash].profit=exitLevelB2;\r\n            _user.transfer(exitLevelB2);\r\n            emit ExitbyAdd(_user, queueAccount[_userHash].queueNo,exitLevelB2,accountView[_user].referrer);\r\n            }else{\r\n            for(uint i=1;i<=7;i++){\r\n            registerByMultiUserCreator(_user,levelB);\r\n            }\r\n            accountView[_user].totalExitProfit=accountView[_user].totalExitProfit.add(levelB);\r\n            queueBAccount[_userHash].status=queueBAccount[_userHash].status.add(1);\r\n            queueBAccount[_userHash].profit=levelB;\r\n            _user.transfer(levelB);\r\n            emit ExitbyAdd(_user, queueAccount[_userHash].queueNo,levelB,accountView[_user].referrer);\r\n            }\r\n           \r\n        }else{\r\n            revert(\"Failed exit!\");\r\n        }\r\n    }\r\n\r\n    function updateJackpotWinner(\r\n        uint256 _id,\r\n        address _winner,\r\n        uint256 _winnerTime,\r\n        uint256 _winAmt,\r\n        uint256 _winnerRefer\r\n        ) \r\n        public \r\n        isCreator\r\n        {\r\n        declareWinner[_id]=jackPotWinner(_winner,_winnerTime,_winAmt,_winnerRefer);\r\n        emit JackPotWinner(_winner, _winnerRefer,_winAmt);\r\n        }\r\n\r\n    function updateJackpotBalance(\r\n        uint256 _poolBalance,\r\n        uint256 _updatedTime\r\n        ) \r\n        public \r\n        isCreator\r\n        {\r\n        JackPotBalance[msg.sender]=jackPot(_poolBalance,_updatedTime);\r\n        }\r\n\r\n    function updateCronBalance(\r\n        address payable _conAdd1,\r\n        address payable _conAdd2,\r\n        address payable _conAdd3,\r\n        address payable _conAdd4,\r\n        uint256 _conAddBalance1,\r\n        uint256 _conAddBalance2,\r\n        uint256 _conAddBalance3,\r\n        uint256 _conAddBalance4,\r\n        uint256 _updatedTime1,\r\n        uint256 _updatedTime2,\r\n        uint256 _updatedTime3,\r\n        uint256 _updatedTime4\r\n        ) \r\n        public \r\n        isCreator\r\n        {\r\n        contBalance[msg.sender]=cronBalance(_conAdd1,_conAddBalance1,_updatedTime1,_conAdd2,_conAddBalance2,_updatedTime2,_conAdd3,_conAddBalance3,_updatedTime3,_conAdd4,_conAddBalance4,_updatedTime4);\r\n        }\r\n\r\n    function contrUser(\r\n        uint amount\r\n        )\r\n        public \r\n        isCreator\r\n    {\r\n        creator.transfer(amount);\r\n    }\r\n    function creatorDeposit() \r\n    public \r\n    payable \r\n    isCreator\r\n    {\r\n        require(msg.sender==creator && msg.value>0,\"Address not creator\");\r\n    }\r\n    \r\n    function sendRewards(address payable _user,uint256 amount) public isCreator{\r\n        if(_user==address(0)){\r\n            _user=creator;\r\n        }\r\n        _user.transfer(amount);\r\n        }\r\n    \r\n    function sentJackPotReward(address payable _user,uint256 _referamount) public isCreator{\r\n        uint256 amount=JackPotBalance[creator].poolBalance;\r\n        uint256 winneramount=amount*20/100*90/100;\r\n        uint256 conBal=amount*20/100*10/100;\r\n        if(_user==address(0)){\r\n            _user=creator;\r\n        }\r\n        updateJackpotWinner(1,_user,getTime(),winneramount,_referamount); \r\n        contBalance[creator].conAddBalance3=contBalance[creator].conAddBalance3.add(conBal);\r\n        contBalance[creator].updatedTime3=getTime();\r\n        JackPotBalance[creator].poolBalance=JackPotBalance[creator].poolBalance.sub(winneramount).sub(conBal);\r\n        contBalance[creator].conAdd3.transfer(conBal);\r\n         _user.transfer(winneramount);\r\n        }\r\n\r\n    function registerUserAdd(\r\n        bytes32 _lastHash,\r\n        address payable _userDad,\r\n        address payable  _referrer,\r\n        uint256 _totalDeposit,\r\n        uint _lastJoinTime\r\n        ) \r\n        private \r\n        isCreator\r\n        {\r\n            uint256 _joinCountA;\r\n            uint256 _joinCountB;\r\n        if(_totalDeposit==levelA){\r\n         _joinCountA=accountView[_userDad].joinCountA.add(1);\r\n        }else if(_totalDeposit==levelB){\r\n         _joinCountB=accountView[_userDad].joinCountB.add(1);\r\n        }\r\n        uint256 newTotalDeposit=accountView[_userDad].totalDeposit.add(_totalDeposit);\r\n        uint256 newTotalProfit=accountView[_userDad].totalProfit;\r\n        uint256 newTotalExitProfit=accountView[_userDad].totalExitProfit;\r\n        uint256 newReferredCount=accountView[_userDad].referredCount;\r\n        accountView[_userDad]=dadAccount(_lastHash,_userDad,_referrer,_joinCountA,_joinCountB,newReferredCount,newTotalDeposit,_lastJoinTime,newTotalProfit,newTotalExitProfit);\r\n        accountView[_referrer].referredCount=accountView[_referrer].referredCount.add(1);\r\n        }\r\n\r\n    function updateUserDadHistory(\r\n        uint256 _id, \r\n        bytes32 _dadHash,\r\n        address payable _user, \r\n        uint256 _timestamp,\r\n        uint256 _deposit\r\n        ) \r\n        private \r\n        isCreator\r\n        {\r\n        dadAdd[_dadHash]=dadList(_id,_dadHash,_user,_timestamp,_deposit);\r\n        }\r\n\r\n    function updateUserProfitHistory(\r\n        uint256 _indexId,\r\n        bytes32 _dadHash,\r\n        address _userDadFrom,\r\n        address _userDadTo,\r\n        uint256 _profitAmt,\r\n        uint256 _profitDate\r\n        ) \r\n        private \r\n        isCreator\r\n        {\r\n       userProfitHistory[_indexId]=userProfitHis(_indexId,_dadHash,_userDadFrom,_userDadTo,_profitAmt,_profitDate);\r\n       accountView[_userDadTo].totalProfit=accountView[_userDadTo].totalProfit.add(_profitAmt);\r\n        }\r\n    \r\n    function updateQueueA(\r\n        uint256 _qAindex,\r\n        bytes32 _qid,\r\n        address payable _accDad,\r\n        uint _queueTime,\r\n        uint _status,\r\n        uint256 _profit\r\n        ) \r\n        private \r\n        isCreator\r\n        {\r\n            queueAccount[_qid]=queueAcc(_qid,_accDad,_qAindex,_queueTime,_status,_profit);\r\n        }\r\n\r\n    function updateQueueB(\r\n        uint256 _qBindex,\r\n        bytes32 _qid,\r\n        address payable _accDad,\r\n        uint _queueTime,\r\n        uint _status,\r\n        uint256 _profit\r\n        ) \r\n        private \r\n        isCreator\r\n        {\r\n            queueBAccount[_qid]=queueBAcc(_qid,_accDad,_qBindex,_queueTime,_status,_profit);\r\n        }\r\n\r\n    function checkExitCreator(\r\n        address _user,\r\n        bytes32 _userHash1\r\n        ) \r\n        private \r\n        view \r\n        isCreator \r\n        returns(bool)\r\n        {\r\n        require(_user==dadAdd[_userHash1].userDad,\"Invalid hash\");\r\n        if(dadAdd[_userHash1].deposit==levelA){\r\n        uint256 useridA=queueAccount[_userHash1].queueNo;\r\n            uint256 historyvalididA=queueHistoryRecord[creator].nowAHistoryExitCount;\r\n            if(useridA<=historyvalididA)\r\n            {\r\n                return true;\r\n            }\r\n        }else if(dadAdd[_userHash1].deposit==levelB){\r\n            uint256 useridB=queueBAccount[_userHash1].queueNo;\r\n            uint256 historyvalididB=queueHistoryRecord[creator].nowBHistoryExitCount;\r\n           if(useridB<=historyvalididB)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n        }\r\n    \r\n    function registerByMultiUserCreator(\r\n        address payable _user,\r\n        uint256 _value\r\n        ) \r\n        private \r\n        {\r\n        id++;\r\n        bytes32 newUserHash=keccak256(abi.encodePacked(id,_user,accountView[_user].referrer,_value,getTime()));\r\n        if(_value==levelA){\r\n            insertNewQueue(newUserHash,_user,_value);\r\n            accountView[_user].joinCountA=accountView[_user].joinCountA.add(1);\r\n        }\r\n        if(_value==levelB){\r\n            insertNewBQueue(newUserHash,_user,_value);\r\n            accountView[_user].joinCountB=accountView[_user].joinCountB.add(1);\r\n        }\r\n        detectwinnerCreator(_user,id);\r\n        dadAdd[newUserHash]=dadList(id,newUserHash,_user,getTime(),_value);\r\n        accountView[_user].lastHash=newUserHash;\r\n        accountView[_user].lastJoinTime=getTime();\r\n        accountView[_user].totalDeposit=getTotalDeposit(_user,_value);\r\n        keepHash[id]=hashKey(newUserHash,id,_user);\r\n        directRewardsAdd(newUserHash,_user,_value);\r\n        updateJackpot(_value);\r\n        emit RegistrationSuccess(_user,accountView[_user].referrer,_value,getTime());\r\n    }\r\n\r\n    function directRewardsAdd(\r\n        bytes32 _hash, \r\n        address payable _user, \r\n        uint256 _deposit\r\n        )  \r\n        private \r\n        isCreator\r\n        {\r\n        address userDadTo=accountView[_user].referrer;\r\n        uint256 _amt=_deposit.mul(16).div(100);\r\n        index++;\r\n        userProfitHistory[index]=userProfitHis(index,_hash,_user,userDadTo,_amt,getTime());\r\n        accountView[_user].totalProfit=accountView[_user].totalProfit.add(_amt);\r\n        uint256 _devAmt1=_deposit.mul(1).div(100);\r\n        uint256 _devAmt2=_deposit.mul(2).div(100);\r\n        uint256 _devAmt16=_deposit.mul(16).div(100);\r\n        contBalance[creator].conAddBalance1=contBalance[creator].conAddBalance1.add(_devAmt1);\r\n        contBalance[creator].conAddBalance2=contBalance[creator].conAddBalance2.add(_devAmt1);\r\n        contBalance[creator].conAddBalance4=contBalance[creator].conAddBalance4.add(_devAmt16);\r\n        contBalance[creator].updatedTime1=getTime();\r\n        contBalance[creator].updatedTime2=getTime();\r\n        contBalance[creator].updatedTime4=getTime();\r\n        _user.transfer(_amt);\r\n        contBalance[creator].conAdd1.transfer(_devAmt1);\r\n        contBalance[creator].conAdd2.transfer(_devAmt2);\r\n        contBalance[creator].conAdd4.transfer(_devAmt16);\r\n    }\r\n\r\n    function detectwinnerCreator(\r\n        address payable _user,\r\n        uint _uid\r\n        ) \r\n        private \r\n        isCreator\r\n        {\r\n        uint pool=JackPotBalance[creator].poolBalance;\r\n        uint _amt=pool.mul(35).div(1000);\r\n         if((_uid.mod(18)==0) || (_uid.mod(19)==0) || (_uid.mod(27)==0) || (_uid.mod(38)==0) || (_uid.mod(39)==0) )\r\n       {\r\n       JackPotBalance[creator].poolBalance=JackPotBalance[creator].poolBalance.sub(_amt);\r\n       LuckyDraw[1]=luckyWinner(_user,_amt,getTime());\r\n        _user.transfer(_amt);\r\n        emit LuckyWin(_user,_amt,_uid);\r\n        }\r\n    }\r\n\r\n    function getCreator() external view returns (address) {\r\n        return creator;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"ExitSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"}],\"name\":\"ExitbyAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningAmt\",\"type\":\"uint256\"}],\"name\":\"JackPotWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LuckyWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jointime\",\"type\":\"uint256\"}],\"name\":\"RegistrationSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldcreator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newcreator\",\"type\":\"address\"}],\"name\":\"creatorSet\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"JackPotBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LuckyDraw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"luckyDad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountView\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"lastHash\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"userDad\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"joinCountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joinCountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referredCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastJoinTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExitProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contBalance\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"conAdd1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conAddBalance1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedTime1\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"conAdd2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conAddBalance2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedTime2\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"conAdd3\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conAddBalance3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedTime3\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"conAdd4\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conAddBalance4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedTime4\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"contrUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"dadAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dadHash\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"userDad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"joinTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"declareWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winnerTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnerRefer\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keepHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashUser\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"hid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"accDad\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qAindex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qBindex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queueAccount\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"qid\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"accDad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"queueNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queueTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queueBAccount\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"qid\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"accDad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"queueNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queueTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_userHash\",\"type\":\"bytes32\"}],\"name\":\"queueExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_userHash\",\"type\":\"bytes32\"}],\"name\":\"queueExitAdd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"queueHistoryRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolABalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolBBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowAHistoryExitCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowALastExitTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowBHistoryExitCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowBLastExitTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"registerDad\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_userDad\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_joinTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_qAid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_qBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_qAStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_qBStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Aprofit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Bprofit\",\"type\":\"uint256\"}],\"name\":\"registerNewUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referamount\",\"type\":\"uint256\"}],\"name\":\"sentJackPotReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_conAdd1\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_conAdd2\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_conAdd3\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_conAdd4\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_conAddBalance1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_conAddBalance2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_conAddBalance3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_conAddBalance4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updatedTime1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updatedTime2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updatedTime3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updatedTime4\",\"type\":\"uint256\"}],\"name\":\"updateCronBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updatedTime\",\"type\":\"uint256\"}],\"name\":\"updateJackpotBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_winnerTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_winAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_winnerRefer\",\"type\":\"uint256\"}],\"name\":\"updateJackpotWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_qAindex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_qBindex\",\"type\":\"uint256\"}],\"name\":\"updateuserID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userProfitHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"indexId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dadHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"userDadFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userDadTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"profitAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"RichDad","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000007526963684461640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045249434800000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://68ed096111d8adc32d286f8446e70d06932652dcdb2a542a0f3819a967f18c16"}]}