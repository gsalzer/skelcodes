{"status":"1","message":"OK","result":[{"SourceCode":"{\"AddrMInterface.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\ninterface AddrMInterface {\\n     function getAddr(string calldata name_) external view returns(address);\\n}\"},\"MainPool.sol\":{\"content\":\"pragma solidity 0.5.7;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./AddrMInterface.sol\\\";\\n\\ninterface TickectInerface{\\n    function calDeductionADC(uint256 _value,bool isIn_) external returns(uint256 disADC_);\\n}\\n\\ninterface ERC20 {\\n  function balanceOf(address) external view returns (uint256);\\n  function distroy(address _owner,uint256 _value) external;\\n}\\n\\nlibrary gameDataSet{\\n    struct PlyRelationship{\\n        uint256 parentPID;         //parent PID\\n        uint256 topPID;\\n        uint256 sonNumber;\\n        uint256 bigPotSonPID;    // big pot son ID \\n        uint256 totalRecmdplys; // total recommanded players \\n        uint256 totalRecmdAmount;     // total Recommended ETH  without  himself\\n        uint8   nodeLevel;       // this is node level for V1-V6\\n        //mapping(uint256 =\\u003e uint256)  sonPIDList;     // son number -\\u003e son PID list\\n        mapping(uint256 =\\u003e bool)  sonPIDListMap;     //son PID list mapping\\n        mapping(uint256 =\\u003e uint256) sonTotalBalance; // PID-\\u003e total balance \\n       \\n    }\\n    \\n    struct Player{\\n        //uint256 pID;\\n        uint256 ticketInCost;     // how many eth can join\\n        uint256   withdrawAmount;     // how many eth can join\\n        uint256 startTime;      // join the game time\\n        uint256 totalSettled;   // rturn  funds\\n        uint256 staticIncome;\\n        uint256 lastCalcSITime;      // last Calc staticIncome Time  \\n        //uint256 lastCalcDITime; //  last Calc dynamicIncome Time\\n        uint256 dynamicIncome; //  last Calc dynamicIncome\\n        uint256 stepIncome;\\n        bool isActive; // 1 mean is 10eth,2 have new one son,3,\\n        bool isAlreadGetIns;// already get insePoolBalance income;\\n    }\\n    \\n    \\n    struct Round{\\n        uint256 rID;            //Round ID\\n        uint256 rStartTime;      //Round start ID\\n        uint256 rPlys;           // new round players\\n        uint256 lastPID;         // last Player ID pID\\n        uint256 totalInseAmount; // \\n        uint256 fritInsePoint;\\n        uint256 fritInseAmount;\\n        uint256[] plyInList;\\n    }\\n}\\n\\ncontract MainPool{\\n    using SafeMath for *;\\n    \\n    //address manager \\n    AddrMInterface addrM ;\\n    TickectInerface  tickect;\\n    ERC20  adcERC20;\\n    \\n    // pool\\n    mapping(uint256 =\\u003e uint256)     public allInBalance;\\n    mapping(uint256 =\\u003e uint256)     public mainPoolLockBal; // lock balance do not sub\\n    mapping(uint256 =\\u003e uint256)     public mainPoolBalance; // RID -\\u003e balance total Main pool balance \\n    mapping(uint256 =\\u003e uint256)     public mainPoolWithdrawBalance; // RID -\\u003e balance total Main pool balance \\n    mapping(uint256 =\\u003e uint256)     public alreadyWithDrawBal; // RID -\\u003e balance total Main pool balance \\n    mapping(uint256 =\\u003e uint256)     public insePoolBalance; // total insurance pool Banacle \\n    \\n    uint256 public mainPoolSTime ;\\n    uint256 public totalDistroyADC;\\n    \\n    uint256 public constant oneDay = 86400 seconds ;\\n    \\n    \\n    //node level\\n    mapping(uint8 =\\u003e uint256)       private nlThdAmount; // node level threshold amount\\n    mapping(uint8 =\\u003e uint8)         private nlIncome; // node level threshold amount\\n    mapping(uint256 =\\u003e uint256 )    private doubleV6PID; // id -\\u003e pID ,is start is 1 ;\\n    mapping(uint256 =\\u003e bool )       private isDoubleV6; // PID -\\u003e TRUE ,is start is 1 ;\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e uint256 )) private plydV6Income; // rid -\\u003e pid-\\u003ebalance ,is start is 1 ;\\n    uint256 totalV6Number;\\n    \\n    // Round \\n    uint256 public RID;\\n    mapping(uint256 =\\u003e gameDataSet.Round) public round; // RID =\\u003e round Info\\n    mapping(uint256 =\\u003e mapping(uint256=\\u003ebool)) public luckPID;\\n    \\n    // Player\\n    uint256 lastPID;\\n    mapping(uint256 =\\u003e gameDataSet.PlyRelationship) public plyRShip;\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e gameDataSet.Player)) public plyr; // rid-\\u003e pid-\\u003e player\\n    mapping(address =\\u003e uint256) public plyrID; // address -\\u003e pid-\\u003e playerID\\n    mapping(uint256 =\\u003e address) private plyrAddr; // pid -\\u003e addr-\\u003e playerID\\n    //mapping(uint256 =\\u003emapping(uint256 =\\u003e uint256)) public plyBalance; // player total can without balance  \\n    mapping(uint256 =\\u003emapping(uint256 =\\u003e uint256)) private plyWithdrawBalance; // player total can without balance  \\n    mapping(uint256 =\\u003emapping(uint256 =\\u003e uint256)) public playBiggertReward; // player total can without balance \\n    mapping(uint256 =\\u003euint256) private playDistroyADC; // PID-ADC balance player total can without balance \\n    mapping(address=\\u003ebool) private vipPly;\\n    mapping(uint256=\\u003ebool) private vipPlayerID;\\n    mapping(uint256=\\u003emapping(uint256 =\\u003e uint256))     public  plyLucklyAmount; //rid-pid-amount\\n    \\n    // ambassador \\n   mapping(address =\\u003e bool) public ambassadorList; //addr-true-BOOL\\n    //uint256[] ambRewardList;// PID list\\n    mapping(uint256=\\u003ebool) private ambRewardMap;\\n    //mapping(uint256=\\u003euint256) ambRewardIdx;\\n    mapping(uint256 =\\u003e mapping(uint256=\\u003euint256)) public ambRewardBalance;\\n    \\n    //vip\\n    address constant vip1Addr = address(0x953ad059b61aA4A23fa48d5eca617D4920E3343e);\\n    //address constant vip1Addr = address(0xa9A2CbA5d5d16DE370375B42662F3272279B2b89);\\n    //address constant vip2Addr = address(0x6bE9780954580FCC268944e9D6271B3Dfc886997);\\n    address constant vip2Addr = address(0xfbcB561D76a622341E6e537a17c5C17af33c4628);\\n    address constant vip3Addr = address(0x669f366427ea8184FdCDCda6D6201a6bAAf9b156);\\n    address constant vip4Addr = address(0xBcA44B04e10e04b7FeD7F262cAd70A683D753981);\\n    address constant vip5Addr = address(0x0D3c20D9102200242398dE26fdF09F29f435421b);\\n    address constant vip6Addr = address(0xbb3c82CD454911F140B68FE2E67504af9A2b5D16);\\n    //address constant vip6Addr = address(0xa9A2CbA5d5d16DE370375B42662F3272279B2b89);\\n   \\n    address constant vip7Addr = address(0xbE6DFD74AF0848b9cf6C6DFBc8bb24d2920e6aDe);\\n    address constant vip8Addr = address(0x5b9347799602D0164DF3926c10f237543eaa5b9F);\\n    address constant vip9Addr = address(0xa2221dE49E4085Be8098d1A8B4538734ce4977C7);\\n    address constant vip10Addr = address(0xAc1c0B39F3A1450E53BA0dA1bCAB5D9572DCed57);\\n    address constant vip11Addr = address(0x7721a0C6eb2F2a056C48D107d0a2C4Cff261e98c);\\n    //address constant vip11Addr = address(0xa9A2CbA5d5d16DE370375B42662F3272279B2b89);\\n\\n    \\n    constructor(address addressM_) public{\\n        \\n        addrM = AddrMInterface(addressM_);\\n        tickect = TickectInerface(addrM.getAddr(\\\"TICKET\\\"));\\n        adcERC20 = ERC20(addrM.getAddr(\\\"ADC\\\"));\\n        \\n        mainPoolSTime = now;\\n        RID = 1;\\n        uint256[] memory temparry;\\n        round[RID] = gameDataSet.Round(RID,now,0,11,0,1,0,temparry);\\n        lastPID = 11;\\n        nlThdAmount[1] = 200000000000000000000; //bigger then 200 eth \\n        nlThdAmount[2] = 600000000000000000000;\\n        nlThdAmount[3] = 2000000000000000000000;\\n        nlThdAmount[4] = 6000000000000000000000;\\n        nlThdAmount[5] = 12000000000000000000000;\\n        nlThdAmount[6] = 25000000000000000000000;\\n        \\n        nlIncome[1] = 5; // 5% 5/100\\n        nlIncome[2] = 7;\\n        nlIncome[3] = 9;\\n        nlIncome[4] = 11;\\n        nlIncome[5] = 13;\\n        nlIncome[6] = 15;\\n        //initVip();\\n        initVipPlay();\\n    }\\n    \\n    function initVipPlay() internal{\\n        vipPly[vip1Addr] = true;\\n        vipPly[vip2Addr] = true;\\n        vipPly[vip3Addr] = true;\\n        vipPly[vip4Addr] = true;\\n        vipPly[vip5Addr] = true;\\n        vipPly[vip6Addr] = true;\\n        vipPly[vip7Addr] = true;\\n        vipPly[vip8Addr] = true;\\n        \\n        vipPly[vip9Addr] = true;\\n        vipPly[vip10Addr] = true;\\n        vipPly[vip11Addr] = true;\\n        \\n        \\n        \\n    }\\n    \\n    modifier notContract(address _addr){\\n        uint size;\\n        assembly { size := extcodesize(_addr) }\\n        require(size == 0,\\\"\\\") ;\\n        _;\\n    }\\n    \\n    function joinGame(address parentAddr) public payable notContract(msg.sender){\\n        // check ticket\\n        uint256 tmPid = plyrID[msg.sender];\\n        if(tmPid ==0){\\n            require(msg.sender != parentAddr,\\\"parent same as msg sender\\\");\\n        }\\n        require(checkTicket(msg.sender,msg.value),\\\"check ticket fail\\\");\\n        \\n        // check invite\\n        uint256 pID =plyrID[msg.sender];\\n        \\n        uint256 parentPid_ = plyrID[parentAddr];\\n        uint256 inBalance = plyr[RID][pID].ticketInCost;\\n        \\n        allInBalance[RID] += inBalance;\\n        \\n        if(tmPid == 0 \\u0026\\u0026 !vipPly[msg.sender]){\\n            plyRShip[pID].parentPID = parentPid_;\\n            // topPID\\n            if(parentPid_ == 0){\\n                plyRShip[pID].topPID = pID;\\n            }else{\\n                plyRShip[pID].topPID = plyRShip[parentPid_].topPID;\\n            }\\n        }\\n        \\n        /*if(plyr[RID][parentPid_].lastCalcDITime == 0){\\n            plyr[RID][parentPid_].lastCalcDITime = now;\\n        }*/\\n        \\n        if (RID \\u003e 1 \\u0026\\u0026 !vipPly[msg.sender] \\u0026\\u0026 !vipPlayerID[parentPid_]){\\n            activeParent(pID,parentPid_,plyr[RID][pID].ticketInCost);\\n        } \\n    \\n        // the pool  5% for insurance pool\\n        if(insePoolBalance[RID] \\u003e= 50000*10**18){\\n           mainPoolBalance[RID] += inBalance; \\n           mainPoolLockBal[RID] += inBalance;\\n           mainPoolWithdrawBalance[RID] += inBalance;\\n        }else{\\n            uint256 temp = inBalance*95/100;\\n            insePoolBalance[RID] += inBalance*5/100;\\n            mainPoolBalance[RID] += temp;\\n            mainPoolLockBal[RID] += temp;\\n            mainPoolWithdrawBalance[RID] += temp;\\n        }\\n        \\n        \\n    \\n        // find parents calc earn\\n        calcEarn(pID,inBalance);\\n        \\n        //check pool state\\n        setRoundInfo(pID);\\n        \\n    }\\n    \\n    function withdraw() public{\\n        //check ADC \\n        uint256 pid = plyrID[msg.sender];\\n        uint256 bunlers = 0;\\n        //if(pid \\u003e 11){\\n            require(plyr[RID][pid].isActive,\\\"ply not active\\\");\\n        //}\\n        require(mainPoolWithdrawBalance[RID]\\u003e0,\\\"pool not withdraw balance\\\");\\n        if(RID \\u003e 1 \\u0026\\u0026 !plyr[RID-1][pid].isAlreadGetIns){\\n            //check last round \\n            if(luckPID[RID-1][pid]\\u0026\\u0026 insePoolBalance[RID-1] \\u003e 0 ){\\n                if(pid == round[RID-1].plyInList[round[RID-1].fritInsePoint]){\\n                    bunlers = round[RID-1].fritInseAmount;\\n                    insePoolBalance[RID-1] -= bunlers;\\n                }else{\\n                    bunlers = plyr[RID-1][pid].ticketInCost*2;\\n                    if(bunlers \\u003e insePoolBalance[RID-1]){\\n                        insePoolBalance[RID-1] = 0;\\n                        bunlers = insePoolBalance[RID-1] ;\\n                    }else{\\n                        insePoolBalance[RID-1] -= bunlers;\\n                    }\\n                    \\n                }\\n                \\n                mainPoolBalance[RID] -= bunlers;\\n                plyr[RID-1][pid].isAlreadGetIns = true;\\n                plyLucklyAmount[RID-1][pid] = bunlers;\\n            }\\n        }/*else{\\n            require(plyWithdrawBalance[RID][pid] \\u003c= plyBalance[RID][pid],\\\"not enought balance can withdraw\\\");\\n        }*/\\n        \\n        uint256 wdBalance;\\n        if(plyr[RID][pid].totalSettled\\u003eplyWithdrawBalance[RID][pid] ){\\n            wdBalance = plyr[RID][pid].totalSettled-plyWithdrawBalance[RID][pid] ;\\n        }\\n        if(bunlers == 0){\\n            require(wdBalance \\u003e 0,\\\"not enought balance can withdraw\\\");\\n        }\\n        \\n        \\n        uint256 totalWdBal = wdBalance + bunlers;\\n        //wdBalance += bunlers;\\n        if(totalWdBal \\u003e mainPoolWithdrawBalance[RID]){\\n            totalWdBal = mainPoolWithdrawBalance[RID];\\n        }\\n        uint256 disAmount  = tickect.calDeductionADC(totalWdBal,false);\\n        require(adcERC20.balanceOf(msg.sender)\\u003edisAmount,\\\"not adc to buy out tikcet\\\");\\n        adcERC20.distroy(msg.sender,disAmount);\\n        playDistroyADC[pid] += disAmount;\\n        totalDistroyADC += disAmount;\\n        if(totalWdBal \\u003e= mainPoolWithdrawBalance[RID]){\\n            mainPoolWithdrawBalance[RID] = 0;\\n            plyr[RID][pid].withdrawAmount += mainPoolWithdrawBalance[RID];\\n            alreadyWithDrawBal[RID] += mainPoolWithdrawBalance[RID];\\n            msg.sender.transfer(mainPoolWithdrawBalance[RID]);\\n            \\n        }else{\\n            mainPoolWithdrawBalance[RID] -= totalWdBal;\\n            plyr[RID][pid].withdrawAmount += wdBalance;\\n            alreadyWithDrawBal[RID] += totalWdBal;\\n            msg.sender.transfer(totalWdBal);\\n            \\n        }\\n        \\n        plyWithdrawBalance[RID][pid] += wdBalance;\\n        \\n        plyr[RID][pid].staticIncome = 0;\\n        plyr[RID][pid].dynamicIncome = 0;\\n        plyr[RID][pid].stepIncome = 0;\\n        ambRewardBalance[RID][pid] = 0;\\n        plydV6Income[RID][pid] = 0;\\n    }\\n    \\n    // settlement Static income by web\\n    function settlementStatic() public {// that is temp balance\\n        \\n        //uint256 reward;\\n        uint256 pid = plyrID[msg.sender];\\n        uint256 temp = 0;\\n        gameDataSet.Player storage  rPlyer = plyr[RID][pid];\\n        //require(pid\\u003e11,\\\"is vip\\\");\\n        require(rPlyer.isActive,\\\"not active\\\");\\n        require(rPlyer.ticketInCost \\u003e0,\\\"not charge\\\");\\n        require(rPlyer.totalSettled \\u003c playBiggertReward[RID][pid],\\\"already to top reward\\\");\\n        \\n        \\n        require(now-rPlyer.lastCalcSITime \\u003e oneDay,\\\"not enought one day\\\");\\n        if(rPlyer.lastCalcSITime == 0){\\n            temp = calcS_T(rPlyer.startTime,rPlyer.ticketInCost);\\n        }else if(now - rPlyer.lastCalcSITime \\u003e oneDay){\\n            temp = calcS_T(rPlyer.lastCalcSITime,rPlyer.ticketInCost);\\n        }\\n        //temp = temp*50;\\n        if(rPlyer.totalSettled + temp \\u003e playBiggertReward[RID][pid]){\\n            temp = playBiggertReward[RID][pid] - rPlyer.totalSettled;\\n        }\\n        if(temp == 0){\\n            return ;\\n        }\\n       \\n        if(mainPoolBalance[RID] \\u003e temp){\\n            //plyBalance[RID][pid] += reward;\\n            rPlyer.staticIncome += temp;\\n            rPlyer.totalSettled += temp;\\n            mainPoolBalance[RID] -=temp;\\n            \\n            calcDynamic(pid,temp); \\n        }else{\\n           // plyBalance[RID][pid] += mainPoolBalance[RID];\\n            rPlyer.staticIncome += mainPoolBalance[RID];\\n            rPlyer.totalSettled += mainPoolBalance[RID];\\n            mainPoolBalance[RID] =0;\\n            \\n            // need start new rand\\n            startNewRount();\\n            \\n        }\\n        \\n        \\n        rPlyer.lastCalcSITime = rPlyer.startTime + ((now - rPlyer.startTime) / oneDay) * oneDay; // remark the last calc income time\\n        \\n    }\\n    \\n    function calcDynamic(uint256 plyid_,uint256 staticIncome_) internal{\\n        uint256 parenID = plyRShip[plyid_].parentPID;\\n        uint256 sonLen = plyRShip[parenID].sonNumber;\\n        uint256 dIncome = 0;\\n        \\n        uint256 temp = staticIncome_;\\n        //if((sonLen_ == 1 \\u0026\\u0026 treeHight_\\u003c=2) || (sonLen_ == 2 \\u0026\\u0026 treeHight_ \\u003c= 4) || (sonLen_ == 3 \\u0026\\u0026 treeHight_\\u003c= 6) || (sonLen_ == 4 \\u0026\\u0026 treeHight_\\u003c= 8)){\\n        for(uint8 i=1; i\\u003c= 8;i++){\\n            //find parent\\n            temp = staticIncome_;\\n            if(parenID == 0){\\n                return;\\n            }\\n            //if(!vipPlayerID[parenID]){\\n            if(plyr[RID][parenID].totalSettled \\u003e= playBiggertReward[RID][parenID] || !plyr[RID][parenID].isActive){\\n                parenID = plyRShip[parenID].parentPID;\\n                sonLen = plyRShip[parenID].sonNumber;\\n                continue;\\n            }//}\\n            //if(parenID !=0 ){\\n                /*if(plyr[RID][parenID].ticketInCost == 0 \\u0026\\u0026 RID \\u003e 1 ){\\n                    if(!vipPlayerID[parenID] \\u0026\\u0026 plyr[RID-1][parenID].ticketInCost \\u003c=10*10**18 \\u0026\\u0026 plyr[RID-1][parenID].ticketInCost \\u003c plyr[RID][plyid_].ticketInCost){\\n                 \\n                        if(plyr[RID][plyid_].lastCalcSITime == 0){\\n                            temp = calcS_T(plyr[RID][plyid_].startTime,plyr[RID-1][parenID].ticketInCost);\\n                        }else if(now - plyr[RID][plyid_].lastCalcSITime \\u003e oneDay){\\n                            temp = calcS_T(plyr[RID][plyid_].lastCalcSITime,plyr[RID-1][parenID].ticketInCost);\\n                        }\\n                    }\\n                        \\n                }else{*/\\n                    if(!vipPlayerID[parenID] \\u0026\\u0026 plyr[RID][parenID].ticketInCost \\u003c=10*10**18 \\u0026\\u0026 plyr[RID][parenID].ticketInCost \\u003c plyr[RID][plyid_].ticketInCost){\\n                    \\n                        if(plyr[RID][plyid_].lastCalcSITime == 0){\\n                            temp = calcS_T(plyr[RID][plyid_].startTime,plyr[RID][parenID].ticketInCost);\\n                        }else if(now - plyr[RID][plyid_].lastCalcSITime \\u003e oneDay){\\n                            temp = calcS_T(plyr[RID][plyid_].lastCalcSITime,plyr[RID][parenID].ticketInCost);\\n                        }\\n                    }\\n               // }\\n                if(i == 1){\\n                    dIncome = (temp*20)/100;\\n                }else if(i\\u003e=2 \\u0026\\u0026 i\\u003c=3){\\n                    dIncome = (temp*10)/100;\\n                }else if(i\\u003e=4 \\u0026\\u0026 i\\u003c=8){\\n                    dIncome = (temp*5)/100;\\n                }\\n                if(i==3 ||i==4){\\n                    if(sonLen\\u003c2){\\n                       dIncome = 0; \\n                    }\\n                }else if(i==5 || i==6){\\n                    if(sonLen \\u003c3){\\n                        dIncome = 0;\\n                    } \\n                }else if(i==7 || i==8){\\n                    if(sonLen \\u003c 4){\\n                        dIncome = 0;\\n                    }\\n                }\\n                \\n                if(dIncome \\u003e 0){\\n                    if(plyr[RID][parenID].totalSettled + dIncome \\u003e playBiggertReward[RID][parenID]){\\n                       dIncome = playBiggertReward[RID][parenID] - plyr[RID][parenID].totalSettled;\\n                   }\\n                   \\n                   if(mainPoolBalance[RID] \\u003e dIncome){\\n                        //plyBalance[RID][parenID] += dIncome;\\n                        plyr[RID][parenID].dynamicIncome += dIncome;\\n                        plyr[RID][parenID].totalSettled += dIncome;\\n                        mainPoolBalance[RID] -= dIncome;\\n                        \\n                    }else{\\n                        //plyBalance[RID][parenID] += mainPoolBalance[RID];\\n                        plyr[RID][parenID].dynamicIncome += mainPoolBalance[RID];\\n                        plyr[RID][parenID].totalSettled += mainPoolBalance[RID];\\n                        mainPoolBalance[RID] =0;\\n            \\n                    // need start new rand\\n                        startNewRount();\\n                        break;\\n                    } \\n                }\\n            \\n            dIncome = 0;\\n            parenID = plyRShip[parenID].parentPID;\\n            sonLen = plyRShip[parenID].sonNumber;\\n            \\n        }\\n    }\\n    \\n    function setAmbFlag(address ply_) public{\\n        require(msg.sender == addrM.getAddr(\\\"TICKET\\\"),\\\"msg sender not TICKET\\\");\\n       \\n        ambassadorList[ply_] = true;\\n        \\n    }\\n    \\n    //ambassador\\n    function getPlayerInfo(address ply_,uint256 rid_) public view returns(\\n        uint256 stIncome_,\\n        uint256 dtIncome_,\\n        uint256 stepIncome_,\\n        uint256 ambIncome_,\\n        uint256 doubV6Income_,\\n        uint256 totoalIncome_,\\n        uint256 withdrawAmount_,\\n        uint256 ticketIn_,\\n        uint256 canWithdrawAmount_,\\n        uint256 startTime_,\\n        uint256 liveRountAmount_)\\n    {\\n            uint256 pid = plyrID[ply_];\\n            \\n            stIncome_ = plyr[rid_][pid].staticIncome;\\n            dtIncome_ = plyr[rid_][pid].dynamicIncome;\\n            stepIncome_ =  plyr[rid_][pid].stepIncome;\\n            ambIncome_ = ambRewardBalance[rid_][pid];\\n            doubV6Income_ = plydV6Income[rid_][pid];\\n            totoalIncome_ = plyr[rid_][pid].totalSettled;//plyBalance[rid_][pid];\\n            ticketIn_ = plyr[rid_][pid].ticketInCost;\\n            withdrawAmount_ = plyr[rid_][pid].withdrawAmount;\\n            //canWithdrawAmount_ =  rPlyer.staticIncome + rPlyer.stepIncome+ ambRewardBalance[rid_][pid] + plydV6Income[RID][pid] + rPlyer.dynamicIncome;\\n            if(plyr[rid_][pid].totalSettled \\u003e plyr[rid_][pid].withdrawAmount){\\n                canWithdrawAmount_ = plyr[rid_][pid].totalSettled - plyr[rid_][pid].withdrawAmount;\\n            }else{\\n                canWithdrawAmount_ = 0;\\n            }\\n            startTime_ = plyr[rid_][pid].startTime;\\n            //if(playBiggertReward[RID][pid] \\u003e plyr[rid_][pid].totalSettled){\\n            liveRountAmount_ = playBiggertReward[rid_][pid] - plyr[rid_][pid].totalSettled;\\n            //}\\n            \\n    }\\n    \\n    function getPlayerRelship(address ply_) public view returns(\\n        uint256 sonNumber_,\\n        uint256 allNumber_,\\n        uint256 curLevel_,\\n        bool    isamb_,\\n        uint256 bigPotBalance_,\\n        uint256 smailPotBalance_,\\n        bool isDoubleV6_,\\n        uint256 distroyADC_)\\n    {\\n        uint256 pid = plyrID[ply_]; \\n        sonNumber_= plyRShip[pid].sonNumber;\\n        allNumber_= plyRShip[pid].totalRecmdplys;\\n        curLevel_=plyRShip[pid].nodeLevel;\\n        \\n        bigPotBalance_=plyRShip[pid].sonTotalBalance[plyRShip[pid].bigPotSonPID];\\n        isDoubleV6_ = isDoubleV6[pid];\\n        distroyADC_ = playDistroyADC[pid];\\n        smailPotBalance_ = plyRShip[pid].totalRecmdAmount - plyRShip[pid].sonTotalBalance[plyRShip[pid].bigPotSonPID];\\n        isamb_ = ambRewardMap[pid];\\n    }\\n    \\n   \\n    \\n    function getPoolInfo(uint256 rid_) public view returns(\\n        uint256 totalInBalance_, // all in balanace\\n        uint256 totalDivBalance_, // Dividend  pool balance\\n        uint256 totalInsBalance_,//Insurance pool balance\\n        uint256 totalPlayers_,\\n        uint256 totalDisADC_)\\n    {\\n        totalInBalance_ = allInBalance[rid_];\\n        totalDivBalance_ = mainPoolBalance[rid_];\\n        totalInsBalance_ = insePoolBalance[rid_];\\n        totalPlayers_ = round[rid_].lastPID;\\n        totalDisADC_ = totalDistroyADC;\\n    }\\n    \\n    function getRID() public view returns(uint256 rid_){\\n        rid_ = RID;\\n    }\\n    \\n    \\n    function activeParent(uint256 sonID_,uint256 parentPid_,uint256 value_) internal{\\n        \\n        if(!plyr[RID][parentPid_].isActive){\\n            if(value_ \\u003e= 10*10**18 \\u0026\\u0026 !plyRShip[parentPid_].sonPIDListMap[sonID_]){\\n                plyr[RID][parentPid_].isActive = true;\\n                if(playBiggertReward[RID-1][parentPid_] \\u003e plyr[RID-1][parentPid_].totalSettled){\\n                    playBiggertReward[RID][parentPid_] += (playBiggertReward[RID-1][parentPid_] - plyr[RID-1][parentPid_].totalSettled);\\n                    plyr[RID][parentPid_].ticketInCost = plyr[RID-1][parentPid_].ticketInCost;\\n                    plyr[RID][parentPid_].lastCalcSITime = plyr[RID-1][parentPid_].lastCalcSITime;\\n                }\\n                \\n            }\\n        }\\n       \\n    }\\n    \\n    function checkTicket(address payable ply_,uint256 value_) internal returns(bool){ \\n        \\n       \\n       if(vipPly[ply_]){\\n           initVip(ply_);\\n       }\\n       \\n       uint256 pid =plyrID[ply_];\\n       uint256 disAmount;\\n       \\n        if(pid != 0 ){\\n           if(plyr[RID][pid].totalSettled \\u003e= playBiggertReward[RID][pid]){\\n                   \\n               plyr[RID][pid].totalSettled = 0;\\n               plyr[RID][pid].withdrawAmount = 0;\\n               plyr[RID][pid].ticketInCost = 0;\\n               plyr[RID][pid].staticIncome = 0;\\n               plyr[RID][pid].dynamicIncome = 0;\\n               plyr[RID][pid].stepIncome = 0;\\n               playBiggertReward[RID][pid] = 0;\\n               ambRewardBalance[RID][pid] = 0;\\n               plydV6Income[RID][pid] = 0;\\n               plyWithdrawBalance[RID][pid] = 0;\\n            } \\n        }\\n        \\n        if (plyr[RID][pid].ticketInCost \\u003e 0 ){\\n            return false;\\n        }\\n       \\n        require(value_ \\u003e= 1*10**18,\\\"transfer to smail\\\");\\n        disAmount = tickect.calDeductionADC(value_,true);\\n        //require(adcERC20.balanceOf(ply_)\\u003edisAmount,\\\"not adc to buy in tikcet\\\");\\n        adcERC20.distroy(ply_,disAmount);\\n        totalDistroyADC += disAmount;\\n        \\n        \\n        if(pid == 0){\\n            lastPID += 1;\\n            pid = lastPID;\\n            \\n            plyrID[ply_] = pid; \\n            plyrAddr[pid] = ply_;\\n            plyr[RID][pid].isActive = true;\\n            if(ambassadorList[ply_]){\\n                ambRewardMap[pid] = true;\\n            }\\n            \\n        }\\n        \\n        playDistroyADC[pid] += disAmount;\\n        plyr[RID][pid].startTime = now;\\n        plyr[RID][pid].ticketInCost = value_;\\n        if(vipPly[ply_]){\\n            playBiggertReward[RID][pid] += value_*20000;\\n            vipPlayerID[pid] = true;\\n        }else{\\n           if(value_ \\u003e= 31*10**18){\\n                playBiggertReward[RID][pid] += value_*3;\\n            }else if(value_ \\u003c 31*10**18 \\u0026\\u0026 value_ \\u003e= 11*10**18){\\n                playBiggertReward[RID][pid] +=value_*25/10;\\n            }else{\\n                playBiggertReward[RID][pid] += value_*2;\\n            } \\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    function setRoundInfo(uint256 plyID_) internal{\\n        \\n        if(vipPlayerID[plyID_]){\\n            return;\\n        }\\n        round[RID].rPlys += 1;\\n        round[RID].lastPID = plyID_;\\n        round[RID].plyInList.push(plyID_);\\n        \\n    }\\n    \\n    function calcEarn(uint256 plyID_,uint256 value_) internal{\\n        //check Insurance pool\\n        \\n        uint256 aveIncome ;\\n       // uint256 len = ambRewardList.length;\\n        //uint256  reward;\\n        if(totalV6Number \\u003e 0){\\n            aveIncome= (value_*3/100) /totalV6Number;\\n            uint256 doubpid;\\n            for(uint256 i = 1; i \\u003c= totalV6Number; i++){\\n                doubpid = doubleV6PID[i];\\n                if(RID == 1 || (RID \\u003e1 \\u0026\\u0026 plyr[RID][doubpid].isActive) /*|| vipPlayerID[plyID_]*/){\\n                    if(plyr[RID][doubpid].totalSettled \\u003e= playBiggertReward[RID][doubpid]){\\n                        continue;\\n                    }else{\\n                        if( plyr[RID][doubpid].totalSettled + aveIncome \\u003e playBiggertReward[RID][doubpid]){\\n                            uint256  temp = playBiggertReward[RID][doubpid] - plyr[RID][doubpid].totalSettled;\\n                            \\n                            plyr[RID][doubpid].totalSettled +=temp;\\n                            plydV6Income[RID][doubpid] += temp;\\n                            mainPoolBalance[RID] -= temp;\\n                        }else{\\n                             plydV6Income[RID][doubpid] += aveIncome;\\n                            //plyBalance[RID][doubpid] += aveIncome;\\n                            plyr[RID][doubpid].totalSettled += aveIncome; \\n                            mainPoolBalance[RID] -= aveIncome;\\n                        }\\n                    }\\n                    \\n                    \\n                }\\n            }\\n        }\\n        \\n        findParentByFor(plyID_,value_);\\n    }\\n    \\n    function findParentByFor(uint256 plyID_,uint256 value_) internal{\\n            \\n            uint256 parentPID_ ;\\n            uint256 pp = plyID_;\\n            //uint8 dividendAccount = nlIncome[plyRShip[toppid].nodeLevel]; \\n            uint256 haveOneV6;\\n            uint8 parnetNodeLevel;\\n            uint8 biggestNodeLevel=0;\\n            uint256[] memory stepPlyerList = new uint256[](120);\\n            uint256 stepPlyNum;\\n            \\n            uint256 ambPid = 0 ;\\n            \\n            for(uint8 i=0;i\\u003c120;i++){\\n                parentPID_ = plyRShip[pp].parentPID;\\n                parnetNodeLevel = plyRShip[parentPID_].nodeLevel;\\n                if(parentPID_ == 0){\\n                    break;\\n                }\\n                \\n                if(ambRewardMap[parentPID_] \\u0026\\u0026 ambPid == 0\\u0026\\u0026plyr[RID][parentPID_].isActive){\\n                    ambPid = parentPID_;\\n                }\\n                //if(parentPID_ !=0){\\n                    //set releaseship\\n                    setRelationship(pp,parentPID_,value_);\\n                \\n                    //double v6\\n                    if(parnetNodeLevel \\u003e 0){\\n                        if(parnetNodeLevel == 6 \\u0026\\u0026 haveOneV6 \\u003e=1 \\u0026\\u0026 !isDoubleV6[parentPID_]){\\n                            isDoubleV6[parentPID_] = true;\\n                            totalV6Number +=1;\\n                            doubleV6PID[totalV6Number] = parentPID_;\\n                        }\\n                        if(parnetNodeLevel == 6 \\u0026\\u0026 !isDoubleV6[parentPID_]){\\n                            haveOneV6++;\\n                        }\\n                    \\n                        //step income calc \\n                        if(plyr[RID][parentPID_].isActive){\\n                            if(parnetNodeLevel \\u003e biggestNodeLevel){\\n                                biggestNodeLevel = parnetNodeLevel;\\n                                stepPlyerList[stepPlyNum] = parentPID_;\\n                                stepPlyNum++;\\n                            }\\n                        }\\n                    }\\n                    //check level\\n                    if((plyr[RID][parentPID_].ticketInCost \\u003e= 11*10**18 \\u0026\\u0026 plyRShip[parentPID_].sonNumber \\u003e= 5)){\\n                        for (uint8 j = 1; j \\u003c= 6; j++) {\\n                            if(plyRShip[parentPID_].totalRecmdAmount - plyRShip[parentPID_].sonTotalBalance[plyRShip[parentPID_].bigPotSonPID] \\u003e nlThdAmount[j]){\\n                                plyRShip[parentPID_].nodeLevel = j;\\n                            }\\n                        }\\n                    }\\n                    \\n                    pp = parentPID_;\\n                \\n                //}\\n            }\\n            \\n            //calc step income\\n            if(stepPlyNum \\u003e0){\\n                calcStepByList(stepPlyNum,stepPlyerList,biggestNodeLevel,value_);\\n                \\n            }\\n             \\n            //calc ambReward \\n            if(ambPid \\u003e 0){\\n                setAmbRewardBalance(ambPid,value_);\\n            }\\n            \\n            \\n    }\\n    \\n    function calcStepByList(uint256 stepNum_,uint256[] memory stepPlyerList,uint8 biggestNodeLevel,uint256 value_) internal{\\n                uint8 dividendAccount  = nlIncome[biggestNodeLevel];\\n                uint8 totalDiv;\\n                uint8 curDiv;\\n                uint8 plyNlevel;\\n                uint256 steppid;\\n                for(uint8 i=0;i\\u003cstepNum_;i++){\\n                    steppid = stepPlyerList[i];\\n                    \\n                    plyNlevel = plyRShip[steppid].nodeLevel;\\n                    if(totalDiv == 0){\\n                        curDiv = nlIncome[plyNlevel];\\n                    }else{\\n                        if(dividendAccount \\u003enlIncome[plyNlevel] - totalDiv){\\n                            curDiv = nlIncome[plyNlevel] - totalDiv;\\n                        }else{\\n                            curDiv = dividendAccount;\\n                        }\\n                    } \\n                   \\n                    calcStepIncome(steppid,value_,curDiv);\\n                    \\n                    totalDiv += curDiv;\\n                    if(dividendAccount \\u003e curDiv){\\n                        dividendAccount -=curDiv;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            \\n    }\\n    \\n    function setAmbRewardBalance(uint256 pid_,uint256 value_) internal{\\n       \\n        uint256 ambincom;\\n        if(plyr[RID][pid_].totalSettled \\u003c playBiggertReward[RID][pid_]){\\n            ambincom = plyr[RID][pid_].totalSettled + (value_*5)/100 \\u003e playBiggertReward[RID][pid_]? playBiggertReward[RID][pid_]-plyr[RID][pid_].totalSettled:(value_*5)/100;\\n            plyr[RID][pid_].totalSettled += ambincom;//(value_*5)/100;\\n            ambRewardBalance[RID][pid_] += ambincom;// (value_*5)/100;\\n            mainPoolBalance[RID] -=  ambincom;}//(value_*5)/100;}\\n             \\n    }\\n    \\n    \\n    \\n    function setRelationship(uint256 sonID_,uint256 plyID_,uint256 value_) internal{\\n    \\n        gameDataSet.PlyRelationship storage  rship = plyRShip[plyID_];\\n       \\n            \\n        if(!rship.sonPIDListMap[sonID_]){\\n            rship.sonNumber += 1;\\n            //rship.sonPIDList[rship.sonNumber] = sonID_;//add son\\n            rship.sonPIDListMap[sonID_] = true;\\n        }\\n        //rship.totalRecmdplys++;\\n        rship.sonTotalBalance[sonID_] += value_; // add son toto balance value\\n        rship.totalRecmdAmount += value_;\\n        \\n        //check the big one some\\n        if(rship.sonTotalBalance[sonID_] \\u003e rship.sonTotalBalance[rship.bigPotSonPID]){\\n            rship.bigPotSonPID = sonID_;\\n        }\\n        \\n    }\\n    \\n    \\n    \\n    \\n    function calcS_T(uint256 lastTime_,uint256 value_) internal view returns(uint256 _earnAmount){\\n        \\n        \\n            if(now - mainPoolSTime \\u003c= (60 * oneDay)){ // 2 month\\n                \\n                _earnAmount = (((now -  lastTime_  ) / oneDay ) * value_ * (70))/10000;\\n            }else if(now - mainPoolSTime \\u003c= (120 * oneDay)){ // 4 month\\n                uint256 oneTime = mainPoolSTime + 60*oneDay;\\n                if(lastTime_ \\u003c oneTime){\\n                    _earnAmount = (((oneTime - lastTime_)/oneDay) * value_ * 70)/10000 + (((now - oneTime) / oneDay  ) * value_ * (65))/10000;\\n                }else{\\n                    _earnAmount = (((now -  lastTime_  ) / oneDay ) * value_ * (65))/10000;\\n                }\\n                \\n            }else{// langer then 6 month\\n                uint256 oneTime = mainPoolSTime + 60*oneDay;\\n                uint256 twoTime = mainPoolSTime+ 120*oneDay;\\n                if(lastTime_ \\u003c oneTime){\\n                    _earnAmount = (((oneTime - lastTime_)/oneDay) * value_ * 70)/10000 + (60  * value_ * 65)/10000 + (((now - twoTime) / oneDay ) * value_ * 50)/10000;\\n                }else if(lastTime_ \\u003c twoTime){\\n                    _earnAmount = (((twoTime - lastTime_)/oneDay) * value_ * 65)/10000 + (((now - twoTime) / oneDay ) * value_ * (50))/10000;\\n                }else{\\n                    _earnAmount = (((now -  lastTime_  ) / oneDay ) * value_ * (50))/10000;\\n                } \\n        \\n        }   \\n        \\n        \\n        \\n    }\\n    \\n    function calcStepIncome(uint256 pid_,uint256 value_,uint8 dividendAccount_) public{\\n    \\n        \\n            uint256    spIncome = (value_*dividendAccount_)/100;\\n                if(plyr[RID][pid_].totalSettled \\u003e= playBiggertReward[RID][pid_]){\\n                    return;\\n                }\\n                if(plyr[RID][pid_].totalSettled+spIncome\\u003eplayBiggertReward[RID][pid_]){\\n                    spIncome = playBiggertReward[RID][pid_]-plyr[RID][pid_].totalSettled;\\n                }\\n                //if(mainPoolBalance[RID] \\u003e spIncome){\\n                    plyr[RID][pid_].stepIncome += spIncome;\\n                    //plyBalance[RID][pid_] += spIncome;\\n                    plyr[RID][pid_].totalSettled += spIncome;\\n                    mainPoolBalance[RID] -= spIncome;\\n                /*}else{\\n                    \\n                    plyr[RID][pid_].stepIncome += mainPoolBalance[RID];\\n                    //plyBalance[RID][pid_] += mainPoolBalance[RID];\\n                    plyr[RID][pid_].totalSettled += mainPoolBalance[RID];\\n                    mainPoolBalance[RID] =0;\\n                }*/\\n            \\n        \\n        \\n    }\\n    \\n    \\n    function startNewRount() internal {\\n        \\n        uint256 tisbalance;\\n        uint256 pid ;\\n        uint256 len = round[RID].rPlys;\\n        uint256 starti ;\\n        if(len \\u003e 100){\\n            starti = round[RID].rPlys-100;\\n        }\\n        for(uint256 i=starti ; i\\u003clen; i++){\\n            pid = round[RID].plyInList[len-i-1];\\n            luckPID[RID][pid] = true;\\n            tisbalance += plyr[RID][pid].ticketInCost *2;\\n            if(tisbalance\\u003e=insePoolBalance[RID]){\\n                //luckPID[RID][pid] = true;\\n                round[RID].fritInsePoint = len-i-1;\\n                round[RID].fritInseAmount = insePoolBalance[RID] - (tisbalance-plyr[RID][pid].ticketInCost *2);\\n                round[RID].totalInseAmount = insePoolBalance[RID];\\n                break;\\n            }else{\\n                \\n                if(i==len-1){\\n                    round[RID].fritInsePoint = starti;\\n                    round[RID].totalInseAmount = tisbalance ;\\n                }\\n            }\\n            \\n        }\\n        \\n        RID++;\\n        round[RID].rID = RID;\\n        round[RID].rStartTime = now;\\n        round[RID].rPlys = 0;\\n        mainPoolBalance[RID] = insePoolBalance[RID-1];\\n        mainPoolWithdrawBalance[RID] = insePoolBalance[RID-1];\\n        \\n        if(mainPoolLockBal[RID-1] \\u003e alreadyWithDrawBal[RID-1]   ){\\n            mainPoolBalance[RID] += mainPoolLockBal[RID-1]-alreadyWithDrawBal[RID-1];\\n            mainPoolWithdrawBalance[RID] += mainPoolLockBal[RID-1]-alreadyWithDrawBal[RID-1];\\n        }\\n        \\n        newRoundVIP();\\n    \\n    }\\n    \\n    function initVip(address ply_) internal{\\n       \\n        \\n        //lastPID = 18;\\n         \\n        //1\\n        if(ply_ == vip1Addr){initVIPInfo(vip1Addr,1,0);}\\n        if(ply_ == vip2Addr){initVIPInfo(vip2Addr,2,0);}\\n        if(ply_ == vip3Addr){initVIPInfo(vip3Addr,3,0);}\\n        if(ply_ == vip4Addr){initVIPInfo(vip4Addr,4,0); }\\n        if(ply_ == vip5Addr){initVIPInfo(vip5Addr,5,2);}\\n        \\n        if(ply_ == vip6Addr){initVIPInfo(vip6Addr,6,2);}\\n        if(ply_ == vip7Addr){initVIPInfo(vip7Addr,7,2);}\\n        if(ply_ == vip8Addr){initVIPInfo(vip8Addr,8,3);}\\n        if(ply_ == vip9Addr){initVIPInfo(vip9Addr,9,3);}\\n        if(ply_ == vip10Addr){initVIPInfo(vip10Addr,10,4);}\\n        if(ply_ == vip11Addr){initVIPInfo(vip11Addr,11,4);}\\n        \\n    \\n    }\\n    \\n    \\n    function initVIPInfo(address ply_,uint256 pid_ ,uint256 parentid_) internal{\\n        \\n        plyrID[ply_] = pid_;\\n        //plyr[RID][pid_].pID = pid_;\\n        plyrAddr[pid_] = ply_;\\n        plyr[RID][pid_].isActive = true;\\n        \\n        \\n        if(pid_ == 1){\\n            plyRShip[pid_].parentPID = 0;\\n            plyRShip[pid_].sonNumber = 3;\\n            plyRShip[pid_].sonPIDListMap[2] = true;\\n            plyRShip[pid_].sonPIDListMap[3] = true;\\n            plyRShip[pid_].sonPIDListMap[4] = true;\\n            //plyRShip[pid_].sonPIDList[1] = 2;\\n            //plyRShip[pid_].sonPIDList[2] = 3;\\n            //plyRShip[pid_].sonPIDList[3] = 4;\\n        }else if(pid_ == 2){\\n            plyRShip[pid_].parentPID = 1;\\n            plyRShip[pid_].sonNumber = 3;\\n            plyRShip[pid_].sonPIDListMap[5] = true;\\n            plyRShip[pid_].sonPIDListMap[6] = true;\\n            plyRShip[pid_].sonPIDListMap[7] = true;\\n            //plyRShip[pid_].sonPIDList[1] = 5;\\n            //plyRShip[pid_].sonPIDList[2] = 6;\\n            //plyRShip[pid_].sonPIDList[3] = 7;\\n        }else if(pid_ == 3 ){\\n            plyRShip[pid_].parentPID = 1;\\n            plyRShip[pid_].sonNumber = 2;\\n            plyRShip[pid_].sonPIDListMap[8] = true;\\n            plyRShip[pid_].sonPIDListMap[9] = true;\\n            //plyRShip[pid_].sonPIDList[1] = 8;\\n            //plyRShip[pid_].sonPIDList[2] = 9;\\n        }else if(pid_ == 4){\\n            plyRShip[pid_].parentPID = 1;\\n            plyRShip[pid_].sonNumber = 2;\\n            plyRShip[pid_].sonPIDListMap[10] = true;\\n            plyRShip[pid_].sonPIDListMap[11] = true;\\n            //plyRShip[pid_].sonPIDList[1] = 10;\\n            //plyRShip[pid_].sonPIDList[2] = 11;\\n        }else if(pid_ \\u003e=5 \\u0026\\u0026 pid_ \\u003c= 11){\\n           plyRShip[pid_].parentPID = parentid_; \\n           ambRewardMap[pid_] = true;\\n           ambassadorList[ply_] = true;\\n       \\n        }\\n        \\n        plyRShip[pid_].topPID = 1;\\n        \\n    }\\n    \\n    function newRoundVIP() internal{\\n        for(uint8 i=1;i\\u003c=11;i++){\\n            playBiggertReward[RID][i] = playBiggertReward[RID-1][i];\\n            plyr[RID][i].isActive = true;\\n            plyr[RID][i].ticketInCost = plyr[RID][i-1].ticketInCost;\\n            plyr[RID][i].lastCalcSITime = plyr[RID-1][i].lastCalcSITime;\\n        }   \\n    }\\n    \\n    \\n    \\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\nlibrary SafeMath {\\n \\n    function mul(uint256 a, uint256 b) \\n        internal \\n        pure \\n        returns (uint256 c) \\n    {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        require(c / a == b, \\\"SafeMath mul failed\\\");\\n        return c;\\n    }\\n\\n  \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return c;\\n    }\\n    \\n  \\n    function sub(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (uint256) \\n    {\\n        require(b \\u003c= a, \\\"SafeMath sub failed\\\");\\n        return a - b;\\n    }\\n\\n\\n    function add(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (uint256 c) \\n    {\\n        c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath add failed\\\");\\n        return c;\\n    }\\n    \\n\\n    function sqrt(uint256 x)\\n        internal\\n        pure\\n        returns (uint256 y) \\n    {\\n        uint256 z = ((add(x,1)) / 2);\\n        y = x;\\n        while (z \\u003c y) \\n        {\\n            y = z;\\n            z = ((add((x / z),z)) / 2);\\n        }\\n    }\\n    \\n    function sq(uint256 x)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (mul(x,x));\\n    }\\n\\n    function pwr(uint256 x, uint256 y)\\n        internal \\n        pure \\n        returns (uint256)\\n    {\\n        if (x==0)\\n            return (0);\\n        else if (y==0)\\n            return (1);\\n        else \\n        {\\n            uint256 z = x;\\n            for (uint256 i=1; i \\u003c y; i++)\\n                z = mul(z,x);\\n            return (z);\\n        }\\n    }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"plyrID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ambassadorList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ambRewardBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyRShip\",\"outputs\":[{\"name\":\"parentPID\",\"type\":\"uint256\"},{\"name\":\"topPID\",\"type\":\"uint256\"},{\"name\":\"sonNumber\",\"type\":\"uint256\"},{\"name\":\"bigPotSonPID\",\"type\":\"uint256\"},{\"name\":\"totalRecmdplys\",\"type\":\"uint256\"},{\"name\":\"totalRecmdAmount\",\"type\":\"uint256\"},{\"name\":\"nodeLevel\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"parentAddr\",\"type\":\"address\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckPID\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rid_\",\"type\":\"uint256\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"name\":\"totalInBalance_\",\"type\":\"uint256\"},{\"name\":\"totalDivBalance_\",\"type\":\"uint256\"},{\"name\":\"totalInsBalance_\",\"type\":\"uint256\"},{\"name\":\"totalPlayers_\",\"type\":\"uint256\"},{\"name\":\"totalDisADC_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"rID\",\"type\":\"uint256\"},{\"name\":\"rStartTime\",\"type\":\"uint256\"},{\"name\":\"rPlys\",\"type\":\"uint256\"},{\"name\":\"lastPID\",\"type\":\"uint256\"},{\"name\":\"totalInseAmount\",\"type\":\"uint256\"},{\"name\":\"fritInsePoint\",\"type\":\"uint256\"},{\"name\":\"fritInseAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr\",\"outputs\":[{\"name\":\"ticketInCost\",\"type\":\"uint256\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"totalSettled\",\"type\":\"uint256\"},{\"name\":\"staticIncome\",\"type\":\"uint256\"},{\"name\":\"lastCalcSITime\",\"type\":\"uint256\"},{\"name\":\"dynamicIncome\",\"type\":\"uint256\"},{\"name\":\"stepIncome\",\"type\":\"uint256\"},{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"isAlreadGetIns\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oneDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"alreadyWithDrawBal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playBiggertReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDistroyADC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mainPoolBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ply_\",\"type\":\"address\"},{\"name\":\"rid_\",\"type\":\"uint256\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"stIncome_\",\"type\":\"uint256\"},{\"name\":\"dtIncome_\",\"type\":\"uint256\"},{\"name\":\"stepIncome_\",\"type\":\"uint256\"},{\"name\":\"ambIncome_\",\"type\":\"uint256\"},{\"name\":\"doubV6Income_\",\"type\":\"uint256\"},{\"name\":\"totoalIncome_\",\"type\":\"uint256\"},{\"name\":\"withdrawAmount_\",\"type\":\"uint256\"},{\"name\":\"ticketIn_\",\"type\":\"uint256\"},{\"name\":\"canWithdrawAmount_\",\"type\":\"uint256\"},{\"name\":\"startTime_\",\"type\":\"uint256\"},{\"name\":\"liveRountAmount_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allInBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"insePoolBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mainPoolWithdrawBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid_\",\"type\":\"uint256\"},{\"name\":\"value_\",\"type\":\"uint256\"},{\"name\":\"dividendAccount_\",\"type\":\"uint8\"}],\"name\":\"calcStepIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mainPoolLockBal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ply_\",\"type\":\"address\"}],\"name\":\"setAmbFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settlementStatic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ply_\",\"type\":\"address\"}],\"name\":\"getPlayerRelship\",\"outputs\":[{\"name\":\"sonNumber_\",\"type\":\"uint256\"},{\"name\":\"allNumber_\",\"type\":\"uint256\"},{\"name\":\"curLevel_\",\"type\":\"uint256\"},{\"name\":\"isamb_\",\"type\":\"bool\"},{\"name\":\"bigPotBalance_\",\"type\":\"uint256\"},{\"name\":\"smailPotBalance_\",\"type\":\"uint256\"},{\"name\":\"isDoubleV6_\",\"type\":\"bool\"},{\"name\":\"distroyADC_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainPoolSTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRID\",\"outputs\":[{\"name\":\"rid_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyLucklyAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"addressM_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MainPool","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000049e298b95bda30e6518509187ff348e01117f404","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://00ed826875b4610194c1e09fd9d39b07cf2f4936717190ee5c5b18bf3ba564a7"}]}