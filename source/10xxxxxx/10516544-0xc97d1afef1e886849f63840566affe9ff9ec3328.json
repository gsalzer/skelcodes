{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// openzeppelin-solidity@2.3.0 from NPM\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ValidatorManagerContract {\r\n    using SafeMath for uint256;\r\n\r\n    /// \\frac{threshold_num}{threshold_denom} signatures are required for\r\n    /// validator approval to be granted\r\n    uint8 public threshold_num;\r\n    uint8 public threshold_denom;\r\n\r\n    /// The list of currently elected validators\r\n    address[] public validators;\r\n\r\n    /// The powers of the currently elected validators\r\n    uint64[] public powers;\r\n\r\n    /// The current sum of powers of currently elected validators\r\n    uint256 public totalPower;\r\n\r\n    /// Nonce tracking per to prevent replay attacks on signature\r\n    /// submission during validator rotation\r\n    uint256 public nonce;\r\n\r\n    /// Address of the loom token\r\n    address public loomAddress;\r\n\r\n    /// @notice  Event to log the change of the validator set.\r\n    /// @param  _validators The initial list of validators\r\n    /// @param  _powers The initial list of powers of each validator\r\n    event ValidatorSetChanged(address[] _validators, uint64[] _powers);\r\n\r\n    /// @notice View function that returns the powers array.\r\n    /// @dev    Solidity should have exposed a getter function since the variable is declared public.\r\n    /// @return powers The powers of the currently elected validators\r\n    function getPowers() public view returns(uint64[] memory) {\r\n        return powers;\r\n    }\r\n\r\n    /// @notice View function that returns the validators array.\r\n    /// @dev    Solidity should have exposed a getter function since the variable is declared public.\r\n    /// @return validators The currently elected validators\r\n    function getValidators() public view returns(address[] memory) {\r\n        return validators;\r\n    }\r\n\r\n    /// @notice Initialization of the system\r\n    /// @param  _validators The initial list of validators\r\n    /// @param  _powers The initial list of powers of each validator\r\n    /// @param  _threshold_num The numerator of the fraction of power that needs\r\n    ///         to sign for a call to be approved by a validator\r\n    /// @param  _threshold_denom The denominator of the fraction of power that needs\r\n    ///         to sign for a call to be approved by a validator\r\n    /// @param  _loomAddress The LOOM token address\r\n    constructor (\r\n        address[] memory _validators,\r\n        uint64[] memory _powers,\r\n        uint8 _threshold_num,\r\n        uint8 _threshold_denom,\r\n        address _loomAddress\r\n    ) \r\n        public \r\n    {\r\n        threshold_num = _threshold_num;\r\n        threshold_denom = _threshold_denom;\r\n        require(threshold_num <= threshold_denom && threshold_num > 0, \"Invalid threshold fraction.\");\r\n        loomAddress = _loomAddress;\r\n        _rotateValidators(_validators, _powers);\r\n    }\r\n\r\n    /// @notice Changes the loom token address. (requires signatures from at least `threshold_num/threshold_denom`\r\n    ///         validators, otherwise reverts)\r\n    /// @param  _loomAddress The new loom token address\r\n    /// @param  _signersIndexes Array of indexes of the validator's signatures based on\r\n    ///         the currently elected validators\r\n    /// @param  _v Array of `v` values from the validator signatures\r\n    /// @param  _r Array of `r` values from the validator signatures\r\n    /// @param  _s Array of `s` values from the validator signatures\r\n    function setLoom(\r\n        address _loomAddress,\r\n        uint256[] calldata _signersIndexes, // Based on: https://github.com/cosmos/peggy/blob/master/ethereum-contracts/contracts/Valset.sol#L75\r\n        uint8[] calldata _v,\r\n        bytes32[] calldata _r,\r\n        bytes32[] calldata _s\r\n    ) \r\n        external \r\n    {\r\n        // Hash the address of the contract along with the nonce and the\r\n        // updated loom token address.\r\n        bytes32 message = createMessage(\r\n            keccak256(abi.encodePacked(_loomAddress))\r\n        );\r\n\r\n        // Check if the signatures match the threshold set in the constructor\r\n        checkThreshold(message, _signersIndexes, _v, _r, _s);\r\n\r\n        // Update state\r\n        loomAddress = _loomAddress;\r\n        nonce++;\r\n    }\r\n\r\n    /// @notice Changes the threshold of signatures required to pass the\r\n    ///         validator signature check (requires signatures from at least `threshold_num/threshold_denom`\r\n    ///         validators, otherwise reverts)\r\n    /// @param  _num The new numerator\r\n    /// @param  _denom The new denominator\r\n    /// @param  _signersIndexes Array of indexes of the validator's signatures based on\r\n    ///         the currently elected validators\r\n    /// @param  _v Array of `v` values from the validator signatures\r\n    /// @param  _r Array of `r` values from the validator signatures\r\n    /// @param  _s Array of `s` values from the validator signatures\r\n    function setQuorum(\r\n        uint8 _num,\r\n        uint8 _denom,\r\n        uint256[] calldata _signersIndexes, // Based on: https://github.com/cosmos/peggy/blob/master/ethereum-contracts/contracts/Valset.sol#L75\r\n        uint8[] calldata _v,\r\n        bytes32[] calldata _r,\r\n        bytes32[] calldata _s\r\n    ) \r\n        external \r\n    {\r\n        require(_num <= _denom && _num > 0, \"Invalid threshold fraction\");\r\n\r\n        // Hash the address of the contract along with the nonce and the\r\n        // updated validator set.\r\n        bytes32 message = createMessage(\r\n            keccak256(abi.encodePacked(_num, _denom))\r\n        );\r\n\r\n        // Check if the signatures match the threshold set in the consutrctor\r\n        checkThreshold(message, _signersIndexes, _v, _r, _s);\r\n\r\n        threshold_num = _num;\r\n        threshold_denom = _denom;\r\n        nonce++;\r\n    }\r\n\r\n    /// @notice Updates the validator set with new validators and powers\r\n    ///         (requires signatures from at least `threshold_num/threshold_denom`\r\n    ///         validators, otherwise reverts)\r\n    /// @param  _newValidators The new validator set\r\n    /// @param  _newPowers The new list of powers corresponding to the validator set\r\n    /// @param  _signersIndexes Array of indexes of the validator's signatures based on\r\n    ///         the currently elected validators\r\n    /// @param  _v Array of `v` values from the validator signatures\r\n    /// @param  _r Array of `r` values from the validator signatures\r\n    /// @param  _s Array of `s` values from the validator signatures\r\n    function rotateValidators(\r\n        address[] calldata _newValidators, \r\n        uint64[] calldata  _newPowers,\r\n        uint256[] calldata _signersIndexes, // Based on: https://github.com/cosmos/peggy/blob/master/ethereum-contracts/contracts/Valset.sol#L75\r\n        uint8[] calldata _v,\r\n        bytes32[] calldata _r,\r\n        bytes32[] calldata _s\r\n    ) \r\n        external \r\n    {\r\n        // Hash the address of the contract along with the nonce and the\r\n        // updated validator set and powers.\r\n        bytes32 message = createMessage(\r\n            keccak256(abi.encodePacked(_newValidators,_newPowers))\r\n        );\r\n\r\n        // Check if the signatures match the threshold set in the consutrctor\r\n        checkThreshold(message, _signersIndexes, _v, _r, _s);\r\n\r\n        // update validator set\r\n        _rotateValidators(_newValidators, _newPowers);\r\n        nonce++;\r\n    }\r\n\r\n\r\n    /// @notice Checks if the provided signature is valid on message by the\r\n    ///         validator corresponding to `signersIndex`. Reverts if check fails\r\n    /// @param  _message The messsage hash that was signed\r\n    /// @param  _signersIndex The validator's index in the `validators` array\r\n    /// @param  _v The v value of the validator's signature\r\n    /// @param  _r The r value of the validator's signature\r\n    /// @param  _s The s value of the validator's signature\r\n    function signedByValidator(\r\n        bytes32 _message,\r\n        uint256 _signersIndex,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        public \r\n        view\r\n    {\r\n        // prevent replay attacks by adding the nonce in the sig\r\n        // if a validator signs an invalid nonce,\r\n        // it won't pass the signature verification\r\n        // since the nonce in the hash is stored in the contract\r\n        address signer = ecrecover(_message, _v, _r, _s);\r\n        require(validators[_signersIndex] == signer, \"Message not signed by a validator\");\r\n    }\r\n\r\n    /// @notice Completes if the message being passed was signed by the required\r\n    ///         threshold of validators, otherwise reverts\r\n    /// @param  _signersIndexes Array of indexes of the validator's signatures based on\r\n    ///         the currently elected validators\r\n    /// @param  _v Array of `v` values from the validator signatures\r\n    /// @param  _r Array of `r` values from the validator signatures\r\n    /// @param  _s Array of `s` values from the validator signatures\r\n    function checkThreshold(bytes32 _message, uint256[] memory _signersIndexes, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s) public view {\r\n        uint256 sig_length = _v.length;\r\n\r\n        require(sig_length <= validators.length,\r\n                \"checkThreshold:: Cannot submit more signatures than existing validators\"\r\n        );\r\n\r\n        require(sig_length > 0 && sig_length == _r.length && _r.length == _s.length && sig_length == _signersIndexes.length,\r\n                \"checkThreshold:: Incorrect number of params\"\r\n        );\r\n\r\n        // Signed message prefix\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _message));\r\n\r\n        // Get total voted power while making sure all signatures submitted\r\n        // were by validators without duplication\r\n        uint256 votedPower;\r\n        for (uint256 i = 0; i < sig_length; i++) {\r\n            if (i > 0) {\r\n                require(_signersIndexes[i] > _signersIndexes[i-1]);\r\n            }\r\n\r\n            // Skip malleable signatures / maybe better to revert instead of skipping?\r\n            if (uint256(_s[i]) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n                continue;\r\n            }\r\n            address signer = ecrecover(hash, _v[i], _r[i], _s[i]);\r\n            require(signer == validators[_signersIndexes[i]], \"checkThreshold:: Recovered address is not a validator\");\r\n\r\n            votedPower = votedPower.add(powers[_signersIndexes[i]]);\r\n        }\r\n\r\n        require(votedPower * threshold_denom >= totalPower *\r\n                threshold_num, \"checkThreshold:: Not enough power from validators\");\r\n    }\r\n\r\n\r\n\r\n    /// @notice Internal method that updates the state with the new validator\r\n    ///         set and powers, as well as the new total power\r\n    /// @param  _validators The initial list of validators\r\n    /// @param  _powers The initial list of powers of each validator\r\n    function _rotateValidators(address[] memory _validators, uint64[] memory _powers) internal {\r\n        uint256 val_length = _validators.length;\r\n\r\n        require(val_length == _powers.length, \"_rotateValidators: Array lengths do not match!\");\r\n\r\n        require(val_length > 0, \"Must provide more than 0 validators\");\r\n\r\n        uint256 _totalPower = 0;\r\n        for (uint256 i = 0; i < val_length; i++) {\r\n            _totalPower = _totalPower.add(_powers[i]);\r\n        }\r\n\r\n        // Set total power\r\n        totalPower = _totalPower;\r\n\r\n        // Set validators and their powers\r\n        validators = _validators;\r\n        powers = _powers;\r\n\r\n        emit ValidatorSetChanged(_validators, _powers);\r\n    }\r\n\r\n    /// @notice Creates the message hash that includes replay protection and\r\n    ///         binds the hash to this contract only.\r\n    /// @param  hash The hash of the message being signed\r\n    /// @return A hash on the hash of the message\r\n    function createMessage(bytes32 hash)\r\n    private\r\n    view returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                nonce,\r\n                hash\r\n            )\r\n        );\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint8\"},{\"name\":\"_denom\",\"type\":\"uint8\"},{\"name\":\"_signersIndexes\",\"type\":\"uint256[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"setQuorum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_signersIndexes\",\"type\":\"uint256[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"checkThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loomAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"powers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold_denom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_loomAddress\",\"type\":\"address\"},{\"name\":\"_signersIndexes\",\"type\":\"uint256[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"setLoom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_signersIndex\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"signedByValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold_num\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newValidators\",\"type\":\"address[]\"},{\"name\":\"_newPowers\",\"type\":\"uint64[]\"},{\"name\":\"_signersIndexes\",\"type\":\"uint256[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"rotateValidators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPowers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_validators\",\"type\":\"address[]\"},{\"name\":\"_powers\",\"type\":\"uint64[]\"},{\"name\":\"_threshold_num\",\"type\":\"uint8\"},{\"name\":\"_threshold_denom\",\"type\":\"uint8\"},{\"name\":\"_loomAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_validators\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_powers\",\"type\":\"uint64[]\"}],\"name\":\"ValidatorSetChanged\",\"type\":\"event\"}]","ContractName":"ValidatorManagerContract","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000e25b0bba01dc5630312b6a21927e578061a13f550000000000000000000000000000000000000000000000000000000000000001000000000000000000000000dfda76ddd9949b8cd1b1687bfee7bd2c2df4059800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000064","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6286419c7702cef29d1438a915c055a014f23adb79fa8a0f28452b406b399f98"}]}