{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.7;\r\n\r\ncontract JustHodlIt {\r\n\r\n    uint256 public MINIMUM_INVEST = 0.1 ether;\r\n    uint256 public REFERRAL_PERCENT = 3;\r\n    uint256 public CASHBACK_PERCENT = 2;\r\n\r\n    uint256 internal _totalBank;\r\n    uint256 internal _profitPerShare;\r\n    uint256 internal _magnitude = 1e18;\r\n\r\n    address[] accounts;\r\n    mapping (address => User) public users;\r\n    struct User {\r\n        uint256 deposit;\r\n        address payable referrer;\r\n        uint256 lastActivity;\r\n        uint256 payoutsTo;\r\n    }\r\n\r\n    address payable defaultReferrer;\r\n    address public owner;\r\n\r\n    event OnInvest(address indexed account, uint256 value);\r\n    event OnReinvest(address indexed account, uint256 value);\r\n    event OnWithdraw(address indexed account, uint256 value);\r\n    event OnRefBonus(address indexed account, address indexed referral, uint256 value);\r\n    event OnCashback(address indexed account, uint256 value);\r\n    event OnLostFunds(address indexed account, uint256 value);\r\n\r\n    constructor(address payable defaultReferrerAddr) public {\r\n        require(!_isContract(defaultReferrerAddr));\r\n        defaultReferrer = defaultReferrerAddr;\r\n    }\r\n\r\n    fallback() external payable {\r\n        if (msg.value >= MINIMUM_INVEST) {\r\n            invest(_bytesToAddress(msg.data));\r\n        } else {\r\n            withdrawAll();\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        if (msg.value >= MINIMUM_INVEST) {\r\n            invest(address(0));\r\n        } else {\r\n            withdrawDividends();\r\n        }\r\n    }\r\n\r\n    function invest(address payable referrer) public payable {\r\n        require(msg.value >= MINIMUM_INVEST, \"Investment must be more or equal to the minimum\");\r\n\r\n        _invest(msg.sender, referrer, msg.value);\r\n    }\r\n\r\n    function _invest(address payable account, address payable referrer, uint256 value) internal {\r\n        User storage user = users[account];\r\n\r\n        uint256 dividends = user.referrer == address(0) ? (value * 5 / 100) : (value * 7 / 100);\r\n        if (_totalBank > 0) {\r\n            _profitPerShare += dividends * _magnitude / _totalBank;\r\n            user.payoutsTo += _profitPerShare * value;\r\n        } else {\r\n            _profitPerShare += dividends * _magnitude / value;\r\n        }\r\n\r\n        _totalBank += value;\r\n        user.deposit += value;\r\n        user.lastActivity = block.timestamp;\r\n\r\n        emit OnInvest(account, value);\r\n\r\n        if (user.referrer == address(0)) {\r\n            address payable recipient;\r\n            if (users[referrer].referrer != address(0)) {\r\n                user.referrer = referrer;\r\n                recipient = account;\r\n            } else {\r\n                user.referrer = defaultReferrer;\r\n                recipient = defaultReferrer;\r\n            }\r\n            accounts.push(msg.sender);\r\n            (recipient.send(value * CASHBACK_PERCENT / 100));\r\n            emit OnCashback(recipient, value * CASHBACK_PERCENT / 100);\r\n\t\t}\r\n\r\n        (user.referrer.send(value * REFERRAL_PERCENT / 100));\r\n        emit OnRefBonus(user.referrer, account, value * REFERRAL_PERCENT / 100);\r\n    }\r\n\r\n    function withdrawAll() public {\r\n        User storage user = users[msg.sender];\r\n        uint256 deposit = user.deposit;\r\n        uint256 dividends = getDividends(msg.sender);\r\n\r\n        require(deposit > 0, \"User has no deposit\");\r\n\r\n        user.payoutsTo += (deposit + dividends) * _magnitude;\r\n        _totalBank -= user.deposit;\r\n        if (_totalBank > 0) {\r\n            _profitPerShare += (deposit * 20 / 100) * _magnitude / _totalBank;\r\n            deposit -= deposit * (20 + 10) / 100;\r\n        } else {\r\n            _profitPerShare = 0;\r\n            deposit = 0;\r\n            dividends = address(this).balance;\r\n        }\r\n        user.deposit = 0;\r\n        user.payoutsTo = 0;\r\n        user.lastActivity = block.timestamp;\r\n\r\n        msg.sender.transfer(deposit + dividends);\r\n\r\n        emit OnWithdraw(msg.sender, deposit + dividends);\r\n    }\r\n\r\n    function withdrawDividends() public {\r\n        User storage user = users[msg.sender];\r\n        uint256 payout = getDividends(msg.sender);\r\n\r\n        require(payout > 0, \"User has no dividends\");\r\n\r\n        user.payoutsTo += payout * _magnitude;\r\n        user.lastActivity = block.timestamp;\r\n\r\n        msg.sender.transfer(payout);\r\n\r\n        emit OnWithdraw(msg.sender, payout);\r\n    }\r\n\r\n    function reinvest() public {\r\n        uint256 payout = getDividends(msg.sender);\r\n\r\n        require(payout > 0, \"User has no dividends\");\r\n\r\n        users[msg.sender].payoutsTo += payout * _magnitude;\r\n\r\n        _invest(msg.sender, address(0), payout);\r\n\r\n        emit OnReinvest(msg.sender, payout);\r\n    }\r\n\r\n    function distributeLostFunds(address[] memory lostAccounts) public {\r\n        for (uint256 i = 0; i < lostAccounts.length; i++) {\r\n            if (users[lostAccounts[i]].deposit > 0 && block.timestamp - users[lostAccounts[i]].lastActivity >= 365 days) {\r\n                uint256 lostFunds = users[lostAccounts[i]].deposit * 90 / 100 + getDividends(lostAccounts[i]);\r\n                _totalBank -= users[lostAccounts[i]].deposit;\r\n                users[lostAccounts[i]].deposit = 0;\r\n                users[lostAccounts[i]].payoutsTo = 0;\r\n                _profitPerShare += lostFunds * _magnitude / _totalBank;\r\n                emit OnLostFunds(lostAccounts[i], lostFunds);\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkAccounts(uint256 startIndex, uint256 amount) public view returns(address[] memory) {\r\n        require(startIndex + amount <= accounts.length);\r\n\r\n        uint256[] memory indexes = new uint256[](startIndex + amount);\r\n        uint256 count;\r\n\r\n        for (uint256 i = startIndex; i < amount; i++) {\r\n            if (users[accounts[i]].deposit > 0 && block.timestamp - users[accounts[i]].lastActivity >= 365 days) {\r\n                indexes[count] = i;\r\n                count++;\r\n            }\r\n        }\r\n\r\n        address[] memory lost = new address[](count);\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            lost[i] = accounts[indexes[i]];\r\n        }\r\n\r\n        return lost;\r\n    }\r\n\r\n    function amountOfUsers() public view returns(uint256) {\r\n        return accounts.length;\r\n    }\r\n\r\n    function contractBalance() public view returns(uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getAll(address account) public view returns(uint256) {\r\n        if (users[account].deposit < _totalBank) {\r\n            return (users[account].deposit * 70 / 100) + getDividends(account);\r\n        } else {\r\n            return address(this).balance;\r\n        }\r\n    }\r\n\r\n    function getDividends(address account) public view returns(uint256) {\r\n        return (_profitPerShare * users[account].deposit - users[account].payoutsTo) / _magnitude;\r\n    }\r\n\r\n    function _bytesToAddress(bytes memory source) internal pure returns(address payable parsedreferrer) {\r\n        assembly {\r\n            parsedreferrer := mload(add(source,0x14))\r\n        }\r\n    }\r\n\r\n    function _isContract(address account) internal view returns(bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"defaultReferrerAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OnCashback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OnInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OnLostFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OnRefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OnReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OnWithdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"CASHBACK_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountOfUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"checkAccounts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"lostAccounts\",\"type\":\"address[]\"}],\"name\":\"distributeLostFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastActivity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutsTo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"JustHodlIt","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000263a17c25c3927079926445d34f0f37af1e2095e","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dd85d30a5b9bc89a8ca7db44d636ca200937226ba0425f161bcfeab4b89a31e3"}]}