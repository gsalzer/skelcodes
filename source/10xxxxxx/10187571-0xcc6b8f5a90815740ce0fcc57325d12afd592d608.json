{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/math/SafeMath.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/// @title SafeMath\r\n/// @dev Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n    /// @dev Add two integers\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /// @dev Subtract two integers\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Multiply tow integers\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        assert(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /// @dev Floor divide two integers\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return a / b;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ownership/Ownable.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/// @title Ownable\r\n/// @dev Provide a simple access control with a single authority: the owner\r\ncontract Ownable {\r\n\r\n    // Ethereum address of current owner\r\n    address public owner;\r\n\r\n    // Ethereum address of the next owner\r\n    // (has to claim ownership first to become effective owner)\r\n    address public newOwner;\r\n\r\n    // @dev Log event on ownership transferred\r\n    // @param previousOwner Ethereum address of previous owner\r\n    // @param newOwner Ethereum address of new owner\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev Forbid call by anyone but owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Restricted to owner\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Deployer account becomes initial owner\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev  Transfer ownership to a new Ethereum account (safe method)\r\n    ///       Note: the new owner has to claim his ownership to become effective owner.\r\n    /// @param _newOwner  Ethereum address to transfer ownership to\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0x0), \"New owner is zero\");\r\n\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /// @dev  Transfer ownership to a new Ethereum account (unsafe method)\r\n    ///       Note: It's strongly recommended to use the safe variant via transferOwnership\r\n    ///             and claimOwnership, to prevent accidental transfers to a wrong address.\r\n    /// @param _newOwner  Ethereum address to transfer ownership to\r\n    function transferOwnershipUnsafe(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0x0), \"New owner is zero\");\r\n\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /// @dev  Become effective owner (if dedicated so by previous owner)\r\n    function claimOwnership() public {\r\n        require(msg.sender == newOwner, \"Restricted to new owner\");\r\n\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    /// @dev  Transfer ownership (internal method)\r\n    /// @param _newOwner  Ethereum address to transfer ownership to\r\n    function _transferOwnership(address _newOwner) private {\r\n        if (_newOwner != owner) {\r\n            emit OwnershipTransferred(owner, _newOwner);\r\n\r\n            owner = _newOwner;\r\n        }\r\n        newOwner = address(0x0);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/whitelist/Whitelist.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/// @title Whitelist\r\n/// @author STOKR\r\ncontract Whitelist is Ownable {\r\n\r\n    // Set of admins\r\n    mapping(address => bool) public admins;\r\n\r\n    // Set of Whitelisted addresses\r\n    mapping(address => bool) public isWhitelisted;\r\n\r\n    /// @dev Log entry on admin added to set\r\n    /// @param admin An Ethereum address\r\n    event AdminAdded(address indexed admin);\r\n\r\n    /// @dev Log entry on admin removed from set\r\n    /// @param admin An Ethereum address\r\n    event AdminRemoved(address indexed admin);\r\n\r\n    /// @dev Log entry on investor added set\r\n    /// @param admin An Ethereum address\r\n    /// @param investor An Ethereum address\r\n    event InvestorAdded(address indexed admin, address indexed investor);\r\n\r\n    /// @dev Log entry on investor removed from set\r\n    /// @param admin An Ethereum address\r\n    /// @param investor An Ethereum address\r\n    event InvestorRemoved(address indexed admin, address indexed investor);\r\n\r\n    /// @dev Only admin\r\n    modifier onlyAdmin() {\r\n        require(admins[msg.sender], \"Restricted to whitelist admin\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Add admin to set\r\n    /// @param _admin An Ethereum address\r\n    function addAdmin(address _admin) public onlyOwner {\r\n        require(_admin != address(0x0), \"Whitelist admin is zero\");\r\n\r\n        if (!admins[_admin]) {\r\n            admins[_admin] = true;\r\n\r\n            emit AdminAdded(_admin);\r\n        }\r\n    }\r\n\r\n    /// @dev Remove admin from set\r\n    /// @param _admin An Ethereum address\r\n    function removeAdmin(address _admin) public onlyOwner {\r\n        require(_admin != address(0x0), \"Whitelist admin is zero\");  // Necessary?\r\n\r\n        if (admins[_admin]) {\r\n            admins[_admin] = false;\r\n\r\n            emit AdminRemoved(_admin);\r\n        }\r\n    }\r\n\r\n    /// @dev Add investor to set of whitelisted addresses\r\n    /// @param _investors A list where each entry is an Ethereum address\r\n    function addToWhitelist(address[] calldata _investors) external onlyAdmin {\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            if (!isWhitelisted[_investors[i]]) {\r\n                isWhitelisted[_investors[i]] = true;\r\n\r\n                emit InvestorAdded(msg.sender, _investors[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Remove investor from set of whitelisted addresses\r\n    /// @param _investors A list where each entry is an Ethereum address\r\n    function removeFromWhitelist(address[] calldata _investors) external onlyAdmin {\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            if (isWhitelisted[_investors[i]]) {\r\n                isWhitelisted[_investors[i]] = false;\r\n\r\n                emit InvestorRemoved(msg.sender, _investors[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/whitelist/Whitelisted.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n/// @title Whitelisted\r\n/// @author STOKR\r\ncontract Whitelisted is Ownable {\r\n\r\n    Whitelist public whitelist;\r\n\r\n    /// @dev  Log entry on change of whitelist contract instance\r\n    /// @param previous  Ethereum address of previous whitelist\r\n    /// @param current   Ethereum address of new whitelist\r\n    event WhitelistChange(address indexed previous, address indexed current);\r\n\r\n    /// @dev Ensure only whitelisted addresses can call\r\n    modifier onlyWhitelisted(address _address) {\r\n        require(whitelist.isWhitelisted(_address), \"Address is not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor\r\n    /// @param _whitelist address of whitelist contract\r\n    constructor(Whitelist _whitelist) public {\r\n        setWhitelist(_whitelist);\r\n    }\r\n\r\n    /// @dev Set the address of whitelist\r\n    /// @param _newWhitelist An Ethereum address\r\n    function setWhitelist(Whitelist _newWhitelist) public onlyOwner {\r\n        require(address(_newWhitelist) != address(0x0), \"Whitelist address is zero\");\r\n\r\n        if (address(_newWhitelist) != address(whitelist)) {\r\n            emit WhitelistChange(address(whitelist), address(_newWhitelist));\r\n\r\n            whitelist = Whitelist(_newWhitelist);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/ERC20.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/// @title ERC20 interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address _owner) external view returns (uint);\r\n    function allowance(address _owner, address _spender) external view returns (uint);\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n    function transfer(address _to, uint _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/token/ProfitSharing.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n/// @title ProfitSharing\r\n/// @author STOKR\r\ncontract ProfitSharing is Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n\r\n    // An InvestorAccount object keeps track of the investor's\r\n    // - balance: amount of tokens he/she holds (always up-to-date)\r\n    // - profitShare: amount of wei this token owed him/her at the last update\r\n    // - lastTotalProfits: determines when his/her profitShare was updated\r\n    // Note, this construction requires:\r\n    // - totalProfits to never decrease\r\n    // - totalSupply to be fixed\r\n    // - profitShare of all involved parties to get updated prior to any token transfer\r\n    // - lastTotalProfits to be set to current totalProfits upon profitShare update\r\n    struct InvestorAccount {\r\n        uint balance;           // token balance\r\n        uint lastTotalProfits;  // totalProfits [wei] at the time of last profit share update\r\n        uint profitShare;       // profit share [wei] of last update\r\n    }\r\n\r\n\r\n    // Investor account database\r\n    mapping(address => InvestorAccount) public accounts;\r\n\r\n    // Authority who is allowed to deposit profits [wei] on this\r\n    address public profitDepositor;\r\n\r\n    // Authority who is allowed to distribute profit shares [wei] to investors\r\n    // (so, that they don't need to withdraw it by themselves)\r\n    address public profitDistributor;\r\n\r\n    // Amount of total profits [wei] stored to this token\r\n    // In contrast to the wei balance (which may be reduced due to profit share withdrawal)\r\n    // this value will never decrease\r\n    uint public totalProfits;\r\n\r\n    // As long as the total supply isn't fixed, i.e. new tokens can appear out of thin air,\r\n    // the investors' profit shares aren't determined\r\n    bool public totalSupplyIsFixed;\r\n\r\n    // Total amount of tokens\r\n    uint internal totalSupply_;\r\n\r\n\r\n    /// @dev  Log entry on change of profit deposit authority\r\n    /// @param previous  Ethereum address of previous profit depositor\r\n    /// @param current   Ethereum address of new profit depositor\r\n    event ProfitDepositorChange(\r\n        address indexed previous,\r\n        address indexed current\r\n    );\r\n\r\n    /// @dev  Log entry on change of profit distribution authority\r\n    /// @param previous  Ethereum address of previous profit distributor\r\n    /// @param current   Ethereum address of new profit distributor\r\n    event ProfitDistributorChange(\r\n        address indexed previous,\r\n        address indexed current\r\n    );\r\n\r\n    /// @dev Log entry on profit deposit\r\n    /// @param depositor Profit depositor's address\r\n    /// @param amount Deposited profits in wei\r\n    event ProfitDeposit(\r\n        address indexed depositor,\r\n        uint amount\r\n    );\r\n\r\n    /// @dev Log entry on profit share update\r\n    /// @param investor Investor's address\r\n    /// @param amount New wei amount the token owes the investor\r\n    event ProfitShareUpdate(\r\n        address indexed investor,\r\n        uint amount\r\n    );\r\n\r\n    /// @dev Log entry on profit withdrawal\r\n    /// @param investor Investor's address\r\n    /// @param amount Wei amount the investor withdrew from this token\r\n    event ProfitShareWithdrawal(\r\n        address indexed investor,\r\n        address indexed beneficiary,\r\n        uint amount\r\n    );\r\n\r\n\r\n    /// @dev Restrict operation to profit deposit authority only\r\n    modifier onlyProfitDepositor() {\r\n        require(msg.sender == profitDepositor, \"Restricted to profit depositor\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Restrict operation to profit distribution authority only\r\n    modifier onlyProfitDistributor() {\r\n        require(msg.sender == profitDistributor, \"Restricted to profit distributor\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Restrict operation to when total supply doesn't change anymore\r\n    modifier onlyWhenTotalSupplyIsFixed() {\r\n        require(totalSupplyIsFixed, \"Total supply may change\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor\r\n    /// @param _profitDepositor Profit deposit authority\r\n    constructor(address _profitDepositor, address _profitDistributor) public {\r\n        setProfitDepositor(_profitDepositor);\r\n        setProfitDistributor(_profitDistributor);\r\n    }\r\n\r\n    /// @dev Profit deposit if possible via fallback function\r\n    function () external payable {\r\n        require(msg.data.length == 0, \"Fallback call with data\");\r\n\r\n        depositProfit();\r\n    }\r\n\r\n    /// @dev Change profit depositor\r\n    /// @param _newProfitDepositor An Ethereum address\r\n    function setProfitDepositor(address _newProfitDepositor) public onlyOwner {\r\n        require(_newProfitDepositor != address(0x0), \"New profit depositor is zero\");\r\n\r\n        if (_newProfitDepositor != profitDepositor) {\r\n            emit ProfitDepositorChange(profitDepositor, _newProfitDepositor);\r\n\r\n            profitDepositor = _newProfitDepositor;\r\n        }\r\n    }\r\n\r\n    /// @dev Change profit distributor\r\n    /// @param _newProfitDistributor An Ethereum address\r\n    function setProfitDistributor(address _newProfitDistributor) public onlyOwner {\r\n        require(_newProfitDistributor != address(0x0), \"New profit distributor is zero\");\r\n\r\n        if (_newProfitDistributor != profitDistributor) {\r\n            emit ProfitDistributorChange(profitDistributor, _newProfitDistributor);\r\n\r\n            profitDistributor = _newProfitDistributor;\r\n        }\r\n    }\r\n\r\n    /// @dev Deposit profit\r\n    function depositProfit() public payable onlyProfitDepositor onlyWhenTotalSupplyIsFixed {\r\n        require(totalSupply_ > 0, \"Total supply is zero\");\r\n\r\n        totalProfits = totalProfits.add(msg.value);\r\n\r\n        emit ProfitDeposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev Profit share owing\r\n    /// @param _investor An Ethereum address\r\n    /// @return A positive number\r\n    function profitShareOwing(address _investor) public view returns (uint) {\r\n        if (!totalSupplyIsFixed || totalSupply_ == 0) {\r\n            return 0;\r\n        }\r\n\r\n        InvestorAccount memory account = accounts[_investor];\r\n\r\n        return totalProfits.sub(account.lastTotalProfits)\r\n                           .mul(account.balance)\r\n                           .div(totalSupply_)\r\n                           .add(account.profitShare);\r\n    }\r\n\r\n    /// @dev Update profit share\r\n    /// @param _investor An Ethereum address\r\n    function updateProfitShare(address _investor) public onlyWhenTotalSupplyIsFixed {\r\n        uint newProfitShare = profitShareOwing(_investor);\r\n\r\n        accounts[_investor].lastTotalProfits = totalProfits;\r\n        accounts[_investor].profitShare = newProfitShare;\r\n\r\n        emit ProfitShareUpdate(_investor, newProfitShare);\r\n    }\r\n\r\n    /// @dev Withdraw profit share\r\n    function withdrawProfitShare() public {\r\n        _withdrawProfitShare(msg.sender, msg.sender);\r\n    }\r\n\r\n    function withdrawProfitShareTo(address payable _beneficiary) public {\r\n        _withdrawProfitShare(msg.sender, _beneficiary);\r\n    }\r\n\r\n    /// @dev Withdraw profit share\r\n    function withdrawProfitShares(address payable[] calldata _investors)\r\n        external\r\n        onlyProfitDistributor\r\n    {\r\n        for (uint i = 0; i < _investors.length; ++i) {\r\n            _withdrawProfitShare(_investors[i], _investors[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Withdraw profit share\r\n    function _withdrawProfitShare(address _investor, address payable _beneficiary) internal {\r\n        updateProfitShare(_investor);\r\n\r\n        uint withdrawnProfitShare = accounts[_investor].profitShare;\r\n\r\n        accounts[_investor].profitShare = 0;\r\n        _beneficiary.transfer(withdrawnProfitShare);\r\n\r\n        emit ProfitShareWithdrawal(_investor, _beneficiary, withdrawnProfitShare);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/MintableToken.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n/// @title MintableToken\r\n/// @author STOKR\r\n/// @dev Extension of the ERC20 compliant ProfitSharing Token\r\n///      that allows the creation of tokens via minting for a\r\n///      limited time period (until minting gets finished).\r\ncontract MintableToken is ERC20, ProfitSharing, Whitelisted {\r\n\r\n    address public minter;\r\n    uint public numberOfInvestors = 0;\r\n\r\n    /// @dev Log entry on mint\r\n    /// @param to Beneficiary who received the newly minted tokens\r\n    /// @param amount The amount of minted token units\r\n    event Minted(address indexed to, uint amount);\r\n\r\n    /// @dev Log entry on mint finished\r\n    event MintFinished();\r\n\r\n    /// @dev Restrict an operation to be callable only by the minter\r\n    modifier onlyMinter() {\r\n        require(msg.sender == minter, \"Restricted to minter\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Restrict an operation to be executable only while minting was not finished\r\n    modifier canMint() {\r\n        require(!totalSupplyIsFixed, \"Total supply has been fixed\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Set minter authority\r\n    /// @param _minter Ethereum address of minter authority\r\n    function setMinter(address _minter) public onlyOwner {\r\n        require(minter == address(0x0), \"Minter has already been set\");\r\n        require(_minter != address(0x0), \"Minter is zero\");\r\n\r\n        minter = _minter;\r\n    }\r\n\r\n    /// @dev Mint tokens, i.e. create tokens out of thin air\r\n    /// @param _to Beneficiary who will receive the newly minted tokens\r\n    /// @param _amount The amount of minted token units\r\n    function mint(address _to, uint _amount) public onlyMinter canMint onlyWhitelisted(_to) {\r\n        if (accounts[_to].balance == 0) {\r\n            numberOfInvestors++;\r\n        }\r\n\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        accounts[_to].balance = accounts[_to].balance.add(_amount);\r\n\r\n        emit Minted(_to, _amount);\r\n        emit Transfer(address(0x0), _to, _amount);\r\n    }\r\n\r\n    /// @dev Finish minting -- this should be irreversible\r\n    function finishMinting() public onlyMinter canMint {\r\n        totalSupplyIsFixed = true;\r\n\r\n        emit MintFinished();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/crowdsale/RateSourceInterface.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/// @title RateSource\r\n/// @author STOKR\r\ninterface RateSource {\r\n\r\n    /// @dev The current price of an Ether in EUR cents\r\n    /// @return Current ether rate\r\n    function etherRate() external view returns (uint);\r\n\r\n}\r\n\r\n// File: contracts/crowdsale/MintingCrowdsale.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title MintingCrowdsale\r\n/// @author STOKR\r\ncontract MintingCrowdsale is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    // Maximum Time of offering period after extension\r\n    uint constant MAXOFFERINGPERIOD = 183 days;\r\n\r\n    // Ether rate oracle contract providing the price of an Ether in EUR cents\r\n    RateSource public rateSource;\r\n\r\n    // The token to be sold\r\n    // In the following, the term \"token unit\" always refers to the smallest\r\n    // and non-divisible quantum. Thus, token unit amounts are always integers.\r\n    // One token is expected to consist of 10^18 token units.\r\n    MintableToken public token;\r\n\r\n    // Token amounts in token units\r\n    // The public and the private sale are both capped (i.e. two distinct token pools)\r\n    // The tokenRemaining variables keep track of how many token units are available\r\n    // for the respective type of sale\r\n    uint public tokenCapOfPublicSale;\r\n    uint public tokenCapOfPrivateSale;\r\n    uint public tokenRemainingForPublicSale;\r\n    uint public tokenRemainingForPrivateSale;\r\n\r\n    // Prices are in Euro cents (i.e. 1/100 EUR)\r\n    uint public tokenPrice;\r\n\r\n    // The minimum amount of tokens a purchaser has to buy via one transaction\r\n    uint public tokenPurchaseMinimum;\r\n\r\n    // The maximum total amount of tokens a purchaser may buy during start phase\r\n    uint public tokenPurchaseLimit;\r\n\r\n    // Total token purchased by investor (while purchase amount is limited)\r\n    mapping(address => uint) public tokenPurchased;\r\n\r\n    // Public sale period\r\n    uint public openingTime;\r\n    uint public closingTime;\r\n    uint public limitEndTime;\r\n\r\n    // Ethereum address where invested funds will be transferred to\r\n    address payable public companyWallet;\r\n\r\n    // Amount and receiver of reserved tokens\r\n    uint public tokenReservePerMill;\r\n    address public reserveAccount;\r\n\r\n    // Wether this crowdsale was finalized or not\r\n    bool public isFinalized = false;\r\n\r\n\r\n    /// @dev Log entry upon token distribution event\r\n    /// @param beneficiary Ethereum address of token recipient\r\n    /// @param amount Number of token units\r\n    /// @param isPublicSale Whether the distribution was via public sale\r\n    event TokenDistribution(address indexed beneficiary, uint amount, bool isPublicSale);\r\n\r\n    /// @dev Log entry upon token purchase event\r\n    /// @param buyer Ethereum address of token purchaser\r\n    /// @param value Worth in wei of purchased token amount\r\n    /// @param amount Number of token units\r\n    event TokenPurchase(address indexed buyer, uint value, uint amount);\r\n\r\n    /// @dev Log entry upon rate change event\r\n    /// @param previous Previous closing time of sale\r\n    /// @param current Current closing time of sale\r\n    event ClosingTimeChange(uint previous, uint current);\r\n\r\n    /// @dev Log entry upon finalization event\r\n    event Finalization();\r\n\r\n\r\n    /// @dev Constructor\r\n    /// @param _rateSource Ether rate oracle contract\r\n    /// @param _token The token to be sold\r\n    /// @param _tokenCapOfPublicSale Maximum number of token units to mint in public sale\r\n    /// @param _tokenCapOfPrivateSale Maximum number of token units to mint in private sale\r\n    /// @param _tokenPurchaseMinimum Minimum amount of tokens an investor has to buy at once\r\n    /// @param _tokenPurchaseLimit Maximum total token amounts individually buyable in limit phase\r\n    /// @param _tokenPrice Price of a token in EUR cent\r\n    /// @param _openingTime Block (Unix) timestamp of sale opening time\r\n    /// @param _closingTime Block (Unix) timestamp of sale closing time\r\n    /// @param _limitEndTime Block (Unix) timestamp until token purchases are limited\r\n    /// @param _companyWallet Ethereum account who will receive sent ether\r\n    /// @param _tokenReservePerMill Per mill amount of sold tokens to mint for reserve account\r\n    /// @param _reserveAccount Ethereum address of reserve tokens recipient\r\n    constructor(\r\n        RateSource _rateSource,\r\n        MintableToken _token,\r\n        uint _tokenCapOfPublicSale,\r\n        uint _tokenCapOfPrivateSale,\r\n        uint _tokenPurchaseMinimum,\r\n        uint _tokenPurchaseLimit,\r\n        uint _tokenReservePerMill,\r\n        uint _tokenPrice,\r\n        uint _openingTime,\r\n        uint _closingTime,\r\n        uint _limitEndTime,\r\n        address payable _companyWallet,\r\n        address _reserveAccount\r\n    )\r\n        public\r\n    {\r\n        require(address(_rateSource) != address(0x0), \"Rate source is zero\");\r\n        require(address(_token) != address(0x0), \"Token address is zero\");\r\n        require(_token.minter() == address(0x0), \"Token has another minter\");\r\n        require(_tokenCapOfPublicSale > 0, \"Cap of public sale is zero\");\r\n        require(_tokenCapOfPrivateSale > 0, \"Cap of private sale is zero\");\r\n        require(_tokenPurchaseMinimum <= _tokenCapOfPublicSale\r\n                && _tokenPurchaseMinimum <= _tokenCapOfPrivateSale,\r\n                \"Purchase minimum exceeds cap\");\r\n        require(_tokenPrice > 0, \"Token price is zero\");\r\n        require(_openingTime >= now, \"Opening lies in the past\");\r\n        require(_closingTime >= _openingTime, \"Closing lies before opening\");\r\n        require(_companyWallet != address(0x0), \"Company wallet is zero\");\r\n        require(_reserveAccount != address(0x0), \"Reserve account is zero\");\r\n\r\n\r\n        // Note: There are no time related requirements regarding limitEndTime.\r\n        //       If it's below openingTime, token purchases will never be limited.\r\n        //       If it's above closingTime, token purchases will always be limited.\r\n        if (_limitEndTime > _openingTime) {\r\n            // But, if there's a purchase limitation phase, the limit must be at\r\n            // least the purchase minimum or above to make purchases possible.\r\n            require(_tokenPurchaseLimit >= _tokenPurchaseMinimum,\r\n                    \"Purchase limit is below minimum\");\r\n        }\r\n\r\n        // Utilize safe math to ensure the sum of three token pools does't overflow\r\n        _tokenCapOfPublicSale.add(_tokenCapOfPrivateSale).mul(_tokenReservePerMill);\r\n\r\n        rateSource = _rateSource;\r\n        token = _token;\r\n        tokenCapOfPublicSale = _tokenCapOfPublicSale;\r\n        tokenCapOfPrivateSale = _tokenCapOfPrivateSale;\r\n        tokenPurchaseMinimum = _tokenPurchaseMinimum;\r\n        tokenPurchaseLimit= _tokenPurchaseLimit;\r\n        tokenReservePerMill = _tokenReservePerMill;\r\n        tokenPrice = _tokenPrice;\r\n        openingTime = _openingTime;\r\n        closingTime = _closingTime;\r\n        limitEndTime = _limitEndTime;\r\n        companyWallet = _companyWallet;\r\n        reserveAccount = _reserveAccount;\r\n\r\n        tokenRemainingForPublicSale = _tokenCapOfPublicSale;\r\n        tokenRemainingForPrivateSale = _tokenCapOfPrivateSale;\r\n    }\r\n\r\n\r\n\r\n    /// @dev Fallback function: buys tokens\r\n    function () external payable {\r\n        require(msg.data.length == 0, \"Fallback call with data\");\r\n\r\n        buyTokens();\r\n    }\r\n\r\n    /// @dev Distribute tokens purchased off-chain via public sale\r\n    ///      Note: additional requirements are enforced in internal function.\r\n    /// @param beneficiaries List of recipients' Ethereum addresses\r\n    /// @param amounts List of token units each recipient will receive\r\n    function distributeTokensViaPublicSale(\r\n        address[] memory beneficiaries,\r\n        uint[] memory amounts\r\n    )\r\n        public\r\n    {\r\n        tokenRemainingForPublicSale =\r\n            distributeTokens(tokenRemainingForPublicSale, beneficiaries, amounts, true);\r\n    }\r\n\r\n    /// @dev Distribute tokens purchased off-chain via private sale\r\n    ///      Note: additional requirements are enforced in internal function.\r\n    /// @param beneficiaries List of recipients' Ethereum addresses\r\n    /// @param amounts List of token units each recipient will receive\r\n    function distributeTokensViaPrivateSale(\r\n        address[] memory beneficiaries,\r\n        uint[] memory amounts\r\n    )\r\n        public\r\n    {\r\n        tokenRemainingForPrivateSale =\r\n            distributeTokens(tokenRemainingForPrivateSale, beneficiaries, amounts, false);\r\n    }\r\n\r\n    /// @dev Check whether the sale has closed\r\n    /// @return True iff sale closing time has passed\r\n    function hasClosed() public view returns (bool) {\r\n        return now >= closingTime || tokenRemainingForPublicSale == 0;\r\n    }\r\n\r\n    /// @dev Check wether the sale is open\r\n    /// @return True iff sale opening time has passed and sale is not closed yet\r\n    function isOpen() public view returns (bool) {\r\n        return now >= openingTime && !hasClosed();\r\n    }\r\n\r\n    /// @dev Determine the remaining open time of sale\r\n    /// @return Time in seconds until sale gets closed, or 0 if sale was closed\r\n    function timeRemaining() public view returns (uint) {\r\n        if (hasClosed()) {\r\n            return 0;\r\n        }\r\n\r\n        return closingTime - now;\r\n    }\r\n\r\n    /// @dev Determine the amount of sold tokens (off-chain and on-chain)\r\n    /// @return Token units amount\r\n    function tokenSold() public view returns (uint) {\r\n        return (tokenCapOfPublicSale - tokenRemainingForPublicSale)\r\n             + (tokenCapOfPrivateSale - tokenRemainingForPrivateSale);\r\n    }\r\n\r\n    /// @dev Purchase tokens\r\n    function buyTokens() public payable {\r\n        require(isOpen(), \"Sale is not open\");\r\n\r\n        uint etherRate = rateSource.etherRate();\r\n\r\n        require(etherRate > 0, \"Ether rate is zero\");\r\n\r\n        // Units:  [1e-18*ether] * [cent/ether] / [cent/token] => [1e-18*token]\r\n        uint amount = msg.value.mul(etherRate).div(tokenPrice);\r\n\r\n        require(amount <= tokenRemainingForPublicSale, \"Not enough tokens available\");\r\n        require(amount >= tokenPurchaseMinimum, \"Investment is too low\");\r\n\r\n        // Is the total amount an investor can purchase with Ether limited?\r\n        if (now < limitEndTime) {\r\n            uint purchased = tokenPurchased[msg.sender].add(amount);\r\n\r\n            require(purchased <= tokenPurchaseLimit, \"Purchase limit reached\");\r\n\r\n            tokenPurchased[msg.sender] = purchased;\r\n        }\r\n\r\n        tokenRemainingForPublicSale = tokenRemainingForPublicSale.sub(amount);\r\n\r\n        token.mint(msg.sender, amount);\r\n        forwardFunds();\r\n\r\n        emit TokenPurchase(msg.sender, msg.value, amount);\r\n    }\r\n\r\n    /// @dev Extend the offering period of the crowd sale.\r\n    /// @param _newClosingTime new closingTime of the crowdsale\r\n    function changeClosingTime(uint _newClosingTime) public onlyOwner {\r\n        require(!hasClosed(), \"Sale has already ended\");\r\n        require(_newClosingTime > now, \"ClosingTime not in the future\");\r\n        require(_newClosingTime > openingTime, \"New offering is zero\");\r\n        require(_newClosingTime - openingTime <= MAXOFFERINGPERIOD, \"New offering too long\");\r\n\r\n        emit ClosingTimeChange(closingTime, _newClosingTime);\r\n\r\n        closingTime = _newClosingTime;\r\n    }\r\n\r\n    /// @dev Finalize, i.e. end token minting phase and enable token transfers\r\n    function finalize() public onlyOwner {\r\n        require(!isFinalized, \"Sale has already been finalized\");\r\n        require(hasClosed(), \"Sale has not closed\");\r\n\r\n        if (tokenReservePerMill > 0) {\r\n            token.mint(reserveAccount, tokenSold().mul(tokenReservePerMill).div(1000));\r\n        }\r\n        token.finishMinting();\r\n        isFinalized = true;\r\n\r\n        emit Finalization();\r\n    }\r\n\r\n    /// @dev Distribute tokens purchased off-chain (in Euro) to investors\r\n    /// @param tokenRemaining Token units available for sale\r\n    /// @param beneficiaries Ethereum addresses of purchasers\r\n    /// @param amounts Token unit amounts to deliver to each investor\r\n    /// @return Token units available for sale after distribution\r\n    function distributeTokens(\r\n        uint tokenRemaining,\r\n        address[] memory beneficiaries,\r\n        uint[] memory amounts,\r\n        bool isPublicSale\r\n    )\r\n        internal\r\n        onlyOwner\r\n        returns (uint)\r\n    {\r\n        require(!isFinalized, \"Sale has been finalized\");\r\n        require(beneficiaries.length == amounts.length, \"Lengths are different\");\r\n\r\n        for (uint i = 0; i < beneficiaries.length; ++i) {\r\n            address beneficiary = beneficiaries[i];\r\n            uint amount = amounts[i];\r\n\r\n            require(amount <= tokenRemaining, \"Not enough tokens available\");\r\n\r\n            tokenRemaining = tokenRemaining.sub(amount);\r\n            token.mint(beneficiary, amount);\r\n\r\n            emit TokenDistribution(beneficiary, amount, isPublicSale);\r\n        }\r\n\r\n        return tokenRemaining;\r\n    }\r\n\r\n    /// @dev Forward invested ether to company wallet\r\n    function forwardFunds() internal {\r\n        companyWallet.transfer(address(this).balance);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/token/TokenRecoverable.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/// @title TokenRecoverable\r\n/// @author STOKR\r\ncontract TokenRecoverable is Ownable {\r\n\r\n    // Address that can do the TokenRecovery\r\n    address public tokenRecoverer;\r\n\r\n    /// @dev  Event emitted when the TokenRecoverer changes\r\n    /// @param previous  Ethereum address of previous token recoverer\r\n    /// @param current   Ethereum address of new token recoverer\r\n    event TokenRecovererChange(address indexed previous, address indexed current);\r\n\r\n    /// @dev Event emitted in case of a TokenRecovery\r\n    /// @param oldAddress Ethereum address of old account\r\n    /// @param newAddress Ethereum address of new account\r\n    event TokenRecovery(address indexed oldAddress, address indexed newAddress);\r\n\r\n    /// @dev Restrict operation to token recoverer\r\n    modifier onlyTokenRecoverer() {\r\n        require(msg.sender == tokenRecoverer, \"Restricted to token recoverer\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor\r\n    /// @param _tokenRecoverer Ethereum address of token recoverer\r\n    constructor(address _tokenRecoverer) public {\r\n        setTokenRecoverer(_tokenRecoverer);\r\n    }\r\n\r\n    /// @dev Set token recoverer\r\n    /// @param _newTokenRecoverer Ethereum address of new token recoverer\r\n    function setTokenRecoverer(address _newTokenRecoverer) public onlyOwner {\r\n        require(_newTokenRecoverer != address(0x0), \"New token recoverer is zero\");\r\n\r\n        if (_newTokenRecoverer != tokenRecoverer) {\r\n            emit TokenRecovererChange(tokenRecoverer, _newTokenRecoverer);\r\n\r\n            tokenRecoverer = _newTokenRecoverer;\r\n        }\r\n    }\r\n\r\n    /// @dev Recover token\r\n    /// @param _oldAddress address\r\n    /// @param _newAddress address\r\n    function recoverToken(address _oldAddress, address _newAddress) public;\r\n\r\n}\r\n\r\n// File: contracts/token/StokrToken.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n/// @title StokrToken\r\n/// @author Stokr\r\ncontract StokrToken is MintableToken, TokenRecoverable {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping(address => mapping(address => uint)) internal allowance_;\r\n\r\n    /// @dev Log entry on self destruction of the token\r\n    event TokenDestroyed();\r\n\r\n    /// @dev Constructor\r\n    /// @param _whitelist       Ethereum address of whitelist contract\r\n    /// @param _tokenRecoverer  Ethereum address of token recoverer\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        Whitelist _whitelist,\r\n        address _profitDepositor,\r\n        address _profitDistributor,\r\n        address _tokenRecoverer\r\n    )\r\n        public\r\n        Whitelisted(_whitelist)\r\n        ProfitSharing(_profitDepositor, _profitDistributor)\r\n        TokenRecoverable(_tokenRecoverer)\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /// @dev  Self destruct can only be called by crowdsale contract in case the goal wasn't reached\r\n    function destruct() public onlyMinter {\r\n        emit TokenDestroyed();\r\n        selfdestruct(address(uint160(owner)));\r\n    }\r\n\r\n    /// @dev Recover token\r\n    /// @param _oldAddress  address of old account\r\n    /// @param _newAddress  address of new account\r\n    function recoverToken(address _oldAddress, address _newAddress)\r\n        public\r\n        onlyTokenRecoverer\r\n        onlyWhitelisted(_newAddress)\r\n    {\r\n        // Ensure that new address is *not* an existing account.\r\n        // Check for account.profitShare is not needed because of following implication:\r\n        //   (account.lastTotalProfits == 0) ==> (account.profitShare == 0)\r\n        require(accounts[_newAddress].balance == 0 && accounts[_newAddress].lastTotalProfits == 0,\r\n                \"New address exists already\");\r\n\r\n        updateProfitShare(_oldAddress);\r\n\r\n        accounts[_newAddress] = accounts[_oldAddress];\r\n        delete accounts[_oldAddress];\r\n\r\n        emit TokenRecovery(_oldAddress, _newAddress);\r\n        emit Transfer(_oldAddress, _newAddress, accounts[_newAddress].balance);\r\n    }\r\n\r\n    /// @dev  Total supply of this token\r\n    /// @return  Token amount\r\n    function totalSupply() public view returns (uint) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /// @dev  Token balance\r\n    /// @param _investor  Ethereum address of token holder\r\n    /// @return           Token amount\r\n    function balanceOf(address _investor) public view returns (uint) {\r\n        return accounts[_investor].balance;\r\n    }\r\n\r\n    /// @dev  Allowed token amount a third party trustee may transfer\r\n    /// @param _investor  Ethereum address of token holder\r\n    /// @param _spender   Ethereum address of third party\r\n    /// @return           Allowed token amount\r\n    function allowance(address _investor, address _spender) public view returns (uint) {\r\n        return allowance_[_investor][_spender];\r\n    }\r\n\r\n    /// @dev  Approve a third party trustee to transfer tokens\r\n    ///       Note: additional requirements are enforced within internal function.\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _value    Maximum token amount that is allowed to get transferred\r\n    /// @return          Always true\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        return _approve(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /// @dev  Increase the amount of tokens a third party trustee may transfer\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _amount   Additional token amount that is allowed to get transferred\r\n    /// @return          Always true\r\n    function increaseAllowance(address _spender, uint _amount) public returns (bool) {\r\n        require(allowance_[msg.sender][_spender] + _amount >= _amount, \"Allowance overflow\");\r\n\r\n        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].add(_amount));\r\n    }\r\n\r\n    /// @dev  Decrease the amount of tokens a third party trustee may transfer\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _amount   Reduced token amount that is allowed to get transferred\r\n    /// @return          Always true\r\n    function decreaseAllowance(address _spender, uint _amount) public returns (bool) {\r\n        require(_amount <= allowance_[msg.sender][_spender], \"Amount exceeds allowance\");\r\n\r\n        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].sub(_amount));\r\n    }\r\n\r\n    /// @dev  Check if a token transfer is possible\r\n    /// @param _from   Ethereum address of token sender\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        True iff a transfer with given pramaters would succeed\r\n    function canTransfer(address _from, address _to, uint _value)\r\n        public view returns (bool)\r\n    {\r\n        return totalSupplyIsFixed\r\n            && _from != address(0x0)\r\n            && _to != address(0x0)\r\n            && _value <= accounts[_from].balance\r\n            && whitelist.isWhitelisted(_from)\r\n            && whitelist.isWhitelisted(_to);\r\n    }\r\n\r\n    /// @dev  Check if a token transfer by third party is possible\r\n    /// @param _spender  Ethereum address of third party trustee\r\n    /// @param _from     Ethereum address of token holder\r\n    /// @param _to       Ethereum address of token recipient\r\n    /// @param _value    Token amount to transfer\r\n    /// @return          True iff a transfer with given pramaters would succeed\r\n    function canTransferFrom(address _spender, address _from, address _to, uint _value)\r\n        public view returns (bool)\r\n    {\r\n        return canTransfer(_from, _to, _value) && _value <= allowance_[_from][_spender];\r\n    }\r\n\r\n    /// @dev  Token transfer\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        Always true\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev  Token transfer by a third party\r\n    ///       Note: additional requirements are enforces within internal function.\r\n    /// @param _from   Ethereum address of token holder\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        Always true\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        require(_value <= allowance_[_from][msg.sender], \"Amount exceeds allowance\");\r\n\r\n        return _approve(_from, msg.sender, allowance_[_from][msg.sender].sub(_value))\r\n            && _transfer(_from, _to, _value);\r\n    }\r\n\r\n    /// @dev  Approve a third party trustee to transfer tokens (internal implementation)\r\n    /// @param _from     Ethereum address of token holder\r\n    /// @param _spender  Ethereum address of third party\r\n    /// @param _value    Maximum token amount the trustee is allowed to transfer\r\n    /// @return          Always true\r\n    function _approve(address _from, address _spender, uint _value)\r\n        internal\r\n        onlyWhitelisted(_from)\r\n        onlyWhenTotalSupplyIsFixed\r\n        returns (bool)\r\n    {\r\n        allowance_[_from][_spender] = _value;\r\n\r\n        emit Approval(_from, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev  Token transfer (internal implementation)\r\n    /// @param _from   Ethereum address of token sender\r\n    /// @param _to     Ethereum address of token recipient\r\n    /// @param _value  Token amount to transfer\r\n    /// @return        Always true\r\n    function _transfer(address _from, address _to, uint _value)\r\n        internal\r\n        onlyWhitelisted(_from)\r\n        onlyWhitelisted(_to)\r\n        onlyWhenTotalSupplyIsFixed\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0x0), \"Recipient is zero\");\r\n        require(_value <= accounts[_from].balance, \"Amount exceeds balance\");\r\n\r\n        updateProfitShare(_from);\r\n        updateProfitShare(_to);\r\n\r\n        accounts[_from].balance = accounts[_from].balance.sub(_value);\r\n        accounts[_to].balance = accounts[_to].balance.add(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/crowdsale/StokrCrowdsale.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n/// @title StokrCrowdsale\r\n/// @author STOKR\r\ncontract StokrCrowdsale is MintingCrowdsale {\r\n\r\n    // Soft cap in token units\r\n    uint public tokenGoal;\r\n\r\n    // As long as the goal is not reached funds of purchases are held back\r\n    // and investments are assigned to investors here to enable a refunding\r\n    // if the goal is missed upon finalization\r\n    mapping(address => uint) public investments;\r\n\r\n\r\n    // Log entry upon investor refund event\r\n    event InvestorRefund(address indexed investor, uint value);\r\n\r\n\r\n    /// @dev Constructor\r\n    /// @param _token The token\r\n    /// @param _tokenCapOfPublicSale Available token units for public sale\r\n    /// @param _tokenCapOfPrivateSale Available token units for private sale\r\n    /// @param _tokenGoal Minimum number of sold token units to be successful\r\n    /// @param _tokenPurchaseMinimum Minimum amount of tokens an investor has to buy at once\r\n    /// @param _tokenPurchaseLimit Maximum total token amounts individually buyable in limit phase\r\n    /// @param _tokenReservePerMill Additional reserve tokens in per mill of sold tokens\r\n    /// @param _tokenPrice Price of a token in EUR cent\r\n    /// @param _rateSource Ethereum address of ether rate setting authority\r\n    /// @param _openingTime Block (Unix) timestamp of sale opening time\r\n    /// @param _closingTime Block (Unix) timestamp of sale closing time\r\n    /// @param _limitEndTime Block (Unix) timestamp until token purchases are limited\r\n    /// @param _companyWallet Ethereum account who will receive sent ether\r\n    /// @param _reserveAccount An address\r\n    constructor(\r\n        RateSource _rateSource,\r\n        StokrToken _token,\r\n        uint _tokenCapOfPublicSale,\r\n        uint _tokenCapOfPrivateSale,\r\n        uint _tokenGoal,\r\n        uint _tokenPurchaseMinimum,\r\n        uint _tokenPurchaseLimit,\r\n        uint _tokenReservePerMill,\r\n        uint _tokenPrice,\r\n        uint _openingTime,\r\n        uint _closingTime,\r\n        uint _limitEndTime,\r\n        address payable _companyWallet,\r\n        address _reserveAccount\r\n    )\r\n        public\r\n        MintingCrowdsale(\r\n            _rateSource,\r\n            _token,\r\n            _tokenCapOfPublicSale,\r\n            _tokenCapOfPrivateSale,\r\n            _tokenPurchaseMinimum,\r\n            _tokenPurchaseLimit,\r\n            _tokenReservePerMill,\r\n            _tokenPrice,\r\n            _openingTime,\r\n            _closingTime,\r\n            _limitEndTime,\r\n            _companyWallet,\r\n            _reserveAccount\r\n        )\r\n    {\r\n        require(\r\n            _tokenGoal <= _tokenCapOfPublicSale + _tokenCapOfPrivateSale,\r\n            \"Goal is not attainable\"\r\n        );\r\n\r\n        tokenGoal = _tokenGoal;\r\n    }\r\n\r\n    /// @dev Wether the goal of sold tokens was reached or not\r\n    /// @return True if the sale can be considered successful\r\n    function goalReached() public view returns (bool) {\r\n        return tokenSold() >= tokenGoal;\r\n    }\r\n\r\n    /// @dev Investors can claim refunds here if crowdsale was unsuccessful\r\n    function distributeRefunds(address payable[] calldata _investors) external {\r\n        for (uint i = 0; i < _investors.length; ++i) {\r\n            refundInvestor(_investors[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Investors can claim refunds here if crowdsale was unsuccessful\r\n    function claimRefund() public {\r\n        refundInvestor(msg.sender);\r\n    }\r\n\r\n    /// @dev Overwritten. Kill the token if goal was missed\r\n    function finalize() public onlyOwner {\r\n        super.finalize();\r\n\r\n        if (!goalReached()) {\r\n            StokrToken(address(token)).destruct();\r\n        }\r\n    }\r\n\r\n    function distributeTokensViaPublicSale(\r\n        address[] memory beneficiaries,\r\n        uint[] memory amounts\r\n    )\r\n        public\r\n    {\r\n        super.distributeTokensViaPublicSale(beneficiaries, amounts);\r\n        // The goal may get reached due to token distribution,\r\n        // so forward any accumulated funds to the company wallet.\r\n        forwardFunds();\r\n    }\r\n\r\n    function distributeTokensViaPrivateSale(\r\n        address[] memory beneficiaries,\r\n        uint[] memory amounts\r\n    )\r\n        public\r\n    {\r\n        super.distributeTokensViaPrivateSale(beneficiaries, amounts);\r\n        // The goal may get reached due to token distribution,\r\n        // so forward any accumulated funds to the company wallet.\r\n        forwardFunds();\r\n    }\r\n\r\n    /// @dev Overwritten. Funds are held back until goal was reached\r\n    function forwardFunds() internal {\r\n        if (goalReached()) {\r\n            super.forwardFunds();\r\n        }\r\n        else {\r\n            investments[msg.sender] = investments[msg.sender].add(msg.value);\r\n        }\r\n    }\r\n\r\n    /// @dev Refund an investor if the sale was not successful\r\n    /// @param _investor Ethereum address of investor\r\n    function refundInvestor(address payable _investor) internal {\r\n        require(isFinalized, \"Sale has not been finalized\");\r\n        require(!goalReached(), \"Goal was reached\");\r\n\r\n        uint investment = investments[_investor];\r\n\r\n        if (investment > 0) {\r\n            investments[_investor] = 0;\r\n            _investor.transfer(investment);\r\n\r\n            emit InvestorRefund(_investor, investment);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract RateSource\",\"name\":\"_rateSource\",\"type\":\"address\"},{\"internalType\":\"contract StokrToken\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenCapOfPublicSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenCapOfPrivateSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenGoal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPurchaseMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPurchaseLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenReservePerMill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limitEndTime\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_companyWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserveAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"ClosingTimeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvestorRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPublicSale\",\"type\":\"bool\"}],\"name\":\"TokenDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newClosingTime\",\"type\":\"uint256\"}],\"name\":\"changeClosingTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"distributeRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeTokensViaPrivateSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeTokensViaPublicSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateSource\",\"outputs\":[{\"internalType\":\"contract RateSource\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract MintableToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCapOfPrivateSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCapOfPublicSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGoal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPurchaseLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPurchaseMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPurchased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRemainingForPrivateSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRemainingForPublicSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReservePerMill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipUnsafe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StokrCrowdsale","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000017f3af25e9a7463c35bb7f9aa3f7e633eaa5160d0000000000000000000000009a3f7daafd36a69fb9f88c764b10817f2066a7f000000000000000000000000000000000000000000000d3c20dee1639f99c000000000000000000000000000000000000000000000003b8e98b0350e0fbe400000000000000000000000000000000000000000000000069e10de76676d08000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000005ef08120000000000000000000000000000000000000000000000000000000005f69cb20000000000000000000000000000000000000000000000000000000005ef08120000000000000000000000000988fb34aa8b470969c9353c2ad02f2d161eb9994000000000000000000000000988fb34aa8b470969c9353c2ad02f2d161eb9994","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://dcb016d059791e86e9ad1c9919263fb931cdb44818356e5d3e27b3f081f74480"}]}