{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nPlease note, there are 3 native components to this token design. Token, Router, and Core. \r\nEach component is deployed separately as an external contract.\r\n\r\nThis is the main code of a mutable token contract.\r\nThe Router component is the mutable part and it can be re-routed should there be any code updates.\r\nAny other contract is also external and it must be additionally registered and routed within the native components.\r\nThe main idea of this design was to follow the adjusted Proxy and the MVC design patterns.\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity = 0.7 .0;\r\n\r\nlibrary SafeMath {\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n\t\trequire(b <= a, errorMessage);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n}\r\n\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns(address payable) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns(bytes memory) {\r\n\t\tthis;\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tconstructor() {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t}\r\n\r\n\tfunction owner() public view returns(address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n\tfunction currentTokenContract() external view returns(address routerAddress);\r\n\r\n\tfunction currentRouterContract() external view returns(address routerAddress);\r\n\r\n\tfunction transfer(address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\r\n\r\n\tfunction approve(address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\r\n\r\n\tfunction transferFrom(address[3] memory addressArr, uint[3] memory uintArr) external returns(bool success);\r\n\r\n\tfunction increaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\r\n\r\n\tfunction decreaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\r\n\r\n\tfunction mint(address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\r\n\r\n\tfunction burn(address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\r\n\t\r\n\tfunction updateTotalSupply(uint[2] memory uintArr) external returns(bool success);\r\n\t\t    \r\n\tfunction updateCurrentSupply(uint[2] memory uintArr) external returns(bool success);\r\n\t\r\n\tfunction updateJointSupply(uint[2] memory uintArr) external returns(bool success);\r\n\r\n}\r\n\r\nabstract contract Token {\r\n\tfunction balanceOf(address account) external view virtual returns(uint256 data);\r\n\r\n\tfunction allowance(address owner, address spender) external view virtual returns(uint256 data);\r\n\t\r\n\tfunction updateTotalSupply(uint newTotalSupply) external virtual returns(bool success);\r\n\t\r\n\tfunction updateCurrentSupply(uint newCurrentSupply) external virtual returns(bool success);\r\n\t\r\n\tfunction updateJointSupply(uint newCurrentSupply) external virtual returns(bool success);\r\n\r\n\tfunction emitTransfer(address fromAddress, address toAddress, uint amount, bool affectTotalSupply) external virtual returns(bool success);\r\n\r\n\tfunction emitApproval(address fromAddress, address toAddress, uint amount) external virtual returns(bool success);\r\n\r\n}\r\n\r\n//============================================================================================\r\n// MAIN CONTRACT \r\n//============================================================================================\r\n\r\ncontract Core is IERC20, Ownable {\r\n\r\n\tusing SafeMath\r\n\tfor uint256;\r\n\r\n\taddress public tokenContract;\r\n\taddress public routerContract;\r\n\tToken private token;\r\n\r\n\tfunction currentTokenContract() override external view virtual returns(address tokenAddress) {\r\n\t\treturn tokenContract;\r\n\t}\r\n\r\n\tfunction currentRouterContract() override external view virtual returns(address routerAddress) {\r\n\t\treturn routerContract;\r\n\t}\r\n\r\n\tfunction setNewTokenContract(address newTokenAddress) onlyOwner public virtual returns(bool success) {\r\n\t\ttokenContract = newTokenAddress;\r\n\t\ttoken = Token(newTokenAddress);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setNewRouterContract(address newRouterAddress) onlyOwner public virtual returns(bool success) {\r\n\t\trouterContract = newRouterAddress;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//============== NATIVE FUNCTIONS START HERE ==================================================\r\n\t//These functions should never change when introducing a new version of a router.\r\n\t//Router is expected to constantly change, and the code should be written under \r\n\t//the \"NON-CORE FUNCTIONS TO BE CODED BELOW\".\r\n\r\n\tfunction transfer(address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: transfer | message: Must be called by the registered Router contract\");\r\n\t\t_transfer(addressArr, uintArr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _transfer(address[2] memory addressArr, uint[2] memory uintArr) private returns(bool success) {\r\n\t\taddress fromAddress = addressArr[0];\r\n\t\taddress toAddress = addressArr[1];\r\n\r\n\t\trequire(fromAddress != address(0), \"at: core.sol | contract: Core | function: _transfer | message: Sender cannot be address(0)\");\r\n\r\n\t\tuint amount = uintArr[0];\r\n\r\n\t\trequire(amount <= token.balanceOf(fromAddress), \"at: core.sol | contract: Core | function: _transfer | message: Insufficient amount\");\r\n\r\n\t\ttoken.emitTransfer(fromAddress, toAddress, amount, false);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address[2] memory addressArr, uint[2] memory uintArr) override external returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: approve | message: Must be called by the registered Router contract\");\r\n\t\t_approve(addressArr, uintArr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _approve(address[2] memory addressArr, uint[2] memory uintArr) private returns(bool success) {\r\n\t\taddress owner = addressArr[0];\r\n\t\taddress spender = addressArr[1];\r\n\t\tuint amount = uintArr[0];\r\n\r\n\t\trequire(owner != address(0), \"at: core.sol | contract: Core | function: _approve | message: ERC20: approve from the zero address\");\r\n\t\trequire(spender != address(0), \"at: core.sol | contract: Core | function: _approve | message: ERC20: approve to the zero address\");\r\n\r\n\t\ttoken.emitApproval(owner, spender, amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address[3] memory addressArr, uint[3] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: transferFrom | message: Must be called by the registered Router contract\");\r\n\t\tuint allowance = token.allowance(addressArr[1], addressArr[0]);\r\n\t\trequire(allowance >= uintArr[0], \"at: core.sol | contract: Core | function: transferFrom | message: Insufficient amount\");\r\n\r\n\t\taddress[2] memory tmpAddresses1 = [addressArr[1], addressArr[2]];\r\n\t\taddress[2] memory tmpAddresses2 = [addressArr[1], addressArr[0]];\r\n\r\n\t\tuint[2] memory tmpUint = [uintArr[0], uintArr[1]];\r\n\r\n\t\t\r\n\t\t_transfer(tmpAddresses1, tmpUint);\r\n\t\t\r\n\t\ttmpUint = [allowance.sub(uintArr[0]), uintArr[1]];\r\n\t\t_approve(tmpAddresses2, tmpUint);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction increaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: increaseAllowance | message: Must be called by the registered Router contract\");\r\n\t\tuint newAllowance = token.allowance(addressArr[0], addressArr[1]).add(uintArr[0]);\r\n\t\tuintArr[0] = newAllowance;\r\n\t\t_approve(addressArr, uintArr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: decreaseAllowance | message: Must be called by the registered Router contract\");\r\n\t\tuint newAllowance = token.allowance(addressArr[0], addressArr[1]).sub(uintArr[0], \"at: core.sol | contract: Core | function: decreaseAllowance | message: Decreases allowance below zero\");\r\n\t\tuintArr[0] = newAllowance;\r\n\t\t_approve(addressArr, uintArr);\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\t//============== NATIVE FUNCTIONS END HERE ==================================================\r\n\r\n\r\n\t//=============== NON-NATIVE FUNCTIONS TO BE CODED BELOW ====================================\r\n\t// This code is a subject to a change, should we decide to alter anything.\r\n\t// We can also design another external contract, possibilities are infinite.\r\n\r\n\tfunction mint(address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: mint | message: Must be called by the registered Router contract\");\r\n\t\taddress fromAddress = address(0);\r\n\t\taddress toAddress = addressArr[1];\r\n\t\tuint amount = uintArr[0];\r\n\t\ttoken.emitTransfer(fromAddress, toAddress, amount, false);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction burn(address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: burn | message: Must be called by the registered Router contract\");\r\n\t\taddress fromAddress = addressArr[0];\r\n\t\taddress toAddress = address(0);\r\n\t\tuint amount = uintArr[0];\r\n\t\ttoken.emitTransfer(fromAddress, toAddress, amount,false);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction updateTotalSupply(uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: updateTotalSupply | message: Must be called by the registered Router contract\");\r\n\t\tuint amount = uintArr[0];\r\n\t\ttoken.updateTotalSupply(amount);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction updateCurrentSupply(uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: updateCurrentSupply | message: Must be called by the registered Router contract\");\r\n\t\tuint amount = uintArr[0];\r\n\t\ttoken.updateCurrentSupply(amount);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction updateJointSupply(uint[2] memory uintArr) override external virtual returns(bool success) {\r\n\t\trequire(msg.sender == routerContract, \"at: core.sol | contract: Core | function: updateCurrentSupply | message: Must be called by the registered Router contract\");\r\n\t\tuint amount = uintArr[0];\r\n\t\ttoken.updateJointSupply(amount);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addressArr\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addressArr\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRouterContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addressArr\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addressArr\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addressArr\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouterAddress\",\"type\":\"address\"}],\"name\":\"setNewRouterContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTokenAddress\",\"type\":\"address\"}],\"name\":\"setNewTokenContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addressArr\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"addressArr\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"uintArr\",\"type\":\"uint256[3]\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"updateCurrentSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"updateJointSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"uintArr\",\"type\":\"uint256[2]\"}],\"name\":\"updateTotalSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Core","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6f37cd0771b15b75485b256c1e9d01ec40ea12ffa7816d3e484357eebb2d9367"}]}