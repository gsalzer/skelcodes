{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/sol6/utils/zeppelin/SafeMath.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/IEpochUtils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IEpochUtils {\r\n    function epochPeriodInSeconds() external view returns (uint256);\r\n\r\n    function firstEpochStartTimestamp() external view returns (uint256);\r\n\r\n    function getCurrentEpochNumber() external view returns (uint256);\r\n\r\n    function getEpochNumber(uint256 timestamp) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/Dao/EpochUtils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ncontract EpochUtils is IEpochUtils {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public override epochPeriodInSeconds;\r\n    uint256 public override firstEpochStartTimestamp;\r\n\r\n    function getCurrentEpochNumber() public view override returns (uint256) {\r\n        return getEpochNumber(now);\r\n    }\r\n\r\n    function getEpochNumber(uint256 timestamp) public view override returns (uint256) {\r\n        if (timestamp < firstEpochStartTimestamp || epochPeriodInSeconds == 0) {\r\n            return 0;\r\n        }\r\n        // ((timestamp - firstEpochStartTimestamp) / epochPeriodInSeconds) + 1;\r\n        return ((timestamp.sub(firstEpochStartTimestamp)).div(epochPeriodInSeconds)).add(1);\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/DaoOperator.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract DaoOperator {\r\n    address public daoOperator;\r\n\r\n    constructor(address _daoOperator) public {\r\n        require(_daoOperator != address(0), \"daoOperator is 0\");\r\n        daoOperator = _daoOperator;\r\n    }\r\n\r\n    modifier onlyDaoOperator() {\r\n        require(msg.sender == daoOperator, \"only daoOperator\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n\r\n}\r\n\r\n// File: contracts/sol6/utils/zeppelin/ReentrancyGuard.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/IKyberStaking.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberStaking is IEpochUtils {\r\n    event Delegated(\r\n        address indexed staker,\r\n        address indexed representative,\r\n        uint256 indexed epoch,\r\n        bool isDelegated\r\n    );\r\n    event Deposited(uint256 curEpoch, address indexed staker, uint256 amount);\r\n    event Withdraw(uint256 indexed curEpoch, address indexed staker, uint256 amount);\r\n\r\n    function initAndReturnStakerDataForCurrentEpoch(address staker)\r\n        external\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function delegate(address dAddr) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice return combine data (stake, delegatedStake, representative) of a staker\r\n     * @dev allow to get staker data up to current epoch + 1\r\n     */\r\n    function getStakerData(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n\r\n    function getLatestStakerData(address staker)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n\r\n    /**\r\n     * @notice return raw data of a staker for an epoch\r\n     *         WARN: should be used only for initialized data\r\n     *          if data has not been initialized, it will return all 0\r\n     *          pool master shouldn't use this function to compute/distribute rewards of pool members\r\n     */\r\n    function getStakerRawData(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n}\r\n\r\n// File: contracts/sol6/IKyberDao.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberDao is IEpochUtils {\r\n    event Voted(address indexed staker, uint indexed epoch, uint indexed campaignID, uint option);\r\n\r\n    function getLatestNetworkFeeDataWithCache()\r\n        external\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function getLatestBRRDataWithCache()\r\n        external\r\n        returns (\r\n            uint256 burnInBps,\r\n            uint256 rewardInBps,\r\n            uint256 rebateInBps,\r\n            uint256 epoch,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function handleWithdrawal(address staker, uint256 penaltyAmount) external;\r\n\r\n    function vote(uint256 campaignID, uint256 option) external;\r\n\r\n    function getLatestNetworkFeeData()\r\n        external\r\n        view\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function shouldBurnRewardForEpoch(uint256 epoch) external view returns (bool);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for a past epoch only\r\n     *       fee handler should call this function when a staker wants to claim reward\r\n     *       return 0 if staker has no votes or stakes\r\n     */\r\n    function getPastEpochRewardPercentageInPrecision(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for the current epoch\r\n     *       reward percentage is not finalized until the current epoch is ended\r\n     */\r\n    function getCurrentEpochRewardPercentageInPrecision(address staker)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/Dao/KyberStaking.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice   This contract is using SafeMath for uint, which is inherited from EpochUtils\r\n *           Some events are moved to interface, easier for public uses\r\n *           Staking contract will be deployed by KyberDao's contract\r\n */\r\ncontract KyberStaking is IKyberStaking, EpochUtils, ReentrancyGuard {\r\n    struct StakerData {\r\n        uint256 stake;\r\n        uint256 delegatedStake;\r\n        address representative;\r\n    }\r\n\r\n    IERC20 public immutable kncToken;\r\n    IKyberDao public immutable kyberDao;\r\n\r\n    // staker data per epoch, including stake, delegated stake and representative\r\n    mapping(uint256 => mapping(address => StakerData)) internal stakerPerEpochData;\r\n    // latest data of a staker, including stake, delegated stake, representative\r\n    mapping(address => StakerData) internal stakerLatestData;\r\n    // true/false: if data has been initialized at an epoch for a staker\r\n    mapping(uint256 => mapping(address => bool)) internal hasInited;\r\n\r\n    // event is fired if something is wrong with withdrawal\r\n    // even though the withdrawal is still successful\r\n    event WithdrawDataUpdateFailed(uint256 curEpoch, address staker, uint256 amount);\r\n\r\n    constructor(\r\n        IERC20 _kncToken,\r\n        uint256 _epochPeriod,\r\n        uint256 _startTimestamp,\r\n        IKyberDao _kyberDao\r\n    ) public {\r\n        require(_epochPeriod > 0, \"ctor: epoch period is 0\");\r\n        require(_startTimestamp >= now, \"ctor: start in the past\");\r\n        require(_kncToken != IERC20(0), \"ctor: kncToken 0\");\r\n        require(_kyberDao != IKyberDao(0), \"ctor: kyberDao 0\");\r\n\r\n        epochPeriodInSeconds = _epochPeriod;\r\n        firstEpochStartTimestamp = _startTimestamp;\r\n        kncToken = _kncToken;\r\n        kyberDao = _kyberDao;\r\n    }\r\n\r\n    /**\r\n     * @dev calls to set delegation for msg.sender, will take effect from the next epoch\r\n     * @param newRepresentative address to delegate to\r\n     */\r\n    function delegate(address newRepresentative) external override {\r\n        require(newRepresentative != address(0), \"delegate: representative 0\");\r\n        address staker = msg.sender;\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n\r\n        initDataIfNeeded(staker, curEpoch);\r\n\r\n        address curRepresentative = stakerPerEpochData[curEpoch + 1][staker].representative;\r\n        // nothing changes here\r\n        if (newRepresentative == curRepresentative) {\r\n            return;\r\n        }\r\n\r\n        uint256 updatedStake = stakerPerEpochData[curEpoch + 1][staker].stake;\r\n\r\n        // reduce delegatedStake for curRepresentative if needed\r\n        if (curRepresentative != staker) {\r\n            initDataIfNeeded(curRepresentative, curEpoch);\r\n\r\n            stakerPerEpochData[curEpoch + 1][curRepresentative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][curRepresentative].delegatedStake.sub(updatedStake);\r\n            stakerLatestData[curRepresentative].delegatedStake =\r\n                stakerLatestData[curRepresentative].delegatedStake.sub(updatedStake);\r\n\r\n            emit Delegated(staker, curRepresentative, curEpoch, false);\r\n        }\r\n\r\n        stakerLatestData[staker].representative = newRepresentative;\r\n        stakerPerEpochData[curEpoch + 1][staker].representative = newRepresentative;\r\n\r\n        // ignore if staker is delegating back to himself\r\n        if (newRepresentative != staker) {\r\n            initDataIfNeeded(newRepresentative, curEpoch);\r\n            stakerPerEpochData[curEpoch + 1][newRepresentative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][newRepresentative].delegatedStake.add(updatedStake);\r\n            stakerLatestData[newRepresentative].delegatedStake =\r\n                stakerLatestData[newRepresentative].delegatedStake.add(updatedStake);\r\n            emit Delegated(staker, newRepresentative, curEpoch, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev call to stake more KNC for msg.sender\r\n     * @param amount amount of KNC to stake\r\n     */\r\n    function deposit(uint256 amount) external override {\r\n        require(amount > 0, \"deposit: amount is 0\");\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        address staker = msg.sender;\r\n\r\n        // collect KNC token from staker\r\n        require(\r\n            kncToken.transferFrom(staker, address(this), amount),\r\n            \"deposit: can not get token\"\r\n        );\r\n\r\n        initDataIfNeeded(staker, curEpoch);\r\n\r\n        stakerPerEpochData[curEpoch + 1][staker].stake =\r\n            stakerPerEpochData[curEpoch + 1][staker].stake.add(amount);\r\n        stakerLatestData[staker].stake =\r\n            stakerLatestData[staker].stake.add(amount);\r\n\r\n        // increase delegated stake for address that staker has delegated to (if it is not staker)\r\n        address representative = stakerPerEpochData[curEpoch + 1][staker].representative;\r\n        if (representative != staker) {\r\n            initDataIfNeeded(representative, curEpoch);\r\n            stakerPerEpochData[curEpoch + 1][representative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][representative].delegatedStake.add(amount);\r\n            stakerLatestData[representative].delegatedStake =\r\n                stakerLatestData[representative].delegatedStake.add(amount);\r\n        }\r\n\r\n        emit Deposited(curEpoch, staker, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev call to withdraw KNC from staking, it could affect reward when calling KyberDao handleWithdrawal\r\n     * @param amount amount of KNC to withdraw\r\n     */\r\n    function withdraw(uint256 amount) external override nonReentrant {\r\n        require(amount > 0, \"withdraw: amount is 0\");\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        address staker = msg.sender;\r\n\r\n        require(\r\n            stakerLatestData[staker].stake >= amount,\r\n            \"withdraw: latest amount staked < withdrawal amount\"\r\n        );\r\n\r\n        (bool success, ) = address(this).call(\r\n            abi.encodeWithSignature(\r\n                \"handleWithdrawal(address,uint256,uint256)\",\r\n                staker,\r\n                amount,\r\n                curEpoch\r\n            )\r\n        );\r\n        if (!success) {\r\n            // Note: should catch this event to check if something went wrong\r\n            emit WithdrawDataUpdateFailed(curEpoch, staker, amount);\r\n        }\r\n\r\n        stakerLatestData[staker].stake = stakerLatestData[staker].stake.sub(amount);\r\n\r\n        // transfer KNC back to staker\r\n        require(kncToken.transfer(staker, amount), \"withdraw: can not transfer knc\");\r\n        emit Withdraw(curEpoch, staker, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev initialize data if needed, then return staker's data for current epoch\r\n     * @dev for safe, only allow calling this func from KyberDao address\r\n     * @param staker - staker's address to initialize and get data for\r\n     */\r\n    function initAndReturnStakerDataForCurrentEpoch(address staker)\r\n        external\r\n        override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        require(\r\n            msg.sender == address(kyberDao),\r\n            \"initAndReturnData: only kyberDao\"\r\n        );\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        initDataIfNeeded(staker, curEpoch);\r\n\r\n        StakerData memory stakerData = stakerPerEpochData[curEpoch][staker];\r\n        stake = stakerData.stake;\r\n        delegatedStake = stakerData.delegatedStake;\r\n        representative = stakerData.representative;\r\n    }\r\n\r\n    /**\r\n     * @notice return raw data of a staker for an epoch\r\n     *         WARN: should be used only for initialized data\r\n     *          if data has not been initialized, it will return all 0\r\n     *          pool master shouldn't use this function to compute/distribute rewards of pool members\r\n     * @dev  in KyberDao contract, if staker wants to claim reward for past epoch,\r\n     *       we must know the staker's data for that epoch\r\n     *       if the data has not been initialized, it means staker hasn't done any action -> no reward\r\n     */\r\n    function getStakerRawData(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        StakerData memory stakerData = stakerPerEpochData[epoch][staker];\r\n        stake = stakerData.stake;\r\n        delegatedStake = stakerData.delegatedStake;\r\n        representative = stakerData.representative;\r\n    }\r\n\r\n    /**\r\n     * @dev allow to get data up to current epoch + 1\r\n     */\r\n    function getStake(address staker, uint256 epoch) external view returns (uint256) {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return 0;\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                return stakerPerEpochData[i][staker].stake;\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev allow to get data up to current epoch + 1\r\n     */\r\n    function getDelegatedStake(address staker, uint256 epoch) external view returns (uint256) {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return 0;\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                return stakerPerEpochData[i][staker].delegatedStake;\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev allow to get data up to current epoch + 1\r\n     */\r\n    function getRepresentative(address staker, uint256 epoch) external view returns (address) {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return address(0);\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                return stakerPerEpochData[i][staker].representative;\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        // not delegated to anyone, default to yourself\r\n        return staker;\r\n    }\r\n\r\n    /**\r\n     * @notice return combine data (stake, delegatedStake, representative) of a staker\r\n     * @dev allow to get staker data up to current epoch + 1\r\n     */\r\n    function getStakerData(address staker, uint256 epoch)\r\n        external view override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        stake = 0;\r\n        delegatedStake = 0;\r\n        representative = address(0);\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return (stake, delegatedStake, representative);\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                stake = stakerPerEpochData[i][staker].stake;\r\n                delegatedStake = stakerPerEpochData[i][staker].delegatedStake;\r\n                representative = stakerPerEpochData[i][staker].representative;\r\n                return (stake, delegatedStake, representative);\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        // not delegated to anyone, default to yourself\r\n        representative = staker;\r\n    }\r\n\r\n    function getLatestRepresentative(address staker) external view returns (address) {\r\n        return\r\n            stakerLatestData[staker].representative == address(0)\r\n                ? staker\r\n                : stakerLatestData[staker].representative;\r\n    }\r\n\r\n    function getLatestDelegatedStake(address staker) external view returns (uint256) {\r\n        return stakerLatestData[staker].delegatedStake;\r\n    }\r\n\r\n    function getLatestStakeBalance(address staker) external view returns (uint256) {\r\n        return stakerLatestData[staker].stake;\r\n    }\r\n\r\n    function getLatestStakerData(address staker)\r\n        external view override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        stake = stakerLatestData[staker].stake;\r\n        delegatedStake = stakerLatestData[staker].delegatedStake;\r\n        representative = stakerLatestData[staker].representative == address(0)\r\n                ? staker\r\n                : stakerLatestData[staker].representative;\r\n    }\r\n\r\n    /**\r\n    * @dev  separate logics from withdraw, so staker can withdraw as long as amount <= staker's deposit amount\r\n            calling this function from withdraw function, ignore reverting\r\n    * @param staker staker that is withdrawing\r\n    * @param amount amount to withdraw\r\n    * @param curEpoch current epoch\r\n    */\r\n    function handleWithdrawal(\r\n        address staker,\r\n        uint256 amount,\r\n        uint256 curEpoch\r\n    ) external {\r\n        require(msg.sender == address(this), \"only staking contract\");\r\n        initDataIfNeeded(staker, curEpoch);\r\n        // Note: update latest stake will be done after this function\r\n        // update staker's data for next epoch\r\n        stakerPerEpochData[curEpoch + 1][staker].stake =\r\n            stakerPerEpochData[curEpoch + 1][staker].stake.sub(amount);\r\n\r\n        address representative = stakerPerEpochData[curEpoch][staker].representative;\r\n        uint256 curStake = stakerPerEpochData[curEpoch][staker].stake;\r\n        uint256 lStakeBal = stakerLatestData[staker].stake.sub(amount);\r\n        uint256 newStake = curStake.min(lStakeBal);\r\n        uint256 reduceAmount = curStake.sub(newStake); // newStake is always <= curStake\r\n\r\n        if (reduceAmount > 0) {\r\n            if (representative != staker) {\r\n                initDataIfNeeded(representative, curEpoch);\r\n                // staker has delegated to representative, withdraw will affect representative's delegated stakes\r\n                stakerPerEpochData[curEpoch][representative].delegatedStake =\r\n                    stakerPerEpochData[curEpoch][representative].delegatedStake.sub(reduceAmount);\r\n            }\r\n            stakerPerEpochData[curEpoch][staker].stake = newStake;\r\n            // call KyberDao to reduce reward, if staker has delegated, then pass his representative\r\n            if (address(kyberDao) != address(0)) {\r\n                // don't revert if KyberDao revert so data will be updated correctly\r\n                (bool success, ) = address(kyberDao).call(\r\n                    abi.encodeWithSignature(\r\n                        \"handleWithdrawal(address,uint256)\",\r\n                        representative,\r\n                        reduceAmount\r\n                    )\r\n                );\r\n                if (!success) {\r\n                    emit WithdrawDataUpdateFailed(curEpoch, staker, amount);\r\n                }\r\n            }\r\n        }\r\n        representative = stakerPerEpochData[curEpoch + 1][staker].representative;\r\n        if (representative != staker) {\r\n            initDataIfNeeded(representative, curEpoch);\r\n            stakerPerEpochData[curEpoch + 1][representative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][representative].delegatedStake.sub(amount);\r\n            stakerLatestData[representative].delegatedStake =\r\n                stakerLatestData[representative].delegatedStake.sub(amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev initialize data if it has not been initialized yet\r\n     * @param staker staker's address to initialize\r\n     * @param epoch should be current epoch\r\n     */\r\n    function initDataIfNeeded(address staker, uint256 epoch) internal {\r\n        address representative = stakerLatestData[staker].representative;\r\n        if (representative == address(0)) {\r\n            // not delegate to anyone, consider as delegate to yourself\r\n            stakerLatestData[staker].representative = staker;\r\n            representative = staker;\r\n        }\r\n\r\n        uint256 ldStake = stakerLatestData[staker].delegatedStake;\r\n        uint256 lStakeBal = stakerLatestData[staker].stake;\r\n\r\n        if (!hasInited[epoch][staker]) {\r\n            hasInited[epoch][staker] = true;\r\n            StakerData storage stakerData = stakerPerEpochData[epoch][staker];\r\n            stakerData.representative = representative;\r\n            stakerData.delegatedStake = ldStake;\r\n            stakerData.stake = lStakeBal;\r\n        }\r\n\r\n        // whenever stakers deposit/withdraw/delegate, the current and next epoch data need to be updated\r\n        // as the result, we will also initialize data for staker at the next epoch\r\n        if (!hasInited[epoch + 1][staker]) {\r\n            hasInited[epoch + 1][staker] = true;\r\n            StakerData storage nextEpochStakerData = stakerPerEpochData[epoch + 1][staker];\r\n            nextEpochStakerData.representative = representative;\r\n            nextEpochStakerData.delegatedStake = ldStake;\r\n            nextEpochStakerData.stake = lStakeBal;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/utils/Utils5.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @title Kyber utility file\r\n * mostly shared constants and rate calculation helpers\r\n * inherited by most of kyber contracts.\r\n * previous utils implementations are for previous solidity versions.\r\n */\r\ncontract Utils5 {\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    uint256 internal constant PRECISION = (10**18);\r\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\r\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\r\n    uint256 internal constant MAX_DECIMALS = 18;\r\n    uint256 internal constant ETH_DECIMALS = 18;\r\n    uint256 constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\r\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\r\n\r\n    mapping(IERC20 => uint256) internal decimals;\r\n\r\n    function getUpdateDecimals(IERC20 token) internal returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) {\r\n            tokenDecimals = token.decimals();\r\n            decimals[token] = tokenDecimals;\r\n        }\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function setDecimals(IERC20 token) internal {\r\n        if (decimals[token] != 0) return; //already set\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            decimals[token] = ETH_DECIMALS;\r\n        } else {\r\n            decimals[token] = token.decimals();\r\n        }\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(IERC20 token, address user) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return user.balance;\r\n        } else {\r\n            return token.balanceOf(user);\r\n        }\r\n    }\r\n\r\n    function getDecimals(IERC20 token) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDestAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 destAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcDstQty(\r\n        uint256 srcQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(\r\n        uint256 dstQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcRateFromQty(\r\n        uint256 srcAmount,\r\n        uint256 destAmount,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals\r\n    ) internal pure returns (uint256) {\r\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/KyberDao.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice  This contract is using SafeMath for uint, which is inherited from EpochUtils\r\n            Some events are moved to interface, easier for public uses\r\n * @dev Network fee campaign: options are fee in bps\r\n *      BRR fee handler campaign: options are combined of rebate (left most 128 bits) + reward (right most 128 bits)\r\n *      General campaign: options are from 1 to num_options\r\n */\r\ncontract KyberDao is IKyberDao, EpochUtils, ReentrancyGuard, Utils5, DaoOperator {\r\n    // max number of campaigns for each epoch\r\n    uint256 public   constant MAX_EPOCH_CAMPAIGNS = 10;\r\n    // max number of options for each campaign\r\n    uint256 public   constant MAX_CAMPAIGN_OPTIONS = 8;\r\n    uint256 internal constant POWER_128 = 2**128;\r\n\r\n    enum CampaignType {General, NetworkFee, FeeHandlerBRR}\r\n\r\n    struct FormulaData {\r\n        uint256 minPercentageInPrecision;\r\n        uint256 cInPrecision;\r\n        uint256 tInPrecision;\r\n    }\r\n\r\n    struct CampaignVoteData {\r\n        uint256 totalVotes;\r\n        uint256[] votePerOption;\r\n    }\r\n\r\n    struct Campaign {\r\n        CampaignType campaignType;\r\n        bool campaignExists;\r\n        uint256 startTimestamp;\r\n        uint256 endTimestamp;\r\n        uint256 totalKNCSupply; // total KNC supply at the time campaign was created\r\n        FormulaData formulaData; // formula params for concluding campaign result\r\n        bytes link; // link to KIP, explaination of options, etc.\r\n        uint256[] options; // data of options\r\n        CampaignVoteData campaignVoteData; // campaign vote data: total votes + vote per option\r\n    }\r\n\r\n    struct BRRData {\r\n        uint256 rewardInBps;\r\n        uint256 rebateInBps;\r\n    }\r\n\r\n    uint256 public minCampaignDurationInSeconds = 15 minutes;\r\n    IERC20 public immutable kncToken;\r\n    IKyberStaking public immutable staking;\r\n\r\n    // use to generate increasing campaign ID\r\n    uint256 public numberCampaigns = 0;\r\n    mapping(uint256 => Campaign) internal campaignData;\r\n\r\n    // epochCampaigns[epoch]: list campaign IDs for an epoch (epoch => campaign IDs)\r\n    mapping(uint256 => uint256[]) internal epochCampaigns;\r\n    // totalEpochPoints[epoch]: total points for an epoch (epoch => total points)\r\n    mapping(uint256 => uint256) internal totalEpochPoints;\r\n    // numberVotes[staker][epoch]: number of campaigns that the staker has voted in an epoch\r\n    mapping(address => mapping(uint256 => uint256)) public numberVotes;\r\n    // stakerVotedOption[staker][campaignID]: staker's voted option ID for a campaign\r\n    mapping(address => mapping(uint256 => uint256)) public stakerVotedOption;\r\n\r\n    uint256 internal latestNetworkFeeResult;\r\n    // epoch => campaignID for network fee campaigns\r\n    mapping(uint256 => uint256) public networkFeeCampaigns;\r\n    // latest BRR data (reward and rebate in bps)\r\n    BRRData internal latestBrrData;\r\n    // epoch => campaignID for brr campaigns\r\n    mapping(uint256 => uint256) public brrCampaigns;\r\n\r\n    event NewCampaignCreated(\r\n        CampaignType campaignType,\r\n        uint256 indexed campaignID,\r\n        uint256 startTimestamp,\r\n        uint256 endTimestamp,\r\n        uint256 minPercentageInPrecision,\r\n        uint256 cInPrecision,\r\n        uint256 tInPrecision,\r\n        uint256[] options,\r\n        bytes link\r\n    );\r\n\r\n    event CancelledCampaign(uint256 indexed campaignID);\r\n\r\n    constructor(\r\n        uint256 _epochPeriod,\r\n        uint256 _startTimestamp,\r\n        IERC20 _knc,\r\n        uint256 _defaultNetworkFeeBps,\r\n        uint256 _defaultRewardBps,\r\n        uint256 _defaultRebateBps,\r\n        address _daoOperator\r\n    ) public DaoOperator(_daoOperator) {\r\n        require(_epochPeriod > 0, \"ctor: epoch period is 0\");\r\n        require(_startTimestamp >= now, \"ctor: start in the past\");\r\n        require(_knc != IERC20(0), \"ctor: knc token 0\");\r\n        // in Network, maximum fee that can be taken from 1 tx is (platform fee + 2 * network fee)\r\n        // so network fee should be less than 50%\r\n        require(_defaultNetworkFeeBps < BPS / 2, \"ctor: network fee high\");\r\n        require(_defaultRewardBps.add(_defaultRebateBps) <= BPS, \"reward plus rebate high\");\r\n\r\n        epochPeriodInSeconds = _epochPeriod;\r\n        firstEpochStartTimestamp = _startTimestamp;\r\n        kncToken = _knc;\r\n\r\n        latestNetworkFeeResult = _defaultNetworkFeeBps;\r\n        latestBrrData = BRRData({\r\n            rewardInBps: _defaultRewardBps,\r\n            rebateInBps: _defaultRebateBps\r\n        });\r\n\r\n        // deploy staking contract \r\n        staking = new KyberStaking({\r\n            _kncToken: _knc,\r\n            _epochPeriod: _epochPeriod,\r\n            _startTimestamp: _startTimestamp,\r\n            _kyberDao: IKyberDao(this)\r\n        });\r\n    }\r\n\r\n    modifier onlyStakingContract {\r\n        require(msg.sender == address(staking), \"only staking contract\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by staking contract when staker wanted to withdraw\r\n     * @param staker address of staker to reduce reward\r\n     * @param reduceAmount amount voting power to be reduced for each campaign staker has voted at this epoch\r\n     */\r\n    function handleWithdrawal(address staker, uint256 reduceAmount) external override onlyStakingContract {\r\n        // staking shouldn't call this func with reduce amount = 0\r\n        if (reduceAmount == 0) {\r\n            return;\r\n        }\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n\r\n        uint256 numVotes = numberVotes[staker][curEpoch];\r\n        // staker has not participated in any campaigns at the current epoch\r\n        if (numVotes == 0) {\r\n            return;\r\n        }\r\n\r\n        // update total points for current epoch\r\n        totalEpochPoints[curEpoch] = totalEpochPoints[curEpoch].sub(numVotes.mul(reduceAmount));\r\n\r\n        // update voted count for each campaign staker has voted\r\n        uint256[] memory campaignIDs = epochCampaigns[curEpoch];\r\n\r\n        for (uint256 i = 0; i < campaignIDs.length; i++) {\r\n            uint256 campaignID = campaignIDs[i];\r\n\r\n            uint256 votedOption = stakerVotedOption[staker][campaignID];\r\n            if (votedOption == 0) {\r\n                continue;\r\n            } // staker has not voted yet\r\n\r\n            Campaign storage campaign = campaignData[campaignID];\r\n            if (campaign.endTimestamp >= now) {\r\n                // the staker has voted for this campaign and the campaign has not ended yet\r\n                // reduce total votes and vote count of staker's voted option\r\n                campaign.campaignVoteData.totalVotes =\r\n                    campaign.campaignVoteData.totalVotes.sub(reduceAmount);\r\n                campaign.campaignVoteData.votePerOption[votedOption - 1] =\r\n                    campaign.campaignVoteData.votePerOption[votedOption - 1].sub(reduceAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev create new campaign, only called by daoOperator\r\n     * @param campaignType type of campaign (General, NetworkFee, FeeHandlerBRR)\r\n     * @param startTimestamp timestamp to start running the campaign\r\n     * @param endTimestamp timestamp to end this campaign\r\n     * @param minPercentageInPrecision min percentage (in precision) for formula to conclude campaign\r\n     * @param cInPrecision c value (in precision) for formula to conclude campaign\r\n     * @param tInPrecision t value (in precision) for formula to conclude campaign\r\n     * @param options list values of options to vote for this campaign\r\n     * @param link additional data for this campaign\r\n     */\r\n    function submitNewCampaign(\r\n        CampaignType campaignType,\r\n        uint256 startTimestamp,\r\n        uint256 endTimestamp,\r\n        uint256 minPercentageInPrecision,\r\n        uint256 cInPrecision,\r\n        uint256 tInPrecision,\r\n        uint256[] calldata options,\r\n        bytes calldata link\r\n    ) external onlyDaoOperator returns (uint256 campaignID) {\r\n        // campaign epoch could be different from current epoch\r\n        // as we allow to create campaign of next epoch as well\r\n        uint256 campaignEpoch = getEpochNumber(startTimestamp);\r\n\r\n        validateCampaignParams(\r\n            campaignType,\r\n            startTimestamp,\r\n            endTimestamp,\r\n            minPercentageInPrecision,\r\n            cInPrecision,\r\n            tInPrecision,\r\n            options\r\n        );\r\n\r\n        numberCampaigns = numberCampaigns.add(1);\r\n        campaignID = numberCampaigns;\r\n\r\n        // add campaignID into the list campaign IDs\r\n        epochCampaigns[campaignEpoch].push(campaignID);\r\n        // update network fee or fee handler brr campaigns\r\n        if (campaignType == CampaignType.NetworkFee) {\r\n            networkFeeCampaigns[campaignEpoch] = campaignID;\r\n        } else if (campaignType == CampaignType.FeeHandlerBRR) {\r\n            brrCampaigns[campaignEpoch] = campaignID;\r\n        }\r\n\r\n        FormulaData memory formulaData = FormulaData({\r\n            minPercentageInPrecision: minPercentageInPrecision,\r\n            cInPrecision: cInPrecision,\r\n            tInPrecision: tInPrecision\r\n        });\r\n        CampaignVoteData memory campaignVoteData = CampaignVoteData({\r\n            totalVotes: 0,\r\n            votePerOption: new uint256[](options.length)\r\n        });\r\n\r\n        campaignData[campaignID] = Campaign({\r\n            campaignExists: true,\r\n            campaignType: campaignType,\r\n            startTimestamp: startTimestamp,\r\n            endTimestamp: endTimestamp,\r\n            totalKNCSupply: kncToken.totalSupply(),\r\n            link: link,\r\n            formulaData: formulaData,\r\n            options: options,\r\n            campaignVoteData: campaignVoteData\r\n        });\r\n\r\n        emit NewCampaignCreated(\r\n            campaignType,\r\n            campaignID,\r\n            startTimestamp,\r\n            endTimestamp,\r\n            minPercentageInPrecision,\r\n            cInPrecision,\r\n            tInPrecision,\r\n            options,\r\n            link\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev  cancel a campaign with given id, called by daoOperator only\r\n     *       only can cancel campaigns that have not started yet\r\n     * @param campaignID id of the campaign to cancel\r\n     */\r\n    function cancelCampaign(uint256 campaignID) external onlyDaoOperator {\r\n        Campaign storage campaign = campaignData[campaignID];\r\n        require(campaign.campaignExists, \"cancelCampaign: campaignID doesn't exist\");\r\n\r\n        require(campaign.startTimestamp > now, \"cancelCampaign: campaign already started\");\r\n\r\n        uint256 epoch = getEpochNumber(campaign.startTimestamp);\r\n\r\n        if (campaign.campaignType == CampaignType.NetworkFee) {\r\n            delete networkFeeCampaigns[epoch];\r\n        } else if (campaign.campaignType == CampaignType.FeeHandlerBRR) {\r\n            delete brrCampaigns[epoch];\r\n        }\r\n\r\n        delete campaignData[campaignID];\r\n\r\n        uint256[] storage campaignIDs = epochCampaigns[epoch];\r\n        for (uint256 i = 0; i < campaignIDs.length; i++) {\r\n            if (campaignIDs[i] == campaignID) {\r\n                // remove this campaign id out of list\r\n                campaignIDs[i] = campaignIDs[campaignIDs.length - 1];\r\n                campaignIDs.pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit CancelledCampaign(campaignID);\r\n    }\r\n\r\n    /**\r\n     * @dev  vote for an option of a campaign\r\n     *       options are indexed from 1 to number of options\r\n     * @param campaignID id of campaign to vote for\r\n     * @param option id of options to vote for\r\n     */\r\n    function vote(uint256 campaignID, uint256 option) external override {\r\n        validateVoteOption(campaignID, option);\r\n        address staker = msg.sender;\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        (uint256 stake, uint256 dStake, address representative) =\r\n            staking.initAndReturnStakerDataForCurrentEpoch(staker);\r\n\r\n        uint256 totalStake = representative == staker ? stake.add(dStake) : dStake;\r\n        uint256 lastVotedOption = stakerVotedOption[staker][campaignID];\r\n\r\n        CampaignVoteData storage voteData = campaignData[campaignID].campaignVoteData;\r\n\r\n        if (lastVotedOption == 0) {\r\n            // increase number campaigns that the staker has voted at the current epoch\r\n            numberVotes[staker][curEpoch]++;\r\n\r\n            totalEpochPoints[curEpoch] = totalEpochPoints[curEpoch].add(totalStake);\r\n            // increase voted count for this option\r\n            voteData.votePerOption[option - 1] =\r\n                voteData.votePerOption[option - 1].add(totalStake);\r\n            // increase total votes\r\n            voteData.totalVotes = voteData.totalVotes.add(totalStake);\r\n        } else if (lastVotedOption != option) {\r\n            // deduce previous option voted count\r\n            voteData.votePerOption[lastVotedOption - 1] =\r\n                voteData.votePerOption[lastVotedOption - 1].sub(totalStake);\r\n            // increase new option voted count\r\n            voteData.votePerOption[option - 1] =\r\n                voteData.votePerOption[option - 1].add(totalStake);\r\n        }\r\n\r\n        stakerVotedOption[staker][campaignID] = option;\r\n\r\n        emit Voted(staker, curEpoch, campaignID, option);\r\n    }\r\n\r\n    /**\r\n     * @dev get latest network fee data + expiry timestamp\r\n     *    conclude network fee campaign if needed and caching latest result in KyberDao\r\n     */\r\n    function getLatestNetworkFeeDataWithCache()\r\n        external\r\n        override\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp)\r\n    {\r\n        (feeInBps, expiryTimestamp) = getLatestNetworkFeeData();\r\n        // cache latest data\r\n        latestNetworkFeeResult = feeInBps;\r\n    }\r\n\r\n    /**\r\n     * @dev return latest burn/reward/rebate data, also affecting epoch + expiry timestamp\r\n     *      conclude brr campaign if needed and caching latest result in KyberDao\r\n     */\r\n    function getLatestBRRDataWithCache()\r\n        external\r\n        override\r\n        returns (\r\n            uint256 burnInBps,\r\n            uint256 rewardInBps,\r\n            uint256 rebateInBps,\r\n            uint256 epoch,\r\n            uint256 expiryTimestamp\r\n        )\r\n    {\r\n        (burnInBps, rewardInBps, rebateInBps, epoch, expiryTimestamp) = getLatestBRRData();\r\n        latestBrrData.rewardInBps = rewardInBps;\r\n        latestBrrData.rebateInBps = rebateInBps;\r\n    }\r\n\r\n    /**\r\n     * @dev some epochs have reward but no one can claim, for example: epoch 0\r\n     *      return true if should burn all that reward\r\n     * @param epoch epoch to check for burning reward\r\n     */\r\n    function shouldBurnRewardForEpoch(uint256 epoch) external view override returns (bool) {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch >= curEpoch) {\r\n            return false;\r\n        }\r\n        return totalEpochPoints[epoch] == 0;\r\n    }\r\n\r\n    // return list campaign ids for epoch, excluding non-existed ones\r\n    function getListCampaignIDs(uint256 epoch) external view returns (uint256[] memory campaignIDs) {\r\n        campaignIDs = epochCampaigns[epoch];\r\n    }\r\n\r\n    // return total points for an epoch\r\n    function getTotalEpochPoints(uint256 epoch) external view returns (uint256) {\r\n        return totalEpochPoints[epoch];\r\n    }\r\n\r\n    function getCampaignDetails(uint256 campaignID)\r\n        external\r\n        view\r\n        returns (\r\n            CampaignType campaignType,\r\n            uint256 startTimestamp,\r\n            uint256 endTimestamp,\r\n            uint256 totalKNCSupply,\r\n            uint256 minPercentageInPrecision,\r\n            uint256 cInPrecision,\r\n            uint256 tInPrecision,\r\n            bytes memory link,\r\n            uint256[] memory options\r\n        )\r\n    {\r\n        Campaign storage campaign = campaignData[campaignID];\r\n        campaignType = campaign.campaignType;\r\n        startTimestamp = campaign.startTimestamp;\r\n        endTimestamp = campaign.endTimestamp;\r\n        totalKNCSupply = campaign.totalKNCSupply;\r\n        minPercentageInPrecision = campaign.formulaData.minPercentageInPrecision;\r\n        cInPrecision = campaign.formulaData.cInPrecision;\r\n        tInPrecision = campaign.formulaData.tInPrecision;\r\n        link = campaign.link;\r\n        options = campaign.options;\r\n    }\r\n\r\n    function getCampaignVoteCountData(uint256 campaignID)\r\n        external\r\n        view\r\n        returns (uint256[] memory voteCounts, uint256 totalVoteCount)\r\n    {\r\n        CampaignVoteData memory voteData = campaignData[campaignID].campaignVoteData;\r\n        totalVoteCount = voteData.totalVotes;\r\n        voteCounts = voteData.votePerOption;\r\n    }\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for a past epoch only\r\n     *       fee handler should call this function when a staker wants to claim reward\r\n     *       return 0 if staker has no votes or stakes\r\n     */\r\n    function getPastEpochRewardPercentageInPrecision(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        // return 0 if epoch is not past epoch\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch >= curEpoch) {\r\n            return 0;\r\n        }\r\n\r\n        return getRewardPercentageInPrecision(staker, epoch);\r\n    }\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for the current epoch\r\n     */\r\n    function getCurrentEpochRewardPercentageInPrecision(address staker)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        return getRewardPercentageInPrecision(staker, curEpoch);\r\n    }\r\n\r\n    /**\r\n     * @dev return campaign winning option and its value\r\n     *      return (0, 0) if campaign does not exist\r\n     *      return (0, 0) if campaign has not ended yet\r\n     *      return (0, 0) if campaign has no winning option based on the formula\r\n     * @param campaignID id of campaign to get result\r\n     */\r\n    function getCampaignWinningOptionAndValue(uint256 campaignID)\r\n        public\r\n        view\r\n        returns (uint256 optionID, uint256 value)\r\n    {\r\n        Campaign storage campaign = campaignData[campaignID];\r\n        if (!campaign.campaignExists) {\r\n            return (0, 0);\r\n        } // not exist\r\n\r\n        // campaign has not ended yet, return 0 as winning option\r\n        if (campaign.endTimestamp > now) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint256 totalSupply = campaign.totalKNCSupply;\r\n        // something is wrong here, total KNC supply shouldn't be 0\r\n        if (totalSupply == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint256 totalVotes = campaign.campaignVoteData.totalVotes;\r\n        uint256[] memory voteCounts = campaign.campaignVoteData.votePerOption;\r\n\r\n        // Finding option with most votes\r\n        uint256 winningOption = 0;\r\n        uint256 maxVotedCount = 0;\r\n        for (uint256 i = 0; i < voteCounts.length; i++) {\r\n            if (voteCounts[i] > maxVotedCount) {\r\n                winningOption = i + 1;\r\n                maxVotedCount = voteCounts[i];\r\n            } else if (voteCounts[i] == maxVotedCount) {\r\n                winningOption = 0;\r\n            }\r\n        }\r\n\r\n        // more than 1 options have same vote count\r\n        if (winningOption == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        FormulaData memory formulaData = campaign.formulaData;\r\n\r\n        // compute voted percentage (in precision)\r\n        uint256 votedPercentage = totalVotes.mul(PRECISION).div(campaign.totalKNCSupply);\r\n\r\n        // total voted percentage is below min acceptable percentage, no winning option\r\n        if (formulaData.minPercentageInPrecision > votedPercentage) {\r\n            return (0, 0);\r\n        }\r\n\r\n        // as we already limit value for c & t, no need to check for overflow here\r\n        uint256 x = formulaData.tInPrecision.mul(votedPercentage).div(PRECISION);\r\n        if (x <= formulaData.cInPrecision) {\r\n            // threshold is not negative, need to compare with voted count\r\n            uint256 y = formulaData.cInPrecision.sub(x);\r\n            // (most voted option count / total votes) is below threshold, no winining option\r\n            if (maxVotedCount.mul(PRECISION) < y.mul(totalVotes)) {\r\n                return (0, 0);\r\n            }\r\n        }\r\n\r\n        optionID = winningOption;\r\n        value = campaign.options[optionID - 1];\r\n    }\r\n\r\n    /**\r\n     * @dev return latest network fee and expiry timestamp\r\n     */\r\n    function getLatestNetworkFeeData()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp)\r\n    {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        feeInBps = latestNetworkFeeResult;\r\n        // expiryTimestamp = firstEpochStartTimestamp + curEpoch * epochPeriodInSeconds - 1;\r\n        expiryTimestamp = firstEpochStartTimestamp.add(curEpoch.mul(epochPeriodInSeconds)).sub(1);\r\n        if (curEpoch == 0) {\r\n            return (feeInBps, expiryTimestamp);\r\n        }\r\n        uint256 campaignID = networkFeeCampaigns[curEpoch.sub(1)];\r\n        if (campaignID == 0) {\r\n            // don't have network fee campaign, return latest result\r\n            return (feeInBps, expiryTimestamp);\r\n        }\r\n\r\n        uint256 winningOption;\r\n        (winningOption, feeInBps) = getCampaignWinningOptionAndValue(campaignID);\r\n        if (winningOption == 0) {\r\n            // fallback to previous result\r\n            feeInBps = latestNetworkFeeResult;\r\n        }\r\n        return (feeInBps, expiryTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev return latest brr result, conclude brr campaign if needed\r\n     */\r\n    function getLatestBRRData()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 burnInBps,\r\n            uint256 rewardInBps,\r\n            uint256 rebateInBps,\r\n            uint256 epoch,\r\n            uint256 expiryTimestamp\r\n        )\r\n    {\r\n        epoch = getCurrentEpochNumber();\r\n        // expiryTimestamp = firstEpochStartTimestamp + epoch * epochPeriodInSeconds - 1;\r\n        expiryTimestamp = firstEpochStartTimestamp.add(epoch.mul(epochPeriodInSeconds)).sub(1);\r\n        rewardInBps = latestBrrData.rewardInBps;\r\n        rebateInBps = latestBrrData.rebateInBps;\r\n\r\n        if (epoch > 0) {\r\n            uint256 campaignID = brrCampaigns[epoch.sub(1)];\r\n            if (campaignID != 0) {\r\n                uint256 winningOption;\r\n                uint256 brrData;\r\n                (winningOption, brrData) = getCampaignWinningOptionAndValue(campaignID);\r\n                if (winningOption > 0) {\r\n                    // has winning option, update reward and rebate value\r\n                    (rebateInBps, rewardInBps) = getRebateAndRewardFromData(brrData);\r\n                }\r\n            }\r\n        }\r\n\r\n        burnInBps = BPS.sub(rebateInBps).sub(rewardInBps);\r\n    }\r\n\r\n    // Helper functions for squeezing data\r\n    function getRebateAndRewardFromData(uint256 data)\r\n        public\r\n        pure\r\n        returns (uint256 rebateInBps, uint256 rewardInBps)\r\n    {\r\n        rewardInBps = data & (POWER_128.sub(1));\r\n        rebateInBps = (data.div(POWER_128)) & (POWER_128.sub(1));\r\n    }\r\n\r\n    /**\r\n     * @dev  helper func to get encoded reward and rebate\r\n     *       revert if validation failed\r\n     */\r\n    function getDataFromRewardAndRebateWithValidation(uint256 rewardInBps, uint256 rebateInBps)\r\n        public\r\n        pure\r\n        returns (uint256 data)\r\n    {\r\n        require(rewardInBps.add(rebateInBps) <= BPS, \"reward plus rebate high\");\r\n        data = (rebateInBps.mul(POWER_128)).add(rewardInBps);\r\n    }\r\n\r\n    /**\r\n     * @dev options are indexed from 1\r\n     */\r\n    function validateVoteOption(uint256 campaignID, uint256 option) internal view {\r\n        Campaign storage campaign = campaignData[campaignID];\r\n        require(campaign.campaignExists, \"vote: campaign doesn't exist\");\r\n\r\n        require(campaign.startTimestamp <= now, \"vote: campaign not started\");\r\n        require(campaign.endTimestamp >= now, \"vote: campaign already ended\");\r\n\r\n        // option is indexed from 1 to options.length\r\n        require(option > 0, \"vote: option is 0\");\r\n        require(option <= campaign.options.length, \"vote: option is not in range\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate params to check if we could submit a new campaign with these params\r\n     */\r\n    function validateCampaignParams(\r\n        CampaignType campaignType,\r\n        uint256 startTimestamp,\r\n        uint256 endTimestamp,\r\n        uint256 minPercentageInPrecision,\r\n        uint256 cInPrecision,\r\n        uint256 tInPrecision,\r\n        uint256[] memory options\r\n    ) internal view {\r\n        // now <= start timestamp < end timestamp\r\n        require(startTimestamp >= now, \"validateParams: start in the past\");\r\n        // campaign duration must be at least min campaign duration\r\n        // endTimestamp - startTimestamp + 1 >= minCampaignDurationInSeconds,\r\n        require(\r\n            endTimestamp.add(1) >= startTimestamp.add(minCampaignDurationInSeconds),\r\n            \"validateParams: campaign duration is low\"\r\n        );\r\n\r\n        uint256 startEpoch = getEpochNumber(startTimestamp);\r\n        uint256 endEpoch = getEpochNumber(endTimestamp);\r\n\r\n        require(\r\n            epochCampaigns[startEpoch].length < MAX_EPOCH_CAMPAIGNS,\r\n            \"validateParams: too many campaigns\"\r\n        );\r\n\r\n        // start timestamp and end timestamp must be in the same epoch\r\n        require(startEpoch == endEpoch, \"validateParams: start & end not same epoch\");\r\n\r\n        uint256 currentEpoch = getCurrentEpochNumber();\r\n        require(\r\n            startEpoch <= currentEpoch.add(1),\r\n            \"validateParams: only for current or next epochs\"\r\n        );\r\n\r\n        // verify number of options\r\n        uint256 numOptions = options.length;\r\n        require(\r\n            numOptions > 1 && numOptions <= MAX_CAMPAIGN_OPTIONS,\r\n            \"validateParams: invalid number of options\"\r\n        );\r\n\r\n        // Validate option values based on campaign type\r\n        if (campaignType == CampaignType.General) {\r\n            // option must be positive number\r\n            for (uint256 i = 0; i < options.length; i++) {\r\n                require(options[i] > 0, \"validateParams: general campaign option is 0\");\r\n            }\r\n        } else if (campaignType == CampaignType.NetworkFee) {\r\n            require(\r\n                networkFeeCampaigns[startEpoch] == 0,\r\n                \"validateParams: already had network fee campaign for this epoch\"\r\n            );\r\n            // network fee campaign, option must be fee in bps\r\n            for (uint256 i = 0; i < options.length; i++) {\r\n                // in Network, maximum fee that can be taken from 1 tx is (platform fee + 2 * network fee)\r\n                // so network fee should be less than 50%\r\n                require(\r\n                    options[i] < BPS / 2,\r\n                    \"validateParams: network fee must be smaller then BPS / 2\"\r\n                );\r\n            }\r\n        } else {\r\n            require(\r\n                brrCampaigns[startEpoch] == 0,\r\n                \"validateParams: already had brr campaign for this epoch\"\r\n            );\r\n            // brr fee handler campaign, option must be combined for reward + rebate %\r\n            for (uint256 i = 0; i < options.length; i++) {\r\n                // rebate (left most 128 bits) + reward (right most 128 bits)\r\n                (uint256 rebateInBps, uint256 rewardInBps) =\r\n                    getRebateAndRewardFromData(options[i]);\r\n                require(\r\n                    rewardInBps.add(rebateInBps) <= BPS,\r\n                    \"validateParams: rebate + reward can't be bigger than BPS\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // percentage should be smaller than or equal 100%\r\n        require(minPercentageInPrecision <= PRECISION, \"validateParams: min percentage is high\");\r\n\r\n        // limit value of c and t to avoid overflow\r\n        require(cInPrecision < POWER_128, \"validateParams: c is high\");\r\n\r\n        require(tInPrecision < POWER_128, \"validateParams: t is high\");\r\n    }\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for an epoch\r\n     *       return 0 if staker has no votes or stakes\r\n     *       called by 2 functions in KyberDao\r\n     */\r\n    function getRewardPercentageInPrecision(address staker, uint256 epoch)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 numVotes = numberVotes[staker][epoch];\r\n        // no votes, no rewards\r\n        if (numVotes == 0) {\r\n            return 0;\r\n        }\r\n\r\n        (uint256 stake, uint256 delegatedStake, address representative) =\r\n            staking.getStakerRawData(staker, epoch);\r\n\r\n        uint256 totalStake = representative == staker ? stake.add(delegatedStake) : delegatedStake;\r\n        if (totalStake == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 points = numVotes.mul(totalStake);\r\n        uint256 totalPts = totalEpochPoints[epoch];\r\n\r\n        // staker's reward percentage should be <= 100%\r\n        assert(points <= totalPts);\r\n\r\n        return points.mul(PRECISION).div(totalPts);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_knc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_defaultNetworkFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defaultRewardBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defaultRebateBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_daoOperator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"}],\"name\":\"CancelledCampaign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum KyberDao.CampaignType\",\"name\":\"campaignType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPercentageInPrecision\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cInPrecision\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tInPrecision\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"options\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"link\",\"type\":\"bytes\"}],\"name\":\"NewCampaignCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_CAMPAIGN_OPTIONS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EPOCH_CAMPAIGNS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"brrCampaigns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"}],\"name\":\"cancelCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriodInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstEpochStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"}],\"name\":\"getCampaignDetails\",\"outputs\":[{\"internalType\":\"enum KyberDao.CampaignType\",\"name\":\"campaignType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalKNCSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPercentageInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"link\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"options\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"}],\"name\":\"getCampaignVoteCountData\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"voteCounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalVoteCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"}],\"name\":\"getCampaignWinningOptionAndValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getCurrentEpochRewardPercentageInPrecision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebateInBps\",\"type\":\"uint256\"}],\"name\":\"getDataFromRewardAndRebateWithValidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestBRRData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burnInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebateInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestBRRDataWithCache\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burnInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebateInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestNetworkFeeData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestNetworkFeeDataWithCache\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getListCampaignIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"campaignIDs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getPastEpochRewardPercentageInPrecision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"getRebateAndRewardFromData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rebateInBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardInBps\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getTotalEpochPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"}],\"name\":\"handleWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kncToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minCampaignDurationInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"networkFeeCampaigns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberCampaigns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numberVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"shouldBurnRewardForEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakerVotedOption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"contract IKyberStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum KyberDao.CampaignType\",\"name\":\"campaignType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPercentageInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"options\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"link\",\"type\":\"bytes\"}],\"name\":\"submitNewCampaign\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KyberDao","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"430","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000a8c000000000000000000000000000000000000000000000000000000005EFD5BC0000000000000000000000000dd974D5C2e2928deA5F71b9825b8b646686BD20000000000000000000000000000000000000000000000000000000000000001F4000000000000000000000000000000000000000000000000000000000000000A0000000000000000000000000000000000000000000000000000000000002706000000000000000000000000fdb39391184481df0f8e7d57c029f9bf8dbdaca8","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e226a6302b84b358849f5b5e0f541d9614dcdad0cedb6d983293d343b1243995"}]}