{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary NumbersList {\n    using SafeMath for uint256;\n\n    // Given a whole number percentage, multiply by it and then divide by this.\n    uint256 private constant PERCENTAGE_TO_DECIMAL = 10000;\n\n    // Holds values to can calculate the threshold of a list of numbers\n    struct Values {\n        uint256 count; // The total number of numbers added\n        uint256 max; // The maximum number that was added\n        uint256 min; // The minimum number that was added\n        uint256 sum; // The total sum of the numbers that were added\n    }\n\n    /**\n     * @dev Add to the sum while keeping track of min and max values\n     * @param self The Value this function was called on\n     * @param newValue Number to increment sum by\n     */\n    function addValue(Values storage self, uint256 newValue) internal {\n        if (self.max < newValue) {\n            self.max = newValue;\n        }\n        if (self.min > newValue || self.count == 0) {\n            self.min = newValue;\n        }\n        self.sum = self.sum.add(newValue);\n        self.count = self.count.add(1);\n    }\n\n    /**\n     * @param self The Value this function was called on\n     * @return the number of times the sum has updated\n     */\n    function valuesCount(Values storage self) internal view returns (uint256) {\n        return self.count;\n    }\n\n    /**\n     * @dev Checks if the sum has been changed\n     * @param self The Value this function was called on\n     * @return boolean\n     */\n    function isEmpty(Values storage self) internal view returns (bool) {\n        return valuesCount(self) == 0;\n    }\n\n    /**\n     * @dev Checks if the sum has been changed `totalRequiredValues` times\n     * @param self The Value this function was called on\n     * @param totalRequiredValues The maximum amount of numbers to be added to the sum\n     * @return boolean\n     */\n    function isFinalized(Values storage self, uint256 totalRequiredValues)\n        internal\n        view\n        returns (bool)\n    {\n        return valuesCount(self) >= totalRequiredValues;\n    }\n\n    /**\n     * @param self The Value this function was called on\n     * @return the average number that was used to calculate the sum\n     */\n    function getAverage(Values storage self) internal view returns (uint256) {\n        return isEmpty(self) ? 0 : self.sum.div(valuesCount(self));\n    }\n\n    /**\n     * @dev Checks if the min and max numbers are with in the acceptable tolerance\n     * @param self The Value this function was called on\n     * @param tolerancePercentage Acceptable tolerance percentage as a whole number\n     * @return boolean\n     */\n    function isWithinTolerance(Values storage self, uint256 tolerancePercentage)\n        internal\n        view\n        returns (bool)\n    {\n        if (isEmpty(self)) {\n            return false;\n        }\n        uint256 average = getAverage(self);\n        uint256 toleranceAmount = average.mul(tolerancePercentage).div(\n            PERCENTAGE_TO_DECIMAL\n        );\n\n        uint256 minTolerance = average.sub(toleranceAmount);\n        if (self.min < minTolerance) {\n            return false;\n        }\n\n        uint256 maxTolerance = average.add(toleranceAmount);\n        if (self.max > maxTolerance) {\n            return false;\n        }\n        return true;\n    }\n}\n\nlibrary TellerCommon {\n    enum LoanStatus {NonExistent, TermsSet, Active, Closed}\n\n    // The amount of interest owed to a borrower\n    // The interest is just that accrued until `timeLastAccrued`\n    struct AccruedInterest {\n        uint256 totalAccruedInterest;\n        uint256 totalNotWithdrawn;\n        uint256 timeLastAccrued;\n    }\n\n    // Represents a user signature\n    struct Signature {\n        uint256 signerNonce;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // Consensus request object for accruing interest\n    struct InterestRequest {\n        address lender;\n        address consensusAddress;\n        uint256 requestNonce;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 requestTime;\n    }\n\n    // Consensus response object for accruing interest\n    struct InterestResponse {\n        address signer;\n        address consensusAddress;\n        uint256 responseTime;\n        uint256 interest;\n        Signature signature;\n    }\n\n    // Borrower request object to take out a loan\n    struct LoanRequest {\n        address payable borrower;\n        address recipient;\n        address consensusAddress;\n        uint256 requestNonce;\n        uint256 amount;\n        uint256 duration;\n        uint256 requestTime;\n    }\n\n    // Borrower response object to take out a loan\n    struct LoanResponse {\n        address signer;\n        address consensusAddress;\n        uint256 responseTime;\n        uint256 interestRate;\n        uint256 collateralRatio;\n        uint256 maxLoanAmount;\n        Signature signature;\n    }\n\n    // Represents loan terms based on consensus values\n    struct AccruedLoanTerms {\n        NumbersList.Values interestRate;\n        NumbersList.Values collateralRatio;\n        NumbersList.Values maxLoanAmount;\n    }\n\n    // Represents the terms of a loan based on the consensus of a LoanRequest\n    struct LoanTerms {\n        address payable borrower;\n        address recipient;\n        uint256 interestRate;\n        uint256 collateralRatio;\n        uint256 maxLoanAmount;\n        uint256 duration;\n    }\n\n    // Data per borrow as struct\n    struct Loan {\n        uint256 id;\n        LoanTerms loanTerms;\n        uint256 termsExpiry;\n        uint256 loanStartTime;\n        uint256 collateral;\n        uint256 lastCollateralIn;\n        uint256 principalOwed;\n        uint256 interestOwed;\n        uint256 borrowedAmount;\n        LoanStatus status;\n        bool liquidated;\n    }\n}\n\ncontract SettingsConsts {\n    /** Constants */\n\n    /**\n        @notice The setting name for the required subsmission settings.\n     */\n    bytes32 public constant REQUIRED_SUBMISSIONS_SETTING = \"RequiredSubmissions\";\n    /**\n        @notice The setting name for the maximum tolerance settings.\n        @notice This is the maximum tolerance for the values submitted (by nodes) when they are aggregated (average). It is used in the consensus mechanisms.\n        @notice This is a percentage value with 2 decimal places.\n            i.e. maximumTolerance of 325 => tolerance of 3.25% => 0.0325 of value\n            i.e. maximumTolerance of 0 => It means all the values submitted must be equals.        \n        @dev The max value is 100% => 10000\n     */\n    bytes32 public constant MAXIMUM_TOLERANCE_SETTING = \"MaximumTolerance\";\n    /**\n        @notice The setting name for the response expiry length settings.\n        @notice This is the maximum time (in seconds) a node has to submit a response. After that time, the response is considered expired.\n     */\n    bytes32 public constant RESPONSE_EXPIRY_LENGTH_SETTING = \"ResponseExpiryLength\";\n    /**\n        @notice The setting name for the safety interval settings.\n        @notice This is the minimum time you need to wait (in seconds) between the last time you deposit collateral and you take out the loan.\n        @notice It is used to avoid potential attacks using Flash Loans (AAVE) or Flash Swaps (Uniswap V2).\n     */\n    bytes32 public constant SAFETY_INTERVAL_SETTING = \"SafetyInterval\";\n    /**\n        @notice The setting name for the term expiry time settings.\n        @notice This represents the time (in seconds) that loan terms will be available after requesting them.\n        @notice After this time, the loan terms will expire and the borrower will need to request it again.\n     */\n    bytes32 public constant TERMS_EXPIRY_TIME_SETTING = \"TermsExpiryTime\";\n    /**\n        @notice The setting name for the liquidate ETH price settings.\n        @notice It represents the percentage value (with 2 decimal places) to liquidate loans.\n            i.e. an ETH liquidation price at 95% is stored as 9500\n     */\n    bytes32 public constant LIQUIDATE_ETH_PRICE_SETTING = \"LiquidateEthPrice\";\n    /**\n        @notice The setting name for the maximum loan duration settings.\n        @notice The maximum loan duration setting is defined in seconds.\n     */\n    bytes32 public constant MAXIMUM_LOAN_DURATION_SETTING = \"MaximumLoanDuration\";\n    /**\n        @notice The setting name for the request loan terms rate limit settings.\n        @notice The request loan terms rate limit setting is defined in seconds.\n     */\n    bytes32 public constant REQUEST_LOAN_TERMS_RATE_LIMIT_SETTING = \"RequestLoanTermsRateLimit\";\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8);\n}\n\nlibrary ERC20Lib {\n    using SafeMath for uint256;\n\n    // Used to calculate one whole token.\n    uint256 internal constant TEN = 10;\n\n    /**\n        @notice Gets a whole token based on the token decimals.\n        @param self the current ERC20 instance.\n        @return a whole token value based on the decimals.\n     */\n    function getAWholeToken(ERC20 self) internal view returns (uint256) {\n        uint8 decimals = self.decimals();\n        return TEN**decimals;\n    }\n\n    /**\n        @notice It transfers an amount of tokens to a specific address.\n        @param self The current token instance.\n        @param recipient The address which will receive the tokens.\n        @param amount The amount of tokens to transfer.\n        @dev It throws a require error if 'transfer' invocation fails.\n     */\n    function tokenTransfer(ERC20 self, address recipient, uint256 amount) internal {\n        uint256 initialBalance = self.balanceOf(address(this));\n        require(initialBalance >= amount, \"NOT_ENOUGH_TOKENS_BALANCE\");\n\n        bool transferResult = self.transfer(recipient, amount);\n        require(transferResult, \"TOKENS_TRANSFER_FAILED\");\n\n        uint256 finalBalance = self.balanceOf(address(this));\n\n        require(initialBalance.sub(finalBalance) == amount, \"INV_BALANCE_AFTER_TRANSFER\");\n    }\n\n    /**\n        @notice It transfers an amount of tokens from an address to this contract.\n        @param self The current token instance.\n        @param from The address where the tokens will transfer from.\n        @param amount The amount to be transferred.\n        @dev It throws a require error if the allowance is not enough.\n        @dev It throws a require error if 'transferFrom' invocation fails.\n     */\n    function tokenTransferFrom(ERC20 self, address from, uint256 amount) internal {\n        uint256 currentAllowance = self.allowance(from, address(this));\n        require(currentAllowance >= amount, \"NOT_ENOUGH_TOKENS_ALLOWANCE\");\n\n        uint256 initialBalance = self.balanceOf(address(this));\n        bool transferFromResult = self.transferFrom(from, address(this), amount);\n        require(transferFromResult, \"TOKENS_TRANSFER_FROM_FAILED\");\n\n        uint256 finalBalance = self.balanceOf(address(this));\n        require(\n            finalBalance.sub(initialBalance) == amount,\n            \"INV_BALANCE_AFTER_TRANSFER_FROM\"\n        );\n    }\n}\n\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\ncontract ReentrancyGuard is Initializable {\n    // counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n\n    uint256[50] private ______gap;\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary AddressLib {\n    address public constant ADDRESS_EMPTY = address(0x0);\n\n    /**\n     * @dev Checks if this address is all 0s\n     * @param self The address this function was called on\n     * @return boolean\n     */\n    function isEmpty(address self) internal pure returns (bool) {\n        return self == ADDRESS_EMPTY;\n    }\n\n    /**\n     * @dev Checks if this address is the same as another address\n     * @param self The address this function was called on\n     * @param other Address to check against itself\n     * @return boolean\n     */\n    function isEqualTo(address self, address other) internal pure returns (bool) {\n        return self == other;\n    }\n\n    /**\n     * @dev Checks if this address is different to another address\n     * @param self The address this function was called on\n     * @param other Address to check against itself\n     * @return boolean\n     */\n    function isNotEqualTo(address self, address other) internal pure returns (bool) {\n        return self != other;\n    }\n\n    /**\n     * @dev Checks if this address is not all 0s\n     * @param self The address this function was called on\n     * @return boolean\n     */\n    function isNotEmpty(address self) internal pure returns (bool) {\n        return self != ADDRESS_EMPTY;\n    }\n\n    /**\n     * @dev Throws an error if address is all 0s\n     * @param self The address this function was called on\n     * @param message Error message if address is all 0s\n     */\n    function requireNotEmpty(address self, string memory message) internal pure {\n        require(isNotEmpty(self), message);\n    }\n\n    /**\n     * @dev Throws an error if address is not all 0s\n     * @param self The address this function was called on\n     * @param message Error message if address is not all 0s\n     */\n    function requireEmpty(address self, string memory message) internal pure {\n        require(isEmpty(self), message);\n    }\n\n    /**\n     * @dev Throws an error if address is not the same as another address\n     * @param self The address this function was called on\n     * @param other The address to check against itself\n     * @param message Error message if addresses are not the same\n     */\n    function requireEqualTo(address self, address other, string memory message)\n        internal\n        pure\n    {\n        require(isEqualTo(self, other), message);\n    }\n\n    /**\n     * @dev Throws an error if address is the same as another address\n     * @param self The address this function was called on\n     * @param other The address to check against itself\n     * @param message Error message if addresses are the same\n     */\n    function requireNotEqualTo(address self, address other, string memory message)\n        internal\n        pure\n    {\n        require(isNotEqualTo(self, other), message);\n    }\n}\n\ncontract TInitializable {\n    /* State Variables */\n\n    bool private _isInitialized;\n\n    /** Modifiers */\n\n    /**\n        @notice Checks whether the contract is initialized or not.\n        @dev It throws a require error if the contract is initialized.\n     */\n    modifier isNotInitialized() {\n        require(!_isInitialized, \"CONTRACT_ALREADY_INITIALIZED\");\n        _;\n    }\n\n    /**\n        @notice Checks whether the contract is initialized or not.\n        @dev It throws a require error if the contract is not initialized.\n     */\n    modifier isInitialized() {\n        require(_isInitialized, \"CONTRACT_NOT_INITIALIZED\");\n        _;\n    }\n\n    /* Constructor */\n\n    /** External Functions */\n\n    /**\n        @notice Gets if the contract is initialized.\n        @return true if contract is initialized. Otherwise it returns false.\n     */\n    function initialized() external view returns (bool) {\n        return _isInitialized;\n    }\n\n    /** Internal functions */\n\n    /**\n        @notice It initializes this contract.\n     */\n    function _initialize() internal {\n        _isInitialized = true;\n    }\n\n    /** Private functions */\n}\n\nlibrary AssetSettingsLib {\n    using SafeMath for uint256;\n    using AddressLib for address;\n    using Address for address;\n\n    /**\n        @notice This struct manages the asset settings in the platform.\n        @param cTokenAddress cToken address associated to the asset. \n        @param maxLoanAmount max loan amount configured for the asset.\n     */\n    struct AssetSettings {\n        // It prepresents the cTokenAddress or 0x0.\n        address cTokenAddress;\n        // It represents the maximum loan amount to borrow.\n        uint256 maxLoanAmount;\n    }\n\n    /**\n        @notice It initializes the struct instance with the given parameters.\n        @param cTokenAddress the initial cToken address.\n        @param maxLoanAmount the initial max loan amount.\n     */\n    function initialize(\n        AssetSettings storage self,\n        address cTokenAddress,\n        uint256 maxLoanAmount\n    ) internal {\n        require(maxLoanAmount > 0, \"INIT_MAX_AMOUNT_REQUIRED\");\n        require(\n            cTokenAddress.isEmpty() || cTokenAddress.isContract(),\n            \"CTOKEN_MUST_BE_CONTRACT_OR_EMPTY\"\n        );\n        self.cTokenAddress = cTokenAddress;\n        self.maxLoanAmount = maxLoanAmount;\n    }\n\n    /**\n        @notice Checks whether the current asset settings exists or not.\n        @dev It throws a require error if the asset settings already exists.\n        @param self the current asset settings.\n     */\n    function requireNotExists(AssetSettings storage self) internal view {\n        require(exists(self) == false, \"ASSET_SETTINGS_ALREADY_EXISTS\");\n    }\n\n    /**\n        @notice Checks whether the current asset settings exists or not.\n        @dev It throws a require error if the asset settings doesn't exist.\n        @param self the current asset settings.\n     */\n    function requireExists(AssetSettings storage self) internal view {\n        require(exists(self) == true, \"ASSET_SETTINGS_NOT_EXISTS\");\n    }\n\n    /**\n        @notice Tests whether the current asset settings exists or not.\n        @param self the current asset settings.\n        @return true if the current settings exists (max loan amount higher than zero). Otherwise it returns false.\n     */\n    function exists(AssetSettings storage self) internal view returns (bool) {\n        return self.maxLoanAmount > 0;\n    }\n\n    /**\n        @notice Tests whether a given amount is greater than the current max loan amount.\n        @param self the current asset settings.\n        @param amount to test.\n        @return true if the given amount is greater than the current max loan amount. Otherwise it returns false.\n     */\n    function exceedsMaxLoanAmount(AssetSettings storage self, uint256 amount)\n        internal\n        view\n        returns (bool)\n    {\n        return amount > self.maxLoanAmount;\n    }\n\n    /**\n        @notice It updates the cToken address.\n        @param self the current asset settings.\n        @param newCTokenAddress the new cToken address to set.\n     */\n    function updateCTokenAddress(AssetSettings storage self, address newCTokenAddress)\n        internal\n    {\n        requireExists(self);\n        require(self.cTokenAddress != newCTokenAddress, \"NEW_CTOKEN_ADDRESS_REQUIRED\");\n        self.cTokenAddress = newCTokenAddress;\n    }\n\n    /**\n        @notice It updates the max loan amount.\n        @param self the current asset settings.\n        @param newMaxLoanAmount the new max loan amount to set.\n     */\n    function updateMaxLoanAmount(AssetSettings storage self, uint256 newMaxLoanAmount)\n        internal\n    {\n        requireExists(self);\n        require(self.maxLoanAmount != newMaxLoanAmount, \"NEW_MAX_LOAN_AMOUNT_REQUIRED\");\n        require(newMaxLoanAmount > 0, \"MAX_LOAN_AMOUNT_NOT_ZERO\");\n        self.maxLoanAmount = newMaxLoanAmount;\n    }\n}\n\nlibrary PlatformSettingsLib {\n    /**\n        It defines a platform settings. It includes: value, min, and max values.\n     */\n    struct PlatformSetting {\n        uint256 value;\n        uint256 min;\n        uint256 max;\n        bool exists;\n    }\n\n    /**\n        @notice It creates a new platform setting given a name, min and max values.\n        @param value initial value for the setting.\n        @param min min value allowed for the setting.\n        @param max max value allowed for the setting.\n     */\n    function initialize(\n        PlatformSetting storage self,\n        uint256 value,\n        uint256 min,\n        uint256 max\n    ) internal {\n        requireNotExists(self);\n        require(value >= min, \"VALUE_MUST_BE_GT_MIN_VALUE\");\n        require(value <= max, \"VALUE_MUST_BE_LT_MAX_VALUE\");\n        self.value = value;\n        self.min = min;\n        self.max = max;\n        self.exists = true;\n    }\n\n    /**\n        @notice Checks whether the current platform setting exists or not.\n        @dev It throws a require error if the platform setting already exists.\n        @param self the current platform setting.\n     */\n    function requireNotExists(PlatformSetting storage self) internal view {\n        require(self.exists == false, \"PLATFORM_SETTING_ALREADY_EXISTS\");\n    }\n\n    /**\n        @notice Checks whether the current platform setting exists or not.\n        @dev It throws a require error if the current platform setting doesn't exist.\n        @param self the current platform setting.\n     */\n    function requireExists(PlatformSetting storage self) internal view {\n        require(self.exists == true, \"PLATFORM_SETTING_NOT_EXISTS\");\n    }\n\n    /**\n        @notice It updates a current platform setting.\n        @dev It throws a require error if:\n            - The new value is equal to the current value.\n            - The new value is not lower than the max value.\n            - The new value is not greater than the min value\n        @param self the current platform setting.\n        @param newValue the new value to set in the platform setting.\n     */\n    function update(PlatformSetting storage self, uint256 newValue)\n        internal\n        returns (uint256 oldValue)\n    {\n        requireExists(self);\n        require(self.value != newValue, \"NEW_VALUE_REQUIRED\");\n        require(newValue >= self.min, \"NEW_VALUE_MUST_BE_GT_MIN_VALUE\");\n        require(newValue <= self.max, \"NEW_VALUE_MUST_BE_LT_MAX_VALUE\");\n        oldValue = self.value;\n        self.value = newValue;\n    }\n\n    /**\n        @notice It removes a current platform setting.\n        @param self the current platform setting to remove.\n     */\n    function remove(PlatformSetting storage self) internal {\n        requireExists(self);\n        self.value = 0;\n        self.min = 0;\n        self.max = 0;\n        self.exists = false;\n    }\n}\n\ninterface SettingsInterface {\n    /**\n        @notice This event is emitted when a new platform setting is created.\n        @param settingName new setting name.\n        @param sender address that created it.\n        @param value value for the new setting.\n     */\n    event PlatformSettingCreated(\n        bytes32 indexed settingName,\n        address indexed sender,\n        uint256 value,\n        uint256 minValue,\n        uint256 maxValue\n    );\n\n    /**\n        @notice This event is emitted when a current platform setting is removed.\n        @param settingName setting name removed.\n        @param sender address that removed it.\n     */\n    event PlatformSettingRemoved(\n        bytes32 indexed settingName,\n        uint256 lastValue,\n        address indexed sender\n    );\n\n    /**\n        @notice This event is emitted when a platform setting is updated.\n        @param settingName settings name updated.\n        @param sender address that updated it.\n        @param oldValue old value for the setting.\n        @param newValue new value for the setting.\n     */\n    event PlatformSettingUpdated(\n        bytes32 indexed settingName,\n        address indexed sender,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice This event is emitted when a lending pool is paused.\n        @param account address that paused the lending pool.\n        @param lendingPoolAddress lending pool address which was paused.\n     */\n    event LendingPoolPaused(address indexed account, address indexed lendingPoolAddress);\n\n    /**\n        @notice This event is emitted when a lending pool is unpaused.\n        @param account address that paused the lending pool.\n        @param lendingPoolAddress lending pool address which was unpaused.\n     */\n    event LendingPoolUnpaused(\n        address indexed account,\n        address indexed lendingPoolAddress\n    );\n\n    /**\n        @notice This event is emitted when an new asset settings is created.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to create the settings.\n        @param cTokenAddress cToken address to configure for the asset.\n        @param maxLoanAmount max loan amount to configure for the asset.\n     */\n    event AssetSettingsCreated(\n        address indexed sender,\n        address indexed assetAddress,\n        address cTokenAddress,\n        uint256 maxLoanAmount\n    );\n\n    /**\n        @notice This event is emitted when an asset settings is removed.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to remove the settings.\n     */\n    event AssetSettingsRemoved(address indexed sender, address indexed assetAddress);\n\n    /**\n        @notice This event is emitted when an asset settings (address type) is updated.\n        @param assetSettingName asset setting name updated.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to update the asset settings.\n        @param oldValue old value used for the asset setting.\n        @param newValue the value updated.\n     */\n    event AssetSettingsAddressUpdated(\n        bytes32 indexed assetSettingName,\n        address indexed sender,\n        address indexed assetAddress,\n        address oldValue,\n        address newValue\n    );\n\n    /**\n        @notice This event is emitted when an asset settings (uint256 type) is updated.\n        @param assetSettingName asset setting name updated.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to update the asset settings.\n        @param oldValue old value used for the asset setting.\n        @param newValue the value updated.\n     */\n    event AssetSettingsUintUpdated(\n        bytes32 indexed assetSettingName,\n        address indexed sender,\n        address indexed assetAddress,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice It creates a new platform setting given a setting name, value, min and max values.\n        @param settingName setting name to create.\n        @param value the initial value for the given setting name.\n        @param minValue the min value for the setting.\n        @param maxValue the max value for the setting.\n     */\n    function createPlatformSetting(\n        bytes32 settingName,\n        uint256 value,\n        uint256 minValue,\n        uint256 maxValue\n    ) external;\n\n    /**\n        @notice It updates an existent platform setting given a setting name.\n        @notice It only allows to update the value (not the min or max values).\n        @notice In case you need to update the min or max values, you need to remove it, and create it again.\n        @param settingName setting name to update.\n        @param newValue the new value to set.\n     */\n    function updatePlatformSetting(bytes32 settingName, uint256 newValue) external;\n\n    /**\n        @notice Removes a current platform setting given a setting name.\n        @param settingName to remove.\n     */\n    function removePlatformSetting(bytes32 settingName) external;\n\n    /**\n        @notice It gets the current platform setting for a given setting name\n        @param settingName to get.\n        @return the current platform setting.\n     */\n    function getPlatformSetting(bytes32 settingName)\n        external\n        view\n        returns (PlatformSettingsLib.PlatformSetting memory);\n\n    /**\n        @notice It gets the current platform setting value for a given setting name\n        @param settingName to get.\n        @return the current platform setting value.\n     */\n    function getPlatformSettingValue(bytes32 settingName) external view returns (uint256);\n\n    /**\n        @notice It tests whether a setting name is already configured.\n        @param settingName setting name to test.\n        @return true if the setting is already configured. Otherwise it returns false.\n     */\n    function hasPlatformSetting(bytes32 settingName) external view returns (bool);\n\n    /**\n        @notice It gets whether the platform is paused or not.\n        @return true if platform is paused. Otherwise it returns false.\n     */\n    function isPaused() external view returns (bool);\n\n    /**\n        @notice It gets whether a lending pool is paused or not.\n        @param lendingPoolAddress lending pool address to test.\n        @return true if the lending pool is paused. Otherwise it returns false.\n     */\n    function lendingPoolPaused(address lendingPoolAddress) external view returns (bool);\n\n    /**\n        @notice It pauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to pause.\n     */\n    function pauseLendingPool(address lendingPoolAddress) external;\n\n    /**\n        @notice It unpauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to unpause.\n     */\n    function unpauseLendingPool(address lendingPoolAddress) external;\n\n    /**\n        @notice It creates a new asset settings in the platform.\n        @param assetAddress asset address used to create the new setting.\n        @param cTokenAddress cToken address used to configure the asset setting.\n        @param maxLoanAmount the max loan amount used to configure the asset setting.\n     */\n    function createAssetSettings(\n        address assetAddress,\n        address cTokenAddress,\n        uint256 maxLoanAmount\n    ) external;\n\n    /**\n        @notice It removes all the asset settings for a specific asset address.\n        @param assetAddress asset address used to remove the asset settings.\n     */\n    function removeAssetSettings(address assetAddress) external;\n\n    /**\n        @notice It updates the maximum loan amount for a specific asset address.\n        @param assetAddress asset address to configure.\n        @param newMaxLoanAmount the new maximum loan amount to configure.\n     */\n    function updateMaxLoanAmount(address assetAddress, uint256 newMaxLoanAmount) external;\n\n    /**\n        @notice It updates the cToken address for a specific asset address.\n        @param assetAddress asset address to configure.\n        @param newCTokenAddress the new cToken address to configure.\n     */\n    function updateCTokenAddress(address assetAddress, address newCTokenAddress) external;\n\n    /**\n        @notice Gets the current asset addresses list.\n        @return the asset addresses list.\n     */\n    function getAssets() external view returns (address[] memory);\n\n    /**\n        @notice Get the current asset settings for a given asset address.\n        @param assetAddress asset address used to get the current settings.\n        @return the current asset settings.\n     */\n    function getAssetSettings(address assetAddress)\n        external\n        view\n        returns (AssetSettingsLib.AssetSettings memory);\n\n    /**\n        @notice Tests whether amount exceeds the current maximum loan amount for a specific asset settings.\n        @param assetAddress asset address to test the setting.\n        @param amount amount to test.\n        @return true if amount exceeds current max loan amout. Otherwise it returns false.\n     */\n    function exceedsMaxLoanAmount(address assetAddress, uint256 amount)\n        external\n        view\n        returns (bool);\n\n    /**\n        @notice Tests whether an account has the pauser role.\n        @param account account to test.\n        @return true if account has the pauser role. Otherwise it returns false.\n     */\n    function hasPauserRole(address account) external view returns (bool);\n}\n\nlibrary MarketStateLib {\n    using SafeMath for uint256;\n\n    // Multiply by this to convert a number into a percentage.\n    uint256 private constant TO_PERCENTAGE = 10000;\n\n    struct MarketState {\n        uint256 totalSupplied;\n        uint256 totalRepaid;\n        uint256 totalBorrowed;\n    }\n\n    /**\n        @notice It increases the repayment amount for a given market.\n        @param self the current market state reference.\n        @param amount amount to add.\n     */\n    function increaseRepayment(MarketState storage self, uint256 amount) internal {\n        self.totalRepaid = self.totalRepaid.add(amount);\n    }\n\n    /**\n        @notice It increases the supply amount for a given market.\n        @param self the current market state reference.\n        @param amount amount to add.\n     */\n    function increaseSupply(MarketState storage self, uint256 amount) internal {\n        self.totalSupplied = self.totalSupplied.add(amount);\n    }\n\n    /**\n        @notice It decreases the supply amount for a given market.\n        @param self the current market state reference.\n        @param amount amount to add.\n     */\n    function decreaseSupply(MarketState storage self, uint256 amount) internal {\n        self.totalSupplied = self.totalSupplied.sub(amount);\n    }\n\n    /**\n        @notice It increases the borrowed amount for a given market.\n        @param self the current market state reference.\n        @param amount amount to add.\n     */\n    function increaseBorrow(MarketState storage self, uint256 amount) internal {\n        self.totalBorrowed = self.totalBorrowed.add(amount);\n    }\n\n    /**\n        @notice It gets the current supply-to-debt (StD) ratio for a given market.\n        @notice The formula to calculate StD ratio is:\n            \n            StD = (SUM(total borrowed) - SUM(total repaid)) / SUM(total supplied)\n\n        @notice The value has 2 decimal places.\n            Example:\n                100 => 1%\n        @param self the current market state reference.\n        @return the supply-to-debt ratio value.\n     */\n    function getSupplyToDebt(MarketState storage self) internal view returns (uint256) {\n        if (self.totalSupplied == 0) {\n            return 0;\n        }\n        return\n            self.totalBorrowed.sub(self.totalRepaid).mul(TO_PERCENTAGE).div(\n                self.totalSupplied\n            );\n    }\n\n    /**\n        @notice It gets the supply-to-debt (StD) ratio for a given market, including a new loan amount.\n        @notice The formula to calculate StD ratio (including a new loan amount) is:\n            \n            StD = (SUM(total borrowed) - SUM(total repaid) + NewLoanAmount) / SUM(total supplied)\n\n        @param self the current market state reference.\n        @param loanAmount a new loan amount to consider in the ratio.\n        @return the supply-to-debt ratio value.\n     */\n    function getSupplyToDebtFor(MarketState storage self, uint256 loanAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        if (self.totalSupplied == 0) {\n            return 0;\n        }\n        return\n            self\n                .totalBorrowed\n                .sub(self.totalRepaid)\n                .add(loanAmount)\n                .mul(TO_PERCENTAGE)\n                .div(self.totalSupplied);\n    }\n}\n\ninterface MarketsStateInterface {\n    /**\n        @notice It increases the repayment amount for a given market.\n        @notice This function is called every new repayment is received.\n        @param borrowedAsset borrowed asset address.\n        @param collateralAsset collateral asset address.\n        @param amount amount to add.\n     */\n    function increaseRepayment(\n        address borrowedAsset,\n        address collateralAsset,\n        uint256 amount\n    ) external;\n\n    /**\n        @notice It increases the supply amount for a given market.\n        @notice This function is called every new deposit (Lenders) is received.\n        @param borrowedAsset borrowed asset address.\n        @param collateralAsset collateral asset address.\n        @param amount amount to add.\n     */\n    function increaseSupply(\n        address borrowedAsset,\n        address collateralAsset,\n        uint256 amount\n    ) external;\n\n    /**\n        @notice It decreases the supply amount for a given market.\n        @notice This function is called every new withdraw (Lenders) is done.\n        @param borrowedAsset borrowed asset address.\n        @param collateralAsset collateral asset address.\n        @param amount amount to decrease.\n     */\n    function decreaseSupply(\n        address borrowedAsset,\n        address collateralAsset,\n        uint256 amount\n    ) external;\n\n    /**\n        @notice It increases the borrowed amount for a given market.\n        @notice This function is called every new loan is taken out.\n        @param borrowedAsset borrowed asset address.\n        @param collateralAsset collateral asset address.\n        @param amount amount to add.\n     */\n    function increaseBorrow(\n        address borrowedAsset,\n        address collateralAsset,\n        uint256 amount\n    ) external;\n\n    /**\n        @notice It gets the current supply-to-debt (StD) ratio for a given market.\n        @param borrowedAsset borrowed asset address.\n        @param collateralAsset collateral asset address.\n        @return the supply-to-debt ratio value.\n     */\n    function getSupplyToDebt(address borrowedAsset, address collateralAsset)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice It gets the supply-to-debt (StD) ratio for a given market, including a new loan amount.\n        @param borrowedAsset borrowed asset address.\n        @param collateralAsset collateral asset address.\n        @param loanAmount a new loan amount to consider in the ratio.\n        @return the supply-to-debt ratio value.\n     */\n    function getSupplyToDebtFor(\n        address borrowedAsset,\n        address collateralAsset,\n        uint256 loanAmount\n    ) external view returns (uint256);\n\n    /**\n        @notice It gets the current market state.\n        @param borrowedAsset borrowed asset address.\n        @param collateralAsset collateral asset address.\n        @return the current market state.\n     */\n    function getMarket(address borrowedAsset, address collateralAsset)\n        external\n        view\n        returns (MarketStateLib.MarketState memory);\n}\n\ncontract Base is TInitializable, ReentrancyGuard {\n    using AddressLib for address;\n    using Address for address;\n\n    /* State Variables */\n\n    SettingsInterface public settings;\n    MarketsStateInterface public markets;\n\n    /** Modifiers */\n\n    /**\n        @notice Checks whether the platform is paused or not.\n        @dev It throws a require error if platform is paused.\n     */\n    modifier whenNotPaused() {\n        require(!_isPaused(), \"PLATFORM_IS_PAUSED\");\n        _;\n    }\n\n    /**\n        @notice Checks whether a specific lending pool address is paused or not.\n        @dev It throws a require error if the lending pool is paused.\n        @param lendingPoolAddress lending pool address to check.\n     */\n    modifier whenLendingPoolNotPaused(address lendingPoolAddress) {\n        require(!_isPoolPaused(lendingPoolAddress), \"LENDING_POOL_IS_PAUSED\");\n        _;\n    }\n\n    /**\n        @notice Checks whether the platform is paused or not.\n        @dev It throws a require error if platform is not paused.\n     */\n    modifier whenPaused() {\n        require(_isPaused(), \"PLATFORM_IS_NOT_PAUSED\");\n        _;\n    }\n\n    /**\n        @notice Checks whether a specific lending pool address is paused or not.\n        @dev It throws a require error if the lending pool is not paused.\n        @param lendingPoolAddress lending pool address to check.\n     */\n    modifier whenLendingPoolPaused(address lendingPoolAddress) {\n        require(_isPoolPaused(lendingPoolAddress), \"LENDING_POOL_IS_NOT_PAUSED\");\n        _;\n    }\n\n    /**\n        @notice Checks whether a given address is allowed (see Settings#hasPauserRole function) or not.\n        @dev It throws a require error if address is not allowed.\n        @param anAddress account to test.\n     */\n    modifier whenAllowed(address anAddress) {\n        require(settings.hasPauserRole(anAddress), \"ADDRESS_ISNT_ALLOWED\");\n        _;\n    }\n\n    /* Constructor */\n\n    /** External Functions */\n\n    /** Internal functions */\n\n    /**\n        @notice It initializes the current contract instance setting the required parameters.\n        @param settingsAddress settings contract address.\n        @param marketsAddress markets state contract address.\n     */\n    function _initialize(address settingsAddress, address marketsAddress)\n        internal\n        isNotInitialized()\n    {\n        settingsAddress.requireNotEmpty(\"SETTINGS_MUST_BE_PROVIDED\");\n        require(settingsAddress.isContract(), \"SETTINGS_MUST_BE_A_CONTRACT\");\n        marketsAddress.requireNotEmpty(\"MARKETS_MUST_BE_PROVIDED\");\n        require(marketsAddress.isContract(), \"MARKETS_MUST_BE_A_CONTRACT\");\n\n        _initialize();\n\n        settings = SettingsInterface(settingsAddress);\n        markets = MarketsStateInterface(marketsAddress);\n    }\n\n    /**\n        @notice Gets if a specific lending pool address is paused or not.\n        @param poolAddress lending pool address to check.\n        @return true if the lending pool address is  paused. Otherwise it returns false.\n     */\n    function _isPoolPaused(address poolAddress) internal view returns (bool) {\n        return settings.lendingPoolPaused(poolAddress);\n    }\n\n    /**\n        @notice Gets if the platform is paused or not.\n        @return true if platform is paused. Otherwise it returns false.\n     */\n    function _isPaused() internal view returns (bool) {\n        return settings.isPaused();\n    }\n\n    /** Private functions */\n}\n\ninterface PairAggregatorInterface {\n    /**\n        @notice Gets the current answer from the aggregator.\n        @return the latest answer.\n     */\n    function getLatestAnswer() external view returns (int256);\n\n    /**\n        @notice Gets the last updated height from the aggregator.\n        @return the latest timestamp.\n     */\n    function getLatestTimestamp() external view returns (uint256);\n\n    /**\n        @notice Gets past rounds answer.\n        @param roundsBack the answer number to retrieve the answer for\n        @return the previous answer.\n     */\n    function getPreviousAnswer(uint256 roundsBack) external view returns (int256);\n\n    /**\n        @notice Gets block timestamp when an answer was last updated.\n        @param roundsBack the answer number to retrieve the updated timestamp for.\n        @return the previous timestamp.\n     */\n    function getPreviousTimestamp(uint256 roundsBack) external view returns (uint256);\n\n    /**\n        @notice Gets the latest completed round where the answer was updated.\n        @return the latest round id.\n    */\n    function getLatestRound() external view returns (uint256);\n}\n\ninterface LendingPoolInterface {\n    /**\n        @notice It allows users to deposit tokens into the pool.\n        @dev the user must call ERC20.approve function previously.\n        @param amount of tokens to deposit in the pool.\n    */\n    function deposit(uint256 amount) external;\n\n    /**\n        @notice It allows any tToken holder to burn their tToken tokens and withdraw their tokens.\n        @param amount of tokens to withdraw.\n        @dev It throws a require error if the contract hasn't enough tokens balance.\n        @dev It throws a require error if the holder hasn't enough tToken balance.\n     */\n    function withdraw(uint256 amount) external;\n\n    /**\n        @notice It allows a borrower repaying their loan. \n        @dev This function can be called ONLY by the Loans contract.\n        @dev It requires a ERC20.approve call before calling it.\n        @dev It throws a require error if borrower called ERC20.approve function before calling it.\n        @param amount of tokens.\n        @param borrower address that is repaying the loan.\n     */\n    function repay(uint256 amount, address borrower) external;\n\n    /**\n        @notice Once a loan is liquidated, it transfers the amount of tokens to the liquidator address.\n        @param amount of tokens to liquidate.\n        @param liquidator address to receive the tokens.\n        @dev It throws a require error if this contract hasn't enough token balance.\n     */\n    function liquidationPayment(uint256 amount, address liquidator) external;\n\n    /**\n        @notice Once the loan is created, it transfers the amount of tokens to the borrower.\n        @param amount of tokens to transfer.\n        @param borrower address which will receive the tokens.\n        @dev This function only can be invoked by the LoansInterface implementation.\n        @dev It throws a require error if current ERC20 balance isn't enough to transfer the tokens.\n     */\n    function createLoan(uint256 amount, address borrower) external;\n\n    /**\n        @notice It allows a lender to withdraw a specific amount of interest.\n        @param amount to withdraw.\n        @dev It throws a require error if amount exceeds the current accrued interest.\n    */\n    function withdrawInterest(uint256 amount) external;\n\n    /**\n        @notice It gets the lending token address.\n        @return the ERC20 lending token address.\n    */\n    function lendingToken() external view returns (address);\n\n    /**\n        @notice Gets the current interest validator. By default it is 0x0.\n        @return the interest validator contract address or empty address (0x0). \n     */\n    function interestValidator() external view returns (address);\n\n    /**\n        @notice Update the current interest validator address.\n        @param newInterestValidator the new interest validator address.\n     */\n    function setInterestValidator(address newInterestValidator) external;\n\n    /**\n        @notice This event is emitted when an user deposits tokens into the pool.\n        @param sender address.\n        @param amount of tokens.\n     */\n    event TokenDeposited(address indexed sender, uint256 amount);\n\n    /**\n        @notice This event is emitted when an user withdraws tokens from the pool.\n        @param sender address that withdrew the tokens.\n        @param amount of tokens.\n     */\n    event TokenWithdrawn(address indexed sender, uint256 amount);\n\n    /**\n        @notice This event is emitted when an borrower repaid a loan.\n        @param borrower address.\n        @param amount of tokens.\n     */\n    event TokenRepaid(address indexed borrower, uint256 amount);\n\n    /**\n        @notice This event is emitted when an lender withdraws interests.\n        @param lender address.\n        @param amount of tokens.\n     */\n    event InterestWithdrawn(address indexed lender, uint256 amount);\n\n    /**\n        @notice This event is emitted when a liquidator liquidates a loan.\n        @param liquidator address.\n        @param amount of tokens.\n     */\n    event PaymentLiquidated(address indexed liquidator, uint256 amount);\n\n    /**\n        @notice This event is emitted when the interest validator is updated.\n        @param sender account that sends the transaction.\n        @param oldInterestValidator the old validator address.\n        @param newInterestValidator the new validator address.\n     */\n    event InterestValidatorUpdated(\n        address indexed sender,\n        address indexed oldInterestValidator,\n        address indexed newInterestValidator\n    );\n}\n\ninterface LoanTermsConsensusInterface {\n    /**\n        @notice This event is emitted when the loan terms have been submitted\n        @param signer Account address of the signatory\n        @param borrower Account address of the borrowing party\n        @param requestNonce Nonce used for authentication of the loan request\n        @param interestRate Interest rate submitted in the loan request\n        @param collateralRatio Ratio of collateral submitted for the loan\n        @param maxLoanAmount Maximum loan amount that can be taken out\n     */\n    event TermsSubmitted(\n        address indexed signer,\n        address indexed borrower,\n        uint256 indexed requestNonce,\n        uint256 interestRate,\n        uint256 collateralRatio,\n        uint256 maxLoanAmount\n    );\n\n    /**\n        @notice This event is emitted when the loan terms have been accepted\n        @param borrower Account address of the borrowing party\n        @param requestNonce Accepted interest rate for the loan\n        @param collateralRatio Ratio of collateral needed for the loan\n        @param maxLoanAmount Maximum loan amount that the borrower can take out\n     */\n    event TermsAccepted(\n        address indexed borrower,\n        uint256 indexed requestNonce,\n        uint256 interestRate,\n        uint256 collateralRatio,\n        uint256 maxLoanAmount\n    );\n\n    /**\n        @notice Processes the loan request\n        @param request Struct of the protocol loan request\n        @param responses List of structs of the protocol loan responses\n        @return uint256 Interest rate\n        @return uint256 Collateral ratio\n        @return uint256 Maximum loan amount\n     */\n    function processRequest(\n        TellerCommon.LoanRequest calldata request,\n        TellerCommon.LoanResponse[] calldata responses\n    ) external returns (uint256, uint256, uint256);\n}\n\ninterface LoansInterface {\n    /**\n        @notice This event is emitted when collateral has been deposited for the loan\n        @param loanID ID of the loan for which collateral was deposited\n        @param borrower Account address of the borrower\n        @param depositAmount Amount of collateral deposited\n     */\n    event CollateralDeposited(\n        uint256 indexed loanID,\n        address indexed borrower,\n        uint256 depositAmount\n    );\n\n    /**\n        @notice This event is emitted when collateral has been withdrawn\n        @param loanID ID of loan from which collateral was withdrawn\n        @param borrower Account address of the borrower\n     */\n    event CollateralWithdrawn(\n        uint256 indexed loanID,\n        address indexed borrower,\n        uint256 withdrawalAmount\n    );\n\n    /**\n        @notice This event is emitted when loan terms have been successsfully set\n        @param loanID ID of loan from which collateral was withdrawn\n        @param borrower Account address of the borrower\n        @param recipient Account address of the recipient\n        @param interestRate Interest rate set in the loan terms\n        @param collateralRatio Collateral ratio set in the loan terms\n        @param maxLoanAmount Maximum loan amount that can be taken out, set in the loan terms\n     */\n    event LoanTermsSet(\n        uint256 indexed loanID,\n        address indexed borrower,\n        address indexed recipient,\n        uint256 interestRate,\n        uint256 collateralRatio,\n        uint256 maxLoanAmount,\n        uint256 duration,\n        uint256 termsExpiry\n    );\n\n    /**\n        @notice This event is emitted when a loan has been successfully taken out\n        @param loanID ID of loan from which collateral was withdrawn\n        @param borrower Account address of the borrower\n        @param amountBorrowed Total amount taken out in the loan\n     */\n    event LoanTakenOut(\n        uint256 indexed loanID,\n        address indexed borrower,\n        uint256 amountBorrowed\n    );\n\n    /**\n        @notice This event is emitted when a loan has been successfully repaid\n        @param loanID ID of loan from which collateral was withdrawn\n        @param borrower Account address of the borrower\n        @param amountPaid Amount of the loan paid back\n        @param payer Account address of the payer\n        @param totalOwed Total amount of the loan to be repaid\n     */\n    event LoanRepaid(\n        uint256 indexed loanID,\n        address indexed borrower,\n        uint256 amountPaid,\n        address payer,\n        uint256 totalOwed\n    );\n\n    /**\n        @notice This event is emitted when a loan has been successfully liquidated\n        @param loanID ID of loan from which collateral was withdrawn\n        @param borrower Account address of the borrower\n        @param liquidator Account address of the liquidator\n        @param collateralOut Collateral that is sent to the liquidator\n        @param tokensIn Percentage of the collateral price paid by the liquidator to the lending pool\n     */\n    event LoanLiquidated(\n        uint256 indexed loanID,\n        address indexed borrower,\n        address liquidator,\n        uint256 collateralOut,\n        uint256 tokensIn\n    );\n\n    /**\n        @notice This event is emitted when a the price oracle instance is updated.\n        @param oldPriceOracle the previous price oracle address.\n        @param newPriceOracle the new price oracle address.\n     */\n    event PriceOracleUpdated(\n        address indexed sender,\n        address indexed oldPriceOracle,\n        address indexed newPriceOracle\n    );\n\n    /**\n        @notice Returns a list of all loans for a borrower\n        @param borrower Account address of the borrower\n     */\n    function getBorrowerLoans(address borrower) external view returns (uint256[] memory);\n\n    /**\n        @notice Returns the struct of a loan\n        @param loanID ID of loan from which collateral was withdrawn\n     */\n    function loans(uint256 loanID) external view returns (TellerCommon.Loan memory);\n\n    /**\n        @notice Deposit collateral for a loan, unless it isn't allowed\n        @param borrower Account address of the borrower\n        @param loanID ID of loan from which collateral was withdrawn\n        @param amount Amount to be deposited as collateral\n     */\n    function depositCollateral(address borrower, uint256 loanID, uint256 amount)\n        external\n        payable;\n\n    /**\n        @notice Withdraw collateral from a loan, unless this isn't allowed\n        @param amount The amount of collateral token or ether the caller is hoping to withdraw\n        @param loanID The ID of the loan the collateral is for\n     */\n    function withdrawCollateral(uint256 amount, uint256 loanID) external;\n\n    /**\n        @notice Create a loan with specified terms, if allowed\n        @param request Struct of the protocol loan request\n        @param responses List of structs of the protocol loan responses\n        @param collateralAmount Amount of collateral for the loan\n     */\n    function createLoanWithTerms(\n        TellerCommon.LoanRequest calldata request,\n        TellerCommon.LoanResponse[] calldata responses,\n        uint256 collateralAmount\n    ) external payable;\n\n    /**\n        @notice Take out a loan, if allowed\n        @param loanID The ID of the loan to be taken out\n        @param amountBorrow Amount of tokens to be taken out in the loan\n     */\n    function takeOutLoan(uint256 loanID, uint256 amountBorrow) external;\n\n    /**\n        @notice Make a payment to a specified loan\n        @param amount The amount of tokens to pay back to the loan\n        @param loanID The ID of the loan the payment is for\n     */\n    function repay(uint256 amount, uint256 loanID) external;\n\n    /**\n        @notice Liquidate a loan if has is expired or undercollateralised\n        @param loanID The ID of the loan to be liquidated\n     */\n    function liquidateLoan(uint256 loanID) external;\n\n    /**\n        @notice Get the current price oracle\n        @return address Contract adddress of the price oracle\n     */\n    function priceOracle() external view returns (address);\n\n    /**\n        @notice Returns the lending token in the lending pool\n        @return address Contract adddress of the lending pool\n     */\n    function lendingPool() external view returns (address);\n\n    /**\n        @notice Returns the lending token in the lending pool\n        @return address Contract address of the lending token\n     */\n    function lendingToken() external view returns (address);\n\n    /**\n        @notice Returns the total amount of collateral\n        @return uint256 The total amount of collateral held by the contract instance\n     */\n    function totalCollateral() external view returns (uint256);\n\n    /**\n        @notice Returns the ID of loans taken out\n        @return uint256 The next available loan ID\n     */\n    function loanIDCounter() external view returns (uint256);\n\n    /**\n        @notice Returns the collateral token\n        @return address Contract address of the token\n     */\n    function collateralToken() external view returns (address);\n\n    /**\n        @notice Get collateral infomation of a specific loan\n        @param loanID ID of the loan to get info for\n        @return uint256 Collateral needed\n        @return uint256 Collaternal needed in Lending tokens\n        @return uint256 Collateral needed in Collateral tokens\n        @return bool If more collateral is needed or not\n     */\n    function getCollateralInfo(uint256 loanID)\n        external\n        view\n        returns (\n            uint256 collateral,\n            uint256 collateralNeededLendingTokens,\n            uint256 collateralNeededCollateralTokens,\n            bool requireCollateral\n        );\n\n    /**\n        @notice Updates the current price oracle instance.\n        @param newPriceOracle the new price oracle address.\n     */\n    function setPriceOracle(address newPriceOracle) external;\n}\n\ninterface IATMSettings {\n    /** Events */\n\n    /**\n        @notice This event is emitted when an ATM is paused.\n        @param atm paused ATM address.\n        @param account address that paused the ATM.\n     */\n    event ATMPaused(address indexed atm, address indexed account);\n\n    /**\n        @notice This event is emitted when an ATM is unpaused.\n        @param atm unpaused ATM address.\n        @param account address that unpaused the ATM.\n     */\n    event ATMUnpaused(address indexed account, address indexed atm);\n\n    /**\n        @notice This event is emitted when the setting for a Market/ATM is set.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atm ATM address to set in the given market.\n        @param account address that set the setting.\n     */\n    event MarketToAtmSet(\n        address indexed borrowedToken,\n        address indexed collateralToken,\n        address indexed atm,\n        address account\n    );\n\n    /**\n        @notice This event is emitted when the setting for a Market/ATM is updated.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param oldAtm the old ATM address in the given market.\n        @param newAtm the new ATM address in the given market.\n        @param account address that updated the setting.\n     */\n    event MarketToAtmUpdated(\n        address indexed borrowedToken,\n        address indexed collateralToken,\n        address indexed oldAtm,\n        address newAtm,\n        address account\n    );\n\n    /**\n        @notice This event is emitted when the setting for a Market/ATM is removed.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param oldAtm last ATM address in the given market.\n        @param account address that removed the setting.\n     */\n    event MarketToAtmRemoved(\n        address indexed borrowedToken,\n        address indexed collateralToken,\n        address indexed oldAtm,\n        address account\n    );\n\n    /* State Variables */\n\n    /** Modifiers */\n\n    /* Constructor */\n\n    /** External Functions */\n\n    /**\n        @notice It pauses an given ATM.\n        @param atmAddress ATM address to pause.\n     */\n    function pauseATM(address atmAddress) external;\n\n    /**\n        @notice It unpauses an given ATM.\n        @param atmAddress ATM address to unpause.\n     */\n    function unpauseATM(address atmAddress) external;\n\n    /**\n        @notice Gets whether an ATM is paused or not.\n        @param atmAddress ATM address to test.\n        @return true if ATM is paused. Otherwise it returns false.\n     */\n    function isATMPaused(address atmAddress) external view returns (bool);\n\n    /**\n        @notice Sets an ATM for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atmAddress ATM address to set.\n     */\n    function setATMToMarket(\n        address borrowedToken,\n        address collateralToken,\n        address atmAddress\n    ) external;\n\n    /**\n        @notice Updates a new ATM for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param newAtmAddress the new ATM address to update.\n     */\n    function updateATMToMarket(\n        address borrowedToken,\n        address collateralToken,\n        address newAtmAddress\n    ) external;\n\n    /**\n        @notice Removes the ATM address for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n     */\n    function removeATMToMarket(address borrowedToken, address collateralToken) external;\n\n    /**\n        @notice Gets the ATM configured for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @return the ATM address configured for a given market.\n     */\n    function getATMForMarket(address borrowedToken, address collateralToken)\n        external\n        view\n        returns (address);\n\n    /**\n        @notice Tests whether an ATM is configured for a given market (borrowed token and collateral token) or not.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atmAddress ATM address to test.\n        @return true if the ATM is configured for the market. Otherwise it returns false.\n     */\n    function isATMForMarket(\n        address borrowedToken,\n        address collateralToken,\n        address atmAddress\n    ) external view returns (bool);\n}\n\ninterface IATMGovernance {\n    /* Events */\n\n    /**\n        @notice Emitted when a new ATM General Setting was added.\n        @param sender transaction sender address.\n        @param settingName name of the newly added setting.\n        @param settingValue value of the newly added setting.  \n     */\n    event GeneralSettingAdded(\n        address indexed sender,\n        bytes32 indexed settingName,\n        uint256 settingValue\n    );\n\n    /**\n        @notice Emitted when an ATM General Setting was updated.\n        @param sender transaction sender address.\n        @param settingName name of the newly added setting.\n        @param oldValue previous value of this setting.  \n        @param newValue new value of this setting.  \n     */\n    event GeneralSettingUpdated(\n        address indexed sender,\n        bytes32 indexed settingName,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice Emitted when an ATM General Setting was removed.\n        @param sender transaction sender address.\n        @param settingName name of the setting removed.\n        @param settingValue value of the setting removed.  \n     */\n    event GeneralSettingRemoved(\n        address indexed sender,\n        bytes32 indexed settingName,\n        uint256 settingValue\n    );\n\n    /**\n        @notice Emitted when a new Asset Setting was added for an specific Market.\n        @param sender transaction sender address.\n        @param asset asset address this setting was created for.\n        @param settingName name of the added setting.\n        @param settingValue value of the added setting.\n     */\n    event AssetMarketSettingAdded(\n        address indexed sender,\n        address indexed asset,\n        bytes32 indexed settingName,\n        uint256 settingValue\n    );\n\n    /**\n        @notice Emitted when an Asset Setting was updated for an specific Market.\n        @param sender transaction sender address.\n        @param asset asset address this setting was updated for.\n        @param settingName name of the updated setting.\n        @param oldValue previous value of this setting.\n        @param newValue new value of this setting.\n     */\n    event AssetMarketSettingUpdated(\n        address indexed sender,\n        address indexed asset,\n        bytes32 indexed settingName,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice Emitted when an Asset Setting was removed for an specific Market.\n        @param sender transaction sender address.\n        @param asset asset address this setting was removed for.\n        @param settingName name of the removed setting.\n        @param oldValue previous value of the removed setting.\n     */\n    event AssetMarketSettingRemoved(\n        address indexed sender,\n        address indexed asset,\n        bytes32 indexed settingName,\n        uint256 oldValue\n    );\n\n    /**\n        @notice Emitted when a new Data Provider was added to this ATM.\n        @param sender transaction sender address.\n        @param dataTypeIndex index of this data type.\n        @param amountDataProviders amount of data providers for this data type.\n        @param dataProvider address of the added Data Provider.\n     */\n    event DataProviderAdded(\n        address indexed sender,\n        uint8 indexed dataTypeIndex,\n        uint256 amountDataProviders,\n        address dataProvider\n    );\n\n    /**\n        @notice Emitted when a Data Provider was updated on this ATM.\n        @param sender transaction sender address.\n        @param dataTypeIndex index of this data type.\n        @param dataProviderIndex index of this data provider.\n        @param oldDataProvider previous address of the Data Provider.\n        @param newDataProvider new address of the Data Provider.\n     */\n    event DataProviderUpdated(\n        address indexed sender,\n        uint8 indexed dataTypeIndex,\n        uint256 indexed dataProviderIndex,\n        address oldDataProvider,\n        address newDataProvider\n    );\n\n    /**\n        @notice Emitted when a Data Provider was removed on this ATM.\n        @param sender transaction sender address.\n        @param dataTypeIndex index of this data type.\n        @param dataProviderIndex index of this data provider inside this data type.\n        @param dataProvider address of the Data Provider.\n     */\n    event DataProviderRemoved(\n        address indexed sender,\n        uint8 indexed dataTypeIndex,\n        uint256 indexed dataProviderIndex,\n        address dataProvider\n    );\n\n    /**\n        @notice Emitted when a new CRA - Credit Risk Algorithm is set.\n        @param sender transaction sender address.\n        @param craCommitHash github commit hash with the new CRA implementation.\n     */\n    event CRASet(address indexed sender, string craCommitHash);\n\n    /* External Functions */\n\n    /**\n        @notice Adds a new General Setting to this ATM.\n        @param settingName name of the setting to be added.\n        @param settingValue value of the setting to be added.\n     */\n    function addGeneralSetting(bytes32 settingName, uint256 settingValue) external;\n\n    /**\n        @notice Updates an existing General Setting on this ATM.\n        @param settingName name of the setting to be modified.\n        @param newValue new value to be set for this settingName. \n     */\n    function updateGeneralSetting(bytes32 settingName, uint256 newValue) external;\n\n    /**\n        @notice Removes a General Setting from this ATM.\n        @param settingName name of the setting to be removed.\n     */\n    function removeGeneralSetting(bytes32 settingName) external;\n\n    /**\n        @notice Adds a new Asset Setting from a specific Market on this ATM.\n        @param asset market specific asset address.\n        @param settingName name of the setting to be added.\n        @param settingValue value of the setting to be added.\n     */\n    function addAssetMarketSetting(\n        address asset,\n        bytes32 settingName,\n        uint256 settingValue\n    ) external;\n\n    /**\n        @notice Updates an existing Asset Setting from a specific Market on this ATM.\n        @param asset market specific asset address.\n        @param settingName name of the setting to be added.\n        @param newValue value of the setting to be added.\n     */\n    function updateAssetMarketSetting(\n        address asset,\n        bytes32 settingName,\n        uint256 newValue\n    ) external;\n\n    /**\n        @notice Removes an existing Asset Setting from a specific Market on this ATM.\n        @param asset market specific asset address.\n        @param settingName name of the setting to be added.\n     */\n    function removeAssetMarketSetting(address asset, bytes32 settingName) external;\n\n    /**\n        @notice Adds a new Data Provider on a specific Data Type array.\n            This function would accept duplicated data providers for the same data type.\n        @param dataTypeIndex array index for this Data Type.\n        @param dataProvider data provider address.\n     */\n    function addDataProvider(uint8 dataTypeIndex, address dataProvider) external;\n\n    /**\n        @notice Updates an existing Data Provider on a specific Data Type array.\n        @param dataTypeIndex array index for this Data Type.\n        @param providerIndex previous data provider index.\n        @param newProvider new data provider address.\n     */\n    function updateDataProvider(\n        uint8 dataTypeIndex,\n        uint256 providerIndex,\n        address newProvider\n    ) external;\n\n    /**\n        @notice Removes an existing Data Provider on a specific Data Type array.\n        @param dataTypeIndex array index for this Data Type.\n        @param dataProvider data provider index.\n     */\n    function removeDataProvider(uint8 dataTypeIndex, uint256 dataProvider) external;\n\n    /**\n        @notice Sets the CRA - Credit Risk Algorithm to be used on this specific ATM.\n                CRA is represented by a Github commit hash of the newly proposed algorithm.\n     */\n    function setCRA(string calldata cra) external;\n\n    /* External Constant functions */\n\n    /**\n        @notice Returns a General Setting value from this ATM.\n        @param settingName name of the setting to be returned.\n     */\n    function getGeneralSetting(bytes32 settingName) external view returns (uint256);\n\n    /**\n        @notice Returns an existing Asset Setting value from a specific Market on this ATM.\n        @param asset market specific asset address.\n        @param settingName name of the setting to be returned.\n     */\n    function getAssetMarketSetting(address asset, bytes32 settingName)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice Returns a Data Provider on a specific Data Type array.\n        @param dataTypeIndex array index for this Data Type.\n        @param dataProviderIndex data provider index number.\n     */\n    function getDataProvider(uint8 dataTypeIndex, uint256 dataProviderIndex)\n        external\n        view\n        returns (address);\n\n    /**\n        @notice Returns current CRA - Credit Risk Algorithm that is being used on this specific ATM.\n                CRA is represented by a Github commit hash of the newly proposed algorithm.\n     */\n    function getCRA() external view returns (string memory);\n}\n\ncontract LoansBase is LoansInterface, Base, SettingsConsts {\n    using SafeMath for uint256;\n    using ERC20Lib for ERC20;\n\n    /* State Variables */\n\n    // Loan length will be inputted in days, with 4 decimal places. i.e. 30 days will be inputted as\n    // 300000. Therefore in interest calculations we must divide by 365000\n    uint256 internal constant DAYS_PER_YEAR_4DP = 3650000;\n\n    // For interestRate, collateral, and liquidation price, 7% is represented as 700. To find the value\n    // of something we must divide 700 by 100 to remove decimal places, and another 100 for percentage.\n    uint256 internal constant TEN_THOUSAND = 10000;\n\n    bytes32 internal constant SUPPLY_TO_DEBT_ATM_SETTING = \"SupplyToDebt\";\n\n    uint256 public totalCollateral;\n\n    address public collateralToken;\n\n    // At any time, this variable stores the next available loan ID\n    uint256 public loanIDCounter;\n\n    address public priceOracle;\n\n    LendingPoolInterface public lendingPool;\n\n    LoanTermsConsensusInterface public loanTermsConsensus;\n\n    IATMSettings public atmSettings;\n\n    mapping(address => uint256[]) public borrowerLoans;\n\n    mapping(uint256 => TellerCommon.Loan) public loans;\n\n    /* Modifiers */\n\n    /**\n        @notice Checks if the sender is a borrower or not\n        @dev It throws a require error if the sender is not a borrower\n        @param borrower Account address to check\n     */\n    modifier isBorrower(address borrower) {\n        require(msg.sender == borrower, \"BORROWER_MUST_BE_SENDER\");\n        _;\n    }\n\n    /**\n        @notice Checks whether the loan is active or not\n        @dev Throws a require error if the loan is not active\n        @param loanID number of loan to check\n     */\n    modifier loanActive(uint256 loanID) {\n        require(\n            loans[loanID].status == TellerCommon.LoanStatus.Active,\n            \"LOAN_NOT_ACTIVE\"\n        );\n        _;\n    }\n\n    /**\n        @notice Checks if the loan has been set or not\n        @dev Throws a require error if the loan terms have not been set\n        @param loanID number of loan to check\n     */\n    modifier loanTermsSet(uint256 loanID) {\n        require(loans[loanID].status == TellerCommon.LoanStatus.TermsSet, \"LOAN_NOT_SET\");\n        _;\n    }\n\n    /**\n        @notice Checks whether the loan is active and has been set or not\n        @dev Throws a require error if the loan is not active or has not been set\n        @param loanID number of loan to check\n     */\n    modifier loanActiveOrSet(uint256 loanID) {\n        require(\n            loans[loanID].status == TellerCommon.LoanStatus.TermsSet ||\n                loans[loanID].status == TellerCommon.LoanStatus.Active,\n            \"LOAN_NOT_ACTIVE_OR_SET\"\n        );\n        _;\n    }\n\n    /**\n        @notice Checks the given loan request is valid.\n        @dev It throws an require error if the duration exceeds the maximum loan duration.\n        @dev It throws an require error if the loan amount exceeds the maximum loan amount for the given asset.\n        @param loanRequest to validate.\n     */\n    modifier withValidLoanRequest(TellerCommon.LoanRequest memory loanRequest) {\n        require(\n            settings.getPlatformSettingValue(MAXIMUM_LOAN_DURATION_SETTING) >=\n                loanRequest.duration,\n            \"DURATION_EXCEEDS_MAX_DURATION\"\n        );\n        require(\n            !settings.exceedsMaxLoanAmount(\n                lendingPool.lendingToken(),\n                loanRequest.amount\n            ),\n            \"AMOUNT_EXCEEDS_MAX_AMOUNT\"\n        );\n        require(\n            _isSupplyToDebtRatioValid(loanRequest.amount),\n            \"SUPPLY_TO_DEBT_EXCEEDS_MAX\"\n        );\n        _;\n    }\n\n    /**\n        @notice Get a list of all loans for a borrower\n        @param borrower The borrower's address\n     */\n    function getBorrowerLoans(address borrower) external view returns (uint256[] memory) {\n        return borrowerLoans[borrower];\n    }\n\n    /**\n        @notice Returns the lending token in the lending pool\n        @return Address of the lending token\n     */\n    function lendingToken() external view returns (address) {\n        return lendingPool.lendingToken();\n    }\n\n    /**\n     * @notice Withdraw collateral from a loan, unless this isn't allowed\n     * @param amount The amount of collateral token or ether the caller is hoping to withdraw.\n     * @param loanID The ID of the loan the collateral is for\n     */\n    function withdrawCollateral(uint256 amount, uint256 loanID)\n        external\n        loanActiveOrSet(loanID)\n        isInitialized()\n        whenNotPaused()\n        whenLendingPoolNotPaused(address(lendingPool))\n        nonReentrant()\n    {\n        require(msg.sender == loans[loanID].loanTerms.borrower, \"CALLER_DOESNT_OWN_LOAN\");\n        require(amount > 0, \"CANNOT_WITHDRAW_ZERO\");\n\n        // Find the minimum collateral amount this loan is allowed in tokens or ether.\n        uint256 collateralNeededToken = _getCollateralNeededInTokens(\n            _getTotalOwed(loanID),\n            loans[loanID].loanTerms.collateralRatio\n        );\n        uint256 collateralNeededWei = _convertTokenToWei(collateralNeededToken);\n\n        // Withdrawal amount holds the amount of excess collateral in the loan\n        uint256 withdrawalAmount = loans[loanID].collateral.sub(collateralNeededWei);\n        if (withdrawalAmount > amount) {\n            withdrawalAmount = amount;\n        }\n\n        if (withdrawalAmount > 0) {\n            // Update the contract total and the loan collateral total\n            _payOutCollateral(loanID, withdrawalAmount, msg.sender);\n        }\n\n        emit CollateralWithdrawn(loanID, msg.sender, withdrawalAmount);\n    }\n\n    /**\n     * @notice Take out a loan\n     *\n     * @dev collateral ratio is a percentage of the loan amount that's required in collateral\n     * @dev the percentage will be *(10**2). I.e. collateralRatio of 5244 means 52.44% collateral\n     * @dev is required in the loan. Interest rate is also a percentage with 2 decimal points.\n     */\n    function takeOutLoan(uint256 loanID, uint256 amountBorrow)\n        external\n        loanTermsSet(loanID)\n        isInitialized()\n        whenNotPaused()\n        whenLendingPoolNotPaused(address(lendingPool))\n        nonReentrant()\n        isBorrower(loans[loanID].loanTerms.borrower)\n    {\n        require(\n            loans[loanID].loanTerms.maxLoanAmount >= amountBorrow,\n            \"MAX_LOAN_EXCEEDED\"\n        );\n\n        require(loans[loanID].termsExpiry >= now, \"LOAN_TERMS_EXPIRED\");\n\n        require(\n            loans[loanID].lastCollateralIn <=\n                now.sub(settings.getPlatformSettingValue(SAFETY_INTERVAL_SETTING)),\n            \"COLLATERAL_DEPOSITED_RECENTLY\"\n        );\n\n        loans[loanID].borrowedAmount = amountBorrow;\n        loans[loanID].principalOwed = amountBorrow;\n        loans[loanID].interestOwed = amountBorrow\n            .mul(loans[loanID].loanTerms.interestRate)\n            .mul(loans[loanID].loanTerms.duration)\n            .div(TEN_THOUSAND)\n            .div(DAYS_PER_YEAR_4DP);\n\n        // check that enough collateral has been provided for this loan\n        (, , , bool moreCollateralRequired) = _getCollateralInfo(loanID);\n\n        require(!moreCollateralRequired, \"MORE_COLLATERAL_REQUIRED\");\n\n        loans[loanID].loanStartTime = now;\n\n        loans[loanID].status = TellerCommon.LoanStatus.Active;\n\n        // give the recipient their requested amount of tokens\n        if (loans[loanID].loanTerms.recipient != address(0)) {\n            lendingPool.createLoan(amountBorrow, loans[loanID].loanTerms.recipient);\n        } else {\n            lendingPool.createLoan(amountBorrow, loans[loanID].loanTerms.borrower);\n        }\n\n        markets.increaseBorrow(\n            lendingPool.lendingToken(),\n            this.collateralToken(),\n            amountBorrow\n        );\n\n        emit LoanTakenOut(loanID, loans[loanID].loanTerms.borrower, amountBorrow);\n    }\n\n    /**\n     * @notice Make a payment to a loan\n     * @param amount The amount of tokens to pay back to the loan\n     * @param loanID The ID of the loan the payment is for\n     */\n    function repay(uint256 amount, uint256 loanID)\n        external\n        loanActive(loanID)\n        isInitialized()\n        whenNotPaused()\n        whenLendingPoolNotPaused(address(lendingPool))\n        nonReentrant()\n    {\n        require(amount > 0, \"AMOUNT_VALUE_REQUIRED\");\n        // calculate the actual amount to repay\n        uint256 toPay = amount;\n        uint256 totalOwed = _getTotalOwed(loanID);\n        if (totalOwed < toPay) {\n            toPay = totalOwed;\n        }\n\n        // update the amount owed on the loan\n        totalOwed = totalOwed.sub(toPay);\n        _payLoan(loanID, toPay);\n\n        // if the loan is now fully paid, close it and return collateral\n        if (totalOwed == 0) {\n            loans[loanID].status = TellerCommon.LoanStatus.Closed;\n\n            uint256 collateralAmount = loans[loanID].collateral;\n            _payOutCollateral(loanID, collateralAmount, loans[loanID].loanTerms.borrower);\n\n            emit CollateralWithdrawn(\n                loanID,\n                loans[loanID].loanTerms.borrower,\n                collateralAmount\n            );\n        }\n\n        // collect the money from the payer\n        lendingPool.repay(toPay, msg.sender);\n\n        markets.increaseRepayment(\n            lendingPool.lendingToken(),\n            this.collateralToken(),\n            toPay\n        );\n\n        emit LoanRepaid(\n            loanID,\n            loans[loanID].loanTerms.borrower,\n            toPay,\n            msg.sender,\n            totalOwed\n        );\n    }\n\n    /**\n     * @notice Liquidate a loan if it is expired or undercollateralised\n     * @param loanID The ID of the loan to be liquidated\n     */\n    function liquidateLoan(uint256 loanID)\n        external\n        loanActive(loanID)\n        isInitialized()\n        whenNotPaused()\n        whenLendingPoolNotPaused(address(lendingPool))\n        nonReentrant()\n    {\n        // calculate the amount of collateral the loan needs in tokens\n        (uint256 loanCollateral, , , bool moreCollateralRequired) = _getCollateralInfo(\n            loanID\n        );\n\n        // calculate when the loan should end\n        uint256 loanEndTime = loans[loanID].loanStartTime.add(\n            loans[loanID].loanTerms.duration\n        );\n\n        // to liquidate it must be undercollateralised, or expired\n        require(moreCollateralRequired || loanEndTime < now, \"DOESNT_NEED_LIQUIDATION\");\n\n        loans[loanID].status = TellerCommon.LoanStatus.Closed;\n        loans[loanID].liquidated = true;\n\n        uint256 collateralInTokens = _convertWeiToToken(loanCollateral);\n\n        // the caller gets the collateral from the loan\n        _payOutCollateral(loanID, loanCollateral, msg.sender);\n\n        uint256 tokenPayment = collateralInTokens\n            .mul(settings.getPlatformSettingValue(LIQUIDATE_ETH_PRICE_SETTING))\n            .div(TEN_THOUSAND);\n        // the liquidator pays x% of the collateral price\n        lendingPool.liquidationPayment(tokenPayment, msg.sender);\n\n        emit LoanLiquidated(\n            loanID,\n            loans[loanID].loanTerms.borrower,\n            msg.sender,\n            loanCollateral,\n            tokenPayment\n        );\n    }\n\n    /**\n        @notice Get collateral infomation of a specific loan\n        @param loanID of the loan to get info for\n        @return uint256 Collateral needed\n        @return uint256 Collaternal needed in Lending tokens\n        @return uint256 Collateral needed in Collateral tokens (wei)\n        @return bool If more collateral is needed or not\n     */\n    function getCollateralInfo(uint256 loanID)\n        external\n        view\n        returns (\n            uint256 collateral,\n            uint256 collateralNeededLendingTokens,\n            uint256 collateralNeededCollateralTokens,\n            bool moreCollateralRequired\n        )\n    {\n        return _getCollateralInfo(loanID);\n    }\n\n    /**\n        @notice Updates the current price oracle instance.\n        @dev It throws a require error if sender is not allowed.\n        @dev It throws a require error if new address is empty (0x0) or not a contract.\n        @param newPriceOracle the new price oracle address.\n     */\n    function setPriceOracle(address newPriceOracle)\n        external\n        isInitialized()\n        whenAllowed(msg.sender)\n    {\n        // New address must be a contract and not empty\n        require(newPriceOracle.isContract(), \"ORACLE_MUST_CONTRACT_NOT_EMPTY\");\n        address oldPriceOracle = address(priceOracle);\n        oldPriceOracle.requireNotEqualTo(newPriceOracle, \"NEW_ORACLE_MUST_BE_PROVIDED\");\n\n        priceOracle = newPriceOracle;\n\n        emit PriceOracleUpdated(msg.sender, oldPriceOracle, newPriceOracle);\n    }\n\n    /** Internal Functions */\n    /**\n        @notice Pays out the collateral for a loan\n        @param loanID ID of loan from which collateral is to be paid out\n        @param amount Amount of collateral paid out\n        @param recipient Account address of the recipient of the collateral\n     */\n    function _payOutCollateral(uint256 loanID, uint256 amount, address payable recipient)\n        internal;\n\n    /**\n        @notice Get collateral infomation of a specific loan\n        @param loanID of the loan to get info for\n        @return uint256 Collateral needed\n        @return uint256 Collaternal needed in Lending tokens\n        @return uint256 Collateral needed in Collateral tokens (wei)\n        @return bool If more collateral is needed or not\n     */\n    function _getCollateralInfo(uint256 loanID)\n        internal\n        view\n        returns (\n            uint256 collateral,\n            uint256 collateralNeededLendingTokens,\n            uint256 collateralNeededCollateralTokens,\n            bool moreCollateralRequired\n        )\n    {\n        collateral = loans[loanID].collateral;\n        (\n            collateralNeededLendingTokens,\n            collateralNeededCollateralTokens\n        ) = _getCollateralNeededInfo(\n            _getTotalOwed(loanID),\n            loans[loanID].loanTerms.collateralRatio\n        );\n        moreCollateralRequired = collateralNeededCollateralTokens > collateral;\n    }\n\n    /**\n       @notice Get information on the collateral needed for the loan\n       @param totalOwed Total amount owed for the loan\n       @param collateralRatio Collateral ratio set in the loan terms\n       @return uint256 Collaternal needed in Lending tokens\n       @return uint256 Collateral needed in Collateral tokens (wei)\n     */\n    function _getCollateralNeededInfo(uint256 totalOwed, uint256 collateralRatio)\n        internal\n        view\n        returns (\n            uint256 collateralNeededLendingTokens,\n            uint256 collateralNeededCollateralTokens\n        )\n    {\n        // Get collateral needed in lending tokens.\n        uint256 collateralNeededToken = _getCollateralNeededInTokens(\n            totalOwed,\n            collateralRatio\n        );\n        // Convert collateral (in lending tokens) into collateral tokens.\n        return (collateralNeededToken, _convertTokenToWei(collateralNeededToken));\n    }\n\n    /**\n        @notice Initializes the current contract instance setting the required parameters.\n        @param priceOracleAddress Contract address of the price oracle\n        @param lendingPoolAddress Contract address of the lending pool\n        @param loanTermsConsensusAddress Contract adddress for loan term consensus\n        @param settingsAddress Contract address for the configuration of the platform\n        @param marketsAddress Contract address to store market data.\n        @param atmSettingsAddress Contract address to get ATM settings data.\n     */\n    function _initialize(\n        address priceOracleAddress,\n        address lendingPoolAddress,\n        address loanTermsConsensusAddress,\n        address settingsAddress,\n        address marketsAddress,\n        address atmSettingsAddress\n    ) internal isNotInitialized() {\n        priceOracleAddress.requireNotEmpty(\"PROVIDE_ORACLE_ADDRESS\");\n        lendingPoolAddress.requireNotEmpty(\"PROVIDE_LENDINGPOOL_ADDRESS\");\n        loanTermsConsensusAddress.requireNotEmpty(\"PROVIDED_LOAN_TERMS_ADDRESS\");\n        atmSettingsAddress.requireNotEmpty(\"PROVIDED_ATM_SETTINGS_ADDRESS\");\n\n        _initialize(settingsAddress, marketsAddress);\n\n        priceOracle = priceOracleAddress;\n        lendingPool = LendingPoolInterface(lendingPoolAddress);\n        loanTermsConsensus = LoanTermsConsensusInterface(loanTermsConsensusAddress);\n        atmSettings = IATMSettings(atmSettingsAddress);\n    }\n\n    /**\n        @notice Pays collateral in for the associated loan\n        @param loanID The ID of the loan the collateral is for\n        @param amount The amount of collateral to be paid\n     */\n    function _payInCollateral(uint256 loanID, uint256 amount) internal {\n        totalCollateral = totalCollateral.add(amount);\n        loans[loanID].collateral = loans[loanID].collateral.add(amount);\n        loans[loanID].lastCollateralIn = now;\n    }\n\n    /**\n        @notice Make a payment towards the prinicial and interest for a specified loan\n        @param loanID The ID of the loan the payment is for\n        @param toPay The amount of tokens to pay to the loan\n     */\n    function _payLoan(uint256 loanID, uint256 toPay) internal {\n        if (toPay > loans[loanID].principalOwed) {\n            uint256 leftToPay = toPay;\n            leftToPay = leftToPay.sub(loans[loanID].principalOwed);\n            loans[loanID].principalOwed = 0;\n            loans[loanID].interestOwed = loans[loanID].interestOwed.sub(leftToPay);\n        } else {\n            loans[loanID].principalOwed = loans[loanID].principalOwed.sub(toPay);\n        }\n    }\n\n    /**\n        @notice Returns the total owed amount remaining for a specified loan\n        @param loanID The ID of the loan to be queried\n        @return uint256 The total amount owed remaining\n     */\n    function _getTotalOwed(uint256 loanID) internal view returns (uint256) {\n        return loans[loanID].interestOwed.add(loans[loanID].principalOwed);\n    }\n\n    /**\n        @notice Returns the value of collateral\n        @param loanAmount The total amount of the loan for which collateral is needed\n        @param collateralRatio Collateral ratio set in the loan terms\n        @return uint256 The amount of collateral needed in lending tokens (not wei)\n     */\n    function _getCollateralNeededInTokens(uint256 loanAmount, uint256 collateralRatio)\n        internal\n        pure\n        returns (uint256)\n    {\n        return loanAmount.mul(collateralRatio).div(TEN_THOUSAND);\n    }\n\n    /**\n        @notice Converts the collateral tokens to lending tokens\n        @param weiAmount The amount of wei to be converted\n        @return uint256 The value the collateal tokens (wei) in lending tokens (not wei)\n     */\n    function _convertWeiToToken(uint256 weiAmount) internal view returns (uint256) {\n        // wei amount / lending token price in wei * the lending token decimals.\n        uint256 aWholeLendingToken = ERC20(lendingPool.lendingToken()).getAWholeToken();\n        uint256 oneLendingTokenPriceWei = uint256(\n            PairAggregatorInterface(priceOracle).getLatestAnswer()\n        );\n        uint256 tokenValue = weiAmount.mul(aWholeLendingToken).div(\n            oneLendingTokenPriceWei\n        );\n        return tokenValue;\n    }\n\n    /**\n        @notice Converts the lending token to collareal tokens\n        @param tokenAmount The amount in lending tokens (not wei) to be converted\n        @return uint256 The value of lending tokens (not wei) in collateral tokens (wei)\n     */\n    function _convertTokenToWei(uint256 tokenAmount) internal view returns (uint256) {\n        // tokenAmount is in token units, chainlink price is in whole tokens\n        // token amount in tokens * lending token price in wei / the lending token decimals.\n        uint256 aWholeLendingToken = ERC20(lendingPool.lendingToken()).getAWholeToken();\n        uint256 oneLendingTokenPriceWei = uint256(\n            PairAggregatorInterface(priceOracle).getLatestAnswer()\n        );\n        uint256 weiValue = tokenAmount.mul(oneLendingTokenPriceWei).div(\n            aWholeLendingToken\n        );\n        return weiValue;\n    }\n\n    /**\n        @notice Returns the current loan ID and increments it by 1\n        @return uint256 The current loan ID before incrementing\n     */\n    function getAndIncrementLoanID() internal returns (uint256 newLoanID) {\n        newLoanID = loanIDCounter;\n        loanIDCounter += 1;\n    }\n\n    /**\n        @notice Creates a loan with the loan request\n        @param loanID The ID of the loan\n        @param request Loan request as per the struct of the Teller platform\n        @param interestRate Interest rate set in the loan terms\n        @param collateralRatio Collateral ratio set in the loan terms\n        @param maxLoanAmount Maximum loan amount that can be taken out, set in the loan terms\n        @return memory TellerCommon.Loan Loan struct as per the Teller platform\n     */\n    function createLoan(\n        uint256 loanID,\n        TellerCommon.LoanRequest memory request,\n        uint256 interestRate,\n        uint256 collateralRatio,\n        uint256 maxLoanAmount\n    ) internal view returns (TellerCommon.Loan memory) {\n        uint256 termsExpiry = now.add(\n            settings.getPlatformSettingValue(TERMS_EXPIRY_TIME_SETTING)\n        );\n        return\n            TellerCommon.Loan({\n                id: loanID,\n                loanTerms: TellerCommon.LoanTerms({\n                    borrower: request.borrower,\n                    recipient: request.recipient,\n                    interestRate: interestRate,\n                    collateralRatio: collateralRatio,\n                    maxLoanAmount: maxLoanAmount,\n                    duration: request.duration\n                }),\n                termsExpiry: termsExpiry,\n                loanStartTime: 0,\n                collateral: 0,\n                lastCollateralIn: 0,\n                principalOwed: 0,\n                interestOwed: 0,\n                borrowedAmount: 0,\n                status: TellerCommon.LoanStatus.TermsSet,\n                liquidated: false\n            });\n    }\n\n    function _emitLoanTermsSetAndCollateralDepositedEventsIfApplicable(\n        uint256 loanID,\n        TellerCommon.LoanRequest memory request,\n        uint256 interestRate,\n        uint256 collateralRatio,\n        uint256 maxLoanAmount,\n        uint256 depositedAmount\n    ) internal {\n        emit LoanTermsSet(\n            loanID,\n            request.borrower,\n            request.recipient,\n            interestRate,\n            collateralRatio,\n            maxLoanAmount,\n            request.duration,\n            loans[loanID].termsExpiry\n        );\n        if (depositedAmount > 0) {\n            emit CollateralDeposited(loanID, request.borrower, depositedAmount);\n        }\n    }\n\n    /**\n        @notice It validates whether supply to debt (StD) ratio is valid including the loan amount.\n        @param newLoanAmount the new loan amount to consider o the StD ratio.\n        @return true if the ratio is valid. Otherwise it returns false.\n     */\n    function _isSupplyToDebtRatioValid(uint256 newLoanAmount)\n        internal\n        view\n        returns (bool)\n    {\n        address atmAddressForMarket = atmSettings.getATMForMarket(\n            lendingPool.lendingToken(),\n            collateralToken\n        );\n        require(atmAddressForMarket != address(0x0), \"ATM_NOT_FOUND_FOR_MARKET\");\n        uint256 supplyToDebtMarketLimit = IATMGovernance(atmAddressForMarket)\n            .getGeneralSetting(SUPPLY_TO_DEBT_ATM_SETTING);\n        uint256 currentSupplyToDebtMarket = markets.getSupplyToDebtFor(\n            lendingPool.lendingToken(),\n            collateralToken,\n            newLoanAmount\n        );\n        return currentSupplyToDebtMarket <= supplyToDebtMarketLimit;\n    }\n}\n\ncontract EtherCollateralLoans is LoansBase {\n    /**\n     * @notice Deposit collateral into a loan\n     * @param borrower The address of the loan borrower.\n     * @param loanID The ID of the loan the collateral is for\n     */\n    function depositCollateral(address borrower, uint256 loanID, uint256 amount)\n        external\n        payable\n        loanActiveOrSet(loanID)\n        isInitialized()\n        whenNotPaused()\n        whenLendingPoolNotPaused(address(lendingPool))\n    {\n        require(\n            loans[loanID].loanTerms.borrower == borrower,\n            \"BORROWER_LOAN_ID_MISMATCH\"\n        );\n        require(msg.value == amount, \"INCORRECT_ETH_AMOUNT\");\n        require(msg.value > 0, \"CANNOT_DEPOSIT_ZERO\");\n\n        // Update the contract total and the loan collateral total\n        _payInCollateral(loanID, amount);\n\n        emit CollateralDeposited(loanID, borrower, amount);\n    }\n\n    /**\n        @notice Creates a loan with the loan request and terms\n        @param request Struct of the protocol loan request\n        @param responses List of structs of the protocol loan responses\n        @param collateralAmount Amount of collateral required for the loan\n     */\n    function createLoanWithTerms(\n        TellerCommon.LoanRequest calldata request,\n        TellerCommon.LoanResponse[] calldata responses,\n        uint256 collateralAmount\n    )\n        external\n        payable\n        isInitialized()\n        whenNotPaused()\n        isBorrower(request.borrower)\n        withValidLoanRequest(request)\n    {\n        require(msg.value == collateralAmount, \"INCORRECT_ETH_AMOUNT\");\n\n        uint256 loanID = getAndIncrementLoanID();\n        (\n            uint256 interestRate,\n            uint256 collateralRatio,\n            uint256 maxLoanAmount\n        ) = loanTermsConsensus.processRequest(request, responses);\n\n        loans[loanID] = createLoan(\n            loanID,\n            request,\n            interestRate,\n            collateralRatio,\n            maxLoanAmount\n        );\n\n        if (msg.value > 0) {\n            // Update collateral, totalCollateral, and lastCollateralIn\n            _payInCollateral(loanID, msg.value);\n        }\n\n        borrowerLoans[request.borrower].push(loanID);\n\n        _emitLoanTermsSetAndCollateralDepositedEventsIfApplicable(\n            loanID,\n            request,\n            interestRate,\n            collateralRatio,\n            maxLoanAmount,\n            msg.value\n        );\n    }\n\n    /**\n        @notice Initializes the current contract instance setting the required parameters\n        @param priceOracleAddress Contract address of the price oracle\n        @param lendingPoolAddress Contract address of the lending pool\n        @param loanTermsConsensusAddress Contract adddress for loan term consensus\n        @param settingsAddress Contract address for the configuration of the platform\n        @param marketsAddress Contract address to store the market data.\n        @param atmSettingsAddress Contract address to get ATM settings data.\n     */\n    function initialize(\n        address priceOracleAddress,\n        address lendingPoolAddress,\n        address loanTermsConsensusAddress,\n        address settingsAddress,\n        address marketsAddress,\n        address atmSettingsAddress\n    ) external isNotInitialized() {\n        _initialize(\n            priceOracleAddress,\n            lendingPoolAddress,\n            loanTermsConsensusAddress,\n            settingsAddress,\n            marketsAddress,\n            atmSettingsAddress\n        );\n\n        collateralToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n\n    /** Internal Functions */\n    /**\n        @notice Pays out collateral for the associated loan\n        @param loanID The ID of the loan the collateral is for\n        @param amount The amount of collateral to be paid\n     */\n    function _payOutCollateral(uint256 loanID, uint256 amount, address payable recipient)\n        internal\n    {\n        totalCollateral = totalCollateral.sub(amount);\n        loans[loanID].collateral = loans[loanID].collateral.sub(amount);\n        recipient.transfer(amount);\n    }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"CollateralDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalAmount\",\"type\":\"uint256\"}],\"name\":\"CollateralWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIn\",\"type\":\"uint256\"}],\"name\":\"LoanLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalOwed\",\"type\":\"uint256\"}],\"name\":\"LoanRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBorrowed\",\"type\":\"uint256\"}],\"name\":\"LoanTakenOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLoanAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"termsExpiry\",\"type\":\"uint256\"}],\"name\":\"LoanTermsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPriceOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPriceOracle\",\"type\":\"address\"}],\"name\":\"PriceOracleUpdated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATE_ETH_PRICE_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_LOAN_DURATION_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_TOLERANCE_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REQUEST_LOAN_TERMS_RATE_LIMIT_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REQUIRED_SUBMISSIONS_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESPONSE_EXPIRY_LENGTH_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFETY_INTERVAL_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TERMS_EXPIRY_TIME_SETTING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"atmSettings\",\"outputs\":[{\"internalType\":\"contract IATMSettings\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"borrowerLoans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"consensusAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestTime\",\"type\":\"uint256\"}],\"internalType\":\"struct TellerCommon.LoanRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"consensusAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"responseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"signerNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct TellerCommon.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct TellerCommon.LoanResponse[]\",\"name\":\"responses\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"createLoanWithTerms\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getBorrowerLoans\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"getCollateralInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNeededLendingTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralNeededCollateralTokens\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"moreCollateralRequired\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceOracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lendingPoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loanTermsConsensusAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settingsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"atmSettingsAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract LendingPoolInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lendingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"liquidateLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanIDCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanTermsConsensus\",\"outputs\":[{\"internalType\":\"contract LoanTermsConsensusInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct TellerCommon.LoanTerms\",\"name\":\"loanTerms\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"termsExpiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCollateralIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalOwed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestOwed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum TellerCommon.LoanStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"liquidated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"contract MarketsStateInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPriceOracle\",\"type\":\"address\"}],\"name\":\"setPriceOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"contract SettingsInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBorrow\",\"type\":\"uint256\"}],\"name\":\"takeOutLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherCollateralLoans","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}