{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"Babylonian.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity \\u003e=0.4.0;\\r\\n\\r\\n// computes square roots using the babylonian method\\r\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\r\\nlibrary Babylonian {\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y \\u003e 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x \\u003c z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n        // else z = 0\\r\\n    }\\r\\n}\\r\\n\"},\"FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity \\u003e=0.4.0;\\r\\n\\r\\nimport \\u0027./Babylonian.sol\\u0027;\\r\\n\\r\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\r\\nlibrary FixedPoint {\\r\\n    // range: [0, 2**112 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq112x112 {\\r\\n        uint224 _x;\\r\\n    }\\r\\n\\r\\n    // range: [0, 2**144 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq144x112 {\\r\\n        uint _x;\\r\\n    }\\r\\n\\r\\n    uint8 private constant RESOLUTION = 112;\\r\\n    uint private constant Q112 = uint(1) \\u003c\\u003c RESOLUTION;\\r\\n    uint private constant Q224 = Q112 \\u003c\\u003c RESOLUTION;\\r\\n\\r\\n    // encode a uint112 as a UQ112x112\\r\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\r\\n        return uq112x112(uint224(x) \\u003c\\u003c RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // encodes a uint144 as a UQ144x112\\r\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\r\\n        return uq144x112(uint256(x) \\u003c\\u003c RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\r\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\r\\n        require(x != 0, \\u0027FixedPoint: DIV_BY_ZERO\\u0027);\\r\\n        return uq112x112(self._x / uint224(x));\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\r\\n    // reverts on overflow\\r\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\r\\n        uint z;\\r\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\r\\n        return uq144x112(z);\\r\\n    }\\r\\n\\r\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\r\\n    // equivalent to encode(numerator).div(denominator)\\r\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\r\\n        require(denominator \\u003e 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\r\\n        return uq112x112((uint224(numerator) \\u003c\\u003c RESOLUTION) / denominator);\\r\\n    }\\r\\n\\r\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\r\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\r\\n        return uint112(self._x \\u003e\\u003e RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\r\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\r\\n        return uint144(self._x \\u003e\\u003e RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // take the reciprocal of a UQ112x112\\r\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        require(self._x != 0, \\u0027FixedPoint: ZERO_RECIPROCAL\\u0027);\\r\\n        return uq112x112(uint224(Q224 / self._x));\\r\\n    }\\r\\n\\r\\n    // square root of a UQ112x112\\r\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) \\u003c\\u003c 56));\\r\\n    }\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface UniswapPair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.4.21 \\u003c0.7.0;\\r\\n\\r\\ncontract Migrations {\\r\\n  address public owner;\\r\\n  uint public last_completed_migration;\\r\\n\\r\\n  constructor() public {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  modifier restricted() {\\r\\n    if (msg.sender == owner) _;\\r\\n  }\\r\\n\\r\\n  function setCompleted(uint completed) public restricted {\\r\\n    last_completed_migration = completed;\\r\\n  }\\r\\n}\\r\\n\"},\"PYLON.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\n/* import \\\"./PYLONTokenInterface.sol\\\"; */\\r\\nimport \\\"./PYLONGovernance.sol\\\";\\r\\n\\r\\ncontract PYLONToken is PYLONGovernanceToken {\\r\\n    // Modifiers\\r\\n    modifier onlyGov() {\\r\\n        require(msg.sender == gov);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRebaser() {\\r\\n        require(msg.sender == rebaser);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMinter() {\\r\\n        require(msg.sender == rebaser || msg.sender == incentivizer || msg.sender == gov, \\\"not minter\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validRecipient(address to) {\\r\\n        require(to != address(0x0));\\r\\n        require(to != address(this));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initialize(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        require(pylonsScalingFactor == 0, \\\"already initialized\\\");\\r\\n        name = name_;\\r\\n        symbol = symbol_;\\r\\n        decimals = decimals_;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n    * @notice Computes the current max scaling factor\\r\\n    */\\r\\n    function maxScalingFactor()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _maxScalingFactor();\\r\\n    }\\r\\n\\r\\n    function _maxScalingFactor()\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // scaling factor can only go up to 2**256-1 = initSupply * pylonsScalingFactor\\r\\n        // this is used to check if pylonsScalingFactor will be too high to compute balances when rebasing.\\r\\n        return uint256(-1) / initSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Mints new tokens, increasing totalSupply, initSupply, and a users balance.\\r\\n    * @dev Limited to onlyMinter modifier\\r\\n    */\\r\\n    function mint(address to, uint256 amount)\\r\\n        external\\r\\n        onlyMinter\\r\\n        returns (bool)\\r\\n    {\\r\\n        _mint(to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _mint(address to, uint256 amount)\\r\\n        internal\\r\\n    {\\r\\n      // increase totalSupply\\r\\n      totalSupply = totalSupply.add(amount);\\r\\n\\r\\n      // get underlying value\\r\\n      uint256 pylonValue = amount.mul(internalDecimals).div(pylonsScalingFactor);\\r\\n\\r\\n      // increase initSupply\\r\\n      initSupply = initSupply.add(pylonValue);\\r\\n\\r\\n      // make sure the mint didnt push maxScalingFactor too low\\r\\n      require(pylonsScalingFactor \\u003c= _maxScalingFactor(), \\\"max scaling factor too low\\\");\\r\\n\\r\\n      // add balance\\r\\n      _pylonBalances[to] = _pylonBalances[to].add(pylonValue);\\r\\n\\r\\n      // add delegates to the minter\\r\\n      _moveDelegates(address(0), _delegates[to], pylonValue);\\r\\n      emit Mint(to, amount);\\r\\n    }\\r\\n\\r\\n    /* - ERC20 functionality - */\\r\\n\\r\\n    /**\\r\\n    * @dev Transfer tokens to a specified address.\\r\\n    * @param to The address to transfer to.\\r\\n    * @param value The amount to be transferred.\\r\\n    * @return True on success, false otherwise.\\r\\n    */\\r\\n    function transfer(address to, uint256 value)\\r\\n        external\\r\\n        validRecipient(to)\\r\\n        returns (bool)\\r\\n    {\\r\\n        // underlying balance is stored in pylons, so divide by current scaling factor\\r\\n\\r\\n        // note, this means as scaling factor grows, dust will be untransferrable.\\r\\n        // minimum transfer value == pylonsScalingFactor / 1e24;\\r\\n\\r\\n        // get amount in underlying\\r\\n        uint256 pylonValue = value.mul(internalDecimals).div(pylonsScalingFactor);\\r\\n\\r\\n        // sub from balance of sender\\r\\n        _pylonBalances[msg.sender] = _pylonBalances[msg.sender].sub(pylonValue);\\r\\n\\r\\n        // add to balance of receiver\\r\\n        _pylonBalances[to] = _pylonBalances[to].add(pylonValue);\\r\\n        emit Transfer(msg.sender, to, value);\\r\\n\\r\\n        _moveDelegates(_delegates[msg.sender], _delegates[to], pylonValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Transfer tokens from one address to another.\\r\\n    * @param from The address you want to send tokens from.\\r\\n    * @param to The address you want to transfer to.\\r\\n    * @param value The amount of tokens to be transferred.\\r\\n    */\\r\\n    function transferFrom(address from, address to, uint256 value)\\r\\n        external\\r\\n        validRecipient(to)\\r\\n        returns (bool)\\r\\n    {\\r\\n        // decrease allowance\\r\\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\\r\\n\\r\\n        // get value in pylons\\r\\n        uint256 pylonValue = value.mul(internalDecimals).div(pylonsScalingFactor);\\r\\n\\r\\n        // sub from from\\r\\n        _pylonBalances[from] = _pylonBalances[from].sub(pylonValue);\\r\\n        _pylonBalances[to] = _pylonBalances[to].add(pylonValue);\\r\\n        emit Transfer(from, to, value);\\r\\n\\r\\n        _moveDelegates(_delegates[from], _delegates[to], pylonValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @param who The address to query.\\r\\n    * @return The balance of the specified address.\\r\\n    */\\r\\n    function balanceOf(address who)\\r\\n      external\\r\\n      view\\r\\n      returns (uint256)\\r\\n    {\\r\\n      return _pylonBalances[who].mul(pylonsScalingFactor).div(internalDecimals);\\r\\n    }\\r\\n\\r\\n    /** @notice Currently returns the internal storage amount\\r\\n    * @param who The address to query.\\r\\n    * @return The underlying balance of the specified address.\\r\\n    */\\r\\n    function balanceOfUnderlying(address who)\\r\\n      external\\r\\n      view\\r\\n      returns (uint256)\\r\\n    {\\r\\n      return _pylonBalances[who];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\\r\\n     * @param owner_ The address which owns the funds.\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @return The number of tokens still available for the spender.\\r\\n     */\\r\\n    function allowance(address owner_, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowedFragments[owner_][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\\r\\n     * msg.sender. This method is included for ERC20 compatibility.\\r\\n     * increaseAllowance and decreaseAllowance should be used instead.\\r\\n     * Changing an allowance with this method brings the risk that someone may transfer both\\r\\n     * the old and the new allowance - if they are both greater than zero - if a transfer\\r\\n     * transaction is mined before the later approve() call is mined.\\r\\n     *\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param value The amount of tokens to be spent.\\r\\n     */\\r\\n    function approve(address spender, uint256 value)\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] = value;\\r\\n        emit Approval(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\\r\\n     * This method should be used instead of approve() to avoid the double approval vulnerability\\r\\n     * described above.\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param addedValue The amount of tokens to increase the allowance by.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] =\\r\\n            _allowedFragments[msg.sender][spender].add(addedValue);\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\\r\\n     *\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\r\\n        if (subtractedValue \\u003e= oldValue) {\\r\\n            _allowedFragments[msg.sender][spender] = 0;\\r\\n        } else {\\r\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\\r\\n        }\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /* - Governance Functions - */\\r\\n\\r\\n    /** @notice sets the rebaser\\r\\n     * @param rebaser_ The address of the rebaser contract to use for authentication.\\r\\n     */\\r\\n    function _setRebaser(address rebaser_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        address oldRebaser = rebaser;\\r\\n        rebaser = rebaser_;\\r\\n        emit NewRebaser(oldRebaser, rebaser_);\\r\\n    }\\r\\n\\r\\n    /** @notice sets the incentivizer\\r\\n     * @param incentivizer_ The address of the rebaser contract to use for authentication.\\r\\n     */\\r\\n    function _setIncentivizer(address incentivizer_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        address oldIncentivizer = incentivizer;\\r\\n        incentivizer = incentivizer_;\\r\\n        emit NewIncentivizer(oldIncentivizer, incentivizer_);\\r\\n    }\\r\\n\\r\\n    /** @notice sets the pendingGov\\r\\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\\r\\n     */\\r\\n    function _setPendingGov(address pendingGov_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        address oldPendingGov = pendingGov;\\r\\n        pendingGov = pendingGov_;\\r\\n        emit NewPendingGov(oldPendingGov, pendingGov_);\\r\\n    }\\r\\n\\r\\n    /** @notice lets msg.sender accept governance\\r\\n     *\\r\\n     */\\r\\n    function _acceptGov()\\r\\n        external\\r\\n    {\\r\\n        require(msg.sender == pendingGov, \\\"!pending\\\");\\r\\n        address oldGov = gov;\\r\\n        gov = pendingGov;\\r\\n        pendingGov = address(0);\\r\\n        emit NewGov(oldGov, gov);\\r\\n    }\\r\\n\\r\\n    /* - Extras - */\\r\\n\\r\\n    /**\\r\\n    * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\\r\\n    *\\r\\n    * @dev The supply adjustment equals (totalSupply * DeviationFromTargetRate) / rebaseLag\\r\\n    *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\\r\\n    *      and targetRate is CpiOracleRate / baseCpi\\r\\n    */\\r\\n    function rebase(\\r\\n        uint256 epoch,\\r\\n        uint256 indexDelta,\\r\\n        bool positive\\r\\n    )\\r\\n        external\\r\\n        onlyRebaser\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (indexDelta == 0) {\\r\\n          emit Rebase(epoch, pylonsScalingFactor, pylonsScalingFactor);\\r\\n          return totalSupply;\\r\\n        }\\r\\n\\r\\n        uint256 prevPYLONsScalingFactor = pylonsScalingFactor;\\r\\n\\r\\n        if (!positive) {\\r\\n           pylonsScalingFactor = pylonsScalingFactor.mul(BASE.sub(indexDelta)).div(BASE);\\r\\n        } else {\\r\\n            uint256 newScalingFactor = pylonsScalingFactor.mul(BASE.add(indexDelta)).div(BASE);\\r\\n            if (newScalingFactor \\u003c _maxScalingFactor()) {\\r\\n                pylonsScalingFactor = newScalingFactor;\\r\\n            } else {\\r\\n              pylonsScalingFactor = _maxScalingFactor();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        totalSupply = initSupply.mul(pylonsScalingFactor);\\r\\n        emit Rebase(epoch, prevPYLONsScalingFactor, pylonsScalingFactor);\\r\\n        return totalSupply;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PYLON is PYLONToken {\\r\\n    /**\\r\\n     * @notice Initialize the new money market\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     */\\r\\n    function initialize(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        address initial_owner,\\r\\n        uint256 initSupply_\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        require(initSupply_ \\u003e 0, \\\"0 init supply\\\");\\r\\n\\r\\n        super.initialize(name_, symbol_, decimals_);\\r\\n\\r\\n        initSupply = initSupply_.mul(10**24/ (BASE));\\r\\n        totalSupply = initSupply_;\\r\\n        pylonsScalingFactor = BASE;\\r\\n        _pylonBalances[initial_owner] = initSupply_.mul(10**24 / (BASE));\\r\\n\\r\\n        // owner renounces ownership after deployment as they need to set\\r\\n        // rebaser and incentivizer\\r\\n        // gov = gov_;\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONCOMPPool.sol\":{\"content\":\"/*\\r\\n   ____            __   __        __   _\\r\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\r\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\r\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\r\\n     /___/\\r\\n\\r\\n* Synthetix: PYLONRewards.sol\\r\\n*\\r\\n* Docs: https://docs.synthetix.io/\\r\\n*\\r\\n*\\r\\n* MIT License\\r\\n* ===========\\r\\n*\\r\\n* Copyright (c) 2020 Synthetix\\r\\n*\\r\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n* in the Software without restriction, including without limitation the rights\\r\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n* copies of the Software, and to permit persons to whom the Software is\\r\\n* furnished to do so, subject to the following conditions:\\r\\n*\\r\\n* The above copyright notice and this permission notice shall be included in all\\r\\n* copies or substantial portions of the Software.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/IRewardDistributionRecipient.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ncontract IRewardDistributionRecipient is Ownable {\\r\\n    address public rewardDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardDistribution() {\\r\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setRewardDistribution(address _rewardDistribution)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardDistribution = _rewardDistribution;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/CurveRewards.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ninterface PYLON {\\r\\n    function pylonsScalingFactor() external returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract LPTokenWrapper {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public comp = IERC20(0xc00e94Cb662C3520282E6f5717214004A7f26888);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        comp.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        comp.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PYLONCOMPPool is LPTokenWrapper, IRewardDistributionRecipient {\\r\\n    IERC20 public pylon = IERC20(0xD7B7d3C0bdA57723Fb54ab95Fd8F9EA033AF37f2);\\r\\n    uint256 public constant DURATION = 864000; // 10 days\\r\\n\\r\\n    uint256 public starttime = 1598918400; // 2020-09-01 00:00:00 (UTC UTC +00:00)\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier checkStart() {\\r\\n        require(block.timestamp \\u003e= starttime,\\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    // stake visibility is public as overriding LPTokenWrapper\\u0027s stake() function\\r\\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        super.stake(amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        super.withdraw(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(balanceOf(msg.sender));\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    function getReward() public updateReward(msg.sender) checkStart {\\r\\n        uint256 reward = earned(msg.sender);\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 trueReward = reward.mul(scalingFactor).div(10**18);\\r\\n            pylon.safeTransfer(msg.sender, trueReward);\\r\\n            emit RewardPaid(msg.sender, trueReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward)\\r\\n        external\\r\\n        onlyRewardDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        if (block.timestamp \\u003e starttime) {\\r\\n          if (block.timestamp \\u003e= periodFinish) {\\r\\n              rewardRate = reward.div(DURATION);\\r\\n          } else {\\r\\n              uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n              uint256 leftover = remaining.mul(rewardRate);\\r\\n              rewardRate = reward.add(leftover).div(DURATION);\\r\\n          }\\r\\n          lastUpdateTime = block.timestamp;\\r\\n          periodFinish = block.timestamp.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        } else {\\r\\n          rewardRate = reward.div(DURATION);\\r\\n          lastUpdateTime = starttime;\\r\\n          periodFinish = starttime.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONDelegate.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./PYLON.sol\\\";\\r\\n\\r\\ncontract PYLONDelegationStorage {\\r\\n    /**\\r\\n     * @notice Implementation address for this contract\\r\\n     */\\r\\n    address public implementation;\\r\\n}\\r\\n\\r\\ncontract PYLONDelegatorInterface is PYLONDelegationStorage {\\r\\n    /**\\r\\n     * @notice Emitted when implementation is changed\\r\\n     */\\r\\n    event NewImplementation(address oldImplementation, address newImplementation);\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the gov to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\\r\\n}\\r\\n\\r\\ncontract PYLONDelegateInterface is PYLONDelegationStorage {\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\r\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes memory data) public;\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\r\\n     */\\r\\n    function _resignImplementation() public;\\r\\n}\\r\\n\\r\\n\\r\\ncontract PYLONDelegate is PYLON, PYLONDelegateInterface {\\r\\n    /**\\r\\n     * @notice Construct an empty delegate\\r\\n     */\\r\\n    constructor() public {}\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes memory data) public {\\r\\n        // Shh -- currently unused\\r\\n        data;\\r\\n\\r\\n        // Shh -- we don\\u0027t ever want this hook to be marked pure\\r\\n        if (false) {\\r\\n            implementation = address(0);\\r\\n        }\\r\\n\\r\\n        require(msg.sender == gov, \\\"only the gov may call _becomeImplementation\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\r\\n     */\\r\\n    function _resignImplementation() public {\\r\\n        // Shh -- we don\\u0027t ever want this hook to be marked pure\\r\\n        if (false) {\\r\\n            implementation = address(0);\\r\\n        }\\r\\n\\r\\n        require(msg.sender == gov, \\\"only the gov may call _resignImplementation\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONDelegator.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./PYLONTokenInterface.sol\\\";\\r\\nimport \\\"./PYLONDelegate.sol\\\";\\r\\n\\r\\ncontract PYLONDelegator is PYLONTokenInterface, PYLONDelegatorInterface {\\r\\n    /**\\r\\n     * @notice Construct a new PYLON\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     * @param initSupply_ Initial token amount\\r\\n     * @param implementation_ The address of the implementation the contract delegates to\\r\\n     * @param becomeImplementationData The encoded args for becomeImplementation\\r\\n     */\\r\\n    constructor(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        uint256 initSupply_,\\r\\n        address implementation_,\\r\\n        bytes memory becomeImplementationData\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n\\r\\n\\r\\n        // Creator of the contract is gov during initialization\\r\\n        gov = msg.sender;\\r\\n\\r\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\r\\n        delegateTo(\\r\\n            implementation_,\\r\\n            abi.encodeWithSignature(\\r\\n                \\\"initialize(string,string,uint8,address,uint256)\\\",\\r\\n                name_,\\r\\n                symbol_,\\r\\n                decimals_,\\r\\n                msg.sender,\\r\\n                initSupply_\\r\\n            )\\r\\n        );\\r\\n\\r\\n        // New implementations always get set via the settor (post-initialize)\\r\\n        _setImplementation(implementation_, false, becomeImplementationData);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the gov to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\\r\\n        require(msg.sender == gov, \\\"PYLONDelegator::_setImplementation: Caller must be gov\\\");\\r\\n\\r\\n        if (allowResign) {\\r\\n            delegateToImplementation(abi.encodeWithSignature(\\\"_resignImplementation()\\\"));\\r\\n        }\\r\\n\\r\\n        address oldImplementation = implementation;\\r\\n        implementation = implementation_;\\r\\n\\r\\n        delegateToImplementation(abi.encodeWithSignature(\\\"_becomeImplementation(bytes)\\\", becomeImplementationData));\\r\\n\\r\\n        emit NewImplementation(oldImplementation, implementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function mint(address to, uint256 mintAmount)\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        to; mintAmount; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transfer(address dst, uint256 amount)\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        dst; amount; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        src; dst; amount; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n     * @dev This will overwrite the approval amount for `spender`\\r\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\r\\n     * @return Whether or not the approval succeeded\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        spender; amount; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\\r\\n     * This method should be used instead of approve() to avoid the double approval vulnerability\\r\\n     * described above.\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param addedValue The amount of tokens to increase the allowance by.\\r\\n     */\\r\\n    function increaseAllowance(\\r\\n        address spender,\\r\\n        uint256 addedValue\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        spender; addedValue; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    function maxScalingFactor()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        delegateToViewAndReturn();\\r\\n    }\\r\\n\\r\\n    function rebase(\\r\\n        uint256 epoch,\\r\\n        uint256 indexDelta,\\r\\n        bool positive\\r\\n    )\\r\\n        external\\r\\n        returns (uint256)\\r\\n    {\\r\\n        epoch; indexDelta; positive;\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\\r\\n     *\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\r\\n     */\\r\\n    function decreaseAllowance(\\r\\n        address spender,\\r\\n        uint256 subtractedValue\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        spender; subtractedValue; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param owner The address of the account which owns the tokens to be spent\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        owner; spender; // Shh\\r\\n        delegateToViewAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param delegator The address of the account which has designated a delegate\\r\\n     * @return Address of delegatee\\r\\n     */\\r\\n    function delegates(\\r\\n        address delegator\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        delegator; // Shh\\r\\n        delegateToViewAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the token balance of the `owner`\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The number of tokens owned by `owner`\\r\\n     */\\r\\n    function balanceOf(address owner)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        owner; // Shh\\r\\n        delegateToViewAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Currently unused. For future compatability\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The number of underlying tokens owned by `owner`\\r\\n     */\\r\\n    function balanceOfUnderlying(address owner)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        owner; // Shh\\r\\n        delegateToViewAndReturn();\\r\\n    }\\r\\n\\r\\n    /*** Gov Functions ***/\\r\\n\\r\\n    /**\\r\\n      * @notice Begins transfer of gov rights. The newPendingGov must call `_acceptGov` to finalize the transfer.\\r\\n      * @dev Gov function to begin change of gov. The newPendingGov must call `_acceptGov` to finalize the transfer.\\r\\n      * @param newPendingGov New pending gov.\\r\\n      */\\r\\n    function _setPendingGov(address newPendingGov)\\r\\n        external\\r\\n    {\\r\\n        newPendingGov; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    function _setRebaser(address rebaser_)\\r\\n        external\\r\\n    {\\r\\n        rebaser_; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    function _setIncentivizer(address incentivizer_)\\r\\n        external\\r\\n    {\\r\\n        incentivizer_; // Shh\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @notice Accepts transfer of gov rights. msg.sender must be pendingGov\\r\\n      * @dev Gov function for pending gov to accept role and update gov\\r\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n      */\\r\\n    function _acceptGov()\\r\\n        external\\r\\n    {\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n\\r\\n    function getPriorVotes(address account, uint blockNumber)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        account; blockNumber;\\r\\n        delegateToViewAndReturn();\\r\\n    }\\r\\n\\r\\n    function delegateBySig(\\r\\n        address delegatee,\\r\\n        uint nonce,\\r\\n        uint expiry,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        delegatee; nonce; expiry; v; r; s;\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    function delegate(address delegatee)\\r\\n        external\\r\\n    {\\r\\n        delegatee;\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n\\r\\n    function getCurrentVotes(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        account;\\r\\n        delegateToViewAndReturn();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal method to delegate execution to another contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param callee The contract to delegatecall\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\r\\n        assembly {\\r\\n            if eq(success, 0) {\\r\\n                revert(add(returnData, 0x20), returndatasize)\\r\\n            }\\r\\n        }\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to the implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\r\\n        return delegateTo(implementation, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to an implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\\r\\n     * @param data The raw data to delegatecall\\r\\n     * @return The returned bytes from the delegatecall\\r\\n     */\\r\\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\\r\\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\\\"delegateToImplementation(bytes)\\\", data));\\r\\n        assembly {\\r\\n            if eq(success, 0) {\\r\\n                revert(add(returnData, 0x20), returndatasize)\\r\\n            }\\r\\n        }\\r\\n        return abi.decode(returnData, (bytes));\\r\\n    }\\r\\n\\r\\n    function delegateToViewAndReturn() private view returns (bytes memory) {\\r\\n        (bool success, ) = address(this).staticcall(abi.encodeWithSignature(\\\"delegateToImplementation(bytes)\\\", msg.data));\\r\\n\\r\\n        assembly {\\r\\n            let free_mem_ptr := mload(0x40)\\r\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\r\\n\\r\\n            switch success\\r\\n            case 0 { revert(free_mem_ptr, returndatasize) }\\r\\n            default { return(add(free_mem_ptr, 0x40), returndatasize) }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function delegateAndReturn() private returns (bytes memory) {\\r\\n        (bool success, ) = implementation.delegatecall(msg.data);\\r\\n\\r\\n        assembly {\\r\\n            let free_mem_ptr := mload(0x40)\\r\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\r\\n\\r\\n            switch success\\r\\n            case 0 { revert(free_mem_ptr, returndatasize) }\\r\\n            default { return(free_mem_ptr, returndatasize) }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates execution to an implementation contract\\r\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\r\\n     */\\r\\n    function () external payable {\\r\\n        require(msg.value == 0,\\\"PYLONDelegator:fallback: cannot send value to fallback\\\");\\r\\n\\r\\n        // delegate all other functions to current implementation\\r\\n        delegateAndReturn();\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONGovernance.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./PYLONGovernanceStorage.sol\\\";\\r\\nimport \\\"./PYLONTokenInterface.sol\\\";\\r\\n\\r\\ncontract PYLONGovernanceToken is PYLONTokenInterface {\\r\\n\\r\\n      /// @notice An event thats emitted when an account changes its delegate\\r\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\r\\n\\r\\n    /// @notice An event thats emitted when a delegate account\\u0027s vote balance changes\\r\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\r\\n\\r\\n    /**\\r\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\r\\n     * @param delegator The address to get delegatee for\\r\\n     */\\r\\n    function delegates(address delegator)\\r\\n        external\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return _delegates[delegator];\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @notice Delegate votes from `msg.sender` to `delegatee`\\r\\n    * @param delegatee The address to delegate votes to\\r\\n    */\\r\\n    function delegate(address delegatee) external {\\r\\n        return _delegate(msg.sender, delegatee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates votes from signatory to `delegatee`\\r\\n     * @param delegatee The address to delegate votes to\\r\\n     * @param nonce The contract state required to match the signature\\r\\n     * @param expiry The time at which to expire the signature\\r\\n     * @param v The recovery byte of the signature\\r\\n     * @param r Half of the ECDSA signature pair\\r\\n     * @param s Half of the ECDSA signature pair\\r\\n     */\\r\\n    function delegateBySig(\\r\\n        address delegatee,\\r\\n        uint nonce,\\r\\n        uint expiry,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        bytes32 domainSeparator = keccak256(\\r\\n            abi.encode(\\r\\n                DOMAIN_TYPEHASH,\\r\\n                keccak256(bytes(name)),\\r\\n                getChainId(),\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        bytes32 structHash = keccak256(\\r\\n            abi.encode(\\r\\n                DELEGATION_TYPEHASH,\\r\\n                delegatee,\\r\\n                nonce,\\r\\n                expiry\\r\\n            )\\r\\n        );\\r\\n\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                domainSeparator,\\r\\n                structHash\\r\\n            )\\r\\n        );\\r\\n\\r\\n        address signatory = ecrecover(digest, v, r, s);\\r\\n        require(signatory != address(0), \\\"PYLON::delegateBySig: invalid signature\\\");\\r\\n        require(nonce == nonces[signatory]++, \\\"PYLON::delegateBySig: invalid nonce\\\");\\r\\n        require(now \\u003c= expiry, \\\"PYLON::delegateBySig: signature expired\\\");\\r\\n        return _delegate(signatory, delegatee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current votes balance for `account`\\r\\n     * @param account The address to get votes balance\\r\\n     * @return The number of current votes for `account`\\r\\n     */\\r\\n    function getCurrentVotes(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint32 nCheckpoints = numCheckpoints[account];\\r\\n        return nCheckpoints \\u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine the prior number of votes for an account as of a block number\\r\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\r\\n     * @param account The address of the account to check\\r\\n     * @param blockNumber The block number to get the vote balance at\\r\\n     * @return The number of votes the account had as of the given block\\r\\n     */\\r\\n    function getPriorVotes(address account, uint blockNumber)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(blockNumber \\u003c block.number, \\\"PYLON::getPriorVotes: not yet determined\\\");\\r\\n\\r\\n        uint32 nCheckpoints = numCheckpoints[account];\\r\\n        if (nCheckpoints == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // First check most recent balance\\r\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock \\u003c= blockNumber) {\\r\\n            return checkpoints[account][nCheckpoints - 1].votes;\\r\\n        }\\r\\n\\r\\n        // Next check implicit zero balance\\r\\n        if (checkpoints[account][0].fromBlock \\u003e blockNumber) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint32 lower = 0;\\r\\n        uint32 upper = nCheckpoints - 1;\\r\\n        while (upper \\u003e lower) {\\r\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\r\\n            Checkpoint memory cp = checkpoints[account][center];\\r\\n            if (cp.fromBlock == blockNumber) {\\r\\n                return cp.votes;\\r\\n            } else if (cp.fromBlock \\u003c blockNumber) {\\r\\n                lower = center;\\r\\n            } else {\\r\\n                upper = center - 1;\\r\\n            }\\r\\n        }\\r\\n        return checkpoints[account][lower].votes;\\r\\n    }\\r\\n\\r\\n    function _delegate(address delegator, address delegatee)\\r\\n        internal\\r\\n    {\\r\\n        address currentDelegate = _delegates[delegator];\\r\\n        uint256 delegatorBalance = _pylonBalances[delegator]; // balance of underlying PYLONs (not scaled);\\r\\n        _delegates[delegator] = delegatee;\\r\\n\\r\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\r\\n\\r\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\r\\n    }\\r\\n\\r\\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\\r\\n        if (srcRep != dstRep \\u0026\\u0026 amount \\u003e 0) {\\r\\n            if (srcRep != address(0)) {\\r\\n                // decrease old representative\\r\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\r\\n                uint256 srcRepOld = srcRepNum \\u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\r\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\r\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\r\\n            }\\r\\n\\r\\n            if (dstRep != address(0)) {\\r\\n                // increase new representative\\r\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\r\\n                uint256 dstRepOld = dstRepNum \\u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\r\\n                uint256 dstRepNew = dstRepOld.add(amount);\\r\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _writeCheckpoint(\\r\\n        address delegatee,\\r\\n        uint32 nCheckpoints,\\r\\n        uint256 oldVotes,\\r\\n        uint256 newVotes\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint32 blockNumber = safe32(block.number, \\\"PYLON::_writeCheckpoint: block number exceeds 32 bits\\\");\\r\\n\\r\\n        if (nCheckpoints \\u003e 0 \\u0026\\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\r\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\r\\n        } else {\\r\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\r\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\r\\n        }\\r\\n\\r\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\r\\n    }\\r\\n\\r\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(n \\u003c 2**32, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function getChainId() internal pure returns (uint) {\\r\\n        uint256 chainId;\\r\\n        assembly { chainId := chainid() }\\r\\n        return chainId;\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONGovernanceStorage.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ncontract PYLONGovernanceStorage {\\r\\n    /// @notice A record of each accounts delegate\\r\\n    mapping (address =\\u003e address) internal _delegates;\\r\\n\\r\\n    /// @notice A checkpoint for marking number of votes from a given block\\r\\n    struct Checkpoint {\\r\\n        uint32 fromBlock;\\r\\n        uint256 votes;\\r\\n    }\\r\\n\\r\\n    /// @notice A record of votes checkpoints for each account, by index\\r\\n    mapping (address =\\u003e mapping (uint32 =\\u003e Checkpoint)) public checkpoints;\\r\\n\\r\\n    /// @notice The number of checkpoints for each account\\r\\n    mapping (address =\\u003e uint32) public numCheckpoints;\\r\\n\\r\\n    /// @notice The EIP-712 typehash for the contract\\u0027s domain\\r\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\r\\n\\r\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\r\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\r\\n\\r\\n    /// @notice A record of states for signing / validating signatures\\r\\n    mapping (address =\\u003e uint) public nonces;\\r\\n}\\r\\n\"},\"PYLONGovernorAlpha.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// Original work from Compound: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\r\\n// Modified to work in the PYLON system\\r\\n\\r\\n// all votes work on underlying _pylonBalances[address], not balanceOf(address)\\r\\n\\r\\n// Original audit: https://blog.openzeppelin.com/compound-alpha-governance-system-audit/\\r\\n// Overview:\\r\\n//    No Critical\\r\\n//    High:\\r\\n//      Issue:\\r\\n//        Approved proposal may be impossible to queue, cancel or execute\\r\\n//        Fixed with `proposalMaxOperations`\\r\\n//      Issue:\\r\\n//        Queued proposal with repeated actions cannot be executed\\r\\n//        Fixed by explicitly disallow proposals with repeated actions to be queued in the Timelock contract.\\r\\n//\\r\\n// Changes made by PYLON after audit:\\r\\n//    Formatting, naming, \\u0026 uint256 instead of uint\\r\\n//    Since PYLON supply changes, updated quorum \\u0026 proposal requirements\\r\\n//    If any uint96, changed to uint256 to match PYLON as opposed to comp\\r\\n\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract GovernorAlpha {\\r\\n    /// @notice The name of this contract\\r\\n    string public constant name = \\\"PYLON Governor Alpha\\\";\\r\\n\\r\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\r\\n    function quorumVotes() public view returns (uint256) { return SafeMath.div(SafeMath.mul(pylon.initSupply(), 4), 100); } // 4% of PYLON\\r\\n\\r\\n    /// @notice The number of votes required in order for a voter to become a proposer\\r\\n    function proposalThreshold() public view returns (uint256) { return SafeMath.div(pylon.initSupply(), 100); } // 1% of PYLON\\r\\n\\r\\n    /// @notice The maximum number of actions that can be included in a proposal\\r\\n    function proposalMaxOperations() public pure returns (uint256) { return 10; } // 10 actions\\r\\n\\r\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\r\\n    function votingDelay() public pure returns (uint256) { return 1; } // 1 block\\r\\n\\r\\n    /// @notice The duration of voting on a proposal, in blocks\\r\\n    function votingPeriod() public pure returns (uint256) { return 17280; } // ~3 days in blocks (assuming 15s blocks)\\r\\n\\r\\n    /// @notice The address of the Compound Protocol Timelock\\r\\n    TimelockInterface public timelock;\\r\\n\\r\\n    /// @notice The address of the Compound governance token\\r\\n    PYLONInterface public pylon;\\r\\n\\r\\n    /// @notice The address of the Governor Guardian\\r\\n    address public guardian;\\r\\n\\r\\n    /// @notice The total number of proposals\\r\\n    uint256 public proposalCount;\\r\\n\\r\\n    struct Proposal {\\r\\n        /// @notice Unique id for looking up a proposal\\r\\n        uint256 id;\\r\\n\\r\\n        /// @notice Creator of the proposal\\r\\n        address proposer;\\r\\n\\r\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\r\\n        uint256 eta;\\r\\n\\r\\n        /// @notice the ordered list of target addresses for calls to be made\\r\\n        address[] targets;\\r\\n\\r\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\r\\n        uint[] values;\\r\\n\\r\\n        /// @notice The ordered list of function signatures to be called\\r\\n        string[] signatures;\\r\\n\\r\\n        /// @notice The ordered list of calldata to be passed to each call\\r\\n        bytes[] calldatas;\\r\\n\\r\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\r\\n        uint256 startBlock;\\r\\n\\r\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\r\\n        uint256 endBlock;\\r\\n\\r\\n        /// @notice Current number of votes in favor of this proposal\\r\\n        uint256 forVotes;\\r\\n\\r\\n        /// @notice Current number of votes in opposition to this proposal\\r\\n        uint256 againstVotes;\\r\\n\\r\\n        /// @notice Flag marking whether the proposal has been canceled\\r\\n        bool canceled;\\r\\n\\r\\n        /// @notice Flag marking whether the proposal has been executed\\r\\n        bool executed;\\r\\n\\r\\n        /// @notice Receipts of ballots for the entire set of voters\\r\\n        mapping (address =\\u003e Receipt) receipts;\\r\\n    }\\r\\n\\r\\n    /// @notice Ballot receipt record for a voter\\r\\n    struct Receipt {\\r\\n        /// @notice Whether or not a vote has been cast\\r\\n        bool hasVoted;\\r\\n\\r\\n        /// @notice Whether or not the voter supports the proposal\\r\\n        bool support;\\r\\n\\r\\n        /// @notice The number of votes the voter had, which were cast\\r\\n        uint256 votes;\\r\\n    }\\r\\n\\r\\n    /// @notice Possible states that a proposal may be in\\r\\n    enum ProposalState {\\r\\n        Pending,\\r\\n        Active,\\r\\n        Canceled,\\r\\n        Defeated,\\r\\n        Succeeded,\\r\\n        Queued,\\r\\n        Expired,\\r\\n        Executed\\r\\n    }\\r\\n\\r\\n    /// @notice The official record of all proposals ever proposed\\r\\n    mapping (uint256 =\\u003e Proposal) public proposals;\\r\\n\\r\\n    /// @notice The latest proposal for each proposer\\r\\n    mapping (address =\\u003e uint256) public latestProposalIds;\\r\\n\\r\\n    /// @notice The EIP-712 typehash for the contract\\u0027s domain\\r\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\r\\n\\r\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\r\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\r\\n\\r\\n    /// @notice An event emitted when a new proposal is created\\r\\n    event ProposalCreated(uint256 id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint256 startBlock, uint256 endBlock, string description);\\r\\n\\r\\n    /// @notice An event emitted when a vote has been cast on a proposal\\r\\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\\r\\n\\r\\n    /// @notice An event emitted when a proposal has been canceled\\r\\n    event ProposalCanceled(uint256 id);\\r\\n\\r\\n    /// @notice An event emitted when a proposal has been queued in the Timelock\\r\\n    event ProposalQueued(uint256 id, uint256 eta);\\r\\n\\r\\n    /// @notice An event emitted when a proposal has been executed in the Timelock\\r\\n    event ProposalExecuted(uint256 id);\\r\\n\\r\\n    constructor(address timelock_, address pylon_) public {\\r\\n        timelock = TimelockInterface(timelock_);\\r\\n        pylon = PYLONInterface(pylon_);\\r\\n        guardian = msg.sender;\\r\\n    }\\r\\n\\r\\n    function propose(\\r\\n        address[] memory targets,\\r\\n        uint[] memory values,\\r\\n        string[] memory signatures,\\r\\n        bytes[] memory calldatas,\\r\\n        string memory description\\r\\n    )\\r\\n        public\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(pylon.getPriorVotes(msg.sender, sub256(block.number, 1)) \\u003e proposalThreshold(), \\\"GovernorAlpha::propose: proposer votes below proposal threshold\\\");\\r\\n        require(targets.length == values.length \\u0026\\u0026 targets.length == signatures.length \\u0026\\u0026 targets.length == calldatas.length, \\\"GovernorAlpha::propose: proposal function information arity mismatch\\\");\\r\\n        require(targets.length != 0, \\\"GovernorAlpha::propose: must provide actions\\\");\\r\\n        require(targets.length \\u003c= proposalMaxOperations(), \\\"GovernorAlpha::propose: too many actions\\\");\\r\\n\\r\\n        uint256 latestProposalId = latestProposalIds[msg.sender];\\r\\n        if (latestProposalId != 0) {\\r\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\r\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\\\");\\r\\n          require(proposersLatestProposalState != ProposalState.Pending, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\\\");\\r\\n        }\\r\\n\\r\\n        uint256 startBlock = add256(block.number, votingDelay());\\r\\n        uint256 endBlock = add256(startBlock, votingPeriod());\\r\\n\\r\\n        proposalCount++;\\r\\n        Proposal memory newProposal = Proposal({\\r\\n            id: proposalCount,\\r\\n            proposer: msg.sender,\\r\\n            eta: 0,\\r\\n            targets: targets,\\r\\n            values: values,\\r\\n            signatures: signatures,\\r\\n            calldatas: calldatas,\\r\\n            startBlock: startBlock,\\r\\n            endBlock: endBlock,\\r\\n            forVotes: 0,\\r\\n            againstVotes: 0,\\r\\n            canceled: false,\\r\\n            executed: false\\r\\n        });\\r\\n\\r\\n        proposals[newProposal.id] = newProposal;\\r\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\r\\n\\r\\n        emit ProposalCreated(\\r\\n            newProposal.id,\\r\\n            msg.sender,\\r\\n            targets,\\r\\n            values,\\r\\n            signatures,\\r\\n            calldatas,\\r\\n            startBlock,\\r\\n            endBlock,\\r\\n            description\\r\\n        );\\r\\n        return newProposal.id;\\r\\n    }\\r\\n\\r\\n    function queue(uint256 proposalId)\\r\\n        public\\r\\n    {\\r\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"GovernorAlpha::queue: proposal can only be queued if it is succeeded\\\");\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        uint256 eta = add256(block.timestamp, timelock.delay());\\r\\n        for (uint256 i = 0; i \\u003c proposal.targets.length; i++) {\\r\\n            _queueOrRevert(\\r\\n                proposal.targets[i],\\r\\n                proposal.values[i],\\r\\n                proposal.signatures[i],\\r\\n                proposal.calldatas[i],\\r\\n                eta\\r\\n            );\\r\\n        }\\r\\n        proposal.eta = eta;\\r\\n        emit ProposalQueued(proposalId, eta);\\r\\n    }\\r\\n\\r\\n    function _queueOrRevert(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string memory signature,\\r\\n        bytes memory data,\\r\\n        uint256 eta\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        require(!timelock.queuedTransactions(\\r\\n              keccak256(\\r\\n                  abi.encode(\\r\\n                      target,\\r\\n                      value,\\r\\n                      signature,\\r\\n                      data,\\r\\n                      eta\\r\\n                  )\\r\\n              )\\r\\n          ),\\r\\n          \\\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\\\"\\r\\n        );\\r\\n\\r\\n        timelock.queueTransaction(target, value, signature, data, eta);\\r\\n    }\\r\\n\\r\\n    function execute(uint256 proposalId)\\r\\n        public\\r\\n        payable\\r\\n    {\\r\\n        require(state(proposalId) == ProposalState.Queued, \\\"GovernorAlpha::execute: proposal can only be executed if it is queued\\\");\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        proposal.executed = true;\\r\\n        for (uint256 i = 0; i \\u003c proposal.targets.length; i++) {\\r\\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\r\\n        }\\r\\n        emit ProposalExecuted(proposalId);\\r\\n    }\\r\\n\\r\\n    function cancel(uint256 proposalId)\\r\\n        public\\r\\n    {\\r\\n        ProposalState state = state(proposalId);\\r\\n        require(state != ProposalState.Executed, \\\"GovernorAlpha::cancel: cannot cancel executed proposal\\\");\\r\\n\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        require(msg.sender == guardian || pylon.getPriorVotes(proposal.proposer, sub256(block.number, 1)) \\u003c proposalThreshold(), \\\"GovernorAlpha::cancel: proposer above threshold\\\");\\r\\n\\r\\n        proposal.canceled = true;\\r\\n        for (uint256 i = 0; i \\u003c proposal.targets.length; i++) {\\r\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\r\\n        }\\r\\n\\r\\n        emit ProposalCanceled(proposalId);\\r\\n    }\\r\\n\\r\\n    function getActions(uint256 proposalId)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            address[] memory targets,\\r\\n            uint[] memory values,\\r\\n            string[] memory signatures,\\r\\n            bytes[] memory calldatas\\r\\n        )\\r\\n    {\\r\\n        Proposal storage p = proposals[proposalId];\\r\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\r\\n    }\\r\\n\\r\\n    function getReceipt(uint256 proposalId, address voter)\\r\\n        public\\r\\n        view\\r\\n        returns (Receipt memory)\\r\\n    {\\r\\n        return proposals[proposalId].receipts[voter];\\r\\n    }\\r\\n\\r\\n    function state(uint256 proposalId)\\r\\n        public\\r\\n        view\\r\\n        returns (ProposalState)\\r\\n    {\\r\\n        require(proposalCount \\u003e= proposalId \\u0026\\u0026 proposalId \\u003e 0, \\\"GovernorAlpha::state: invalid proposal id\\\");\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        if (proposal.canceled) {\\r\\n            return ProposalState.Canceled;\\r\\n        } else if (block.number \\u003c= proposal.startBlock) {\\r\\n            return ProposalState.Pending;\\r\\n        } else if (block.number \\u003c= proposal.endBlock) {\\r\\n            return ProposalState.Active;\\r\\n        } else if (proposal.forVotes \\u003c= proposal.againstVotes || proposal.forVotes \\u003c quorumVotes()) {\\r\\n            return ProposalState.Defeated;\\r\\n        } else if (proposal.eta == 0) {\\r\\n            return ProposalState.Succeeded;\\r\\n        } else if (proposal.executed) {\\r\\n            return ProposalState.Executed;\\r\\n        } else if (block.timestamp \\u003e= add256(proposal.eta, timelock.GRACE_PERIOD())) {\\r\\n            return ProposalState.Expired;\\r\\n        } else {\\r\\n            return ProposalState.Queued;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function castVote(uint256 proposalId, bool support)\\r\\n        public\\r\\n    {\\r\\n        return _castVote(msg.sender, proposalId, support);\\r\\n    }\\r\\n\\r\\n    function castVoteBySig(\\r\\n        uint256 proposalId,\\r\\n        bool support,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        bytes32 domainSeparator = keccak256(\\r\\n            abi.encode(\\r\\n                DOMAIN_TYPEHASH,\\r\\n                keccak256(bytes(name)),\\r\\n                getChainId(),\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        bytes32 structHash = keccak256(\\r\\n            abi.encode(\\r\\n                BALLOT_TYPEHASH,\\r\\n                proposalId,\\r\\n                support\\r\\n            )\\r\\n        );\\r\\n\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                domainSeparator,\\r\\n                structHash\\r\\n            )\\r\\n        );\\r\\n\\r\\n        address signatory = ecrecover(digest, v, r, s);\\r\\n        require(signatory != address(0), \\\"GovernorAlpha::castVoteBySig: invalid signature\\\");\\r\\n        return _castVote(signatory, proposalId, support);\\r\\n    }\\r\\n\\r\\n    function _castVote(\\r\\n        address voter,\\r\\n        uint256 proposalId,\\r\\n        bool support\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        // disable vote\\r\\n        // require(state(proposalId) == ProposalState.Active, \\\"GovernorAlpha::_castVote: voting is closed\\\");\\r\\n        // Proposal storage proposal = proposals[proposalId];\\r\\n        // Receipt storage receipt = proposal.receipts[voter];\\r\\n        // require(receipt.hasVoted == false, \\\"GovernorAlpha::_castVote: voter already voted\\\");\\r\\n        // uint256 votes = pylon.getPriorVotes(voter, proposal.startBlock);\\r\\n\\r\\n        // if (support) {\\r\\n        //     proposal.forVotes = add256(proposal.forVotes, votes);\\r\\n        // } else {\\r\\n        //     proposal.againstVotes = add256(proposal.againstVotes, votes);\\r\\n        // }\\r\\n\\r\\n        // receipt.hasVoted = true;\\r\\n        // receipt.support = support;\\r\\n        // receipt.votes = votes;\\r\\n\\r\\n        // emit VoteCast(voter, proposalId, support, votes);\\r\\n    }\\r\\n\\r\\n    function __acceptAdmin()\\r\\n        public\\r\\n    {\\r\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__acceptAdmin: sender must be gov guardian\\\");\\r\\n        timelock.acceptAdmin();\\r\\n    }\\r\\n\\r\\n    function __abdicate()\\r\\n        public\\r\\n    {\\r\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__abdicate: sender must be gov guardian\\\");\\r\\n        guardian = address(0);\\r\\n    }\\r\\n\\r\\n    function __queueSetTimelockPendingAdmin(\\r\\n        address newPendingAdmin,\\r\\n        uint256 eta\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\r\\n        timelock.queueTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\r\\n    }\\r\\n\\r\\n    function __executeSetTimelockPendingAdmin(\\r\\n        address newPendingAdmin,\\r\\n        uint256 eta\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\r\\n        timelock.executeTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\r\\n    }\\r\\n\\r\\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"subtraction underflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function getChainId() internal pure returns (uint256) {\\r\\n        uint256 chainId;\\r\\n        assembly { chainId := chainid() }\\r\\n        return chainId;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface TimelockInterface {\\r\\n    function delay() external view returns (uint256);\\r\\n    function GRACE_PERIOD() external view returns (uint256);\\r\\n    function acceptAdmin() external;\\r\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\r\\n    function queueTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external returns (bytes32);\\r\\n    function cancelTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external;\\r\\n    function executeTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external payable returns (bytes memory);\\r\\n}\\r\\n\\r\\ninterface PYLONInterface {\\r\\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);\\r\\n    function initSupply() external view returns (uint256);\\r\\n    function _acceptGov() external;\\r\\n}\\r\\n\"},\"PYLONIncentives.sol\":{\"content\":\"/*\\r\\n   ____            __   __        __   _\\r\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\r\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\r\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\r\\n     /___/\\r\\n\\r\\n* Synthetix: PYLONIncentives.sol\\r\\n*\\r\\n* Docs: https://docs.synthetix.io/\\r\\n*\\r\\n*\\r\\n* MIT License\\r\\n* ===========\\r\\n*\\r\\n* Copyright (c) 2020 Synthetix\\r\\n*\\r\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n* in the Software without restriction, including without limitation the rights\\r\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n* copies of the Software, and to permit persons to whom the Software is\\r\\n* furnished to do so, subject to the following conditions:\\r\\n*\\r\\n* The above copyright notice and this permission notice shall be included in all\\r\\n* copies or substantial portions of the Software.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function mint(address account, uint amount) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/IRewardDistributionRecipient.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ncontract IRewardDistributionRecipient is Ownable {\\r\\n    address rewardDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardDistribution() {\\r\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setRewardDistribution(address _rewardDistribution)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardDistribution = _rewardDistribution;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/CurveRewards.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ncontract LPTokenWrapper {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public uni_lp = IERC20(0x2C7a51A357d5739C5C74Bf3C96816849d2c9F726);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        uni_lp.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        uni_lp.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface PYLON {\\r\\n    function pylonsScalingFactor() external returns (uint256);\\r\\n    function mint(address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract PYLONIncentivizer is LPTokenWrapper, IRewardDistributionRecipient {\\r\\n    IERC20 public pylon = IERC20(0xD7B7d3C0bdA57723Fb54ab95Fd8F9EA033AF37f2);\\r\\n    uint256 public constant DURATION = 864000;\\r\\n\\r\\n    uint256 public initreward = 6300 * 10**18; // 6,300\\r\\n    uint256 public starttime = 1599004800; // 2020-09-02 00:00:00 (UTC UTC +00:00)\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    // stake visibility is public as overriding LPTokenWrapper\\u0027s stake() function\\r\\n    function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        super.stake(amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        super.withdraw(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(balanceOf(msg.sender));\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    function getReward() public updateReward(msg.sender) checkhalve checkStart {\\r\\n        uint256 reward = earned(msg.sender);\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 trueReward = reward.mul(scalingFactor).div(10**18);\\r\\n            pylon.safeTransfer(msg.sender, trueReward);\\r\\n            emit RewardPaid(msg.sender, trueReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier checkhalve() {\\r\\n        if (block.timestamp \\u003e= periodFinish) {\\r\\n            initreward = initreward.mul(50).div(100);\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 newRewards = initreward.mul(scalingFactor).div(10**18);\\r\\n            pylon.mint(address(this), newRewards);\\r\\n\\r\\n            rewardRate = initreward.div(DURATION);\\r\\n            periodFinish = block.timestamp.add(DURATION);\\r\\n            emit RewardAdded(initreward);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier checkStart(){\\r\\n        require(block.timestamp \\u003e= starttime,\\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward)\\r\\n        external\\r\\n        onlyRewardDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        if (block.timestamp \\u003e starttime) {\\r\\n          if (block.timestamp \\u003e= periodFinish) {\\r\\n              rewardRate = reward.div(DURATION);\\r\\n          } else {\\r\\n              uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n              uint256 leftover = remaining.mul(rewardRate);\\r\\n              rewardRate = reward.add(leftover).div(DURATION);\\r\\n          }\\r\\n          lastUpdateTime = block.timestamp;\\r\\n          periodFinish = block.timestamp.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        } else {\\r\\n          require(pylon.balanceOf(address(this)) == 0, \\\"already initialized\\\");\\r\\n          pylon.mint(address(this), initreward);\\r\\n          rewardRate = initreward.div(DURATION);\\r\\n          lastUpdateTime = starttime;\\r\\n          periodFinish = starttime.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    // This function allows governance to take unsupported tokens out of the\\r\\n    // contract, since this one exists longer than the other pools.\\r\\n    // This is in an effort to make someone whole, should they seriously\\r\\n    // mess up. There is no guarantee governance will vote to return these.\\r\\n    // It also allows for removal of airdropped tokens.\\r\\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to)\\r\\n        external\\r\\n    {\\r\\n        // only gov\\r\\n        require(msg.sender == owner(), \\\"!governance\\\");\\r\\n        // cant take staked asset\\r\\n        require(_token != uni_lp, \\\"uni_lp\\\");\\r\\n        // cant take reward asset\\r\\n        require(_token != pylon, \\\"pylon\\\");\\r\\n\\r\\n        // transfer to\\r\\n        _token.safeTransfer(to, amount);\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONLENDPool.sol\":{\"content\":\"/*\\r\\n   ____            __   __        __   _\\r\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\r\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\r\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\r\\n     /___/\\r\\n\\r\\n* Synthetix: PYLONRewards.sol\\r\\n*\\r\\n* Docs: https://docs.synthetix.io/\\r\\n*\\r\\n*\\r\\n* MIT License\\r\\n* ===========\\r\\n*\\r\\n* Copyright (c) 2020 Synthetix\\r\\n*\\r\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n* in the Software without restriction, including without limitation the rights\\r\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n* copies of the Software, and to permit persons to whom the Software is\\r\\n* furnished to do so, subject to the following conditions:\\r\\n*\\r\\n* The above copyright notice and this permission notice shall be included in all\\r\\n* copies or substantial portions of the Software.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/IRewardDistributionRecipient.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ncontract IRewardDistributionRecipient is Ownable {\\r\\n    address public rewardDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardDistribution() {\\r\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setRewardDistribution(address _rewardDistribution)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardDistribution = _rewardDistribution;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/CurveRewards.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ninterface PYLON {\\r\\n    function pylonsScalingFactor() external returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract LPTokenWrapper {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public lend = IERC20(0x80fB784B7eD66730e8b1DBd9820aFD29931aab03);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        lend.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        lend.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PYLONLENDPool is LPTokenWrapper, IRewardDistributionRecipient {\\r\\n    IERC20 public pylon = IERC20(0xD7B7d3C0bdA57723Fb54ab95Fd8F9EA033AF37f2);\\r\\n    uint256 public constant DURATION = 864000; // 10 days\\r\\n\\r\\n    uint256 public starttime = 1598918400; // 2020-09-01 00:00:00 (UTC UTC +00:00)\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier checkStart() {\\r\\n        require(block.timestamp \\u003e= starttime,\\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    // stake visibility is public as overriding LPTokenWrapper\\u0027s stake() function\\r\\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        super.stake(amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        super.withdraw(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(balanceOf(msg.sender));\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    function getReward() public updateReward(msg.sender) checkStart {\\r\\n        uint256 reward = earned(msg.sender);\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 trueReward = reward.mul(scalingFactor).div(10**18);\\r\\n            pylon.safeTransfer(msg.sender, trueReward);\\r\\n            emit RewardPaid(msg.sender, trueReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward)\\r\\n        external\\r\\n        onlyRewardDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        if (block.timestamp \\u003e starttime) {\\r\\n          if (block.timestamp \\u003e= periodFinish) {\\r\\n              rewardRate = reward.div(DURATION);\\r\\n          } else {\\r\\n              uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n              uint256 leftover = remaining.mul(rewardRate);\\r\\n              rewardRate = reward.add(leftover).div(DURATION);\\r\\n          }\\r\\n          lastUpdateTime = block.timestamp;\\r\\n          periodFinish = block.timestamp.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        } else {\\r\\n          rewardRate = reward.div(DURATION);\\r\\n          lastUpdateTime = starttime;\\r\\n          periodFinish = starttime.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONRebaser.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\u0027./IUniswapV2Pair.sol\\u0027;\\r\\nimport \\\"./UniswapV2OracleLibrary.sol\\\";\\r\\nimport \\\"./PYLONTokenInterface.sol\\\";\\r\\n\\r\\n\\r\\ncontract PYLONRebaser {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    modifier onlyGov() {\\r\\n        require(msg.sender == gov);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    struct Transaction {\\r\\n        bool enabled;\\r\\n        address destination;\\r\\n        bytes data;\\r\\n    }\\r\\n\\r\\n    struct UniVars {\\r\\n      uint256 pylonsToUni;\\r\\n      uint256 amountFromReserves;\\r\\n      uint256 mintToReserves;\\r\\n    }\\r\\n\\r\\n    /// @notice an event emitted when a transaction fails\\r\\n    event TransactionFailed(address indexed destination, uint index, bytes data);\\r\\n\\r\\n    /// @notice an event emitted when maxSlippageFactor is changed\\r\\n    event NewMaxSlippageFactor(uint256 oldSlippageFactor, uint256 newSlippageFactor);\\r\\n\\r\\n    /// @notice an event emitted when deviationThreshold is changed\\r\\n    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the treasury mint percentage of rebase\\r\\n     */\\r\\n    event NewRebaseMintPercent(uint256 oldRebaseMintPerc, uint256 newRebaseMintPerc);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the reserve contract\\r\\n     */\\r\\n    event NewReserveContract(address oldReserveContract, address newReserveContract);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the reserve contract\\r\\n     */\\r\\n    event TreasuryIncreased(uint256 reservesAdded, uint256 pylonsSold, uint256 pylonsFromReserves, uint256 pylonsToReserves);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingGov is changed\\r\\n     */\\r\\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when gov is changed\\r\\n     */\\r\\n    event NewGov(address oldGov, address newGov);\\r\\n\\r\\n    // Stable ordering is not guaranteed.\\r\\n    Transaction[] public transactions;\\r\\n\\r\\n\\r\\n    /// @notice Governance address\\r\\n    address public gov;\\r\\n\\r\\n    /// @notice Pending Governance address\\r\\n    address public pendingGov;\\r\\n\\r\\n    /// @notice Spreads out getting to the target price\\r\\n    uint256 public rebaseLag;\\r\\n\\r\\n    /// @notice Peg target\\r\\n    uint256 public targetRate;\\r\\n\\r\\n    /// @notice Percent of rebase that goes to minting for treasury building\\r\\n    uint256 public rebaseMintPerc;\\r\\n\\r\\n    // If the current exchange rate is within this fractional distance from the target, no supply\\r\\n    // update is performed. Fixed point number--same format as the rate.\\r\\n    // (ie) abs(rate - targetRate) / targetRate \\u003c deviationThreshold, then no supply change.\\r\\n    uint256 public deviationThreshold;\\r\\n\\r\\n    /// @notice More than this much time must pass between rebase operations.\\r\\n    uint256 public minRebaseTimeIntervalSec;\\r\\n\\r\\n    /// @notice Block timestamp of last rebase operation\\r\\n    uint256 public lastRebaseTimestampSec;\\r\\n\\r\\n    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\\r\\n    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\\r\\n    uint256 public rebaseWindowOffsetSec;\\r\\n\\r\\n    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\\r\\n    uint256 public rebaseWindowLengthSec;\\r\\n\\r\\n    /// @notice The number of rebase cycles since inception\\r\\n    uint256 public epoch;\\r\\n\\r\\n    // rebasing is not active initially. It can be activated at T+12 hours from\\r\\n    // deployment time\\r\\n    ///@notice boolean showing rebase activation status\\r\\n    bool public rebasingActive;\\r\\n\\r\\n    /// @notice delays rebasing activation to facilitate liquidity\\r\\n    uint256 public constant rebaseDelay = 12 hours;\\r\\n\\r\\n    /// @notice Time of TWAP initialization\\r\\n    uint256 public timeOfTWAPInit;\\r\\n\\r\\n    /// @notice PYLON token address\\r\\n    address public pylonAddress;\\r\\n\\r\\n    /// @notice reserve token\\r\\n    address public reserveToken;\\r\\n\\r\\n    /// @notice Reserves vault contract\\r\\n    address public reservesContract;\\r\\n\\r\\n    /// @notice pair for reserveToken \\u003c\\u003e PYLON\\r\\n    address public uniswap_pair;\\r\\n\\r\\n    /// @notice last TWAP update time\\r\\n    uint32 public blockTimestampLast;\\r\\n\\r\\n    /// @notice last TWAP cumulative price;\\r\\n    uint256 public priceCumulativeLast;\\r\\n\\r\\n    // Max slippage factor when buying reserve token. Magic number based on\\r\\n    // the fact that uniswap is a constant product. Therefore,\\r\\n    // targeting a % max slippage can be achieved by using a single precomputed\\r\\n    // number. i.e. 2.5% slippage is always equal to some f(maxSlippageFactor, reserves)\\r\\n    /// @notice the maximum slippage factor when buying reserve token\\r\\n    uint256 public maxSlippageFactor;\\r\\n\\r\\n    /// @notice Whether or not this token is first in uniswap PYLON\\u003c\\u003eReserve pair\\r\\n    bool public isToken0;\\r\\n\\r\\n    constructor(\\r\\n        address pylonAddress_,\\r\\n        address reserveToken_,\\r\\n        address uniswap_factory,\\r\\n        address reservesContract_\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n          minRebaseTimeIntervalSec = 12 hours;\\r\\n          rebaseWindowOffsetSec = 28800; // 8am/8pm UTC rebases\\r\\n          reservesContract = reservesContract_;\\r\\n          (address token0, address token1) = sortTokens(pylonAddress_, reserveToken_);\\r\\n\\r\\n          // used for interacting with uniswap\\r\\n          if (token0 == pylonAddress_) {\\r\\n              isToken0 = true;\\r\\n          } else {\\r\\n              isToken0 = false;\\r\\n          }\\r\\n          // uniswap PYLON\\u003c\\u003eReserve pair\\r\\n          uniswap_pair = pairFor(uniswap_factory, token0, token1);\\r\\n\\r\\n          // Reserves contract is mutable\\r\\n          reservesContract = reservesContract_;\\r\\n\\r\\n          // Reserve token is not mutable. Must deploy a new rebaser to update it\\r\\n          reserveToken = reserveToken_;\\r\\n\\r\\n          pylonAddress = pylonAddress_;\\r\\n\\r\\n          // target 10% slippage\\r\\n          // 5.4%\\r\\n          maxSlippageFactor = 5409258 * 10**10;\\r\\n\\r\\n          // 1 YCRV\\r\\n          targetRate = 10**18;\\r\\n\\r\\n          // twice daily rebase, with targeting reaching peg in 5 days\\r\\n          rebaseLag = 10;\\r\\n\\r\\n          // 10%\\r\\n          rebaseMintPerc = 10**17;\\r\\n\\r\\n          // 5%\\r\\n          deviationThreshold = 5 * 10**16;\\r\\n\\r\\n          // 60 minutes\\r\\n          rebaseWindowLengthSec = 60 * 60;\\r\\n\\r\\n          // Changed in deployment scripts to facilitate protocol initiation\\r\\n          gov = msg.sender;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @notice Updates slippage factor\\r\\n    @param maxSlippageFactor_ the new slippage factor\\r\\n    *\\r\\n    */\\r\\n    function setMaxSlippageFactor(uint256 maxSlippageFactor_)\\r\\n        public\\r\\n        onlyGov\\r\\n    {\\r\\n        uint256 oldSlippageFactor = maxSlippageFactor;\\r\\n        maxSlippageFactor = maxSlippageFactor_;\\r\\n        emit NewMaxSlippageFactor(oldSlippageFactor, maxSlippageFactor_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @notice Updates rebase mint percentage\\r\\n    @param rebaseMintPerc_ the new rebase mint percentage\\r\\n    *\\r\\n    */\\r\\n    function setRebaseMintPerc(uint256 rebaseMintPerc_)\\r\\n        public\\r\\n        onlyGov\\r\\n    {\\r\\n        uint256 oldPerc = rebaseMintPerc;\\r\\n        rebaseMintPerc = rebaseMintPerc_;\\r\\n        emit NewRebaseMintPercent(oldPerc, rebaseMintPerc_);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n    @notice Updates reserve contract\\r\\n    @param reservesContract_ the new reserve contract\\r\\n    *\\r\\n    */\\r\\n    function setReserveContract(address reservesContract_)\\r\\n        public\\r\\n        onlyGov\\r\\n    {\\r\\n        address oldReservesContract = reservesContract;\\r\\n        reservesContract = reservesContract_;\\r\\n        emit NewReserveContract(oldReservesContract, reservesContract_);\\r\\n    }\\r\\n\\r\\n\\r\\n    /** @notice sets the pendingGov\\r\\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\\r\\n     */\\r\\n    function _setPendingGov(address pendingGov_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        address oldPendingGov = pendingGov;\\r\\n        pendingGov = pendingGov_;\\r\\n        emit NewPendingGov(oldPendingGov, pendingGov_);\\r\\n    }\\r\\n\\r\\n    /** @notice lets msg.sender accept governance\\r\\n     *\\r\\n     */\\r\\n    function _acceptGov()\\r\\n        external\\r\\n    {\\r\\n        require(msg.sender == pendingGov, \\\"!pending\\\");\\r\\n        address oldGov = gov;\\r\\n        gov = pendingGov;\\r\\n        pendingGov = address(0);\\r\\n        emit NewGov(oldGov, gov);\\r\\n    }\\r\\n\\r\\n    /** @notice Initializes TWAP start point, starts countdown to first rebase\\r\\n    *\\r\\n    */\\r\\n    function init_twap()\\r\\n        public\\r\\n    {\\r\\n        require(timeOfTWAPInit == 0, \\\"already activated\\\");\\r\\n        (uint priceCumulative, uint32 blockTimestamp) =\\r\\n           UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\\r\\n        require(blockTimestamp \\u003e 0, \\\"no trades\\\");\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n        priceCumulativeLast = priceCumulative;\\r\\n        timeOfTWAPInit = blockTimestamp;\\r\\n    }\\r\\n\\r\\n    /** @notice Activates rebasing\\r\\n    *   @dev One way function, cannot be undone, callable by anyone\\r\\n    */\\r\\n    function activate_rebasing()\\r\\n        public\\r\\n    {\\r\\n        // disable rebase\\r\\n        // require(timeOfTWAPInit \\u003e 0, \\\"twap wasnt intitiated, call init_twap()\\\");\\r\\n        // // cannot enable prior to end of rebaseDelay\\r\\n        // require(now \\u003e= timeOfTWAPInit + rebaseDelay, \\\"!end_delay\\\");\\r\\n\\r\\n        // rebasingActive = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\\r\\n     *\\r\\n     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\\r\\n     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\\r\\n     *      and targetRate is 1e18\\r\\n     */\\r\\n    function rebase()\\r\\n        public\\r\\n    {\\r\\n        // disable rebase\\r\\n        // // EOA only\\r\\n        // require(msg.sender == tx.origin);\\r\\n        // // ensure rebasing at correct time\\r\\n        // _inRebaseWindow();\\r\\n\\r\\n        // // This comparison also ensures there is no reentrancy.\\r\\n        // require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) \\u003c now);\\r\\n\\r\\n        // // Snap the rebase time to the start of this window.\\r\\n        // lastRebaseTimestampSec = now.sub(\\r\\n        //     now.mod(minRebaseTimeIntervalSec)).add(rebaseWindowOffsetSec);\\r\\n\\r\\n        // epoch = epoch.add(1);\\r\\n\\r\\n        // // get twap from uniswap v2;\\r\\n        // uint256 exchangeRate = getTWAP();\\r\\n\\r\\n        // // calculates % change to supply\\r\\n        // (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\\r\\n\\r\\n        // uint256 indexDelta = offPegPerc;\\r\\n\\r\\n        // // Apply the Dampening factor.\\r\\n        // indexDelta = indexDelta.div(rebaseLag);\\r\\n\\r\\n        // PYLONTokenInterface pylon = PYLONTokenInterface(pylonAddress);\\r\\n\\r\\n        // if (positive) {\\r\\n        //     require(pylon.pylonsScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) \\u003c pylon.maxScalingFactor(), \\\"new scaling factor will be too big\\\");\\r\\n        // }\\r\\n\\r\\n\\r\\n        // uint256 currSupply = pylon.totalSupply();\\r\\n\\r\\n        // uint256 mintAmount;\\r\\n        // // reduce indexDelta to account for minting\\r\\n        // if (positive) {\\r\\n        //     uint256 mintPerc = indexDelta.mul(rebaseMintPerc).div(10**18);\\r\\n        //     indexDelta = indexDelta.sub(mintPerc);\\r\\n        //     mintAmount = currSupply.mul(mintPerc).div(10**18);\\r\\n        // }\\r\\n\\r\\n        // // rebase\\r\\n        // uint256 supplyAfterRebase = pylon.rebase(epoch, indexDelta, positive);\\r\\n        // assert(pylon.pylonsScalingFactor() \\u003c= pylon.maxScalingFactor());\\r\\n\\r\\n        // // perform actions after rebase\\r\\n        // afterRebase(mintAmount, offPegPerc);\\r\\n    }\\r\\n\\r\\n\\r\\n    function uniswapV2Call(\\r\\n        address sender,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        bytes memory data\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        // enforce that it is coming from uniswap\\r\\n        require(msg.sender == uniswap_pair, \\\"bad msg.sender\\\");\\r\\n        // enforce that this contract called uniswap\\r\\n        require(sender == address(this), \\\"bad origin\\\");\\r\\n        (UniVars memory uniVars) = abi.decode(data, (UniVars));\\r\\n\\r\\n        PYLONTokenInterface pylon = PYLONTokenInterface(pylonAddress);\\r\\n\\r\\n        if (uniVars.amountFromReserves \\u003e 0) {\\r\\n            // transfer from reserves and mint to uniswap\\r\\n            pylon.transferFrom(reservesContract, uniswap_pair, uniVars.amountFromReserves);\\r\\n            if (uniVars.amountFromReserves \\u003c uniVars.pylonsToUni) {\\r\\n                // if the amount from reserves \\u003e pylonsToUni, we have fully paid for the yCRV tokens\\r\\n                // thus this number would be 0 so no need to mint\\r\\n                pylon.mint(uniswap_pair, uniVars.pylonsToUni.sub(uniVars.amountFromReserves));\\r\\n            }\\r\\n        } else {\\r\\n            // mint to uniswap\\r\\n            pylon.mint(uniswap_pair, uniVars.pylonsToUni);\\r\\n        }\\r\\n\\r\\n        // mint unsold to mintAmount\\r\\n        if (uniVars.mintToReserves \\u003e 0) {\\r\\n            pylon.mint(reservesContract, uniVars.mintToReserves);\\r\\n        }\\r\\n\\r\\n        // transfer reserve token to reserves\\r\\n        if (isToken0) {\\r\\n            SafeERC20.safeTransfer(IERC20(reserveToken), reservesContract, amount1);\\r\\n            emit TreasuryIncreased(amount1, uniVars.pylonsToUni, uniVars.amountFromReserves, uniVars.mintToReserves);\\r\\n        } else {\\r\\n            SafeERC20.safeTransfer(IERC20(reserveToken), reservesContract, amount0);\\r\\n            emit TreasuryIncreased(amount0, uniVars.pylonsToUni, uniVars.amountFromReserves, uniVars.mintToReserves);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function buyReserveAndTransfer(\\r\\n        uint256 mintAmount,\\r\\n        uint256 offPegPerc\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        UniswapPair pair = UniswapPair(uniswap_pair);\\r\\n\\r\\n        PYLONTokenInterface pylon = PYLONTokenInterface(pylonAddress);\\r\\n\\r\\n        // get reserves\\r\\n        (uint256 token0Reserves, uint256 token1Reserves, ) = pair.getReserves();\\r\\n\\r\\n        // check if protocol has excess pylon in the reserve\\r\\n        uint256 excess = pylon.balanceOf(reservesContract);\\r\\n\\r\\n\\r\\n        uint256 tokens_to_max_slippage = uniswapMaxSlippage(token0Reserves, token1Reserves, offPegPerc);\\r\\n\\r\\n        UniVars memory uniVars = UniVars({\\r\\n          pylonsToUni: tokens_to_max_slippage, // how many pylons uniswap needs\\r\\n          amountFromReserves: excess, // how much of pylonsToUni comes from reserves\\r\\n          mintToReserves: 0 // how much pylons protocol mints to reserves\\r\\n        });\\r\\n\\r\\n        // tries to sell all mint + excess\\r\\n        // falls back to selling some of mint and all of excess\\r\\n        // if all else fails, sells portion of excess\\r\\n        // upon pair.swap, `uniswapV2Call` is called by the uniswap pair contract\\r\\n        if (isToken0) {\\r\\n            if (tokens_to_max_slippage \\u003e mintAmount.add(excess)) {\\r\\n                // we already have performed a safemath check on mintAmount+excess\\r\\n                // so we dont need to continue using it in this code path\\r\\n\\r\\n                // can handle selling all of reserves and mint\\r\\n                uint256 buyTokens = getAmountOut(mintAmount + excess, token0Reserves, token1Reserves);\\r\\n                uniVars.pylonsToUni = mintAmount + excess;\\r\\n                uniVars.amountFromReserves = excess;\\r\\n                // call swap using entire mint amount and excess; mint 0 to reserves\\r\\n                pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\\r\\n            } else {\\r\\n                if (tokens_to_max_slippage \\u003e excess) {\\r\\n                    // uniswap can handle entire reserves\\r\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token0Reserves, token1Reserves);\\r\\n\\r\\n                    // swap up to slippage limit, taking entire pylon reserves, and minting part of total\\r\\n                    uniVars.mintToReserves = mintAmount.sub((tokens_to_max_slippage - excess));\\r\\n                    pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\\r\\n                } else {\\r\\n                    // uniswap cant handle all of excess\\r\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token0Reserves, token1Reserves);\\r\\n                    uniVars.amountFromReserves = tokens_to_max_slippage;\\r\\n                    uniVars.mintToReserves = mintAmount;\\r\\n                    // swap up to slippage limit, taking excess - remainingExcess from reserves, and minting full amount\\r\\n                    // to reserves\\r\\n                    pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            if (tokens_to_max_slippage \\u003e mintAmount.add(excess)) {\\r\\n                // can handle all of reserves and mint\\r\\n                uint256 buyTokens = getAmountOut(mintAmount + excess, token1Reserves, token0Reserves);\\r\\n                uniVars.pylonsToUni = mintAmount + excess;\\r\\n                uniVars.amountFromReserves = excess;\\r\\n                // call swap using entire mint amount and excess; mint 0 to reserves\\r\\n                pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\\r\\n            } else {\\r\\n                if (tokens_to_max_slippage \\u003e excess) {\\r\\n                    // uniswap can handle entire reserves\\r\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token1Reserves, token0Reserves);\\r\\n\\r\\n                    // swap up to slippage limit, taking entire pylon reserves, and minting part of total\\r\\n                    uniVars.mintToReserves = mintAmount.sub( (tokens_to_max_slippage - excess));\\r\\n                    // swap up to slippage limit, taking entire pylon reserves, and minting part of total\\r\\n                    pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\\r\\n                } else {\\r\\n                    // uniswap cant handle all of excess\\r\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token1Reserves, token0Reserves);\\r\\n                    uniVars.amountFromReserves = tokens_to_max_slippage;\\r\\n                    uniVars.mintToReserves = mintAmount;\\r\\n                    // swap up to slippage limit, taking excess - remainingExcess from reserves, and minting full amount\\r\\n                    // to reserves\\r\\n                    pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function uniswapMaxSlippage(\\r\\n        uint256 token0,\\r\\n        uint256 token1,\\r\\n        uint256 offPegPerc\\r\\n    )\\r\\n      internal\\r\\n      view\\r\\n      returns (uint256)\\r\\n    {\\r\\n        if (isToken0) {\\r\\n          if (offPegPerc \\u003e= 10**17) {\\r\\n              // cap slippage\\r\\n              return token0.mul(maxSlippageFactor).div(10**18);\\r\\n          } else {\\r\\n              // in the 5-10% off peg range, slippage is essentially 2*x (where x is percentage of pool to buy).\\r\\n              // all we care about is not pushing below the peg, so underestimate\\r\\n              // the amount we can sell by dividing by 3. resulting price impact\\r\\n              // should be ~= offPegPerc * 2 / 3, which will keep us above the peg\\r\\n              //\\r\\n              // this is a conservative heuristic\\r\\n              return token0.mul(offPegPerc / 3).div(10**18);\\r\\n          }\\r\\n        } else {\\r\\n            if (offPegPerc \\u003e= 10**17) {\\r\\n                return token1.mul(maxSlippageFactor).div(10**18);\\r\\n            } else {\\r\\n                return token1.mul(offPegPerc / 3).div(10**18);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\r\\n     *\\r\\n     * @param amountIn input amount of the asset\\r\\n     * @param reserveIn reserves of the asset being sold\\r\\n     * @param reserveOut reserves if the asset being purchased\\r\\n     */\\r\\n\\r\\n   function getAmountOut(\\r\\n        uint amountIn,\\r\\n        uint reserveIn,\\r\\n        uint reserveOut\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint amountOut)\\r\\n    {\\r\\n       require(amountIn \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\r\\n       require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_LIQUIDITY\\u0027);\\r\\n       uint amountInWithFee = amountIn.mul(997);\\r\\n       uint numerator = amountInWithFee.mul(reserveOut);\\r\\n       uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\r\\n       amountOut = numerator / denominator;\\r\\n   }\\r\\n\\r\\n\\r\\n    function afterRebase(\\r\\n        uint256 mintAmount,\\r\\n        uint256 offPegPerc\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        // update uniswap\\r\\n        UniswapPair(uniswap_pair).sync();\\r\\n\\r\\n        if (mintAmount \\u003e 0) {\\r\\n            buyReserveAndTransfer(\\r\\n                mintAmount,\\r\\n                offPegPerc\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // call any extra functions\\r\\n        for (uint i = 0; i \\u003c transactions.length; i++) {\\r\\n            Transaction storage t = transactions[i];\\r\\n            if (t.enabled) {\\r\\n                bool result =\\r\\n                    externalCall(t.destination, t.data);\\r\\n                if (!result) {\\r\\n                    emit TransactionFailed(t.destination, i, t.data);\\r\\n                    revert(\\\"Transaction Failed\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates TWAP from uniswap\\r\\n     *\\r\\n     * @dev When liquidity is low, this can be manipulated by an end of block -\\u003e next block\\r\\n     *      attack. We delay the activation of rebases 12 hours after liquidity incentives\\r\\n     *      to reduce this attack vector. Additional there is very little supply\\r\\n     *      to be able to manipulate this during that time period of highest vuln.\\r\\n     */\\r\\n    function getTWAP()\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n      (uint priceCumulative, uint32 blockTimestamp) =\\r\\n         UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\\r\\n       uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n\\r\\n       // no period check as is done in isRebaseWindow\\r\\n\\r\\n       // overflow is desired, casting never truncates\\r\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\r\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\\r\\n\\r\\n        priceCumulativeLast = priceCumulative;\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n\\r\\n        return FixedPoint.decode144(FixedPoint.mul(priceAverage, 10**18));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates current TWAP from uniswap\\r\\n     *\\r\\n     */\\r\\n    function getCurrentTWAP()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n      (uint priceCumulative, uint32 blockTimestamp) =\\r\\n         UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\\r\\n       uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n\\r\\n       // no period check as is done in isRebaseWindow\\r\\n\\r\\n       // overflow is desired, casting never truncates\\r\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\r\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\\r\\n\\r\\n        return FixedPoint.decode144(FixedPoint.mul(priceAverage, 10**18));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the deviation threshold fraction. If the exchange rate given by the market\\r\\n     *         oracle is within this fractional distance from the targetRate, then no supply\\r\\n     *         modifications are made.\\r\\n     * @param deviationThreshold_ The new exchange rate threshold fraction.\\r\\n     */\\r\\n    function setDeviationThreshold(uint256 deviationThreshold_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(deviationThreshold \\u003e 0);\\r\\n        uint256 oldDeviationThreshold = deviationThreshold;\\r\\n        deviationThreshold = deviationThreshold_;\\r\\n        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the rebase lag parameter.\\r\\n               It is used to dampen the applied supply adjustment by 1 / rebaseLag\\r\\n               If the rebase lag R, equals 1, the smallest value for R, then the full supply\\r\\n               correction is applied on each rebase cycle.\\r\\n               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\\r\\n     * @param rebaseLag_ The new rebase lag parameter.\\r\\n     */\\r\\n    function setRebaseLag(uint256 rebaseLag_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(rebaseLag_ \\u003e 0);\\r\\n        rebaseLag = rebaseLag_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the targetRate parameter.\\r\\n     * @param targetRate_ The new target rate parameter.\\r\\n     */\\r\\n    function setTargetRate(uint256 targetRate_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(targetRate_ \\u003e 0);\\r\\n        targetRate = targetRate_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the parameters which control the timing and frequency of\\r\\n     *         rebase operations.\\r\\n     *         a) the minimum time period that must elapse between rebase cycles.\\r\\n     *         b) the rebase window offset parameter.\\r\\n     *         c) the rebase window length parameter.\\r\\n     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\\r\\n     *        operations, in seconds.\\r\\n     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\\r\\n              the rebase interval, where the rebase window begins.\\r\\n     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\\r\\n     */\\r\\n    function setRebaseTimingParameters(\\r\\n        uint256 minRebaseTimeIntervalSec_,\\r\\n        uint256 rebaseWindowOffsetSec_,\\r\\n        uint256 rebaseWindowLengthSec_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(minRebaseTimeIntervalSec_ \\u003e 0);\\r\\n        require(rebaseWindowOffsetSec_ \\u003c minRebaseTimeIntervalSec_);\\r\\n\\r\\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\\r\\n        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\\r\\n        rebaseWindowLengthSec = rebaseWindowLengthSec_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return If the latest block timestamp is within the rebase time window it, returns true.\\r\\n     *         Otherwise, returns false.\\r\\n     */\\r\\n    function inRebaseWindow() public view returns (bool) {\\r\\n\\r\\n        // rebasing is delayed until there is a liquid market\\r\\n        _inRebaseWindow();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _inRebaseWindow() internal view {\\r\\n\\r\\n        // rebasing is delayed until there is a liquid market\\r\\n        require(rebasingActive, \\\"rebasing not active\\\");\\r\\n\\r\\n        require(now.mod(minRebaseTimeIntervalSec) \\u003e= rebaseWindowOffsetSec, \\\"too early\\\");\\r\\n        require(now.mod(minRebaseTimeIntervalSec) \\u003c (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \\\"too late\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Computes in % how far off market is from peg\\r\\n     */\\r\\n    function computeOffPegPerc(uint256 rate)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256, bool)\\r\\n    {\\r\\n        if (withinDeviationThreshold(rate)) {\\r\\n            return (0, false);\\r\\n        }\\r\\n\\r\\n        // indexDelta =  (rate - targetRate) / targetRate\\r\\n        if (rate \\u003e targetRate) {\\r\\n            return (rate.sub(targetRate).mul(10**18).div(targetRate), true);\\r\\n        } else {\\r\\n            return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param rate The current exchange rate, an 18 decimal fixed point number.\\r\\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\\r\\n     *         Otherwise, returns false.\\r\\n     */\\r\\n    function withinDeviationThreshold(uint256 rate)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\\r\\n            .div(10 ** 18);\\r\\n\\r\\n        return (rate \\u003e= targetRate \\u0026\\u0026 rate.sub(targetRate) \\u003c absoluteDeviationThreshold)\\r\\n            || (rate \\u003c targetRate \\u0026\\u0026 targetRate.sub(rate) \\u003c absoluteDeviationThreshold);\\r\\n    }\\r\\n\\r\\n    /* - Constructor Helpers - */\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(\\r\\n        address factory,\\r\\n        address token0,\\r\\n        address token1\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (address pair)\\r\\n    {\\r\\n        pair = address(uint(keccak256(abi.encodePacked(\\r\\n                hex\\u0027ff\\u0027,\\r\\n                factory,\\r\\n                keccak256(abi.encodePacked(token0, token1)),\\r\\n                hex\\u002796e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\u0027 // init code hash\\r\\n            ))));\\r\\n    }\\r\\n\\r\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\r\\n    function sortTokens(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (address token0, address token1)\\r\\n    {\\r\\n        require(tokenA != tokenB, \\u0027UniswapV2Library: IDENTICAL_ADDRESSES\\u0027);\\r\\n        (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\r\\n        require(token0 != address(0), \\u0027UniswapV2Library: ZERO_ADDRESS\\u0027);\\r\\n    }\\r\\n\\r\\n    /* -- Rebase helpers -- */\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a transaction that gets called for a downstream receiver of rebases\\r\\n     * @param destination Address of contract destination\\r\\n     * @param data Transaction data payload\\r\\n     */\\r\\n    function addTransaction(address destination, bytes calldata data)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        transactions.push(Transaction({\\r\\n            enabled: true,\\r\\n            destination: destination,\\r\\n            data: data\\r\\n        }));\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @param index Index of transaction to remove.\\r\\n     *              Transaction ordering may have changed since adding.\\r\\n     */\\r\\n    function removeTransaction(uint index)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(index \\u003c transactions.length, \\\"index out of bounds\\\");\\r\\n\\r\\n        if (index \\u003c transactions.length - 1) {\\r\\n            transactions[index] = transactions[transactions.length - 1];\\r\\n        }\\r\\n\\r\\n        transactions.length--;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param index Index of transaction. Transaction ordering may have changed since adding.\\r\\n     * @param enabled True for enabled, false for disabled.\\r\\n     */\\r\\n    function setTransactionEnabled(uint index, bool enabled)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(index \\u003c transactions.length, \\\"index must be in range of stored tx list\\\");\\r\\n        transactions[index].enabled = enabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev wrapper to call the encoded transactions on downstream consumers.\\r\\n     * @param destination Address of destination contract.\\r\\n     * @param data The encoded data payload.\\r\\n     * @return True on success\\r\\n     */\\r\\n    function externalCall(address destination, bytes memory data)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        bool result;\\r\\n        assembly {  // solhint-disable-line no-inline-assembly\\r\\n            // \\\"Allocate\\\" memory for output\\r\\n            // (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\r\\n            let outputAddress := mload(0x40)\\r\\n\\r\\n            // First 32 bytes are the padded length of data, so exclude that\\r\\n            let dataAddress := add(data, 32)\\r\\n\\r\\n            result := call(\\r\\n                // 34710 is the value that solidity is currently emitting\\r\\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB)\\r\\n                // + callValueTransferGas (9000) + callNewAccountGas\\r\\n                // (25000, in case the destination address does not exist and needs creating)\\r\\n                sub(gas, 34710),\\r\\n\\r\\n\\r\\n                destination,\\r\\n                0, // transfer value in wei\\r\\n                dataAddress,\\r\\n                mload(data),  // Size of the input, in bytes. Stored in position 0 of the array.\\r\\n                outputAddress,\\r\\n                0  // Output is ignored, therefore the output size is zero\\r\\n            )\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONReserves.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\nimport \\\"./PYLONTokenInterface.sol\\\";\\r\\n\\r\\ncontract PYLONReserves {\\r\\n\\r\\n    // Token that serves as a reserve for PYLON\\r\\n    address public reserveToken;\\r\\n\\r\\n    address public gov;\\r\\n\\r\\n    address public pendingGov;\\r\\n\\r\\n    address public rebaser;\\r\\n\\r\\n    address public pylonAddress;\\r\\n\\r\\n    /*** Gov Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingGov is changed\\r\\n     */\\r\\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when gov is changed\\r\\n     */\\r\\n    event NewGov(address oldGov, address newGov);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when rebaser is changed\\r\\n     */\\r\\n    event NewRebaser(address oldRebaser, address newRebaser);\\r\\n\\r\\n\\r\\n    modifier onlyGov() {\\r\\n        require(msg.sender == gov);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address reserveToken_,\\r\\n        address pylonAddress_\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        reserveToken = reserveToken_;\\r\\n        pylonAddress = pylonAddress_;\\r\\n        gov = msg.sender;\\r\\n    }\\r\\n\\r\\n    function _setRebaser(address rebaser_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        address oldRebaser = rebaser;\\r\\n        PYLONTokenInterface(pylonAddress).decreaseAllowance(oldRebaser, uint256(-1));\\r\\n        rebaser = rebaser_;\\r\\n        PYLONTokenInterface(pylonAddress).approve(rebaser_, uint256(-1));\\r\\n        emit NewRebaser(oldRebaser, rebaser_);\\r\\n    }\\r\\n\\r\\n    /** @notice sets the pendingGov\\r\\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\\r\\n     */\\r\\n    function _setPendingGov(address pendingGov_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        address oldPendingGov = pendingGov;\\r\\n        pendingGov = pendingGov_;\\r\\n        emit NewPendingGov(oldPendingGov, pendingGov_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice lets msg.sender accept governance\\r\\n     */\\r\\n    function _acceptGov()\\r\\n        external\\r\\n    {\\r\\n        require(msg.sender == pendingGov, \\\"!pending\\\");\\r\\n        address oldGov = gov;\\r\\n        gov = pendingGov;\\r\\n        pendingGov = address(0);\\r\\n        emit NewGov(oldGov, gov);\\r\\n    }\\r\\n\\r\\n    /// @notice Moves all tokens to a new reserve contract\\r\\n    function migrateReserves(\\r\\n        address newReserve,\\r\\n        address[] memory tokens\\r\\n    )\\r\\n        public\\r\\n        onlyGov\\r\\n    {\\r\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\r\\n            IERC20 token =  IERC20(tokens[i]);\\r\\n            uint256 bal = token.balanceOf(address(this));\\r\\n            SafeERC20.safeTransfer(token, newReserve, bal);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Gets the current amount of reserves token held by this contract\\r\\n    function reserves()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return IERC20(reserveToken).balanceOf(address(this));\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONSNXPool.sol\":{\"content\":\"/*\\r\\n   ____            __   __        __   _\\r\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\r\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\r\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\r\\n     /___/\\r\\n\\r\\n* Synthetix: PYLONRewards.sol\\r\\n*\\r\\n* Docs: https://docs.synthetix.io/\\r\\n*\\r\\n*\\r\\n* MIT License\\r\\n* ===========\\r\\n*\\r\\n* Copyright (c) 2020 Synthetix\\r\\n*\\r\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n* in the Software without restriction, including without limitation the rights\\r\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n* copies of the Software, and to permit persons to whom the Software is\\r\\n* furnished to do so, subject to the following conditions:\\r\\n*\\r\\n* The above copyright notice and this permission notice shall be included in all\\r\\n* copies or substantial portions of the Software.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/IRewardDistributionRecipient.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ncontract IRewardDistributionRecipient is Ownable {\\r\\n    address public rewardDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardDistribution() {\\r\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setRewardDistribution(address _rewardDistribution)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardDistribution = _rewardDistribution;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/CurveRewards.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ninterface PYLON {\\r\\n    function pylonsScalingFactor() external returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract LPTokenWrapper {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public snx = IERC20(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        snx.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        snx.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PYLONSNXPool is LPTokenWrapper, IRewardDistributionRecipient {\\r\\n    IERC20 public pylon = IERC20(0xD7B7d3C0bdA57723Fb54ab95Fd8F9EA033AF37f2);\\r\\n    uint256 public constant DURATION = 864000; // 10 days\\r\\n\\r\\n    uint256 public starttime = 1598918400; // 2020-09-01 00:00:00 (UTC UTC +00:00)\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier checkStart() {\\r\\n        require(block.timestamp \\u003e= starttime,\\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    // stake visibility is public as overriding LPTokenWrapper\\u0027s stake() function\\r\\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        super.stake(amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        super.withdraw(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(balanceOf(msg.sender));\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    function getReward() public updateReward(msg.sender) checkStart {\\r\\n        uint256 reward = earned(msg.sender);\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 trueReward = reward.mul(scalingFactor).div(10**18);\\r\\n            pylon.safeTransfer(msg.sender, trueReward);\\r\\n            emit RewardPaid(msg.sender, trueReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward)\\r\\n        external\\r\\n        onlyRewardDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        if (block.timestamp \\u003e starttime) {\\r\\n          if (block.timestamp \\u003e= periodFinish) {\\r\\n              rewardRate = reward.div(DURATION);\\r\\n          } else {\\r\\n              uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n              uint256 leftover = remaining.mul(rewardRate);\\r\\n              rewardRate = reward.add(leftover).div(DURATION);\\r\\n          }\\r\\n          lastUpdateTime = block.timestamp;\\r\\n          periodFinish = block.timestamp.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        } else {\\r\\n          rewardRate = reward.div(DURATION);\\r\\n          lastUpdateTime = starttime;\\r\\n          periodFinish = starttime.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONTokenInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./PYLONTokenStorage.sol\\\";\\r\\nimport \\\"./PYLONGovernanceStorage.sol\\\";\\r\\n\\r\\ncontract PYLONTokenInterface is PYLONTokenStorage, PYLONGovernanceStorage {\\r\\n\\r\\n    /// @notice An event thats emitted when an account changes its delegate\\r\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\r\\n\\r\\n    /// @notice An event thats emitted when a delegate account\\u0027s vote balance changes\\r\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are rebased\\r\\n     */\\r\\n    event Rebase(uint256 epoch, uint256 prevPYLONsScalingFactor, uint256 newPYLONsScalingFactor);\\r\\n\\r\\n    /*** Gov Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingGov is changed\\r\\n     */\\r\\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when gov is changed\\r\\n     */\\r\\n    event NewGov(address oldGov, address newGov);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the rebaser contract\\r\\n     */\\r\\n    event NewRebaser(address oldRebaser, address newRebaser);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the incentivizer contract\\r\\n     */\\r\\n    event NewIncentivizer(address oldIncentivizer, address newIncentivizer);\\r\\n\\r\\n    /* - ERC20 Events - */\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Transfer event\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint amount);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Approval event\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\r\\n\\r\\n    /* - Extra Events - */\\r\\n    /**\\r\\n     * @notice Tokens minted event\\r\\n     */\\r\\n    event Mint(address to, uint256 amount);\\r\\n\\r\\n    // Public functions\\r\\n    function transfer(address to, uint256 value) external returns(bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\\r\\n    function balanceOf(address who) external view returns(uint256);\\r\\n    function balanceOfUnderlying(address who) external view returns(uint256);\\r\\n    function allowance(address owner_, address spender) external view returns(uint256);\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\r\\n    function maxScalingFactor() external view returns (uint256);\\r\\n\\r\\n    /* - Governance Functions - */\\r\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\\r\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    function delegate(address delegatee) external;\\r\\n    function delegates(address delegator) external view returns (address);\\r\\n    function getCurrentVotes(address account) external view returns (uint256);\\r\\n\\r\\n    /* - Permissioned/Governance functions - */\\r\\n    function mint(address to, uint256 amount) external returns (bool);\\r\\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\\r\\n    function _setRebaser(address rebaser_) external;\\r\\n    function _setIncentivizer(address incentivizer_) external;\\r\\n    function _setPendingGov(address pendingGov_) external;\\r\\n    function _acceptGov() external;\\r\\n}\\r\\n\"},\"PYLONTokenStorage.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n// Storage for a PYLON token\\r\\ncontract PYLONTokenStorage {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev Guard variable for re-entrancy checks. Not currently used\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token name for this token\\r\\n     */\\r\\n    string public name;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token symbol for this token\\r\\n     */\\r\\n    string public symbol;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token decimals for this token\\r\\n     */\\r\\n    uint8 public decimals;\\r\\n\\r\\n    /**\\r\\n     * @notice Governor for this contract\\r\\n     */\\r\\n    address public gov;\\r\\n\\r\\n    /**\\r\\n     * @notice Pending governance for this contract\\r\\n     */\\r\\n    address public pendingGov;\\r\\n\\r\\n    /**\\r\\n     * @notice Approved rebaser for this contract\\r\\n     */\\r\\n    address public rebaser;\\r\\n\\r\\n    /**\\r\\n     * @notice Reserve address of PYLON protocol\\r\\n     */\\r\\n    address public incentivizer;\\r\\n\\r\\n    /**\\r\\n     * @notice Total supply of PYLONs\\r\\n     */\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    /**\\r\\n     * @notice Internal decimals used to handle scaling factor\\r\\n     */\\r\\n    uint256 public constant internalDecimals = 10**24;\\r\\n\\r\\n    /**\\r\\n     * @notice Used for percentage maths\\r\\n     */\\r\\n    uint256 public constant BASE = 10**18;\\r\\n\\r\\n    /**\\r\\n     * @notice Scaling factor that adjusts everyone\\u0027s balances\\r\\n     */\\r\\n    uint256 public pylonsScalingFactor;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _pylonBalances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowedFragments;\\r\\n\\r\\n    uint256 public initSupply;\\r\\n\\r\\n}\\r\\n\"},\"PYLONwBTCPool.sol\":{\"content\":\"/*\\r\\n   ____            __   __        __   _\\r\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\r\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\r\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\r\\n     /___/\\r\\n\\r\\n* Synthetix: PYLONRewards.sol\\r\\n*\\r\\n* Docs: https://docs.synthetix.io/\\r\\n*\\r\\n*\\r\\n* MIT License\\r\\n* ===========\\r\\n*\\r\\n* Copyright (c) 2020 Synthetix\\r\\n*\\r\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n* in the Software without restriction, including without limitation the rights\\r\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n* copies of the Software, and to permit persons to whom the Software is\\r\\n* furnished to do so, subject to the following conditions:\\r\\n*\\r\\n* The above copyright notice and this permission notice shall be included in all\\r\\n* copies or substantial portions of the Software.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/IRewardDistributionRecipient.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ncontract IRewardDistributionRecipient is Ownable {\\r\\n    address public rewardDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardDistribution() {\\r\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setRewardDistribution(address _rewardDistribution)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardDistribution = _rewardDistribution;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/CurveRewards.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ninterface PYLON {\\r\\n    function pylonsScalingFactor() external returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\ncontract LPTokenWrapper {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public wbtc = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        wbtc.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        wbtc.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PYLONwBTCPool is LPTokenWrapper, IRewardDistributionRecipient {\\r\\n    IERC20 public pylon = IERC20(0xD7B7d3C0bdA57723Fb54ab95Fd8F9EA033AF37f2);\\r\\n    uint256 public constant DURATION = 864000; // 10 days\\r\\n\\r\\n    uint256 public starttime = 1598918400; // 2020-09-01 00:00:00 (UTC UTC +00:00)\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier checkStart(){\\r\\n        require(block.timestamp \\u003e= starttime,\\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    // stake visibility is public as overriding LPTokenWrapper\\u0027s stake() function\\r\\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        super.stake(amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        super.withdraw(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(balanceOf(msg.sender));\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    function getReward() public updateReward(msg.sender) checkStart {\\r\\n        uint256 reward = earned(msg.sender);\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 trueReward = reward.mul(scalingFactor).div(10**18);\\r\\n            pylon.safeTransfer(msg.sender, trueReward);\\r\\n            emit RewardPaid(msg.sender, trueReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward)\\r\\n        external\\r\\n        onlyRewardDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        if (block.timestamp \\u003e starttime) {\\r\\n          if (block.timestamp \\u003e= periodFinish) {\\r\\n              rewardRate = reward.div(DURATION);\\r\\n          } else {\\r\\n              uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n              uint256 leftover = remaining.mul(rewardRate);\\r\\n              rewardRate = reward.add(leftover).div(DURATION);\\r\\n          }\\r\\n          lastUpdateTime = block.timestamp;\\r\\n          periodFinish = block.timestamp.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        } else {\\r\\n          rewardRate = reward.div(DURATION);\\r\\n          lastUpdateTime = starttime;\\r\\n          periodFinish = starttime.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONwETHPool.sol\":{\"content\":\"/*\\r\\n   ____            __   __        __   _\\r\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\r\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\r\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\r\\n     /___/\\r\\n\\r\\n* Synthetix: PYLONRewards.sol\\r\\n*\\r\\n* Docs: https://docs.synthetix.io/\\r\\n*\\r\\n*\\r\\n* MIT License\\r\\n* ===========\\r\\n*\\r\\n* Copyright (c) 2020 Synthetix\\r\\n*\\r\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n* in the Software without restriction, including without limitation the rights\\r\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n* copies of the Software, and to permit persons to whom the Software is\\r\\n* furnished to do so, subject to the following conditions:\\r\\n*\\r\\n* The above copyright notice and this permission notice shall be included in all\\r\\n* copies or substantial portions of the Software.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/IRewardDistributionRecipient.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ncontract IRewardDistributionRecipient is Ownable {\\r\\n    address public rewardDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardDistribution() {\\r\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setRewardDistribution(address _rewardDistribution)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardDistribution = _rewardDistribution;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/CurveRewards.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ninterface PYLON {\\r\\n    function pylonsScalingFactor() external returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract LPTokenWrapper {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        weth.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        weth.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PYLONwETHPool is LPTokenWrapper, IRewardDistributionRecipient {\\r\\n    IERC20 public pylon = IERC20(0xD7B7d3C0bdA57723Fb54ab95Fd8F9EA033AF37f2); // token - etherscan.io\\r\\n    uint256 public constant DURATION = 864000; // 10 days\\r\\n\\r\\n    uint256 public starttime = 1598918400; // 2020-09-01 00:00:00 (UTC UTC +00:00)\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier checkStart() {\\r\\n        require(block.timestamp \\u003e= starttime,\\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    // stake visibility is public as overriding LPTokenWrapper\\u0027s stake() function\\r\\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        super.stake(amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        super.withdraw(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(balanceOf(msg.sender));\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    function getReward() public updateReward(msg.sender) checkStart {\\r\\n        uint256 reward = earned(msg.sender);\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 trueReward = reward.mul(scalingFactor).div(10**18);\\r\\n            pylon.safeTransfer(msg.sender, trueReward);\\r\\n            emit RewardPaid(msg.sender, trueReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward)\\r\\n        external\\r\\n        onlyRewardDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        if (block.timestamp \\u003e starttime) {\\r\\n          if (block.timestamp \\u003e= periodFinish) {\\r\\n              rewardRate = reward.div(DURATION);\\r\\n          } else {\\r\\n              uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n              uint256 leftover = remaining.mul(rewardRate);\\r\\n              rewardRate = reward.add(leftover).div(DURATION);\\r\\n          }\\r\\n          lastUpdateTime = block.timestamp;\\r\\n          periodFinish = block.timestamp.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        } else {\\r\\n          rewardRate = reward.div(DURATION);\\r\\n          lastUpdateTime = starttime;\\r\\n          periodFinish = starttime.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"PYLONyaLINKPool.sol\":{\"content\":\"/*\\r\\n   ____            __   __        __   _\\r\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\r\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\r\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\r\\n     /___/\\r\\n\\r\\n* Synthetix: PYLONRewards.sol\\r\\n*\\r\\n* Docs: https://docs.synthetix.io/\\r\\n*\\r\\n*\\r\\n* MIT License\\r\\n* ===========\\r\\n*\\r\\n* Copyright (c) 2020 Synthetix\\r\\n*\\r\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n* in the Software without restriction, including without limitation the rights\\r\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n* copies of the Software, and to permit persons to whom the Software is\\r\\n* furnished to do so, subject to the following conditions:\\r\\n*\\r\\n* The above copyright notice and this permission notice shall be included in all\\r\\n* copies or substantial portions of the Software.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n*/\\r\\n\\r\\n// File: @openzeppelin/contracts/math/Math.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/GSN/Context.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = _msgSender();\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/utils/Address.sol\\r\\n\\r\\npragma solidity ^0.5.5;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\r\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\r\\n     * not containing a contract.\\r\\n     *\\r\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\r\\n     * function returns false is an externally-owned account (EOA) and not a\\r\\n     * contract.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies in extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` into `address payable`. Note that this is\\r\\n     * simply a type cast: the actual underlying value is not changed.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function toPayable(address account) internal pure returns (address payable) {\\r\\n        return address(uint160(account));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-call-value\\r\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/IRewardDistributionRecipient.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\ncontract IRewardDistributionRecipient is Ownable {\\r\\n    address public rewardDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardDistribution() {\\r\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setRewardDistribution(address _rewardDistribution)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardDistribution = _rewardDistribution;\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: contracts/CurveRewards.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ninterface PYLON {\\r\\n    function pylonsScalingFactor() external returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract LPTokenWrapper {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public link = IERC20(0x29E240CFD7946BA20895a7a02eDb25C210f9f324);\\r\\n    uint256 private _totalSupply;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        link.safeTransferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public {\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        link.safeTransfer(msg.sender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PYLONyaLINKPool is LPTokenWrapper, IRewardDistributionRecipient {\\r\\n    IERC20 public pylon = IERC20(0xD7B7d3C0bdA57723Fb54ab95Fd8F9EA033AF37f2);\\r\\n    uint256 public constant DURATION = 864000; // 10 days\\r\\n\\r\\n    uint256 public starttime = 1598918400; // 2020-09-01 00:00:00 (UTC UTC +00:00)\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) public rewards;\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n\\r\\n    modifier checkStart() {\\r\\n        require(block.timestamp \\u003e= starttime,\\\"not start\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (totalSupply() == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable()\\r\\n                    .sub(lastUpdateTime)\\r\\n                    .mul(rewardRate)\\r\\n                    .mul(1e18)\\r\\n                    .div(totalSupply())\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return\\r\\n            balanceOf(account)\\r\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\r\\n                .div(1e18)\\r\\n                .add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    // stake visibility is public as overriding LPTokenWrapper\\u0027s stake() function\\r\\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        super.stake(amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        super.withdraw(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(balanceOf(msg.sender));\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    function getReward() public updateReward(msg.sender) checkStart {\\r\\n        uint256 reward = earned(msg.sender);\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            uint256 scalingFactor = PYLON(address(pylon)).pylonsScalingFactor();\\r\\n            uint256 trueReward = reward.mul(scalingFactor).div(10**18);\\r\\n            pylon.safeTransfer(msg.sender, trueReward);\\r\\n            emit RewardPaid(msg.sender, trueReward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward)\\r\\n        external\\r\\n        onlyRewardDistribution\\r\\n        updateReward(address(0))\\r\\n    {\\r\\n        if (block.timestamp \\u003e starttime) {\\r\\n          if (block.timestamp \\u003e= periodFinish) {\\r\\n              rewardRate = reward.div(DURATION);\\r\\n          } else {\\r\\n              uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n              uint256 leftover = remaining.mul(rewardRate);\\r\\n              rewardRate = reward.add(leftover).div(DURATION);\\r\\n          }\\r\\n          lastUpdateTime = block.timestamp;\\r\\n          periodFinish = block.timestamp.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        } else {\\r\\n          rewardRate = reward.div(DURATION);\\r\\n          lastUpdateTime = starttime;\\r\\n          periodFinish = starttime.add(DURATION);\\r\\n          emit RewardAdded(reward);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"TimeLock.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\n// Original file came from Compound: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol\\r\\n\\r\\n\\r\\n// Original audit: https://blog.openzeppelin.com/compound-finance-patch-audit/\\r\\n// Overview:\\r\\n//    No Critical\\r\\n//    No High\\r\\n//\\r\\n// Changes made by PYLON after audit:\\r\\n//    Formatting, naming, \\u0026 uint256 instead of uint\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract Timelock {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /// @notice An event emitted when the timelock admin changes\\r\\n    event NewAdmin(address indexed newAdmin);\\r\\n    /// @notice An event emitted when a new admin is staged in the timelock\\r\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\r\\n    event NewDelay(uint indexed newDelay);\\r\\n    /// @notice An event emitted when a queued transaction is cancelled\\r\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature,  bytes data, uint256 eta);\\r\\n    /// @notice An event emitted when a queued transaction is executed\\r\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature,  bytes data, uint256 eta);\\r\\n    /// @notice An event emitted when a new transaction is queued\\r\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\\r\\n\\r\\n    /// @notice the length of time after the delay has passed that a transaction can be executed\\r\\n    uint256 public constant GRACE_PERIOD = 14 days;\\r\\n    /// @notice the minimum length of the timelock delay\\r\\n    uint256 public constant MINIMUM_DELAY = 12 hours + 2*60*15; // have to be present for 2 rebases\\r\\n    /// @notice the maximum length of the timelock delay\\r\\n    uint256 public constant MAXIMUM_DELAY = 30 days;\\r\\n\\r\\n    address public admin;\\r\\n    address public pendingAdmin;\\r\\n    uint256 public delay;\\r\\n    bool public admin_initialized;\\r\\n\\r\\n    mapping (bytes32 =\\u003e bool) public queuedTransactions;\\r\\n\\r\\n\\r\\n    constructor()\\r\\n        public\\r\\n    {\\r\\n        /* require(delay_ \\u003e= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\r\\n        require(delay_ \\u003c= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\"); */\\r\\n\\r\\n        admin = msg.sender;\\r\\n        delay = MINIMUM_DELAY;\\r\\n        admin_initialized = false;\\r\\n    }\\r\\n\\r\\n    function() external payable { }\\r\\n\\r\\n\\r\\n    /**\\r\\n    @notice sets the delay\\r\\n    @param delay_ the new delay\\r\\n     */\\r\\n    function setDelay(uint256 delay_)\\r\\n        public\\r\\n    {\\r\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\r\\n        require(delay_ \\u003e= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\r\\n        require(delay_ \\u003c= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\r\\n        delay = delay_;\\r\\n\\r\\n        emit NewDelay(delay);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice sets the new admin address\\r\\n    function acceptAdmin()\\r\\n        public\\r\\n    {\\r\\n        require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\r\\n        admin = msg.sender;\\r\\n        pendingAdmin = address(0);\\r\\n\\r\\n        emit NewAdmin(admin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @notice queues a new pendingAdmin\\r\\n    @param pendingAdmin_ the new pendingAdmin address\\r\\n     */\\r\\n    function setPendingAdmin(address pendingAdmin_)\\r\\n        public\\r\\n    {\\r\\n        // allows one time setting of admin for deployment purposes\\r\\n        if (admin_initialized) {\\r\\n          require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\r\\n        } else {\\r\\n          admin_initialized = true;\\r\\n        }\\r\\n        pendingAdmin = pendingAdmin_;\\r\\n\\r\\n        emit NewPendingAdmin(pendingAdmin);\\r\\n    }\\r\\n\\r\\n\\r\\n    function queueTransaction(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string memory signature,\\r\\n        bytes memory data,\\r\\n        uint256 eta\\r\\n    )\\r\\n        public\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\r\\n        require(eta \\u003e= getBlockTimestamp().add(delay), \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\r\\n\\r\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\r\\n        queuedTransactions[txHash] = true;\\r\\n\\r\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\r\\n        return txHash;\\r\\n    }\\r\\n\\r\\n    function cancelTransaction(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string memory signature,\\r\\n        bytes memory data,\\r\\n        uint256 eta\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n        require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\r\\n\\r\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\r\\n        queuedTransactions[txHash] = false;\\r\\n\\r\\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\\r\\n    }\\r\\n\\r\\n    function executeTransaction(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string memory signature,\\r\\n        bytes memory data,\\r\\n        uint256 eta\\r\\n    )\\r\\n        public\\r\\n        payable\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\r\\n\\r\\n        // timelock not enforced prior to updating the admin. This should occur on\\r\\n        // deployment.\\r\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\r\\n        if (admin_initialized) {\\r\\n          require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn\\u0027t been queued.\\\");\\r\\n          require(getBlockTimestamp() \\u003e= eta, \\\"Timelock::executeTransaction: Transaction hasn\\u0027t surpassed time lock.\\\");\\r\\n          require(getBlockTimestamp() \\u003c= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\r\\n\\r\\n          queuedTransactions[txHash] = false;\\r\\n        }\\r\\n\\r\\n\\r\\n        bytes memory callData;\\r\\n\\r\\n        if (bytes(signature).length == 0) {\\r\\n            callData = data;\\r\\n        } else {\\r\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\r\\n        }\\r\\n\\r\\n        // solium-disable-next-line security/no-call-value\\r\\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\\r\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\r\\n\\r\\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\r\\n\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    function getBlockTimestamp() internal view returns (uint256) {\\r\\n        // solium-disable-next-line security/no-block-members\\r\\n        return block.timestamp;\\r\\n    }\\r\\n}\\r\\n\"},\"UniswapV2OracleLibrary.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\nimport \\u0027./IUniswapV2Pair.sol\\u0027;\\r\\nimport \\u0027./FixedPoint.sol\\u0027;\\r\\n\\r\\n// library with helper methods for oracles that are concerned with computing average prices\\r\\nlibrary UniswapV2OracleLibrary {\\r\\n    using FixedPoint for *;\\r\\n\\r\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\r\\n    function currentBlockTimestamp() internal view returns (uint32) {\\r\\n        return uint32(block.timestamp % 2 ** 32);\\r\\n    }\\r\\n\\r\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\r\\n    function currentCumulativePrices(\\r\\n        address pair,\\r\\n        bool isToken0\\r\\n    ) internal view returns (uint priceCumulative, uint32 blockTimestamp) {\\r\\n        blockTimestamp = currentBlockTimestamp();\\r\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = UniswapPair(pair).getReserves();\\r\\n        if (isToken0) {\\r\\n          priceCumulative = UniswapPair(pair).price0CumulativeLast();\\r\\n\\r\\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\\r\\n          if (blockTimestampLast != blockTimestamp) {\\r\\n              // subtraction overflow is desired\\r\\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\r\\n              // addition overflow is desired\\r\\n              // counterfactual\\r\\n              priceCumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\r\\n          }\\r\\n        } else {\\r\\n          priceCumulative = UniswapPair(pair).price1CumulativeLast();\\r\\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\\r\\n          if (blockTimestampLast != blockTimestamp) {\\r\\n              // subtraction overflow is desired\\r\\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\r\\n              // addition overflow is desired\\r\\n              // counterfactual\\r\\n              priceCumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\r\\n          }\\r\\n        }\\r\\n\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserveToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pylonAddress_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"NewGov\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingGov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingGov\",\"type\":\"address\"}],\"name\":\"NewPendingGov\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRebaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRebaser\",\"type\":\"address\"}],\"name\":\"NewRebaser\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptGov\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingGov_\",\"type\":\"address\"}],\"name\":\"_setPendingGov\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"rebaser_\",\"type\":\"address\"}],\"name\":\"_setRebaser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReserve\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"migrateReserves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingGov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pylonAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PYLONReserves","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000df5e0e81dff6faf3a7e52ba697820c5e32d806a8000000000000000000000000d7b7d3c0bda57723fb54ab95fd8f9ea033af37f2","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://33c23f7bb930f1e4d94e453ea9f5768ed77406c46a9db2c38c18aaca4aef3898"}]}