{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./IACOToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ACOFactory\\r\\n * @dev The contract is the implementation for the ACOProxy.\\r\\n */\\r\\ncontract ACOFactory {\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the factory admin address has been changed.\\r\\n     * @param previousFactoryAdmin Address of the previous factory admin.\\r\\n     * @param newFactoryAdmin Address of the new factory admin.\\r\\n     */\\r\\n    event SetFactoryAdmin(address indexed previousFactoryAdmin, address indexed newFactoryAdmin);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the ACO token implementation has been changed.\\r\\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\\r\\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\\r\\n     */\\r\\n    event SetAcoTokenImplementation(address indexed previousAcoTokenImplementation, address indexed newAcoTokenImplementation);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the ACO fee has been changed.\\r\\n     * @param previousAcoFee Value of the previous ACO fee.\\r\\n     * @param newAcoFee Value of the new ACO fee.\\r\\n     */\\r\\n    event SetAcoFee(uint256 indexed previousAcoFee, uint256 indexed newAcoFee);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the ACO fee destination address has been changed.\\r\\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\\r\\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\\r\\n     */\\r\\n    event SetAcoFeeDestination(address indexed previousAcoFeeDestination, address indexed newAcoFeeDestination);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a new ACO token has been created.\\r\\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param isCall True if the type is CALL, false for PUT.\\r\\n     * @param strikePrice The strike price with the strike asset precision.\\r\\n     * @param expiryTime The UNIX time for the ACO token expiration.\\r\\n     * @param acoToken Address of the new ACO token created.\\r\\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\\r\\n     */\\r\\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\\r\\n    \\r\\n    /**\\r\\n     * @dev The ACO fee value. \\r\\n     * It is a percentage value (100000 is 100%).\\r\\n     */\\r\\n    uint256 public acoFee;\\r\\n    \\r\\n    /**\\r\\n     * @dev The factory admin address.\\r\\n     */\\r\\n    address public factoryAdmin;\\r\\n    \\r\\n    /**\\r\\n     * @dev The ACO token implementation address.\\r\\n     */\\r\\n    address public acoTokenImplementation;\\r\\n    \\r\\n    /**\\r\\n     * @dev The ACO fee destination address.\\r\\n     */\\r\\n    address public acoFeeDestination;\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\\r\\n     * Only factory admin address can execute.\\r\\n     */\\r\\n    modifier onlyFactoryAdmin() {\\r\\n        require(msg.sender == factoryAdmin, \\\"ACOFactory::onlyFactoryAdmin\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to initialize the contract.\\r\\n     * It should be called through the `data` argument when creating the proxy.\\r\\n     * It must be called only once. The `assert` is to guarantee that behavior.\\r\\n     * @param _factoryAdmin Address of the factory admin.\\r\\n     * @param _acoTokenImplementation Address of the ACO token implementation.\\r\\n     * @param _acoFee Value of the ACO fee.\\r\\n     * @param _acoFeeDestination Address of the ACO fee destination.\\r\\n     */\\r\\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\\r\\n        require(factoryAdmin == address(0) \\u0026\\u0026 acoTokenImplementation == address(0), \\\"ACOFactory::init: Contract already initialized.\\\");\\r\\n        \\r\\n        _setFactoryAdmin(_factoryAdmin);\\r\\n        _setAcoTokenImplementation(_acoTokenImplementation);\\r\\n        _setAcoFee(_acoFee);\\r\\n        _setAcoFeeDestination(_acoFeeDestination);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to guarantee that the contract will not receive ether.\\r\\n     */\\r\\n    receive() external payable virtual {\\r\\n        revert();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to create a new ACO token.\\r\\n     * It deploys a minimal proxy for the ACO token implementation address. \\r\\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param isCall Whether the ACO token is the Call type.\\r\\n     * @param strikePrice The strike price with the strike asset precision.\\r\\n     * @param expiryTime The UNIX time for the ACO token expiration.\\r\\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\\r\\n     */\\r\\n    function createAcoToken(\\r\\n        address underlying, \\r\\n        address strikeAsset, \\r\\n        bool isCall,\\r\\n        uint256 strikePrice, \\r\\n        uint256 expiryTime,\\r\\n        uint256 maxExercisedAccounts\\r\\n    ) onlyFactoryAdmin external virtual returns(address) {\\r\\n        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\\r\\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);\\r\\n        return acoToken;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the factory admin address.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newFactoryAdmin Address of the new factory admin.\\r\\n     */\\r\\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\\r\\n        _setFactoryAdmin(newFactoryAdmin);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the ACO token implementation address.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\\r\\n     */\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\\r\\n        _setAcoTokenImplementation(newAcoTokenImplementation);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the ACO fee.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\\r\\n     */\\r\\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\\r\\n        _setAcoFee(newAcoFee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the ACO destination address.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newAcoFeeDestination Address of the new ACO destination.\\r\\n     */\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\\r\\n        _setAcoFeeDestination(newAcoFeeDestination);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the factory admin address.\\r\\n     * @param newFactoryAdmin Address of the new factory admin.\\r\\n     */\\r\\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\\r\\n        require(newFactoryAdmin != address(0), \\\"ACOFactory::_setFactoryAdmin: Invalid factory admin\\\");\\r\\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\\r\\n        factoryAdmin = newFactoryAdmin;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the ACO token implementation address.\\r\\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\\r\\n     */\\r\\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\\r\\n        require(Address.isContract(newAcoTokenImplementation), \\\"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\\\");\\r\\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\\r\\n        acoTokenImplementation = newAcoTokenImplementation;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the ACO fee.\\r\\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\\r\\n     */\\r\\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\\r\\n        emit SetAcoFee(acoFee, newAcoFee);\\r\\n        acoFee = newAcoFee;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the ACO destination address.\\r\\n     * @param newAcoFeeDestination Address of the new ACO destination.\\r\\n     */\\r\\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\\r\\n        require(newAcoFeeDestination != address(0), \\\"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\\\");\\r\\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\\r\\n        acoFeeDestination = newAcoFeeDestination;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\\r\\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param isCall True if the type is CALL, false for PUT.\\r\\n     * @param strikePrice The strike price with the strike asset precision.\\r\\n     * @param expiryTime The UNIX time for the ACO token expiration.\\r\\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\\r\\n     * @return Address of the new minimal proxy deployed for the ACO token.\\r\\n     */\\r\\n    function _deployAcoToken(\\r\\n        address underlying, \\r\\n        address strikeAsset, \\r\\n        bool isCall,\\r\\n        uint256 strikePrice, \\r\\n        uint256 expiryTime,\\r\\n        uint256 maxExercisedAccounts\\r\\n    ) internal virtual returns(address) {\\r\\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\\r\\n        address proxy;\\r\\n        assembly {\\r\\n            let clone := mload(0x40)\\r\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\r\\n            mstore(add(clone, 0x14), implentationBytes)\\r\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\r\\n            proxy := create(0, clone, 0x37)\\r\\n        }\\r\\n        IACOToken(proxy).init(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoFee, payable(acoFeeDestination), maxExercisedAccounts);\\r\\n        return proxy;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ACOFactoryV2 is ACOFactory {\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Struct to store the ACO Token basic data.\\r\\n     */\\r\\n    struct ACOTokenData {\\r\\n        /**\\r\\n         * @dev Address of the underlying asset (0x0 for Ethereum).\\r\\n         */\\r\\n        address underlying;\\r\\n        \\r\\n        /**\\r\\n         * @dev Address of the strike asset (0x0 for Ethereum).\\r\\n         */\\r\\n        address strikeAsset;\\r\\n        \\r\\n        /**\\r\\n         * @dev True if the type is CALL, false for PUT.\\r\\n         */\\r\\n        bool isCall;\\r\\n        \\r\\n        /**\\r\\n         * @dev The strike price with the strike asset precision.\\r\\n         */\\r\\n        uint256 strikePrice;\\r\\n        \\r\\n        /**\\r\\n         * @dev The UNIX time for the ACO token expiration.\\r\\n         */\\r\\n        uint256 expiryTime;\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev The ACO token basic data.\\r\\n     */\\r\\n    mapping(address =\\u003e ACOTokenData) public acoTokenData;\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to create a new ACO token.\\r\\n     * It deploys a minimal proxy for the ACO token implementation address. \\r\\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param isCall Whether the ACO token is the Call type.\\r\\n     * @param strikePrice The strike price with the strike asset precision.\\r\\n     * @param expiryTime The UNIX time for the ACO token expiration.\\r\\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\\r\\n     * @return The created ACO token address.\\r\\n     */\\r\\n    function createAcoToken(\\r\\n        address underlying, \\r\\n        address strikeAsset, \\r\\n        bool isCall,\\r\\n        uint256 strikePrice, \\r\\n        uint256 expiryTime,\\r\\n        uint256 maxExercisedAccounts\\r\\n    ) onlyFactoryAdmin external override returns(address) {\\r\\n        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\\r\\n        acoTokenData[acoToken] = ACOTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime);\\r\\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);\\r\\n        return acoToken;\\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable returns(uint256);\\r\\n    function mintToPayable(address account) external payable returns(uint256);\\r\\n    function mint(uint256 collateralAmount) external returns(uint256);\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\\r\\n    function burn(uint256 tokenAmount) external returns(uint256);\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\\r\\n    function redeem() external returns(uint256);\\r\\n    function redeemFrom(address account) external returns(uint256);\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acoTokenImplementation\",\"type\":\"address\"}],\"name\":\"NewAcoToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousAcoFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAcoFee\",\"type\":\"uint256\"}],\"name\":\"SetAcoFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousAcoFeeDestination\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAcoFeeDestination\",\"type\":\"address\"}],\"name\":\"SetAcoFeeDestination\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousAcoTokenImplementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAcoTokenImplementation\",\"type\":\"address\"}],\"name\":\"SetAcoTokenImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousFactoryAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFactoryAdmin\",\"type\":\"address\"}],\"name\":\"SetFactoryAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acoFeeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"acoTokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acoTokenImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExercisedAccounts\",\"type\":\"uint256\"}],\"name\":\"createAcoToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factoryAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acoTokenImplementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_acoFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_acoFeeDestination\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAcoFee\",\"type\":\"uint256\"}],\"name\":\"setAcoFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAcoFeeDestination\",\"type\":\"address\"}],\"name\":\"setAcoFeeDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAcoTokenImplementation\",\"type\":\"address\"}],\"name\":\"setAcoTokenImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFactoryAdmin\",\"type\":\"address\"}],\"name\":\"setFactoryAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOFactoryV2","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b93871195a9b50e26f709c9bbbe64f0b0f612d05cb34544003d760b0fd12f682"}]}