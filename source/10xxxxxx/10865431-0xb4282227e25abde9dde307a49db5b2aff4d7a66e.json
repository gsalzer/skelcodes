{"status":"1","message":"OK","result":[{"SourceCode":"{\"Gateway.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ninterface IERC20Token {\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _value) external returns (bool);\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\r\\n    function approve(address _spender, uint256 _value) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IEscrow {\\r\\n    function transferToGateway(uint256 value, uint256 channelId) external returns(uint256 send);\\r\\n    function transferFromGateway(uint256 value, uint256 channelId) external;\\r\\n    function paymentFromGateway(uint256 channelId, address token, uint256 value, uint256 soldValue) external payable;\\r\\n}\\r\\n\\r\\ncontract SafeMath {\\r\\n    // Safe Math subtract function\\r\\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    // Safe Math add function\\r\\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ChannelContract is Ownable, SafeMath {\\r\\n    struct Wallet {\\r\\n        string name;\\r\\n        address wallet;\\r\\n        bool isBlocked;  // Block wallet transfer tokens to.\\r\\n    }\\r\\n\\r\\n    Wallet[] wallets;   // list of wallets where allowed to transfer (exchanges wallets, Bancor, etc).\\r\\n    uint256 public spent;   // Amount of token spend from channel (sent to Market, SmartSwap, etc.)\\r\\n    uint256 public received; // Amount of token received from Escrow\\r\\n\\r\\n    string public channelName;\\r\\n    IERC20Token public tokenContract;\\r\\n    address payable public escrowContract;\\r\\n\\r\\n    constructor(IERC20Token _tokenContract,  address payable _escrowContract, string memory _name) public {\\r\\n        tokenContract = _tokenContract;\\r\\n        escrowContract = _escrowContract;\\r\\n        channelName = _name;\\r\\n    }\\r\\n\\r\\n    event SetWallet(address indexed channel, uint256 walletId, address wallet, string name);\\r\\n    event BlockWallet(address indexed channel, uint256 walletId, bool isBlock);\\r\\n    event TransferTokens(address indexed channel, address indexed to, uint256 value, string walletName);\\r\\n    event ReceivedETH(address indexed from, uint256 value);\\r\\n\\r\\n    function totalSupply() public view returns(uint256) {\\r\\n        return safeSub(received, spent);\\r\\n    }\\r\\n\\r\\n    function addWallet(string memory name, address wallet) external onlyOwner {\\r\\n        require(wallet != address(0),\\\"Zero address\\\");\\r\\n        uint256 walletId = wallets.length;\\r\\n        wallets.push(Wallet(name, wallet, false));\\r\\n        emit SetWallet(address(this), walletId, wallet, name);\\r\\n    }\\r\\n\\r\\n    // if wallet is address(0) - wallet removed.\\r\\n    function updateWallet(uint256 walletId, address wallet) external onlyOwner {\\r\\n        wallets[walletId].wallet = wallet;\\r\\n        emit SetWallet(address(this), walletId, wallet, wallets[walletId].name);\\r\\n    }\\r\\n\\r\\n    // Block selected wallet transfer to.\\r\\n    function blockWallet(uint256 walletId, bool isBlock) external onlyOwner {\\r\\n        wallets[walletId].isBlocked = isBlock;\\r\\n        emit BlockWallet(address(this), walletId, isBlock);\\r\\n    }\\r\\n\\r\\n    function getWalletsNumber() external view returns(uint256) {\\r\\n        return wallets.length;\\r\\n    }\\r\\n\\r\\n    function getWalletInfo(uint256 walletId) external view returns(string memory name, address wallet, bool isBlocked) {\\r\\n        name = wallets[walletId].name;\\r\\n        wallet = wallets[walletId].wallet;\\r\\n        isBlocked = wallets[walletId].isBlocked;\\r\\n    }\\r\\n\\r\\n    // Receive tokens from Escrow (gateway)\\r\\n    function receiveTokens(uint256 value) external onlyOwner {\\r\\n        received = safeAdd(received, value);\\r\\n    }\\r\\n\\r\\n    // transfer tokens to selected wallet (ex. Exchange wallet)\\r\\n    function transferTokens(uint256 walletId, uint256 value) external onlyOwner {\\r\\n        require(totalSupply() \\u003e= value, \\\"Not enough tokens\\\");\\r\\n        address to = wallets[walletId].wallet;\\r\\n        require(to != address(0), \\\"Wallet removed\\\");\\r\\n        spent = safeAdd(spent, value); \\r\\n        tokenContract.transfer(to, value);\\r\\n        emit TransferTokens(address(this), to, value, wallets[walletId].name);\\r\\n    }\\r\\n\\r\\n\\r\\n    // transfer tokens to selected wallet (ex. Exchange wallet)\\r\\n    function approveTokens(uint256 walletId, uint256 value) external onlyOwner {\\r\\n        require(totalSupply() \\u003e= value, \\\"Not enough tokens\\\");\\r\\n        address to = wallets[walletId].wallet;\\r\\n        require(to != address(0), \\\"Wallet removed\\\");\\r\\n        spent = safeAdd(spent, value); \\r\\n        tokenContract.approve(to, value);\\r\\n        emit TransferTokens(address(this), to, value, wallets[walletId].name);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Trigger arbitrary function on selected wallet address.\\r\\n     * @param walletId The wallet to call\\r\\n     * @param params encoded params\\r\\n     */\\r\\n    function trigger(uint256 walletId, bytes calldata params) external onlyOwner {\\r\\n        address to = wallets[walletId].wallet;\\r\\n        to.call(params);\\r\\n    }\\r\\n\\r\\n    // Gateway transfer token to Escrow\\r\\n    function returnToEscrow(uint256 value) external onlyOwner {\\r\\n        require(totalSupply() \\u003e= value, \\\"Not enough tokens\\\");\\r\\n        received = safeSub(received, value);\\r\\n        tokenContract.transfer(escrowContract, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Send giveaways (received ETH/ERC20) to Escrow for splitting among participants.\\r\\n     * When token sold on exchange, withdraw ETH/ERC20 to this contract address.\\r\\n     * @param soldTokenAmount amount of sold tokens\\r\\n     * @param receivedToken The ERC20 token address (or 0 for ETH) for which tokens were sold.\\r\\n     * @param receivedAmount Amount of ETH/ERC20 received for sold tokens.\\r\\n     */\\r\\n    function transferGiveaways(uint256 soldTokenAmount, address receivedToken, uint256 receivedAmount) external onlyOwner {\\r\\n        require(spent \\u003e= soldTokenAmount, \\\"Wrong Sold Token Amount\\\");\\r\\n        if (receivedToken == address(0)) {\\r\\n            escrowContract.transfer(receivedAmount);\\r\\n        }\\r\\n        else {\\r\\n            IERC20Token(receivedToken).transfer(escrowContract, receivedAmount);\\r\\n        }\\r\\n        spent = safeSub(spent, soldTokenAmount);\\r\\n        received = safeSub(received, soldTokenAmount);\\r\\n    }\\r\\n\\r\\n    // accept ETH\\r\\n    receive() external payable {\\r\\n        emit ReceivedETH(msg.sender, msg.value);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Gateway is Ownable, SafeMath {\\r\\n    IERC20Token public tokenContract;\\r\\n    IEscrow public escrowContract;\\r\\n    address public admin;\\r\\n    address public jointerVoting;   //Jointer voting contract can block specific Channel or Wallet\\r\\n\\r\\n    struct Channel {\\r\\n        string name;    // name of channel\\r\\n        bool isBlocked;  // Block entire channel to transfer tokens to any wallets.\\r\\n        ChannelContract channel;    // address of ChannelContract\\r\\n    }\\r\\n\\r\\n    Channel[] channels;     // list of liquidity channels\\r\\n\\r\\n    event AddChannel(uint256 indexed channelId, address indexed channelAddress, string name);\\r\\n    event BlockChannel(uint256 indexed channelId, bool isBlock);\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the admin.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(admin == msg.sender,\\\"Not admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set token contract address.\\r\\n     * @param token The address of token contract.\\r\\n     */\\r\\n    function setTokenContract(IERC20Token token) external onlyOwner {\\r\\n        require(token != IERC20Token(0) \\u0026\\u0026 tokenContract == IERC20Token(0),\\\"Change address not allowed\\\");\\r\\n        tokenContract = token;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set escrow contract address\\r\\n     * @param escrow The address of escrow contract.\\r\\n     */\\r\\n    function setEscrowContract(address payable escrow) external onlyOwner {\\r\\n        require(escrow != address(0),\\\"Zero address\\\");\\r\\n        escrowContract = IEscrow(escrow);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set Jointer Voting (Escrowed) contract address\\r\\n     * @param newAddress The address of escrow contract.\\r\\n     */\\r\\n    function setJointerVotingContract(address payable newAddress) external onlyOwner {\\r\\n        require(newAddress != address(0),\\\"Zero address\\\");\\r\\n        jointerVoting = newAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set gateway admin address\\r\\n     * @param _admin The address of gateway admin wallet.\\r\\n     */\\r\\n    function setAdmin(address _admin) external onlyOwner {\\r\\n        require(_admin != address(0),\\\"Zero address\\\");\\r\\n        admin = _admin;\\r\\n    }\\r\\n\\r\\n    // Add new Liquidity channel\\r\\n    function addChannel(string memory name) external onlyOwner {\\r\\n        uint256 channelId = channels.length;\\r\\n        require(channelId \\u003c 251, \\\"Channels limit reached\\\");\\r\\n        channels.push();\\r\\n        channels[channelId].name = name;\\r\\n        channels[channelId].channel = new ChannelContract(tokenContract, payable(address(escrowContract)), name);\\r\\n        emit AddChannel(channelId, address(channels[channelId].channel), name);\\r\\n    }\\r\\n\\r\\n    function getChannelsNumber() external view returns(uint256) {\\r\\n        return channels.length;\\r\\n    }\\r\\n\\r\\n    // Get details of channel\\r\\n    function getChannelInfo(uint256 channelId) external view \\r\\n        returns(\\r\\n            string memory name,\\r\\n            address channelAddress,\\r\\n            bool isBlocked,\\r\\n            uint256 amount,\\r\\n            uint256 spent,\\r\\n            uint256 walletsNumber\\r\\n        ) \\r\\n    {\\r\\n        name = channels[channelId].name;\\r\\n        channelAddress = address(channels[channelId].channel);\\r\\n        isBlocked = channels[channelId].isBlocked;\\r\\n        amount = channels[channelId].channel.received();\\r\\n        spent = channels[channelId].channel.spent();\\r\\n        walletsNumber = channels[channelId].channel.getWalletsNumber();\\r\\n    }\\r\\n\\r\\n    // Add new wallet to selected liquidity channel\\r\\n    function addWallet(uint256 channelId, string memory name, address payable wallet) external onlyOwner {\\r\\n        require(wallet != address(0),\\\"Zero address\\\");\\r\\n        channels[channelId].channel.addWallet(name, wallet);\\r\\n    }\\r\\n\\r\\n    // Update wallet address on selected liquidity channel. If wallet is address(0) - wallet removed.\\r\\n    function updateWallet(uint256 channelId, uint256 walletId, address payable wallet) external onlyOwner {\\r\\n        channels[channelId].channel.updateWallet(walletId, wallet);\\r\\n    }\\r\\n\\r\\n    // In case updating gateway contract, we can change Channel Ownership to the new Gateway contract\\r\\n    function transferChannelOwnership(uint256 channelId, address newOwner) external onlyOwner {\\r\\n        channels[channelId].channel.transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    // Transfer token to gateway from selected channel\\r\\n    function transferToGateway(uint256 value, uint256 channelId) external onlyAdmin {\\r\\n        uint256 approved = escrowContract.transferToGateway(value, channelId);  // amount of approved tokens\\r\\n        ChannelContract channel = channels[channelId].channel;\\r\\n        require(tokenContract.transferFrom(address(escrowContract), address(channel), approved),\\\"Transfer to Gateway channel Failed\\\");\\r\\n        channel.receiveTokens(approved);\\r\\n    }\\r\\n\\r\\n    // Gateway transfer token to Escrow from Channel\\r\\n    function transferFromGateway(uint256 value, uint256 channelId) external onlyAdmin {\\r\\n        channels[channelId].channel.returnToEscrow(value);\\r\\n        escrowContract.transferFromGateway(value, channelId);\\r\\n    }\\r\\n\\r\\n    // Block selected wallet transfer to.\\r\\n    function blockWallet(uint256 channelId, uint256 walletId, bool isBlock) external {\\r\\n        require(msg.sender == jointerVoting, \\\"Only JNTR voting allowed\\\");\\r\\n        channels[channelId].channel.blockWallet(walletId, isBlock);\\r\\n    }\\r\\n\\r\\n    // Block selected channel transfer to any wallet.\\r\\n    function blockChannel(uint256 channelId, bool isBlock) external {\\r\\n        require(msg.sender == jointerVoting, \\\"Only JNTR voting allowed\\\");\\r\\n        channels[channelId].isBlocked = isBlock;\\r\\n        emit BlockChannel(channelId, isBlock);\\r\\n    }\\r\\n\\r\\n    // transfer tokens from Channel to selected wallet (ex. Exchange wallet)\\r\\n    function transferTokens(uint256 channelId, uint256 walletId, uint256 value) external onlyAdmin {\\r\\n        channels[channelId].channel.transferTokens(walletId, value);\\r\\n    }\\r\\n\\r\\n    // approve tokens from Channel to selected wallet (ex. Exchange wallet)\\r\\n    function approveTokens(uint256 channelId, uint256 walletId, uint256 value) external onlyAdmin {\\r\\n        channels[channelId].channel.approveTokens(walletId, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Trigger arbitrary function on selected wallet address.\\r\\n     * @param channelId The channel which have to call\\r\\n     * @param walletId The wallet to call\\r\\n     * @param params encoded params\\r\\n     */\\r\\n    function trigger(uint256 channelId, uint256 walletId, bytes calldata params) external onlyAdmin {\\r\\n        channels[channelId].channel.trigger(walletId, params);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Send giveaways (received ETH/ERC20) to Escrow for splitting among participants.\\r\\n     * When token sold on exchange, withdraw ETH/ERC20 to this contract address.\\r\\n     * @param channelId Liquidity channel ID which sold tokens.\\r\\n     * @param soldTokenAmount amount of sold tokens\\r\\n     * @param receivedToken The ERC20 token address (or 0 for ETH) for which tokens were sold.\\r\\n     * @param receivedAmount Amount of ETH/ERC20 received for sold tokens.\\r\\n     */\\r\\n    function transferGiveaways(uint256 channelId, uint256 soldTokenAmount, address receivedToken, uint256 receivedAmount) external onlyAdmin {\\r\\n        channels[channelId].channel.transferGiveaways(soldTokenAmount, receivedToken, receivedAmount);\\r\\n        escrowContract.paymentFromGateway(channelId, receivedToken, receivedAmount, soldTokenAmount);\\r\\n    }\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n *\\r\\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\\r\\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\\r\\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\\r\\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the address of the owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(),\\\"Not Owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return true if `msg.sender` is the owner of the contract.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to relinquish control of the contract.\\r\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\r\\n     * It will not be possible to call the functions with the `onlyOwner`\\r\\n     * modifier anymore.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0),\\\"Zero address not allowed\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_escrowContract\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBlock\",\"type\":\"bool\"}],\"name\":\"BlockWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"SetWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"walletName\",\"type\":\"string\"}],\"name\":\"TransferTokens\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"addWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBlock\",\"type\":\"bool\"}],\"name\":\"blockWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"channelName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escrowContract\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"}],\"name\":\"getWalletInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBlocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWalletsNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"receiveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"received\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"returnToEscrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"soldTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receivedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"}],\"name\":\"transferGiveaways\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"trigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walletId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"updateWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ChannelContract","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cd899e343a192ac3ce6530ce0ed9009275a2c701000000000000000000000000352e2708ac8f671a2fe46e244d8255dcd17d7d350000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000d536d617274537761702050324300000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d1d47afdc4d44677863e27d9ab28edd014865143d6742d2f1a655ef2770d1281"}]}