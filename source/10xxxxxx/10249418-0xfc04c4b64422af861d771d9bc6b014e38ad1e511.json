{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract InternalModule {\r\n\r\n    address[] _authAddress;\r\n\r\n    address payable public _defaultReciver = address(0x2E5600376D4F07F13Ea69Caf416FB2F7B6659897);\r\n\r\n    address payable[] public _contractOwners = [\r\n        address(0xc99D13544297d5baD9e0b0Ca0E94A4E614312F33)\r\n    ];\r\n\r\n    constructor() public {\r\n        _contractOwners.push(msg.sender);\r\n    }\r\n\r\n    modifier OwnerOnly() {\r\n\r\n        bool exist = false;\r\n        for ( uint i = 0; i < _contractOwners.length; i++ ) {\r\n            if ( _contractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    modifier DAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"DAO_Warning\" );\r\n        _;\r\n    }\r\n\r\n    modifier APIMethod() {\r\n\r\n        bool exist = false;\r\n\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if ( _authAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function AuthAddresses() external view returns (address[] memory authAddr) {\r\n        return _authAddress;\r\n    }\r\n\r\n    function AddAuthAddress(address _addr) external OwnerOnly {\r\n        _authAddress.push(_addr);\r\n    }\r\n\r\n    function DelAuthAddress(address _addr) external OwnerOnly {\r\n\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if (_authAddress[i] == _addr) {\r\n                for (uint j = 0; j < _authAddress.length - 1; j++) {\r\n                    _authAddress[j] = _authAddress[j+1];\r\n                }\r\n                delete _authAddress[_authAddress.length - 1];\r\n                _authAddress.length--;\r\n                return ;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\ncontract KState {\r\n\r\n    address private _KDeveloper;\r\n    address internal _KIMPLAddress;\r\n\r\n    address[] _KAuthAddress;\r\n\r\n    address payable public _KDefaultReciver = address(0x2E5600376D4F07F13Ea69Caf416FB2F7B6659897);\r\n\r\n    address payable[] public _KContractOwners = [\r\n        address(0xc99D13544297d5baD9e0b0Ca0E94A4E614312F33)\r\n    ];\r\n\r\n    bool public _KContractBroken;\r\n    mapping (address => bool) _KWithdrawabledAddress;\r\n\r\n    constructor() public {\r\n        _KDeveloper = msg.sender;\r\n        _KContractOwners.push(msg.sender);\r\n    }\r\n\r\n    modifier KWhenBroken() {\r\n        require(_KContractBroken); _;\r\n    }\r\n\r\n    modifier KWhenNotBroken() {\r\n        require(!_KContractBroken); _;\r\n    }\r\n\r\n    modifier KOwnerOnly() {\r\n\r\n        bool exist = false;\r\n\r\n        for ( uint i = 0; i < _KContractOwners.length; i++ ) {\r\n            if ( _KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KSetContractBroken(bool broken) external KOwnerOnly {\r\n        _KContractBroken = broken;\r\n    }\r\n\r\n    modifier KDAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"DAO_Warning\" );\r\n        _;\r\n    }\r\n\r\n    modifier KAPIMethod() {\r\n\r\n        bool exist = false;\r\n\r\n        for (uint i = 0; i < _KAuthAddress.length; i++) {\r\n            if ( _KAuthAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KAuthAddresses() external view returns (address[] memory authAddr) {\r\n        return _KAuthAddress;\r\n    }\r\n\r\n    function KAddAuthAddress(address _addr) external KOwnerOnly {\r\n        _KAuthAddress.push(_addr);\r\n    }\r\n\r\n    modifier KDeveloperOnly {\r\n        require(msg.sender == _KDeveloper); _;\r\n    }\r\n\r\n    function KSetImplAddress(address impl) external KDeveloperOnly {\r\n        _KIMPLAddress = impl;\r\n    }\r\n\r\n    function KGetImplAddress() external view KDeveloperOnly returns (address) {\r\n        return _KIMPLAddress;\r\n    }\r\n\r\n}\r\n\r\ncontract KDoctor is KState {\r\n    modifier write {_;}\r\n}\r\n\r\ncontract KContract is KState {\r\n\r\n    modifier write {\r\n\r\n        if ( _KIMPLAddress != address(0x0) ) {\r\n\r\n            (, bytes memory ret) = address(_KIMPLAddress).delegatecall(msg.data);\r\n\r\n            assembly {\r\n                return( add(ret, 0x20), mload(ret) )\r\n            }\r\n\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary UserRelation {\r\n\r\n    struct MainDB {\r\n\r\n        uint totalAddresses;\r\n\r\n        mapping ( address => address ) _recommerMapping;\r\n\r\n        mapping ( address => address[] ) _recommerList;\r\n\r\n        mapping ( address => uint256 ) _recommerCountMapping;\r\n\r\n        mapping ( bytes6 => address ) _shortCodeMapping;\r\n\r\n        mapping ( address => bytes6 ) _addressShotCodeMapping;\r\n    }\r\n\r\n    function Init(MainDB storage self) internal {\r\n\r\n        address rootAddr = address(0xdead);\r\n        bytes6 rootCode = 0x303030303030;\r\n\r\n\r\n        self._recommerMapping[rootAddr] = address(0xdeaddead);\r\n        self._shortCodeMapping[rootCode] = rootAddr;\r\n        self._addressShotCodeMapping[rootAddr] = rootCode;\r\n    }\r\n\r\n\r\n    function GetIntroducer( MainDB storage self, address _owner ) internal view returns (address) {\r\n        return self._recommerMapping[_owner];\r\n    }\r\n\r\n\r\n    function RecommendList( MainDB storage self, address _owner ) internal view returns ( address[] memory list, uint256 len ) {\r\n        return (self._recommerList[_owner], self._recommerList[_owner].length );\r\n    }\r\n\r\n\r\n    function RegisterShortCode( MainDB storage self, address _owner, bytes6 shortCode ) internal returns (bool) {\r\n\r\n\r\n        if ( self._shortCodeMapping[shortCode] != address(0x0) ) {\r\n            return false;\r\n        }\r\n\r\n\r\n        if ( self._addressShotCodeMapping[_owner] != bytes6(0x0) ) {\r\n            return false;\r\n        }\r\n\r\n\r\n        self._shortCodeMapping[shortCode] = _owner;\r\n        self._addressShotCodeMapping[_owner] = shortCode;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function ShortCodeToAddress( MainDB storage self, bytes6 shortCode ) internal view returns (address) {\r\n        return self._shortCodeMapping[shortCode];\r\n    }\r\n\r\n\r\n    function AddressToShortCode( MainDB storage self, address addr ) internal view returns (bytes6) {\r\n        return self._addressShotCodeMapping[addr];\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function AddRelation( MainDB storage self, address owner, address recommer ) internal returns (int) {\r\n\r\n\r\n        if ( recommer == owner )  {\r\n            require(false, \"-1\");\r\n            return -1;\r\n        }\r\n\r\n\r\n        require( recommer != owner, \"-1\" );\r\n\r\n\r\n        require( self._recommerMapping[owner] == address(0x0), \"-2\");\r\n\r\n\r\n        if ( recommer != address(0xdead) ) {\r\n            require( self._recommerMapping[recommer] != address(0x0), \"-3\");\r\n        }\r\n\r\n\r\n        self._recommerMapping[owner] = recommer;\r\n\r\n        self._recommerList[recommer].push(owner);\r\n\r\n        self._recommerCountMapping[recommer] ++;\r\n\r\n        self.totalAddresses++;\r\n\r\n        return 0;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function AddRelationEx( MainDB storage self, address owner, address recommer, bytes6 regShoutCode ) internal returns (int) {\r\n\r\n        if ( !RegisterShortCode(self, owner, regShoutCode) ) {\r\n            return -4;\r\n        }\r\n\r\n        return AddRelation(self, owner, recommer);\r\n    }\r\n\r\n\r\n    function TeamMemberTotal( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._recommerCountMapping[_addr];\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\n\r\nlibrary Achievement {\r\n\r\n    using UserRelation for UserRelation.MainDB;\r\n\r\n    struct MainDB {\r\n\r\n\r\n\r\n        uint latestVersion;\r\n\r\n\r\n        uint currVersion;\r\n\r\n\r\n        mapping(uint => mapping(address => uint) ) achievementMapping;\r\n\r\n\r\n        mapping ( address => uint256 ) _vaildMemberCountMapping;\r\n\r\n\r\n        mapping ( address => bool ) _vaildMembersMapping;\r\n\r\n\r\n        mapping ( address => uint256 ) _despositTotalMapping;\r\n    }\r\n\r\n\r\n    function AppendAchievement( MainDB storage self, UserRelation.MainDB storage userRelation, address owner, uint value )\r\n    internal {\r\n\r\n        require(value > 0, \"ValueIsZero\");\r\n\r\n        for (\r\n            address parent = owner;\r\n            parent != address(0x0) && parent != address(0xdead);\r\n            parent = userRelation.GetIntroducer(parent)\r\n        ) {\r\n            self.achievementMapping[self.currVersion][parent] += value;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function DivestmentAchievement( MainDB storage self, UserRelation.MainDB storage userRelation, address owner, uint value)\r\n    internal {\r\n\r\n        for (\r\n            address parent = owner;\r\n            parent != address(0x0) && parent != address(0xdaed);\r\n            parent = userRelation.GetIntroducer(parent)\r\n        ) {\r\n            if ( self.achievementMapping[self.currVersion][parent] < value ) {\r\n                self.achievementMapping[self.currVersion][parent] = 0;\r\n            } else {\r\n                self.achievementMapping[self.currVersion][parent] -= value;\r\n            }\r\n        }\r\n    }\r\n\r\n    function AchievementValueOfOwner( MainDB storage self, address owner )\r\n    internal view\r\n    returns (uint) {\r\n        return self.achievementMapping[self.currVersion][owner];\r\n    }\r\n\r\n\r\n    function AchievementDistribution( MainDB storage self, UserRelation.MainDB storage userRelation, address owner)\r\n    internal view\r\n    returns (\r\n\r\n        uint totalSum,\r\n\r\n        uint large,\r\n\r\n        uint len,\r\n\r\n        address[] memory addrs,\r\n\r\n        uint[] memory values\r\n    ) {\r\n        totalSum = self.achievementMapping[self.currVersion][owner];\r\n\r\n\r\n        (addrs, len) = userRelation.RecommendList(owner);\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            values[i] = self.achievementMapping[self.currVersion][addrs[i]];\r\n\r\n            if ( self.achievementMapping[self.currVersion][addrs[i]] > large ) {\r\n                large = self.achievementMapping[self.currVersion][addrs[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function AchievementDynamicValue( MainDB storage self, UserRelation.MainDB storage userRelation, address owner)\r\n    internal view\r\n    returns (\r\n        uint v\r\n    ) {\r\n\r\n        uint large;\r\n        uint largeId;\r\n        (address[] memory addrs, uint len) = userRelation.RecommendList(owner);\r\n        uint[] memory values = new uint[](len);\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            values[i] = self.achievementMapping[self.currVersion][addrs[i]];\r\n\r\n            if ( self.achievementMapping[self.currVersion][addrs[i]] > large ) {\r\n                large = self.achievementMapping[self.currVersion][addrs[i]];\r\n                largeId = i;\r\n            }\r\n        }\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            if ( i != largeId ) {\r\n\r\n                if ( values[i] > 10000 ether ) {\r\n\r\n                    v += ((values[i]) / 1 ether) + 90000;\r\n\r\n                } else {\r\n\r\n                    v += (values[i] / 1 ether) * 10;\r\n                }\r\n\r\n            } else {\r\n\r\n\r\n                v += (values[i] / 1 ether) / 1000;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function ValidMembersCountOf( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._vaildMemberCountMapping[_addr];\r\n    }\r\n\r\n    function InvestTotalEtherOf( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._despositTotalMapping[_addr];\r\n    }\r\n\r\n    function DirectValidMembersCount( MainDB storage self, UserRelation.MainDB storage userRelation, address _addr ) internal view returns (uint256) {\r\n\r\n        uint256 count = 0;\r\n        address[] storage rlist = userRelation._recommerList[_addr];\r\n        for ( uint i = 0; i < rlist.length; i++ ) {\r\n            if ( self._vaildMembersMapping[rlist[i]] ) {\r\n                count ++;\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n\r\n    function IsValidMember( MainDB storage self, address _addr ) internal view returns (bool) {\r\n        return self._vaildMembersMapping[_addr];\r\n    }\r\n\r\n    function MarkValidAddress( MainDB storage self, UserRelation.MainDB storage userRelation, address _addr, uint256 _evalue ) external {\r\n\r\n        if ( self._vaildMembersMapping[_addr] == false ) {\r\n\r\n\r\n\r\n            address parent = userRelation._recommerMapping[_addr];\r\n\r\n            for ( uint i = 0; i < 15; i++ ) {\r\n\r\n                self._vaildMemberCountMapping[parent] ++;\r\n\r\n                parent = userRelation._recommerMapping[parent];\r\n\r\n                if ( parent == address(0x0) ) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            self._vaildMembersMapping[_addr] = true;\r\n        }\r\n\r\n\r\n        self._despositTotalMapping[_addr] += _evalue;\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.1 <0.6.0;\r\n\r\n\r\n\r\ncontract Recommend is KContract {\r\n\r\n    UserRelation.MainDB _userRelation;\r\n    using UserRelation for UserRelation.MainDB;\r\n\r\n    constructor() public {\r\n        _userRelation.Init();\r\n    }\r\n\r\n    function GetIntroducer( address _owner ) external view returns (address) {\r\n        return _userRelation.GetIntroducer(_owner);\r\n    }\r\n\r\n    function RecommendList( address _owner) external view returns ( address[] memory list, uint256 len ) {\r\n        return _userRelation.RecommendList(_owner);\r\n    }\r\n\r\n    function ShortCodeToAddress( bytes6 shortCode ) external view returns (address) {\r\n        return _userRelation.ShortCodeToAddress(shortCode);\r\n    }\r\n\r\n    function AddressToShortCode( address _addr ) external view returns (bytes6) {\r\n        return _userRelation.AddressToShortCode(_addr);\r\n    }\r\n\r\n    function TeamMemberTotal( address _addr ) external view returns (uint256) {\r\n        return _userRelation.TeamMemberTotal(_addr);\r\n    }\r\n\r\n    function RegisterShortCode( bytes6 shortCode ) external write {\r\n        require(_userRelation.RegisterShortCode(msg.sender, shortCode));\r\n    }\r\n\r\n    function BindRelation( address _recommer ) external write {\r\n        require( _userRelation.AddRelation(msg.sender, _recommer) >= 0, \"-1\" );\r\n    }\r\n\r\n    function BindRelationEx( address _recommer, bytes6 shortCode ) external write{\r\n        require( _userRelation.AddRelationEx(msg.sender, _recommer, shortCode) >= 0, \"-1\" );\r\n    }\r\n\r\n    function AddressesCount() external view returns (uint) {\r\n        return _userRelation.totalAddresses;\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.1 <0.6.0;\r\n\r\n\r\n\r\n\r\ncontract RecommendSmallTeam is Recommend {\r\n\r\n    Achievement.MainDB _achievementer;\r\n    using Achievement for Achievement.MainDB;\r\n\r\n\r\n    function API_AppendAchievement( address owner, uint value )\r\n    external write KAPIMethod {\r\n        _achievementer.AppendAchievement( _userRelation, owner, value );\r\n    }\r\n\r\n\r\n    function API_DivestmentAchievement( address owner, uint value)\r\n    external write KAPIMethod {\r\n        _achievementer.DivestmentAchievement( _userRelation, owner, value );\r\n    }\r\n\r\n\r\n    function AchievementValueOf( address owner )\r\n    external view\r\n    returns (uint) {\r\n        return _achievementer.AchievementValueOfOwner(owner);\r\n    }\r\n\r\n\r\n    function AchievementDistributionOf( address owner)\r\n    external view\r\n    returns (\r\n\r\n        uint totalSum,\r\n\r\n        uint large,\r\n\r\n        uint len,\r\n\r\n        address[] memory addrs,\r\n\r\n        uint[] memory values\r\n    ) {\r\n        return _achievementer.AchievementDistribution(_userRelation, owner );\r\n    }\r\n\r\n\r\n    function AchievementDynamicValue( address owner)\r\n    external view\r\n    returns ( uint ) {\r\n        return _achievementer.AchievementDynamicValue(_userRelation, owner);\r\n    }\r\n\r\n\r\n    function ValidMembersCountOf( address _addr ) external view returns (uint256) {\r\n        return _achievementer.ValidMembersCountOf(_addr);\r\n    }\r\n\r\n    function InvestTotalEtherOf( address _addr ) external view returns (uint256) {\r\n        return _achievementer.InvestTotalEtherOf(_addr);\r\n    }\r\n\r\n    function DirectValidMembersCount( address _addr ) external view returns (uint256) {\r\n        return _achievementer.DirectValidMembersCount(_userRelation, _addr);\r\n    }\r\n\r\n\r\n    function IsValidMember( address _addr ) external view returns (bool) {\r\n        return _achievementer.IsValidMember(_addr);\r\n    }\r\n\r\n    function TotalAddresses() external view returns (uint) {\r\n        return _userRelation.totalAddresses;\r\n    }\r\n\r\n\r\n    function API_MarkValid( address _addr, uint256 _evalue ) external KAPIMethod {\r\n        return _achievementer.MarkValidAddress(_userRelation, _addr, _evalue);\r\n    }\r\n\r\n\r\n    function Developer_VersionInfo() external view returns (uint latest, uint curr) {\r\n        return (_achievementer.latestVersion, _achievementer.currVersion);\r\n    }\r\n\r\n    function Developer_PushNewDataVersion() external write KDeveloperOnly {\r\n        _achievementer.latestVersion++;\r\n    }\r\n\r\n    function Developer_SetDataVersion(uint v) external write KDeveloperOnly {\r\n        _achievementer.currVersion = v;\r\n    }\r\n\r\n    function Developer_WriteRelation( address _parent, address[] calldata _children, bytes6[] calldata _shortCode, bool force ) external write KDeveloperOnly {\r\n\r\n        for ( uint i = 0; i < _children.length; i++ ) {\r\n\r\n\r\n            _userRelation._recommerMapping[_children[i]] = _parent;\r\n\r\n\r\n            _userRelation._shortCodeMapping[_shortCode[i]] = _children[i];\r\n            _userRelation._addressShotCodeMapping[_children[i]] = _shortCode[i];\r\n        }\r\n\r\n        if ( force ) {\r\n\r\n\r\n            for ( uint i = 0; i < _children.length; i++ ) {\r\n                _userRelation._recommerList[_parent].push(_children[i]);\r\n            }\r\n\r\n\r\n            _userRelation._recommerCountMapping[_parent] += _children.length;\r\n\r\n        } else {\r\n\r\n\r\n            _userRelation._recommerList[_parent] = _children;\r\n\r\n\r\n            _userRelation._recommerCountMapping[_parent] = _children.length;\r\n        }\r\n\r\n\r\n        _userRelation.totalAddresses += _children.length;\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract TuringInterface\r\n{\r\n    function CallOnlyOnceInit( address roundAddress ) external;\r\n\r\n\r\n    function GetProfitPropBytime(uint256 time) external view returns (uint256);\r\n\r\n\r\n    function GetCurrentWithrawThreshold() external view returns (uint256);\r\n\r\n\r\n    function GetDepositedLimitMaxCurrent() external view returns (uint256);\r\n\r\n\r\n    function GetDepositedLimitCurrentDelta() external view returns (uint256);\r\n\r\n\r\n    function Analysis() external;\r\n\r\n\r\n    function API_SubDepositedLimitCurrent(uint256 v) external;\r\n\r\n\r\n    function API_PowerOn() external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface CostInterface {\r\n\r\n\r\n    function CurrentCostProp() external view returns (uint);\r\n\r\n\r\n    function WithdrawCost(uint value) external view returns (uint);\r\n    function DepositedCost(uint value) external view returns (uint);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract ERC20Interface\r\n{\r\n    uint256 public totalSupply;\r\n    string  public name;\r\n    uint8   public decimals;\r\n    string  public symbol;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\r\n    function API_MoveToken(address _from, address _to, uint256 _value) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface LevelSubInterface {\r\n\r\n\r\n    function LevelOf( address _owner ) external view returns (uint256 lv);\r\n\r\n\r\n    function CanUpgradeLv( address _rootAddr ) external view returns (int);\r\n\r\n\r\n    function DoUpgradeLv( ) external returns (uint256);\r\n\r\n\r\n    function ProfitHandle( address _owner, uint256 _amount ) external view returns ( uint256 len, address[] memory addrs, uint256[] memory profits );\r\n\r\n    function PaymentToUpgradeNoder() external payable;\r\n\r\n    function ManagerListOfLevel( uint256 lv ) external view returns (address[] memory addrs);\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface LuckAssetsPoolInterface {\r\n\r\n\r\n    function RewardsAmount() external view returns (uint256);\r\n\r\n\r\n    function WithdrawRewards() external returns (uint256);\r\n\r\n    function InPoolProp() external view returns (uint256);\r\n\r\n\r\n    function API_AddLatestAddress( address owner, uint256 amount ) external returns (bool openable);\r\n\r\n\r\n    function NeedPauseGame() external view returns (bool);\r\n    function API_Reboot() external returns (bool);\r\n\r\n\r\n    function API_GameOver() external returns (bool);\r\n    function API_Clear( address owner ) external;\r\n\r\n    event Log_Winner( address owner, uint256 when, uint256 amount);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface StatisticsInterface {\r\n\r\n\r\n    function GetStaticProfitTotalAmount() external view returns (uint256);\r\n\r\n\r\n    function GetDynamicProfitTotalAmount() external view returns (uint256);\r\n\r\n    function API_AddStaticTotalAmount( address player, uint256 value ) external;\r\n\r\n    function API_AddDynamicTotalAmount( address player, uint256 value ) external;\r\n\r\n    function API_AddWinnerCount() external;\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\nlibrary lib_math {\r\n\r\n    function CurrentDayzeroTime() public view returns (uint256) {\r\n        return (now / OneDay()) * OneDay();\r\n    }\r\n\r\n    function ConvertTimeToDay(uint256 t) public pure returns (uint256) {\r\n        return (t / OneDay()) * OneDay();\r\n    }\r\n\r\n    function OneDay() public pure returns (uint256) {\r\n\r\n        return 1 days;\r\n    }\r\n\r\n    function OneHours() public pure returns (uint256) {\r\n        return 1 hours;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary DepositedHistory {\r\n\r\n    struct DB {\r\n\r\n        uint256 currentDepostiTotalAmount;\r\n\r\n        mapping (address => DepositedRecord) map;\r\n\r\n        mapping (address => EverIn[]) amountInputs;\r\n\r\n        mapping (address => Statistics) totalMap;\r\n    }\r\n\r\n    struct Statistics {\r\n        bool isExist;\r\n        uint256 totalIn;\r\n        uint256 totalOut;\r\n    }\r\n\r\n    struct EverIn {\r\n        uint256 timeOfDayZero;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct DepositedRecord {\r\n\r\n\r\n        uint256 createTime;\r\n\r\n\r\n        uint256 latestDepositInTime;\r\n\r\n\r\n        uint256 latestWithdrawTime;\r\n\r\n\r\n        uint256 depositMaxLimit;\r\n\r\n\r\n        uint256 currentEther;\r\n\r\n\r\n        uint256 withdrawableTotal;\r\n\r\n\r\n        uint256 canWithdrawProfix;\r\n\r\n\r\n        uint8 profixMultiplier;\r\n    }\r\n\r\n    function MaxProfixDelta( DB storage self, address owner) public view returns (uint256) {\r\n\r\n        if ( !isExist(self, owner) ) {\r\n            return 0;\r\n        }\r\n\r\n        return (self.map[owner].currentEther * self.map[owner].profixMultiplier) - self.map[owner].withdrawableTotal;\r\n    }\r\n\r\n    function isExist( DB storage self, address owner ) public view returns (bool) {\r\n        return self.map[owner].createTime != 0;\r\n    }\r\n\r\n    function Create( DB storage self, address owner, uint256 value, uint256 maxlimit, uint8 muler ) public returns (bool) {\r\n\r\n        uint256 dayz = lib_math.CurrentDayzeroTime();\r\n\r\n        if ( self.map[owner].createTime != 0 ) {\r\n            return false;\r\n        }\r\n\r\n        self.map[owner] = DepositedRecord(dayz, dayz, dayz, maxlimit, value, 0, 0, muler);\r\n        self.currentDepostiTotalAmount += value;\r\n\r\n        if ( !self.totalMap[owner].isExist ) {\r\n            self.totalMap[owner] = Statistics(true, value, 0);\r\n        } else {\r\n            self.totalMap[owner].totalIn += value;\r\n        }\r\n\r\n        self.amountInputs[owner].push( EverIn(lib_math.CurrentDayzeroTime(), value) );\r\n\r\n        return true;\r\n    }\r\n\r\n    function Clear( DB storage self, address owner) internal {\r\n        self.map[owner].createTime = 0;\r\n        self.map[owner].currentEther = 0;\r\n        self.map[owner].latestDepositInTime = 0;\r\n        self.map[owner].latestWithdrawTime = 0;\r\n        self.map[owner].depositMaxLimit = 0;\r\n        self.map[owner].currentEther = 0;\r\n        self.map[owner].withdrawableTotal = 0;\r\n        self.map[owner].canWithdrawProfix = 0;\r\n        self.map[owner].profixMultiplier = 0;\r\n    }\r\n\r\n    function AppendEtherValue( DB storage self, address owner, uint256 appendValue ) public returns (bool) {\r\n\r\n        if ( self.map[owner].createTime == 0 ) {\r\n            return false;\r\n        }\r\n\r\n        self.map[owner].currentEther += appendValue;\r\n        self.map[owner].latestDepositInTime = now;\r\n        self.currentDepostiTotalAmount += appendValue;\r\n        self.totalMap[owner].totalIn += appendValue;\r\n\r\n        EverIn storage lr = self.amountInputs[owner][ self.amountInputs[owner].length - 1 ];\r\n\r\n        if ( lr.timeOfDayZero == lib_math.CurrentDayzeroTime() ) {\r\n            lr.amount += appendValue;\r\n        } else {\r\n            self.amountInputs[owner].push( EverIn(lib_math.CurrentDayzeroTime(), lr.amount + appendValue) );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function PushWithdrawableTotalRecord( DB storage self, address owner, uint256 profix ) public returns (bool) {\r\n\r\n        if ( self.map[owner].createTime == 0 ) {\r\n            return false;\r\n        }\r\n\r\n\r\n        self.map[owner].canWithdrawProfix = 0;\r\n        self.map[owner].withdrawableTotal += profix;\r\n        self.map[owner].latestWithdrawTime = lib_math.CurrentDayzeroTime();\r\n\r\n        self.totalMap[owner].totalOut += profix;\r\n\r\n        if ( self.map[owner].withdrawableTotal > self.map[owner].currentEther * self.map[owner].profixMultiplier ) {\r\n            self.map[owner].withdrawableTotal = self.map[owner].currentEther * self.map[owner].profixMultiplier;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function GetNearestTotoalInput( DB storage self, address owner, uint256 timeOfDayZero) public view returns (uint256) {\r\n\r\n        EverIn memory lr = self.amountInputs[owner][self.amountInputs[owner].length - 1 ];\r\n\r\n\r\n        if ( timeOfDayZero >= lr.timeOfDayZero ) {\r\n\r\n            return lr.amount;\r\n\r\n        } else {\r\n\r\n\r\n            for ( uint256 i2 = self.amountInputs[owner].length; i2 >= 1; i2--) {\r\n\r\n                uint256 i = i2 - 1;\r\n\r\n                if ( self.amountInputs[owner][i].timeOfDayZero <= timeOfDayZero ) {\r\n                    return self.amountInputs[owner][i].amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n\r\ncontract Round is InternalModule {\r\n\r\n    bool public isBroken = false;\r\n\r\n    TuringInterface public _TuringInc;\r\n    RecommendSmallTeam public _RecommendInc;\r\n    ERC20Interface public _ERC20Inc;\r\n    CostInterface public _CostInc;\r\n    LevelSubInterface public _LevelSubInc;\r\n    StatisticsInterface public _StatisticsInc;\r\n    LuckAssetsPoolInterface public _luckPoolA;\r\n    LuckAssetsPoolInterface public _luckPoolB;\r\n\r\n    constructor (\r\n\r\n        TuringInterface TuringInc,\r\n        RecommendSmallTeam RecommendInc,\r\n        ERC20Interface ERC20Inc,\r\n        CostInterface CostInc,\r\n        LevelSubInterface LevelSubInc,\r\n        StatisticsInterface StatisticsInc,\r\n        LuckAssetsPoolInterface luckPoolA,\r\n        LuckAssetsPoolInterface luckPoolB\r\n\r\n    ) public {\r\n\r\n        _TuringInc = TuringInc;\r\n        _RecommendInc = RecommendInc;\r\n        _ERC20Inc = ERC20Inc;\r\n        _CostInc = CostInc;\r\n        _LevelSubInc = LevelSubInc;\r\n        _StatisticsInc = StatisticsInc;\r\n        _luckPoolA = luckPoolA;\r\n        _luckPoolB = luckPoolB;\r\n\r\n    }\r\n\r\n    uint256 public _depositMinLimit = 1 ether;\r\n    uint256 public _depositMaxLimit = 50 ether;\r\n    uint8   public _profixMultiplier = 3;\r\n\r\n\r\n    uint256[] public _dynamicProfits = [20, 15, 10, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3];\r\n\r\n    DepositedHistory.DB private _depostedHistory;\r\n    using DepositedHistory for DepositedHistory.DB;\r\n\r\n\r\n    uint256 public _beforBrokenedCostProp;\r\n\r\n\r\n    mapping( address => bool ) _redressableMapping;\r\n\r\n    event Log_ProfixHistory(address indexed owner, uint256 indexed value, uint8 indexed ptype, uint256 time);\r\n    event Log_NewDeposited(address indexed owner, uint256 indexed time, uint256 indexed value);\r\n    event Log_NewWinner(address indexed owner, uint256 indexed time, uint256 indexed baseAmount, uint8 mn);\r\n    event Log_WithdrawProfix(address indexed addr, uint256 indexed time, uint256 indexed value, uint256 rvalue);\r\n\r\n\r\n    modifier OnlyInBrokened() {\r\n        require( isBroken );\r\n        _;\r\n    }\r\n\r\n\r\n    modifier OnlyInPlaying() {\r\n        require( !isBroken );\r\n        _;\r\n    }\r\n\r\n    modifier PauseDisable() {\r\n        require ( !_luckPoolA.NeedPauseGame() );\r\n        _;\r\n    }\r\n\r\n    modifier DAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"DAO_Warning\" );\r\n        _;\r\n    }\r\n\r\n    function GetEvenInRecord(address owner, uint256 index) external view returns ( uint256 time, uint256 total, uint256 len ) {\r\n\r\n        return ( _depostedHistory.amountInputs[owner][index].timeOfDayZero, _depostedHistory.amountInputs[owner][index].amount, _depostedHistory.amountInputs[owner].length );\r\n    }\r\n\r\n    function Join() external payable OnlyInPlaying PauseDisable DAODefense {\r\n\r\n        _TuringInc.Analysis();\r\n\r\n\r\n        require( _RecommendInc.GetIntroducer(msg.sender) != address(0x0), \"E01\" );\r\n\r\n\r\n        require( _TuringInc.GetDepositedLimitCurrentDelta() >= msg.value );\r\n        _TuringInc.API_SubDepositedLimitCurrent( msg.value );\r\n\r\n\r\n        require( msg.value >= _depositMinLimit, \"E07\" );\r\n\r\n\r\n        uint256 cost = _CostInc.DepositedCost(msg.value);\r\n\r\n        _ERC20Inc.transferFrom( msg.sender, address(0xdead), cost );\r\n\r\n        if ( _depostedHistory.isExist(msg.sender) ) {\r\n\r\n            DepositedHistory.DepositedRecord memory r = _depostedHistory.map[msg.sender];\r\n\r\n            require( msg.value <= r.depositMaxLimit - r.currentEther);\r\n\r\n\r\n            require( now - r.latestDepositInTime >= lib_math.OneDay() * 2 );\r\n\r\n            _depostedHistory.AppendEtherValue(msg.sender, msg.value);\r\n\r\n        } else {\r\n\r\n            require( msg.value <= _depositMaxLimit );\r\n\r\n            _depostedHistory.Create(msg.sender, msg.value, _depositMaxLimit, _profixMultiplier);\r\n        }\r\n\r\n\r\n        emit Log_NewDeposited( msg.sender, now, msg.value);\r\n\r\n\r\n        if ( address(this).balance > 3000 ether ) {\r\n            _TuringInc.API_PowerOn();\r\n        }\r\n\r\n\r\n        address payable lpiaddrA = address( uint160( address(_luckPoolA) ) );\r\n        address payable lpiaddrB = address( uint160( address(_luckPoolB) ) );\r\n\r\n        lpiaddrA.transfer(msg.value * _luckPoolA.InPoolProp() / 100);\r\n        lpiaddrB.transfer(msg.value * _luckPoolB.InPoolProp() / 100);\r\n\r\n        _luckPoolA.API_AddLatestAddress(msg.sender, msg.value);\r\n        _luckPoolB.API_AddLatestAddress(msg.sender, msg.value);\r\n\r\n\r\n        _RecommendInc.API_MarkValid( msg.sender, msg.value );\r\n\r\n        return ;\r\n    }\r\n\r\n\r\n    function CurrentDepsitedTotalAmount() external view returns (uint256) {\r\n        return _depostedHistory.currentDepostiTotalAmount;\r\n    }\r\n\r\n    function CurrentCanWithdrawProfix(address owner) public view returns (uint256 st, uint256 dy) {\r\n\r\n        if ( !_depostedHistory.isExist(owner) ) {\r\n            return (0, 0);\r\n        }\r\n\r\n        DepositedHistory.DepositedRecord memory r = _depostedHistory.map[owner];\r\n\r\n        uint256 deltaDays = (lib_math.CurrentDayzeroTime() - r.latestWithdrawTime) / lib_math.OneDay();\r\n\r\n        uint256 staticTotal = 0;\r\n\r\n        for (uint256 i = 0; i < deltaDays; i++) {\r\n\r\n            uint256 cday = lib_math.CurrentDayzeroTime() - (i * lib_math.OneDay());\r\n\r\n            uint256 dp = _TuringInc.GetProfitPropBytime( cday );\r\n\r\n\r\n            staticTotal = staticTotal + (_depostedHistory.GetNearestTotoalInput(owner, cday) * dp / 1000);\r\n        }\r\n\r\n        return (staticTotal, r.canWithdrawProfix);\r\n    }\r\n\r\n    function WithdrawProfix() external OnlyInPlaying PauseDisable DAODefense {\r\n\r\n        DepositedHistory.DepositedRecord memory r = _depostedHistory.map[msg.sender];\r\n\r\n\r\n        (uint256 stProfix, uint256 dyProfix) = CurrentCanWithdrawProfix(msg.sender);\r\n        uint256 totalProfix =  stProfix + dyProfix;\r\n\r\n        if ( _depostedHistory.MaxProfixDelta(msg.sender) < totalProfix ) {\r\n\r\n            totalProfix = _depostedHistory.MaxProfixDelta(msg.sender);\r\n\r\n            _StatisticsInc.API_AddWinnerCount();\r\n\r\n            _depostedHistory.Clear(msg.sender);\r\n\r\n            _depostedHistory.totalMap[msg.sender].totalOut += totalProfix;\r\n\r\n            emit Log_NewWinner(msg.sender, now, r.currentEther, r.profixMultiplier);\r\n\r\n        } else {\r\n            _depostedHistory.PushWithdrawableTotalRecord(msg.sender, totalProfix);\r\n        }\r\n\r\n\r\n        uint256 realStProfix = totalProfix * _TuringInc.GetCurrentWithrawThreshold() / 100;\r\n        uint256 cost = _CostInc.WithdrawCost( totalProfix );\r\n\r\n        _ERC20Inc.transferFrom(msg.sender, address(0xdead), cost);\r\n\r\n        msg.sender.transfer(realStProfix);\r\n\r\n        emit Log_ProfixHistory(msg.sender, stProfix * _TuringInc.GetCurrentWithrawThreshold() / 100, 40, now);\r\n        emit Log_WithdrawProfix(msg.sender, now, totalProfix, realStProfix);\r\n\r\n\r\n\r\n        if ( stProfix <= 0 ) {\r\n            return;\r\n        }\r\n\r\n        _StatisticsInc.API_AddStaticTotalAmount(msg.sender, stProfix);\r\n\r\n        uint256 senderDepositedValue = r.currentEther;\r\n        uint256 dyProfixBaseValue = stProfix;\r\n        address parentAddr = msg.sender;\r\n        for ( uint256 i = 0; i < _dynamicProfits.length; i++ ) {\r\n\r\n            parentAddr = _RecommendInc.GetIntroducer(parentAddr);\r\n\r\n            if ( parentAddr == address(0x0) ) {\r\n\r\n                break;\r\n            }\r\n\r\n\r\n            uint256 pdmcount = _RecommendInc.DirectValidMembersCount( parentAddr );\r\n\r\n\r\n            if ( pdmcount >= 6 || _LevelSubInc.LevelOf(parentAddr) > 0 ) {\r\n                pdmcount = _dynamicProfits.length;\r\n            }\r\n\r\n\r\n            if ( (i + 1) > pdmcount ) {\r\n                continue;\r\n            }\r\n\r\n\r\n            if ( _depostedHistory.isExist(parentAddr) ) {\r\n\r\n                uint256 parentDyProfix = dyProfixBaseValue * _dynamicProfits[i] / 100;\r\n\r\n                if ( senderDepositedValue > _depostedHistory.map[parentAddr].currentEther && _depostedHistory.map[parentAddr].currentEther < 30 ether ) {\r\n\r\n                    parentDyProfix = parentDyProfix * ( _depostedHistory.map[parentAddr].currentEther * 100 / senderDepositedValue ) / 100;\r\n                }\r\n\r\n\r\n                emit Log_ProfixHistory(parentAddr, parentDyProfix, uint8(i), now);\r\n                _depostedHistory.map[parentAddr].canWithdrawProfix += parentDyProfix;\r\n                _StatisticsInc.API_AddDynamicTotalAmount(parentAddr, parentDyProfix);\r\n            }\r\n        }\r\n\r\n\r\n        uint256 len = 0;\r\n        address[] memory addrs;\r\n        uint256[] memory profits;\r\n        (len, addrs, profits) = _LevelSubInc.ProfitHandle( msg.sender, stProfix );\r\n        for ( uint j = 0; j < len; j++ ) {\r\n\r\n            if ( addrs[j] == address(0x0) ) {\r\n                continue ;\r\n            }\r\n\r\n            if ( len - j < 3 ) {\r\n                emit Log_ProfixHistory(addrs[j], profits[j], uint8( 30 + _LevelSubInc.LevelOf(addrs[j])), now);\r\n            } else {\r\n                emit Log_ProfixHistory(addrs[j], profits[j], uint8( 20 + _LevelSubInc.LevelOf(addrs[j])), now);\r\n            }\r\n\r\n            _depostedHistory.map[addrs[j]].canWithdrawProfix += profits[j];\r\n            _StatisticsInc.API_AddDynamicTotalAmount(addrs[j], profits[j]);\r\n        }\r\n    }\r\n\r\n\r\n    function TotalInOutAmount() external view returns (uint256 inEther, uint256 outEther) {\r\n        return ( _depostedHistory.totalMap[msg.sender].totalIn, _depostedHistory.totalMap[msg.sender].totalOut );\r\n    }\r\n\r\n\r\n    function GetRedressInfo() external view OnlyInBrokened returns (uint256 total, bool withdrawable) {\r\n\r\n        DepositedHistory.Statistics memory r = _depostedHistory.totalMap[msg.sender];\r\n\r\n        if ( r.totalOut >= r.totalIn ) {\r\n            return (0, false);\r\n        }\r\n\r\n        uint256 subEther = r.totalIn - r.totalOut;\r\n\r\n        uint256 redtotal = (subEther * _beforBrokenedCostProp / 1 ether);\r\n\r\n        return (redtotal, _redressableMapping[msg.sender]);\r\n    }\r\n\r\n\r\n    function DrawRedress() external OnlyInBrokened returns (bool) {\r\n\r\n        DepositedHistory.Statistics memory r = _depostedHistory.totalMap[msg.sender];\r\n\r\n\r\n        if ( r.totalOut >= r.totalIn ) {\r\n            return false;\r\n        }\r\n\r\n        if ( !_redressableMapping[msg.sender] ) {\r\n\r\n            _redressableMapping[msg.sender] = true;\r\n\r\n\r\n            uint256 subEther = r.totalIn - r.totalOut;\r\n\r\n            uint256 redtotal = (subEther * _beforBrokenedCostProp / 1 ether);\r\n\r\n\r\n            _utopiaInc.API_AppendLockedDepositAmount(msg.sender, redtotal);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function GetCurrentGameStatus() external view returns (\r\n        uint256 createTime,\r\n        uint256 latestDepositInTime,\r\n        uint256 latestWithdrawTime,\r\n        uint256 depositMaxLimit,\r\n        uint256 currentEther,\r\n        uint256 withdrawableTotal,\r\n        uint256 canWithdrawProfix,\r\n        uint8 profixMultiplier\r\n    ) {\r\n        createTime = _depostedHistory.map[msg.sender].createTime;\r\n        latestDepositInTime = _depostedHistory.map[msg.sender].latestDepositInTime;\r\n        latestWithdrawTime = _depostedHistory.map[msg.sender].latestWithdrawTime;\r\n        depositMaxLimit = _depostedHistory.map[msg.sender].depositMaxLimit;\r\n        currentEther = _depostedHistory.map[msg.sender].currentEther;\r\n        withdrawableTotal = _depostedHistory.map[msg.sender].withdrawableTotal;\r\n        canWithdrawProfix = _depostedHistory.map[msg.sender].canWithdrawProfix;\r\n        profixMultiplier = _depostedHistory.map[msg.sender].profixMultiplier;\r\n    }\r\n\r\n\r\n    function Owner_TryResumeRound() external OwnerOnly {\r\n\r\n        if ( address(this).balance < 100 ether ) {\r\n\r\n            isBroken = true;\r\n\r\n            _beforBrokenedCostProp = _CostInc.CurrentCostProp();\r\n\r\n            _defaultReciver.transfer( address(this).balance );\r\n\r\n            _luckPoolB.API_GameOver();\r\n\r\n        } else {\r\n\r\n            _luckPoolA.API_Reboot();\r\n        }\r\n\r\n    }\r\n\r\n    function Redeem() external OnlyInPlaying PauseDisable DAODefense {\r\n\r\n        DepositedHistory.Statistics storage tr = _depostedHistory.totalMap[msg.sender];\r\n\r\n        DepositedHistory.DepositedRecord storage r = _depostedHistory.map[msg.sender];\r\n\r\n        require(now - r.latestDepositInTime >= lib_math.OneDay() * 90 );\r\n\r\n        require(tr.totalIn > tr.totalOut);\r\n\r\n        uint256 deltaEther = tr.totalIn - tr.totalOut;\r\n\r\n        require(address(this).balance >= deltaEther);\r\n\r\n        _depostedHistory.Clear(msg.sender);\r\n\r\n        tr.totalOut = tr.totalIn;\r\n\r\n        msg.sender.transfer(deltaEther);\r\n    }\r\n\r\n\r\n    function Owner_SetProfixMultiplier(uint8 m) external OwnerOnly {\r\n        _profixMultiplier = m;\r\n    }\r\n\r\n    function Owner_SetDepositLimit(uint256 min, uint256 max) external OwnerOnly {\r\n        _depositMinLimit = min;\r\n        _depositMaxLimit = max;\r\n    }\r\n\r\n\r\n\r\n\r\n    function Owner_SetDynamicProfits(uint d, uint p) external OwnerOnly {\r\n        _dynamicProfits[d] = p;\r\n    }\r\n\r\n    UtopiaInterface _utopiaInc;\r\n    function Owner_SetUtopiaInterface(UtopiaInterface inc) external OwnerOnly {\r\n        _utopiaInc = inc;\r\n    }\r\n\r\n    function () payable external {}\r\n}\r\n\r\ninterface UtopiaInterface {\r\n    function API_AppendLockedDepositAmount(address owner, uint amount) external;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_ERC20Inc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_depositMaxLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBroken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_CostInc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_LevelSubInc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalInOutAmount\",\"outputs\":[{\"name\":\"inEther\",\"type\":\"uint256\"},{\"name\":\"outEther\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"min\",\"type\":\"uint256\"},{\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"Owner_SetDepositLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetCurrentGameStatus\",\"outputs\":[{\"name\":\"createTime\",\"type\":\"uint256\"},{\"name\":\"latestDepositInTime\",\"type\":\"uint256\"},{\"name\":\"latestWithdrawTime\",\"type\":\"uint256\"},{\"name\":\"depositMaxLimit\",\"type\":\"uint256\"},{\"name\":\"currentEther\",\"type\":\"uint256\"},{\"name\":\"withdrawableTotal\",\"type\":\"uint256\"},{\"name\":\"canWithdrawProfix\",\"type\":\"uint256\"},{\"name\":\"profixMultiplier\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_TuringInc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_contractOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_profixMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Join\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"d\",\"type\":\"uint256\"},{\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"Owner_SetDynamicProfits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Owner_TryResumeRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_beforBrokenedCostProp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"GetEvenInRecord\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"len\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"AddAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CurrentDepsitedTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AuthAddresses\",\"outputs\":[{\"name\":\"authAddr\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetRedressInfo\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"withdrawable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_depositMinLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_StatisticsInc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_RecommendInc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inc\",\"type\":\"address\"}],\"name\":\"Owner_SetUtopiaInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_luckPoolA\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CurrentCanWithdrawProfix\",\"outputs\":[{\"name\":\"st\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_defaultReciver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_luckPoolB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DrawRedress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"m\",\"type\":\"uint8\"}],\"name\":\"Owner_SetProfixMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"DelAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_dynamicProfits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawProfix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"TuringInc\",\"type\":\"address\"},{\"name\":\"RecommendInc\",\"type\":\"address\"},{\"name\":\"ERC20Inc\",\"type\":\"address\"},{\"name\":\"CostInc\",\"type\":\"address\"},{\"name\":\"LevelSubInc\",\"type\":\"address\"},{\"name\":\"StatisticsInc\",\"type\":\"address\"},{\"name\":\"luckPoolA\",\"type\":\"address\"},{\"name\":\"luckPoolB\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ptype\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Log_ProfixHistory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Log_NewDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mn\",\"type\":\"uint8\"}],\"name\":\"Log_NewWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rvalue\",\"type\":\"uint256\"}],\"name\":\"Log_WithdrawProfix\",\"type\":\"event\"}]","ContractName":"Round","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000def65fba8f50f01b811c8247b89bb7f95f6f2e240000000000000000000000003fe5eb14a8e99d7ba8b421c5285b5c0d8292cd1300000000000000000000000091c4b0cfc5eac8b8c5fd953ae9fbc707b520a7d60000000000000000000000000baa130c0f3dcab39981dd5d6a781dcc517eb5d00000000000000000000000002655e4b1957ff8fa6536f705f3f7feb7d910ff7600000000000000000000000039df96d505a10e2202e1b0a27dc29ba136b6a8ec00000000000000000000000058d9aeff5bd966717a61439fffd2273102084b90000000000000000000000000c3715c9614d5d37a0732c47db6bbb6bbc014a822","EVMVersion":"byzantium","Library":"lib_math:307f824808607dfa13ef7fa4370dd267c4ba08f3;DepositedHistory:dc8936cdc3123928342f375b35751acbf0d70047","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0f04b849a70e5f5d0d7a90a0509646c167d6517a926f4284bed71c404ddf816e"}]}