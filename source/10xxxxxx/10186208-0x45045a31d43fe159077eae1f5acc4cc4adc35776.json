{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.6;\r\n\r\n\r\ninterface xEtherTokensContractInterface {\r\n    function ecosystemDividends() external payable;\r\n}\r\n\r\n\r\ncontract XetherSicboLottery {\r\n    uint256 public HOUSE_EDGE_MINIMUM_AMOUNT = 0.0009 ether;\r\n    uint256 public TICKET_PRICE = 0.01 ether;\r\n    uint256 public MAX_AMOUNT = 100 ether;\r\n    uint256 constant BET_EXPIRATION_BLOCKS = 250;\r\n    uint16 constant JACKPOT_MODULO = 10000;\r\n    uint256 public JACKPOT_FEE = 0.001 ether;\r\n    uint256 lastTicketTime = now;\r\n    uint8 averageLotteryLock = 1;\r\n\r\n    uint256 public MIN_BET = 0.01 ether;\r\n    uint256 public MIN_JACKPOT_BET = 0.1 ether;\r\n\r\n    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    uint256 public maxProfitLottery = 5 ether;\r\n    uint256 public maxProfitSicbo = 1 ether;\r\n    uint8 public TICKET_MAX_COUNT = 100;\r\n\r\n    uint256 public sicboTableLimit = 2 ether;\r\n    uint8[] public sumPayput = [\r\n        61,\r\n        31,\r\n        18,\r\n        13,\r\n        9,\r\n        7,\r\n        7,\r\n        7,\r\n        7,\r\n        9,\r\n        13,\r\n        18,\r\n        31,\r\n        61\r\n    ];\r\n    uint8[2][15] public pairBet = [\r\n        [1, 2],\r\n        [1, 3],\r\n        [1, 4],\r\n        [1, 5],\r\n        [1, 6],\r\n        [2, 3],\r\n        [2, 4],\r\n        [2, 5],\r\n        [2, 6],\r\n        [3, 4],\r\n        [3, 5],\r\n        [3, 6],\r\n        [4, 5],\r\n        [4, 6],\r\n        [5, 6]\r\n    ];\r\n\r\n    uint8 public DIVIDENDS_PERCENT = 10; // 1% example: 15 will be 1.5%\r\n    uint8 public ADVERTISE_PERCENT = 0; // 1%\r\n    uint8 public HOUSE_EDGE_PERCENT = 10; // 1%\r\n    uint16 constant PERCENTAGES_BASE = 1000;\r\n    uint256 constant DIVIDENDS_LIMIT = 1 ether;\r\n\r\n    uint16 public luckyNumberLottery = 7777;\r\n    uint16 public luckyNumberSicbo = 777;\r\n    uint256 public jackpotSizeLottery;\r\n    uint256 public jackpotSizeSicbo;\r\n    uint256 public jackpotSize = 0;\r\n\r\n    uint8 public gamesStopped = 0;\r\n\r\n    struct Ticket {\r\n        uint256 amount;\r\n        uint256 count;\r\n        uint40 placeBlockNumber;\r\n        address payable gambler;\r\n        uint128 locked;\r\n        uint256 clientSeed;\r\n    }\r\n    mapping(uint256 => Ticket) tickets;\r\n\r\n    struct Bet {\r\n        uint256 totalBetAmount;\r\n        uint128 locked;\r\n        mapping(uint8 => uint256) amount;\r\n        mapping(uint8 => uint8) bettype;\r\n        uint40 placeBlockNumber;\r\n        uint256 clientSeed;\r\n        mapping(uint8 => uint256) nums;\r\n        address payable gambler;\r\n        uint8 betsCount;\r\n    }\r\n    mapping(uint256 => Bet) bets;\r\n    mapping(address => uint256) public bonusProgrammAccumulated;\r\n\r\n    xEtherTokensContractInterface public xEtherTokensContract;\r\n\r\n    address public owner;\r\n    address private nextOwner;\r\n    address public moderator;\r\n\r\n    uint256 public totalDividends = 0;\r\n    uint256 public totalAdvertise = 0;\r\n\r\n    address public secretSigner;\r\n    address public croupier;\r\n    uint128 public lockedInBetsLottery;\r\n    uint128 public lockedInBetsSicbo;\r\n\r\n    event PaymentLottery(\r\n        address beneficiary,\r\n        uint256 commit,\r\n        uint256 amount,\r\n        string paymentType,\r\n        uint256[] numbers\r\n    );\r\n    event PaymentSicbo(\r\n        address beneficiary,\r\n        uint256 commit,\r\n        uint256 amount,\r\n        string paymentType\r\n    );\r\n    event JackpotSicboPayment(\r\n        address indexed beneficiary,\r\n        uint256 commit,\r\n        uint256 amount\r\n    );\r\n    event JackpotLotteryPayment(\r\n        address indexed beneficiary,\r\n        uint256 commit,\r\n        uint256 amount\r\n    );\r\n\r\n    event PayDividendsSuccess(uint256 time, uint256 amount);\r\n    event PayDividendsFailed(uint256 time, uint256 amount);\r\n\r\n    event CommitLottery(uint256 commit, uint256 clientSeed, uint256 amount);\r\n    event CommitSicbo(uint256 commit, uint256 clientSeed, uint256 amount);\r\n\r\n    modifier onlyModeration {\r\n        require(\r\n            msg.sender == owner || msg.sender == moderator,\r\n            \"Moderation methods called by non-moderator.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCroupier {\r\n        require(\r\n            msg.sender == croupier,\r\n            \"OnlyCroupier methods called by non-croupier.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function approveNextOwner(address _nextOwner) external onlyOwner {\r\n        require(_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require(\r\n            msg.sender == nextOwner,\r\n            \"Can only accept preapproved new owner.\"\r\n        );\r\n        owner = nextOwner;\r\n    }\r\n\r\n    function setMaxProfit(uint256 _maxProfit, uint8 game) public onlyOwner {\r\n        require(\r\n            _maxProfit < MAX_AMOUNT,\r\n            \"maxProfit cant be great then top limit.\"\r\n        );\r\n\r\n        if (game == 0) {\r\n            maxProfitSicbo = _maxProfit;\r\n        } else {\r\n            maxProfitLottery = _maxProfit;\r\n        }\r\n    }\r\n\r\n    function changeMaxTickets(uint8 _newMaxTickets) external onlyOwner {\r\n        require(\r\n            0 <= _newMaxTickets && _newMaxTickets < 1000,\r\n            \"Wrong tickets number\"\r\n        );\r\n        TICKET_MAX_COUNT = _newMaxTickets;\r\n    }\r\n\r\n    function getBonusProgrammLevel(address gambler)\r\n        public\r\n        view\r\n        returns (uint8 discount)\r\n    {\r\n        uint256 accumulated = bonusProgrammAccumulated[gambler];\r\n        discount = 0;\r\n\r\n        if (accumulated >= 20 ether && accumulated < 100 ether) {\r\n            discount = 1;\r\n        } else if (accumulated >= 100 ether && accumulated < 500 ether) {\r\n            discount = 2;\r\n        } else if (accumulated >= 500 ether && accumulated < 1000 ether) {\r\n            discount = 3;\r\n        } else if (accumulated >= 1000 ether && accumulated < 5000 ether) {\r\n            discount = 4;\r\n        } else if (accumulated >= 5000 ether) {\r\n            discount = 5;\r\n        }\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function setNewPercents(\r\n        uint8 newHouseEdgePercent,\r\n        uint8 newDividendsPercent,\r\n        uint8 newAdvertPercent\r\n    ) external onlyModeration {\r\n        // We guarantee that dividends will be minimum 0.5%\r\n        require(newDividendsPercent >= 5, \"dividentds limit\");\r\n        // Total percentages not greater then 3%\r\n        require(\r\n            newHouseEdgePercent + newDividendsPercent + newAdvertPercent <= 30,\r\n            \"Total percentages not greater then 3%\"\r\n        );\r\n\r\n        HOUSE_EDGE_PERCENT = newHouseEdgePercent;\r\n        ADVERTISE_PERCENT = newAdvertPercent;\r\n        DIVIDENDS_PERCENT = newDividendsPercent;\r\n    }\r\n\r\n    function setAdditionalVariables(\r\n        uint256 he,\r\n        uint256 mjb,\r\n        uint256 jf,\r\n        uint256 mb,\r\n        uint256 ma,\r\n        uint8 al\r\n    ) external onlyModeration {\r\n        if (he != 0 && he > 0) {\r\n            HOUSE_EDGE_MINIMUM_AMOUNT = he;\r\n        }\r\n        if (mjb != 0 && mjb > 0) {\r\n            MIN_JACKPOT_BET = mjb;\r\n        }\r\n        if (jf != 0 && jf > 0) {\r\n            JACKPOT_FEE = jf;\r\n        }\r\n        if (mb != 0 && mb > 0) {\r\n            MIN_BET = mb;\r\n        }\r\n        if (ma != 0 && ma > 0) {\r\n            MAX_AMOUNT = ma;\r\n        }\r\n        if (al != 0 && al > 0) {\r\n            averageLotteryLock = al;\r\n        }\r\n    }\r\n\r\n    function stopGames(uint8 _stopGames) external onlyModeration {\r\n        gamesStopped = _stopGames;\r\n    }\r\n\r\n    function setTableLimit(uint256 _newTableLimit) public onlyModeration {\r\n        require(\r\n            _newTableLimit < MAX_AMOUNT,\r\n            \"tableLimit cant be great then top limit.\"\r\n        );\r\n        sicboTableLimit = _newTableLimit;\r\n    }\r\n\r\n    function setXEtherContract(address xEtherContract) external onlyModeration {\r\n        xEtherTokensContract = xEtherTokensContractInterface(xEtherContract);\r\n    }\r\n\r\n    function setAddresses(\r\n        address newCroupier,\r\n        address newSecretSigner,\r\n        address newModerator\r\n    ) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n        croupier = newCroupier;\r\n        moderator = newModerator;\r\n    }\r\n\r\n    function increaseJackpot(uint256 increaseAmount, uint8 game)\r\n        external\r\n        onlyModeration\r\n    {\r\n        require(\r\n            increaseAmount <= address(this).balance,\r\n            \"Increase amount larger than balance.\"\r\n        );\r\n\r\n        if (game == 0) {\r\n            require(\r\n                jackpotSizeSicbo + lockedInBetsSicbo + increaseAmount <=\r\n                    address(this).balance,\r\n                \"Not enough funds.\"\r\n            );\r\n            jackpotSizeSicbo += uint128(increaseAmount);\r\n        } else {\r\n            require(\r\n                jackpotSizeLottery + lockedInBetsLottery + increaseAmount <=\r\n                    address(this).balance,\r\n                \"Not enough funds.\"\r\n            );\r\n            jackpotSizeLottery += uint128(increaseAmount);\r\n        }\r\n    }\r\n\r\n    function releaseLockedInBetSicboAmount() external onlyModeration {\r\n        lockedInBetsSicbo = 0;\r\n    }\r\n\r\n    function releaseLockedInBetLotteryAmount() external onlyModeration {\r\n        lockedInBetsLottery = 0;\r\n    }\r\n\r\n    function withdrawFunds(address payable beneficiary, uint256 withdrawAmount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            withdrawAmount <= address(this).balance,\r\n            \"Increase amount larger than balance.\"\r\n        );\r\n        require(\r\n            jackpotSizeSicbo +\r\n                jackpotSizeLottery +\r\n                lockedInBetsSicbo +\r\n                lockedInBetsLottery +\r\n                withdrawAmount <=\r\n                address(this).balance,\r\n            \"Not enough funds.\"\r\n        );\r\n        sendFundsSicbo(beneficiary, withdrawAmount, 0, \"withdraw\");\r\n    }\r\n\r\n    function withdrawAdvertiseFunds(\r\n        address payable beneficiary,\r\n        uint256 withdrawAmount\r\n    ) external onlyOwner {\r\n        require(\r\n            withdrawAmount <= totalAdvertise,\r\n            \"Increase amount larger than balance.\"\r\n        );\r\n        totalAdvertise = 0;\r\n        sendFundsSicbo(beneficiary, withdrawAmount, 0, \"withdraw\");\r\n    }\r\n\r\n    function withdrawLotteryJackpot(\r\n        address payable beneficiary,\r\n        uint256 withdrawAmount\r\n    ) external onlyOwner {\r\n        require(\r\n            withdrawAmount <= jackpotSizeLottery,\r\n            \"Increase amount larger than balance.\"\r\n        );\r\n        require(\r\n            now >= lastTicketTime + 1 days,\r\n            \"Withdraw jacpot on 1 day inactivity\"\r\n        );\r\n        jackpotSizeLottery -= withdrawAmount;\r\n        uint256[] memory tmp;\r\n        sendFundsLottery(beneficiary, withdrawAmount, 0, \"withdraw\", tmp);\r\n    }\r\n\r\n    function end() external onlyOwner {\r\n        require(\r\n            lockedInBetsSicbo == 0 && lockedInBetsLottery == 0,\r\n            \"All bets should be processed (settled or refunded) before self-destruct.\"\r\n        );\r\n        selfdestruct(address(uint160(owner)));\r\n    }\r\n\r\n    function sendDividends() public payable {\r\n        if (address(xEtherTokensContract) != address(0)) {\r\n            uint256 tmpDividends = totalDividends;\r\n            xEtherTokensContract.ecosystemDividends.value(tmpDividends)();\r\n            totalDividends = 0;\r\n\r\n            emit PayDividendsSuccess(now, tmpDividends);\r\n        }\r\n    }\r\n\r\n    // ----------- SicBo ------------\r\n    function placeBet(\r\n        uint8[] calldata betType,\r\n        uint256[] calldata betNums,\r\n        uint256[] calldata betAmount,\r\n        uint256 commitLastBlock,\r\n        uint256 commit,\r\n        uint256 clientSeed,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable {\r\n        require(gamesStopped == 0, \"Games is running\");\r\n\r\n        Bet storage bet = bets[commit];\r\n        Ticket storage ticket = tickets[commit];\r\n\r\n        require(bet.gambler == address(0) && ticket.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n        require(\r\n            msg.value <= sicboTableLimit,\r\n            \"Bets sum must be LTE table limit\"\r\n        );\r\n        require(\r\n            uint8(betNums.length) == uint8(betType.length) &&\r\n                uint8(betNums.length) == uint8(betAmount.length),\r\n            \"Arguments length not match\"\r\n        );\r\n        bet.betsCount = uint8(betNums.length);\r\n\r\n        require(block.number <= commitLastBlock, \"Commit has expired.\");\r\n        require(\r\n            secretSigner ==\r\n                ecrecover(\r\n                    keccak256(\r\n                        abi.encodePacked(uint40(commitLastBlock), commit)\r\n                    ),\r\n                    27,\r\n                    r,\r\n                    s\r\n                ) ||\r\n                secretSigner ==\r\n                ecrecover(\r\n                    keccak256(\r\n                        abi.encodePacked(uint40(commitLastBlock), commit)\r\n                    ),\r\n                    28,\r\n                    r,\r\n                    s\r\n                ),\r\n            \"ECDSA signature is not valid.\"\r\n        );\r\n\r\n        if (totalDividends >= DIVIDENDS_LIMIT) {\r\n            sendDividends();\r\n        }\r\n\r\n        bet.gambler = msg.sender;\r\n        placeBetProcess(commit, betType, betNums, betAmount);\r\n\r\n        lockedInBetsSicbo += bet.locked;\r\n        require(\r\n            lockedInBetsSicbo <= address(this).balance,\r\n            \"Cannot afford to lose this bet.\"\r\n        );\r\n\r\n        bonusProgrammAccumulated[msg.sender] += msg.value;\r\n\r\n        bet.totalBetAmount = msg.value;\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.clientSeed = clientSeed;\r\n\r\n        emit CommitSicbo(commit, clientSeed, msg.value);\r\n    }\r\n\r\n    function placeBetProcess(\r\n        uint256 commit,\r\n        uint8[] memory betType,\r\n        uint256[] memory betNums,\r\n        uint256[] memory betAmount\r\n    ) internal {\r\n        Bet storage bet = bets[commit];\r\n\r\n        uint256 totalBetAmount = 0;\r\n        uint128 possibleWinAmount;\r\n\r\n        uint256 jackpotFee = msg.value >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n        uint256 feeToJP = msg.value >= MIN_JACKPOT_BET\r\n            ? JACKPOT_FEE / bet.betsCount\r\n            : 0;\r\n\r\n        for (uint8 count = 0; count < bet.betsCount; count += 1) {\r\n            require(\r\n                betAmount[count] >= MIN_BET && betAmount[count] <= MAX_AMOUNT,\r\n                \"Amount should be within range.\"\r\n            );\r\n\r\n            totalBetAmount += betAmount[count];\r\n            require(\r\n                totalBetAmount <= msg.value,\r\n                \"Total bets amount should be LTE amount\"\r\n            );\r\n\r\n            uint8[3] memory tmp1;\r\n\r\n            possibleWinAmount = getDiceWinAmount(\r\n                betAmount[count] - feeToJP,\r\n                betType[count],\r\n                bet.gambler,\r\n                betNums[count],\r\n                tmp1,\r\n                true\r\n            );\r\n            require(\r\n                possibleWinAmount <= betAmount[count] + maxProfitSicbo,\r\n                \"maxProfitPlinko limit violation.\"\r\n            );\r\n\r\n            if (possibleWinAmount > bet.locked) {\r\n                bet.locked = possibleWinAmount;\r\n            }\r\n\r\n            bet.nums[count] = betNums[count];\r\n            bet.bettype[count] = betType[count];\r\n            bet.amount[count] = betAmount[count];\r\n        }\r\n\r\n        jackpotSizeSicbo += uint128(jackpotFee);\r\n    }\r\n\r\n    function settleBet(uint256 reveal) external onlyCroupier {\r\n        uint256 commit = uint256(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint256 placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        require(bet.totalBetAmount > 0, \"Bet already processed\");\r\n        require(\r\n            block.number > placeBlockNumber,\r\n            \"settleBet in the same block as placeBet, or before.\"\r\n        );\r\n        require(\r\n            block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS,\r\n            \"Can't be queried by EVM.\"\r\n        );\r\n\r\n        settleBet(bet, reveal);\r\n    }\r\n\r\n    function settleBet(Bet storage bet, uint256 reveal) private {\r\n        require(bet.totalBetAmount != 0, \"Bet should be in an 'active' state\");\r\n        address payable gambler = bet.gambler;\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, bet.clientSeed));\r\n\r\n        uint8[3] memory dice = [\r\n            uint8((uint256(entropy) % 6) + 1),\r\n            uint8(((uint256(entropy) / 6) % 6) + 1),\r\n            uint8(((uint256(entropy) / 6 / 6) % 6) + 1)\r\n        ];\r\n\r\n        uint256 diceWin = 0;\r\n        uint256 possibleWinAmount = 0;\r\n        uint256 feeToJP = bet.totalBetAmount >= MIN_JACKPOT_BET\r\n            ? JACKPOT_FEE / bet.betsCount\r\n            : 0;\r\n\r\n        for (uint8 index = 0; index < bet.betsCount; index += 1) {\r\n            possibleWinAmount = getDiceWinAmount(\r\n                bet.amount[index] - feeToJP,\r\n                bet.bettype[index],\r\n                bet.gambler,\r\n                bet.nums[index],\r\n                dice,\r\n                false\r\n            );\r\n            diceWin += possibleWinAmount;\r\n        }\r\n\r\n        lockedInBetsSicbo -= bet.locked;\r\n\r\n        uint256 jackpotWin = checkJackPotWin(entropy, 6, 0);\r\n        if (jackpotWin > 0) {\r\n            emit JackpotSicboPayment(\r\n                gambler,\r\n                uint256(keccak256(abi.encodePacked(reveal))),\r\n                jackpotWin\r\n            );\r\n        }\r\n\r\n        sendFundsSicbo(\r\n            gambler,\r\n            diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin,\r\n            uint256(keccak256(abi.encodePacked(reveal))),\r\n            \"payment\"\r\n        );\r\n\r\n        bet.totalBetAmount = 0;\r\n    }\r\n\r\n    function getDiceWinAmount(\r\n        uint256 amount,\r\n        uint8 betType,\r\n        address gambler,\r\n        uint256 nums,\r\n        uint8[3] memory dice,\r\n        bool init\r\n    ) private returns (uint128 winAmount) {\r\n        uint256 tmp = 0;\r\n        uint256 totalPercentages = HOUSE_EDGE_PERCENT +\r\n            ADVERTISE_PERCENT +\r\n            DIVIDENDS_PERCENT;\r\n        uint256 houseEdge = (amount *\r\n            (totalPercentages - getBonusProgrammLevel(gambler))) /\r\n            PERCENTAGES_BASE;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        if (init) {\r\n            totalDividends += (amount * DIVIDENDS_PERCENT) / PERCENTAGES_BASE;\r\n            totalAdvertise += (amount * ADVERTISE_PERCENT) / PERCENTAGES_BASE;\r\n\r\n            if (betType == 0 || betType == 1) {\r\n                require(nums == 0, \"Wrong number\");\r\n                tmp = amount * 2;\r\n            }\r\n            if (betType == 2) {\r\n                require(nums > 0 && nums <= 6, \"Wrong number\");\r\n                tmp = amount * 4;\r\n            }\r\n            if (betType == 3) {\r\n                require(nums >= 0 && nums <= 14, \"Wrong number\");\r\n                tmp = amount * 6;\r\n            }\r\n            if (betType == 4) {\r\n                require(nums >= 4 && nums <= 17, \"Wrong number\");\r\n                tmp = amount * sumPayput[nums - 4];\r\n            }\r\n            if (betType == 5) {\r\n                require(nums >= 1 && nums <= 6, \"Wrong number\");\r\n                tmp = amount * 11;\r\n            }\r\n            if (betType == 6) {\r\n                require(nums >= 1 && nums <= 6, \"Wrong number\");\r\n                tmp = amount * 181;\r\n            }\r\n            if (betType == 7) {\r\n                require(nums == 0, \"Wrong number\");\r\n                tmp = amount * 31;\r\n            }\r\n\r\n            winAmount = uint128(tmp);\r\n        } else {\r\n            uint8 rate = checkBet(betType, nums, dice);\r\n            winAmount = uint128((amount - houseEdge) * rate);\r\n        }\r\n    }\r\n\r\n    function checkBet(\r\n        uint8 betType,\r\n        uint256 nums,\r\n        uint8[3] memory dices\r\n    ) private view returns (uint8 rate) {\r\n        uint8 sum = dices[0] + dices[1] + dices[2];\r\n        uint8 ismatch = 0;\r\n        rate = 0;\r\n\r\n        if (betType == 0) {\r\n            // Small bet\r\n            if (dices[0] == dices[1] && dices[0] == dices[2]) {\r\n                rate = 0;\r\n            } else if (sum >= 4 && sum <= 10) {\r\n                rate = 2;\r\n            }\r\n        }\r\n\r\n        if (betType == 1) {\r\n            // Big bet\r\n            if (dices[0] == dices[1] && dices[0] == dices[2]) {\r\n                rate = 0;\r\n            } else if (sum >= 11 && sum <= 17) {\r\n                rate = 2;\r\n            }\r\n        }\r\n\r\n        if (betType == 2) {\r\n            // Number bets\r\n            if (nums == dices[0]) {\r\n                rate += 1;\r\n            }\r\n            if (nums == dices[1]) {\r\n                rate += 1;\r\n            }\r\n            if (nums == dices[2]) {\r\n                rate += 1;\r\n            }\r\n\r\n            rate += (rate > 0) ? 1 : 0;\r\n        }\r\n\r\n        if (betType == 3) {\r\n            // Pair bets\r\n            ismatch = 0;\r\n            uint8[2] memory tmpNums = pairBet[nums];\r\n            if (tmpNums[0] != tmpNums[1]) {\r\n                if (\r\n                    tmpNums[0] == dices[0] ||\r\n                    tmpNums[0] == dices[1] ||\r\n                    tmpNums[0] == dices[2]\r\n                ) {\r\n                    ismatch += 1;\r\n                }\r\n                if (\r\n                    tmpNums[1] == dices[0] ||\r\n                    tmpNums[1] == dices[1] ||\r\n                    tmpNums[1] == dices[2]\r\n                ) {\r\n                    ismatch += 1;\r\n                }\r\n\r\n                rate = (ismatch == 2) ? 6 : 0;\r\n            }\r\n        }\r\n\r\n        if (betType == 4 && nums == sum && (sum >= 4 && sum <= 17)) {\r\n            // Total bets\r\n            rate = sumPayput[sum - 4];\r\n        }\r\n\r\n        if (betType == 5) {\r\n            // 5 Double bets\r\n            if (\r\n                dices[0] == dices[1] ||\r\n                dices[1] == dices[2] ||\r\n                dices[0] == dices[2]\r\n            ) {\r\n                if (dices[0] == dices[1] && dices[0] == nums) {\r\n                    rate = 11;\r\n                }\r\n                if (dices[1] == dices[2] && dices[1] == nums) {\r\n                    rate = 11;\r\n                }\r\n                if (dices[0] == dices[2] && dices[0] == nums) {\r\n                    rate = 11;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (betType == 6) {\r\n            // 6 Triple bets\r\n            if (dices[0] == dices[1] && dices[0] == dices[2]) {\r\n                if (dices[0] == nums) {\r\n                    rate = 181;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (betType == 7) {\r\n            // 7 Three of a kind\r\n            if (dices[0] == dices[1] && dices[0] == dices[2]) {\r\n                rate = 31;\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkForTicketWin(uint256 number) private pure returns (uint256) {\r\n        if (number == 2000) {\r\n            return 1000;\r\n        } else if (2000 > number && number >= 1998) {\r\n            return 800;\r\n        } else if (1998 > number && number >= 1994) {\r\n            return 500;\r\n        } else if (1994 > number && number >= 1984) {\r\n            return 200;\r\n        } else if (1984 > number && number >= 1964) {\r\n            return 100;\r\n        } else if (1964 > number && number >= 1924) {\r\n            return 50;\r\n        } else if (1924 > number && number >= 1824) {\r\n            return 20;\r\n        } else if (1824 > number && number >= 1500) {\r\n            return 10;\r\n        } else if (1500 > number && number >= 1250) {\r\n            return 5;\r\n        } else if (1250 > number && number >= 1000) {\r\n            return 3;\r\n        } else if (1000 > number && number >= 500) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    // --------------- Lottery ----------------\r\n    function buyTicket(\r\n        uint256 commitLastBlock,\r\n        uint256 commit,\r\n        uint256 clientSeed,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable {\r\n        require(gamesStopped == 0, \"Games is running\");\r\n\r\n        Bet storage bet = bets[commit];\r\n        Ticket storage ticket = tickets[commit];\r\n\r\n        require(bet.gambler == address(0) && ticket.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        uint256 amount = msg.value;\r\n        uint256 ticketsCount = amount / TICKET_PRICE;\r\n\r\n        require(\r\n            0 < ticketsCount && ticketsCount <= TICKET_MAX_COUNT,\r\n            \"Tickets is not in range\"\r\n        );\r\n        require(amount >= TICKET_PRICE, \"Amount should be within range.\");\r\n        require(block.number <= commitLastBlock, \"Commit has expired.\");\r\n        require(\r\n            secretSigner ==\r\n                ecrecover(\r\n                    keccak256(\r\n                        abi.encodePacked(uint40(commitLastBlock), commit)\r\n                    ),\r\n                    27,\r\n                    r,\r\n                    s\r\n                ) ||\r\n                secretSigner ==\r\n                ecrecover(\r\n                    keccak256(\r\n                        abi.encodePacked(uint40(commitLastBlock), commit)\r\n                    ),\r\n                    28,\r\n                    r,\r\n                    s\r\n                ),\r\n            \"ECDSA signature is not valid.\"\r\n        );\r\n\r\n        if (totalDividends >= DIVIDENDS_LIMIT) {\r\n            sendDividends();\r\n        }\r\n\r\n        uint256 totalPercentages = HOUSE_EDGE_PERCENT +\r\n            ADVERTISE_PERCENT +\r\n            DIVIDENDS_PERCENT;\r\n        uint256 houseEdge = (amount * totalPercentages) / PERCENTAGES_BASE;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        totalDividends += (amount * DIVIDENDS_PERCENT) / PERCENTAGES_BASE;\r\n        totalAdvertise += (amount * ADVERTISE_PERCENT) / PERCENTAGES_BASE;\r\n\r\n        uint256 possibleWinAmount = ticketsCount *\r\n            TICKET_PRICE *\r\n            averageLotteryLock; // lock average possible win\r\n\r\n        // check if we can pay max profit for 1 ticket\r\n        require(\r\n            TICKET_PRICE * 100 <= address(this).balance,\r\n            \"Can't pay max profit\"\r\n        );\r\n        require(\r\n            possibleWinAmount <= amount + maxProfitLottery,\r\n            \"maxProfit limit violation.\"\r\n        );\r\n\r\n        lockedInBetsLottery += uint128(possibleWinAmount);\r\n\r\n        require(\r\n            jackpotSizeLottery + lockedInBetsLottery <= address(this).balance,\r\n            \"Cannot afford to lose this bet.\"\r\n        );\r\n\r\n        ticket.count = ticketsCount;\r\n        ticket.amount = ticketsCount * TICKET_PRICE - houseEdge;\r\n        ticket.placeBlockNumber = uint40(block.number);\r\n        ticket.gambler = msg.sender;\r\n        ticket.locked = uint128(possibleWinAmount);\r\n        ticket.clientSeed = clientSeed;\r\n\r\n        lastTicketTime = now;\r\n\r\n        emit CommitLottery(commit, clientSeed, amount);\r\n    }\r\n\r\n    function processTickets(uint256 reveal) external onlyCroupier {\r\n        uint256 commit = uint256(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Ticket storage ticket = tickets[commit];\r\n        uint256 placeBlockNumber = ticket.placeBlockNumber;\r\n\r\n        require(\r\n            block.number > placeBlockNumber,\r\n            \"settleBet in the same block as placeBet, or before.\"\r\n        );\r\n        require(\r\n            block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS,\r\n            \"Blockhash can't be queried by EVM.\"\r\n        );\r\n\r\n        _processTickets(ticket, reveal);\r\n    }\r\n\r\n    function _processTickets(Ticket storage ticket, uint256 reveal) private {\r\n        bytes32 entropy;\r\n        uint256[] memory ticketsWins = new uint256[](ticket.count);\r\n        uint256 ticketNumber;\r\n        uint256 winRate;\r\n        uint256 totalRate = 0;\r\n        uint256 jackpotWin = 0;\r\n        uint256 zeroTickets = 0;\r\n        uint256 commit = uint256(keccak256(abi.encodePacked(reveal)));\r\n\r\n        for (uint8 index = 0; index < ticket.count; index += 1) {\r\n            entropy = keccak256(\r\n                abi.encodePacked(reveal, ticket.clientSeed, index)\r\n            );\r\n            ticketNumber = uint256(entropy) % 2000;\r\n            winRate = checkForTicketWin(ticketNumber);\r\n            ticketsWins[index] = ticketNumber;\r\n            totalRate += winRate;\r\n\r\n            if (winRate == 0) {\r\n                zeroTickets += 1;\r\n            }\r\n\r\n            jackpotWin += checkJackPotWin(entropy, ticketNumber, 1);\r\n            if (jackpotWin > 0) {\r\n                emit JackpotLotteryPayment(ticket.gambler, commit, jackpotWin);\r\n            }\r\n        }\r\n\r\n        if (zeroTickets != 0) {\r\n            jackpotSizeLottery += (zeroTickets * TICKET_PRICE) / 2;\r\n        }\r\n\r\n        lockedInBetsLottery -= uint128(ticket.locked);\r\n\r\n        uint256 winAmount = ((ticket.amount / ticket.count) * totalRate) /\r\n            10 +\r\n            jackpotWin;\r\n\r\n        sendFundsLottery(\r\n            ticket.gambler,\r\n            winAmount == 0 ? 1 wei : winAmount,\r\n            commit,\r\n            \"payment\",\r\n            ticketsWins\r\n        );\r\n    }\r\n\r\n    function checkJackPotWin(\r\n        bytes32 entropy,\r\n        uint256 randMod,\r\n        uint8 game\r\n    ) internal returns (uint256 jackpotWin) {\r\n        jackpotWin = 0;\r\n        uint256 jackpotRng = (uint256(entropy) / randMod) % JACKPOT_MODULO;\r\n\r\n        if (game == 0) {\r\n            if (jackpotRng == luckyNumberSicbo) {\r\n                jackpotWin = jackpotSizeSicbo;\r\n                jackpotSizeSicbo = 0;\r\n            }\r\n        } else {\r\n            if (jackpotRng == luckyNumberLottery) {\r\n                jackpotWin = jackpotSizeLottery;\r\n                jackpotSizeLottery = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function sendFundsLottery(\r\n        address payable beneficiary,\r\n        uint256 amount,\r\n        uint256 commit,\r\n        string memory paymentType,\r\n        uint256[] memory numbers\r\n    ) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit PaymentLottery(\r\n                beneficiary,\r\n                commit,\r\n                amount,\r\n                paymentType,\r\n                numbers\r\n            );\r\n        } else {\r\n            emit PaymentLottery(\r\n                beneficiary,\r\n                commit,\r\n                amount,\r\n                paymentType,\r\n                numbers\r\n            );\r\n        }\r\n    }\r\n\r\n    function sendFundsSicbo(\r\n        address payable beneficiary,\r\n        uint256 amount,\r\n        uint256 commit,\r\n        string memory paymentType\r\n    ) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit PaymentSicbo(beneficiary, commit, amount, paymentType);\r\n        } else {\r\n            emit PaymentSicbo(beneficiary, commit, amount, paymentType);\r\n        }\r\n    }\r\n\r\n    function refundLotteryBet(uint256 commit) external {\r\n        Ticket storage ticket = tickets[commit];\r\n        uint256 amount = ticket.amount;\r\n\r\n        require(amount != 0, \"Bet should be in an 'active' state\");\r\n        require(\r\n            block.number > ticket.placeBlockNumber + BET_EXPIRATION_BLOCKS,\r\n            \"Blockhash can't be queried by EVM.\"\r\n        );\r\n\r\n        ticket.amount = 0;\r\n        lockedInBetsLottery -= ticket.locked;\r\n\r\n        uint256[] memory tmp;\r\n        sendFundsLottery(ticket.gambler, amount, commit, \"refund\", tmp);\r\n    }\r\n\r\n    function refundBetSicbo(uint256 commit) external {\r\n        Bet storage bet = bets[commit];\r\n        uint256 amount = bet.totalBetAmount;\r\n\r\n        require(amount != 0, \"Bet should be in an 'active' state\");\r\n        require(\r\n            block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS,\r\n            \"Blockhash can't be queried by EVM.\"\r\n        );\r\n\r\n        bet.totalBetAmount = 0;\r\n\r\n        for (uint8 index = 0; index < bet.betsCount; index += 1) {\r\n            bet.amount[index] = 0;\r\n        }\r\n\r\n        lockedInBetsSicbo -= bet.locked;\r\n\r\n        if (amount >= MIN_JACKPOT_BET && jackpotSizeSicbo > JACKPOT_FEE) {\r\n            jackpotSizeSicbo -= uint128(JACKPOT_FEE);\r\n        }\r\n\r\n        sendFundsSicbo(bet.gambler, amount, commit, \"refund\");\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sumPayput\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADVERTISE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyNumberLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_JACKPOT_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"he\",\"type\":\"uint256\"},{\"name\":\"mjb\",\"type\":\"uint256\"},{\"name\":\"jf\",\"type\":\"uint256\"},{\"name\":\"mb\",\"type\":\"uint256\"},{\"name\":\"ma\",\"type\":\"uint256\"},{\"name\":\"al\",\"type\":\"uint8\"}],\"name\":\"setAdditionalVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betType\",\"type\":\"uint8[]\"},{\"name\":\"betNums\",\"type\":\"uint256[]\"},{\"name\":\"betAmount\",\"type\":\"uint256[]\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"clientSeed\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"},{\"name\":\"game\",\"type\":\"uint8\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TICKET_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusProgrammAccumulated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xEtherTokensContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TICKET_MAX_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"},{\"name\":\"newSecretSigner\",\"type\":\"address\"},{\"name\":\"newModerator\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moderator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gambler\",\"type\":\"address\"}],\"name\":\"getBonusProgrammLevel\",\"outputs\":[{\"name\":\"discount\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"xEtherContract\",\"type\":\"address\"}],\"name\":\"setXEtherContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"increaseAmount\",\"type\":\"uint256\"},{\"name\":\"game\",\"type\":\"uint8\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBetSicbo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSizeLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"croupier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMaxTickets\",\"type\":\"uint8\"}],\"name\":\"changeMaxTickets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sicboTableLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawAdvertiseFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSizeSicbo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stopGames\",\"type\":\"uint8\"}],\"name\":\"stopGames\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseLockedInBetLotteryAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseLockedInBetSicboAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"clientSeed\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBetsSicbo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAdvertise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseEdgePercent\",\"type\":\"uint8\"},{\"name\":\"newDividendsPercent\",\"type\":\"uint8\"},{\"name\":\"newAdvertPercent\",\"type\":\"uint8\"}],\"name\":\"setNewPercents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendDividends\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundLotteryBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_MINIMUM_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamesStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTableLimit\",\"type\":\"uint256\"}],\"name\":\"setTableLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"}],\"name\":\"processTickets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawLotteryJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBetsLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitSicbo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"end\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDENDS_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyNumberSicbo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"numbers\",\"type\":\"uint256[]\"}],\"name\":\"PaymentLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentType\",\"type\":\"string\"}],\"name\":\"PaymentSicbo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotSicboPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotLotteryPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayDividendsSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayDividendsFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"clientSeed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CommitLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"clientSeed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CommitSicbo\",\"type\":\"event\"}]","ContractName":"XetherSicboLottery","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://498ac01033ea0a8c40a47f5a11b6c9ce8bf0995bd2ae90b72df3acf6d6e0089e"}]}