{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    Owned contract interface\n*/\ninterface IOwned {\n    // this function isn't since the compiler emits automatically generated getter functions as external\n    function owner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external;\n    function acceptOwnership() external;\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n\n\npragma solidity 0.6.12;\n\n\n/*\n    Converter Anchor interface\n*/\ninterface IConverterAnchor is IOwned {\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    ERC20 Standard Token interface\n*/\ninterface IERC20Token {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n}\n\n// File: solidity/contracts/utility/interfaces/IWhitelist.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    Whitelist interface\n*/\ninterface IWhitelist {\n    function isWhitelisted(address _address) external view returns (bool);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverter.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n\n/*\n    Converter interface\n*/\ninterface IConverter is IOwned {\n    function converterType() external pure returns (uint16);\n    function anchor() external view returns (IConverterAnchor);\n    function isActive() external view returns (bool);\n\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) external view returns (uint256, uint256);\n    function convert(IERC20Token _sourceToken,\n                     IERC20Token _targetToken,\n                     uint256 _amount,\n                     address _trader,\n                     address payable _beneficiary) external payable returns (uint256);\n\n    function conversionWhitelist() external view returns (IWhitelist);\n    function conversionFee() external view returns (uint32);\n    function maxConversionFee() external view returns (uint32);\n    function reserveBalance(IERC20Token _reserveToken) external view returns (uint256);\n    receive() external payable;\n\n    function transferAnchorOwnership(address _newOwner) external;\n    function acceptAnchorOwnership() external;\n    function setConversionFee(uint32 _conversionFee) external;\n    function setConversionWhitelist(IWhitelist _whitelist) external;\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\n    function withdrawETH(address payable _to) external;\n    function addReserve(IERC20Token _token, uint32 _ratio) external;\n\n    // deprecated, backward compatibility\n    function token() external view returns (IConverterAnchor);\n    function transferTokenOwnership(address _newOwner) external;\n    function acceptTokenOwnership() external;\n    function connectors(IERC20Token _address) external view returns (uint256, uint32, bool, bool, bool);\n    function getConnectorBalance(IERC20Token _connectorToken) external view returns (uint256);\n    function connectorTokens(uint256 _index) external view returns (IERC20Token);\n    function connectorTokenCount() external view returns (uint16);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterUpgrader.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    Converter Upgrader interface\n*/\ninterface IConverterUpgrader {\n    function upgrade(bytes32 _version) external;\n    function upgrade(uint16 _version) external;\n}\n\n// File: solidity/contracts/converter/interfaces/IBancorFormula.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    Bancor Formula interface\n*/\ninterface IBancorFormula {\n    function purchaseTargetAmount(uint256 _supply,\n                                  uint256 _reserveBalance,\n                                  uint32 _reserveWeight,\n                                  uint256 _amount)\n                                  external view returns (uint256);\n\n    function saleTargetAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveWeight,\n                              uint256 _amount)\n                              external view returns (uint256);\n\n    function crossReserveTargetAmount(uint256 _sourceReserveBalance,\n                                      uint32 _sourceReserveWeight,\n                                      uint256 _targetReserveBalance,\n                                      uint32 _targetReserveWeight,\n                                      uint256 _amount)\n                                      external view returns (uint256);\n\n    function fundCost(uint256 _supply,\n                      uint256 _reserveBalance,\n                      uint32 _reserveRatio,\n                      uint256 _amount)\n                      external view returns (uint256);\n\n    function fundSupplyAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveRatio,\n                              uint256 _amount)\n                              external view returns (uint256);\n\n    function liquidateReserveAmount(uint256 _supply,\n                                    uint256 _reserveBalance,\n                                    uint32 _reserveRatio,\n                                    uint256 _amount)\n                                    external view returns (uint256);\n\n    function balancedWeights(uint256 _primaryReserveStakedBalance,\n                             uint256 _primaryReserveBalance,\n                             uint256 _secondaryReserveBalance,\n                             uint256 _reserveRateNumerator,\n                             uint256 _reserveRateDenominator)\n                             external view returns (uint32, uint32);\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\n\r\npragma solidity 0.6.12;\r\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public override owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public override ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() override public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\n\n// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    Contract Registry interface\n*/\ninterface IContractRegistry {\n    function addressOf(bytes32 _contractName) external view returns (address);\n}\n\n// File: solidity/contracts/utility/ContractRegistryClient.sol\n\n\r\npragma solidity 0.6.12;\r\r\r\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = \"ChainlinkOracleWhitelist\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(address(_registry)) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != registry && address(newRegistry) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/ReentrancyGuard.sol\n\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev ReentrancyGuard\r\n  *\r\n  * The contract provides protection against re-entrancy - calling a function (directly or\r\n  * indirectly) from within itself.\r\n*/\r\ncontract ReentrancyGuard {\r\n    // true while protected code is being executed, false otherwise\r\n    bool private locked = false;\r\n\r\n    /**\r\n      * @dev ensures instantiation only by sub-contracts\r\n    */\r\n    constructor() internal {}\r\n\r\n    // protects a function against reentrancy attacks\r\n    modifier protected() {\r\n        _protected();\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _protected() internal view {\r\n        require(!locked, \"ERR_REENTRANCY\");\r\n    }\r\n}\n\n// File: solidity/contracts/utility/SafeMath.sol\n\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\n\npragma solidity 0.6.12;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _spender approved address\n      * @param _value   allowance amount\n    */\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\n    }\n}\n\n// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\n\n\npragma solidity 0.6.12;\n\n\n\n/*\n    Token Holder interface\n*/\ninterface ITokenHolder is IOwned {\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\n}\n\n// File: solidity/contracts/utility/TokenHolder.sol\n\n\r\npragma solidity 0.6.12;\r\r\r\r\r\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        virtual\r\n        override\r\n        ownerOnly\r\n        validAddress(address(_token))\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\n\n// File: solidity/contracts/token/interfaces/IEtherToken.sol\n\n\npragma solidity 0.6.12;\n\n\n/*\n    Ether Token interface\n*/\ninterface IEtherToken is IERC20Token {\n    function deposit() external payable;\n    function withdraw(uint256 _amount) external;\n    function depositTo(address _to) external payable;\n    function withdrawTo(address payable _to, uint256 _amount) external;\n}\n\n// File: solidity/contracts/bancorx/interfaces/IBancorX.sol\n\n\npragma solidity 0.6.12;\n\n\ninterface IBancorX {\n    function token() external view returns (IERC20Token);\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) external;\n    function getXTransferAmount(uint256 _xTransferId, address _for) external view returns (uint256);\n}\n\n// File: solidity/contracts/converter/ConverterBase.sol\n\n\r\npragma solidity 0.6.12;\r\r\r\r\r\r\r\r\r\r\r\r\n\r\n/**\r\n  * @dev ConverterBase\r\n  *\r\n  * The converter contains the main logic for conversions between different ERC20 tokens.\r\n  *\r\n  * It is also the upgradable part of the mechanism (note that upgrades are opt-in).\r\n  *\r\n  * The anchor must be set on construction and cannot be changed afterwards.\r\n  * Wrappers are provided for some of the anchor's functions, for easier access.\r\n  *\r\n  * Once the converter accepts ownership of the anchor, it becomes the anchor's sole controller\r\n  * and can execute any of its functions.\r\n  *\r\n  * To upgrade the converter, anchor ownership must be transferred to a new converter, along with\r\n  * any relevant data.\r\n  *\r\n  * Note that the converter can transfer anchor ownership to a new converter that\r\n  * doesn't allow upgrades anymore, for finalizing the relationship between the converter\r\n  * and the anchor.\r\n  *\r\n  * Converter types (defined as uint16 type) -\r\n  * 0 = liquid token converter\r\n  * 1 = liquidity pool v1 converter\r\n  * 2 = liquidity pool v2 converter\r\n  *\r\n  * Note that converters don't currently support tokens with transfer fees.\r\n*/\r\nabstract contract ConverterBase is IConverter, TokenHandler, TokenHolder, ContractRegistryClient, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint32 internal constant PPM_RESOLUTION = 1000000;\r\n    IERC20Token internal constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    struct Reserve {\r\n        uint256 balance;    // reserve balance\r\n        uint32 weight;      // reserve weight, represented in ppm, 1-1000000\r\n        bool deprecated1;   // deprecated\r\n        bool deprecated2;   // deprecated\r\n        bool isSet;         // true if the reserve is valid, false otherwise\r\n    }\r\n\r\n    /**\r\n      * @dev version number\r\n    */\r\n    uint16 public constant version = 40;\r\n\r\n    IConverterAnchor public override anchor;            // converter anchor contract\r\n    IWhitelist public override conversionWhitelist;     // whitelist contract with list of addresses that are allowed to use the converter\r\n    IERC20Token[] public reserveTokens;                 // ERC20 standard token addresses (prior version 17, use 'connectorTokens' instead)\r\n    mapping (IERC20Token => Reserve) public reserves;   // reserve token addresses -> reserve data (prior version 17, use 'connectors' instead)\r\n    uint32 public reserveRatio = 0;                     // ratio between the reserves and the market cap, equal to the total reserve weights\r\n    uint32 public override maxConversionFee = 0;        // maximum conversion fee for the lifetime of the contract,\r\n                                                        // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\r\n    uint32 public override conversionFee = 0;           // current conversion fee, represented in ppm, 0...maxConversionFee\r\n    bool public constant conversionsEnabled = true;     // deprecated, backward compatibility\r\n\r\n    /**\r\n      * @dev triggered when the converter is activated\r\n      *\r\n      * @param _type        converter type\r\n      * @param _anchor      converter anchor\r\n      * @param _activated   true if the converter was activated, false if it was deactivated\r\n    */\r\n    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\r\n\r\n    /**\r\n      * @dev triggered when a conversion between two tokens occurs\r\n      *\r\n      * @param _fromToken       source ERC20 token\r\n      * @param _toToken         target ERC20 token\r\n      * @param _trader          wallet that initiated the trade\r\n      * @param _amount          amount converted, in the source token\r\n      * @param _return          amount returned, minus conversion fee\r\n      * @param _conversionFee   conversion fee\r\n    */\r\n    event Conversion(\r\n        IERC20Token indexed _fromToken,\r\n        IERC20Token indexed _toToken,\r\n        address indexed _trader,\r\n        uint256 _amount,\r\n        uint256 _return,\r\n        int256 _conversionFee\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the rate between two tokens in the converter changes\r\n      * note that the event might be dispatched for rate updates between any two tokens in the converter\r\n      * note that prior to version 28, you should use the 'PriceDataUpdate' event instead\r\n      *\r\n      * @param  _token1 address of the first token\r\n      * @param  _token2 address of the second token\r\n      * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\r\n      * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\r\n    */\r\n    event TokenRateUpdate(\r\n        IERC20Token indexed _token1,\r\n        IERC20Token indexed _token2,\r\n        uint256 _rateN,\r\n        uint256 _rateD\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the conversion fee is updated\r\n      *\r\n      * @param  _prevFee    previous fee percentage, represented in ppm\r\n      * @param  _newFee     new fee percentage, represented in ppm\r\n    */\r\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\r\n\r\n    /**\r\n      * @dev used by sub-contracts to initialize a new converter\r\n      *\r\n      * @param  _anchor             anchor governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IConverterAnchor _anchor,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        validAddress(address(_anchor))\r\n        ContractRegistryClient(_registry)\r\n        internal\r\n        validConversionFee(_maxConversionFee)\r\n    {\r\n        anchor = _anchor;\r\n        maxConversionFee = _maxConversionFee;\r\n    }\r\n\r\n    // ensures that the converter is active\r\n    modifier active() {\r\n        _active();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _active() internal view {\r\n        require(isActive(), \"ERR_INACTIVE\");\r\n    }\r\n\r\n    // ensures that the converter is not active\r\n    modifier inactive() {\r\n        _inactive();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _inactive() internal view {\r\n        require(!isActive(), \"ERR_ACTIVE\");\r\n    }\r\n\r\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\r\n    modifier validReserve(IERC20Token _address) {\r\n        _validReserve(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserve(IERC20Token _address) internal view {\r\n        require(reserves[_address].isSet, \"ERR_INVALID_RESERVE\");\r\n    }\r\n\r\n    // validates conversion fee\r\n    modifier validConversionFee(uint32 _conversionFee) {\r\n        _validConversionFee(_conversionFee);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validConversionFee(uint32 _conversionFee) internal pure {\r\n        require(_conversionFee <= PPM_RESOLUTION, \"ERR_INVALID_CONVERSION_FEE\");\r\n    }\r\n\r\n    // validates reserve weight\r\n    modifier validReserveWeight(uint32 _weight) {\r\n        _validReserveWeight(_weight);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserveWeight(uint32 _weight) internal pure {\r\n        require(_weight > 0 && _weight <= PPM_RESOLUTION, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n    }\r\n\r\n    // overrides interface declaration\r\n    function converterType() public pure virtual override returns (uint16);\r\n\r\n    // overrides interface declaration\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256, uint256);\r\n\r\n    /**\r\n      * @dev deposits ether\r\n      * can only be called if the converter has an ETH reserve\r\n    */\r\n    receive() external override payable {\r\n        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\r\n        // a workaround for a problem when running solidity-coverage\r\n        // see https://github.com/sc-forks/solidity-coverage/issues/487\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws ether\r\n      * can only be called by the owner if the converter is inactive or by upgrader contract\r\n      * can only be called after the upgrader contract has accepted the ownership of this contract\r\n      * can only be called if the converter has an ETH reserve\r\n      *\r\n      * @param _to  address to send the ETH to\r\n    */\r\n    function withdrawETH(address payable _to)\r\n        public\r\n        override\r\n        protected\r\n        ownerOnly\r\n        validReserve(ETH_RESERVE_ADDRESS)\r\n    {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        _to.transfer(address(this).balance);\r\n\r\n        // sync the ETH reserve balance\r\n        syncReserveBalance(ETH_RESERVE_ADDRESS);\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter version is 28 or higher\r\n      *\r\n      * @return true, since the converter version is 28 or higher\r\n    */\r\n    function isV28OrHigher() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to update & enable the conversion whitelist contract address\r\n      * when set, only addresses that are whitelisted are actually allowed to use the converter\r\n      * note that the whitelist check is actually done by the BancorNetwork contract\r\n      *\r\n      * @param _whitelist    address of a whitelist contract\r\n    */\r\n    function setConversionWhitelist(IWhitelist _whitelist)\r\n        public\r\n        override\r\n        ownerOnly\r\n        notThis(address(_whitelist))\r\n    {\r\n        conversionWhitelist = _whitelist;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if the converter is active, false otherwise\r\n      *\r\n      * @return true if the converter is active, false otherwise\r\n    */\r\n    function isActive() public view virtual override returns (bool) {\r\n        return anchor.owner() == address(this);\r\n    }\r\n\r\n    /**\r\n      * @dev transfers the anchor ownership\r\n      * the new owner needs to accept the transfer\r\n      * can only be called by the converter upgrder while the upgrader is the owner\r\n      * note that prior to version 28, you should use 'transferAnchorOwnership' instead\r\n      *\r\n      * @param _newOwner    new token owner\r\n    */\r\n    function transferAnchorOwnership(address _newOwner)\r\n        public\r\n        override\r\n        ownerOnly\r\n        only(CONVERTER_UPGRADER)\r\n    {\r\n        anchor.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * most converters are also activated as soon as they accept the anchor ownership\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public virtual override ownerOnly {\r\n        // verify the the converter has at least one reserve\r\n        require(reserveTokenCount() > 0, \"ERR_INVALID_RESERVE_COUNT\");\r\n        anchor.acceptOwnership();\r\n        syncReserveBalances();\r\n    }\r\n\r\n    /**\r\n      * @dev updates the current conversion fee\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _conversionFee new conversion fee, represented in ppm\r\n    */\r\n    function setConversionFee(uint32 _conversionFee) public override ownerOnly {\r\n        require(_conversionFee <= maxConversionFee, \"ERR_INVALID_CONVERSION_FEE\");\r\n        emit ConversionFeeUpdate(conversionFee, _conversionFee);\r\n        conversionFee = _conversionFee;\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the converter and sends them to an account\r\n      * can only be called by the owner\r\n      * note that reserve tokens can only be withdrawn by the owner while the converter is inactive\r\n      * unless the owner is the converter upgrader contract\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        override(IConverter, TokenHolder)\r\n        protected\r\n        ownerOnly\r\n    {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // if the token is not a reserve token, allow withdrawal\r\n        // otherwise verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!reserves[_token].isSet || !isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        super.withdrawTokens(_token, _to, _amount);\r\n\r\n        // if the token is a reserve token, sync the reserve balance\r\n        if (reserves[_token].isSet)\r\n            syncReserveBalance(_token);\r\n    }\r\n\r\n    /**\r\n      * @dev upgrades the converter to the latest version\r\n      * can only be called by the owner\r\n      * note that the owner needs to call acceptOwnership on the new converter after the upgrade\r\n    */\r\n    function upgrade() public ownerOnly {\r\n        IConverterUpgrader converterUpgrader = IConverterUpgrader(addressOf(CONVERTER_UPGRADER));\r\n\r\n        // trigger de-activation event\r\n        emit Activation(converterType(), anchor, false);\r\n\r\n        transferOwnership(address(converterUpgrader));\r\n        converterUpgrader.upgrade(version);\r\n        acceptOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of reserve tokens defined\r\n      * note that prior to version 17, you should use 'connectorTokenCount' instead\r\n      *\r\n      * @return number of reserve tokens\r\n    */\r\n    function reserveTokenCount() public view returns (uint16) {\r\n        return uint16(reserveTokens.length);\r\n    }\r\n\r\n    /**\r\n      * @dev defines a new reserve token for the converter\r\n      * can only be called by the owner while the converter is inactive\r\n      *\r\n      * @param _token   address of the reserve token\r\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _weight)\r\n        public\r\n        virtual\r\n        override\r\n        ownerOnly\r\n        inactive\r\n        validAddress(address(_token))\r\n        notThis(address(_token))\r\n        validReserveWeight(_weight)\r\n    {\r\n        // validate input\r\n        require(address(_token) != address(anchor) && !reserves[_token].isSet, \"ERR_INVALID_RESERVE\");\r\n        require(_weight <= PPM_RESOLUTION - reserveRatio, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n        require(reserveTokenCount() < uint16(-1), \"ERR_INVALID_RESERVE_COUNT\");\r\n\r\n        Reserve storage newReserve = reserves[_token];\r\n        newReserve.balance = 0;\r\n        newReserve.weight = _weight;\r\n        newReserve.isSet = true;\r\n        reserveTokens.push(_token);\r\n        reserveRatio += _weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's weight\r\n      * added in version 28\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve weight\r\n    */\r\n    function reserveWeight(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint32)\r\n    {\r\n        return reserves[_reserveToken].weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's balance\r\n      * note that prior to version 17, you should use 'getConnectorBalance' instead\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve balance\r\n    */\r\n    function reserveBalance(IERC20Token _reserveToken)\r\n        public\r\n        override\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        return reserves[_reserveToken].balance;\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter has an ETH reserve\r\n      *\r\n      * @return true if the converter has an ETH reserve, false otherwise\r\n    */\r\n    function hasETHReserve() public view returns (bool) {\r\n        return reserves[ETH_RESERVE_ADDRESS].isSet;\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function convert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address payable _beneficiary)\r\n        public\r\n        override\r\n        payable\r\n        protected\r\n        only(BANCOR_NETWORK)\r\n        returns (uint256)\r\n    {\r\n        // validate input\r\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\r\n\r\n        // if a whitelist is set, verify that both and trader and the beneficiary are whitelisted\r\n        require(address(conversionWhitelist) == address(0) ||\r\n                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\r\n                \"ERR_NOT_WHITELISTED\");\r\n\r\n        return doConvert(_sourceToken, _targetToken, _amount, _trader, _beneficiary);\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * called by ConverterBase and allows the inherited contracts to implement custom conversion logic\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(\r\n        IERC20Token _sourceToken,\r\n        IERC20Token _targetToken,\r\n        uint256 _amount,\r\n        address _trader,\r\n        address payable _beneficiary)\r\n        internal\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /**\r\n      * @dev returns the conversion fee for a given target amount\r\n      *\r\n      * @param _targetAmount  target amount\r\n      *\r\n      * @return conversion fee\r\n    */\r\n    function calculateFee(uint256 _targetAmount) internal view returns (uint256) {\r\n        return _targetAmount.mul(conversionFee).div(PPM_RESOLUTION);\r\n    }\r\n\r\n    /**\r\n      * @dev syncs the stored reserve balance for a given reserve with the real reserve balance\r\n      *\r\n      * @param _reserveToken    address of the reserve token\r\n    */\r\n    function syncReserveBalance(IERC20Token _reserveToken) internal validReserve(_reserveToken) {\r\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\r\n            reserves[_reserveToken].balance = address(this).balance;\r\n        else\r\n            reserves[_reserveToken].balance = _reserveToken.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n      * @dev syncs all stored reserve balances\r\n    */\r\n    function syncReserveBalances() internal {\r\n        uint256 reserveCount = reserveTokens.length;\r\n        for (uint256 i = 0; i < reserveCount; i++)\r\n            syncReserveBalance(reserveTokens[i]);\r\n    }\r\n\r\n    /**\r\n      * @dev helper, dispatches the Conversion event\r\n      *\r\n      * @param _sourceToken     source ERC20 token\r\n      * @param _targetToken     target ERC20 token\r\n      * @param _trader          address of the caller who executed the conversion\r\n      * @param _amount          amount purchased/sold (in the source token)\r\n      * @param _returnAmount    amount returned (in the target token)\r\n    */\r\n    function dispatchConversionEvent(\r\n        IERC20Token _sourceToken,\r\n        IERC20Token _targetToken,\r\n        address _trader,\r\n        uint256 _amount,\r\n        uint256 _returnAmount,\r\n        uint256 _feeAmount)\r\n        internal\r\n    {\r\n        // fee amount is converted to 255 bits -\r\n        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\r\n        // currently the fee is always taken from the target token\r\n        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\r\n        assert(_feeAmount < 2 ** 255);\r\n        emit Conversion(_sourceToken, _targetToken, _trader, _amount, _returnAmount, int256(_feeAmount));\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\r\n    */\r\n    function token() public view override returns (IConverterAnchor) {\r\n        return anchor;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public override ownerOnly {\r\n        transferAnchorOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function acceptTokenOwnership() public override ownerOnly {\r\n        acceptAnchorOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectors(IERC20Token _address) public view override returns (uint256, uint32, bool, bool, bool) {\r\n        Reserve memory reserve = reserves[_address];\r\n        return(reserve.balance, reserve.weight, false, false, reserve.isSet);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokens(uint256 _index) public view override returns (IERC20Token) {\r\n        return ConverterBase.reserveTokens[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokenCount() public view override returns (uint16) {\r\n        return reserveTokenCount();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view override returns (uint256) {\r\n        return reserveBalance(_connectorToken);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getReturn(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256) {\r\n        return targetAmountAndFee(_sourceToken, _targetToken, _amount);\r\n    }\r\n}\n\n// File: solidity/contracts/token/interfaces/IDSToken.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n/*\n    DSToken interface\n*/\ninterface IDSToken is IConverterAnchor, IERC20Token {\n    function issue(address _to, uint256 _amount) external;\n    function destroy(address _from, uint256 _amount) external;\n}\n\n// File: solidity/contracts/converter/types/liquid-token/LiquidTokenConverter.sol\n\n\r\npragma solidity 0.6.12;\r\r\r\n\r\n/**\r\n  * @dev Liquid Token Converter\r\n  *\r\n  * The liquid token converter is a specialized version of a converter that manages a liquid token.\r\n  *\r\n  * The converters govern a token with a single reserve and allow converting between the two.\r\n  * Liquid tokens usually have fractional reserve (reserve ratio smaller than 100%).\r\n*/\r\ncontract LiquidTokenConverter is ConverterBase {\r\n    /**\r\n      * @dev initializes a new LiquidTokenConverter instance\r\n      *\r\n      * @param  _token              liquid token governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IDSToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        ConverterBase(_token, _registry, _maxConversionFee)\r\n        public\r\n    {\r\n    }\r\n\r\n    /**\r\n      * @dev returns the converter type\r\n      *\r\n      * @return see the converter types in the the main contract doc\r\n    */\r\n    function converterType() public pure override returns (uint16) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * also activates the converter\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public override ownerOnly {\r\n        super.acceptAnchorOwnership();\r\n\r\n        emit Activation(converterType(), anchor, true);\r\n    }\r\n\r\n    /**\r\n      * @dev defines the reserve token for the converter\r\n      * can only be called by the owner while the converter is inactive and the\r\n      * reserve wasn't defined yet\r\n      *\r\n      * @param _token   address of the reserve token\r\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _weight) public override ownerOnly {\r\n        // verify that the converter doesn't have a reserve yet\r\n        require(reserveTokenCount() == 0, \"ERR_INVALID_RESERVE_COUNT\");\r\n        super.addReserve(_token, _weight);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of converting the source token to the\r\n      * target token along with the fee\r\n      *\r\n      * @param _sourceToken contract address of the source token\r\n      * @param _targetToken contract address of the target token\r\n      * @param _amount      amount of tokens received from the user\r\n      *\r\n      * @return expected target amount\r\n      * @return expected fee\r\n    */\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view override returns (uint256, uint256) {\r\n        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet)\r\n            return purchaseTargetAmount(_amount);\r\n        if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet)\r\n            return saleTargetAmount(_amount);\r\n\r\n        // invalid input\r\n        revert(\"ERR_INVALID_TOKEN\");\r\n    }\r\n\r\n    /**\r\n      * @dev converts between the liquid token and its reserve\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address payable _beneficiary)\r\n        internal\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 targetAmount;\r\n        IERC20Token reserveToken;\r\n\r\n        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\r\n            reserveToken = _sourceToken;\r\n            targetAmount = buy(_amount, _trader, _beneficiary);\r\n        }\r\n        else if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet) {\r\n            reserveToken = _targetToken;\r\n            targetAmount = sell(_amount, _trader, _beneficiary);\r\n        }\r\n        else {\r\n            // invalid input\r\n            revert(\"ERR_INVALID_TOKEN\");\r\n        }\r\n\r\n        // dispatch rate update for the liquid token\r\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\r\n        uint32 reserveWeight = reserves[reserveToken].weight;\r\n        emit TokenRateUpdate(IDSToken(address(anchor)), reserveToken, reserveBalance(reserveToken).mul(PPM_RESOLUTION), totalSupply.mul(reserveWeight));\r\n\r\n        return targetAmount;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of buying with a given amount of tokens\r\n      *\r\n      * @param _amount  amount of reserve tokens to get the target amount for\r\n      *\r\n      * @return amount of liquid tokens that the user will receive\r\n      * @return amount of liquid tokens that the user will pay as fee\r\n    */\r\n    function purchaseTargetAmount(uint256 _amount)\r\n        internal\r\n        view\r\n        active\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // if the current supply is zero, then return the input amount divided by the normalized reserve-weight\r\n        if (totalSupply == 0)\r\n            return (_amount.mul(PPM_RESOLUTION).div(reserves[reserveToken].weight), 0);\r\n\r\n        uint256 amount = IBancorFormula(addressOf(BANCOR_FORMULA)).purchaseTargetAmount(\r\n            totalSupply,\r\n            reserveBalance(reserveToken),\r\n            reserves[reserveToken].weight,\r\n            _amount\r\n        );\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        uint256 fee = calculateFee(amount);\r\n        return (amount - fee, fee);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of selling a given amount of tokens\r\n      *\r\n      * @param _amount  amount of liquid tokens to get the target amount for\r\n      *\r\n      * @return expected reserve tokens\r\n      * @return expected fee\r\n    */\r\n    function saleTargetAmount(uint256 _amount)\r\n        internal\r\n        view\r\n        active\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\r\n\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // if selling the entire supply, then return the entire reserve\r\n        if (totalSupply == _amount)\r\n            return (reserveBalance(reserveToken), 0);\r\n\r\n        uint256 amount = IBancorFormula(addressOf(BANCOR_FORMULA)).saleTargetAmount(\r\n            totalSupply,\r\n            reserveBalance(reserveToken),\r\n            reserves[reserveToken].weight,\r\n            _amount\r\n        );\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        uint256 fee = calculateFee(amount);\r\n        return (amount - fee, fee);\r\n    }\r\n\r\n    /**\r\n      * @dev buys the liquid token by depositing in its reserve\r\n      *\r\n      * @param _amount      amount of reserve token to buy the token for\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of liquid tokens received\r\n    */\r\n    function buy(uint256 _amount, address _trader, address _beneficiary) internal returns (uint256) {\r\n        // get expected target amount and fee\r\n        (uint256 amount, uint256 fee) = purchaseTargetAmount(_amount);\r\n\r\n        // ensure the trade gives something in return\r\n        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\r\n\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // ensure that the input amount was already deposited\r\n        if (reserveToken == ETH_RESERVE_ADDRESS)\r\n            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n        else\r\n            require(msg.value == 0 && reserveToken.balanceOf(address(this)).sub(reserveBalance(reserveToken)) >= _amount, \"ERR_INVALID_AMOUNT\");\r\n\r\n        // sync the reserve balance\r\n        syncReserveBalance(reserveToken);\r\n\r\n        // issue new funds to the beneficiary in the liquid token\r\n        IDSToken(address(anchor)).issue(_beneficiary, amount);\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(reserveToken, IDSToken(address(anchor)), _trader, _amount, amount, fee);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev sells the liquid token by withdrawing from its reserve\r\n      *\r\n      * @param _amount      amount of liquid tokens to sell\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of reserve tokens received\r\n    */\r\n    function sell(uint256 _amount, address _trader, address payable _beneficiary) internal returns (uint256) {\r\n        // ensure that the input amount was already deposited\r\n        require(_amount <= IDSToken(address(anchor)).balanceOf(address(this)), \"ERR_INVALID_AMOUNT\");\r\n\r\n        // get expected target amount and fee\r\n        (uint256 amount, uint256 fee) = saleTargetAmount(_amount);\r\n\r\n        // ensure the trade gives something in return\r\n        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\r\n\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // ensure that the trade will only deplete the reserve balance if the total supply is depleted as well\r\n        uint256 tokenSupply = IDSToken(address(anchor)).totalSupply();\r\n        uint256 rsvBalance = reserveBalance(reserveToken);\r\n        assert(amount < rsvBalance || (amount == rsvBalance && _amount == tokenSupply));\r\n\r\n        // destroy the tokens from the converter balance in the liquid token\r\n        IDSToken(address(anchor)).destroy(address(this), _amount);\r\n\r\n        // update the reserve balance\r\n        reserves[reserveToken].balance = reserves[reserveToken].balance.sub(amount);\r\n\r\n        // transfer funds to the beneficiary in the reserve token\r\n        if (reserveToken == ETH_RESERVE_ADDRESS)\r\n            _beneficiary.transfer(amount);\r\n        else\r\n            safeTransfer(reserveToken, _beneficiary, amount);\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(IDSToken(address(anchor)), reserveToken, _trader, _amount, amount, fee);\r\n\r\n        return amount;\r\n    }\r\n}\n\n// File: solidity/contracts/converter/interfaces/ITypedConverterFactory.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n/*\n    Typed Converter Factory interface\n*/\ninterface ITypedConverterFactory {\n    function converterType() external pure returns (uint16);\n    function createConverter(IConverterAnchor _anchor, IContractRegistry _registry, uint32 _maxConversionFee) external returns (IConverter);\n}\n\n// File: solidity/contracts/converter/types/liquid-token/LiquidTokenConverterFactory.sol\n\n\r\npragma solidity 0.6.12;\r\r\r\r\r\n\r\n/*\r\n    LiquidTokenConverter Factory\r\n*/\r\ncontract LiquidTokenConverterFactory is ITypedConverterFactory {\r\n    /**\r\n      * @dev returns the converter type the factory is associated with\r\n      *\r\n      * @return converter type\r\n    */\r\n    function converterType() external pure override returns (uint16) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new converter with the given arguments and transfers\r\n      * the ownership to the caller\r\n      *\r\n      * @param _anchor            anchor governed by the converter\r\n      * @param _registry          address of a contract registry contract\r\n      * @param _maxConversionFee  maximum conversion fee, represented in ppm\r\n      *\r\n      * @return a new converter\r\n    */\r\n    function createConverter(IConverterAnchor _anchor, IContractRegistry _registry, uint32 _maxConversionFee) external override returns (IConverter) {\r\n        IConverter converter = new LiquidTokenConverter(IDSToken(address(_anchor)), _registry, _maxConversionFee);\r\n        converter.transferOwnership(msg.sender);\r\n        return converter;\r\n    }\r\n}\n","ABI":"[{\"inputs\":[],\"name\":\"converterType\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConverterAnchor\",\"name\":\"_anchor\",\"type\":\"address\"},{\"internalType\":\"contract IContractRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_maxConversionFee\",\"type\":\"uint32\"}],\"name\":\"createConverter\",\"outputs\":[{\"internalType\":\"contract IConverter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidTokenConverterFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}