{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.11;\r\npragma experimental ABIEncoderV2;\r\n\r\n// ERC20 Interface\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address, uint) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\ninterface POOLS {\r\n    function stakeForMember(uint inputVether, uint inputAsset, address pool, address member) external payable returns (uint units);\r\n}\r\n// Safe Math\r\nlibrary SafeMath {\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint)   {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract VetherPools {\r\n    using SafeMath for uint;\r\n\r\n    address public VETHER;\r\n    uint public one = 10**18;\r\n    uint public ETHCAP = 10 * one;\r\n    uint public DAY = 86400;\r\n    uint public DAYCAP = 30*DAY;\r\n\r\n    address[] public arrayPools;\r\n    uint public poolCount;\r\n    mapping(address => address[]) public mapPoolStakers;\r\n    mapping(address => PoolData) public poolData;\r\n    struct PoolData {\r\n        bool listed;\r\n        uint genesis;\r\n        uint vether;\r\n        uint asset;\r\n        uint vetherStaked;\r\n        uint assetStaked;\r\n        uint stakerCount;\r\n        uint poolUnits;\r\n        uint fees;\r\n        uint volume;\r\n        uint txCount;\r\n    }\r\n    \r\n    address[] public arrayMembers;\r\n    uint public memberCount;\r\n    mapping(address => MemberData) public memberData;\r\n    struct MemberData {\r\n        address[] arrayPools;\r\n        uint poolCount;\r\n        mapping(address => StakeData) stakeData;\r\n    }\r\n\r\n    struct StakeData {\r\n        uint vether;\r\n        uint asset;\r\n        uint stakeUnits;\r\n    }\r\n   \r\n    event Staked(address pool, address member, uint inputAsset, uint inputVether, uint unitsIssued);\r\n    event Unstaked(address pool, address member, uint outputAsset, uint outputVether, uint unitsClaimed);\r\n    event Swapped(address assetFrom, address assetTo, uint inputAmount, uint transferAmount, uint outPutAmount, uint fee, address recipient);\r\n\r\n    constructor () public payable {\r\n        VETHER = 0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279;\r\n    }\r\n\r\n    receive() external payable {\r\n        buyAsset(address(0), msg.value);\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Staking functions\r\n\r\n    function stake(uint inputVether, uint inputAsset, address pool) public payable returns (uint units) {\r\n        units = stakeForMember(inputVether, inputAsset, pool, msg.sender);\r\n        return units;\r\n    }\r\n\r\n    function stakeForMember(uint inputVether, uint inputAsset, address pool, address member) public payable returns (uint units) {\r\n        require(pool == address(0), \"Must be Eth\");\r\n        if (!poolData[pool].listed) { \r\n            require((inputAsset > 0 && inputVether > 0), \"Must get both assets for new pool\");\r\n            _createNewPool(pool);\r\n        }\r\n        require((poolData[pool].asset + inputAsset <= ETHCAP), \"Must not exceed ETH CAP\");\r\n        uint actualInputAsset = _handleTransferIn(pool, inputAsset);\r\n        uint actualInputVether = _handleTransferIn(VETHER, inputVether);\r\n        units = _stake(actualInputVether, actualInputAsset, pool, member);\r\n        return units;\r\n    }\r\n\r\n    function _createNewPool(address _pool) internal {\r\n        arrayPools.push(_pool);\r\n        poolCount += 1;\r\n        poolData[_pool].listed = true;\r\n        poolData[_pool].genesis = now;\r\n    }\r\n\r\n    function _stake(uint _vether, uint _asset, address _pool, address _member) internal returns (uint _units) {\r\n        uint _V = poolData[_pool].vether.add(_vether);\r\n        uint _A = poolData[_pool].asset.add(_asset);\r\n        _units = calcStakeUnits(_asset, _A, _vether, _V);   \r\n        _incrementPoolBalances(_units, _vether, _asset, _pool);                                                  \r\n        _addDataForMember(_member, _units, _vether, _asset, _pool);\r\n        emit Staked(_pool, _member, _asset, _vether, _units);\r\n        return _units;\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Unstaking functions\r\n\r\n    // Unstake % for self\r\n    function unstake(uint basisPoints, address pool) public returns (bool success) {\r\n        _unstakeToExact(msg.sender, basisPoints, pool);\r\n        return true;\r\n    }\r\n    // Internal - Convert to Exact with Checks\r\n    function _unstakeToExact(address payable member, uint basisPoints, address pool) internal returns (bool success) {\r\n        require(pool == address(0), \"Must be Eth\");\r\n        require(poolData[pool].listed, \"Must be listed\");\r\n        require((basisPoints > 0 && basisPoints <= 10000), \"Must be valid BasisPoints\");\r\n        uint _units = calcPart(basisPoints, memberData[member].stakeData[pool].stakeUnits);\r\n        _unstake(msg.sender, _units, pool);\r\n        return true;\r\n    }\r\n    // Unstake an exact qty of units\r\n    function unstakeExact(uint units, address pool) public returns (bool success) {\r\n        _unstake(msg.sender, units, pool);\r\n        return true;\r\n    }\r\n    // Internal - Unstake function\r\n    function _unstake(address payable member, uint units, address pool) internal returns (bool success) {\r\n        require(pool == address(0), \"Must be Eth\");\r\n        require(memberData[msg.sender].stakeData[pool].stakeUnits >= units);\r\n        uint _outputVether = calcShare(units, poolData[pool].poolUnits, poolData[pool].vether);\r\n        uint _outputAsset = calcShare(units, poolData[pool].poolUnits, poolData[pool].asset);\r\n        _handleUnstake(units, _outputVether, _outputAsset, member, pool);\r\n        return true;\r\n    }\r\n\r\n    // Unstake % Asymmetrically\r\n    function unstakeAsymmetric(uint basisPoints, address pool, bool toVether) public returns (uint outputAmount){\r\n        require(pool == address(0), \"Must be Eth\");\r\n        uint _units = calcPart(basisPoints, memberData[msg.sender].stakeData[pool].stakeUnits);\r\n        outputAmount = unstakeExactAsymmetric(_units, pool, toVether);\r\n        return outputAmount;\r\n    }\r\n    // Unstake Exact Asymmetrically\r\n    function unstakeExactAsymmetric(uint units, address pool, bool toVether) public returns (uint outputAmount){\r\n        require(pool == address(0), \"Must be Eth\");\r\n        require((memberData[msg.sender].stakeData[pool].stakeUnits >= units), \"Must own the units\");\r\n        uint poolUnits = poolData[pool].poolUnits;\r\n        require(units < poolUnits, \"Must not be last staker\");\r\n        uint _outputVether; uint _outputAsset; \r\n        if(toVether){\r\n            _outputVether = calcAsymmetricShare(units, poolUnits, poolData[pool].vether);\r\n            _outputAsset = 0;\r\n            outputAmount = _outputVether;\r\n        } else {\r\n            _outputVether = 0;\r\n            _outputAsset = calcAsymmetricShare(units, poolUnits, poolData[pool].asset);\r\n            outputAmount = _outputAsset;\r\n        }\r\n        _handleUnstake(units, _outputVether, _outputAsset, msg.sender, pool);\r\n        return outputAmount;\r\n    }\r\n\r\n    // Internal - handle Unstake\r\n    function _handleUnstake(uint _units, uint _outputVether, uint _outputAsset, address payable _member, address _pool) internal {\r\n        _decrementPoolBalances(_units, _outputVether, _outputAsset, _pool);\r\n        _removeDataForMember(_member, _units, _pool);\r\n        emit Unstaked(_pool, _member, _outputAsset, _outputVether, _units);\r\n        _handleTransferOut(_pool, _outputAsset, _member);\r\n        _handleTransferOut(VETHER, _outputVether, _member);\r\n    } \r\n\r\n    //==================================================================================//\r\n    // Upgrade functions\r\n\r\n    // Upgrade from this contract to a new one - opt in\r\n    function upgrade(address payable newContract) public {\r\n        address pool = address(0);\r\n        uint _units = memberData[msg.sender].stakeData[pool].stakeUnits;\r\n        uint _outputVether = calcShare(_units, poolData[pool].poolUnits, poolData[pool].vether);\r\n        uint _outputAsset = calcShare(_units, poolData[pool].poolUnits, poolData[pool].asset);\r\n        _decrementPoolBalances(_units, _outputVether, _outputAsset, pool);\r\n        _removeDataForMember(msg.sender, _units, pool);\r\n        emit Unstaked(pool, msg.sender, _outputAsset, _outputVether, _units);\r\n        ERC20(VETHER).approve(newContract, _outputVether);\r\n        POOLS(newContract).stakeForMember{value:_outputAsset}(_outputVether, _outputAsset, pool, msg.sender);\r\n    }\r\n\r\n    // Unstake for member after Day Cap\r\n    function unstakeForMember(address payable member, address pool) public returns (bool success) {\r\n        require(now > poolData[pool].genesis + DAYCAP, \"Must be after Day Cap\");\r\n        _unstakeToExact(member, 10000, pool);\r\n        return true;\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Swapping functions\r\n\r\n    function buyAsset(address pool, uint amount) public payable returns (uint outputAmount) {\r\n        require(pool == address(0), \"Must be Eth\");\r\n        require(now < poolData[pool].genesis + DAYCAP, \"Must not be after Day Cap\");\r\n        uint actualAmount = _handleTransferIn(VETHER, amount);\r\n        outputAmount = _swapVetherToAsset(actualAmount, address(0));\r\n        _handleTransferOut(address(0), outputAmount, msg.sender);\r\n        return outputAmount;\r\n    }\r\n\r\n    function sellAsset(address pool, uint amount) public payable returns (uint outputAmount) {\r\n        require(pool == address(0), \"Must be Eth\");\r\n        require(now < poolData[pool].genesis + DAYCAP, \"Must not be after Day Cap\");\r\n        uint actualAmount = _handleTransferIn(address(0), amount);\r\n        outputAmount = _swapAssetToVether(actualAmount, address(0));\r\n        _handleTransferOut(VETHER, outputAmount, msg.sender);\r\n        return outputAmount;\r\n    }\r\n\r\n    function _swapVetherToAsset(uint _x, address _pool) internal returns (uint _y){\r\n        uint _X = poolData[_pool].vether;\r\n        uint _Y = poolData[_pool].asset;\r\n        _y =  calcSwapOutput(_x, _X, _Y);\r\n        uint _fee = calcSwapFee(_x, _X, _Y);\r\n        poolData[_pool].vether = poolData[_pool].vether.add(_x);\r\n        poolData[_pool].asset = poolData[_pool].asset.sub(_y);\r\n        _updatePoolMetrics(_y+_fee, _fee, _pool, false);\r\n        emit Swapped(VETHER, _pool, _x, 0, _y, _fee, msg.sender);\r\n        return _y;\r\n    }\r\n\r\n    function _swapAssetToVether(uint _x, address _pool) internal returns (uint _y){\r\n        uint _X = poolData[_pool].asset;\r\n        uint _Y = poolData[_pool].vether;\r\n        _y =  calcSwapOutput(_x, _X, _Y);\r\n        uint _fee = calcSwapFee(_x, _X, _Y);\r\n        poolData[_pool].asset = poolData[_pool].asset.add(_x);\r\n        poolData[_pool].vether = poolData[_pool].vether.sub(_y);\r\n        _updatePoolMetrics(_y+_fee, _fee, _pool, true);\r\n        emit Swapped(_pool, VETHER, _x, 0, _y, _fee, msg.sender);\r\n        return _y;\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Data Model\r\n\r\n    function _incrementPoolBalances(uint _units, uint _vether, uint _asset, address _pool) internal {\r\n        poolData[_pool].poolUnits = poolData[_pool].poolUnits.add(_units);\r\n        poolData[_pool].vether = poolData[_pool].vether.add(_vether);\r\n        poolData[_pool].asset = poolData[_pool].asset.add(_asset); \r\n        poolData[_pool].vetherStaked = poolData[_pool].vetherStaked.add(_vether);\r\n        poolData[_pool].assetStaked = poolData[_pool].assetStaked.add(_asset); \r\n    }\r\n\r\n    function _decrementPoolBalances(uint _units, uint _vether, uint _asset, address _pool) internal {\r\n        poolData[_pool].vether = poolData[_pool].vether.sub(_vether);\r\n        poolData[_pool].asset = poolData[_pool].asset.sub(_asset); \r\n        uint _unstakedVether = calcShare(_units, poolData[_pool].poolUnits, poolData[_pool].vetherStaked);\r\n        uint _unstakedAsset = calcShare(_units, poolData[_pool].poolUnits, poolData[_pool].assetStaked);\r\n        poolData[_pool].vetherStaked = poolData[_pool].vetherStaked.sub(_unstakedVether);\r\n        poolData[_pool].assetStaked = poolData[_pool].assetStaked.sub(_unstakedAsset); \r\n        poolData[_pool].poolUnits = poolData[_pool].poolUnits.sub(_units);\r\n    }\r\n\r\n    function _addDataForMember(address _member, uint _units, uint _vether, uint _asset, address _pool) internal {\r\n        if(memberData[_member].poolCount == 0){\r\n            memberCount += 1;\r\n            arrayMembers.push(_member);\r\n        }\r\n        if( memberData[_member].stakeData[_pool].stakeUnits == 0){\r\n            mapPoolStakers[_pool].push(_member);\r\n            memberData[_member].arrayPools.push(_pool);\r\n            memberData[_member].poolCount +=1;\r\n            poolData[_pool].stakerCount += 1;\r\n        }\r\n        memberData[_member].stakeData[_pool].stakeUnits = memberData[_member].stakeData[_pool].stakeUnits.add(_units);\r\n        memberData[_member].stakeData[_pool].vether = memberData[_member].stakeData[_pool].vether.add(_vether);\r\n        memberData[_member].stakeData[_pool].asset = memberData[_member].stakeData[_pool].asset.add(_asset);\r\n    }\r\n\r\n    function _removeDataForMember(address _member, uint _units, address _pool) internal{\r\n        uint stakeUnits = memberData[_member].stakeData[_pool].stakeUnits;\r\n        uint _vether = calcShare(_units, stakeUnits, memberData[_member].stakeData[_pool].vether);\r\n        uint _asset = calcShare(_units, stakeUnits, memberData[_member].stakeData[_pool].asset);\r\n        memberData[_member].stakeData[_pool].stakeUnits = memberData[_member].stakeData[_pool].stakeUnits.sub(_units);\r\n        memberData[_member].stakeData[_pool].vether = memberData[_member].stakeData[_pool].vether.sub(_vether);\r\n        memberData[_member].stakeData[_pool].asset = memberData[_member].stakeData[_pool].asset.sub(_asset);\r\n        if( memberData[_member].stakeData[_pool].stakeUnits == 0){\r\n            poolData[_pool].stakerCount = poolData[_pool].stakerCount.sub(1);\r\n        }\r\n    }\r\n\r\n    function _updatePoolMetrics(uint _tx, uint _fee, address _pool, bool _toVether) internal {\r\n        poolData[_pool].txCount += 1;\r\n        uint _volume = poolData[_pool].volume;\r\n        uint _fees = poolData[_pool].fees;\r\n        if(_toVether){\r\n            poolData[_pool].volume = _tx.add(_volume); \r\n            poolData[_pool].fees = _fee.add(_fees); \r\n        } else {\r\n            uint _txVether = calcValueInVether(_tx, _pool);\r\n            uint _feeVether = calcValueInVether(_fee, _pool);\r\n            poolData[_pool].volume = _volume.add(_txVether); \r\n            poolData[_pool].fees = _fees.add(_feeVether); \r\n        }\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Asset Transfer Functions\r\n\r\n    function _handleTransferIn(address _asset, uint _amount) internal returns(uint actual){\r\n        if(_amount > 0) {\r\n            if(_asset == address(0)){\r\n                require((_amount == msg.value), \"Must get Eth\");\r\n                actual = _amount;\r\n            } else {\r\n                uint startBal = ERC20(_asset).balanceOf(address(this)); \r\n                ERC20(_asset).transferFrom(msg.sender, address(this), _amount); \r\n                actual = ERC20(_asset).balanceOf(address(this)).sub(startBal);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _handleTransferOut(address _asset, uint _amount, address payable _recipient) internal {\r\n        if(_amount > 0) {\r\n            if (_asset == address(0)) {\r\n                _recipient.call{value:_amount}(\"\"); \r\n            } else {\r\n                ERC20(_asset).transfer(_recipient, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function sync(address pool) public {\r\n        if (pool == address(0)) {\r\n            poolData[pool].asset = address(this).balance;\r\n        } else {\r\n            poolData[pool].asset = ERC20(pool).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    //==================================================================================//\r\n    // Helper functions\r\n\r\n    function getStakerUnits(address member, address pool) public view returns(uint stakerUnits){\r\n        return (memberData[member].stakeData[pool].stakeUnits);\r\n    }\r\n    function getStakerShareVether(address member, address pool) public view returns(uint vether){\r\n        uint _units = memberData[member].stakeData[pool].stakeUnits;\r\n        vether = calcShare(_units, poolData[pool].poolUnits, poolData[pool].vether);\r\n        return vether;\r\n    }\r\n    function getStakerShareAsset(address member, address pool) public view returns(uint asset){\r\n        uint _units = memberData[member].stakeData[pool].stakeUnits;\r\n        asset = calcShare(_units, poolData[pool].poolUnits, poolData[pool].asset);\r\n        return asset;\r\n    }\r\n\r\n    function getPoolStaker(address pool, uint index) public view returns(address staker){\r\n        return(mapPoolStakers[pool][index]);\r\n    }\r\n\r\n    function getMemberPool(address member, uint index) public view returns(address staker){\r\n        return(memberData[member].arrayPools[index]);\r\n    }\r\n    function getMemberPoolCount(address member) public view returns(uint){\r\n        return(memberData[member].poolCount);\r\n    }\r\n\r\n    function getMemberStakeData(address member, address pool) public view returns(StakeData memory){\r\n        return(memberData[member].stakeData[pool]);\r\n    }\r\n\r\n    function getPoolROI(address pool) public view returns (uint roi){\r\n        uint _assetStakedInVether = calcValueInVether(poolData[pool].assetStaked, pool);\r\n        uint _vetherStart = poolData[pool].vetherStaked.add(_assetStakedInVether);\r\n        uint _assetInVether = calcValueInVether(poolData[pool].asset, pool);\r\n        uint _vetherEnd = poolData[pool].vether.add(_assetInVether);\r\n        if (_vetherStart == 0){\r\n            roi = 0;\r\n        } else {\r\n            roi = (_vetherEnd.mul(10000)).div(_vetherStart);\r\n        }\r\n        // uint secondsPassed = now.sub(poolData[pool].genesis);\r\n        // dayROI*365 + 100000\r\n        // minus 365*10000\r\n        return roi;\r\n   }\r\n\r\n    function getMemberROI(address member, address pool) public view returns (uint roi){\r\n        // TODO: ensure staked updates when unstaking\r\n        uint _assetStakedInVether = calcValueInVether(memberData[member].stakeData[pool].asset, pool);\r\n        uint _vetherStart = memberData[member].stakeData[pool].vether.add(_assetStakedInVether);\r\n        uint _stakerUnits = memberData[msg.sender].stakeData[pool].stakeUnits;\r\n        uint _memberVether = calcShare(_stakerUnits, poolData[pool].poolUnits, poolData[pool].vether);\r\n        uint _memberAsset = calcShare(_stakerUnits, poolData[pool].poolUnits, poolData[pool].asset);\r\n        uint _assetInVether = calcValueInVether(_memberAsset, pool);\r\n        uint _vetherEnd = _memberVether.add(_assetInVether);\r\n        if (_vetherStart == 0){\r\n            roi = 0;\r\n        } else {\r\n            roi = (_vetherEnd.mul(10000)).div(_vetherStart);\r\n        }\r\n        return roi;\r\n   }\r\n\r\n   function calcValueInVether(uint amount, address pool) public view returns (uint price){\r\n       uint _asset = poolData[pool].asset;\r\n       uint _vether = poolData[pool].vether;\r\n       return (amount.mul(_vether)).div(_asset);\r\n   }\r\n\r\n    function calcValueInAsset(uint amount, address pool) public view returns (uint price){\r\n       uint _asset = poolData[pool].asset;\r\n       uint _vether = poolData[pool].vether;\r\n       return (amount.mul(_asset)).div(_vether);\r\n   }\r\n\r\n   function calcAssetPPinVether(uint amount, address pool) public view returns (uint _output){\r\n        uint _asset = poolData[pool].asset;\r\n        uint _vether = poolData[pool].vether;\r\n        return  calcSwapOutput(amount, _asset, _vether);\r\n   }\r\n\r\n    function calcVetherPPinAsset(uint amount, address pool) public view returns (uint _output){\r\n        uint _asset = poolData[pool].asset;\r\n        uint _vether = poolData[pool].vether;\r\n        return  calcSwapOutput(amount, _vether, _asset);\r\n   }\r\n\r\n   //==================================================================================//\r\n   // Core Math\r\n\r\n    function calcPart(uint bp, uint total) public pure returns (uint part){\r\n        // 10,000 basis points = 100.00%\r\n        require((bp <= 10000) && (bp > 0));\r\n        return calcShare(bp, 10000, total);\r\n    }\r\n\r\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\r\n        // share = amount * part/total\r\n        return(amount.mul(part)).div(total);\r\n    }\r\n\r\n    function  calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){\r\n        // y = (x * X * Y )/(x + X)^2\r\n        uint numerator = x.mul(X.mul(Y));\r\n        uint denominator = (x.add(X)).mul(x.add(X));\r\n        return numerator.div(denominator);\r\n    }\r\n\r\n    function  calcSwapFee(uint x, uint X, uint Y) public pure returns (uint output){\r\n        // y = (x * x * Y) / (x + X)^2\r\n        uint numerator = x.mul(x.mul(Y));\r\n        uint denominator = (x.add(X)).mul(x.add(X));\r\n        return numerator.div(denominator);\r\n    }\r\n\r\n    function calcStakeUnits(uint a, uint A, uint v, uint V) public pure returns (uint units){\r\n        // units = ((V + A) * (v * A + V * a))/(4 * V * A)\r\n        // (part1 * (part2 + part3)) / part4\r\n        uint part1 = V.add(A);\r\n        uint part2 = v.mul(A);\r\n        uint part3 = V.mul(a);\r\n        uint numerator = part1.mul((part2.add(part3)));\r\n        uint part4 = 4 * (V.mul(A));\r\n        return numerator.div(part4);\r\n    }\r\n\r\n    function calcAsymmetricShare(uint s, uint T, uint A) public pure returns (uint share){\r\n        // share = (s * A * (2 * T^2 - 2 * T * s + s^2))/T^3\r\n        // (part1 * (part2 - part3 + part4)) / part5\r\n        uint part1 = s.mul(A);\r\n        uint part2 = T.mul(T).mul(2);\r\n        uint part3 = T.mul(s).mul(2);\r\n        uint part4 = s.mul(s);\r\n        uint numerator = part1.mul(part2.sub(part3).add(part4));\r\n        uint part5 = T.mul(T).mul(T);\r\n        return numerator.div(part5);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAsset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputVether\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsIssued\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outPutAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAsset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputVether\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsClaimed\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAYCAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETHCAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VETHER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrayMembers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrayPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"calcAssetPPinVether\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_output\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"T\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"A\",\"type\":\"uint256\"}],\"name\":\"calcAsymmetricShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"calcPart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"part\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"part\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"A\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"V\",\"type\":\"uint256\"}],\"name\":\"calcStakeUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"name\":\"calcSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"name\":\"calcSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"calcValueInAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"calcValueInVether\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"calcVetherPPinAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_output\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getMemberPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"getMemberPoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getMemberROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getMemberStakeData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"vether\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeUnits\",\"type\":\"uint256\"}],\"internalType\":\"struct VetherPools.StakeData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getPoolROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPoolStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getStakerShareAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getStakerShareVether\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vether\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getStakerUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakerUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapPoolStakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"one\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"listed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"genesis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vether\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vetherStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakerCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputVether\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputAsset\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputVether\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputAsset\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"stakeForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toVether\",\"type\":\"bool\"}],\"name\":\"unstakeAsymmetric\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"unstakeExact\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toVether\",\"type\":\"bool\"}],\"name\":\"unstakeExactAsymmetric\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"unstakeForMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"VetherPools","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://012180d8cd45476b64acafba1d32c702518db584ecab889736f6984cc3dd6049"}]}