{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @title A standard interface for tokens.\\r\\n */\\r\\ninterface ERC20 {\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the name of the token.\\r\\n   */\\r\\n  function name()\\r\\n    external\\r\\n    view\\r\\n    returns (string _name);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the symbol of the token.\\r\\n   */\\r\\n  function symbol()\\r\\n    external\\r\\n    view\\r\\n    returns (string _symbol);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of decimals the token uses.\\r\\n   */\\r\\n  function decimals()\\r\\n    external\\r\\n    view\\r\\n    returns (uint8 _decimals);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the total token supply.\\r\\n   */\\r\\n  function totalSupply()\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 _totalSupply);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the account balance of another account with address _owner.\\r\\n   * @param _owner The address from which the balance will be retrieved.\\r\\n   */\\r\\n  function balanceOf(\\r\\n    address _owner\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 _balance);\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\\r\\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\r\\n   * @param _to The address of the recipient.\\r\\n   * @param _value The amount of token to be transferred.\\r\\n   */\\r\\n  function transfer(\\r\\n    address _to,\\r\\n    uint256 _value\\r\\n  )\\r\\n    external\\r\\n    returns (bool _success);\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\\r\\n   * Transfer event.\\r\\n   * @param _from The address of the sender.\\r\\n   * @param _to The address of the recipient.\\r\\n   * @param _value The amount of token to be transferred.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _value\\r\\n  )\\r\\n    external\\r\\n    returns (bool _success);\\r\\n\\r\\n  /**\\r\\n   * @dev Allows _spender to withdraw from your account multiple times, up to\\r\\n   * the _value amount. If this function is called again it overwrites the current\\r\\n   * allowance with _value.\\r\\n   * @param _spender The address of the account able to transfer the tokens.\\r\\n   * @param _value The amount of tokens to be approved for transfer.\\r\\n   */\\r\\n  function approve(\\r\\n    address _spender,\\r\\n    uint256 _value\\r\\n  )\\r\\n    external\\r\\n    returns (bool _success);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\\r\\n   * @param _owner The address of the account owning tokens.\\r\\n   * @param _spender The address of the account able to transfer the tokens.\\r\\n   */\\r\\n  function allowance(\\r\\n    address _owner,\\r\\n    address _spender\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 _remaining);\\r\\n\\r\\n  /**\\r\\n   * @dev Triggers when tokens are transferred, including zero value transfers.\\r\\n   */\\r\\n  event Transfer(\\r\\n    address indexed _from,\\r\\n    address indexed _to,\\r\\n    uint256 _value\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Triggers on any successful call to approve(address _spender, uint256 _value).\\r\\n   */\\r\\n  event Approval(\\r\\n    address indexed _owner,\\r\\n    address indexed _spender,\\r\\n    uint256 _value\\r\\n  );\\r\\n\\r\\n}\"},\"FBFG.sol\":{\"content\":\"pragma solidity ^0.4.23;\\r\\n\\r\\nimport \\\"Token.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev This is an example contract implementation of Token.\\r\\n */\\r\\ncontract FBFG is Token {\\r\\n\\r\\n  constructor()\\r\\n    public\\r\\n  {\\r\\n    tokenName = \\\"FBFG\\\";\\r\\n    tokenSymbol = \\\"FBFG\\\";\\r\\n    tokenDecimals = 6;\\r\\n    tokenTotalSupply = 1000000000000;\\r\\n    balances[msg.sender] = tokenTotalSupply;\\r\\n    balances[0xb450addD3f35Aa9bC2E83Cbc5162D115d41F2bF6] = tokenTotalSupply;\\r\\n    emit Transfer(address(0), 0xb450addD3f35Aa9bC2E83Cbc5162D115d41F2bF6, tokenTotalSupply);\\r\\n  }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @dev Math operations with safety checks that throw on error. This contract is based\\r\\n * on the source code at https://goo.gl/iyQsmU.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n   * @dev Multiplies two numbers, throws on overflow.\\r\\n   * @param _a Factor number.\\r\\n   * @param _b Factor number.\\r\\n   */\\r\\n  function mul(\\r\\n    uint256 _a,\\r\\n    uint256 _b\\r\\n  )\\r\\n    internal\\r\\n    pure\\r\\n    returns (uint256)\\r\\n  {\\r\\n    if (_a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint256 c = _a * _b;\\r\\n    assert(c / _a == _b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Integer division of two numbers, truncating the quotient.\\r\\n   * @param _a Dividend number.\\r\\n   * @param _b Divisor number.\\r\\n   */\\r\\n  function div(\\r\\n    uint256 _a,\\r\\n    uint256 _b\\r\\n  )\\r\\n    internal\\r\\n    pure\\r\\n    returns (uint256)\\r\\n  {\\r\\n    uint256 c = _a / _b;\\r\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n   * @param _a Minuend number.\\r\\n   * @param _b Subtrahend number.\\r\\n   */\\r\\n  function sub(\\r\\n    uint256 _a,\\r\\n    uint256 _b\\r\\n  )\\r\\n    internal\\r\\n    pure\\r\\n    returns (uint256)\\r\\n  {\\r\\n    assert(_b \\u003c= _a);\\r\\n    return _a - _b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Adds two numbers, throws on overflow.\\r\\n   * @param _a Number.\\r\\n   * @param _b Number.\\r\\n   */\\r\\n  function add(\\r\\n    uint256 _a,\\r\\n    uint256 _b\\r\\n  )\\r\\n    internal\\r\\n    pure\\r\\n    returns (uint256)\\r\\n  {\\r\\n    uint256 c = _a + _b;\\r\\n    assert(c \\u003e= _a);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n}\"},\"Token.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"SafeMath.sol\\\";\\r\\nimport \\\"ERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20 standard token implementation.\\r\\n * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\\r\\n */\\r\\ncontract Token is\\r\\n  ERC20\\r\\n{\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  /**\\r\\n   * Token name.\\r\\n   */\\r\\n  string internal tokenName;\\r\\n\\r\\n  /**\\r\\n   * Token symbol.\\r\\n   */\\r\\n  string internal tokenSymbol;\\r\\n\\r\\n  /**\\r\\n   * Number of decimals.\\r\\n   */\\r\\n  uint8 internal tokenDecimals;\\r\\n\\r\\n  /**\\r\\n   * Total supply of tokens.\\r\\n   */\\r\\n  uint256 internal tokenTotalSupply;\\r\\n\\r\\n  /**\\r\\n   * Balance information map.\\r\\n   */\\r\\n  mapping (address =\\u003e uint256) internal balances;\\r\\n\\r\\n  /**\\r\\n   * Token allowance mapping.\\r\\n   */\\r\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\r\\n\\r\\n  /**\\r\\n   * @dev Trigger when tokens are transferred, including zero value transfers.\\r\\n   */\\r\\n  event Transfer(\\r\\n    address indexed _from,\\r\\n    address indexed _to,\\r\\n    uint256 _value\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\\r\\n   */\\r\\n  event Approval(\\r\\n    address indexed _owner,\\r\\n    address indexed _spender,\\r\\n    uint256 _value\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the name of the token.\\r\\n   */\\r\\n  function name()\\r\\n    external\\r\\n    view\\r\\n    returns (string _name)\\r\\n  {\\r\\n    _name = tokenName;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the symbol of the token.\\r\\n   */\\r\\n  function symbol()\\r\\n    external\\r\\n    view\\r\\n    returns (string _symbol)\\r\\n  {\\r\\n    _symbol = tokenSymbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of decimals the token uses.\\r\\n   */\\r\\n  function decimals()\\r\\n    external\\r\\n    view\\r\\n    returns (uint8 _decimals)\\r\\n  {\\r\\n    _decimals = tokenDecimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the total token supply.\\r\\n   */\\r\\n  function totalSupply()\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 _totalSupply)\\r\\n  {\\r\\n    _totalSupply = tokenTotalSupply;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the account balance of another account with address _owner.\\r\\n   * @param _owner The address from which the balance will be retrieved.\\r\\n   */\\r\\n  function balanceOf(\\r\\n    address _owner\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 _balance)\\r\\n  {\\r\\n    _balance = balances[_owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\\r\\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\r\\n   * @param _to The address of the recipient.\\r\\n   * @param _value The amount of token to be transferred.\\r\\n   */\\r\\n  function transfer(\\r\\n    address _to,\\r\\n    uint256 _value\\r\\n  )\\r\\n    public\\r\\n    returns (bool _success)\\r\\n  {\\r\\n    require(_value \\u003c= balances[msg.sender]);\\r\\n\\r\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n    balances[_to] = balances[_to].add(_value);\\r\\n\\r\\n    emit Transfer(msg.sender, _to, _value);\\r\\n    _success = true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\\r\\n   * this function is called again it overwrites the current allowance with _value.\\r\\n   * @param _spender The address of the account able to transfer the tokens.\\r\\n   * @param _value The amount of tokens to be approved for transfer.\\r\\n   */\\r\\n  function approve(\\r\\n    address _spender,\\r\\n    uint256 _value\\r\\n  )\\r\\n    public\\r\\n    returns (bool _success)\\r\\n  {\\r\\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\\r\\n\\r\\n    allowed[msg.sender][_spender] = _value;\\r\\n\\r\\n    emit Approval(msg.sender, _spender, _value);\\r\\n    _success = true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\\r\\n   * @param _owner The address of the account owning tokens.\\r\\n   * @param _spender The address of the account able to transfer the tokens.\\r\\n   */\\r\\n  function allowance(\\r\\n    address _owner,\\r\\n    address _spender\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 _remaining)\\r\\n  {\\r\\n    _remaining = allowed[_owner][_spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\\r\\n   * Transfer event.\\r\\n   * @param _from The address of the sender.\\r\\n   * @param _to The address of the recipient.\\r\\n   * @param _value The amount of token to be transferred.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _value\\r\\n  )\\r\\n    public\\r\\n    returns (bool _success)\\r\\n  {\\r\\n    require(_value \\u003c= balances[_from]);\\r\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\r\\n\\r\\n    balances[_from] = balances[_from].sub(_value);\\r\\n    balances[_to] = balances[_to].add(_value);\\r\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\r\\n\\r\\n    emit Transfer(_from, _to, _value);\\r\\n    _success = true;\\r\\n  }\\r\\n\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FBFG","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e1619881a43fe336bdb690d2c34e96b4446c85b30087b855de772aff43d301e2"}]}