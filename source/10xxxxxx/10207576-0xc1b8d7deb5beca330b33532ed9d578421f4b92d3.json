{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Cannot transfer to zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract SubscriptionsContract is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    address public feeWallet;\r\n    address public currency;\r\n    uint public feePercent;\r\n    \r\n    struct Subscription {\r\n        address user;\r\n        address merchant;\r\n        string productId;\r\n        string parentProductId;\r\n        string status;\r\n        bool unlimited;\r\n        bool isSubProduct;\r\n        uint cycles;\r\n        uint payment;\r\n        uint successPaymentsAmount;\r\n        uint lastPaymentDate;\r\n    }\r\n    \r\n    mapping(string => Subscription) private subscriptions;\r\n    mapping(string => bool) private productPaused;\r\n    \r\n    event SubscriptionCreated(address user, address merchant, string subscriptionId, string productId);\r\n    event SubscriptionMonthlyPaymentPaid(address user, address merchant, uint payment, uint lastPaymentDate);\r\n    \r\n    constructor(address _feeWallet, address _currency, uint _feePercent) public {\r\n        feeWallet = _feeWallet;\r\n        currency = _currency;\r\n        feePercent = _feePercent;\r\n    }\r\n    \r\n    function subscribeUser(address user, address merchant, string memory subscriptionId, string memory productId, uint cycles, uint payment, bool unlimited, bool isSubProduct, string memory parentProductId) public onlyOwner {\r\n        require(ERC20(currency).balanceOf(user) >= payment, 'User doesnt have enough tokens for first payment');\r\n        require(ERC20(currency).allowance(user, address(this)) >= payment.mul(cycles), 'User didnt approve needed amount of tokens');\r\n        require(!productPaused[productId], 'Product paused by merchant');\r\n        require(keccak256(abi.encodePacked(subscriptions[subscriptionId].status)) != keccak256(abi.encodePacked((\"active\"))), \"User already has an active subscription for this merchant\");\r\n        \r\n        if(subscriptions[subscriptionId].isSubProduct) {\r\n            require(!productPaused[subscriptions[subscriptionId].parentProductId], \"Parent product paused by merchant\");\r\n        }\r\n        \r\n        subscriptions[subscriptionId] = Subscription(user, merchant, productId, parentProductId, 'active', unlimited, isSubProduct, cycles, payment, 0, 0);\r\n        emit SubscriptionCreated(user, merchant, subscriptionId, productId);\r\n        processPayment(subscriptionId, payment);\r\n    }\r\n    \r\n    function processPayment(string memory subscriptionId, uint payment) public onlyOwner {\r\n        require((subscriptions[subscriptionId].successPaymentsAmount < subscriptions[subscriptionId].cycles) || subscriptions[subscriptionId].unlimited, 'Subscription is over');\r\n        require((payment <= subscriptions[subscriptionId].payment) || subscriptions[subscriptionId].unlimited, 'Payment cant be more then started payment amount');\r\n        require(!productPaused[subscriptions[subscriptionId].productId], 'Product paused by merchant');\r\n        require(keccak256(abi.encodePacked(subscriptions[subscriptionId].status)) != keccak256(abi.encodePacked((\"unsubscribe\"))), 'Subscription must be unsubscribed');\r\n        require(keccak256(abi.encodePacked(subscriptions[subscriptionId].status)) != keccak256(abi.encodePacked((\"pause\"))), 'Subscription must not be paused');\r\n        \r\n        if(ERC20(currency).balanceOf(subscriptions[subscriptionId].user) < subscriptions[subscriptionId].payment) {\r\n            subscriptions[subscriptionId].status = \"unsubscribe\";\r\n            return;\r\n        }\r\n        \r\n        require(ERC20(currency).transferFrom(subscriptions[subscriptionId].user, subscriptions[subscriptionId].merchant, payment.mul(uint(1000).sub(feePercent)).div(1000).sub(300000000000000000)), \"Transfer to merchant failed\");\r\n        require(ERC20(currency).transferFrom(subscriptions[subscriptionId].user, feeWallet, payment.mul(feePercent).div(1000).add(300000000000000000)), \"Transfer to fee wallet failed\");\r\n        \r\n        subscriptions[subscriptionId].status = \"active\";\r\n        subscriptions[subscriptionId].lastPaymentDate = block.timestamp;\r\n        subscriptions[subscriptionId].successPaymentsAmount = subscriptions[subscriptionId].successPaymentsAmount.add(1);\r\n        \r\n        emit SubscriptionMonthlyPaymentPaid(subscriptions[subscriptionId].user, subscriptions[subscriptionId].merchant, payment, subscriptions[subscriptionId].lastPaymentDate);\r\n        \r\n        if(subscriptions[subscriptionId].successPaymentsAmount == subscriptions[subscriptionId].cycles && !subscriptions[subscriptionId].unlimited) {\r\n            subscriptions[subscriptionId].status = \"end\";\r\n        }\r\n    }\r\n    \r\n    function pauseSubscriptionsByMerchant(string memory productId) public onlyOwner {\r\n        productPaused[productId] = true;\r\n    }\r\n    \r\n    function activateSubscriptionsByMerchant(string memory productId) public onlyOwner {\r\n        productPaused[productId] = false;\r\n    }\r\n    \r\n    function unsubscribeBatchByMerchant(string[] memory subscriptionIds) public onlyOwner {\r\n        for(uint i = 0; i < subscriptionIds.length; i++) {\r\n            subscriptions[subscriptionIds[i]].status = \"unsubscribe\";\r\n        }\r\n    }\r\n    \r\n    function cancelSubscription(string memory subscriptionId) public onlyOwner {\r\n        subscriptions[subscriptionId].status = \"unsubscribe\";\r\n    }\r\n    \r\n    function pauseSubscription(string memory subscriptionId) public onlyOwner {\r\n        require(ERC20(currency).balanceOf(subscriptions[subscriptionId].user) >= subscriptions[subscriptionId].payment.mul(125).div(1000), 'User doesnt have enough tokens for first payment');\r\n        require(ERC20(currency).allowance(subscriptions[subscriptionId].user, address(this)) >= subscriptions[subscriptionId].payment.mul(125).div(1000), 'User didnt approve needed amount of tokens');\r\n        \r\n        require(ERC20(currency).transferFrom(subscriptions[subscriptionId].user, subscriptions[subscriptionId].merchant, subscriptions[subscriptionId].payment.mul(10).div(100)), \"Transfer to merchant failed\");\r\n        require(ERC20(currency).transferFrom(subscriptions[subscriptionId].user, feeWallet, subscriptions[subscriptionId].payment.mul(25).div(1000)), \"Transfer to fee wallet failed\");\r\n        \r\n        subscriptions[subscriptionId].status = \"pause\";\r\n    }\r\n    \r\n    function activateSubscription(string memory subscriptionId) public onlyOwner {\r\n        require(keccak256(abi.encodePacked(subscriptions[subscriptionId].status)) == keccak256(abi.encodePacked(\"unsubscribe\")), \"Subscription must be unsubscribed\");\r\n        subscriptions[subscriptionId].status = \"active\";\r\n    }\r\n    \r\n    function getSubscriptionStatus(string calldata subscriptionId) external view returns(string memory) {\r\n        return subscriptions[subscriptionId].status;\r\n    }\r\n    \r\n    function getSubscriptionDetails(string calldata subscriptionId) external view returns(Subscription memory) {\r\n        return subscriptions[subscriptionId];\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"productId\",\"type\":\"string\"}],\"name\":\"SubscriptionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastPaymentDate\",\"type\":\"uint256\"}],\"name\":\"SubscriptionMonthlyPaymentPaid\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"}],\"name\":\"activateSubscription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"productId\",\"type\":\"string\"}],\"name\":\"activateSubscriptionsByMerchant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"}],\"name\":\"cancelSubscription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"}],\"name\":\"getSubscriptionDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"productId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"parentProductId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"unlimited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSubProduct\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"cycles\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"successPaymentsAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPaymentDate\",\"type\":\"uint256\"}],\"internalType\":\"struct SubscriptionsContract.Subscription\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"}],\"name\":\"getSubscriptionStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"}],\"name\":\"pauseSubscription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"productId\",\"type\":\"string\"}],\"name\":\"pauseSubscriptionsByMerchant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"processPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"subscriptionId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"productId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"cycles\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unlimited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSubProduct\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"parentProductId\",\"type\":\"string\"}],\"name\":\"subscribeUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"subscriptionIds\",\"type\":\"string[]\"}],\"name\":\"unsubscribeBatchByMerchant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SubscriptionsContract","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a44a5d224c1c158b81bc0bd404037939644859ea0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000023","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://13beeaa68743650388e8d17402a352f9b231af7d89ff867c79c41589c7d23ea4"}]}