{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/SafeMath.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Ezer.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\ncontract Ezer {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public MIN_STAKE = 0.1 ether;\r\n    uint8 public CONTRACT_FEE_PERCENT = 1;\r\n    uint8 public ORACLE_FEE_PERCENT = 9;\r\n    uint8 public constant MAX_OUTCOMES_COUNT = 5;\r\n    uint16 public constant MAX_TITLE_LENGTH = 96;\r\n    uint16 public constant MAX_DESCRIPTION_LENGTH = 96;\r\n\r\n    uint8 public constant POOL_SIZE = 15;\r\n    uint8 public constant MIN_SUCCESS_COUNT = 9;\r\n    uint8 public constant CATEGORIES_COUNT = 8;\r\n    uint8 public constant HISTORY_SIZE = 15;\r\n    uint8 public constant MAX_PLAYERS = 50;\r\n\r\n    enum EventState {open, closed, canceled}\r\n\r\n    enum PoolState {open, closed, canceled}\r\n\r\n    struct Pool {\r\n        uint256[CATEGORIES_COUNT] banks;\r\n        uint256 bank;\r\n        uint256 jackpot;\r\n        uint256 maxWinning;\r\n        address payable[] players;\r\n        string[POOL_SIZE] titles;\r\n        string[POOL_SIZE] descriptions;\r\n        uint64[POOL_SIZE] expiries;\r\n        uint8 outcomes;\r\n        uint8[CATEGORIES_COUNT] percents;\r\n        uint32 id;\r\n        PoolState state;\r\n        uint8 jackpotPercent;\r\n        int8[POOL_SIZE] results;\r\n        EventState[POOL_SIZE] states;\r\n    }\r\n\r\n    struct Ticket {\r\n        uint256 stake;\r\n        uint256 winning;\r\n        bytes15 outcomes;\r\n        uint8 categories;\r\n        bool jackpot;\r\n    }\r\n\r\n    enum Categories {\r\n        success9,\r\n        success10,\r\n        success11,\r\n        success12,\r\n        success13,\r\n        success14,\r\n        success15,\r\n        losing\r\n    }\r\n\r\n    event logNewPool(uint32 _id, string _firstEvent);\r\n\r\n    event logPayment(\r\n        address indexed _player,\r\n        uint32 indexed _poolId,\r\n        uint256 _winning,\r\n        bool indexed _isJackpot\r\n    );\r\n\r\n    event logFailedPayment(\r\n        address indexed _player,\r\n        uint32 indexed _poolId,\r\n        uint256 _winning,\r\n        bool indexed _isJackpot\r\n    );\r\n\r\n    address payable public owner;\r\n    address payable public oracle;\r\n    uint256 public contractFee;\r\n    uint256 public jackpot;\r\n    uint256 public newJackpot;\r\n\r\n    uint32[] poolIds;\r\n    mapping(uint32 => Pool) pools;\r\n    mapping(address => uint32[]) playerPools;\r\n    mapping(uint32 => mapping(address => Ticket)) tickets; // poolId => player => ticket\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        createOracle(owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracle() {\r\n        require(\r\n            msg.sender == oracle || msg.sender == owner,\r\n            \"Sender is not oracle\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// Withdraw jackpot and contract fee to owner\r\n    function kill() external onlyOwner {\r\n        if (jackpot > 0) withdrawJackpot(owner, jackpot);\r\n        if (contractFee > 0) withdrawContractFee(owner, contractFee);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /// Change minimum stake\r\n    /// @param minStake Minimum stake\r\n    function changeMinStake(uint256 minStake) external onlyOwner {\r\n        require(minStake > 0, \"Incorrect minimum stake amount\");\r\n        MIN_STAKE = minStake;\r\n    }\r\n\r\n    /// Change contract fee percent of the stake\r\n    /// @param contractFeePercent Contract fee percent\r\n    function changeContractFeePercent(uint8 contractFeePercent)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(contractFeePercent < 100, \"Incorrect percent value\");\r\n        CONTRACT_FEE_PERCENT = contractFeePercent;\r\n    }\r\n\r\n    /// Change oracle fee percent of the stake\r\n    /// @param oracleFeePercent Oracle fee percent\r\n    function changeOracleFeePercent(uint8 oracleFeePercent) external onlyOwner {\r\n        require(oracleFeePercent < 100, \"Incorrect percent value\");\r\n        ORACLE_FEE_PERCENT = oracleFeePercent;\r\n    }\r\n\r\n    /// Create new pool bets\r\n    /// @dev Id of the new pool saved in emitted event\r\n    /// @notice Events must be sorted by expiries\r\n    /// @param titles Array of event titles\r\n    /// @param descriptions Array of event descriptions\r\n    /// @param expiries Array of event expiries\r\n    /// @param outcomes Count of outcomes\r\n    function createPool(\r\n        string[POOL_SIZE] calldata titles,\r\n        string[POOL_SIZE] calldata descriptions,\r\n        uint64[POOL_SIZE] calldata expiries,\r\n        uint8 outcomes\r\n    ) external onlyOracle {\r\n        uint32 poolId = uint32(poolIds.length + 1);\r\n        Pool storage pool = pools[poolId];\r\n\r\n        for (uint256 i = 0; i < POOL_SIZE; i++) {\r\n            require(expiries[i] > now, \"Expiry must be in the future\");\r\n            require(outcomes > 1 && outcomes < 4, \"Incorrect outcomes\");\r\n            // Check event title and description\r\n            validateString(titles[i], MAX_TITLE_LENGTH);\r\n            validateString(descriptions[i], MAX_DESCRIPTION_LENGTH);\r\n\r\n            pool.titles[i] = titles[i];\r\n            pool.descriptions[i] = descriptions[i];\r\n            pool.expiries[i] = expiries[i];\r\n            pool.outcomes = outcomes;\r\n        }\r\n\r\n        setDefaultPercents(pool);\r\n        pool.id = poolId;\r\n        poolIds.push(pool.id);\r\n\r\n        emit logNewPool(pool.id, titles[0]);\r\n    }\r\n\r\n    /// Close event of the `poolId` pool with the result\r\n    /// @param poolId Id of the pool\r\n    /// @param eventIdx Index of the event in a pool\r\n    /// @param result Index of the result outcome\r\n    function closeEvent(uint32 poolId, uint8 eventIdx, int8 result)\r\n        external\r\n        onlyOracle\r\n    {\r\n        Pool storage pool = pools[poolId];\r\n        require(isPoolExist(pool), \"The pool does not exist\");\r\n        require(eventIdx < POOL_SIZE, \"The event does not exist\");\r\n        require(int8(pool.outcomes) > result, \"The outcome does not exist\");\r\n        require(\r\n            pool.states[eventIdx] == EventState.open,\r\n            \"The event is already closed\"\r\n        );\r\n\r\n        if (result < 0) pool.states[eventIdx] = EventState.canceled;\r\n        else pool.states[eventIdx] = EventState.closed;\r\n\r\n        pool.results[eventIdx] = result;\r\n    }\r\n\r\n    /// Place ticket in `poolId`\r\n    /// @param poolId Id of the pool\r\n    /// @param outcomes Bytes of outcomes. Bits in bytes are selected indexes of outcomes\r\n    function placeTicket(uint32 poolId, bytes15 outcomes) external payable {\r\n        require(msg.value >= MIN_STAKE, \"Stake is too small\");\r\n        Pool storage pool = pools[poolId];\r\n        require(isPoolExist(pool), \"The pool does not exist\");\r\n        Ticket storage ticket = tickets[poolId][msg.sender];\r\n\r\n        require(pool.expiries[0] >= now, \"The pool is already expired\");\r\n\r\n        require(pool.state == PoolState.open, \"The pool is already closed\");\r\n\r\n        if (ticket.stake == 0) {\r\n            require(\r\n                pool.players.length < MAX_PLAYERS,\r\n                \"The pool is full of players\"\r\n            );\r\n            pool.players.push(msg.sender);\r\n            playerPools[msg.sender].push(poolId);\r\n        }\r\n\r\n        ticket.outcomes |= outcomes;\r\n\r\n        uint256 variants = 1;\r\n\r\n        for (uint256 i = 0; i < POOL_SIZE; i++) {\r\n            variants = variants.mul(\r\n                uint256(countBits(uint32(uint8(ticket.outcomes[i]))))\r\n            );\r\n        }\r\n\r\n        require(variants > 0, \"Incorrect outcomes\");\r\n\r\n        ticket.stake = ticket.stake.add(msg.value);\r\n\r\n        require(ticket.stake >= variants.mul(MIN_STAKE), \"Stake is too small\");\r\n\r\n        pool.bank = pool.bank.add(msg.value);\r\n    }\r\n\r\n    /// Get pool by it's id\r\n    /// @param poolId Pool id\r\n    /// @return Pool instance\r\n    function getPool(uint32 poolId) external view returns (Pool memory) {\r\n        Pool storage poolOrigin = pools[poolId];\r\n        Pool memory poolRead = poolOrigin;\r\n\r\n        if (poolOrigin.state == PoolState.open) poolRead.jackpot = jackpot;\r\n\r\n        return poolRead;\r\n    }\r\n\r\n    /// Get last pools\r\n    /// @return Array of pool ids\r\n    function getPoolsHistory()\r\n        external\r\n        view\r\n        returns (uint32[HISTORY_SIZE] memory)\r\n    {\r\n        uint32[HISTORY_SIZE] memory history;\r\n\r\n        for (uint256 i = 0; i < HISTORY_SIZE && i < poolIds.length; i++) {\r\n            history[i] = poolIds[poolIds.length - 1 - i];\r\n        }\r\n\r\n        return history;\r\n    }\r\n\r\n    /// Get player's `player` pool ids\r\n    /// @param player Address of the player\r\n    /// @return Array of pool ids\r\n    function getPlayerHistory(address player)\r\n        external\r\n        view\r\n        returns (uint32[HISTORY_SIZE] memory)\r\n    {\r\n        uint32[HISTORY_SIZE] memory history;\r\n        uint32[] storage _playerPools = playerPools[player];\r\n\r\n        for (uint256 i = 0; i < HISTORY_SIZE && i < _playerPools.length; i++) {\r\n            history[i] = _playerPools[_playerPools.length - 1 - i];\r\n        }\r\n\r\n        return history;\r\n    }\r\n\r\n    /// Get ticket instance\r\n    /// @param poolId Id of the pool\r\n    /// @param player Address of the player\r\n    /// @return Ticket instance\r\n    function getTicket(uint32 poolId, address player)\r\n        external\r\n        view\r\n        returns (Ticket memory)\r\n    {\r\n        return tickets[poolId][player];\r\n    }\r\n\r\n    /// Close pool\r\n    /// @param poolId Pool id\r\n    function closePool(uint32 poolId) public onlyOracle {\r\n        Pool storage pool = pools[poolId];\r\n        require(isPoolExist(pool), \"The pool does not exist\");\r\n        require(pool.state == PoolState.open, \"The pool is already closed\");\r\n\r\n        pool.state = PoolState.closed;\r\n\r\n        if (pool.bank != 0) {\r\n            processFailedEvents(pool, getFailedEvents(pool));\r\n\r\n            distributeFees(pool);\r\n\r\n            categorizePlayers(pool);\r\n\r\n            distributeWinnings(pool);\r\n\r\n            sendWinnings(pool);\r\n\r\n            updateJackpot(pool);\r\n        }\r\n\r\n        deletePool(poolId);\r\n    }\r\n\r\n    /// Cancel pool\r\n    /// @param poolId Pool id\r\n    function cancelPool(uint32 poolId) public onlyOracle {\r\n        Pool storage pool = pools[poolId];\r\n        require(isPoolExist(pool), \"The pool does not exist\");\r\n\r\n        if (pool.state == PoolState.open) {\r\n            pool.state = PoolState.canceled;\r\n            sendWinnings(pool);\r\n            deletePool(poolId);\r\n        }\r\n    }\r\n\r\n    /// Increace jackpot value\r\n    function increaseJackpot() public payable {\r\n        jackpot = jackpot.add(msg.value);\r\n    }\r\n\r\n    /// Withdraw contract fee\r\n    /// @param to Destination address\r\n    /// @param amount Withdraw amount\r\n    function withdrawContractFee(address payable to, uint256 amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(\r\n            amount <= contractFee && amount <= address(this).balance,\r\n            \"Amount is too big\"\r\n        );\r\n        contractFee = contractFee.sub(amount);\r\n        to.transfer(amount);\r\n    }\r\n\r\n    /// Withdraw jackpot\r\n    /// @param to Destination address\r\n    /// @param amount Withdraw amount\r\n    function withdrawJackpot(address payable to, uint256 amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(\r\n            amount <= jackpot && amount <= address(this).balance,\r\n            \"Amount is too big\"\r\n        );\r\n        jackpot = jackpot.sub(amount);\r\n        to.transfer(amount);\r\n    }\r\n\r\n    /// Create oracle\r\n    /// @param _oracle Oracle address\r\n    function createOracle(address payable _oracle) public onlyOwner {\r\n        oracle = _oracle;\r\n    }\r\n\r\n    function sendPayment(\r\n        address payable to,\r\n        uint32 poolId,\r\n        uint256 amount,\r\n        bool _isJackpot\r\n    ) private {\r\n        (bool success, ) = to.call.value(amount)(\"\");\r\n        if (success) emit logPayment(to, poolId, amount, _isJackpot);\r\n        else emit logFailedPayment(to, poolId, amount, _isJackpot);\r\n    }\r\n\r\n    function countBits(uint32 number) private pure returns (uint32) {\r\n        uint32 i = number;\r\n        i = i - ((i >> 1) & 0x55555555);\r\n        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\r\n        return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\r\n    }\r\n\r\n    function deletePool(uint32 poolId) private {\r\n        if (poolId >= HISTORY_SIZE + 1) {\r\n            uint32 removingIdx = poolId - HISTORY_SIZE;\r\n            Pool storage removingPool = pools[removingIdx];\r\n\r\n            for (\r\n                uint256 i = 0;\r\n                i < removingPool.players.length && i < MAX_PLAYERS;\r\n                i++\r\n            ) {\r\n                address player = removingPool.players[i];\r\n                delete tickets[removingIdx][player];\r\n                for (uint256 j = 0; j < playerPools[player].length; j++) {\r\n                    uint32[] storage playersPools = playerPools[player];\r\n                    if (\r\n                        playersPools[playersPools.length - 1 - j] == removingIdx\r\n                    ) {\r\n                        delete playersPools[playersPools.length - 1 - j];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            delete poolIds[removingIdx - 1];\r\n            delete pools[removingIdx];\r\n        }\r\n    }\r\n\r\n    function distributeFees(Pool storage pool) private {\r\n        if (pool.state == PoolState.canceled) return;\r\n\r\n        if (pool.bank > 0) {\r\n            uint256 poolContractFee = percentFrom(\r\n                pool.bank,\r\n                CONTRACT_FEE_PERCENT\r\n            );\r\n            contractFee = contractFee.add(poolContractFee);\r\n\r\n            uint256 poolOracleFee = percentFrom(pool.bank, ORACLE_FEE_PERCENT);\r\n\r\n            uint256 allFees = poolContractFee.add(poolOracleFee);\r\n            assert(pool.bank > allFees);\r\n            pool.bank = pool.bank.sub(allFees);\r\n\r\n            sendPayment(oracle, pool.id, poolOracleFee, false);\r\n        }\r\n    }\r\n\r\n    function percentFrom(uint256 value, uint8 percent)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(percent <= 100, \"Incorrect percent value\");\r\n        if (percent == 0) return 0;\r\n        return value.mul(percent).div(100);\r\n    }\r\n\r\n    function updateJackpot(Pool storage pool) private {\r\n        if (pool.state != PoolState.canceled && newJackpot > 0)\r\n            jackpot = jackpot.add(newJackpot);\r\n    }\r\n\r\n    function sendWinnings(Pool storage pool) private {\r\n        for (uint256 i = 0; i < pool.players.length && i < MAX_PLAYERS; i++) {\r\n            address payable player = pool.players[i];\r\n            Ticket storage ticket = tickets[pool.id][player];\r\n\r\n            if (pool.state == PoolState.canceled)\r\n                sendPayment(player, pool.id, ticket.stake, false);\r\n            else if (ticket.winning != 0) {\r\n                sendPayment(player, pool.id, ticket.winning, ticket.jackpot);\r\n            }\r\n        }\r\n    }\r\n\r\n    function distributeWinnings(Pool storage pool) private {\r\n        if (pool.state == PoolState.canceled) {\r\n            return;\r\n        }\r\n\r\n        uint256 localNewJackpot = pool.bank;\r\n        uint256 tmpJackpot = jackpot;\r\n        uint256 maxWinning;\r\n\r\n        if (jackpot != 0 && pool.jackpotPercent != 0) {\r\n            pool.jackpot = percentFrom(jackpot, pool.jackpotPercent);\r\n        }\r\n\r\n        for (uint8 i = 0; i < CATEGORIES_COUNT; i++) {\r\n            uint256 categoryBank = pool.banks[i];\r\n            uint8 categoryPercent = uint8(pool.percents[i]);\r\n\r\n            if (categoryPercent != 0 && categoryBank != 0) {\r\n                uint256 categoryWinnings = percentFrom(\r\n                    pool.bank,\r\n                    categoryPercent\r\n                );\r\n\r\n                assert(categoryWinnings <= localNewJackpot);\r\n\r\n                localNewJackpot = localNewJackpot.sub(categoryWinnings);\r\n\r\n                for (\r\n                    uint256 j = 0;\r\n                    j < pool.players.length && i < MAX_PLAYERS;\r\n                    j++\r\n                ) {\r\n                    Ticket storage ticket = tickets[pool.id][pool.players[j]];\r\n                    if ((ticket.categories & (uint8(1) << i)) != 0) {\r\n                        uint256 ticketWinning = categoryWinnings\r\n                            .mul(ticket.stake)\r\n                            .div(categoryBank);\r\n\r\n                        if (\r\n                            i == uint8(Categories.success15) &&\r\n                            pool.jackpot != 0\r\n                        ) {\r\n                            uint256 jackpotWinning = pool\r\n                                .jackpot\r\n                                .mul(ticket.stake)\r\n                                .div(categoryBank);\r\n                            ticketWinning = ticketWinning.add(jackpotWinning);\r\n                            ticket.jackpot = true;\r\n                            tmpJackpot = tmpJackpot.sub(jackpotWinning);\r\n                        }\r\n\r\n                        ticket.winning = ticket.winning.add(ticketWinning);\r\n\r\n                        maxWinning = max(maxWinning, ticket.winning);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        newJackpot = localNewJackpot;\r\n        jackpot = tmpJackpot;\r\n        pool.maxWinning = maxWinning;\r\n    }\r\n\r\n    function categorizePlayers(Pool storage pool) private {\r\n        if (pool.state == PoolState.canceled) {\r\n            return;\r\n        }\r\n\r\n        uint256[CATEGORIES_COUNT] memory banks;\r\n\r\n        for (uint256 i = 0; i < pool.players.length && i < MAX_PLAYERS; i++) {\r\n            Ticket storage ticket = tickets[pool.id][pool.players[i]];\r\n            uint256 successVariants = 0;\r\n\r\n            for (uint256 j = 0; j < POOL_SIZE; j++) {\r\n                if (\r\n                    pool.states[j] == EventState.canceled ||\r\n                    (uint8(ticket.outcomes[j]) &\r\n                        (uint8(1) << uint8(pool.results[j]))) !=\r\n                    0\r\n                ) {\r\n                    successVariants++;\r\n                }\r\n            }\r\n\r\n            Categories playerCategory = getSuccessCategory(successVariants);\r\n\r\n            assert(uint8(playerCategory) < 8);\r\n\r\n            if (playerCategory == Categories.losing) {\r\n                banks[uint256(playerCategory)] = banks[uint256(playerCategory)]\r\n                    .add(ticket.stake);\r\n                ticket.categories |= (uint8(1) << uint8(playerCategory));\r\n            } else {\r\n                assert(successVariants >= MIN_SUCCESS_COUNT);\r\n                for (uint256 j = successVariants; j >= MIN_SUCCESS_COUNT; j--) {\r\n                    playerCategory = getSuccessCategory(j);\r\n                    banks[uint256(playerCategory)] = banks[uint256(\r\n                        playerCategory\r\n                    )]\r\n                        .add(ticket.stake);\r\n                    ticket.categories |= (uint8(1) << uint8(playerCategory));\r\n                }\r\n            }\r\n        }\r\n\r\n        pool.banks = banks;\r\n    }\r\n\r\n    function processFailedEvents(Pool storage pool, uint256 _canceledEvents)\r\n        private\r\n    {\r\n        if (_canceledEvents == 1) {\r\n            pool.jackpotPercent = 35;\r\n        } else if (_canceledEvents == 2) {\r\n            pool.jackpotPercent = 20;\r\n        } else if (_canceledEvents == 3) {\r\n            pool.jackpotPercent = 10;\r\n            set3FailedPercents(pool);\r\n        } else if (_canceledEvents == 4) {\r\n            pool.jackpotPercent = 5;\r\n            set4FailedPercents(pool);\r\n        } else if (_canceledEvents >= 5) {\r\n            pool.jackpotPercent = 0;\r\n            pool.state = PoolState.canceled;\r\n        }\r\n    }\r\n\r\n    function setDefaultPercents(Pool storage pool) private {\r\n        pool.percents[uint256(Categories.success9)] = 32;\r\n        pool.percents[uint256(Categories.success10)] = 18;\r\n        pool.percents[uint256(Categories.success11)] = 10;\r\n        pool.percents[uint256(Categories.success12)] = 10;\r\n        pool.percents[uint256(Categories.success13)] = 10;\r\n        pool.percents[uint256(Categories.success14)] = 10;\r\n        pool.percents[uint256(Categories.success15)] = 10;\r\n        pool.percents[uint256(Categories.losing)] = 0;\r\n        pool.jackpotPercent = 100;\r\n    }\r\n\r\n    function set3FailedPercents(Pool storage pool) private {\r\n        pool.percents[uint256(Categories.success9)] = 0;\r\n        pool.percents[uint256(Categories.success10)] = 40;\r\n        pool.percents[uint256(Categories.success11)] = 20;\r\n        pool.percents[uint256(Categories.success12)] = 15;\r\n        pool.percents[uint256(Categories.success13)] = 10;\r\n        pool.percents[uint256(Categories.success14)] = 10;\r\n        pool.percents[uint256(Categories.success15)] = 5;\r\n    }\r\n\r\n    function set4FailedPercents(Pool storage pool) private {\r\n        pool.percents[uint256(Categories.success9)] = 0;\r\n        pool.percents[uint256(Categories.success10)] = 0;\r\n        pool.percents[uint256(Categories.success11)] = 45;\r\n        pool.percents[uint256(Categories.success12)] = 25;\r\n        pool.percents[uint256(Categories.success13)] = 15;\r\n        pool.percents[uint256(Categories.success14)] = 10;\r\n        pool.percents[uint256(Categories.success15)] = 5;\r\n    }\r\n\r\n    function getFailedEvents(Pool storage pool) private view returns (uint256) {\r\n        uint256 canceledEvents = 0;\r\n\r\n        for (uint256 i = 0; i < POOL_SIZE; i++) {\r\n            require(\r\n                pool.states[i] != EventState.open,\r\n                \"One of the events is not closed\"\r\n            );\r\n            if (pool.states[i] == EventState.canceled) canceledEvents++;\r\n        }\r\n\r\n        return canceledEvents;\r\n    }\r\n\r\n    function isPoolExist(Pool storage pool) private view returns (bool) {\r\n        return pool.id != 0;\r\n    }\r\n\r\n    function getSuccessCategory(uint256 successCount)\r\n        private\r\n        pure\r\n        returns (Categories)\r\n    {\r\n        if (successCount < MIN_SUCCESS_COUNT) return Categories.losing;\r\n        return Categories(successCount - MIN_SUCCESS_COUNT);\r\n    }\r\n\r\n    function validateString(string memory _string, uint256 limit) private pure {\r\n        uint256 length = bytes(_string).length;\r\n        require(0 < length && length <= limit, \"Incorrect string length\");\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_poolId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_winning\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_isJackpot\",\"type\":\"bool\"}],\"name\":\"logFailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_firstEvent\",\"type\":\"string\"}],\"name\":\"logNewPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"_poolId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_winning\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_isJackpot\",\"type\":\"bool\"}],\"name\":\"logPayment\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"CATEGORIES_COUNT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FEE_PERCENT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HISTORY_SIZE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_DESCRIPTION_LENGTH\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OUTCOMES_COUNT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PLAYERS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TITLE_LENGTH\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_SUCCESS_COUNT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORACLE_FEE_PERCENT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"POOL_SIZE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"cancelPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"contractFeePercent\",\"type\":\"uint8\"}],\"name\":\"changeContractFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minStake\",\"type\":\"uint256\"}],\"name\":\"changeMinStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"oracleFeePercent\",\"type\":\"uint8\"}],\"name\":\"changeOracleFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"eventIdx\",\"type\":\"uint8\"},{\"internalType\":\"int8\",\"name\":\"result\",\"type\":\"int8\"}],\"name\":\"closeEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"closePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"createOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string[15]\",\"name\":\"titles\",\"type\":\"string[15]\"},{\"internalType\":\"string[15]\",\"name\":\"descriptions\",\"type\":\"string[15]\"},{\"internalType\":\"uint64[15]\",\"name\":\"expiries\",\"type\":\"uint64[15]\"},{\"internalType\":\"uint8\",\"name\":\"outcomes\",\"type\":\"uint8\"}],\"name\":\"createPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerHistory\",\"outputs\":[{\"internalType\":\"uint32[15]\",\"name\":\"\",\"type\":\"uint32[15]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[8]\",\"name\":\"banks\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256\",\"name\":\"bank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jackpot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWinning\",\"type\":\"uint256\"},{\"internalType\":\"address payable[]\",\"name\":\"players\",\"type\":\"address[]\"},{\"internalType\":\"string[15]\",\"name\":\"titles\",\"type\":\"string[15]\"},{\"internalType\":\"string[15]\",\"name\":\"descriptions\",\"type\":\"string[15]\"},{\"internalType\":\"uint64[15]\",\"name\":\"expiries\",\"type\":\"uint64[15]\"},{\"internalType\":\"uint8\",\"name\":\"outcomes\",\"type\":\"uint8\"},{\"internalType\":\"uint8[8]\",\"name\":\"percents\",\"type\":\"uint8[8]\"},{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"enum Ezer.PoolState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"jackpotPercent\",\"type\":\"uint8\"},{\"internalType\":\"int8[15]\",\"name\":\"results\",\"type\":\"int8[15]\"},{\"internalType\":\"enum Ezer.EventState[15]\",\"name\":\"states\",\"type\":\"uint8[15]\"}],\"internalType\":\"struct Ezer.Pool\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolsHistory\",\"outputs\":[{\"internalType\":\"uint32[15]\",\"name\":\"\",\"type\":\"uint32[15]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getTicket\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winning\",\"type\":\"uint256\"},{\"internalType\":\"bytes15\",\"name\":\"outcomes\",\"type\":\"bytes15\"},{\"internalType\":\"uint8\",\"name\":\"categories\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"jackpot\",\"type\":\"bool\"}],\"internalType\":\"struct Ezer.Ticket\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newJackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"internalType\":\"bytes15\",\"name\":\"outcomes\",\"type\":\"bytes15\"}],\"name\":\"placeTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawContractFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Ezer","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b6ceeadd82b9d681f2b70e4f4d957bc143901d855173f86575c2ff2125cbc11c"}]}