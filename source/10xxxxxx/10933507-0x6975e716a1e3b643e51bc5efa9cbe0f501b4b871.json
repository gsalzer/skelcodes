{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n * \r\n * \"Stash\" (v0.1 beta)\r\n * A simple tool for a personal smart contract wallet to help protect your assets.\r\n * \r\n * For more info checkout: https://squirrel.finance\r\n * \r\n */\r\n\r\n\r\ncontract StashFactory {\r\n    \r\n    mapping(address => address) public stashes;\r\n    address[] squirrels;\r\n    \r\n    \r\n    function createStash(address squirrel) external {\r\n        require(stashes[squirrel] == 0 && squirrel != 0);\r\n        SquirrelStash stash = new SquirrelStash(squirrel);\r\n        stashes[squirrel] = address(stash);\r\n        squirrels.push(squirrel);\r\n    }\r\n    \r\n    \r\n    function getWhitelisted(address stashAddress, uint256 startIndex, uint256 endIndex) public view returns (address[], bool[2][]) {\r\n        SquirrelStash stash = SquirrelStash(stashAddress);\r\n        \r\n        uint256 numWhitelists = (endIndex - startIndex) + 1;\r\n        if (startIndex == 0 && endIndex == 0) {\r\n            numWhitelists = stash.whitelistLength();\r\n        }\r\n\r\n        address[] memory list = new address[](numWhitelists);\r\n        bool[2][] memory approved = new bool[2][](numWhitelists);\r\n        for (uint256 i = 0; i < numWhitelists; i++) {\r\n            address recipient = stash.whitelist(i + startIndex);\r\n            list[i] = recipient;\r\n            (, approved[i][0], approved[i][1]) = stash.whitelistedAddress(recipient);\r\n        }\r\n        return (list, approved);\r\n    }\r\n    \r\n    \r\n    function getAdmins(address stashAddress, uint256 startIndex, uint256 endIndex) public view returns (address[]) {\r\n        SquirrelStash stash = SquirrelStash(stashAddress);\r\n        \r\n        uint256 numAdmins = (endIndex - startIndex) + 1;\r\n        if (startIndex == 0 && endIndex == 0) {\r\n            numAdmins = stash.adminsLength();\r\n        }\r\n\r\n        address[] memory list = new address[](numAdmins);\r\n        for (uint256 i = 0; i < numAdmins; i++) {\r\n            list[i] = stash.admins(i + startIndex);\r\n        }\r\n        return (list);\r\n    }\r\n    \r\n    function getSquirrels(uint256 startIndex, uint256 endIndex) public view returns (address[]) {\r\n        uint256 numSquirrels = (endIndex - startIndex) + 1;\r\n        if (startIndex == 0 && endIndex == 0) {\r\n            numSquirrels = squirrels.length;\r\n        }\r\n\r\n        address[] memory list = new address[](numSquirrels);\r\n        for (uint256 i = 0; i < numSquirrels; i++) {\r\n            list[i] = squirrels[i + startIndex];\r\n        }\r\n        return (list);\r\n    }\r\n    \r\n    \r\n    function getLatestHistory(address stashAddress, uint256 startIndex, uint256 amount) external view returns (address[], address[], uint256[8][], uint256) {\r\n        SquirrelStash stash = SquirrelStash(stashAddress);\r\n        \r\n        uint256 toFetch = amount;\r\n        if (stash.historyLength() < amount) {\r\n            toFetch = stash.historyLength();\r\n        }\r\n        if (stash.historyLength() < startIndex + amount) {\r\n            toFetch = stash.historyLength() - startIndex;\r\n        }\r\n\r\n        address[] memory recipients = new address[](toFetch);\r\n        address[] memory tokens = new address[](toFetch);\r\n        uint256[8][] memory extraData = new uint256[8][](toFetch);\r\n        uint256 index = (stash.historyLength() - 1) - startIndex;\r\n        for (uint256 i = 0; i < toFetch; i++) {\r\n            setData1(recipients, tokens, index, i, stash);\r\n            setData2(extraData, index, i, stash);\r\n            setData3(extraData, index, i, stash);\r\n        }\r\n\r\n        return (recipients, tokens, extraData, stash.historyLength());\r\n    }\r\n    \r\n    \r\n    function setData1(address[] recipients, address[] tokens, uint256 index, uint256 i, SquirrelStash stash) internal view {\r\n        (recipients[i], tokens[i], , , , , , , ) = stash.history(index - i);\r\n    }\r\n    \r\n    function setData2(uint256[8][] extraData, uint256 index, uint256 i, SquirrelStash stash) internal view {\r\n        (, , extraData[i][0], extraData[i][1], extraData[i][2], extraData[i][3], extraData[i][4], , ) = stash.history(index - i);\r\n    }\r\n    \r\n    function setData3(uint256[8][] extraData, uint256 index, uint256 i, SquirrelStash stash) internal view {\r\n        (, , , , , , , bool ethApproved, bool tokenApproved) = stash.history(index - i);\r\n        extraData[i][5] = ethApproved ? 1 : 0;\r\n        extraData[i][6] = tokenApproved ? 1 : 0;\r\n        extraData[i][7] = index - i;\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract SquirrelStash {\r\n\r\n    mapping(address => uint256) private adminAddresses; // Can withdraw to whitelisted addresses only\r\n    address[] public admins;\r\n    \r\n    address[] public whitelist;\r\n    mapping(address => Whitelisted) public whitelistedAddress;\r\n    mapping(address => bytes32) private addressPasswords; // Hashed\r\n    mapping(uint256 => bytes32) private pendingPasswords;\r\n    \r\n    mapping(address => mapping(address => uint256)) private addressLimits;\r\n    mapping(address => mapping(address => LimitUpdate)) private pendingLimitUpdate;\r\n    \r\n    mapping(address => mapping(address => uint256)) private limitEpochEnds;\r\n    mapping(address => mapping(address => uint256)) private limitEpochSpent;\r\n    \r\n    uint8 constant public ACTION_EDIT_PASSWORD = 1;\r\n    uint8 constant public ACTION_EDIT_ADMIN = 2;\r\n    uint8 constant public ACTION_WITHDRAW_TOKEN = 3;\r\n    uint8 constant public ACTION_WITHDRAW_ETH = 4;\r\n    uint8 constant public ACTION_ADD_RECIPIENT = 5;\r\n    uint8 constant public ACTION_EDIT_DELAY = 6;\r\n    uint8 constant public ACTION_EDIT_LIMIT = 7;\r\n    \r\n    uint8 constant public STATE_PENDING = 0;\r\n    uint8 constant public STATE_COMPLETED = 1;\r\n    uint8 constant public STATE_CANCELLED = 2;\r\n    \r\n    History[] public history;\r\n    uint256 public DELAY_TIMER = 3 days;\r\n    \r\n    struct Whitelisted {\r\n        uint128 index;\r\n        bool ethApproved;\r\n        bool tokenApproved;\r\n    }\r\n    \r\n    struct LimitUpdate {\r\n        uint128 etaTimestamp;\r\n        uint128 limit;\r\n    }\r\n    \r\n    struct History {\r\n        address recipient;\r\n        address token;\r\n        uint8 action;\r\n        uint8 state;\r\n        uint128 amount;\r\n        uint48 epoch;\r\n        uint48 eta;\r\n        bool ethApproved;\r\n        bool tokenApproved;\r\n    }\r\n\r\n    modifier adminOnly() {\r\n        require(adminAddresses[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    constructor(address squirrel) public {\r\n        admins.push(squirrel);\r\n        adminAddresses[squirrel] = 1;\r\n    }\r\n    \r\n    function() external payable { /** Accepts eth **/ }\r\n    \r\n    \r\n    function whitelistAddress(address candidate, bool tokenApproved, bool ethApproved) external adminOnly {\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        history.push(History(candidate, msg.sender, ACTION_ADD_RECIPIENT, STATE_PENDING, 0, uint48(now), eta, tokenApproved, ethApproved));\r\n    }\r\n\r\n\r\n    function triggerWhiteListApproval(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_ADD_RECIPIENT);\r\n        require(pending.state == STATE_PENDING);\r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            if (pending.eta > 0 && pending.eta < now) {\r\n                updateCandidate(pending);\r\n                pending.state = STATE_COMPLETED;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function updateCandidate(History action) internal {\r\n        address candidate = action.recipient;\r\n        uint128 index = whitelistedAddress[candidate].index;\r\n        bool approving = (action.ethApproved || action.tokenApproved);\r\n        if (index == 0 && approving) {\r\n            whitelist.push(candidate); // Add new recipient\r\n            whitelistedAddress[candidate] = Whitelisted(uint128(whitelist.length), action.ethApproved, action.tokenApproved);\r\n        } else if (index > 0) {\r\n            if (approving) {\r\n                Whitelisted memory data = whitelistedAddress[candidate];\r\n                data.ethApproved = action.ethApproved;\r\n                data.tokenApproved = action.tokenApproved;\r\n                whitelistedAddress[candidate] = data;\r\n            } else { // Removing from whitelist\r\n                uint256 numWhitelisted = whitelist.length;\r\n                delete whitelistedAddress[candidate];\r\n                if (numWhitelisted > 1) {\r\n                    whitelist[index - 1] = whitelist[numWhitelisted - 1];\r\n                }\r\n                delete whitelist[numWhitelisted - 1];\r\n                whitelist.length--;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function editPassword(address candidate, bytes32 hash) external adminOnly {\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        pendingPasswords[history.length] = hash;\r\n        history.push(History(candidate, msg.sender, ACTION_EDIT_PASSWORD, STATE_PENDING, 0, uint48(now), eta, hash != 0, false));\r\n    }\r\n    \r\n    function triggerPasswordUpdate(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_PASSWORD);\r\n        require(pending.state == STATE_PENDING);\r\n        \r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            bytes32 newPassword = pendingPasswords[index];\r\n            if (newPassword == keccak256(\"\")) {\r\n                delete addressPasswords[pending.recipient];\r\n            } else {\r\n                addressPasswords[pending.recipient] = newPassword;\r\n            }\r\n            delete pendingPasswords[index];\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n    \r\n\r\n    function editAdmin(address candidate, bool isAdmin) external adminOnly {\r\n        require(candidate != msg.sender); // Don't edit yourself\r\n        \r\n        if (isAdmin && adminAddresses[candidate] == 0) {\r\n            admins.push(candidate); // Add new admin\r\n            adminAddresses[candidate] = admins.length;\r\n            history.push(History(candidate, msg.sender, ACTION_EDIT_ADMIN, STATE_COMPLETED, 0, uint48(now), 0, isAdmin, false));\r\n        } else if (!isAdmin && adminAddresses[candidate] > 0) {\r\n            uint48 eta = uint48(now + DELAY_TIMER); // Removing admin\r\n            history.push(History(candidate, msg.sender, ACTION_EDIT_ADMIN, STATE_PENDING, 0, uint48(now), eta, false, false));\r\n        }\r\n    }\r\n    \r\n    function triggerAdminRemoval(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_ADMIN);\r\n        require(pending.state == STATE_PENDING);\r\n        \r\n         if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.recipient != msg.sender); // Don't remove yourself\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            uint256 numAdmins = admins.length;\r\n            uint256 adminIndex = adminAddresses[pending.recipient] - 1;\r\n            delete adminAddresses[pending.recipient]; // Remove old admin\r\n            if (numAdmins > 1) {\r\n                admins[adminIndex] = admins[numAdmins - 1];\r\n            }\r\n            delete admins[numAdmins - 1];\r\n            admins.length--;\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n    \r\n    \r\n    function editWithdrawLimit(address candidate, address token, uint128 limit) external adminOnly {\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        pendingLimitUpdate[candidate][token] = LimitUpdate(eta, limit);\r\n        history.push(History(candidate, token, ACTION_EDIT_LIMIT, STATE_PENDING, limit, uint48(now), eta, false, false));\r\n    }\r\n    \r\n    function triggerLimitUpdate(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_LIMIT);\r\n        require(pending.state == STATE_PENDING);\r\n        \r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            if (pending.amount > 0) {\r\n                addressLimits[pending.recipient][pending.token] = pending.amount;\r\n            } else {\r\n                delete addressLimits[pending.recipient][pending.token];\r\n            }\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n    \r\n    \r\n    function editDelay(uint128 newDelay) external adminOnly {\r\n        require(newDelay >= 24 hours && newDelay <= 30 days);\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        history.push(History(0, msg.sender, ACTION_EDIT_DELAY, STATE_PENDING, newDelay, uint48(now), eta, false, false));\r\n    }\r\n    \r\n    function triggerDelayUpdate(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_DELAY);\r\n        require(pending.state == STATE_PENDING);\r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            DELAY_TIMER = pending.amount;\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n\r\n\r\n    function withdrawToken(address recipient, address token, uint256 amount) external adminOnly {\r\n        withdrawTokenInternal(recipient, token, amount);\r\n    }\r\n    \r\n    function withdrawToken(address recipient, address token, uint256 amount, string password) external {\r\n        validatePassword(recipient, password);\r\n        withdrawTokenInternal(recipient, token, amount);\r\n    }\r\n    \r\n    function withdrawTokenInternal(address recipient, address token, uint256 amount) internal {\r\n        require(whitelistedAddress[recipient].tokenApproved);\r\n        validateLimits(recipient, token, amount);\r\n        history.push(History(recipient, token, ACTION_WITHDRAW_TOKEN, STATE_COMPLETED, uint128(amount), uint48(now), 0, false, false));\r\n        ERC20(token).transfer(recipient, amount);\r\n    }\r\n    \r\n    function withdrawEth(address recipient, uint256 amount) external adminOnly {\r\n        withdrawEthInternal(recipient, amount);\r\n    }\r\n    \r\n    function withdrawEth(address recipient, uint256 amount, string password) external {\r\n        validatePassword(recipient, password);\r\n        withdrawEthInternal(recipient, amount);\r\n    }\r\n    \r\n    function withdrawEthInternal(address recipient, uint256 amount) internal {\r\n        require(whitelistedAddress[recipient].ethApproved);\r\n        validateLimits(recipient, 0, amount);\r\n        history.push(History(recipient, 0, ACTION_WITHDRAW_ETH, STATE_COMPLETED, uint128(amount), uint48(now), 0, false, false));\r\n        recipient.transfer(amount);\r\n    }\r\n    \r\n    \r\n    function validatePassword(address recipient, string password) view internal {\r\n        bytes32 key = addressPasswords[recipient];\r\n        require(key != 0);\r\n        require(keccak256(password) == key);\r\n    }\r\n    \r\n    function validateLimits(address recipient, address token, uint256 amount) internal {\r\n        require(uint256(amount) == uint128(amount));\r\n        uint256 limit = addressLimits[recipient][token];\r\n        if (limit > 0) {\r\n            if (limitEpochEnds[recipient][token] < now) {\r\n                require(amount <= limit);\r\n                limitEpochEnds[recipient][token] = now + 24 hours; // Daily withdrawal limit\r\n                limitEpochSpent[recipient][token] = amount;\r\n            } else {\r\n                uint256 totalToday = amount + limitEpochSpent[recipient][token];\r\n                require(totalToday <= limit);\r\n                limitEpochSpent[recipient][token] = totalToday;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function hashed(address recipient) external view returns (bool) {\r\n        return addressPasswords[recipient] != 0;\r\n    }\r\n    \r\n    function adminsLength() public view returns (uint256) {\r\n        return admins.length;\r\n    }\r\n    \r\n    function whitelistLength() public view returns (uint256) {\r\n        return whitelist.length;\r\n    }\r\n    \r\n    function historyLength() public view returns (uint256) {\r\n        return history.length;\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20 {\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    \r\n    string public symbol;\r\n    uint8 public decimals;\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"squirrel\",\"type\":\"address\"}],\"name\":\"createStash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stashAddress\",\"type\":\"address\"},{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getLatestHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[8][]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stashAddress\",\"type\":\"address\"},{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getAdmins\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stashAddress\",\"type\":\"address\"},{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"bool[2][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getSquirrels\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stashes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StashFactory","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9904800d0322d4f683bffb0f13bde9ff1abd58dabf195c7322a50321cdfc2f51"}]}