{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.6;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title Docs interface for registering files\r\n/// @author taek lee <leekt216@gmail.com>\r\n/// @notice Used for Registering and Updating docs hash\r\n/// @dev deployed per template id\r\ninterface IDocs {\r\n    /// @notice emited when new file is registered\r\n    /// @param user address of registering user\r\n    /// @param hash 256bit hash of file\r\n    /// @param created created timestamp as unix timestamp\r\n    event DocsRegistered(address user, bytes32 hash, uint128 created);\r\n\r\n    /// @notice emited when file is deleted\r\n    /// @param user address of file owner\r\n    /// @param hash file hash\r\n    event DocsDeleted(address user, bytes32 hash);\r\n\r\n    /// @notice registers `_file` with `_hash`\r\n    /// @param _hash file hash\r\n    /// @return success true if succeeded\r\n    function registerDocs(bytes32 _hash) external returns(bool success);\r\n\r\n    /// @notice deletes document `_file`\r\n    /// @param _hash file hash\r\n    /// @return success true if succeeded\r\n    function deleteDocs(bytes32 _hash) external returns(bool success);\r\n\r\n    /// @notice deletes old hash and registers new hash\r\n    /// @param _hash old file hash\r\n    /// @param _newHash new file hash\r\n    function updateDocs(bytes32 _hash, bytes32 _newHash) external returns(bool success);\r\n\r\n    /// @notice get `_file` info\r\n    /// @param _user address of file owner\r\n    /// @param _hash file hash\r\n    /// @return hash 256bit hash of file\r\n    /// @return created created timestamp\r\n    function docInfo(address _user, bytes32 _hash) external view returns(bytes32 hash, uint256 created);\r\n\r\n    function getDocs(address _user) external view returns(bytes32[] memory docs);\r\n\r\n}\r\n\r\n// File: contracts/models/Document.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\nstruct Document {\r\n    bytes32 hash;\r\n    uint128 createdAt;\r\n}\r\n\r\n// File: contracts/interface/IOwnable.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IOwnable {\r\n    event OwnershipTransferred(\r\n        address indexed currentOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    function owner() external view returns (address ownerAddress);\r\n\r\n    function transferOwnership(address newOwner) external returns (bool success);\r\n\r\n    function renounceOwnership() external returns (bool success);\r\n}\r\n\r\n// File: contracts/library/Ownable.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract Ownable is IOwnable{\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed currentOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == _owner,\r\n            \"Ownable : Function called by unauthorized user.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function owner() external view override returns (address ownerAddress) {\r\n        ownerAddress = _owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner)\r\n        external\r\n        override\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        require(newOwner != address(0), \"TransferOwnership/User renounceOwnership() for deleting owner\");\r\n        return _transferOwnership(newOwner);\r\n    }\r\n\r\n    function renounceOwnership() external override onlyOwner returns (bool success) {\r\n        success = _transferOwnership(address(0));\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal returns (bool success) {\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n        success = true;\r\n    }\r\n}\r\n\r\n// File: contracts/Docs.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\ncontract Docs is IDocs, Ownable {\r\n\r\n    // docs id => document detail\r\n    mapping(bytes32 => Document) internal _docs;\r\n    // user address => docs id []\r\n    mapping(address => bytes32[]) internal _userDocs;\r\n\r\n    function registerDocs(bytes32 _hash) external override returns(bool success) {\r\n        require(_hash != bytes32(0), \"Register/Invalid Hash\");\r\n        return _addDocs(msg.sender, _hash);\r\n    }\r\n\r\n    function deleteDocs(bytes32 _hash) external override returns(bool success) {\r\n        return _deleteDocs(msg.sender, _hash);\r\n    }\r\n\r\n    function updateDocs(bytes32 _hash, bytes32 _newHash) external override returns(bool success){\r\n        require(_newHash != bytes32(0), \"Update/Invalid Hash\");\r\n        _deleteDocs(msg.sender, _hash);\r\n        _addDocs(msg.sender, _newHash);\r\n        return true;\r\n    }\r\n\r\n    function docInfo(address _user, bytes32 _hash) external override view returns(bytes32 hash, uint256 created) {\r\n        bytes32 key = _getKey(_user, _hash);\r\n        Document memory doc = _docs[key];\r\n        hash = doc.hash;\r\n        created = doc.createdAt;\r\n    }\r\n\r\n    function getDocs(address _user) external override view returns(bytes32[] memory docs){\r\n        docs = _userDocs[_user];\r\n    }\r\n\r\n    function _addDocs(address _user, bytes32 _hash) internal returns(bool success) {\r\n        bytes32 key = _getKey(_user, _hash);\r\n        _userDocs[_user].push(_hash);\r\n        Document storage doc = _docs[key];\r\n        require(doc.hash == bytes32(0), \"Register/Already Registered\");\r\n        doc.hash = _hash;\r\n        doc.createdAt = uint128(now);\r\n        emit DocsRegistered(_user, _hash, uint128(now));\r\n        success = true;\r\n    }\r\n\r\n    function _deleteDocs(address _user, bytes32 _hash) internal returns(bool success){\r\n        bytes32 key = _getKey(_user, _hash);\r\n        uint256 index = _getIndex(_user, key);\r\n        _userDocs[_user][index] = _userDocs[_user][_userDocs[_user].length-1];\r\n        delete _docs[key];\r\n        _userDocs[_user].pop();\r\n        emit DocsDeleted(_user, _hash);\r\n        return true;\r\n    }\r\n\r\n    function _getKey(address _user, bytes32 _hash) internal pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(_user,_hash));\r\n    }\r\n\r\n    function _getIndex(address _user, bytes32 _docsId) internal view returns(uint256 index) {\r\n        for(index = 0; index < _userDocs[_user].length; index++){\r\n            if(_getKey(_user, _userDocs[_user][index]) == _docsId){\r\n                return index;\r\n            }\r\n        }\r\n        revert(\"Document not found!\");\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"DocsDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"created\",\"type\":\"uint128\"}],\"name\":\"DocsRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"deleteDocs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"docInfo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDocs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"docs\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"registerDocs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_newHash\",\"type\":\"bytes32\"}],\"name\":\"updateDocs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Docs","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","EVMVersion":"petersburg","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3c245070782bb99a59a19c968b20a213b9d5e0e06827cfd6dd5f1ab6adac73ac"}]}