{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Authereum Labs, Inc.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title AccountStateV1\n * @author Authereum Labs, Inc.\n * @dev This contract holds the state variables used by the account contracts.\n * @dev This abstraction exists in order to retain the order of the state variables.\n */\ncontract AccountStateV1 {\n    uint256 public lastInitializedVersion;\n    mapping(address => bool) public authKeys;\n    uint256 public nonce;\n    uint256 public numAuthKeys;\n}\n\n/**\n * @title AccountState\n * @author Authereum Labs, Inc.\n * @dev This contract holds the state variables used by the account contracts.\n * @dev This exists as the main contract to hold state. This contract is inherited\n * @dev by Account.sol, which will not care about state as long as it inherits\n * @dev AccountState.sol. Any state variable additions will be made to the various\n * @dev versions of AccountStateVX that this contract will inherit.\n */\ncontract AccountState is AccountStateV1 {}\n\n/**\n * @title AccountEvents\n * @author Authereum Labs, Inc.\n * @dev This contract holds the events used by the Authereum contracts.\n * @dev This abstraction exists in order to retain the order to give initialization functions\n * @dev access to events.\n * @dev This contract can be overwritten with no changes to the upgradeability.\n */\ncontract AccountEvents {\n\n    /**\n     * BaseAccount.sol\n     */\n\n    event AuthKeyAdded(address indexed authKey);\n    event AuthKeyRemoved(address indexed authKey);\n    event CallFailed(string reason);\n\n    /**\n     * AccountUpgradeability.sol\n     */\n\n    event Upgraded(address indexed implementation);\n}\n\n/**\n * @title AccountInitializeV1\n * @author Authereum Labs, Inc.\n * @dev This contract holds the initialize function used by the account contracts.\n * @dev This abstraction exists in order to retain the order of the initialization functions.\n */\ncontract AccountInitializeV1 is AccountState, AccountEvents {\n\n    /// @dev Initialize the Authereum Account\n    /// @param _authKey authKey that will own this account\n    function initializeV1(\n        address _authKey\n    )\n        public\n    {\n        require(lastInitializedVersion == 0, \"AI: Improper initialization order\");\n        lastInitializedVersion = 1;\n\n        // Add first authKey\n        authKeys[_authKey] = true;\n        numAuthKeys += 1;\n        emit AuthKeyAdded(_authKey);\n    }\n}\n\ncontract IERC20 {\n    function balanceOf(address account) external returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n/**\n * @title AccountInitializeV2\n * @author Authereum Labs, Inc.\n * @dev This contract holds the initialize function used by the account contracts.\n * @dev This abstraction exists in order to retain the order of the initialization functions.\n */\ncontract AccountInitializeV2 is AccountState {\n\n    /// @dev Add the ability to refund the contract for a deployment\n    /// @param _deploymentCost Cost of the deployment\n    /// @param _deploymentFeeTokenAddress Address of the token used to pay a deployment fee\n    function initializeV2(\n        uint256 _deploymentCost,\n        address _deploymentFeeTokenAddress\n    )\n        public\n    {\n        require(lastInitializedVersion == 1, \"AI2: Improper initialization order\");\n        lastInitializedVersion = 2;\n\n        if (_deploymentCost != 0) {\n            if (_deploymentFeeTokenAddress == address(0)) {\n                uint256 amountToTransfer = _deploymentCost < address(this).balance ? _deploymentCost : address(this).balance;\n                tx.origin.transfer(amountToTransfer);\n            } else {\n                IERC20 deploymentFeeToken = IERC20(_deploymentFeeTokenAddress);\n                uint256 userBalanceOf = deploymentFeeToken.balanceOf(address(this));\n                uint256 amountToTransfer = _deploymentCost < userBalanceOf ? _deploymentCost : userBalanceOf;\n                deploymentFeeToken.transfer(tx.origin, amountToTransfer);\n            }\n        }\n    }\n}\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n\n/**\n * @title AccountInitializeV3\n * @author Authereum Labs, Inc.\n * @dev This contract holds the initialize function used by the account contracts.\n * @dev This abstraction exists in order to retain the order of the initialization functions.\n */\ncontract AccountInitializeV3 is AccountState {\n\n    address constant private ERC1820_REGISTRY_ADDRESS = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n    /// @dev Initialize the Authereum Account with the 1820 registry\n    function initializeV3() public {\n        require(lastInitializedVersion == 2, \"AI3: Improper initialization order\");\n        lastInitializedVersion = 3;\n\n        IERC1820Registry registry = IERC1820Registry(ERC1820_REGISTRY_ADDRESS);\n        registry.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n    }\n}\n\n/**\n * @title AccountInitialize\n * @author Authereum Labs, Inc.\n * @dev This contract holds the initialize functions used by the account contracts.\n * @dev This exists as the main contract to hold these functions. This contract is inherited\n * @dev by AuthereumAccount.sol, which will not care about initialization functions as long as it inherits\n * @dev AccountInitialize.sol. Any initialization function additions will be made to the various\n * @dev versions of AccountInitializeVx that this contract will inherit.\n */\ncontract AccountInitialize is AccountInitializeV1, AccountInitializeV2, AccountInitializeV3 {}\n\ncontract TokenReceiverHooks {\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n    bytes32 constant private ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n\n    /**\n     *  ERC721\n     */\n\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * param operator The address which called `safeTransferFrom` function\n     * param from The address which previously owned the token\n     * param tokenId The NFT identifier which is being transferred\n     * param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     *  ERC1155\n     */\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns(bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @notice Handle the receipt of multiple ERC1155 token types.\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n     * This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n     * This function MUST revert if it rejects the transfer(s).\n     * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n     * param _operator  The address which initiated the batch transfer (i.e. msg.sender)\n     * param _from      The address which previously owned the token\n     * param _ids       An array containing ids of each token being transferred (order and length must match _values array)\n     * param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\n     * param _data      Additional data with no specified format\n     * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     */\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external returns(bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     *  ERC777\n     */\n\n    /// @dev Notify a send or mint (if from is 0x0) of amount tokens from the from address to the\n    ///      to address by the operator address.\n    /// param operator Address which triggered the balance increase (through sending or minting).\n    /// param from Holder whose tokens were sent (or 0x0 for a mint).\n    /// param to Recipient of the tokens.\n    /// param amount Number of tokens the recipient balance is increased by.\n    /// param data Information provided by the holder.\n    /// param operatorData Information provided by the operator.\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external { }\n\n    /**\n     *  ERC1820\n     */\n\n    /// @dev Indicates whether the contract implements the interface `interfaceHash` for the address `addr` or not.\n    /// @param interfaceHash keccak256 hash of the name of the interface\n    /// @param addr Address for which the contract will implement the interface\n    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements `interfaceHash` for the address `addr`.\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32) {\n        if (interfaceHash == TOKENS_RECIPIENT_INTERFACE_HASH && addr == address(this)) {\n            return ERC1820_ACCEPT_MAGIC;\n        }\n    }\n}\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n * \n * This contract is from openzeppelin-solidity 2.4.0\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * This contract is from openzeppelin-solidity 2.4.0\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_start + 1 >= _start, \"toUint8_overflow\");\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_start + 2 >= _start, \"toUint16_overflow\");\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_start + 4 >= _start, \"toUint32_overflow\");\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_start + 8 >= _start, \"toUint64_overflow\");\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_start + 12 >= _start, \"toUint96_overflow\");\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_start + 16 >= _start, \"toUint128_overflow\");\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_start + 32 >= _start, \"toUint256_overflow\");\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes4(bytes memory _bytes, uint256 _start) internal  pure returns (bytes4) {\n        require(_start + 4 >= _start, \"toBytes4_overflow\");\n        require(_bytes.length >= _start + 4, \"toBytes4_outOfBounds\");\n        bytes4 tempBytes4;\n\n        assembly {\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes4;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_start + 32 >= _start, \"toBytes32_overflow\");\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n\n/*\n * @title String & slice utility library for Solidity contracts.\n * @author Nick Johnson <arachnid@notdot.net>\n *\n * @dev Functionality in this library is largely implemented using an\n *      abstraction called a 'slice'. A slice represents a part of a string -\n *      anything from the entire string to a single character, or even no\n *      characters at all (a 0-length slice). Since a slice only has to specify\n *      an offset and a length, copying and manipulating slices is a lot less\n *      expensive than copying and manipulating the strings they reference.\n *\n *      To further reduce gas costs, most functions on slice that need to return\n *      a slice modify the original one instead of allocating a new one; for\n *      instance, `s.split(\".\")` will return the text up to the first '.',\n *      modifying s to only contain the remainder of the string after the '.'.\n *      In situations where you do not want to modify the original slice, you\n *      can make a copy first with `.copy()`, for example:\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\n *      Solidity has no memory management, it will result in allocating many\n *      short-lived slices that are later discarded.\n *\n *      Functions that return two slices come in two versions: a non-allocating\n *      version that takes the second slice as an argument, modifying it in\n *      place, and an allocating version that allocates and returns the second\n *      slice; see `nextRune` for example.\n *\n *      Functions that have to copy string data will return strings rather than\n *      slices; these can be cast back to slices for further processing if\n *      required.\n *\n *      For convenience, some functions are provided with non-modifying\n *      variants that create a new slice and return both; for instance,\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\n *      corresponding to the left and right parts of the string.\n */\n/* solium-disable */\nlibrary strings {\n    struct slice {\n        uint _len;\n        uint _ptr;\n    }\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n        // Copy word-length chunks while possible\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n     * @dev Returns a slice containing the entire string.\n     * @param self The string to make a slice from.\n     * @return A newly allocated slice containing the entire string.\n     */\n    function toSlice(string memory self) internal pure returns (slice memory) {\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }\n\n    /*\n     * @dev Returns the length of a null-terminated bytes32 string.\n     * @param self The value to find the length of.\n     * @return The length of the string, from 0 to 32.\n     */\n    function len(bytes32 self) internal pure returns (uint) {\n        uint ret;\n        if (self == 0)\n            return 0;\n        if (uint256(self) & 0xffffffffffffffffffffffffffffffff == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }\n        if (uint256(self) & 0xffffffffffffffff == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }\n        if (uint256(self) & 0xffffffff == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }\n        if (uint256(self) & 0xffff == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }\n        if (uint256(self) & 0xff == 0) {\n            ret += 1;\n        }\n        return 32 - ret;\n    }\n\n    /*\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n     *      null-terminated utf-8 string.\n     * @param self The bytes32 value to convert to a slice.\n     * @return A new slice containing the value of the input argument up to the\n     *         first null.\n     */\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret._len = len(self);\n    }\n\n    /*\n     * @dev Returns a new slice containing the same data as the current slice.\n     * @param self The slice to copy.\n     * @return A new slice containing the same data as `self`.\n     */\n    function copy(slice memory self) internal pure returns (slice memory) {\n        return slice(self._len, self._ptr);\n    }\n\n    /*\n     * @dev Copies a slice to a new string.\n     * @param self The slice to copy.\n     * @return A newly allocated string containing the slice's text.\n     */\n    function toString(slice memory self) internal pure returns (string memory) {\n        string memory ret = new string(self._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n        return ret;\n    }\n\n    /*\n     * @dev Returns the length in runes of the slice. Note that this operation\n     *      takes time proportional to the length of the slice; avoid using it\n     *      in loops, and call `slice.empty()` if you only need to know whether\n     *      the slice is empty or not.\n     * @param self The slice to operate on.\n     * @return The length of the slice in runes.\n     */\n    function len(slice memory self) internal pure returns (uint l) {\n        // Starting at ptr-31 means the LSB will be the byte we care about\n        uint ptr = self._ptr - 31;\n        uint end = ptr + self._len;\n        for (l = 0; ptr < end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n    }\n\n    /*\n     * @dev Returns true if the slice is empty (has a length of 0).\n     * @param self The slice to operate on.\n     * @return True if the slice is empty, False otherwise.\n     */\n    function empty(slice memory self) internal pure returns (bool) {\n        return self._len == 0;\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two slices are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first slice to compare.\n     * @param other The second slice to compare.\n     * @return The result of the comparison.\n     */\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n        uint shortest = self._len;\n        if (other._len < self._len)\n            shortest = other._len;\n\n        uint selfptr = self._ptr;\n        uint otherptr = other._ptr;\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask = uint256(-1); // 0xffff...\n                if(shortest < 32) {\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                uint256 diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n        return int(self._len) - int(other._len);\n    }\n\n    /*\n     * @dev Returns true if the two slices contain the same text.\n     * @param self The first slice to compare.\n     * @param self The second slice to compare.\n     * @return True if the slices are equal, false otherwise.\n     */\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n        return compare(self, other) == 0;\n    }\n\n    /*\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n     *      slice to point to the next rune and returning `self`.\n     * @param self The slice to operate on.\n     * @param rune The slice that will contain the first rune.\n     * @return `rune`.\n     */\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n        rune._ptr = self._ptr;\n\n        if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }\n\n        uint l;\n        uint b;\n        // Load the first byte of the rune into the LSBs of b\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if (b < 0x80) {\n            l = 1;\n        } else if(b < 0xE0) {\n            l = 2;\n        } else if(b < 0xF0) {\n            l = 3;\n        } else {\n            l = 4;\n        }\n\n        // Check for truncated codepoints\n        if (l > self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }\n\n        self._ptr += l;\n        self._len -= l;\n        rune._len = l;\n        return rune;\n    }\n\n    /*\n     * @dev Returns the first rune in the slice, advancing the slice to point\n     *      to the next rune.\n     * @param self The slice to operate on.\n     * @return A slice containing only the first rune from `self`.\n     */\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n        nextRune(self, ret);\n    }\n\n    /*\n     * @dev Returns the number of the first codepoint in the slice.\n     * @param self The slice to operate on.\n     * @return The number of the first codepoint in the slice.\n     */\n    function ord(slice memory self) internal pure returns (uint ret) {\n        if (self._len == 0) {\n            return 0;\n        }\n\n        uint word;\n        uint length;\n        uint divisor = 2 ** 248;\n\n        // Load the rune into the MSBs of b\n        assembly { word:= mload(mload(add(self, 32))) }\n        uint b = word / divisor;\n        if (b < 0x80) {\n            ret = b;\n            length = 1;\n        } else if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }\n\n        // Check for truncated codepoints\n        if (length > self._len) {\n            return 0;\n        }\n\n        for (uint i = 1; i < length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }\n\n        return ret;\n    }\n\n    /*\n     * @dev Returns the keccak-256 hash of the slice.\n     * @param self The slice to hash.\n     * @return The hash of the slice.\n     */\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }\n\n    /*\n     * @dev Returns true if `self` starts with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        if (self._ptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return equal;\n    }\n\n    /*\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        bool equal = true;\n        if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }\n\n        return self;\n    }\n\n    /*\n     * @dev Returns true if the slice ends with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        if (selfptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return equal;\n    }\n\n    /*\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n     *      end of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n        bool equal = true;\n        if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n        }\n\n        return self;\n    }\n\n    // Returns the memory address of the first byte of the first occurrence of\n    // `needle` in `self`, or the first byte after `self` if not found.\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr = selfptr;\n        uint idx;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                uint end = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr >= end)\n                        return selfptr + selflen;\n                    ptr++;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }\n        return selfptr + selflen;\n    }\n\n    // Returns the memory address of the first byte after the last occurrence of\n    // `needle` in `self`, or the address of `self` if not found.\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                ptr = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr <= selfptr)\n                        return selfptr;\n                    ptr--;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr + needlelen;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }\n\n    /*\n     * @dev Modifies `self` to contain everything from the first occurrence of\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n     *      if `needle` is not found.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len -= ptr - self._ptr;\n        self._ptr = ptr;\n        return self;\n    }\n\n    /*\n     * @dev Modifies `self` to contain the part of the string from the start of\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n     *      is not found, `self` is set to the empty slice.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len = ptr - self._ptr;\n        return self;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and `token` to everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = self._ptr;\n        token._len = ptr - self._ptr;\n        if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and returning everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` up to the first occurrence of `delim`.\n     */\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        split(self, needle, token);\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and `token` to everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and returning everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` after the last occurrence of `delim`.\n     */\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        rsplit(self, needle, token);\n    }\n\n    /*\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return The number of occurrences of `needle` found in `self`.\n     */\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n        while (ptr <= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }\n    }\n\n    /*\n     * @dev Returns True if `self` contains `needle`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return True if `needle` is found in `self`, false otherwise.\n     */\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n    }\n\n    /*\n     * @dev Returns a newly allocated string containing the concatenation of\n     *      `self` and `other`.\n     * @param self The first slice to concatenate.\n     * @param other The second slice to concatenate.\n     * @return The concatenation of the two strings.\n     */\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n        string memory ret = new string(self._len + other._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n        memcpy(retptr, self._ptr, self._len);\n        memcpy(retptr + self._len, other._ptr, other._len);\n        return ret;\n    }\n\n    /*\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n     *      newly allocated string.\n     * @param self The delimiter to use.\n     * @param parts A list of slices to join.\n     * @return A newly allocated string containing all the slices in `parts`,\n     *         joined with `self`.\n     */\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n        if (parts.length == 0)\n            return \"\";\n\n        uint length = self._len * (parts.length - 1);\n        for(uint i = 0; i < parts.length; i++)\n            length += parts[i]._len;\n\n        string memory ret = new string(length);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        for(uint i = 0; i < parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }\n\n        return ret;\n    }\n}\n\n/**\n * @title BaseAccount\n * @author Authereum Labs, Inc.\n * @dev Base account contract. Performs most of the functionality\n * @dev of an Authereum account contract.\n */\ncontract BaseAccount is AccountState, AccountInitialize, TokenReceiverHooks {\n    using SafeMath for uint256;\n    using ECDSA for bytes32;\n    using BytesLib for bytes;\n    using strings for *;\n\n    string constant public CALL_REVERT_PREFIX = \"Authereum Call Revert: \";\n\n    modifier onlyAuthKey {\n        require(_isValidAuthKey(msg.sender), \"BA: Only auth key allowed\");\n        _;\n    }\n\n    modifier onlySelf {\n        require(msg.sender == address(this), \"BA: Only self allowed\");\n        _;\n    }\n\n    modifier onlyAuthKeyOrSelf {\n        require(_isValidAuthKey(msg.sender) || msg.sender == address(this), \"BA: Only auth key or self allowed\");\n        _;\n    }\n\n    // Initialize logic contract via the constructor so it does not need to be done manually\n    // after the deployment of the logic contract. Using max uint ensures that the true\n    // lastInitializedVersion is never reached.\n    constructor () public {\n        lastInitializedVersion = uint256(-1);\n    }\n\n    // This is required for funds sent to this contract\n    function () external payable {}\n\n    /**\n     *  Getters\n     */\n\n    /// @dev Get the chain ID constant\n    /// @return The chain id\n    function getChainId() public pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     *  Public functions\n     */\n\n    /// @dev Add an auth key to the list of auth keys\n    /// @param _authKey Address of the auth key to add\n    function addAuthKey(address _authKey) external onlyAuthKeyOrSelf {\n        require(authKeys[_authKey] == false, \"BA: Auth key already added\");\n        require(_authKey != address(this), \"BA: Cannot add self as an auth key\");\n        authKeys[_authKey] = true;\n        numAuthKeys += 1;\n        emit AuthKeyAdded(_authKey);\n    }\n\n    /// @dev Remove an auth key from the list of auth keys\n    /// @param _authKey Address of the auth key to remove\n    function removeAuthKey(address _authKey) external onlyAuthKeyOrSelf {\n        require(authKeys[_authKey] == true, \"BA: Auth key not yet added\");\n        require(numAuthKeys > 1, \"BA: Cannot remove last auth key\");\n        authKeys[_authKey] = false;\n        numAuthKeys -= 1;\n        emit AuthKeyRemoved(_authKey);\n    }\n\n    /**\n     *  Internal functions\n     */\n\n    /// @dev Check if an auth key is valid\n    /// @param _authKey Address of the auth key to validate\n    /// @return True if the auth key is valid\n    function _isValidAuthKey(address _authKey) internal view returns (bool) {\n        return authKeys[_authKey];\n    }\n\n    /// @dev Execute a transaction without a refund\n    /// @notice This is the transaction sent from the CBA\n    /// @param _to To address of the transaction\n    /// @param _value Value of the transaction\n    /// @param _gasLimit Gas limit of the transaction\n    /// @param _data Data of the transaction\n    /// @return Response of the call\n    function _executeTransaction(\n        address _to,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory res) = _to.call.gas(_gasLimit).value(_value)(_data);\n\n        // Get the revert message of the call and revert with it if the call failed\n        if (!success) {\n            revert(_getPrefixedRevertMsg(res));\n        }\n\n        return res;\n    }\n\n    /// @dev Get the revert message from a call\n    /// @notice This is needed in order to get the human-readable revert message from a call\n    /// @param _res Response of the call\n    /// @return Revert message string\n    function _getRevertMsgFromRes(bytes memory _res) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return 'BA: Transaction reverted silently';\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /// @dev Get the prefixed revert message from a call\n    /// @param _res Response of the call\n    /// @return Prefixed revert message string\n    function _getPrefixedRevertMsg(bytes memory _res) internal pure returns (string memory) {\n        string memory _revertMsg = _getRevertMsgFromRes(_res);\n        return string(abi.encodePacked(CALL_REVERT_PREFIX, _revertMsg));\n    }\n}\n\ncontract IERC1271 {\n    function isValidSignature(\n        bytes32 _messageHash,\n        bytes memory _signature\n    ) public view returns (bytes4 magicValue);\n\n    function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature\n    ) public view returns (bytes4 magicValue);\n}\n\n/**\n * @title ERC1271Account\n * @author Authereum Labs, Inc.\n * @dev Implements isValidSignature for ERC1271 compatibility\n */\ncontract ERC1271Account is IERC1271, BaseAccount {\n\n    // NOTE: Valid magic value bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 constant private VALID_SIG = 0x1626ba7e;\n    // NOTE: Valid magic value bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 constant private VALID_SIG_BYTES = 0x20c13b0b;\n    // NOTE: Invalid magic value\n    bytes4 constant private INVALID_SIG = 0xffffffff;\n\n    /**\n     *  Public functions\n     */\n\n    /// @dev Check if a message hash and signature pair is valid\n    /// @notice The _signature parameter can either be one auth key signature or it can\n    /// @notice be a login key signature and an auth key signature (signed login key)\n    /// @param _messageHash Hash of the data that was signed\n    /// @param _signature Signature(s) of the data. Either a single signature (login) or two (login and auth)\n    /// @return VALID_SIG or INVALID_SIG hex data\n    function isValidSignature(\n        bytes32 _messageHash,\n        bytes memory _signature\n    )\n        public\n        view\n        returns (bytes4)\n    {\n        bool isValid = _isValidSignature(_messageHash, _signature);\n        return isValid ? VALID_SIG : INVALID_SIG;\n    }\n\n    /// @dev Check if a message and signature pair is valid\n    /// @notice The _signature parameter can either be one auth key signature or it can\n    /// @notice be a login key signature and an auth key signature (signed login key)\n    /// @param _data Data that was signed\n    /// @param _signature Signature(s) of the data. Either a single signature (login) or two (login and auth)\n    /// @return VALID_SIG or INVALID_SIG hex data\n    function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature\n    )\n        public\n        view\n        returns (bytes4)\n    {\n        bytes32 messageHash = _getEthSignedMessageHash(_data);\n        bool isValid = _isValidSignature(messageHash, _signature);\n        return isValid ? VALID_SIG_BYTES : INVALID_SIG;\n    }\n\n    /// @dev Check if a message and auth key signature pair is valid\n    /// @param _messageHash Message hash that was signed\n    /// @param _signature Signature of the data signed by the authkey\n    /// @return True if the signature is valid\n    function isValidAuthKeySignature(\n        bytes32 _messageHash,\n        bytes memory _signature\n    )\n        public\n        view\n        returns (bool)\n    {\n        require(_signature.length == 65, \"ERC1271: Invalid isValidAuthKeySignature _signature length\");\n\n        address authKeyAddress = _messageHash.recover(\n            _signature\n        );\n\n        return _isValidAuthKey(authKeyAddress);\n    }\n\n    /// @dev Check if a message and login key signature pair is valid, as well as a signed login key by an auth key\n    /// @param _messageHash Message hash that was signed\n    /// @param _signature Signature of the data. Signed msg data by the login key and signed login key by auth key\n    /// @return True if the signature is valid\n    function isValidLoginKeySignature(\n        bytes32 _messageHash,\n        bytes memory _signature\n    )\n        public\n        view\n        returns (bool)\n    {\n        require(_signature.length >= 130, \"ERC1271: Invalid isValidLoginKeySignature _signature length\");\n\n        bytes memory msgHashSignature = _signature.slice(0, 65);\n        bytes memory loginKeyAttestationSignature = _signature.slice(65, 65);\n        uint256 restrictionDataLength = _signature.length.sub(130);\n        bytes memory loginKeyRestrictionsData = _signature.slice(130, restrictionDataLength);\n\n        address _loginKeyAddress = _messageHash.recover(\n            msgHashSignature\n        );\n\n        // NOTE: The OpenZeppelin toEthSignedMessageHash is used here (and not above)\n        // NOTE: because the length is hard coded at 32 and we know that this will always\n        // NOTE: be true for this line.\n        bytes32 loginKeyAttestationMessageHash = keccak256(abi.encode(\n            _loginKeyAddress, loginKeyRestrictionsData\n        )).toEthSignedMessageHash();\n\n        address _authKeyAddress = loginKeyAttestationMessageHash.recover(\n            loginKeyAttestationSignature\n        );\n\n        return _isValidAuthKey(_authKeyAddress);\n    }\n\n    /**\n     *  Internal functions\n     */\n\n    /// @dev Identify the key type and check if a message hash and signature pair is valid\n    /// @notice The _signature parameter can either be one auth key signature or it can\n    /// @notice be a login key signature and an auth key signature (signed login key)\n    /// @param _messageHash Hash of the data that was signed\n    /// @param _signature Signature(s) of the data. Either a single signature (login) or two (login and auth)\n    /// @return True if the signature is valid\n    function _isValidSignature(\n        bytes32 _messageHash,\n        bytes memory _signature\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (_signature.length == 65) {\n            return isValidAuthKeySignature(_messageHash, _signature);\n        } else if (_signature.length >= 130) {\n            return isValidLoginKeySignature(_messageHash, _signature);\n        } else {\n            revert(\"ERC1271: Invalid isValidSignature _signature length\");\n        }\n    }\n\n    /// @dev Adds ETH signed message prefix to bytes message and hashes it\n    /// @param _data Bytes data before adding the prefix\n    /// @return Prefixed and hashed message\n    function _getEthSignedMessageHash(bytes memory _data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", _uint2str(_data.length), _data));\n    }\n\n    /// @dev Convert uint to string\n    /// @param _num Uint to be converted\n    /// @return String equivalent of the uint\n    function _uint2str(uint _num) private pure returns (string memory _uintAsString) {\n        if (_num == 0) {\n            return \"0\";\n        }\n        uint i = _num;\n        uint j = _num;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0) {\n            bstr[k--] = byte(uint8(48 + i % 10));\n            i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n/**\n * @title BaseMetaTxAccount\n * @author Authereum Labs, Inc.\n * @dev Contract that lays the foundations for meta transactions\n * @dev are performed in this contract as well.\n */\ncontract BaseMetaTxAccount is BaseAccount {\n\n    /**\n     * Public functions\n     */\n\n    /// @dev Execute multiple transactions\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @return The responses of the calls\n    function executeMultipleTransactions(bytes[] memory _transactions) public onlyAuthKey returns (bytes[] memory) {\n        bool isMetaTransaction = false;\n        return _executeMultipleTransactions(_transactions, isMetaTransaction);\n    }\n\n    /// @dev Execute multiple meta transactions\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @return The responses of the calls\n    function executeMultipleMetaTransactions(bytes[] memory _transactions) public onlySelf returns (bytes[] memory) {\n        bool isMetaTransaction = true;\n        return _executeMultipleTransactions(_transactions, isMetaTransaction);\n    }\n\n    /**\n     *  Internal functions\n     */\n\n    /// @dev Atomically execute a meta transaction\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @param _gasPrice Gas price set by the user\n    /// @return A success boolean and the responses of the calls\n    function _atomicExecuteMultipleMetaTransactions(\n        bytes[] memory _transactions,\n        uint256 _gasPrice\n    )\n        internal\n        returns (bool, bytes[] memory)\n    {\n        // Verify that the relayer gasPrice is acceptable\n        require(_gasPrice <= tx.gasprice, \"BMTA: Not a large enough tx.gasprice\");\n\n        // Increment nonce by the number of transactions being processed\n        // NOTE: The nonce will still increment even if batched transactions fail atomically\n        // NOTE: The reason for this is to mimic an EOA as closely as possible\n        nonce = nonce.add(_transactions.length);\n\n        bytes memory _encodedTransactions = abi.encodeWithSelector(\n            this.executeMultipleMetaTransactions.selector,\n            _transactions\n        );\n\n        (bool success, bytes memory res) = address(this).call(_encodedTransactions);\n\n        // Check if any of the atomic transactions failed, if not, decode return data\n        bytes[] memory _returnValues;\n        if (!success) {\n            // If there is no prefix to the reversion reason, we know it was an OOG error\n            if (res.length == 0) {\n                revert(\"BMTA: Atomic call ran out of gas\");\n            }\n\n            string memory _revertMsg = _getRevertMsgFromRes(res);\n            emit CallFailed(_revertMsg);\n        } else {\n            _returnValues = abi.decode(res, (bytes[]));\n        }\n\n        return (success, _returnValues);\n    }\n\n    /// @dev Executes multiple transactions\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @param _isMetaTransaction True if the transaction is a meta transaction\n    /// @return The responses of the calls\n    function _executeMultipleTransactions(bytes[] memory _transactions, bool _isMetaTransaction) internal returns (bytes[] memory) {\n        // Execute transactions individually\n        bytes[] memory _returnValues = new bytes[](_transactions.length);\n        for(uint i = 0; i < _transactions.length; i++) {\n            // Execute the transaction\n            _returnValues[i] = _decodeAndExecuteTransaction(_transactions[i], _isMetaTransaction);\n        }\n\n        return _returnValues;\n    }\n\n    /// @dev Decode and execute a meta transaction\n    /// @param _transaction Transaction (to, value, gasLimit, data)\n    /// @param _isMetaTransaction True if the transaction is a meta transaction\n    /// @return Success status and response of the call\n    function _decodeAndExecuteTransaction(bytes memory _transaction, bool _isMetaTransaction) internal returns (bytes memory) {\n        (address _to, uint256 _value, uint256 _gasLimit, bytes memory _data) = _decodeTransactionData(_transaction);\n\n        if (_isMetaTransaction) {\n            // Require that there will be enough gas to complete the atomic transaction\n            // We use 64/63 of the to account for EIP-150 and validate that there will be enough remaining gas\n            // We use 34700 as the max possible cost for a call\n            // We add 100 as a buffer for additional logic costs\n            // NOTE: An out of gas failure after the completion of the call is the concern of the relayer\n            // NOTE: This check CANNOT have a revert reason, as the parent caller relies on a non-prefixed message for this reversion\n            require(gasleft() > _gasLimit.mul(64).div(63).add(34800));\n        }\n\n        // Execute the transaction\n        return _executeTransaction(_to, _value, _gasLimit, _data);\n    }\n\n    /// @dev Decode transaction data\n    /// @param _transaction Transaction (to, value, gasLimit, data)\n    /// @return Decoded transaction\n    function _decodeTransactionData(bytes memory _transaction) internal pure returns (address, uint256, uint256, bytes memory) {\n        return abi.decode(_transaction, (address, uint256, uint256, bytes));\n    }\n\n    /// @dev Issue a refund\n    /// @param _startGas Starting gas at the beginning of the transaction\n    /// @param _gasPrice Gas price to use when sending a refund\n    /// @param _gasOverhead Gas overhead of the transaction calculated offchain\n    /// @param _feeTokenAddress Address of the token used to pay a fee\n    /// @param _feeTokenRate Rate of the token (in tokenGasPrice/ethGasPrice) used to pay a fee\n    function _issueRefund(\n        uint256 _startGas,\n        uint256 _gasPrice,\n        uint256 _gasOverhead,\n        address _feeTokenAddress,\n        uint256 _feeTokenRate\n    )\n        internal\n    {\n        uint256 _gasUsed = _startGas.sub(gasleft()).add(_gasOverhead);\n\n        // Pay refund in ETH if _feeTokenAddress is 0. Else, pay in the token\n        if (_feeTokenAddress == address(0)) {\n            uint256 totalEthFee = _gasUsed.mul(_gasPrice);\n\n            // Don't refund if there is nothing to refund\n            if (totalEthFee == 0) return;\n            require(totalEthFee <= address(this).balance, \"BA: Insufficient gas (ETH) for refund\");\n\n            // NOTE: The return value is not checked because the relayer should not propagate a transaction that will revert\n            // NOTE: and malicious behavior by the relayer here will cost the relayer, as the fee is already calculated\n            msg.sender.call.value(totalEthFee)(\"\");\n        } else {\n            IERC20 feeToken = IERC20(_feeTokenAddress);\n            uint256 totalTokenFee = _gasUsed.mul(_feeTokenRate);\n\n            // Don't refund if there is nothing to refund\n            if (totalTokenFee == 0) return;\n            require(totalTokenFee <= feeToken.balanceOf(address(this)), \"BA: Insufficient gas (token) for refund\");\n\n            // NOTE: The return value is not checked because the relayer should not propagate a transaction that will revert\n            feeToken.transfer(msg.sender, totalTokenFee);\n        }\n    }\n}\n\ninterface ILoginKeyTransactionValidator {\n    /// @dev Reverts if the transaction is invalid\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @param _validationData Data used by the LoginKeyTransactionValidator and is signed in the \n    ///        login key attestation\n    /// @param _relayerAddress Address that called the account contract\n    function validateTransactions(\n        bytes[] calldata _transactions,\n        bytes calldata _validationData,\n        address _relayerAddress\n    ) external;\n\n    /// @dev Called after a transaction is executed to record information about the transaction\n    ///      and perform any post-execution validation\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @param _validationData Data used by the LoginKeyTransactionValidator and is signed in the \n    ///        login key attestation\n    /// @param _relayerAddress Address that called the account contract\n    function transactionsDidExecute(\n        bytes[] calldata _transactions,\n        bytes calldata _validationData,\n        address _relayerAddress\n    ) external;\n}\n\n/**\n * @title LoginKeyMetaTxAccount\n * @author Authereum Labs, Inc.\n * @dev Contract used by login keys to send transactions. Login key firewall checks\n * @dev are performed in this contract as well.\n */\ncontract LoginKeyMetaTxAccount is BaseMetaTxAccount {\n\n    /// @dev Execute an loginKey meta transaction\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @param _gasPrice Gas price set by the user\n    /// @param _gasOverhead Gas overhead of the transaction calculated offchain\n    /// @param _loginKeyRestrictionsData Contains restrictions to the loginKey's functionality\n    /// @param _feeTokenAddress Address of the token used to pay a fee\n    /// @param _feeTokenRate Rate of the token (in tokenGasPrice/ethGasPrice) used to pay a fee\n    /// @param _transactionMessageHashSignature Signed transaction data\n    /// @param _loginKeyAttestationSignature Signed loginKey\n    /// @return Return values of the call\n    function executeMultipleLoginKeyMetaTransactions(\n        bytes[] memory _transactions,\n        uint256 _gasPrice,\n        uint256 _gasOverhead,\n        bytes memory _loginKeyRestrictionsData,\n        address _feeTokenAddress,\n        uint256 _feeTokenRate,\n        bytes memory _transactionMessageHashSignature,\n        bytes memory _loginKeyAttestationSignature\n    )\n        public\n        returns (bytes[] memory)\n    {\n        uint256 startGas = gasleft();\n\n        _validateDestinations(_transactions);\n        _validateRestrictionDataPreHook(_transactions, _loginKeyRestrictionsData);\n\n        // Hash the parameters\n        bytes32 _transactionMessageHash = keccak256(abi.encode(\n            address(this),\n            msg.sig,\n            getChainId(),\n            nonce,\n            _transactions,\n            _gasPrice,\n            _gasOverhead,\n            _feeTokenAddress,\n            _feeTokenRate\n        )).toEthSignedMessageHash();\n\n        // Validate the signers\n        // NOTE: This must be done prior to the _atomicExecuteMultipleMetaTransactions() call for security purposes\n        _validateLoginKeyMetaTransactionSigs(\n            _transactionMessageHash, _transactionMessageHashSignature, _loginKeyRestrictionsData, _loginKeyAttestationSignature\n        );\n\n        (bool success, bytes[] memory _returnValues) = _atomicExecuteMultipleMetaTransactions(\n            _transactions,\n            _gasPrice\n        );\n\n        // If transaction batch succeeded\n        if (success) {\n            _validateRestrictionDataPostHook(_transactions, _loginKeyRestrictionsData);\n        }\n\n        // Refund gas costs\n        _issueRefund(startGas, _gasPrice, _gasOverhead, _feeTokenAddress, _feeTokenRate);\n\n        return _returnValues;\n    }\n\n    /**\n     *  Internal functions\n     */\n\n    /// @dev Decodes the loginKeyRestrictionsData and calls the ILoginKeyTransactionValidator contract's pre-execution hook\n    /// @param _transactions The encoded transactions being executed\n    /// @param _loginKeyRestrictionsData The encoded data used by the ILoginKeyTransactionValidator contract\n    function _validateRestrictionDataPreHook(\n        bytes[] memory _transactions,\n        bytes memory _loginKeyRestrictionsData\n    )\n        internal\n    {\n        (address validationContract, bytes memory validationData) = abi.decode(_loginKeyRestrictionsData, (address, bytes));\n        if (validationContract != address(0)) {\n            ILoginKeyTransactionValidator(validationContract).validateTransactions(_transactions, validationData, msg.sender);\n        }\n    }\n\n    /// @dev Decodes the loginKeyRestrictionsData and calls the ILoginKeyTransactionValidator contract's post-execution hook\n    /// @param _transactions The encoded transactions being executed\n    /// @param _loginKeyRestrictionsData The encoded data used by the ILoginKeyTransactionValidator contract\n    function _validateRestrictionDataPostHook(\n        bytes[] memory _transactions,\n        bytes memory _loginKeyRestrictionsData\n    )\n        internal\n    {\n        (address validationContract, bytes memory validationData) = abi.decode(_loginKeyRestrictionsData, (address, bytes));\n        if (validationContract != address(0)) {\n            ILoginKeyTransactionValidator(validationContract).transactionsDidExecute(_transactions, validationData, msg.sender);\n        }\n    }\n\n    /// @dev Validates all loginKey Restrictions\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    function _validateDestinations(\n        bytes[] memory _transactions\n    )\n        internal\n        view\n    {\n        // Check that calls made to self and auth keys have no data and are limited in gas\n        address to;\n        uint256 gasLimit;\n        bytes memory data;\n        for (uint i = 0; i < _transactions.length; i++) {\n            (to,,gasLimit,data) = _decodeTransactionData(_transactions[i]);\n\n            if (data.length != 0 || gasLimit > 2300) {\n                require(to != address(this), \"LKMTA: Login key is not able to call self\");\n                require(!authKeys[to], \"LKMTA: Login key is not able to call an Auth key\");\n            }\n        }\n    }\n\n    /// @dev Validate signatures from an auth key meta transaction\n    /// @param _transactionsMessageHash Ethereum signed message of the transaction\n    /// @param _transactionMessageHashSignature Signed transaction data\n    /// @param _loginKeyRestrictionsData Contains restrictions to the loginKey's functionality\n    /// @param _loginKeyAttestationSignature Signed loginKey\n    /// @return Address of the login key that signed the data\n    function _validateLoginKeyMetaTransactionSigs(\n        bytes32 _transactionsMessageHash,\n        bytes memory _transactionMessageHashSignature,\n        bytes memory _loginKeyRestrictionsData,\n        bytes memory _loginKeyAttestationSignature\n    )\n        internal\n        view\n    {\n        address _transactionMessageSigner = _transactionsMessageHash.recover(\n            _transactionMessageHashSignature\n        );\n\n        bytes32 loginKeyAttestationMessageHash = keccak256(abi.encode(\n            _transactionMessageSigner,\n            _loginKeyRestrictionsData\n        )).toEthSignedMessageHash();\n\n        address _authKeyAddress = loginKeyAttestationMessageHash.recover(\n            _loginKeyAttestationSignature\n        );\n\n        require(_isValidAuthKey(_authKeyAddress), \"LKMTA: Auth key is invalid\");\n    }\n}\n\n/**\n * @title AuthKeyMetaTxAccount\n * @author Authereum Labs, Inc.\n * @dev Contract used by auth keys to send transactions.\n */\ncontract AuthKeyMetaTxAccount is BaseMetaTxAccount {\n\n    /// @dev Execute multiple authKey meta transactions\n    /// @param _transactions Arrays of transaction data ([to, value, gasLimit, data],[...],...)\n    /// @param _gasPrice Gas price set by the user\n    /// @param _gasOverhead Gas overhead of the transaction calculated offchain\n    /// @param _feeTokenAddress Address of the token used to pay a fee\n    /// @param _feeTokenRate Rate of the token (in tokenGasPrice/ethGasPrice) used to pay a fee\n    /// @param _transactionMessageHashSignature Signed transaction data\n    /// @return Return values of the call\n    function executeMultipleAuthKeyMetaTransactions(\n        bytes[] memory _transactions,\n        uint256 _gasPrice,\n        uint256 _gasOverhead,\n        address _feeTokenAddress,\n        uint256 _feeTokenRate,\n        bytes memory _transactionMessageHashSignature\n    )\n        public\n        returns (bytes[] memory)\n    {\n        uint256 _startGas = gasleft();\n\n        // Hash the parameters\n        bytes32 _transactionMessageHash = keccak256(abi.encode(\n            address(this),\n            msg.sig,\n            getChainId(),\n            nonce,\n            _transactions,\n            _gasPrice,\n            _gasOverhead,\n            _feeTokenAddress,\n            _feeTokenRate\n        )).toEthSignedMessageHash();\n\n        // Validate the signer\n        // NOTE: This must be done prior to the _atomicExecuteMultipleMetaTransactions() call for security purposes\n        _validateAuthKeyMetaTransactionSigs(\n            _transactionMessageHash, _transactionMessageHashSignature\n        );\n\n        (, bytes[] memory _returnValues) = _atomicExecuteMultipleMetaTransactions(\n            _transactions,\n            _gasPrice\n        );\n\n        _issueRefund(_startGas, _gasPrice, _gasOverhead, _feeTokenAddress, _feeTokenRate);\n\n        return _returnValues;\n    }\n\n    /**\n     *  Internal functions\n     */\n\n    /// @dev Validate signatures from an auth key meta transaction\n    /// @param _transactionMessageHash Ethereum signed message of the transaction\n    /// @param _transactionMessageHashSignature Signed transaction data\n    /// @return Address of the auth key that signed the data\n    function _validateAuthKeyMetaTransactionSigs(\n        bytes32 _transactionMessageHash,\n        bytes memory _transactionMessageHashSignature\n    )\n        internal\n        view\n    {\n        address _authKey = _transactionMessageHash.recover(_transactionMessageHashSignature);\n        require(_isValidAuthKey(_authKey), \"AKMTA: Auth key is invalid\");\n    }\n}\n\n/**\n * Utility library of inline functions on addresses\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n */\nlibrary OpenZeppelinUpgradesAddress {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n/**\n * @title AccountUpgradeability\n * @author Authereum Labs, Inc.\n * @dev The upgradeability logic for an Authereum account.\n */\ncontract AccountUpgradeability is BaseAccount {\n    /// @dev Storage slot with the address of the current implementation\n    /// @notice This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted \n    /// @notice by 1, and is validated in the constructor\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     *  Public functions\n     */\n\n    /// @dev Returns the current implementation\n    /// @notice This is meant to be called through the proxy to retrieve it's implementation address\n    /// @return Address of the current implementation\n    function implementation() public view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /// @dev Upgrades the proxy to the newest implementation of a contract and \n    /// @dev forwards a function call to it\n    /// @notice This is useful to initialize the proxied contract\n    /// @param _newImplementation Address of the new implementation\n    /// @param _data Array of initialize data\n    function upgradeToAndCall(\n        address _newImplementation, \n        bytes memory _data\n    ) \n        public \n        onlySelf\n    {\n        _setImplementation(_newImplementation);\n        (bool success, bytes memory res) = _newImplementation.delegatecall(_data);\n\n        // Get the revert message of the call and revert with it if the call failed\n        string memory _revertMsg = _getRevertMsgFromRes(res);\n        require(success, _revertMsg);\n        emit Upgraded(_newImplementation);\n    }\n\n    /**\n     *  Internal functions\n     */\n\n    /// @dev Sets the implementation address of the proxy\n    /// @notice This is only meant to be called when upgrading self\n    /// @notice The initial setImplementation for a proxy is set during\n    /// @notice the proxy's initialization, not with this call\n    /// @param _newImplementation Address of the new implementation\n    function _setImplementation(address _newImplementation) internal {\n        require(OpenZeppelinUpgradesAddress.isContract(_newImplementation), \"AU: Cannot set a proxy implementation to a non-contract address\");\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        assembly {\n            sstore(slot, _newImplementation)\n        }\n    }\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n *\n * This contract is from openzeppelin-solidity 2.4.0\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4);\n}\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n*/\ninterface IERC1155TokenReceiver {\n    /**\n        @notice Handle the receipt of a single ERC1155 token type.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\n        This function MUST revert if it rejects the transfer.\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _id        The ID of the token being transferred\n        @param _value     The amount of tokens being transferred\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    */\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\n\n    /**\n        @notice Handle the receipt of multiple ERC1155 token types.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\n        This function MUST revert if it rejects the transfer(s).\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\n        @param _from      The address which previously owned the token\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    */\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n}\n\ninterface IERC1820ImplementerInterface {\n    /// @notice Indicates whether the contract implements the interface `interfaceHash` for the address `addr` or not.\n    /// @param interfaceHash keccak256 hash of the name of the interface\n    /// @param addr Address for which the contract will implement the interface\n    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements `interfaceHash` for the address `addr`.\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);\n}\n\ncontract IERC777TokensRecipient {\n    /// @dev Notify a send or mint (if from is 0x0) of amount tokens from the from address to the\n    ///      to address by the operator address.\n    /// @param operator Address which triggered the balance increase (through sending or minting).\n    /// @param from Holder whose tokens were sent (or 0x0 for a mint).\n    /// @param to Recipient of the tokens.\n    /// @param amount Number of tokens the recipient balance is increased by.\n    /// @param data Information provided by the holder.\n    /// @param operatorData Information provided by the operator.\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n}\n\ncontract IAuthereumAccount is IERC1271, IERC721Receiver, IERC1155TokenReceiver, IERC1820ImplementerInterface, IERC777TokensRecipient {\n    function () external payable;\n    function name() external view returns (string memory);\n    function version() external view returns (string memory);\n    function implementation() external view returns (address);\n    function lastInitializedVersion() external returns (uint256);\n    function authKeys(address _authKey) external returns (bool);\n    function nonce() external returns (uint256);\n    function numAuthKeys() external returns (uint256);\n    function getChainId() external pure returns (uint256);\n    function addAuthKey(address _authKey) external;\n    function upgradeToAndCall(address _newImplementation, bytes calldata _data) external;\n    function removeAuthKey(address _authKey) external;\n    function isValidAuthKeySignature(bytes32 _messageHash, bytes calldata _signature) external view returns (bool);\n    function isValidLoginKeySignature(bytes32 _messageHash, bytes calldata _signature) external view returns (bool);\n    function executeMultipleTransactions(bytes[] calldata _transactions) external returns (bytes[] memory);\n    function executeMultipleMetaTransactions(bytes[] calldata _transactions) external returns (bytes[] memory);\n\n    function executeMultipleAuthKeyMetaTransactions(\n        bytes[] calldata _transactions,\n        uint256 _gasPrice,\n        uint256 _gasOverhead,\n        address _feeTokenAddress,\n        uint256 _feeTokenRate,\n        bytes calldata _transactionMessageHashSignature\n    ) external returns (bytes[] memory);\n\n    function executeMultipleLoginKeyMetaTransactions(\n        bytes[] calldata _transactions,\n        uint256 _gasPrice,\n        uint256 _gasOverhead,\n        bytes calldata _loginKeyRestrictionsData,\n        address _feeTokenAddress,\n        uint256 _feeTokenRate,\n        bytes calldata _transactionMessageHashSignature,\n        bytes calldata _loginKeyAttestationSignature\n    ) external returns (bytes[] memory);\n}\n\n/**\n * @title AuthereumAccount\n * @author Authereum Labs, Inc.\n * @dev Top-level contract used when creating an Authereum account.\n * @dev This contract is meant to only hold the version. All other logic is inherited.\n */\ncontract AuthereumAccount is\n    IAuthereumAccount,\n    BaseAccount,\n    ERC1271Account,\n    LoginKeyMetaTxAccount,\n    AuthKeyMetaTxAccount,\n    AccountUpgradeability\n{\n    string constant public name = \"Authereum Account\";\n    string constant public version = \"2020070100\";\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authKey\",\"type\":\"address\"}],\"name\":\"AuthKeyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authKey\",\"type\":\"address\"}],\"name\":\"AuthKeyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"CallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"CALL_REVERT_PREFIX\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"_isValidSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authKey\",\"type\":\"address\"}],\"name\":\"addAuthKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authKeys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_transactions\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasOverhead\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeTokenRate\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_transactionMessageHashSignature\",\"type\":\"bytes\"}],\"name\":\"executeMultipleAuthKeyMetaTransactions\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_transactions\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasOverhead\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_loginKeyRestrictionsData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_feeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeTokenRate\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_transactionMessageHashSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_loginKeyAttestationSignature\",\"type\":\"bytes\"}],\"name\":\"executeMultipleLoginKeyMetaTransactions\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_transactions\",\"type\":\"bytes[]\"}],\"name\":\"executeMultipleMetaTransactions\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_transactions\",\"type\":\"bytes[]\"}],\"name\":\"executeMultipleTransactions\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authKey\",\"type\":\"address\"}],\"name\":\"initializeV1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deploymentCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_deploymentFeeTokenAddress\",\"type\":\"address\"}],\"name\":\"initializeV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializeV3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidAuthKeySignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidLoginKeySignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastInitializedVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAuthKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authKey\",\"type\":\"address\"}],\"name\":\"removeAuthKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AuthereumAccount","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}