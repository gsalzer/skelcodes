{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2018 Murray Software, LLC.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\ncontract CloneFactory {\r\n\r\n    function createClone(address target) internal returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Copyright 2020 Compound Labs, Inc.\r\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ncontract FuelToken {\r\n    /// @notice EIP-20 token name for this token\r\n    string public constant name = \"PowerTrade Fuel Token\";\r\n\r\n    /// @notice EIP-20 token symbol for this token\r\n    string public constant symbol = \"PTF\";\r\n\r\n    /// @notice EIP-20 token decimals for this token\r\n    uint8 public constant decimals = 18;\r\n\r\n    /// @notice Total number of tokens in circulation\r\n    uint public totalSupply;\r\n\r\n    /// @notice Minter address\r\n    address public minter;\r\n\r\n    /// @notice Allowance amounts on behalf of others\r\n    mapping (address => mapping (address => uint96)) internal allowances;\r\n\r\n    /// @notice Official record of token balances for each account\r\n    mapping (address => uint96) internal balances;\r\n\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) public delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /// @notice The standard EIP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @notice The standard EIP-20 approval event\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /// @notice An event thats emitted when the minter is changed\r\n    event NewMinter(address minter);\r\n\r\n    modifier onlyMinter {\r\n        require(msg.sender == minter, \"FuelToken:onlyMinter: should only be called by minter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Construct a new Fuel token\r\n     * @param initialSupply The initial supply minted at deployment\r\n     * @param account The initial account to grant all the tokens\r\n     */\r\n    constructor(uint initialSupply, address account, address _minter) public {\r\n        totalSupply = safe96(initialSupply, \"FuelToken::constructor:amount exceeds 96 bits\");\r\n        balances[account] = uint96(initialSupply);\r\n        minter = _minter;\r\n        emit Transfer(address(0), account, initialSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\r\n     * @param account The address of the account holding the funds\r\n     * @param spender The address of the account spending the funds\r\n     * @return The number of tokens approved\r\n     */\r\n    function allowance(address account, address spender) external view returns (uint) {\r\n        return allowances[account][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint rawAmount) external returns (bool) {\r\n        uint96 amount;\r\n        if (rawAmount == uint(-1)) {\r\n            amount = uint96(-1);\r\n        } else {\r\n            amount = safe96(rawAmount, \"FuelToken::approve: amount exceeds 96 bits\");\r\n        }\r\n\r\n        allowances[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens held by the `account`\r\n     * @param account The address of the account to get the balance of\r\n     * @return The number of tokens held\r\n     */\r\n    function balanceOf(address account) external view returns (uint) {\r\n        return balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Mint `amount` tokens to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to mint\r\n     * @notice only callable by minter\r\n     */\r\n    function mint(address dst, uint rawAmount) external onlyMinter {\r\n        uint96 amount = safe96(rawAmount, \"FuelToken::mint: amount exceeds 96 bits\");\r\n        _mintTokens(dst, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn `amount` tokens\r\n     * @param rawAmount The number of tokens to burn\r\n     */\r\n    function burn(uint rawAmount) external {\r\n        uint96 amount = safe96(rawAmount, \"FuelToken::burn: amount exceeds 96 bits\");\r\n        _burnTokens(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Change minter address to `account`\r\n     * @param account The address of the new minter\r\n     * @notice only callable by minter\r\n     */\r\n    function changeMinter(address account) external onlyMinter {\r\n        minter = account;\r\n        emit NewMinter(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint rawAmount) external returns (bool) {\r\n        uint96 amount = safe96(rawAmount, \"FuelToken::transfer: amount exceeds 96 bits\");\r\n        _transferTokens(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\r\n        address spender = msg.sender;\r\n        uint96 spenderAllowance = allowances[src][spender];\r\n        uint96 amount = safe96(rawAmount, \"FuelToken::approve: amount exceeds 96 bits\");\r\n\r\n        if (spender != src && spenderAllowance != uint96(-1)) {\r\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"FuelToken::transferFrom: transfer amount exceeds spender allowance\");\r\n            allowances[src][spender] = newAllowance;\r\n\r\n            emit Approval(src, spender, newAllowance);\r\n        }\r\n\r\n        _transferTokens(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"FuelToken::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"FuelToken::delegateBySig: invalid nonce\");\r\n        require(now <= expiry, \"FuelToken::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint96) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\r\n        require(blockNumber < block.number, \"FuelToken::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        uint96 delegatorBalance = balances[delegator];\r\n        delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _transferTokens(address src, address dst, uint96 amount) internal {\r\n        require(src != address(0), \"FuelToken::_transferTokens: cannot transfer from the zero address\");\r\n        require(dst != address(0), \"FuelToken::_transferTokens: cannot transfer to the zero address\");\r\n\r\n        balances[src] = sub96(balances[src], amount, \"FuelToken::_transferTokens: transfer amount exceeds balance\");\r\n        balances[dst] = add96(balances[dst], amount, \"FuelToken::_transferTokens: transfer amount overflows\");\r\n        emit Transfer(src, dst, amount);\r\n\r\n        _moveDelegates(delegates[src], delegates[dst], amount);\r\n    }\r\n\r\n    function _mintTokens(address dst, uint96 amount) internal {\r\n        require(dst != address(0), \"FuelToken::_mintTokens: cannot transfer to the zero address\");\r\n        uint96 supply = safe96(totalSupply, \"FuelToken::_mintTokens: totalSupply exceeds 96 bits\");\r\n        totalSupply = add96(supply, amount, \"FuelToken::_mintTokens: totalSupply exceeds 96 bits\");\r\n        balances[dst] = add96(balances[dst], amount, \"FuelToken::_mintTokens: transfer amount overflows\");\r\n        emit Transfer(address(0), dst, amount);\r\n\r\n        _moveDelegates(address(0), delegates[dst], amount);\r\n    }\r\n\r\n    function _burnTokens(address src, uint96 amount) internal {\r\n        uint96 supply = safe96(totalSupply, \"FuelToken::_burnTokens: totalSupply exceeds 96 bits\");\r\n        totalSupply = sub96(supply, amount, \"FuelToken::_burnTokens:totalSupply underflow\");\r\n        balances[src] = sub96(balances[src], amount, \"FuelToken::_burnTokens: amount overflows\");\r\n        emit Transfer(src, address(0), amount);\r\n\r\n        _moveDelegates(delegates[src], address(0), amount);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"FuelToken::_moveVotes: vote amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint96 dstRepNew = add96(dstRepOld, amount, \"FuelToken::_moveVotes: vote amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\r\n      uint32 blockNumber = safe32(block.number, \"FuelToken::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n      } else {\r\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n          numCheckpoints[delegatee] = nCheckpoints + 1;\r\n      }\r\n\r\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n\r\n/// @author BlockRocket\r\ncontract VestingDepositAccount {\r\n\r\n    /// @notice the controlling parent vesting contract\r\n    address public controller;\r\n\r\n    /// @notice beneficiary who tokens will be transferred to\r\n    address public beneficiary;\r\n\r\n    /// @notice ERC20 token that is vested (extended with a delegate function)\r\n    FuelToken public token;\r\n\r\n    /**\r\n     * @notice Using a minimal proxy contract pattern initialises the contract and sets delegation\r\n     * @dev initialises the VestingDepositAccount (see https://eips.ethereum.org/EIPS/eip-1167)\r\n     * @dev only controller\r\n     */\r\n    function init(address _tokenAddress, address _controller, address _beneficiary) external {\r\n        require(controller == address(0), \"VestingDepositAccount::init: Contract already initialized\");\r\n        token = FuelToken(_tokenAddress);\r\n        controller = _controller;\r\n        beneficiary = _beneficiary;\r\n\r\n        // sets the beneficiary as the delegate on the token\r\n        token.delegate(beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens vested in the VestingDepositAccount to the beneficiary\r\n     * @param _amount amount of tokens (in wei)\r\n     * @dev only controller\r\n     */\r\n    function transferToBeneficiary(uint256 _amount) external returns (bool) {\r\n        require(msg.sender == controller, \"VestingDepositAccount::transferToBeneficiary: Only controller\");\r\n        return token.transfer(beneficiary, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the beneficiary to be switched on the VestingDepositAccount and sets delegation\r\n     * @param _newBeneficiary address to receive tokens once switched\r\n     * @dev only controller\r\n     */\r\n    function switchBeneficiary(address _newBeneficiary) external {\r\n        require(msg.sender == controller, \"VestingDepositAccount::switchBeneficiary: Only controller\");\r\n        beneficiary = _newBeneficiary;\r\n\r\n        // sets the new beneficiary as the delegate on the token\r\n        token.delegate(_newBeneficiary);\r\n    }\r\n}\r\n\r\n/// @author BlockRocket\r\ncontract VestingContract is CloneFactory, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice event emitted when a vesting schedule is created\r\n    event ScheduleCreated(address indexed _beneficiary, uint256 indexed _amount);\r\n\r\n    /// @notice event emitted when a successful drawn down of vesting tokens is made\r\n    event DrawDown(address indexed _beneficiary, uint256 indexed _amount, uint256 indexed _time);\r\n\r\n    /// @notice struct to define the total amount vested (this never changes) and the associated deposit account\r\n    struct Schedule {\r\n        uint256 amount;\r\n        VestingDepositAccount depositAccount;\r\n    }\r\n\r\n    /// @notice owner address set on construction\r\n    address public owner;\r\n\r\n    /// @notice beneficiary to schedule mapping. Note beneficiary address can not be reused\r\n    mapping(address => Schedule) public vestingSchedule;\r\n\r\n    /// @notice cumulative total of tokens drawn down (and transferred from the deposit account) per beneficiary\r\n    mapping(address => uint256) public totalDrawn;\r\n\r\n    /// @notice last drawn down time (seconds) per beneficiary\r\n    mapping(address => uint256) public lastDrawnAt;\r\n\r\n    /// @notice set when updating beneficiary (via owner) to indicate a voided/completed schedule\r\n    mapping(address => bool) public voided;\r\n\r\n    /// @notice ERC20 token we are vesting\r\n    IERC20 public token;\r\n\r\n    /// @notice the blueprint deposit account to clone using CloneFactory (https://eips.ethereum.org/EIPS/eip-1167)\r\n    address public baseVestingDepositAccount;\r\n\r\n    /// @notice start of vesting period as a timestamp\r\n    uint256 public start;\r\n\r\n    /// @notice end of vesting period as a timestamp\r\n    uint256 public end;\r\n\r\n    /// @notice cliff duration in seconds\r\n    uint256 public cliffDuration;\r\n\r\n    /**\r\n     * @notice Construct a new vesting contract\r\n     * @param _token ERC20 token\r\n     * @param _baseVestingDepositAccount address of the VestingDepositAccount to clone\r\n     * @param _start start timestamp\r\n     * @param _end end timestamp\r\n     * @param _cliffDurationInSecs cliff duration in seconds\r\n     * @dev caller on constructor set as owner; this can not be changed\r\n     */\r\n    constructor(\r\n        IERC20 _token,\r\n        address _baseVestingDepositAccount,\r\n        uint256 _start,\r\n        uint256 _end,\r\n        uint256 _cliffDurationInSecs\r\n    ) public {\r\n        require(address(_token) != address(0), \"VestingContract::constructor: Invalid token\");\r\n        require(_end >= _start, \"VestingContract::constructor: Start must be before end\");\r\n\r\n        token = _token;\r\n        owner = msg.sender;\r\n        baseVestingDepositAccount = _baseVestingDepositAccount;\r\n\r\n        start = _start;\r\n        end = _end;\r\n        cliffDuration = _cliffDurationInSecs;\r\n    }\r\n\r\n    /**\r\n     * @notice Create a new vesting schedule\r\n     * @notice A transfer is used to bring tokens into the VestingDepositAccount so pre-approval is required\r\n     * @notice Delegation is set for the beneficiary on the token during schedule creation\r\n     * @param _beneficiary beneficiary of the vested tokens\r\n     * @param _amount amount of tokens (in wei)\r\n     */\r\n    function createVestingSchedule(address _beneficiary, uint256 _amount) external returns (bool) {\r\n        require(msg.sender == owner, \"VestingContract::createVestingSchedule: Only Owner\");\r\n        require(_beneficiary != address(0), \"VestingContract::createVestingSchedule: Beneficiary cannot be empty\");\r\n        require(_amount > 0, \"VestingContract::createVestingSchedule: Amount cannot be empty\");\r\n\r\n        // Ensure only one per address\r\n        require(\r\n            vestingSchedule[_beneficiary].amount == 0,\r\n            \"VestingContract::createVestingSchedule: Schedule already in flight\"\r\n        );\r\n\r\n        // Set up the vesting deposit account for the _beneficiary\r\n        address depositAccountAddress = createClone(baseVestingDepositAccount);\r\n        VestingDepositAccount depositAccount = VestingDepositAccount(depositAccountAddress);\r\n        depositAccount.init(address(token), address(this), _beneficiary);\r\n\r\n        // Create schedule\r\n        vestingSchedule[_beneficiary] = Schedule({\r\n            amount : _amount,\r\n            depositAccount : depositAccount\r\n            });\r\n\r\n        // Vest the tokens into the deposit account and delegate to the beneficiary\r\n        require(\r\n            token.transferFrom(msg.sender, address(depositAccount), _amount),\r\n            \"VestingContract::createVestingSchedule: Unable to transfer tokens to VDA\"\r\n        );\r\n\r\n        emit ScheduleCreated(_beneficiary, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Draws down any vested tokens due\r\n     * @dev Must be called directly by the beneficiary assigned the tokens in the schedule\r\n     */\r\n    function drawDown() nonReentrant external returns (bool) {\r\n        return _drawDown(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates a schedule beneficiary\r\n     * @notice Voids the old schedule and transfers remaining amount to new beneficiary via a new schedule\r\n     * @dev Only owner\r\n     * @param _currentBeneficiary beneficiary to be replaced\r\n     * @param _newBeneficiary beneficiary to vest remaining tokens to\r\n     */\r\n    function updateScheduleBeneficiary(address _currentBeneficiary, address _newBeneficiary) external {\r\n        require(msg.sender == owner, \"VestingContract::updateScheduleBeneficiary: Only owner\");\r\n\r\n        // retrieve existing schedule\r\n        Schedule memory schedule = vestingSchedule[_currentBeneficiary];\r\n        require(\r\n            schedule.amount > 0,\r\n            \"VestingContract::updateScheduleBeneficiary: There is no schedule currently in flight\"\r\n        );\r\n        require(_drawDown(_currentBeneficiary), \"VestingContract::_updateScheduleBeneficiary: Unable to drawn down\");\r\n\r\n        // the old schedule is now void\r\n        voided[_currentBeneficiary] = true;\r\n\r\n        // setup new schedule with the amount left after the previous beneficiary's draw down\r\n        vestingSchedule[_newBeneficiary] = Schedule({\r\n            amount : schedule.amount.sub(totalDrawn[_currentBeneficiary]),\r\n            depositAccount : schedule.depositAccount\r\n            });\r\n\r\n        vestingSchedule[_newBeneficiary].depositAccount.switchBeneficiary(_newBeneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership role\r\n     * @notice Changes the owner of this contract to a new address\r\n     * @dev Only owner\r\n     * @param _newOwner beneficiary to vest remaining tokens to\r\n     */\r\n    function transferOwnership(address _newOwner) external {\r\n        require(msg.sender == owner, \"VestingContract::transferOwnership: Only owner\");\r\n        owner = _newOwner;\r\n    }\r\n\r\n    // Accessors\r\n\r\n    /**\r\n     * @notice Vested token balance for a beneficiary\r\n     * @dev Must be called directly by the beneficiary assigned the tokens in the schedule\r\n     * @return _tokenBalance total balance proxied via the ERC20 token\r\n     */\r\n    function tokenBalance() external view returns (uint256 _tokenBalance) {\r\n        return token.balanceOf(address(vestingSchedule[msg.sender].depositAccount));\r\n    }\r\n\r\n    /**\r\n     * @notice Vesting schedule and associated data for a beneficiary\r\n     * @dev Must be called directly by the beneficiary assigned the tokens in the schedule\r\n     * @return _amount\r\n     * @return _totalDrawn\r\n     * @return _lastDrawnAt\r\n     * @return _drawDownRate\r\n     * @return _remainingBalance\r\n     * @return _depositAccountAddress\r\n     */\r\n    function vestingScheduleForBeneficiary(address _beneficiary)\r\n    external view\r\n    returns (\r\n        uint256 _amount,\r\n        uint256 _totalDrawn,\r\n        uint256 _lastDrawnAt,\r\n        uint256 _drawDownRate,\r\n        uint256 _remainingBalance,\r\n        address _depositAccountAddress\r\n    ) {\r\n        Schedule memory schedule = vestingSchedule[_beneficiary];\r\n        return (\r\n        schedule.amount,\r\n        totalDrawn[_beneficiary],\r\n        lastDrawnAt[_beneficiary],\r\n        schedule.amount.div(end.sub(start)),\r\n        schedule.amount.sub(totalDrawn[_beneficiary]),\r\n        address(schedule.depositAccount)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Draw down amount currently available (based on the block timestamp)\r\n     * @param _beneficiary beneficiary of the vested tokens\r\n     * @return _amount tokens due from vesting schedule\r\n     */\r\n    function availableDrawDownAmount(address _beneficiary) external view returns (uint256 _amount) {\r\n        return _availableDrawDownAmount(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Balance remaining in vesting schedule\r\n     * @param _beneficiary beneficiary of the vested tokens\r\n     * @return _remainingBalance tokens still due (and currently locked) from vesting schedule\r\n     */\r\n    function remainingBalance(address _beneficiary) external view returns (uint256 _remainingBalance) {\r\n        Schedule memory schedule = vestingSchedule[_beneficiary];\r\n        return schedule.amount.sub(totalDrawn[_beneficiary]);\r\n    }\r\n\r\n    // Internal\r\n\r\n    function _drawDown(address _beneficiary) internal returns (bool) {\r\n        Schedule memory schedule = vestingSchedule[_beneficiary];\r\n        require(schedule.amount > 0, \"VestingContract::_drawDown: There is no schedule currently in flight\");\r\n\r\n        uint256 amount = _availableDrawDownAmount(_beneficiary);\r\n        require(amount > 0, \"VestingContract::_drawDown: No allowance left to withdraw\");\r\n\r\n        // Update last drawn to now\r\n        lastDrawnAt[_beneficiary] = _getNow();\r\n\r\n        // Increase total drawn amount\r\n        totalDrawn[_beneficiary] = totalDrawn[_beneficiary].add(amount);\r\n\r\n        // Safety measure - this should never trigger\r\n        require(\r\n            totalDrawn[_beneficiary] <= schedule.amount,\r\n            \"VestingContract::_drawDown: Safety Mechanism - Drawn exceeded Amount Vested\"\r\n        );\r\n\r\n        // Issue tokens to beneficiary\r\n        require(\r\n            schedule.depositAccount.transferToBeneficiary(amount),\r\n            \"VestingContract::_drawDown: Unable to transfer tokens\"\r\n        );\r\n\r\n        emit DrawDown(_beneficiary, amount, _getNow());\r\n\r\n        return true;\r\n    }\r\n\r\n    function _getNow() internal view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function _availableDrawDownAmount(address _beneficiary) internal view returns (uint256 _amount) {\r\n        Schedule memory schedule = vestingSchedule[_beneficiary];\r\n\r\n        // voided contract should not allow any draw downs\r\n        if (voided[_beneficiary]) {\r\n            return 0;\r\n        }\r\n\r\n        // cliff\r\n        if (_getNow() <= start.add(cliffDuration)) {\r\n            // the cliff period has not ended, no tokens to draw down\r\n            return 0;\r\n        }\r\n\r\n        // schedule complete\r\n        if (_getNow() > end) {\r\n            return schedule.amount.sub(totalDrawn[_beneficiary]);\r\n        }\r\n\r\n        // Schedule is active\r\n\r\n        // Work out when the last invocation was\r\n        uint256 timeLastDrawnOrStart = lastDrawnAt[_beneficiary] == 0 ? start : lastDrawnAt[_beneficiary];\r\n\r\n        // Find out how much time has past since last invocation\r\n        uint256 timePassedSinceLastInvocation = _getNow().sub(timeLastDrawnOrStart);\r\n\r\n        // Work out how many due tokens - time passed * rate per second\r\n        uint256 drawDownRate = schedule.amount.div(end.sub(start));\r\n        uint256 amount = timePassedSinceLastInvocation.mul(drawDownRate);\r\n\r\n        return amount;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_baseVestingDepositAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliffDurationInSecs\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"DrawDown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ScheduleCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"availableDrawDownAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseVestingDepositAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cliffDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createVestingSchedule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drawDown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastDrawnAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"remainingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_remainingBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalDrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currentBeneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newBeneficiary\",\"type\":\"address\"}],\"name\":\"updateScheduleBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestingSchedule\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract VestingDepositAccount\",\"name\":\"depositAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"vestingScheduleForBeneficiary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastDrawnAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_drawDownRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_remainingBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_depositAccountAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voided\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VestingContract","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c57d533c50bc22247d49a368880fb49a1caa39f7000000000000000000000000dfdd6014a6b92ed74a3b34f171d6b07cdf8d91de000000000000000000000000000000000000000000000000000000005f6ca66000000000000000000000000000000000000000000000000000000000614dd9e00000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9ee624054ba96d4d69399f0bbd3f83d6969ec90ea7a244b2bd9b09180afb1dba"}]}