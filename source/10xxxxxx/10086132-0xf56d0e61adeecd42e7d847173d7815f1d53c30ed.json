{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.6;\r\n\r\n/**\r\n * @title Blockd Build Demo\r\n * \r\n * @dev This is Blockd's demo contract for Blockd Build.\r\n *      In this contract we have multiple functions with big vulnerabilities\r\n *      that emulate big contract hacks that have happened in the past.\r\n * \r\n *      If a user attempts to take advantage of these vulnerabilities,\r\n *      Blockd Build will race their transaction to blacklist them before\r\n *      their hack can execute.\r\n * \r\n *      Blacklisting is used instead of a contract-wide pause or something less \r\n *      centralized to make public testing less complicated. For the same reason,\r\n *      we pad the gas required for each function so as to not go broke when racing\r\n *      every person who attempts to hack the contract.\r\n * \r\n *      Enjoy testing Blockd Build and good luck hacking this contract!\r\n * \r\n *      P.S. This is not a honeypot! To attempt a hack, you need no Ether deposited.\r\n *      If you deposit Ether, you can withdraw that same amount just fine.\r\n * \r\n * @author Robert M.C. Forster, Blockd L.L.C.\r\n**/\r\ncontract BlockdBuildDemo {\r\n    \r\n    // Owner of the contract. For the purposes of this demo, despite making the contract\r\n    // somewhat centralized, this address is allowed to blacklist users.\r\n    address public owner;\r\n    \r\n    // Balances mapping. Users *should* never be able to withdraw more than is in here.\r\n    mapping (address => uint256) public balances;\r\n    \r\n    // Ether price set by oracle. Doesn't have much of a purpose in this demo besides an example.\r\n    uint256 public etherPrice;\r\n    \r\n    // Blacklist potential hackers on the contract. This centralizes things a bit and wouldn't\r\n    // normally be suggested for Blockd Build, but a contract-wide pause would complicate testing.\r\n    mapping (address => bool) public blacklist;\r\n    \r\n    // Arbitrary variable used to pad gas costs.\r\n    uint256 private padVar;\r\n    \r\n    /**\r\n     * @dev Set owner and Ether price..\r\n    **/\r\n    constructor()\r\n      public\r\n    {\r\n        owner       = msg.sender;\r\n        etherPrice  = 1;\r\n    }\r\n    \r\n    /**\r\n     * @dev Owner may transfer ownership of the contract.\r\n     * @param _newOwner The new address that will have power over blacklisting.\r\n     * @notice Uh-oh, this has no require! Anyone can call this successfully!\r\n    **/\r\n    function transferOwner( address _newOwner )\r\n      public\r\n      padGas\r\n      notBLorSC\r\n    {\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Callback may be used by Oracle to set new Ether price.\r\n     *      API data is gotten from: \"https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD\"\r\n     *      Callback must equal USD value * 100\r\n     * @param _etherPrice The new price of Ether (should always be 1).\r\n     * @notice Uh-oh, this function does not check that sender is Oraclize!\r\n    **/\r\n    function callback( uint256 _etherPrice )\r\n      public\r\n      padGas\r\n      notBLorSC\r\n    {\r\n        etherPrice = _etherPrice;\r\n    }\r\n    \r\n    /**\r\n     * @dev Allows users to withdraw funds from their balances.\r\n     * @param _amount The amount of funds the user would like to withdraw.\r\n     * @notice Uh-oh, this doesn't check to make sure the user has enough balance!\r\n    **/\r\n    function withdraw( uint256 _amount )\r\n      public\r\n      padGas\r\n      notBLorSC\r\n    {\r\n        msg.sender.transfer( _amount );\r\n        \r\n        // Let's at least avoid underflows.\r\n        uint256 balance = balances[msg.sender];\r\n        if (balance - _amount < balance) balances[msg.sender] -= _amount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Allows users to deposit funds into their balance.\r\n     * @notice Not a vulnerable function. Simply exists to allow other vectors to be tested\r\n     *         and to demonstrate that an allowed deposit/withdrawal will execute normally.\r\n    **/\r\n    function deposit()\r\n      public\r\n      payable\r\n      padGas\r\n      notBLorSC // Let's not let users deposit if they can't withdraw.\r\n    {\r\n        balances[ msg.sender ] += msg.value;    \r\n    }\r\n    \r\n    /**\r\n     * @dev Allows the owner to blacklist hackers from interacting with the contract.\r\n     * @param _user The address to be blacklisted.\r\n     * @param _blacklist True to blacklist user, false to take user off blacklist.\r\n     * @notice This function is made to not be vulnerable by requiring the sender to be owner.\r\n    **/\r\n    function blacklistUser( address _user, bool _blacklist )\r\n      public\r\n    {\r\n        require( msg.sender == owner );\r\n        blacklist[ _user ]  = _blacklist;\r\n    }\r\n    \r\n    /**\r\n     * @dev Make sure the sender has not been blacklisted for attempting to hack this contract.\r\n     *      Smart contracts are also blocked on this contract to simplify demo.\r\n    **/\r\n    modifier notBLorSC {\r\n        require( !blacklist[ msg.sender ] );\r\n        require( msg.sender == tx.origin );\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev For this demo contract, we're going to pad function gas costs because,\r\n     *      with the amount of hacks we'll have to deal with, the low cost of these hacks,\r\n     *      and the fact that we don't do a pause but continually just block single hackers,\r\n     *      it would get very expensive for us to block everyone who would to race us.\r\n     *      This should add 200,000 to the gas cost, ensuring a successful race would require\r\n     *      around 10x the cost of a blacklist transaction.\r\n    **/\r\n    modifier padGas {\r\n        for ( uint256 i = 1; i < 200; i++ ) {\r\n            padVar = i;\r\n        }\r\n        _;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_blacklist\",\"type\":\"bool\"}],\"name\":\"blacklistUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_etherPrice\",\"type\":\"uint256\"}],\"name\":\"callback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BlockdBuildDemo","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7d9e1aa5f97d72ad2e78b5f9db6eff679fd20ccd99c0f051a0c3072932499dc4"}]}