{"status":"1","message":"OK","result":[{"SourceCode":"// Dependency file: contracts/libraries/SafeMath.sol\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n// Dependency file: contracts/libraries/DemaxSwapLibrary.sol\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\n// import '../interfaces/IDemaxPair.sol';\r\n// import '../interfaces/IDemaxFactory.sol';\r\n// import \"./SafeMath.sol\";\r\n\r\nlibrary DemaxSwapLibrary {\r\n    using SafeMath for uint;\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'DemaxSwapLibrary: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'DemaxSwapLibrary: ZERO_ADDRESS');\r\n    }\r\n\r\n     function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        bytes32 rawAddress = keccak256(\r\n         abi.encodePacked(\r\n            bytes1(0xff),\r\n            factory,\r\n            salt,\r\n            IDemaxFactory(factory).contractCodeHash()\r\n            )\r\n        );\r\n     return address(bytes20(rawAddress << 96));\r\n    }\r\n\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IDemaxPair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n    \r\n    function quoteEnhance(address factory, address tokenA, address tokenB, uint amountA) internal view returns(uint amountB) {\r\n        (uint reserveA, uint reserveB) = getReserves(factory, tokenA, tokenB);\r\n        return quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'DemaxSwapLibrary: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'DemaxSwapLibrary: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'DemaxSwapLibrary: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'DemaxSwapLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = amountIn.mul(reserveOut);\r\n        uint denominator = reserveIn.add(amountIn);\r\n        amountOut = numerator / denominator;\r\n    }\r\n    \r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'DemaxSwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'DemaxSwapLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut);\r\n        uint denominator = reserveOut.sub(amountOut);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n}\r\n// Dependency file: contracts/interfaces/IDemaxPair.sol\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IDemaxPair {\r\n  \r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address from, address to, uint amount) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address tokenA, address tokenB, address platform, address dgas) external;\r\n    function swapFee(uint amount, address token, address to) external ;\r\n    function queryReward() external view returns (uint rewardAmount, uint blockNumber);\r\n    function mintReward() external returns (uint rewardAmount);\r\n    function getDGASReserve() external view returns (uint);\r\n}\r\n\r\n// Dependency file: contracts/interfaces/IERC20.sol\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// Dependency file: contracts/interfaces/IDemaxFactory.sol\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IDemaxFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function contractCodeHash() external view returns (bytes32);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function isPair(address pair) external view returns (bool);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function playerPairs(address player, uint index) external view returns (address pair);\r\n    function getPlayerPairCount(address player) external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function addPlayerPair(address player, address _pair) external returns (bool);\r\n}\r\n\r\n// Dependency file: contracts/interfaces/IDgas.sol\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IDgas {\r\n    function amountPerBlock() external view returns (uint);\r\n    function changeAmountPerBlock(uint value) external returns (bool);\r\n    function getProductivity(address user) external view returns (uint, uint);\r\n    function increaseProductivity(address user, uint value) external returns (bool);\r\n    function decreaseProductivity(address user, uint value) external returns (bool);\r\n    function take() external view returns (uint);\r\n    function takes() external view returns (uint, uint);\r\n    function mint() external returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function upgradeImpl(address _newImpl) external  returns (uint);\r\n}\r\n// Dependency file: contracts/modules/Ownable.sol\r\n\r\n// pragma solidity >=0.5.16;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'Ownable: FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\r\n        emit OwnerChanged(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity >=0.6.6;\r\n// import './modules/Ownable.sol';\r\n// import './interfaces/IDgas.sol';\r\n// import './interfaces/IDemaxFactory.sol';\r\n// import './interfaces/IERC20.sol';\r\n// import './interfaces/IDemaxPair.sol';\r\n// import './libraries/DemaxSwapLibrary.sol';\r\n// import './libraries/SafeMath.sol';\r\n\r\ncontract DemaxTransferListener is Ownable {\r\n    uint public version = 1;\r\n    address public DGAS;\r\n    address public PLATFORM;\r\n    address public WETH;\r\n    address public FACTORY;\r\n    event Transfer(address indexed from, address indexed to, address indexed token, uint256 amount);\r\n\r\n    function initialize(\r\n        address _DGAS,\r\n        address _FACTORY,\r\n        address _WETH,\r\n        address _PLATFORM\r\n    ) external onlyOwner {\r\n        require(DGAS == address(0), 'DEMAX TRANSFER LISTENER : ADDRESS IS ZERO');\r\n        require(\r\n            _DGAS != address(0) && _FACTORY != address(0) && _WETH != address(0) && _PLATFORM != address(0),\r\n            'DEMAX TRANSFER LISTENER : INPUT ADDRESS IS ZERO'\r\n        );\r\n        DGAS = _DGAS;\r\n        FACTORY = _FACTORY;\r\n        WETH = _WETH;\r\n        PLATFORM = _PLATFORM;\r\n    }\r\n\r\n    function updateDGASImpl(address _newImpl) external onlyOwner {\r\n        IDgas(DGAS).upgradeImpl(_newImpl);\r\n    }\r\n\r\n    function transferNotify(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        require(msg.sender == PLATFORM, 'DEMAX TRANSFER LISTENER: PERMISSION');\r\n        if (token == WETH) {\r\n            if (IDemaxFactory(FACTORY).isPair(from)) {\r\n                uint256 decreasePower = IDemaxFactory(FACTORY).getPair(DGAS, WETH) == from\r\n                    ? SafeMath.mul(amount, 2)\r\n                    : amount;\r\n                IDgas(DGAS).decreaseProductivity(from, decreasePower);\r\n            }\r\n            if (IDemaxFactory(FACTORY).isPair(to)) {\r\n                uint256 increasePower = IDemaxFactory(FACTORY).getPair(DGAS, WETH) == to\r\n                    ? SafeMath.mul(amount, 2)\r\n                    : amount;\r\n                IDgas(DGAS).increaseProductivity(to, increasePower);\r\n            }\r\n        } else if (token == DGAS) {\r\n            (uint256 reserveDGAS, uint256 reserveWETH) = DemaxSwapLibrary.getReserves(FACTORY, DGAS, WETH);\r\n            if (IDemaxFactory(FACTORY).isPair(to) && IDemaxFactory(FACTORY).getPair(DGAS, WETH) != to) {\r\n                IDgas(DGAS).increaseProductivity(to, DemaxSwapLibrary.quote(amount, reserveDGAS, reserveWETH));\r\n            }\r\n            if (IDemaxFactory(FACTORY).isPair(from) && IDemaxFactory(FACTORY).getPair(DGAS, WETH) != from) {\r\n                (uint256 pairPower, ) = IDgas(DGAS).getProductivity(from);\r\n                uint256 balance = IDemaxPair(from).getDGASReserve();\r\n                uint256 decrasePower = (SafeMath.mul(amount, pairPower)) / (SafeMath.add(balance, amount));\r\n                if (decrasePower > 0) IDgas(DGAS).decreaseProductivity(from, decrasePower);\r\n            }\r\n        }\r\n        emit Transfer(from, to, token, amount);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DGAS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DGAS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_FACTORY\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_PLATFORM\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferNotify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImpl\",\"type\":\"address\"}],\"name\":\"updateDGASImpl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DemaxTransferListener","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fef88f69d28cdd4a0ac57ce6a9ac943fb5eac6995bfd203630e9293b8f76e084"}]}