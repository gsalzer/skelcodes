{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/libraries/openzeppelin-upgradeability/VersionedInitializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n/**\r\n * @title VersionedInitializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n *\r\n * @author Aave, inspired by the OpenZeppelin Initializable contract\r\n */\r\ncontract VersionedInitializable {\r\n    /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n    uint256 private lastInitializedRevision = 0;\r\n\r\n    /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n    bool private initializing;\r\n\r\n    /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n    modifier initializer() {\r\n        uint256 revision = getRevision();\r\n        require(initializing || isConstructor() || revision > lastInitializedRevision, \"Contract instance has already been initialized\");\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            lastInitializedRevision = revision;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns the revision number of the contract.\r\n    /// Needs to be defined in the inherited class as a constant.\r\n    function getRevision() internal pure returns(uint256);\r\n\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        uint256 cs;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            cs := extcodesize(address)\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/interfaces/IFeeProvider.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title IFeeProvider interface\r\n* @notice Interface for the Aave fee provider.\r\n**/\r\n\r\ninterface IFeeProvider {\r\n    function calculateLoanOriginationFee(address _user, uint256 _amount) external view returns (uint256);\r\n    function getLoanOriginationFeePercentage() external view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/WadRayMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n* @title WadRayMath library\r\n* @author Aave\r\n* @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n**/\r\n\r\nlibrary WadRayMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant halfWAD = WAD / 2;\r\n\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant halfRAY = RAY / 2;\r\n\r\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n    /**\r\n    * @return one ray, 1e27\r\n    **/\r\n    function ray() internal pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    /**\r\n    * @return one wad, 1e18\r\n    **/\r\n\r\n    function wad() internal pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    /**\r\n    * @return half ray, 1e27/2\r\n    **/\r\n    function halfRay() internal pure returns (uint256) {\r\n        return halfRAY;\r\n    }\r\n\r\n    /**\r\n    * @return half ray, 1e18/2\r\n    **/\r\n    function halfWad() internal pure returns (uint256) {\r\n        return halfWAD;\r\n    }\r\n\r\n    /**\r\n    * @dev multiplies two wad, rounding half up to the nearest wad\r\n    * @param a wad\r\n    * @param b wad\r\n    * @return the result of a*b, in wad\r\n    **/\r\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfWAD.add(a.mul(b)).div(WAD);\r\n    }\r\n\r\n    /**\r\n    * @dev divides two wad, rounding half up to the nearest wad\r\n    * @param a wad\r\n    * @param b wad\r\n    * @return the result of a/b, in wad\r\n    **/\r\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(WAD)).div(b);\r\n    }\r\n\r\n    /**\r\n    * @dev multiplies two ray, rounding half up to the nearest ray\r\n    * @param a ray\r\n    * @param b ray\r\n    * @return the result of a*b, in ray\r\n    **/\r\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfRAY.add(a.mul(b)).div(RAY);\r\n    }\r\n\r\n    /**\r\n    * @dev divides two ray, rounding half up to the nearest ray\r\n    * @param a ray\r\n    * @param b ray\r\n    * @return the result of a/b, in ray\r\n    **/\r\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(RAY)).div(b);\r\n    }\r\n\r\n    /**\r\n    * @dev casts ray down to wad\r\n    * @param a ray\r\n    * @return a casted to wad, rounded half up to the nearest wad\r\n    **/\r\n    function rayToWad(uint256 a) internal pure returns (uint256) {\r\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n\r\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\r\n    }\r\n\r\n    /**\r\n    * @dev convert wad up to ray\r\n    * @param a wad\r\n    * @return a converted in ray\r\n    **/\r\n    function wadToRay(uint256 a) internal pure returns (uint256) {\r\n        return a.mul(WAD_RAY_RATIO);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates base^exp. The code uses the ModExp precompile\r\n    * @return base^exp, in ray\r\n    */\r\n    //solium-disable-next-line\r\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rayMul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rayMul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/fees/FeeProvider.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title FeeProvider contract\r\n* @notice Implements calculation for the fees applied by the protocol\r\n* @author Aave\r\n**/\r\ncontract FeeProvider is IFeeProvider, VersionedInitializable {\r\n    using WadRayMath for uint256;\r\n\r\n    // percentage of the fee to be calculated on the loan amount\r\n    uint256 public originationFeePercentage;\r\n\r\n\r\n    uint256 constant public FEE_PROVIDER_REVISION = 0x2;\r\n\r\n    function getRevision() internal pure returns(uint256) {\r\n        return FEE_PROVIDER_REVISION;\r\n    }\r\n    /**\r\n    * @dev initializes the FeeProvider after it's added to the proxy\r\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider\r\n    */\r\n    function initialize(address _addressesProvider) public initializer {\r\n        /// @notice origination fee is set as default as 1 basis point of the loan amount (0.0001%)\r\n        originationFeePercentage = 0.0001 * 1e18;\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the origination fee for every loan executed on the platform.\r\n    * @param _user can be used in the future to apply discount to the origination fee based on the\r\n    * _user account (eg. stake AAVE tokens in the lending pool, or deposit > 1M USD etc.)\r\n    * @param _amount the amount of the loan\r\n    **/\r\n    function calculateLoanOriginationFee(address _user, uint256 _amount) external view returns (uint256) {\r\n        return _amount.wadMul(originationFeePercentage);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the origination fee percentage\r\n    **/\r\n    function getLoanOriginationFeePercentage() external view returns (uint256) {\r\n        return originationFeePercentage;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"FEE_PROVIDER_REVISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateLoanOriginationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLoanOriginationFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressesProvider\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"originationFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FeeProvider","CompilerVersion":"v0.5.14+commit.01f1aaa4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a7810c2702c0c88361d0fdda2cf9f5c583e9f9e9678b2a563fa1557599a09344"}]}