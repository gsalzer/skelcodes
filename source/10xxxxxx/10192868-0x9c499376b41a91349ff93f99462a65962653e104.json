{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\ninterface ExchangeInterfaceV2 {\r\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable returns (uint);\r\n\r\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external payable returns(uint);\r\n\r\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\r\n\r\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\r\n}\r\nabstract contract OasisInterface {\r\n    function getBuyAmount(address tokenToBuy, address tokenToPay, uint256 amountToPay)\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint256 amountBought);\r\n\r\n    function getPayAmount(address tokenToPay, address tokenToBuy, uint256 amountToBuy)\r\n        public virtual\r\n        view\r\n        returns (uint256 amountPaid);\r\n\r\n    function sellAllAmount(address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount)\r\n        public virtual\r\n        returns (uint256 fill_amt);\r\n\r\n    function buyAllAmount(address buy_gem, uint256 buy_amt, address pay_gem, uint256 max_fill_amount)\r\n        public virtual\r\n        returns (uint256 fill_amt);\r\n}\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function decimals() external view returns (uint256 digits);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\nabstract contract TokenInterface {\r\n    function allowance(address, address) public virtual returns (uint256);\r\n\r\n    function balanceOf(address) public virtual returns (uint256);\r\n\r\n    function approve(address, uint256) public virtual;\r\n\r\n    function transfer(address, uint256) public virtual returns (bool);\r\n\r\n    function transferFrom(address, address, uint256) public virtual returns (bool);\r\n\r\n    function deposit() public virtual payable;\r\n\r\n    function withdraw(uint256) public virtual;\r\n}\r\ncontract DSMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint256 constant WAD = 10**18;\r\n    uint256 constant RAY = 10**27;\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\ncontract OasisTradeWrapper is DSMath, ExchangeInterfaceV2 {\r\n    \r\n    address public constant OTC_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\r\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    /// @notice Sells a _srcAmount of tokens at Oasis\r\n    /// @param _srcAddr From token\r\n    /// @param _destAddr To token\r\n    /// @param _srcAmount From amount\r\n    /// @return uint Destination amount\r\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\r\n        address srcAddr = ethToWethAddr(_srcAddr);\r\n        address destAddr = ethToWethAddr(_destAddr);\r\n\r\n        require(ERC20(srcAddr).approve(OTC_ADDRESS, _srcAmount), \"Approve src token\");\r\n\r\n        // convert eth -> weth\r\n        if (srcAddr == WETH_ADDRESS) {\r\n            TokenInterface(WETH_ADDRESS).deposit{value: _srcAmount}();\r\n        }\r\n\r\n        uint destAmount = OasisInterface(OTC_ADDRESS).sellAllAmount(srcAddr, _srcAmount, destAddr, 0);\r\n\r\n        // convert weth -> eth and send back\r\n        if (destAddr == WETH_ADDRESS) {\r\n            TokenInterface(WETH_ADDRESS).withdraw(destAmount);\r\n            msg.sender.transfer(destAmount);\r\n        } else {\r\n            ERC20(destAddr).transfer(msg.sender, destAmount);\r\n        }\r\n\r\n        return destAmount;\r\n    }\r\n\r\n    /// @notice Buys a _destAmount of tokens at Oasis\r\n    /// @param _srcAddr From token\r\n    /// @param _destAddr To token\r\n    /// @param _destAmount To amount\r\n    /// @return uint srcAmount\r\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\r\n        address srcAddr = ethToWethAddr(_srcAddr);\r\n        address destAddr = ethToWethAddr(_destAddr);\r\n\r\n        require(ERC20(srcAddr).approve(OTC_ADDRESS, uint(-1)), \"Approve src token\");\r\n\r\n        // convert eth -> weth\r\n        if (srcAddr == WETH_ADDRESS) {\r\n            TokenInterface(WETH_ADDRESS).deposit{value: msg.value}();\r\n        }\r\n\r\n        uint srcAmount = OasisInterface(OTC_ADDRESS).buyAllAmount(srcAddr, _destAmount, destAddr, uint(-1));\r\n\r\n        // convert weth -> eth and send back\r\n        if (destAddr == WETH_ADDRESS) {\r\n            TokenInterface(WETH_ADDRESS).withdraw(_destAmount);\r\n            msg.sender.transfer(_destAmount);\r\n        } else {\r\n            ERC20(destAddr).transfer(msg.sender, _destAmount);\r\n        }\r\n\r\n        // Send the leftover from the source token back\r\n        sendLeftOver(srcAddr);\r\n\r\n        return srcAmount;\r\n    }\r\n\r\n    /// @notice Return a rate for which we can sell an amount of tokens\r\n    /// @param _srcAddr From token\r\n    /// @param _destAddr To token\r\n    /// @param _srcAmount From amount\r\n    /// @return uint Rate\r\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\r\n        address srcAddr = ethToWethAddr(_srcAddr);\r\n        address destAddr = ethToWethAddr(_destAddr);\r\n\r\n        return wdiv(OasisInterface(OTC_ADDRESS).getBuyAmount(srcAddr, destAddr, _srcAmount), _srcAmount);\r\n    }\r\n\r\n\r\n    /// @notice Return a rate for which we can buy an amount of tokens\r\n    /// @param _srcAddr From token\r\n    /// @param _destAddr To token\r\n    /// @param _destAmount To amount\r\n    /// @return uint Rate\r\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\r\n        address srcAddr = ethToWethAddr(_srcAddr);\r\n        address destAddr = ethToWethAddr(_destAddr);\r\n\r\n        return wdiv(OasisInterface(OTC_ADDRESS).getPayAmount(destAddr, srcAddr, _destAmount), _destAmount);\r\n    }\r\n\r\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\r\n    /// @param _srcAddr Source token address\r\n    function sendLeftOver(address _srcAddr) internal {\r\n         address srcAddr = ethToWethAddr(_srcAddr);\r\n\r\n        if (srcAddr == WETH_ADDRESS) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20(srcAddr).transfer(msg.sender, ERC20(srcAddr).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /// @notice Converts Kybers Eth address -> Weth\r\n    /// @param _src Input address\r\n    function ethToWethAddr(address _src) internal pure returns (address) {\r\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\r\n    }\r\n\r\n\r\n    receive() payable external {}\r\n}","ABI":"[{\"inputs\":[],\"name\":\"KYBER_ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OTC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_destAmount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_destAmount\",\"type\":\"uint256\"}],\"name\":\"getBuyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_srcAmount\",\"type\":\"uint256\"}],\"name\":\"getSellRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_srcAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"OasisTradeWrapper","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://34a72bf594fdf3dd9033870fa2bbe6a590a839f45ac0df2da84165006953355e"}]}