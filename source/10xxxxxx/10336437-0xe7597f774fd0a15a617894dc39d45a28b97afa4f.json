{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOWriter.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./IACOToken.sol\\\";\\r\\nimport \\\"./IWETH.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ACOWriter\\r\\n * @dev Contract to write ACO tokens. Minting them and then selling through the 0x protocol.\\r\\n */\\r\\ncontract ACOWriter {\\r\\n    \\r\\n    /**\\r\\n     * @dev The WETH address.\\r\\n     */\\r\\n    address immutable public weth;\\r\\n    \\r\\n    /**\\r\\n     * @dev Address for 0x ERC20 proxy.\\r\\n     */\\r\\n    address immutable public erc20proxy;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 balanceOf function.\\r\\n     */\\r\\n    bytes4 immutable internal _balanceOfSelector;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 transfer function.\\r\\n     */\\r\\n    bytes4 immutable internal _transferSelector;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 transferFrom function.\\r\\n     */\\r\\n    bytes4 immutable internal _transferFromSelector;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 approve function.\\r\\n     */\\r\\n    bytes4 immutable internal _approveSelector;\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal data to control the exchange address.\\r\\n     */\\r\\n    address internal _exchange;\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal data to control the reentrancy.\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to handle with the exchange address during the transaction.\\r\\n     */\\r\\n    modifier setExchange(address exchange) {\\r\\n        _exchange = exchange;\\r\\n        _;\\r\\n        _exchange = address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"ACOWriter::Reentry\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    constructor(address _weth, address _erc20proxy) public {\\r\\n        weth =_weth;\\r\\n        erc20proxy = _erc20proxy;\\r\\n        \\r\\n        _balanceOfSelector = bytes4(keccak256(bytes(\\\"balanceOf(address)\\\")));\\r\\n        _transferSelector = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\r\\n        _transferFromSelector = bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\r\\n        _approveSelector = bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\r\\n        \\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to guarantee that the contract will receive ether only from the exchange.\\r\\n     */\\r\\n    receive() external payable {\\r\\n        if (msg.sender != _exchange) {\\r\\n            revert();\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to write ACO tokens.\\r\\n     * The tokens are minted then sold on the 0x exchange. The transaction sender receive the premium. \\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param collateralAmount Amount of collateral deposited.\\r\\n     * @param exchangeAddress Address to sell the tokens.\\r\\n     * @param exchangeData Data to be sent to the exchange.\\r\\n     */\\r\\n    function write(\\r\\n        address acoToken, \\r\\n        uint256 collateralAmount, \\r\\n        address exchangeAddress, \\r\\n        bytes memory exchangeData\\r\\n    ) \\r\\n        nonReentrant \\r\\n        setExchange(exchangeAddress) \\r\\n        public \\r\\n        payable \\r\\n    {\\r\\n        require(msg.value \\u003e 0,  \\\"ACOWriter::write: Invalid msg value\\\");\\r\\n        require(collateralAmount \\u003e 0,  \\\"ACOWriter::write: Invalid collateral amount\\\");\\r\\n        \\r\\n        address _collateral = IACOToken(acoToken).collateral();\\r\\n        if (_isEther(_collateral)) {\\r\\n            IACOToken(acoToken).mintToPayable{value: collateralAmount}(msg.sender);\\r\\n        } else {\\r\\n            _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\\r\\n            _approveERC20(_collateral, acoToken, collateralAmount);\\r\\n            IACOToken(acoToken).mintTo(msg.sender, collateralAmount);\\r\\n        }\\r\\n        \\r\\n        _sellACOTokens(acoToken, exchangeData);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to sell the ACO tokens and transfer the premium to the transaction sender.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param exchangeData Data to be sent to the exchange.\\r\\n     */\\r\\n    function _sellACOTokens(address acoToken, bytes memory exchangeData) internal {\\r\\n        uint256 acoBalance = _balanceOfERC20(acoToken, address(this));\\r\\n        _approveERC20(acoToken, erc20proxy, acoBalance);\\r\\n        (bool success,) = _exchange.call{value: address(this).balance}(exchangeData);\\r\\n        require(success, \\\"ACOWriter::_sellACOTokens: Error on call the exchange\\\");\\r\\n        \\r\\n        address token = IACOToken(acoToken).strikeAsset();\\r\\n        if(_isEther(token)) {\\r\\n            uint256 wethBalance = _balanceOfERC20(weth, address(this));\\r\\n            if (wethBalance \\u003e 0) {\\r\\n                IWETH(weth).withdraw(wethBalance);\\r\\n            }\\r\\n        } else {\\r\\n            _transferERC20(token, msg.sender, _balanceOfERC20(token, address(this)));\\r\\n        }\\r\\n        \\r\\n        if (address(this).balance \\u003e 0) {\\r\\n            msg.sender.transfer(address(this).balance);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    } \\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get balance of ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param owner Address of the owner.\\r\\n     * @return The token balance of the owner.\\r\\n     */\\r\\n    function _balanceOfERC20(address token, address owner) internal view returns(uint256) {\\r\\n        (bool success, bytes memory returndata) = token.staticcall(abi.encodeWithSelector(_balanceOfSelector, owner));\\r\\n        require(success, \\\"ACOWriter::_balanceOfERC20\\\");\\r\\n        return abi.decode(returndata, (uint256));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _approveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_approveSelector, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOWriter::_approveERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _transferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferFromSelector, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOWriter::_transferFromERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _transferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferSelector, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOWriter::_transferERC20\\\");\\r\\n    }\\r\\n}\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable;\\r\\n    function mintToPayable(address account) external payable;\\r\\n    function mint(uint256 collateralAmount) external;\\r\\n    function mintTo(address account, uint256 collateralAmount) external;\\r\\n    function burn(uint256 tokenAmount) external;\\r\\n    function burnFrom(address account, uint256 tokenAmount) external;\\r\\n    function redeem() external;\\r\\n    function redeemFrom(address account) external;\\r\\n    function exercise(uint256 tokenAmount) external payable;\\r\\n    function exerciseFrom(address account, uint256 tokenAmount) external payable;\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable;\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable;\\r\\n    function clear() external;\\r\\n    function clearFrom(address account) external;\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IWETH.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function withdraw(uint) external;\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc20proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"erc20proxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"exchangeData\",\"type\":\"bytes\"}],\"name\":\"write\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOWriter","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000095e6f48254609a6ee006f7d493c8e5fb97094cef","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5ddd33bc87693ef2cc475b3c03ba594c46ca0db98440ea4e60dec8714af4ad9e"}]}