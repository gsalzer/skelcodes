{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/StableCoinInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface StableCoinInterface is IERC20 {\r\n    event LogIsAcceptableSBT(bytes32 indexed bondID, bool isAcceptable);\r\n\r\n    event LogMintIDOL(\r\n        bytes32 indexed bondID,\r\n        address indexed owner,\r\n        bytes32 poolID,\r\n        uint256 obtainIDOLAmount,\r\n        uint256 poolIDOLAmount\r\n    );\r\n\r\n    event LogBurnIDOL(\r\n        bytes32 indexed bondID, // poolID?\r\n        address indexed owner,\r\n        uint256 burnIDOLAmount,\r\n        uint256 unlockSBTAmount\r\n    );\r\n\r\n    event LogReturnLockedPool(\r\n        bytes32 indexed poolID,\r\n        address indexed owner,\r\n        uint64 backIDOLAmount\r\n    );\r\n\r\n    function getPoolInfo(bytes32 poolID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 lockedSBTTotal,\r\n            uint64 unlockedSBTTotal,\r\n            uint64 lockedPoolIDOLTotal,\r\n            uint64 burnedIDOLTotal,\r\n            uint64 soldSBTTotalInAuction,\r\n            uint64 paidIDOLTotalInAuction,\r\n            uint64 settledAverageAuctionPrice,\r\n            bool isAllAmountSoldInAuction\r\n        );\r\n\r\n    function solidValueTotal() external view returns (uint256 solidValue);\r\n\r\n    function isAcceptableSBT(bytes32 bondID) external returns (bool ok);\r\n\r\n    function mint(\r\n        bytes32 bondID,\r\n        address recipient,\r\n        uint64 lockAmount\r\n    )\r\n        external\r\n        returns (\r\n            bytes32 poolID,\r\n            uint64 obtainIDOLAmount,\r\n            uint64 poolIDOLAmount\r\n        );\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n    function unlockSBT(bytes32 bondID, uint64 burnAmount)\r\n        external\r\n        returns (uint64 rewardSBT);\r\n\r\n    function startAuctionOnMaturity(bytes32 bondID) external;\r\n\r\n    function startAuctionByMarket(bytes32 bondID) external;\r\n\r\n    function setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 totalPaidIDOL,\r\n        uint64 SBTAmount,\r\n        bool isLast\r\n    ) external;\r\n\r\n    function calcSBT2IDOL(uint256 solidBondAmount)\r\n        external\r\n        view\r\n        returns (uint256 IDOLAmount);\r\n\r\n    function returnLockedPool(bytes32[] calldata poolIDs)\r\n        external\r\n        returns (uint64 IDOLAmount);\r\n\r\n    function generatePoolID(bytes32 bondID, uint64 count)\r\n        external\r\n        pure\r\n        returns (bytes32 poolID);\r\n\r\n    function getCurrentPoolID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 poolID);\r\n\r\n    function getLockedPool(address user, bytes32 poolID)\r\n        external\r\n        view\r\n        returns (uint64, uint64);\r\n}\r\n\r\n// File: contracts/util/Time.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract Time {\r\n    function _getBlockTimestampSec()\r\n        internal\r\n        view\r\n        returns (uint256 unixtimesec)\r\n    {\r\n        unixtimesec = now; // solium-disable-line security/no-block-members\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    constructor() internal {}\r\n\r\n    function _msgSender() internal virtual view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal virtual view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n\r\n\r\n            bytes32 accountHash\r\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20MinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        virtual\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(\r\n            amount,\r\n            \"ERC20: burn amount exceeds balance\"\r\n        );\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionTimeControlInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface AuctionTimeControlInterface {\r\n    enum TimeControlFlag {\r\n        BEFORE_AUCTION_FLAG,\r\n        ACCEPTING_BIDS_PERIOD_FLAG,\r\n        REVEALING_BIDS_PERIOD_FLAG,\r\n        RECEIVING_SBT_PERIOD_FLAG,\r\n        AFTER_AUCTION_FLAG\r\n    }\r\n\r\n    function listAuction(uint256 timestamp)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n\r\n    function getTimeControlFlag(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (TimeControlFlag);\r\n\r\n    function isInPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function isAfterPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/AuctionInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface AuctionInterface is AuctionTimeControlInterface {\r\n    event LogStartAuction(bytes32 indexed auctionID, bytes32 bondID);\r\n\r\n    event LogCancelBid(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes32 secret,\r\n        uint256 returnedIDOLAmount\r\n    );\r\n\r\n    event LogAuctionResult(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint256 SBTAmountOfReward,\r\n        uint256 IDOLAmountOfPayment,\r\n        uint256 IDOLAmountOfChange\r\n    );\r\n\r\n    event LogCloseAuction(\r\n        bytes32 indexed auctionID,\r\n        bool isLast,\r\n        bytes32 nextAuctionID\r\n    );\r\n\r\n    function auctionID2BondID(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (bytes32);\r\n\r\n    function ongoingAuctionSBTTotal(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64 ongoingSBTAmountE8);\r\n\r\n    function startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) external returns (bytes32 auctonID);\r\n\r\n    function cancelBid(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (uint64 returnedIDOLAmount);\r\n\r\n    function makeAuctionResult(\r\n        bytes32 auctionID,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata winnerBids,\r\n        uint64[] calldata loserBids\r\n    )\r\n        external\r\n        returns (\r\n            uint64 winnerAmount,\r\n            uint64 toPay,\r\n            uint64 IDOLAmountOfChange\r\n        );\r\n\r\n    function closeAuction(bytes32 auctionID)\r\n        external\r\n        returns (bool isLast, bytes32 nextAuctionID);\r\n\r\n    function receiveUnrevealedBidDistribution(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (bool success);\r\n\r\n    function getCurrentAuctionID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 auctionID);\r\n\r\n    function generateAuctionID(bytes32 bondID, uint256 auctionCount)\r\n        external\r\n        pure\r\n        returns (bytes32 auctionID);\r\n\r\n    function listBondIDFromAuctionID(bytes32[] calldata auctionIDs)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs);\r\n\r\n    function getAuctionStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 closingTime,\r\n            uint64 auctionAmount,\r\n            uint64 rewardedAmount,\r\n            uint64 totalSBTAmountBid,\r\n            bool isEmergency,\r\n            bool doneFinalizeWinnerAmount,\r\n            bool doneSortPrice,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n            uint64 totalSBTAmountPaidForUnrevealed\r\n        );\r\n\r\n    function getWeeklyAuctionStatus(uint256 weekNumber)\r\n        external\r\n        view\r\n        returns (uint256[] memory weeklyAuctionStatus);\r\n\r\n    function calcWinnerAmount(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64[] calldata winnerBids\r\n    ) external view returns (uint64 winnerAmount);\r\n\r\n    function calcBillAndCheckLoserBids(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64 winnerAmountInput,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata myLoseBids\r\n    ) external view returns (uint64 paymentAmount);\r\n\r\n    function getAuctionCount(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (uint256 auctionCount);\r\n}\r\n\r\n// File: contracts/util/DeployerRole.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract DeployerRole {\r\n    address internal immutable _deployer;\r\n\r\n    modifier onlyDeployer() {\r\n        require(\r\n            _isDeployer(msg.sender),\r\n            \"only deployer is allowed to call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _deployer = msg.sender;\r\n    }\r\n\r\n    function _isDeployer(address account) internal view returns (bool) {\r\n        return account == _deployer;\r\n    }\r\n}\r\n\r\n// File: contracts/UseAuctionLater.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract UseAuctionLater is DeployerRole {\r\n    AuctionInterface internal _auctionContract;\r\n\r\n    modifier isNotEmptyAuctionInstance() {\r\n        require(\r\n            address(_auctionContract) != address(0),\r\n            \"the auction contract is not set\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev This function is called only once when the code is initially deployed.\r\n     */\r\n    function setAuctionContract(address contractAddress) public onlyDeployer {\r\n        require(\r\n            address(_auctionContract) == address(0),\r\n            \"the auction contract is already registered\"\r\n        );\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _setAuctionContract(contractAddress);\r\n    }\r\n\r\n    function _setAuctionContract(address contractAddress) internal {\r\n        _auctionContract = AuctionInterface(payable(contractAddress));\r\n    }\r\n}\r\n\r\n// File: contracts/util/TransferETHInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface TransferETHInterface {\r\n    receive() external payable;\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/bondToken/BondTokenInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface BondTokenInterface is TransferETHInterface, IERC20 {\r\n    event LogExpire(\r\n        uint128 rateNumerator,\r\n        uint128 rateDenominator,\r\n        bool firstTime\r\n    );\r\n\r\n    function mint(address account, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function expire(uint128 rateNumerator, uint128 rateDenominator)\r\n        external\r\n        returns (bool firstTime);\r\n\r\n    function burn(uint256 amount) external returns (bool success);\r\n\r\n    function burnAll() external returns (uint256 amount);\r\n\r\n    function isMinter(address account) external view returns (bool minter);\r\n\r\n    function getRate()\r\n        external\r\n        view\r\n        returns (uint128 rateNumerator, uint128 rateDenominator);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 private constant _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(\r\n            !(a == -1 && b == _INT256_MIN),\r\n            \"SignedSafeMath: multiplication overflow\"\r\n        );\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(\r\n            !(b == -1 && a == _INT256_MIN),\r\n            \"SignedSafeMath: division overflow\"\r\n        );\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require(\r\n            (b >= 0 && c <= a) || (b < 0 && c > a),\r\n            \"SignedSafeMath: subtraction overflow\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require(\r\n            (b >= 0 && c >= a) || (b < 0 && c < a),\r\n            \"SignedSafeMath: addition overflow\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/math/UseSafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\r\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\r\n */\r\n\r\nlibrary SafeMathDivRoundUp {\r\n    using SafeMath for uint256;\r\n\r\n    function divRoundUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(b > 0, errorMessage);\r\n        return ((a - 1) / b) + 1;\r\n    }\r\n\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title UseSafeMath\r\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\r\n * and also can use SafeCast for uint256.\r\n * For example:\r\n *   uint64 a = 1;\r\n *   uint64 b = 2;\r\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\r\n * In additionally, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\r\n * In the case of the operation to the uint64 value, one need to cast the value into int256 in\r\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\r\n * For example:\r\n *   int256 a = 1;\r\n *   uint64 b = 2;\r\n *   int256 c = 3;\r\n *   a = a.add(int256(b).sub(c)); // `a` become 0 as int256\r\n *   b = a.toUint256().toUint64(); // `b` become 0 as uint64\r\n */\r\nabstract contract UseSafeMath {\r\n    using SafeMath for uint256;\r\n    using SafeMathDivRoundUp for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMathDivRoundUp for uint64;\r\n    using SafeMath for uint16;\r\n    using SignedSafeMath for int256;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n}\r\n\r\n// File: contracts/solidBondSafety/SolidBondSafety.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n// This contract is used for calculating minimum threshold acceptable strike price (relative to the current oracle price)\r\n// for the SBT with the time to maturity and the volatility from oracle.\r\n// It is derived from the risk appetite of this protocol.\r\n// For volatile SBT due to the long time to maturity or the underlying ETH volatility,\r\n// the minimum threshold acceptable strike price needs to increase in order to mitigate the risk of emergency auction.\r\n// The policy in this protocol is to equalize the risk of acceptable SBT over the different time to maturity or the underlying ETH volatility.\r\n// The threshold is thus derived from solving the black-scholes formula with a linear approximation technique.\r\n// Even in the approximation of the formula, there remains square root of time, which is tricky to handle in solidity.\r\n// Hence, we deal with the value in the squared form of the value.\r\n// In the following notations, for example, vvtE16 represents v^2 * t * 10^16.\r\nabstract contract SolidBondSafety is UseSafeMath, Time {\r\n    /// @notice The return values of getEmergencyBorderInfo are intermediate values\r\n    /// used for checking if the SBT is acceptable to the IDOL contract.\r\n    /// Let f(x) = a*x + b be the function defined below:\r\n    /// f(x) =            1.1    for 0      <= x <= 0.3576\r\n    /// f(x) =  1.52 x +  0.5564 for 0.3576 < x <= 0.7751\r\n    /// f(x) =  6.4  x -  3.226  for 0.7751 < x <= 1.1562\r\n    /// f(x) = 14.27 x - 12.3256 for 1.1562 < x <= 1.416\r\n    /// f(x) = 29.13 x - 33.3676 for 1.416  < x <= 1.6257\r\n    /// f(x) = 53.15 x - 72.4165 for 1.6257 < x <= 1.8\r\n    /// Then, we define getEmergencyBorderInfo(x^2 * 10^8) = (a^2 * 10^4, b * 10^4).\r\n    /// @param  xxE8 is multiply 10^8 with the square of x\r\n    /// @return aaE4 is multiply 10000 with the square of a\r\n    /// @return bE4  is multiply 10000 with b\r\n    function getEmergencyBorderInfo(uint256 xxE8)\r\n        public\r\n        pure\r\n        returns (int256 aaE4, int256 bE4)\r\n    {\r\n        if (xxE8 <= 3576 * 3576) {\r\n            return (0, 11000);\r\n        } else if (xxE8 <= 7751 * 7751) {\r\n            return (152 * 152, 5564);\r\n        } else if (xxE8 <= 11562 * 11562) {\r\n            return (640 * 640, -32260);\r\n        } else if (xxE8 <= 14160 * 14160) {\r\n            return (1427 * 1427, -123256);\r\n        } else if (xxE8 <= 16257 * 16257) {\r\n            return (2913 * 2913, -333676);\r\n        } else if (xxE8 <= 18000 * 18000) {\r\n            return (5315 * 5315, -724165);\r\n        } else {\r\n            revert(\"not acceptable\");\r\n        }\r\n    }\r\n\r\n    /// @param rateETH2USD S * 10^8 (USD/ETH)\r\n    /// @param solidBondStrikePrice K * 10^4 (USD/SBT)\r\n    /// @param volatility v * 10^8\r\n    /// @param untilMaturity t (= T * 365 * 86400)\r\n    // isInEmergency checks if the SBT should be put into emergency auction.\r\n    // The condition is verified by utilizing approximate form of black-scholes formula.\r\n    function isInEmergency(\r\n        uint256 rateETH2USD,\r\n        uint256 solidBondStrikePrice,\r\n        uint256 volatility,\r\n        uint256 untilMaturity\r\n    ) public pure returns (bool) {\r\n        uint256 vE8 = volatility;\r\n        if (vE8 > 2 * 10**8) {\r\n            vE8 = 2 * 10**8; // The volatility is too high.\r\n        }\r\n        if (untilMaturity >= 12 weeks) {\r\n            return true; // The period until maturity is too long.\r\n        }\r\n        uint256 vvtE16 = vE8.mul(vE8).mul(untilMaturity);\r\n\r\n        uint256 xxE8 = vvtE16 / (64 * 10**6 * 86400 * 365); // 1.25^2 / 10^8 = 1 / (64 * 10^6)\r\n        (int256 aaE4, int256 bE4) = getEmergencyBorderInfo(xxE8);\r\n        int256 sE8 = rateETH2USD.toInt256();\r\n        int256 kE4 = solidBondStrikePrice.toInt256();\r\n        int256 cE8 = sE8.sub(bE4.mul(kE4));\r\n        // int256 lE28 = cE8.mul(cE8).mul(20183040 * 10**12);\r\n        int256 rE28 = int256(vvtE16).mul(aaE4).mul(kE4).mul(kE4);\r\n        bool isDanger = cE8 <= 0 || cE8.mul(cE8).mul(20183040 * 10**12) <= rE28;\r\n        return isDanger;\r\n    }\r\n\r\n    /// @param rateETH2USD S * 10^8 (USD/ETH)\r\n    /// @param solidBondStrikePrice K * 10^4  (USD/SBT)\r\n    /// @param volatility v * 10^8\r\n    /// @param untilMaturity t (= T * 365 * 86400)\r\n    // isDangerSolidBond checks if the SBT is acceptable to be a part of IDOL.\r\n    // The condition is verified by utilizing approximate form of black-scholes formula.\r\n    // This condition is more strict than the condition for triggering emergency auction described in isInEmergency function above.\r\n    function isDangerSolidBond(\r\n        uint256 rateETH2USD,\r\n        uint256 solidBondStrikePrice,\r\n        uint256 volatility,\r\n        uint256 untilMaturity\r\n    ) public pure returns (bool) {\r\n        if (\r\n            solidBondStrikePrice * 5 * 10**4 < rateETH2USD * 2 &&\r\n            untilMaturity < 2 weeks\r\n        ) {\r\n            return false;\r\n        } else if (volatility > 2 * 10**8) {\r\n            return true; // The volatility is too high.\r\n        }\r\n        if (untilMaturity >= 12 weeks) {\r\n            return true; // The period until maturity is too long.\r\n        }\r\n        uint256 vvtE16 = volatility.mul(volatility).mul(untilMaturity);\r\n\r\n        uint256 xxE8 = vvtE16 / (64 * 10**6 * 86400 * 365); // 1.25^2 / 10^8 = 1 / (64 * 10^6)\r\n        (int256 aaE4, int256 bE4) = getEmergencyBorderInfo(xxE8);\r\n        //                                            S/K <= 1.5f(1.25*v*sqrt(T))\r\n        // <=>                                        S/K <= 1.5(1.25a*v*sqrt(T) + b)\r\n        // <=>                                 (2S - 3bK) <= (3.75aKv) * sqrt(T)\r\n        // if 2S > 3bK,\r\n        //                                   (2S - 3bK)^2 <= (3.75aKv)^2 * t / 365 / 86400\r\n        // <=>                       20183040(2S - 3bK)^2 <= 9t(aKv)^2\r\n        // <=> 20183040 * 10^12(10^8 * 2S - 10^8 * 3bK)^2 <= 9 * 10000a^2 * (10000K)^2 * t(10^8 * v)^2\r\n        int256 sE8 = rateETH2USD.toInt256();\r\n        int256 kE4 = solidBondStrikePrice.toInt256();\r\n        int256 cE8 = sE8.mul(2).sub(bE4.mul(kE4).mul(3));\r\n        // int256 lE28 = cE8.mul(cE8).mul(20183040 * 10**12);\r\n        int256 rE28 = int256(vvtE16).mul(aaE4).mul(kE4).mul(kE4).mul(9);\r\n        bool isDanger = cE8 <= 0 || cE8.mul(cE8).mul(20183040 * 10**12) <= rE28;\r\n        return isDanger;\r\n    }\r\n}\r\n\r\n\r\n// File: contracts/oracle/OracleInterface.sol\r\n\r\n// Oracle referenced by OracleProxy must implement this interface.\r\ninterface OracleInterface {\r\n    // Returns if oracle is running.\r\n    function alive() external view returns (bool);\r\n\r\n    // Returns latest id.\r\n    // The first id is 1 and 0 value is invalid as id.\r\n    // Each price values and theirs timestamps are identified by id.\r\n    // Ids are assigned incrementally to values.\r\n    function latestId() external returns (uint256);\r\n\r\n    // Returns latest price value.\r\n    // decimal 8\r\n    function latestPrice() external returns (uint256);\r\n\r\n    // Returns timestamp of latest price.\r\n    function latestTimestamp() external returns (uint256);\r\n\r\n    // Returns price of id.\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    // Returns timestamp of id.\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n\r\n    function getVolatility() external returns (uint256);\r\n}\r\n\r\n// File: contracts/oracle/UseOracle.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract UseOracle {\r\n    OracleInterface internal _oracleContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _oracleContract = OracleInterface(contractAddress);\r\n    }\r\n\r\n    /// @notice Get the latest USD/ETH price and historical volatility using oracle.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    /// @return volatilityE8 (10^-8)\r\n    function _getOracleData()\r\n        internal\r\n        returns (uint256 rateETH2USDE8, uint256 volatilityE8)\r\n    {\r\n        rateETH2USDE8 = _oracleContract.latestPrice();\r\n        volatilityE8 = _oracleContract.getVolatility();\r\n\r\n        return (rateETH2USDE8, volatilityE8);\r\n    }\r\n\r\n    /// @notice Get the price of the oracle data with a minimum timestamp that does more than input value\r\n    /// when you know the ID you are looking for.\r\n    /// @param timestamp is the timestamp that you want to get price.\r\n    /// @param hintID is the ID of the oracle data you are looking for.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    function _getPriceOn(uint256 timestamp, uint256 hintID)\r\n        internal\r\n        returns (uint256 rateETH2USDE8)\r\n    {\r\n        uint256 latestID = _oracleContract.latestId();\r\n        require(\r\n            latestID != 0,\r\n            \"system error: the ID of oracle data should not be zero\"\r\n        );\r\n\r\n        require(hintID != 0, \"the hint ID must not be zero\");\r\n        uint256 id = hintID;\r\n        if (hintID > latestID) {\r\n            id = latestID;\r\n        }\r\n\r\n        require(\r\n            _oracleContract.getTimestamp(id) > timestamp,\r\n            \"there is no price data after maturity\"\r\n        );\r\n\r\n        id--;\r\n        while (id != 0) {\r\n            if (_oracleContract.getTimestamp(id) <= timestamp) {\r\n                break;\r\n            }\r\n            id--;\r\n        }\r\n\r\n        return _oracleContract.getPrice(id + 1);\r\n    }\r\n}\r\n\r\n// File: contracts/BondMakerInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface BondMakerInterface {\r\n    event LogNewBond(\r\n        bytes32 indexed bondID,\r\n        address bondTokenAddress,\r\n        uint64 stableStrikePrice,\r\n        bytes32 fnMapID\r\n    );\r\n\r\n    event LogNewBondGroup(uint256 indexed bondGroupID);\r\n\r\n    event LogIssueNewBonds(\r\n        uint256 indexed bondGroupID,\r\n        address indexed issuer,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogReverseBondToETH(\r\n        uint256 indexed bondGroupID,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogExchangeEquivalentBonds(\r\n        address indexed owner,\r\n        uint256 indexed inputBondGroupID,\r\n        uint256 indexed outputBondGroupID,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    function registerNewBond(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        returns (\r\n            bytes32 bondID,\r\n            address bondTokenAddress,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function registerNewBondGroup(\r\n        bytes32[] calldata bondIDList,\r\n        uint256 maturity\r\n    ) external returns (uint256 bondGroupID);\r\n\r\n    function issueNewBonds(uint256 bondGroupID)\r\n        external\r\n        payable\r\n        returns (uint256 amount);\r\n\r\n    function reverseBondToETH(uint256 bondGroupID, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function exchangeEquivalentBonds(\r\n        uint256 inputBondGroupID,\r\n        uint256 outputBondGroupID,\r\n        uint256 amount,\r\n        bytes32[] calldata exceptionBonds\r\n    ) external returns (bool);\r\n\r\n    function liquidateBond(uint256 bondGroupID, uint256 oracleHintID) external;\r\n\r\n    function getBond(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (\r\n            address bondAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function getFnMap(bytes32 fnMapID)\r\n        external\r\n        view\r\n        returns (bytes memory fnMap);\r\n\r\n    function getBondGroup(uint256 bondGroupID)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs, uint256 maturity);\r\n\r\n    function generateBondID(uint256 maturity, bytes calldata functionHash)\r\n        external\r\n        pure\r\n        returns (bytes32 bondID);\r\n}\r\n\r\n\r\n// File: contracts/UseBondMaker.sol\r\n\r\nabstract contract UseBondMaker {\r\n    BondMakerInterface internal immutable _bondMakerContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _bondMakerContract = BondMakerInterface(payable(contractAddress));\r\n    }\r\n}\r\n\r\n\r\n// File: contracts/StableCoin.sol\r\n\r\ncontract FlattenStableCoin is\r\n    UseSafeMath,\r\n    StableCoinInterface,\r\n    Time,\r\n    ERC20(\"iDOL\", \"iDOL\"),\r\n    SolidBondSafety,\r\n    UseOracle,\r\n    UseBondMaker,\r\n    UseAuctionLater\r\n{\r\n    using Math for uint256;\r\n\r\n    /**\r\n     * @dev pool:mint = 1:9\r\n     */\r\n    uint256 internal constant LOCK_POOL_BORDER = 1;\r\n    uint256 internal constant MINT_IDOL_BORDER = 10 - LOCK_POOL_BORDER;\r\n    uint256 internal immutable AUCTION_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_SPAN;\r\n\r\n    /**\r\n     * @dev The contents of this internal storage variable can be seen by solidValueTotal function.\r\n     */\r\n    uint256 internal _solidValueTotalE12;\r\n\r\n    mapping(bytes32 => uint64) public auctionTriggerCount;\r\n\r\n    /**\r\n     * @dev Record the pooled IDOL for each person(= beta * minted amount).\r\n     * The pooled IDOL is going to be refunded partially to the person when the deposited SBT is\r\n     * sold in the auction.\r\n     */\r\n    struct LockedPool {\r\n        uint64 IDOLAmount;\r\n        uint64 baseSBTAmount;\r\n    }\r\n    mapping(address => mapping(bytes32 => LockedPool)) public lockedPoolE8;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by getPoolInfo function.\r\n     * @param lockedSolidBondTotalE8 is the current locked SBT amount.\r\n     * @param unlockedSolidBondTotalE8 is the SBT amount unlocked by unlockSBT().\r\n     * @param lockedPoolIDOLTotalE8 is the iDOL amount locked to the pool for the SBT.\r\n     * @param SBT2BurnedIDOLTotalE8 is the iDOL amount burned by unlockSBT() or setSettledAverageAuctionPrice().\r\n     */\r\n    struct AccountingTotalInfo {\r\n        uint64 lockedSolidBondTotalE8;\r\n        uint64 unlockedSolidBondTotalE8;\r\n        uint64 lockedPoolIDOLTotalE8;\r\n        uint64 SBT2BurnedIDOLTotalE8;\r\n    }\r\n    mapping(bytes32 => AccountingTotalInfo) internal _accountingTotalInfo;\r\n\r\n    /**\r\n     * @notice Record the average settlement price for each SBT bondID.\r\n     * @dev The average settlement price is used for calculating the amount to return partially from\r\n     * the pooled IDOL.\r\n     * The contents in this internal storage variable can be seen by getPoolInfo function.\r\n     * @param auctionSoldSolidBondTotal is the SBT total amount already sold in the auction.\r\n     * @param auctionPaidIDOLTotalE8 is the iDOL amount already paid for the SBT in the auction.\r\n     * @param settledAverageAuctionPrice is the average price for the SBT in the auction and unlockSBT().\r\n     * @param isAllAmountSoldInAuction indicates whether auctionSoldSolidBondTotal equals to the auction amount or not.\r\n     */\r\n    struct AuctionAmountInfo {\r\n        uint64 auctionSoldSolidBondTotal;\r\n        uint64 auctionPaidIDOLTotalE8;\r\n        uint64 settledAverageAuctionPrice;\r\n        bool isAllAmountSoldInAuction;\r\n    }\r\n    mapping(bytes32 => AuctionAmountInfo) internal _auctionAmountInfo;\r\n\r\n    constructor(\r\n        address oracleAddress,\r\n        address bondMakerAddress,\r\n        uint256 auctionSpan,\r\n        uint256 emergencyAuctionSpan\r\n    ) public UseOracle(oracleAddress) UseBondMaker(bondMakerAddress) {\r\n        _setupDecimals(8);\r\n        AUCTION_SPAN = auctionSpan;\r\n        EMERGENCY_AUCTION_SPAN = emergencyAuctionSpan;\r\n    }\r\n\r\n    function _reduceSBTValue(uint256 SBTValueE12) internal {\r\n        _solidValueTotalE12 = _solidValueTotalE12.sub(SBTValueE12);\r\n    }\r\n\r\n    /**\r\n     * @notice In order to calculate the amount to burn from the pooled IDOL, need to aggregate\r\n     * IDOLs both in the auction and in the unlockSBT function. Calculate settled-average-auction-\r\n     * price (every time an auction ends, the auction contract trigger this)\r\n     * @param bondID ID for auctioned SBT\r\n     * @param auctionPaidIDOL IDOL amount burned in this auction\r\n     * @param auctionSoldAmount SBT amount sold in this auction\r\n     * @param isLastTime True when the auction successfully sold all the SBT\r\n     */\r\n    function _setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 auctionPaidIDOL,\r\n        uint64 auctionSoldAmount,\r\n        bool isLastTime\r\n    ) internal {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        AuctionAmountInfo memory auctionInfo = _auctionAmountInfo[poolID];\r\n\r\n        auctionInfo.auctionSoldSolidBondTotal = auctionInfo\r\n            .auctionSoldSolidBondTotal\r\n            .add(auctionSoldAmount)\r\n            .toUint64();\r\n        auctionInfo.auctionPaidIDOLTotalE8 = auctionInfo\r\n            .auctionPaidIDOLTotalE8\r\n            .add(auctionPaidIDOL)\r\n            .toUint64();\r\n\r\n        if (isLastTime) {\r\n            // Calculate the amount of IDOL to burn\r\n\r\n\r\n                AccountingTotalInfo memory accountingInfo\r\n             = _accountingTotalInfo[poolID];\r\n            uint256 burnIDOLAmount = 0;\r\n\r\n            /**\r\n             * @dev In the case of beta=0.1, total distributed IDOL for the bondID\r\n             * can be calculated by the pooled IDOL amount for the bondID multiplied by 9\r\n             * (= MINT_IDOL_BORDER).\r\n             * In the case that someone has withdrawn SBT by unlockSBT(), the pooled IDOL is also\r\n             * circulated.\r\n             * When 3 SBT (strike = $100) are withdrawn by unlockSBT() and 8 SBT are sold in the\r\n             * auction, circulated = (3+8)*100*0.9 and everminted = (3+8)*100.\r\n             * Those 3 and 8 can be captured by looking at the amount of IDOL in the pool.\r\n             */\r\n            {\r\n                // (circulated amount) = (locked pool iDOL total) * MINT_IDOL_BORDER / LOCK_POOL_BORDER\r\n                //                     = (locked pool iDOL total) * MINT_IDOL_BORDER\r\n                uint256 circulated = accountingInfo.lockedPoolIDOLTotalE8.mul(\r\n                    MINT_IDOL_BORDER\r\n                );\r\n                uint256 everMinted = accountingInfo.lockedPoolIDOLTotalE8.add(\r\n                    circulated\r\n                );\r\n                uint256 allBurn = accountingInfo.SBT2BurnedIDOLTotalE8.add(\r\n                    auctionInfo.auctionPaidIDOLTotalE8\r\n                );\r\n                if (allBurn > circulated) {\r\n                    if (everMinted >= allBurn) {\r\n                        // burn all the IDOL issued for the SBT put up in the auction\r\n                        //SAME MEANING of: burnIDOLAmount = everMinted.sub(allBurn).add(auctionPaidIDOLTotalE8[bondID]);\r\n                        burnIDOLAmount = everMinted.sub(\r\n                            accountingInfo.SBT2BurnedIDOLTotalE8\r\n                        );\r\n                    } else {\r\n                        // burn all the IDOL issued for the SBT put up in the auction, and excess amount.\r\n                        //SAME MEANING of: burnIDOLAmount = allBurn.sub(allBurn).add(auctionPaidIDOLTotalE8[bondID]);\r\n                        burnIDOLAmount = allBurn.sub(\r\n                            accountingInfo.SBT2BurnedIDOLTotalE8\r\n                        );\r\n                    }\r\n                } else {\r\n                    // burn as much as we can.\r\n                    //In this case, burn rate(price) is lower than 1-beta\r\n                    burnIDOLAmount = accountingInfo.lockedPoolIDOLTotalE8.add(\r\n                        auctionInfo.auctionPaidIDOLTotalE8\r\n                    );\r\n                }\r\n            }\r\n\r\n            (, , uint64 solidBondStrikePriceUSD, ) = _bondMakerContract.getBond(\r\n                bondID\r\n            );\r\n\r\n            _burn(address(this), burnIDOLAmount);\r\n            accountingInfo.SBT2BurnedIDOLTotalE8 = accountingInfo\r\n                .SBT2BurnedIDOLTotalE8\r\n                .add(auctionInfo.auctionPaidIDOLTotalE8)\r\n                .toUint64();\r\n\r\n            _reduceSBTValue(\r\n                auctionInfo.auctionSoldSolidBondTotal.mul(\r\n                    solidBondStrikePriceUSD\r\n                )\r\n            );\r\n            accountingInfo.unlockedSolidBondTotalE8 = accountingInfo\r\n                .unlockedSolidBondTotalE8\r\n                .add(auctionInfo.auctionSoldSolidBondTotal)\r\n                .toUint64();\r\n\r\n            auctionInfo.settledAverageAuctionPrice = accountingInfo\r\n                .SBT2BurnedIDOLTotalE8\r\n                .mul(10**8)\r\n                .div(\r\n                accountingInfo\r\n                    .unlockedSolidBondTotalE8,\r\n                \"system: the total unlock amount should be non-zero value\"\r\n            )\r\n                .toUint64();\r\n\r\n            auctionInfo.isAllAmountSoldInAuction = true;\r\n            auctionTriggerCount[bondID] = auctionTriggerCount[bondID]\r\n                .add(1)\r\n                .toUint64();\r\n\r\n            _accountingTotalInfo[poolID] = accountingInfo;\r\n        }\r\n        _auctionAmountInfo[poolID] = auctionInfo;\r\n    }\r\n\r\n    /**\r\n     * @param poolID is a pool ID.\r\n     * @return lockedSBTTotal is the current locked SBT amount. (e8)\r\n     * @return unlockedSBTTotal is the SBT amount unlocked with unlockSBT(). (e8)\r\n     * @return lockedPoolIDOLTotal is the iDOL amount locked to the pool when this was minted. (e8)\r\n     * @return burnedIDOLTotal is the iDOL amount burned with unlockSBT() and setSettledAverageAuctionPrice(). (e8)\r\n     * @return soldSBTTotalInAuction is the SBT total amount already sold in the auction. (e8)\r\n     * @return paidIDOLTotalInAuction is the iDOL amount already paid for SBT in the auction. (e8)\r\n     * @return settledAverageAuctionPrice is the average price with iDOL of the SBT in the auction and unlockSBT(). (e8)\r\n     * @return isAllAmountSoldInAuction is whether auctionSoldSolidBondTotal is equal to the auction amount or not.\r\n     */\r\n    function getPoolInfo(bytes32 poolID)\r\n        external\r\n        override\r\n        view\r\n        returns (\r\n            uint64 lockedSBTTotal,\r\n            uint64 unlockedSBTTotal,\r\n            uint64 lockedPoolIDOLTotal,\r\n            uint64 burnedIDOLTotal,\r\n            uint64 soldSBTTotalInAuction,\r\n            uint64 paidIDOLTotalInAuction,\r\n            uint64 settledAverageAuctionPrice,\r\n            bool isAllAmountSoldInAuction\r\n        )\r\n    {\r\n\r\n            AccountingTotalInfo memory accountingInfo\r\n         = _accountingTotalInfo[poolID];\r\n        lockedSBTTotal = accountingInfo.lockedSolidBondTotalE8;\r\n        unlockedSBTTotal = accountingInfo.unlockedSolidBondTotalE8;\r\n        lockedPoolIDOLTotal = accountingInfo.lockedPoolIDOLTotalE8;\r\n        burnedIDOLTotal = accountingInfo.SBT2BurnedIDOLTotalE8;\r\n\r\n\r\n            AuctionAmountInfo memory auctionSettlementInfo\r\n         = _auctionAmountInfo[poolID];\r\n        soldSBTTotalInAuction = auctionSettlementInfo.auctionSoldSolidBondTotal;\r\n        paidIDOLTotalInAuction = auctionSettlementInfo.auctionPaidIDOLTotalE8;\r\n        settledAverageAuctionPrice = auctionSettlementInfo\r\n            .settledAverageAuctionPrice;\r\n        isAllAmountSoldInAuction = auctionSettlementInfo\r\n            .isAllAmountSoldInAuction;\r\n    }\r\n\r\n    function solidValueTotal() external override view returns (uint256) {\r\n        return _solidValueTotalE12;\r\n    }\r\n\r\n    function generatePoolID(bytes32 bondID, uint64 count)\r\n        public\r\n        override\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(bondID, count, \"lien\"));\r\n    }\r\n\r\n    function getCurrentPoolID(bytes32 bondID)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint64 currentTriggeredCount = auctionTriggerCount[bondID];\r\n        return generatePoolID(bondID, currentTriggeredCount);\r\n    }\r\n\r\n    function getLockedPool(address user, bytes32 poolID)\r\n        public\r\n        override\r\n        view\r\n        returns (uint64, uint64)\r\n    {\r\n        return (\r\n            lockedPoolE8[user][poolID].IDOLAmount,\r\n            lockedPoolE8[user][poolID].baseSBTAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev poolID is counted up and used when the SBT once released from IDOL in the emergency\r\n     * auction becomes qualified again before its maturity.\r\n     */\r\n\r\n    /**\r\n     * @dev Check if the SBT is qualified in terms of the length of the time until maturity,\r\n     * the volatility, and the distance between the current price and the strike price.\r\n     */\r\n    function isAcceptableSBT(bytes32 bondID)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        (, uint256 maturity, uint64 solidStrikePriceE4, ) = _bondMakerContract\r\n            .getBond(bondID);\r\n        require(\r\n            solidStrikePriceE4 != 0,\r\n            \"the bond does not match to the form of SBT\"\r\n        );\r\n        require(\r\n            maturity > _getBlockTimestampSec() + AUCTION_SPAN,\r\n            \"a request to hold an auction of the bond has already expired\"\r\n        );\r\n        require(\r\n            solidStrikePriceE4 % (10**5) == 0,\r\n            \"the strike price need to be $ 10*X\"\r\n        );\r\n\r\n        bytes32 auctionID = _auctionContract.getCurrentAuctionID(bondID);\r\n        require(\r\n            _auctionContract.ongoingAuctionSBTTotal(auctionID) == 0,\r\n            \"this SBT is on a auciton\"\r\n        );\r\n\r\n        (uint256 rateETH2USDE8, uint256 volatilityE8) = _getOracleData();\r\n        bool isDanger = isDangerSolidBond(\r\n            rateETH2USDE8,\r\n            solidStrikePriceE4,\r\n            volatilityE8,\r\n            maturity - _getBlockTimestampSec()\r\n        );\r\n\r\n        emit LogIsAcceptableSBT(bondID, !isDanger);\r\n\r\n        return !isDanger;\r\n    }\r\n\r\n    /**\r\n     * @notice Lock SBT and mint IDOL\r\n     * @param bondID the ID for the SBT locked for minting IDOL\r\n     * @param lockAmountE8 the amount of locked SBT\r\n     */\r\n    function mint(\r\n        bytes32 bondID,\r\n        address recipient,\r\n        uint64 lockAmountE8\r\n    )\r\n        public\r\n        override\r\n        returns (\r\n            bytes32 poolID,\r\n            uint64 obtainIDOLAmountE8,\r\n            uint64 poolIDOLAmountE8\r\n        )\r\n    {\r\n        poolID = getCurrentPoolID(bondID);\r\n\r\n        // Check if the maturity is sufficiently distant from the current time.\r\n        (\r\n            address bondTokenAddress,\r\n            ,\r\n            uint256 solidStrikePriceE4,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(\r\n            isAcceptableSBT(bondID),\r\n            \"SBT with the bondID is not currently acceptable\"\r\n        );\r\n\r\n\r\n            AccountingTotalInfo memory accountingInfo\r\n         = _accountingTotalInfo[poolID];\r\n\r\n        // Calculate the mint amount based on the dilution ratio.\r\n        uint256 solidBondValueE12 = lockAmountE8.mul(solidStrikePriceE4);\r\n        uint256 mintAmountE8 = calcSBT2IDOL(solidBondValueE12);\r\n\r\n        ERC20 bondTokenContract = ERC20(bondTokenAddress);\r\n        bondTokenContract.transferFrom(msg.sender, address(this), lockAmountE8);\r\n\r\n        // (pooling amount) = mintAmountE8 * LOCK_POOL_BORDER / 10 = mintAmountE8 / 10\r\n        uint256 poolAmount = mintAmountE8.div(10);\r\n        LockedPool storage lockedPoolInfo = lockedPoolE8[recipient][poolID];\r\n        lockedPoolInfo.IDOLAmount = lockedPoolInfo\r\n            .IDOLAmount\r\n            .add(poolAmount)\r\n            .toUint64();\r\n        lockedPoolInfo.baseSBTAmount = lockedPoolInfo\r\n            .baseSBTAmount\r\n            .add(lockAmountE8)\r\n            .toUint64();\r\n\r\n        _mint(recipient, mintAmountE8.sub(poolAmount));\r\n        _mint(address(this), poolAmount);\r\n        _solidValueTotalE12 = _solidValueTotalE12.add(solidBondValueE12);\r\n        accountingInfo.lockedSolidBondTotalE8 = accountingInfo\r\n            .lockedSolidBondTotalE8\r\n            .add(lockAmountE8)\r\n            .toUint64();\r\n        accountingInfo.lockedPoolIDOLTotalE8 = accountingInfo\r\n            .lockedPoolIDOLTotalE8\r\n            .add(poolAmount)\r\n            .toUint64();\r\n        _accountingTotalInfo[poolID] = accountingInfo;\r\n\r\n        uint256 obtainAmount = mintAmountE8.sub(poolAmount);\r\n        emit LogMintIDOL(bondID, recipient, poolID, obtainAmount, poolAmount);\r\n        return (poolID, obtainAmount.toUint64(), poolAmount.toUint64());\r\n    }\r\n\r\n    /**\r\n     * @dev Only the auction contract address can burn some specified amount of the IDOL held by\r\n     * an account.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public override {\r\n        require(\r\n            msg.sender == address(_auctionContract),\r\n            \"msg.sender must be auction contract\"\r\n        );\r\n        _burn(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice This function provides the opportunity to redeem any type of SBT with a correct\r\n     * amount by burning iDOL. iDOL is pegged to totalLockedValue/totalSupply dollar\r\n     * (initially 1 dollar), so we can always allow anyone to redeem at most 1 dollar worth SBT\r\n     * by burning 1 dollar worth iDOL.\r\n     * This is based on the mathematical fact that the theoretical value of 1 unit SBT with\r\n     * strike price 100 dollar is always strictly less than 100 dollar (e.g. 99.99 dollar).\r\n     * @dev IDOL contract needs to know the value of iDOL per unit by calculating\r\n     * totalLockedValue/totalSupply the value of iDOL per unit may change when the auction\r\n     * settlement price is not within the certain price range.\r\n     * rewardSBT = burnAmountE8/solidStrikePriceE4 * totalSupply/totalLockedValue\r\n     * @param bondID is the bond to unlock\r\n     * @param burnAmountE8 is the iDOL amount to burn\r\n     */\r\n    function unlockSBT(bytes32 bondID, uint64 burnAmountE8)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        (\r\n            address bondTokenAddress,\r\n            ,\r\n            uint256 solidStrikePriceE4,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(solidStrikePriceE4 != 0, \"the bond is not the form of SBT\");\r\n\r\n\r\n            AccountingTotalInfo memory accountingInfo\r\n         = _accountingTotalInfo[poolID];\r\n\r\n        uint64 rewardSBTE8 = burnAmountE8\r\n            .mul(_solidValueTotalE12)\r\n            .div(totalSupply(), \"system error: totalSupply never becomes zero\")\r\n            .div(\r\n            solidStrikePriceE4,\r\n            \"system error: solidStrikePrice never becomes zero [unlockSBT]\"\r\n        )\r\n            .toUint64();\r\n\r\n        // Burn iDOL.\r\n        accountingInfo.SBT2BurnedIDOLTotalE8 = accountingInfo\r\n            .SBT2BurnedIDOLTotalE8\r\n            .add(burnAmountE8)\r\n            .toUint64();\r\n\r\n        _burn(msg.sender, burnAmountE8);\r\n\r\n        // Return SBT.\r\n        BondTokenInterface bondTokenContract = BondTokenInterface(\r\n            payable(bondTokenAddress)\r\n        );\r\n        bondTokenContract.transfer(msg.sender, rewardSBTE8);\r\n\r\n        emit LogBurnIDOL(bondID, msg.sender, burnAmountE8, rewardSBTE8);\r\n\r\n        // Update solidValueTotal, lockedSolidBondTotalE18 and unlockedSolidBondTotal.\r\n        _solidValueTotalE12 = _solidValueTotalE12.sub(\r\n            rewardSBTE8.mul(solidStrikePriceE4)\r\n        );\r\n        accountingInfo.lockedSolidBondTotalE8 = accountingInfo\r\n            .lockedSolidBondTotalE8\r\n            .sub(rewardSBTE8)\r\n            .toUint64();\r\n        accountingInfo.unlockedSolidBondTotalE8 = accountingInfo\r\n            .unlockedSolidBondTotalE8\r\n            .add(rewardSBTE8)\r\n            .toUint64();\r\n\r\n        _accountingTotalInfo[poolID] = accountingInfo;\r\n\r\n        return rewardSBTE8;\r\n    }\r\n\r\n    /**\r\n     * @notice Starts regular auction for SBT with short maturity.\r\n     */\r\n    function startAuctionOnMaturity(bytes32 bondID) public override {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        (address bondTokenAddress, uint256 maturity, , ) = _bondMakerContract\r\n            .getBond(bondID);\r\n        require(\r\n            maturity <= _getBlockTimestampSec() + AUCTION_SPAN,\r\n            \"maturity is later than the regular auctionSpan\"\r\n        );\r\n\r\n        uint64 lockedSolidBondTotalE8;\r\n        {\r\n\r\n                AccountingTotalInfo memory accountingInfo\r\n             = _accountingTotalInfo[poolID];\r\n            lockedSolidBondTotalE8 = accountingInfo.lockedSolidBondTotalE8;\r\n            if (lockedSolidBondTotalE8 == 0) {\r\n                if (accountingInfo.lockedPoolIDOLTotalE8 != 0) {\r\n                    _setSettledAverageAuctionPrice(bondID, 0, 0, true);\r\n                }\r\n                return;\r\n            }\r\n            delete _accountingTotalInfo[poolID].lockedSolidBondTotalE8;\r\n        }\r\n\r\n        if (maturity <= _getBlockTimestampSec() + EMERGENCY_AUCTION_SPAN) {\r\n            _auctionContract.startAuction(bondID, lockedSolidBondTotalE8, true);\r\n        } else {\r\n            _auctionContract.startAuction(\r\n                bondID,\r\n                lockedSolidBondTotalE8,\r\n                false\r\n            );\r\n        }\r\n\r\n        // Send SBT to the auction contract.\r\n        BondTokenInterface bondTokenContract = BondTokenInterface(\r\n            payable(bondTokenAddress)\r\n        );\r\n        bondTokenContract.transfer(\r\n            address(_auctionContract),\r\n            lockedSolidBondTotalE8\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Starts emergency auction\r\n     * @dev Check if the SBT needs to trigger the emergency auction based on the length of the\r\n     * time until maturity, the volatility, and the distance between the current price and the\r\n     * strike price.\r\n     */\r\n    function startAuctionByMarket(bytes32 bondID) public override {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        (\r\n            address bondTokenAddress,\r\n            uint256 maturity,\r\n            uint64 solidBondStrikePriceUSD,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(\r\n            solidBondStrikePriceUSD != 0,\r\n            \"the bond is not the form of SBT\"\r\n        );\r\n\r\n        (uint256 rateETH2USD, uint256 volatility) = _getOracleData();\r\n        bool isDanger = isInEmergency(\r\n            rateETH2USD,\r\n            solidBondStrikePriceUSD,\r\n            volatility,\r\n            maturity - _getBlockTimestampSec()\r\n        );\r\n        require(isDanger, \"the SBT is not in emergency\");\r\n\r\n        uint64 lockedSolidBondTotalE8;\r\n        {\r\n\r\n                AccountingTotalInfo memory accountingInfo\r\n             = _accountingTotalInfo[poolID];\r\n            lockedSolidBondTotalE8 = accountingInfo.lockedSolidBondTotalE8;\r\n            if (lockedSolidBondTotalE8 == 0) {\r\n                if (accountingInfo.lockedPoolIDOLTotalE8 != 0) {\r\n                    _setSettledAverageAuctionPrice(bondID, 0, 0, true);\r\n                }\r\n                return;\r\n            }\r\n            delete _accountingTotalInfo[poolID].lockedSolidBondTotalE8;\r\n        }\r\n\r\n        _auctionContract.startAuction(bondID, lockedSolidBondTotalE8, true);\r\n\r\n        // Send SBT to the auction contract.\r\n        BondTokenInterface bondTokenContract = BondTokenInterface(\r\n            payable(bondTokenAddress)\r\n        );\r\n        bondTokenContract.transfer(\r\n            address(_auctionContract),\r\n            lockedSolidBondTotalE8\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sets SettledAverageAuctionPrice and burns a portion of pooled IDOL.\r\n     * @dev Only callable from the auction contract.\r\n     */\r\n    function setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 totalPaidIDOL,\r\n        uint64 SBTAmount,\r\n        bool isLast\r\n    ) public override {\r\n        require(\r\n            msg.sender == address(_auctionContract),\r\n            \"msg.sender must be auction contract\"\r\n        );\r\n\r\n        (, , uint256 solidStrikePrice, ) = _bondMakerContract.getBond(bondID);\r\n        require(solidStrikePrice != 0, \"the bond is not the form of SBT\");\r\n        _setSettledAverageAuctionPrice(\r\n            bondID,\r\n            totalPaidIDOL,\r\n            SBTAmount,\r\n            isLast\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the IDOL amount equivalent to the strike price value of SBT.\r\n     * @param solidBondValueE12 solidBondValueE12(USD) = SBT(SBT) * strikePrice(USD/SBT)\r\n     */\r\n    function calcSBT2IDOL(uint256 solidBondValueE12)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256 IDOLAmountE8)\r\n    {\r\n        if (_solidValueTotalE12 == 0) {\r\n            return solidBondValueE12.div(10**4);\r\n        }\r\n\r\n        return solidBondValueE12.mul(totalSupply()).div(_solidValueTotalE12);\r\n    }\r\n\r\n    function _calcUnlockablePoolAmount(bytes32 poolID)\r\n        internal\r\n        returns (uint64)\r\n    {\r\n        AuctionAmountInfo memory auctionInfo = _auctionAmountInfo[poolID];\r\n        if (!auctionInfo.isAllAmountSoldInAuction) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 pool = lockedPoolE8[msg.sender][poolID].IDOLAmount;\r\n        uint256 amountE8 = lockedPoolE8[msg.sender][poolID].baseSBTAmount;\r\n        delete lockedPoolE8[msg.sender][poolID];\r\n\r\n        uint256 auctionIDOLPriceE8 = auctionInfo.settledAverageAuctionPrice;\r\n        uint256 toBack = 0;\r\n\r\n        // The return value can be calculated by\r\n        // (average sold price) * (total sold amount) - (total distributed amount) for the bondID.\r\n        // Here, (total distributed amount) = pool * MINT_IDOL_BORDER / LOCK_POOL_BORDER = pool * MINT_IDOL_BORDER\r\n        if (\r\n            auctionIDOLPriceE8.mul(amountE8).div(10**8) >\r\n            pool.mul(MINT_IDOL_BORDER)\r\n        ) {\r\n            toBack =\r\n                auctionIDOLPriceE8.mul(amountE8).div(10**8) -\r\n                pool.mul(MINT_IDOL_BORDER);\r\n        }\r\n\r\n        return toBack.min(pool).toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice Receives all the redeemable IDOL in one action.\r\n     * @dev Receive corresponding pooled IDOL based on the SettledAverageAuctionPrice.\r\n     */\r\n    function returnLockedPool(bytes32[] memory poolIDs)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        uint256 totalBackIDOLAmount = 0;\r\n        for (uint256 i = 0; i < poolIDs.length; i++) {\r\n            // For each bondID, the return amount should not exceed the pooled amount.\r\n            uint64 backIDOLAmount = _calcUnlockablePoolAmount(poolIDs[i]);\r\n            totalBackIDOLAmount = totalBackIDOLAmount.add(backIDOLAmount);\r\n            emit LogReturnLockedPool(poolIDs[i], msg.sender, backIDOLAmount);\r\n        }\r\n\r\n        this.transfer(msg.sender, totalBackIDOLAmount);\r\n\r\n        return totalBackIDOLAmount.toUint64();\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bondMakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyAuctionSpan\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnIDOLAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockSBTAmount\",\"type\":\"uint256\"}],\"name\":\"LogBurnIDOL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAcceptable\",\"type\":\"bool\"}],\"name\":\"LogIsAcceptableSBT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"obtainIDOLAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolIDOLAmount\",\"type\":\"uint256\"}],\"name\":\"LogMintIDOL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"backIDOLAmount\",\"type\":\"uint64\"}],\"name\":\"LogReturnLockedPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionTriggerCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"solidBondValueE12\",\"type\":\"uint256\"}],\"name\":\"calcSBT2IDOL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"IDOLAmountE8\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"}],\"name\":\"generatePoolID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"getCurrentPoolID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xxE8\",\"type\":\"uint256\"}],\"name\":\"getEmergencyBorderInfo\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"aaE4\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"bE4\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"}],\"name\":\"getLockedPool\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"lockedSBTTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"unlockedSBTTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockedPoolIDOLTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"burnedIDOLTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"soldSBTTotalInAuction\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"paidIDOLTotalInAuction\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"settledAverageAuctionPrice\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isAllAmountSoldInAuction\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"isAcceptableSBT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rateETH2USD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"solidBondStrikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"untilMaturity\",\"type\":\"uint256\"}],\"name\":\"isDangerSolidBond\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rateETH2USD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"solidBondStrikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"untilMaturity\",\"type\":\"uint256\"}],\"name\":\"isInEmergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lockedPoolE8\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"IDOLAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"baseSBTAmount\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"lockAmountE8\",\"type\":\"uint64\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"obtainIDOLAmountE8\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"poolIDOLAmountE8\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"poolIDs\",\"type\":\"bytes32[]\"}],\"name\":\"returnLockedPool\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setAuctionContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"totalPaidIDOL\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"SBTAmount\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isLast\",\"type\":\"bool\"}],\"name\":\"setSettledAverageAuctionPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solidValueTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"startAuctionByMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"startAuctionOnMaturity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"burnAmountE8\",\"type\":\"uint64\"}],\"name\":\"unlockSBT\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FlattenStableCoin","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000120a078fdc516a1a98bbecb9e961f8741ac7ac82000000000000000000000000acDC94b9f187fA7ee3C5cf0969c2fAcCaB4E37A3000000000000000000000000000000000000000000000000000000000003f4800000000000000000000000000000000000000000000000000000000000015f90","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ec31e73691d5223cd49ce0de66f4abd57af73830d3eba761318d911fb47bb1dc"}]}