{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.5\r\n\"\"\"\r\n@title \"Zap\" Depositer for Curve GUSD pool\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020 - all rights reserved\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface CurveMeta:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\r\n    def base_pool() -> address: view\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface CurveBase:\r\n    def add_liquidity(amounts: uint256[BASE_N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[BASE_N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[BASE_N_COINS], deposit: bool) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n\r\n\r\nN_COINS: constant(int128) = 2\r\nMAX_COIN: constant(int128) = N_COINS-1\r\nBASE_N_COINS: constant(int128) = 3\r\nN_ALL_COINS: constant(int128) = N_COINS + BASE_N_COINS - 1\r\n\r\n# An asset shich may have a transfer fee (USDT)\r\nFEE_ASSET: constant(address) = 0xdAC17F958D2ee523a2206206994597C13D831ec7\r\n\r\n\r\npool: public(address)\r\ntoken: public(address)\r\nbase_pool: public(address)\r\n\r\ncoins: public(address[N_COINS])\r\nbase_coins: public(address[BASE_N_COINS])\r\n\r\n\r\n@external\r\ndef __init__(_pool: address, _token: address):\r\n    self.pool = _pool\r\n    self.token = _token\r\n    _base_pool: address = CurveMeta(_pool).base_pool()\r\n    self.base_pool = _base_pool\r\n\r\n    for i in range(N_COINS):\r\n        coin: address = CurveMeta(_pool).coins(convert(i, uint256))\r\n        self.coins[i] = coin\r\n        # approve coins for infinite transfers\r\n        _response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_pool, bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)\r\n\r\n    for i in range(BASE_N_COINS):\r\n        coin: address = CurveBase(_base_pool).coins(convert(i, uint256))\r\n        self.base_coins[i] = coin\r\n        # approve underlying coins for infinite transfers\r\n        _response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_base_pool, bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(amounts: uint256[N_ALL_COINS], min_mint_amount: uint256) -> uint256:\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    deposit_base: bool = False\r\n\r\n    # Transfer all coins in\r\n    for i in range(N_ALL_COINS):\r\n        amount: uint256 = amounts[i]\r\n        if amount == 0:\r\n            continue\r\n        coin: address = ZERO_ADDRESS\r\n        if i < MAX_COIN:\r\n            coin = self.coins[i]\r\n            meta_amounts[i] = amount\r\n        else:\r\n            x: int128 = i - MAX_COIN\r\n            coin = self.base_coins[x]\r\n            base_amounts[x] = amount\r\n            deposit_base = True\r\n        # \"safeTransferFrom\" which works for ERC20s which return bool or not\r\n        _response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(msg.sender, bytes32),\r\n                convert(self, bytes32),\r\n                convert(amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )  # dev: failed transfer\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)  # dev: failed transfer\r\n        # end \"safeTransferFrom\"\r\n        # Handle potential Tether fees\r\n        if coin == FEE_ASSET:\r\n            amount = ERC20(FEE_ASSET).balanceOf(self)\r\n            if i < MAX_COIN:\r\n                meta_amounts[i] = amount\r\n            else:\r\n                base_amounts[i - MAX_COIN] = amount\r\n\r\n    # Deposit to the base pool\r\n    if deposit_base:\r\n        CurveBase(self.base_pool).add_liquidity(base_amounts, 0)\r\n        meta_amounts[MAX_COIN] = ERC20(self.coins[MAX_COIN]).balanceOf(self)\r\n\r\n    # Deposit to the meta pool\r\n    CurveMeta(self.pool).add_liquidity(meta_amounts, min_mint_amount)\r\n\r\n    # Transfer meta token back\r\n    _lp_token: address = self.token\r\n    _lp_amount: uint256 = ERC20(_lp_token).balanceOf(self)\r\n    assert ERC20(_lp_token).transfer(msg.sender, _lp_amount)\r\n\r\n    return _lp_amount\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_ALL_COINS]) -> uint256[N_ALL_COINS]:\r\n    _token: address = self.token\r\n    assert ERC20(_token).transferFrom(msg.sender, self, _amount)\r\n\r\n    min_amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    min_amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts: uint256[N_ALL_COINS] = empty(uint256[N_ALL_COINS])\r\n\r\n    # Withdraw from meta\r\n    for i in range(MAX_COIN):\r\n        min_amounts_meta[i] = min_amounts[i]\r\n    CurveMeta(self.pool).remove_liquidity(_amount, min_amounts_meta)\r\n\r\n    # Withdraw from base\r\n    _base_amount: uint256 = ERC20(self.coins[1]).balanceOf(self)\r\n    for i in range(BASE_N_COINS):\r\n        min_amounts_base[i] = min_amounts[MAX_COIN+i]\r\n    CurveBase(self.base_pool).remove_liquidity(_base_amount, min_amounts_base)\r\n\r\n    # Transfer all coins out\r\n    for i in range(N_ALL_COINS):\r\n        coin: address = ZERO_ADDRESS\r\n        if i < MAX_COIN:\r\n            coin = self.coins[i]\r\n        else:\r\n            coin = self.base_coins[i - MAX_COIN]\r\n        amounts[i] = ERC20(coin).balanceOf(self)\r\n        # \"safeTransfer\" which works for ERC20s which return bool or not\r\n        _response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(msg.sender, bytes32),\r\n                convert(amounts[i], bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )  # dev: failed transfer\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)  # dev: failed transfer\r\n        # end \"safeTransfer\"\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256) -> uint256:\r\n    _token: address = self.token\r\n    assert ERC20(_token).transferFrom(msg.sender, self, _token_amount)\r\n\r\n    coin: address = ZERO_ADDRESS\r\n    if i < MAX_COIN:\r\n        coin = self.coins[i]\r\n        # Withdraw a metapool coin\r\n        CurveMeta(self.pool).remove_liquidity_one_coin(_token_amount, i, min_amount)\r\n    else:\r\n        coin = self.base_coins[i - MAX_COIN]\r\n        # Withdraw a base pool coin\r\n        CurveMeta(self.pool).remove_liquidity_one_coin(_token_amount, MAX_COIN, 0)\r\n        CurveBase(self.base_pool).remove_liquidity_one_coin(\r\n            ERC20(self.coins[MAX_COIN]).balanceOf(self), i-MAX_COIN, min_amount\r\n        )\r\n\r\n    # Tranfer the coin out\r\n    coin_amount: uint256 = ERC20(coin).balanceOf(self)\r\n    # \"safeTransfer\" which works for ERC20s which return bool or not\r\n    _response: Bytes[32] = raw_call(\r\n        coin,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(msg.sender, bytes32),\r\n            convert(coin_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )  # dev: failed transfer\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool)  # dev: failed transfer\r\n    # end \"safeTransfer\"\r\n\r\n    return coin_amount\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256:\r\n    if i < MAX_COIN:\r\n        return CurveMeta(self.pool).calc_withdraw_one_coin(_token_amount, i)\r\n    else:\r\n        _base_tokens: uint256 = CurveMeta(self.pool).calc_withdraw_one_coin(_token_amount, MAX_COIN)\r\n        return CurveBase(self.base_pool).calc_withdraw_one_coin(_base_tokens, i-MAX_COIN)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(amounts: uint256[N_ALL_COINS], deposit: bool) -> uint256:\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n\r\n    for i in range(MAX_COIN):\r\n        meta_amounts[i] = amounts[i]\r\n\r\n    for i in range(BASE_N_COINS):\r\n        base_amounts[i] = amounts[i + MAX_COIN]\r\n\r\n    _base_tokens: uint256 = CurveBase(self.base_pool).calc_token_amount(base_amounts, deposit)\r\n    meta_amounts[MAX_COIN] = _base_tokens\r\n\r\n    return CurveMeta(self.pool).calc_token_amount(meta_amounts, deposit)","ABI":"[{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_token\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"add_liquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256[4]\",\"name\":\"amounts\"},{\"type\":\"uint256\",\"name\":\"min_mint_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":111014},{\"name\":\"remove_liquidity\",\"outputs\":[{\"type\":\"uint256[4]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256[4]\",\"name\":\"min_amounts\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":109938},{\"name\":\"remove_liquidity_one_coin\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_amount\"},{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"uint256\",\"name\":\"min_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":91715},{\"name\":\"calc_withdraw_one_coin\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_token_amount\"},{\"type\":\"int128\",\"name\":\"i\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2972},{\"name\":\"calc_token_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256[4]\",\"name\":\"amounts\"},{\"type\":\"bool\",\"name\":\"deposit\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":4295},{\"name\":\"pool\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1211},{\"name\":\"token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1241},{\"name\":\"base_pool\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1271},{\"name\":\"coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1410},{\"name\":\"base_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1440}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.5","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000007f90122bf0700f9e7e1f688fe926940e8839f3530000000000000000000000001337bedc9d22ecbe766df105c9623922a27963ec","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}