{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Crypto stamp 2 Pre-sale\r\n * On-chain reservation token (ERC 1155) to be redeemed later for\r\n * actual digital-physical collectible postage stamps\r\n *\r\n * Developed by Capacity Blockchain Solutions GmbH <capacity.at>\r\n * for Ã–sterreichische Post AG <post.at>\r\n */\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/OZ_ERC1155/IERC1155.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n    @title ERC-1155 Multi Token Standard basic interface\r\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\r\n */\r\nabstract contract IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256);\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view virtual returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external virtual;\r\n\r\n    function isApprovedForAll(address account, address operator) external view virtual returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external virtual;\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external virtual;\r\n}\r\n\r\n// File: contracts/OZ_ERC1155/IERC1155Receiver.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n    @title ERC-1155 Multi Token Receiver Interface\r\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\r\n*/\r\ninterface IERC1155Receiver is IERC165 {\r\n\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/OZ_ERC1155/ERC1155.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC1155 token\r\n *\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n */\r\ncontract ERC1155 is ERC165, IERC1155\r\n{\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping (uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Mapping token ID to that token being registered as existing\r\n    mapping (uint256 => bool) private _tokenExists;\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\r\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\r\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\r\n     *\r\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\r\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\r\n\r\n    constructor() public {\r\n        // register the supported interfaces to conform to ERC1155 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC1155);\r\n    }\r\n\r\n    /**\r\n        @dev Get the specified address' balance for token with specified ID.\r\n\r\n        Attempting to query the zero account for a balance will result in a revert.\r\n\r\n        @param account The address of the token holder\r\n        @param id ID of the token\r\n        @return The account's balance of the token type requested\r\n     */\r\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        require(_exists(id), \"ERC1155: balance query for nonexistent token\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n        @dev Get the balance of multiple account/token pairs.\r\n\r\n        If any of the query accounts is the zero account, this query will revert.\r\n\r\n        @param accounts The addresses of the token holders\r\n        @param ids IDs of the tokens\r\n        @return Balances for each account and token id pair\r\n     */\r\n    function balanceOfBatch(\r\n        address[] memory accounts,\r\n        uint256[] memory ids\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and IDs must have same lengths\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            require(accounts[i] != address(0), \"ERC1155: some address in batch balance query is zero\");\r\n            require(_exists(ids[i]), \"ERC1155: some token in batch balance query does not exist\");\r\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator.\r\n     *\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n     *\r\n     * Because an account already has operator privileges for itself, this function will revert\r\n     * if the account attempts to set the approval status for itself.\r\n     *\r\n     * @param operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external override virtual {\r\n        require(msg.sender != operator, \"ERC1155: cannot set approval status for self\");\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given account.\r\n        @param account   The account of the Tokens\r\n        @param operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n        @dev Transfers `value` amount of an `id` from the `from` address to the `to` address specified.\r\n        Caller must be approved to manage the tokens being transferred out of the `from` account.\r\n        If `to` is a smart contract, will call `onERC1155Received` on `to` and act appropriately.\r\n        @param from Source address\r\n        @param to Target address\r\n        @param id ID of the token type\r\n        @param value Transfer amount\r\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\r\n    */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        override\r\n        virtual\r\n    {\r\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\r\n        require(\r\n            from == msg.sender || isApprovedForAll(from, msg.sender) == true,\r\n            \"ERC1155: need operator approval for 3rd party transfers\"\r\n        );\r\n\r\n        _balances[id][from] = _balances[id][from].sub(value, \"ERC1155: insufficient balance for transfer\");\r\n        _balances[id][to] = _balances[id][to].add(value);\r\n\r\n        emit TransferSingle(msg.sender, from, to, id, value);\r\n\r\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\r\n    }\r\n\r\n    /**\r\n        @dev Transfers `values` amount(s) of `ids` from the `from` address to the\r\n        `to` address specified. Caller must be approved to manage the tokens being\r\n        transferred out of the `from` account. If `to` is a smart contract, will\r\n        call `onERC1155BatchReceived` on `to` and act appropriately.\r\n        @param from Source address\r\n        @param to Target address\r\n        @param ids IDs of each token type\r\n        @param values Transfer amounts per token type\r\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\r\n    */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        override\r\n        virtual\r\n    {\r\n        require(ids.length == values.length, \"ERC1155: IDs and values must have same lengths\");\r\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\r\n        require(\r\n            from == msg.sender || isApprovedForAll(from, msg.sender) == true,\r\n            \"ERC1155: need operator approval for 3rd party transfers\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 value = values[i];\r\n\r\n            _balances[id][from] = _balances[id][from].sub(\r\n                value,\r\n                \"ERC1155: insufficient balance of some token type for transfer\"\r\n            );\r\n            _balances[id][to] = _balances[id][to].add(value);\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, to, ids, values);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, ids, values, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Register a token ID so other contract functionality knows this token\r\n     * actually exists and this ID is valid. Minting will automatically call this.\r\n     * @param id uint256 ID of the token to register\r\n     */\r\n    function _registerToken(uint256 id) internal virtual {\r\n        _tokenExists[id] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists. Use {_registerTokenID} to set this flag.\r\n     * @param id uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 id) internal view returns (bool) {\r\n        return _tokenExists[id];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint an amount of a token with the given ID\r\n     * @param to The address that will own the minted token\r\n     * @param id ID of the token to be minted\r\n     * @param value Amount of the token to be minted\r\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\r\n     */\r\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        if (!_exists(id)) {\r\n            _registerToken(id);\r\n        }\r\n        _balances[id][to] = _balances[id][to].add(value);\r\n        emit TransferSingle(msg.sender, address(0), to, id, value);\r\n\r\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, value, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to batch mint amounts of tokens with the given IDs\r\n     * @param to The address that will own the minted token\r\n     * @param ids IDs of the tokens to be minted\r\n     * @param values Amounts of the tokens to be minted\r\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\r\n     */\r\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal virtual {\r\n        require(to != address(0), \"ERC1155: batch mint to the zero address\");\r\n        require(ids.length == values.length, \"ERC1155: minted IDs and values must have same lengths\");\r\n\r\n        for(uint i = 0; i < ids.length; i++) {\r\n            if (!_exists(ids[i])) {\r\n                _registerToken(ids[i]);\r\n            }\r\n            _balances[ids[i]][to] = values[i].add(_balances[ids[i]][to]);\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, address(0), to, ids, values);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(msg.sender, address(0), to, ids, values, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn an amount of a token with the given ID\r\n     * @param account Account which owns the token to be burnt\r\n     * @param id ID of the token to be burnt\r\n     * @param value Amount of the token to be burnt\r\n     */\r\n    function _burn(address account, uint256 id, uint256 value) internal virtual {\r\n        require(account != address(0), \"ERC1155: attempting to burn tokens on zero account\");\r\n\r\n        _balances[id][account] = _balances[id][account].sub(\r\n            value,\r\n            \"ERC1155: attempting to burn more than balance\"\r\n        );\r\n        emit TransferSingle(msg.sender, account, address(0), id, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to batch burn an amounts of tokens with the given IDs\r\n     * @param account Account which owns the token to be burnt\r\n     * @param ids IDs of the tokens to be burnt\r\n     * @param values Amounts of the tokens to be burnt\r\n     */\r\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory values) internal virtual {\r\n        require(account != address(0), \"ERC1155: attempting to burn batch of tokens on zero account\");\r\n        require(ids.length == values.length, \"ERC1155: burnt IDs and values must have same lengths\");\r\n\r\n        for(uint i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\r\n                values[i],\r\n                \"ERC1155: attempting to burn more than balance for some token\"\r\n            );\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, account, address(0), ids, values);\r\n    }\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes memory data\r\n    )\r\n        internal\r\n        virtual\r\n    {\r\n        if(to.isContract()) {\r\n            require(\r\n                IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) ==\r\n                    IERC1155Receiver(to).onERC1155Received.selector,\r\n                \"ERC1155: got unknown value from onERC1155Received\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory values,\r\n        bytes memory data\r\n    )\r\n        internal\r\n        virtual\r\n    {\r\n        if(to.isContract()) {\r\n            require(\r\n                IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) ==\r\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector,\r\n                \"ERC1155: got unknown value from onERC1155BatchReceived\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/OZ_ERC1155/IERC1155MetadataURI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title ERC-1155 Multi Token Standard basic interface, optional metadata URI extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\r\n */\r\nabstract contract IERC1155MetadataURI is IERC1155 {\r\n    function uri(uint256 id) external view virtual returns (string memory);\r\n}\r\n\r\n// File: contracts/OZ_ERC1155/ERC1155MetadataURICatchAll.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\ncontract ERC1155MetadataURICatchAll is ERC165, ERC1155, IERC1155MetadataURI {\r\n    // Catch-all URI with placeholders, e.g. https://example.com/{locale}/{id}.json\r\n    string private _uri;\r\n\r\n     /*\r\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory uri) public {\r\n        _setURI(uri);\r\n\r\n        // register the supported interfaces to conform to ERC1155 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\r\n    }\r\n\r\n    /**\r\n     * @notice A distinct Uniform Resource Identifier (URI) for a given token.\r\n     * @dev URIs are defined in RFC 3986.\r\n     * The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n     * param id uint256 ID of the token to query (ignored in this particular implementation,\r\n     * as an {id} parameter in the string is expected)\r\n     * @return URI string\r\n    */\r\n    function uri(uint256 id) external view override returns (string memory) {\r\n        require(_exists(id), \"ERC1155MetadataURI: URI query for nonexistent token\");\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set a new URI\r\n     * @param newuri New URI to be set\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n        emit URI(_uri, 0);\r\n    }\r\n}\r\n\r\n// File: contracts/ENSReverseRegistrarI.sol\r\n\r\n/*\r\n * Interfaces for ENS Reverse Registrar\r\n * See https://github.com/ensdomains/ens/blob/master/contracts/ReverseRegistrar.sol for full impl\r\n * Also see https://github.com/wealdtech/wealdtech-solidity/blob/master/contracts/ens/ENSReverseRegister.sol\r\n *\r\n * Use this as follows (registryAddress is the address of the ENS registry to use):\r\n * -----\r\n * // This hex value is caclulated by namehash('addr.reverse')\r\n * bytes32 public constant ENS_ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n * function registerReverseENS(address registryAddress, string memory calldata) external {\r\n *     require(registryAddress != address(0), \"need a valid registry\");\r\n *     address reverseRegistrarAddress = ENSRegistryOwnerI(registryAddress).owner(ENS_ADDR_REVERSE_NODE)\r\n *     require(reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\r\n * }\r\n * -----\r\n * or\r\n * -----\r\n * function registerReverseENS(address reverseRegistrarAddress, string memory calldata) external {\r\n *    require(reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\r\n * }\r\n * -----\r\n * ENS deployments can be found at https://docs.ens.domains/ens-deployments\r\n * For Mainnet, 0x9062c0a6dbd6108336bcbe4593a3d1ce05512069 is the reverseRegistrarAddress,\r\n * for Ropsten, it is at 0x67d5418a000534a8F1f5FF4229cC2f439e63BBe2.\r\n */\r\npragma solidity ^0.6.0;\r\n\r\ninterface ENSRegistryOwnerI {\r\n    function owner(bytes32 node) external view returns (address);\r\n}\r\n\r\ninterface ENSReverseRegistrarI {\r\n    function setName(string calldata name) external returns (bytes32 node);\r\n}\r\n\r\n// File: contracts/OracleRequest.sol\r\n\r\n/*\r\nInterface for requests to the rate oracle (for EUR/ETH)\r\nCopy this to projects that need to access the oracle.\r\nSee rate-oracle project for implementation.\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\n\r\nabstract contract OracleRequest {\r\n\r\n    uint256 public EUR_WEI; //number of wei per EUR\r\n\r\n    uint256 public lastUpdate; //timestamp of when the last update occurred\r\n\r\n    function ETH_EUR() public view virtual returns (uint256); //number of EUR per ETH (rounded down!)\r\n\r\n    function ETH_EURCENT() public view virtual returns (uint256); //number of EUR cent per ETH (rounded down!)\r\n\r\n}\r\n\r\n// File: contracts/CS2PresaleIBuyDP.sol\r\n\r\n/*\r\nInterfacte for CS2 on-chain presale for usage with DirectPay contracts.\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract CS2PresaleIBuyDP {\r\n    enum AssetType {\r\n        Honeybadger,\r\n        Llama,\r\n        Panda,\r\n        Doge\r\n    }\r\n\r\n    // Buy assets of a single type/animal. The number of assets is determined from the amount of ETH sent.\r\n    // This variant will be used externally from the CS2PresaleDirectPay contracts, which need to buy for _their_ msg.sender.\r\n    function buy(AssetType _type, address payable _recipient) public payable virtual;\r\n\r\n}\r\n\r\n// File: contracts/CS2PresaleDirectPay.sol\r\n\r\n/*\r\nImplements an on-chain presale for Crypto stamp Edition 2\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CS2PresaleDirectPay {\r\n    using SafeMath for uint256;\r\n\r\n    address public tokenAssignmentControl;\r\n\r\n    CS2PresaleIBuyDP public presale;\r\n    CS2PresaleIBuyDP.AssetType public assetType;\r\n\r\n    event TokenAssignmentControlTransferred(address indexed previousTokenAssignmentControl, address indexed newTokenAssignmentControl);\r\n\r\n    constructor(CS2PresaleIBuyDP _presale,\r\n        CS2PresaleIBuyDP.AssetType _assetType,\r\n        address _tokenAssignmentControl)\r\n    public\r\n    {\r\n        presale = _presale;\r\n        require(address(presale) != address(0x0), \"You need to provide an actual presale contract.\");\r\n        assetType = _assetType;\r\n        tokenAssignmentControl = _tokenAssignmentControl;\r\n        require(address(tokenAssignmentControl) != address(0x0), \"You need to provide an actual tokenAssignmentControl address.\");\r\n    }\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(msg.sender == tokenAssignmentControl, \"tokenAssignmentControl key required for this function.\");\r\n        _;\r\n    }\r\n\r\n    /*** Enable adjusting variables after deployment ***/\r\n\r\n    function transferTokenAssignmentControl(address _newTokenAssignmentControl)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(_newTokenAssignmentControl != address(0), \"tokenAssignmentControl cannot be the zero address.\");\r\n        emit TokenAssignmentControlTransferred(tokenAssignmentControl, _newTokenAssignmentControl);\r\n        tokenAssignmentControl = _newTokenAssignmentControl;\r\n    }\r\n\r\n    /*** Actual presale functionality ***/\r\n\r\n    // Buy assets of a single type/animal. The number of assets is determined from the amount of ETH sent.\r\n    receive()\r\n    external payable\r\n    {\r\n        presale.buy{value: msg.value}(assetType, msg.sender);\r\n    }\r\n\r\n    /*** Enable reverse ENS registration ***/\r\n\r\n    // Call this with the address of the reverse registrar for the respecitve network and the ENS name to register.\r\n    // The reverse registrar can be found as the owner of 'addr.reverse' in the ENS system.\r\n    // For Mainnet, the address needed is 0x9062c0a6dbd6108336bcbe4593a3d1ce05512069\r\n    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(_reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n        ENSReverseRegistrarI(_reverseRegistrarAddress).setName(_name);\r\n    }\r\n\r\n    /*** Make sure currency or NFT doesn't get stranded in this contract ***/\r\n\r\n    // If this contract gets a balance in some ERC20 contract after it's finished, then we can rescue it.\r\n    function rescueToken(IERC20 _foreignToken, address _to)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        _foreignToken.transfer(_to, _foreignToken.balanceOf(address(this)));\r\n    }\r\n\r\n    // If this contract gets a balance in some ERC721 contract after it's finished, then we can rescue it.\r\n    function approveNFTrescue(IERC721 _foreignNFT, address _to)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        _foreignNFT.setApprovalForAll(_to, true);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/CS2Presale.sol\r\n\r\n/*\r\nImplements an on-chain presale for Crypto stamp Edition 2\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CS2Presale is ERC1155MetadataURICatchAll, CS2PresaleIBuyDP {\r\n    using SafeMath for uint256;\r\n\r\n    OracleRequest internal oracle;\r\n\r\n    address payable public beneficiary;\r\n    address public tokenAssignmentControl;\r\n    address public redeemer;\r\n\r\n    uint256 public priceEurCent;\r\n\r\n    uint256 public limitPerType;\r\n\r\n    // Keep those sizes in sync with the length of the AssetType enum.\r\n    uint256[4] public assetSupply;\r\n    uint256[4] public assetSold;\r\n    CS2PresaleDirectPay[4] public directPay;\r\n\r\n    bool internal _isOpen = true;\r\n\r\n    event DirectPayDeployed(address directPayContract);\r\n    event PriceChanged(uint256 previousPriceEurCent, uint256 newPriceEurCent);\r\n    event LimitChanged(uint256 previousLimitPerType, uint256 newLimitPerType);\r\n    event OracleChanged(address indexed previousOracle, address indexed newOracle);\r\n    event BeneficiaryTransferred(address indexed previousBeneficiary, address indexed newBeneficiary);\r\n    event TokenAssignmentControlTransferred(address indexed previousTokenAssignmentControl, address indexed newTokenAssignmentControl);\r\n    event RedeemerTransferred(address indexed previousRedeemer, address indexed newRedeemer);\r\n    event ShopOpened();\r\n    event ShopClosed();\r\n\r\n    constructor(OracleRequest _oracle,\r\n        uint256 _priceEurCent,\r\n        uint256 _limitPerType,\r\n        address payable _beneficiary,\r\n        address _tokenAssignmentControl)\r\n    ERC1155MetadataURICatchAll(\"https://test.crypto.post.at/CS2PS/meta/{id}\")\r\n    public\r\n    {\r\n        oracle = _oracle;\r\n        require(address(oracle) != address(0x0), \"You need to provide an actual Oracle contract.\");\r\n        beneficiary = _beneficiary;\r\n        require(address(beneficiary) != address(0x0), \"You need to provide an actual beneficiary address.\");\r\n        tokenAssignmentControl = _tokenAssignmentControl;\r\n        require(address(tokenAssignmentControl) != address(0x0), \"You need to provide an actual tokenAssignmentControl address.\");\r\n        redeemer = tokenAssignmentControl;\r\n        priceEurCent = _priceEurCent;\r\n        require(priceEurCent > 0, \"You need to provide a non-zero price.\");\r\n        limitPerType = _limitPerType;\r\n        // Register the token IDs we'll be using.\r\n        uint256 typesNum = assetSupply.length;\r\n        for (uint256 i = 0; i < typesNum; i++) {\r\n            _registerToken(i);\r\n        }\r\n    }\r\n\r\n    modifier onlyBeneficiary() {\r\n        require(msg.sender == beneficiary, \"Only the current benefinicary can call this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(msg.sender == tokenAssignmentControl, \"tokenAssignmentControl key required for this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyRedeemer() {\r\n        require(msg.sender == redeemer, \"Only the current redeemer can call this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier requireOpen() {\r\n        require(isOpen() == true, \"This call only works when the presale is open.\");\r\n        _;\r\n    }\r\n\r\n    /*** Deploy DirectPay contracts ***/\r\n\r\n    // This is its own function as it takes about 2M gas in addition to the 4M+ gas the main contract needs,\r\n    // so it's probably better not to do this right in the constructor.\r\n    // As it can only be done once and the caller cannot influence it, no restrictions are made on who can call it.\r\n    function deployDP()\r\n    public\r\n    {\r\n        uint256 typesNum = directPay.length;\r\n        for (uint256 i = 0; i < typesNum; i++) {\r\n            require(address(directPay[i]) == address(0x0), \"direct-pay contracts have already been deployed.\");\r\n            directPay[i] = new CS2PresaleDirectPay(this, AssetType(i), tokenAssignmentControl);\r\n            emit DirectPayDeployed(address(directPay[i]));\r\n        }\r\n    }\r\n\r\n    /*** Enable adjusting variables after deployment ***/\r\n\r\n    function setPrice(uint256 _newPriceEurCent)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(_newPriceEurCent > 0, \"You need to provide a non-zero price.\");\r\n        emit PriceChanged(priceEurCent, _newPriceEurCent);\r\n        priceEurCent = _newPriceEurCent;\r\n    }\r\n\r\n    function setLimit(uint256 _newLimitPerType)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        uint256 typesNum = assetSold.length;\r\n        for (uint256 i = 0; i < typesNum; i++) {\r\n            require(assetSold[i] <= _newLimitPerType, \"At least one requested asset is already over the requested limit.\");\r\n        }\r\n        emit LimitChanged(limitPerType, _newLimitPerType);\r\n        limitPerType = _newLimitPerType;\r\n    }\r\n\r\n    function setOracle(OracleRequest _newOracle)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(address(_newOracle) != address(0x0), \"You need to provide an actual Oracle contract.\");\r\n        emit OracleChanged(address(oracle), address(_newOracle));\r\n        oracle = _newOracle;\r\n    }\r\n\r\n    function setMetadataURI(string memory _newURI)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        _setURI(_newURI);\r\n    }\r\n\r\n    function transferBeneficiary(address payable _newBeneficiary)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(_newBeneficiary != address(0), \"beneficiary cannot be the zero address.\");\r\n        emit BeneficiaryTransferred(beneficiary, _newBeneficiary);\r\n        beneficiary = _newBeneficiary;\r\n    }\r\n\r\n    function transferTokenAssignmentControl(address _newTokenAssignmentControl)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(_newTokenAssignmentControl != address(0), \"tokenAssignmentControl cannot be the zero address.\");\r\n        emit TokenAssignmentControlTransferred(tokenAssignmentControl, _newTokenAssignmentControl);\r\n        tokenAssignmentControl = _newTokenAssignmentControl;\r\n    }\r\n\r\n    function transferRedeemer(address _newRedeemer)\r\n    public\r\n    onlyRedeemer\r\n    {\r\n        require(_newRedeemer != address(0), \"redeemer cannot be the zero address.\");\r\n        emit RedeemerTransferred(redeemer, _newRedeemer);\r\n        redeemer = _newRedeemer;\r\n    }\r\n\r\n    function openShop()\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        _isOpen = true;\r\n        emit ShopOpened();\r\n    }\r\n\r\n    function closeShop()\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        _isOpen = false;\r\n        emit ShopClosed();\r\n    }\r\n\r\n    /*** Actual presale functionality ***/\r\n\r\n    // Return true if presale is currently open for purchases.\r\n    // This can have additional conditions to just the variable, e.g. actually having items to sell.\r\n    function isOpen()\r\n    public view\r\n    returns (bool)\r\n    {\r\n        return _isOpen;\r\n    }\r\n\r\n    // Calculate current asset price in wei.\r\n    // Note: Price in EUR cent is available from public var getter priceEurCent().\r\n    function priceWei()\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        return priceEurCent.mul(oracle.EUR_WEI()).div(100);\r\n    }\r\n\r\n    // This returns the total amount of all assets currently existing.\r\n    function totalSupply()\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        uint256 _totalSupply = 0;\r\n        uint256 typesNum = assetSupply.length;\r\n        for (uint256 i = 0; i < typesNum; i++) {\r\n            _totalSupply = _totalSupply.add(assetSupply[i]);\r\n        }\r\n        return _totalSupply;\r\n    }\r\n\r\n    // This returns the total amount of all assets created/sold.\r\n    function totalSold()\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        uint256 _totalSold = 0;\r\n        uint256 typesNum = assetSold.length;\r\n        for (uint256 i = 0; i < typesNum; i++) {\r\n            _totalSold = _totalSold.add(assetSold[i]);\r\n        }\r\n        return _totalSold;\r\n    }\r\n\r\n    // Returns the amount of assets of that type still available for sale.\r\n    function availableForSale(AssetType _type)\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        return limitPerType.sub(assetSold[uint256(_type)]);\r\n    }\r\n\r\n    // Returns true if the asset of the given type is sold out.\r\n    function isSoldOut(AssetType _type)\r\n    public view\r\n    returns (bool)\r\n    {\r\n        return assetSold[uint256(_type)] >= limitPerType;\r\n    }\r\n\r\n    // Buy assets of a single type/animal. The number of assets is determined from the amount of ETH sent.\r\n    function buy(AssetType _type)\r\n    external payable\r\n    requireOpen\r\n    {\r\n        buy(_type, msg.sender);\r\n    }\r\n\r\n    // Buy assets of a single type/animal. The number of assets is determined from the amount of ETH sent.\r\n    // This variant will be used externally from the CS2PresaleDirectPay contracts, which need to buy for _their_ msg.sender.\r\n    function buy(AssetType _type, address payable _recipient)\r\n    public payable override\r\n    requireOpen\r\n    {\r\n        uint256 curPriceWei = priceWei();\r\n        require(msg.value >= curPriceWei, \"You need to send enough currency to actually pay at least one item.\");\r\n        uint256 maxToSell = limitPerType.sub(assetSold[uint256(_type)]);\r\n        require(maxToSell > 0, \"The requested asset is sold out.\");\r\n        // Determine amount of assets to buy from payment value (algorithm rounds down).\r\n        uint256 assetCount = msg.value.div(curPriceWei);\r\n        // Don't allow buying more assets than available of this type.\r\n        if (assetCount > maxToSell) {\r\n            assetCount = maxToSell;\r\n        }\r\n        // Determine actual price of rounded-down count.\r\n        uint256 payAmount = assetCount.mul(curPriceWei);\r\n        // Transfer the actual payment amount to the beneficiary.\r\n        beneficiary.transfer(payAmount);\r\n        // Generate and assign the actual assets.\r\n        _mint(_recipient, uint256(_type), assetCount, bytes(\"\"));\r\n        assetSupply[uint256(_type)] = assetSupply[uint256(_type)].add(assetCount);\r\n        assetSold[uint256(_type)] = assetSold[uint256(_type)].add(assetCount);\r\n        // Send back change money. Do this last.\r\n        if (msg.value > payAmount) {\r\n            _recipient.transfer(msg.value.sub(payAmount));\r\n        }\r\n    }\r\n\r\n    // Buy assets of a multiple types/animals at once.\r\n    function buyBatch(AssetType[] calldata _type, uint256[] calldata _count)\r\n    external payable\r\n    requireOpen\r\n    {\r\n        uint256 inputlines = _type.length;\r\n        require(inputlines == _count.length, \"Both input arrays need to be the same length.\");\r\n        uint256 curPriceWei = priceWei();\r\n        require(msg.value >= curPriceWei, \"You need to send enough currency to actually pay at least one item.\");\r\n        // Determine actual price of items to buy.\r\n        uint256 payAmount = 0;\r\n        uint256[] memory ids = new uint256[](inputlines);\r\n        for (uint256 i = 0; i < inputlines; i++) {\r\n            payAmount = payAmount.add(_count[i].mul(curPriceWei));\r\n            ids[i] = uint256(_type[i]);\r\n            assetSupply[ids[i]] = assetSupply[ids[i]].add(_count[i]);\r\n            assetSold[ids[i]] = assetSold[ids[i]].add(_count[i]);\r\n            // If any asset in the batch would go over the limit, fail the whole transaction.\r\n            require(assetSold[ids[i]] <= limitPerType, \"At least one requested asset is sold out.\");\r\n        }\r\n        require(msg.value >= payAmount, \"You need to send enough currency to actually pay all specified items.\");\r\n        // Transfer the actual payment amount to the beneficiary.\r\n        beneficiary.transfer(payAmount);\r\n        // Generate and assign the actual assets.\r\n        _mintBatch(msg.sender, ids, _count, bytes(\"\"));\r\n        // Send back change money. Do this last.\r\n        if (msg.value > payAmount) {\r\n            msg.sender.transfer(msg.value.sub(payAmount));\r\n        }\r\n    }\r\n\r\n    // Redeem assets of a multiple types/animals at once.\r\n    // This burns them in this contract, but should be called by a contract that assigns/creates the final assets in turn.\r\n    function redeemBatch(address owner, AssetType[] calldata _type, uint256[] calldata _count)\r\n    external\r\n    onlyRedeemer\r\n    {\r\n        uint256 inputlines = _type.length;\r\n        require(inputlines == _count.length, \"Both input arrays need to be the same length.\");\r\n        uint256[] memory ids = new uint256[](inputlines);\r\n        for (uint256 i = 0; i < inputlines; i++) {\r\n            ids[i] = uint256(_type[i]);\r\n            assetSupply[ids[i]] = assetSupply[ids[i]].sub(_count[i]);\r\n        }\r\n        _burnBatch(owner, ids, _count);\r\n    }\r\n\r\n    // Returns whether the specified token exists.\r\n    function exists(uint256 id) public view returns (bool) {\r\n        return _exists(id);\r\n    }\r\n\r\n    /*** Enable reverse ENS registration ***/\r\n\r\n    // Call this with the address of the reverse registrar for the respecitve network and the ENS name to register.\r\n    // The reverse registrar can be found as the owner of 'addr.reverse' in the ENS system.\r\n    // For Mainnet, the address needed is 0x9062c0a6dbd6108336bcbe4593a3d1ce05512069\r\n    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(_reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n        ENSReverseRegistrarI(_reverseRegistrarAddress).setName(_name);\r\n    }\r\n\r\n    /*** Make sure currency or NFT doesn't get stranded in this contract ***/\r\n\r\n    // If this contract gets a balance in some ERC20 contract after it's finished, then we can rescue it.\r\n    function rescueToken(IERC20 _foreignToken, address _to)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        _foreignToken.transfer(_to, _foreignToken.balanceOf(address(this)));\r\n    }\r\n\r\n    // If this contract gets a balance in some ERC721 contract after it's finished, then we can rescue it.\r\n    function approveNFTrescue(IERC721 _foreignNFT, address _to)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        _foreignNFT.setApprovalForAll(_to, true);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract OracleRequest\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_priceEurCent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limitPerType\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousBeneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"directPayContract\",\"type\":\"address\"}],\"name\":\"DirectPayDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousLimitPerType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLimitPerType\",\"type\":\"uint256\"}],\"name\":\"LimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"OracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPriceEurCent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceEurCent\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRedeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRedeemer\",\"type\":\"address\"}],\"name\":\"RedeemerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ShopClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ShopOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTokenAssignmentControl\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTokenAssignmentControl\",\"type\":\"address\"}],\"name\":\"TokenAssignmentControlTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_foreignNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"approveNFTrescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PresaleIBuyDP.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"availableForSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PresaleIBuyDP.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PresaleIBuyDP.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PresaleIBuyDP.AssetType[]\",\"name\":\"_type\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_count\",\"type\":\"uint256[]\"}],\"name\":\"buyBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeShop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployDP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directPay\",\"outputs\":[{\"internalType\":\"contract CS2PresaleDirectPay\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PresaleIBuyDP.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"isSoldOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitPerType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openShop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceEurCent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"enum CS2PresaleIBuyDP.AssetType[]\",\"name\":\"_type\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_count\",\"type\":\"uint256[]\"}],\"name\":\"redeemBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reverseRegistrarAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"registerReverseENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_foreignToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimitPerType\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newURI\",\"type\":\"string\"}],\"name\":\"setMetadataURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract OracleRequest\",\"name\":\"_newOracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPriceEurCent\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAssignmentControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newBeneficiary\",\"type\":\"address\"}],\"name\":\"transferBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRedeemer\",\"type\":\"address\"}],\"name\":\"transferRedeemer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenAssignmentControl\",\"type\":\"address\"}],\"name\":\"transferTokenAssignmentControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CS2Presale","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001863d1351fc3003f1ad361939248e3a3a114958e00000000000000000000000000000000000000000000000000000000000002bc00000000000000000000000000000000000000000000000000000000000009c4000000000000000000000000cebb9ae52a3d61c4ed1528fba93e5beaaa40e9e2000000000000000000000000596e620e175c2c37a5f35a41d9f2305a991ffc89","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e530b4a1f5eb2232b21aaac217af56dac744980c9da31d315691c0f0d0efb9bb"}]}