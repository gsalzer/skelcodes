{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/InterFaces/IAuctionRegistery.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract AuctionRegisteryContracts {\r\n    bytes32 internal constant MAIN_TOKEN = \"MAIN_TOKEN\";\r\n    bytes32 internal constant ETN_TOKEN = \"ETN_TOKEN\";\r\n    bytes32 internal constant STOCK_TOKEN = \"STOCK_TOKEN\";\r\n    bytes32 internal constant WHITE_LIST = \"WHITE_LIST\";\r\n    bytes32 internal constant AUCTION = \"AUCTION\";\r\n    bytes32 internal constant AUCTION_PROTECTION = \"AUCTION_PROTECTION\";\r\n    bytes32 internal constant LIQUIDITY = \"LIQUIDITY\";\r\n    bytes32 internal constant CURRENCY = \"CURRENCY\";\r\n    bytes32 internal constant VAULT = \"VAULT\";\r\n    bytes32 internal constant CONTRIBUTION_TRIGGER = \"CONTRIBUTION_TRIGGER\";\r\n    bytes32 internal constant COMPANY_FUND_WALLET = \"COMPANY_FUND_WALLET\";\r\n    bytes32 internal constant SMART_SWAP = \"SMART_SWAP\";\r\n    bytes32 internal constant SMART_SWAP_P2P = \"SMART_SWAP_P2P\";\r\n    bytes32 internal constant ESCROW = \"ESCROW\";\r\n}\r\n\r\ninterface IAuctionRegistery {\r\n    function getAddressOf(bytes32 _contractName)\r\n        external\r\n        view\r\n        returns (address payable);\r\n}\r\n\r\n// File: contracts/Auction/AuctionStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ncontract AuctionStorage {\r\n    IAuctionRegistery public contractsRegistry;\r\n\r\n    address payable public whiteListAddress;\r\n    address payable public smartSwapAddress;\r\n    address payable public currencyPricesAddress;\r\n    address payable public vaultAddress;\r\n    address payable public mainTokenAddress;\r\n    address payable public liquidityAddress;\r\n    address payable public companyFundWalletAddress;\r\n    address payable public escrowAddress;\r\n    address payable public auctionProtectionAddress;\r\n\r\n    uint256 public constant PRICE_NOMINATOR = 10**9;\r\n\r\n    uint256 public constant DECIMAL_NOMINATOR = 10**18;\r\n    \r\n    uint256 public constant PERCENT_NOMINATOR = 10**6;\r\n\r\n    // allowed contarct limit the contribution\r\n    uint256 public maxContributionAllowed;\r\n    // managment fee to run auction cut from basesupply\r\n    uint256 public managementFee;\r\n    // staking percentage\r\n    uint256 public staking;\r\n    // fund that will be locked in contacrt\r\n    uint256 public downSideProtectionRatio;\r\n    // Fund goes to companyWallet\r\n    uint256 public fundWalletRatio;\r\n    // if contribution reach above yesterdayContribution groupBonus multiplyer\r\n    uint256 public groupBonusRatio;\r\n    // user neeed this amount of mainToken to contribute\r\n    uint256 public mainTokenRatio;\r\n\r\n    //from which day mainTokenCheck start\r\n    uint256 public mainTokencheckDay;\r\n    // current auctionday\r\n    uint256 public auctionDay;\r\n    // current totalContribution\r\n    uint256 public totalContribution;\r\n    // today total contributiton\r\n    uint256 public todayContribution;\r\n    // yesterday's contribution\r\n    uint256 public yesterdayContribution;\r\n    // allowed max contribution in a day\r\n    uint256 public allowMaxContribution;\r\n    // yesterday token Supply\r\n    uint256 public yesterdaySupply;\r\n    // today token supply\r\n    uint256 public todaySupply;\r\n\r\n    uint256 public averageDay;\r\n\r\n    // address how much invested by them in auciton till date\r\n    mapping(address => uint256) public userTotalFund;\r\n\r\n    // how much token recived by address in auciton till date\r\n    mapping(address => uint256) public userTotalReturnToken;\r\n\r\n    // day wise supply (groupBounus+coreSupply)\r\n    mapping(uint256 => uint256) public dayWiseSupply;\r\n\r\n    // day wise  coreSupply\r\n    mapping(uint256 => uint256) public dayWiseSupplyCore;\r\n\r\n    // day wise bonusSupply\r\n    mapping(uint256 => uint256) public dayWiseSupplyBonus;\r\n\r\n    // daywise contribution\r\n    mapping(uint256 => uint256) public dayWiseContribution;\r\n\r\n    // daywise markertPrice\r\n    mapping(uint256 => uint256) public dayWiseMarketPrice;\r\n\r\n    // dayWise downsideProtection Ratio\r\n    mapping(uint256 => uint256) public dayWiseDownSideProtectionRatio;\r\n\r\n    // address wise contribution each day\r\n    mapping(uint256 => mapping(address => uint256))\r\n        public walletDayWiseContribution;\r\n\r\n    // daywise contribution\r\n    mapping(uint256 => mapping(address => uint256))\r\n        public mainTokenCheckDayWise;\r\n\r\n    // return index of user for bonus\r\n    mapping(uint256 => uint256) public indexReturn;\r\n\r\n    // day wiser five top contributor\r\n    mapping(uint256 => mapping(uint256 => address)) public topFiveContributor;\r\n\r\n    //contributor Index\r\n    mapping(uint256 => mapping(address => uint256)) public topContributorIndex;\r\n\r\n    // check if daywise token disturbuted\r\n    mapping(uint256 => mapping(address => bool)) public returnToken;\r\n\r\n    uint256 public MIN_AUCTION_END_TIME; //epoch\r\n\r\n    uint256 public LAST_AUCTION_START;\r\n\r\n    uint256 public INTERVAL;\r\n    \r\n    uint256 public currentMarketPrice;\r\n    \r\n    event FundAdded(\r\n        uint256 indexed _auctionDayId,\r\n        uint256 _todayContribution,\r\n        address indexed _fundBy,\r\n        address indexed _fundToken,\r\n        uint256 _fundAmount,\r\n        uint256 _fundValue,\r\n        uint256 _totalFund,\r\n        uint256 _marketPrice\r\n    );\r\n\r\n    event FundAddedBehalf(address indexed _caller, address indexed _recipient);\r\n\r\n    event AuctionEnded(\r\n        uint256 indexed _auctionDayId,\r\n        uint256 _todaySupply,\r\n        uint256 _yesterdaySupply,\r\n        uint256 _todayContribution,\r\n        uint256 _yesterdayContribution,\r\n        uint256 _totalContribution,\r\n        uint256 _maxContributionAllowed,\r\n        uint256 _tokenPrice,\r\n        uint256 _tokenMarketPrice\r\n    );\r\n\r\n    event FundDeposited(address _token, address indexed _from, uint256 _amount);\r\n\r\n    event TokenDistrubuted(\r\n        address indexed _whom,\r\n        uint256 indexed dayId,\r\n        uint256 _totalToken,\r\n        uint256 lockedToken,\r\n        uint256 _userToken\r\n    );\r\n\r\n}\r\n\r\n// File: contracts/common/Constant.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract Constant {\r\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\r\n\r\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\r\n\r\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\r\n\r\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\r\n\r\n    string constant ERR_SAME_ADDRESS = \"ERR_SAME_ADDRESS\";\r\n\r\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\r\n\r\n    modifier notOwnAddress(address _which) {\r\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // validates an address is not zero\r\n    modifier notZeroAddress(address _which) {\r\n        require(_which != address(0), ERR_ZERO_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThisAddress(address _which) {\r\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    modifier notZeroValue(uint256 _value) {\r\n        require(_value > 0, ERR_VALUE_IS_ZERO);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/common/ProxyOwnable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\ncontract ProxyOwnable is Constant {\r\n    \r\n    address public primaryOwner;\r\n\r\n    address public authorityAddress;\r\n\r\n    address public newAuthorityAddress;\r\n\r\n    address public systemAddress;\r\n    \r\n    bool public isOwnerInitialize = false;\r\n\r\n    event OwnershipTransferred(\r\n        string ownerType,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    \r\n    event AuthorityAddressChnageCall(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the `primaryOwner` and `systemAddress` and '_multisigAddress'\r\n     * account.\r\n     */\r\n\r\n    function initializeOwner(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress\r\n    ) internal notZeroAddress(_primaryOwner) notZeroAddress(_systemAddress) notZeroAddress(_authorityAddress) {\r\n        \r\n        require(!isOwnerInitialize,\"ERR_OWNER_INTIALIZED_ALREADY\");\r\n        \r\n        require(_primaryOwner != _systemAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_systemAddress != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_primaryOwner != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        primaryOwner = _primaryOwner;\r\n        systemAddress = _systemAddress;\r\n        authorityAddress = _authorityAddress;\r\n        isOwnerInitialize = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == primaryOwner, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender == systemAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOneOfOnwer() {\r\n        require(\r\n            msg.sender == primaryOwner || msg.sender == systemAddress,\r\n            ERR_AUTHORIZED_ADDRESS_ONLY\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == authorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev change primary ownership governance \r\n     */\r\n    function changePrimaryOwner()\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        emit OwnershipTransferred(\"PRIMARY_OWNER\", primaryOwner, authorityAddress);\r\n        primaryOwner = authorityAddress;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new system address\r\n     */\r\n    function changeSystemAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notThisAddress(_which)\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress &&\r\n                _which != primaryOwner,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        emit OwnershipTransferred(\"SYSTEM_ADDRESS\", systemAddress, _which);\r\n        systemAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new Authority address\r\n     */\r\n    function changeAuthorityAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        newAuthorityAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    function acceptAuthorityAddress() public returns (bool) {\r\n        require(msg.sender == newAuthorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        emit OwnershipTransferred(\r\n            \"AUTHORITY_ADDRESS\",\r\n            authorityAddress,\r\n            newAuthorityAddress\r\n        );\r\n        authorityAddress = newAuthorityAddress;\r\n        newAuthorityAddress = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/common/SafeMath.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 result;\r\n        assembly {\r\n            result := exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // calculates a^(1/n) to dp decimal places\r\n    // maxIts bounds the number of iterations performed\r\n    function nthRoot(\r\n        uint256 _a,\r\n        uint256 _n,\r\n        uint256 _dp,\r\n        uint256 _maxIts\r\n    ) internal pure returns (uint256) {\r\n        assert(_n > 1);\r\n\r\n        // The scale factor is a crude way to turn everything into integer calcs.\r\n        // Actually do (a * (10 ^ ((dp + 1) * n))) ^ (1/n)\r\n        // We calculate to one extra dp and round at the end\r\n        uint256 one = 10**(1 + _dp);\r\n        uint256 a0 = one**_n * _a;\r\n\r\n        // Initial guess: 1.0\r\n        uint256 xNew = one;\r\n        uint256 x;\r\n\r\n        uint256 iter = 0;\r\n        while (xNew != x && iter < _maxIts) {\r\n            x = xNew;\r\n            uint256 t0 = x**(_n - 1);\r\n            if (x * t0 > a0) {\r\n                xNew = x - (x - a0 / t0) / _n;\r\n            } else {\r\n                xNew = x + (a0 / t0 - x) / _n;\r\n            }\r\n            ++iter;\r\n        }\r\n\r\n        // Round to nearest in the last dp.\r\n        return (xNew + 5) / 10;\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IERC20Token.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: contracts/common/TokenTransfer.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ncontract TokenTransfer {\r\n    function ensureTransferFrom(\r\n        IERC20Token _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_from == address(this))\r\n            require(_token.transfer(_to, _amount), \"ERR_TOKEN_TRANSFER_FAIL\");\r\n        else\r\n            require(\r\n                _token.transferFrom(_from, _to, _amount),\r\n                \"ERR_TOKEN_TRANSFER_FAIL\"\r\n            );\r\n    }\r\n\r\n    function approveTransferFrom(\r\n        IERC20Token _token,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_token.approve(_spender, _amount), \"ERR_TOKEN_APPROVAL_FAIL\");\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/IRegistry.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title IRegistry\r\n * @dev This contract represents the interface of a registry contract\r\n */\r\ninterface IRegistry {\r\n    /**\r\n     * @dev This event will be emitted every time a new proxy is created\r\n     * @param proxy representing the address of the proxy created\r\n     */\r\n    event ProxyCreated(address proxy);\r\n\r\n    /**\r\n     * @dev This event will be emitted every time a new implementation is registered\r\n     * @param version representing the version name of the registered implementation\r\n     * @param implementation representing the address of the registered implementation\r\n     */\r\n    event VersionAdded(uint256 version, address implementation);\r\n\r\n    /**\r\n     * @dev Registers a new version with its implementation address\r\n     * @param version representing the version name of the new implementation to be registered\r\n     * @param implementation representing the address of the new implementation to be registered\r\n     */\r\n    function addVersion(uint256  version, address implementation)\r\n        external;\r\n\r\n    /**\r\n     * @dev Tells the address of the implementation for a given version\r\n     * @param version to query the implementation of\r\n     * @return address of the implementation registered for the given version\r\n     */\r\n    function getVersion(uint256 version)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/Proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n     * @dev Tells the address of the implementation where every call will be delegated.\r\n     * @return address of the implementation to which it will be delegated\r\n     */\r\n    function implementation() public view returns (address);\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    \r\n    function() external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0),\"ERR_IMPLEMENTEION_ZERO\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }  \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n}\r\n\r\n// File: contracts/Proxy/UpgradeabilityStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage is Proxy {\r\n    // Versions registry\r\n    IRegistry public registry;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/Upgradeable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title Upgradeable\r\n * @dev This contract holds all the minimum required functionality for a behavior to be upgradeable.\r\n * This means, required state variables for owned upgradeability purpose and simple initialization validation.\r\n */\r\ncontract Upgradeable is UpgradeabilityStorage {\r\n    /**\r\n     * @dev Validates the caller is the versions registry.\r\n     * THIS FUNCTION SHOULD BE OVERRIDDEN CALLING SUPER\r\n     */\r\n    function initialize() public view {\r\n        require(msg.sender == address(registry),\"ERR_ONLY_REGISTRERY_CAN_CALL\");\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IContributionTrigger.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IContributionTrigger {\r\n    function depositeToken(\r\n        IERC20Token _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function contributeTowardLiquidity(uint256 _amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    function transferTokenLiquidity(\r\n        IERC20Token _token,\r\n        address _reciver,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/ICurrencyPrices.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface ICurrencyPrices {\r\n    function getCurrencyPrice(address _which) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/InterFaces/IAuctionLiquidity.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IAuctionLiquidity {\r\n    function contributeWithEther() external payable returns (uint256);\r\n\r\n    function auctionEnded() external returns (bool);\r\n\r\n    function contributeTowardMainReserve() external returns (uint256);\r\n}\r\n\r\n// File: contracts/InterFaces/ITokenVault.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface ITokenVault {\r\n    function depositeToken(\r\n        IERC20Token _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function directTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferEther(address payable _to, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/IToken.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface IToken {\r\n    function mintTokens(uint256 _amount) external returns (bool);\r\n\r\n    function buyTokens(address _fromToken, uint256 _amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    function burn(uint256 _value) external returns (bool);\r\n\r\n    function lockToken(\r\n        address _which,\r\n        uint256 _amount,\r\n        uint256 _locktime\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/IWhiteList.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface IWhiteList {\r\n    function address_belongs(address _who) external view returns (address);\r\n\r\n    function isWhiteListed(address _who) external view returns (bool);\r\n\r\n    function isAllowedInAuction(address _which) external view returns (bool);\r\n\r\n    function isAddressByPassed(address _which) external view returns (bool);\r\n\r\n    function isExchangeAddress(address _which) external view returns (bool);\r\n\r\n    function main_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function etn_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function stock_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function addWalletBehalfExchange(address _mainWallet, address _subWallet)\r\n        external\r\n        returns (bool);\r\n\r\n    function main_isReceiveAllowed(address user) external view returns (bool);\r\n\r\n    function etn_isReceiveAllowed(address user) external view returns (bool);\r\n\r\n    function stock_isReceiveAllowed(address user) external view returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/IEscrow.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface IEscrow {\r\n    function depositFee(uint256 value) external returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/IAuctionProtection.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IAuctionProtection {\r\n    function lockEther(uint256 _auctionDay,address _which)\r\n        external\r\n        payable\r\n        returns (bool);\r\n    \r\n    function stackFund(uint256 _amount)\r\n        external\r\n        returns (bool);\r\n        \r\n    function depositToken(\r\n        uint256 _auctionDay,\r\n        address _which,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n    \r\n    function unLockTokens() external returns (bool);\r\n}\r\n\r\n// File: contracts/Auction/Auction.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface AuctionInitializeInterface {\r\n    function initialize(\r\n        uint256 _startTime,\r\n        uint256 _minAuctionTime,\r\n        uint256 _interval,\r\n        uint256 _mainTokenCheckDay,\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _multisigAddress,\r\n        address _registryaddress\r\n    ) external;\r\n}\r\n\r\ncontract RegisteryAuction is ProxyOwnable, AuctionRegisteryContracts,AuctionStorage {\r\n    \r\n\r\n    function updateRegistery(address _address)\r\n        external\r\n        onlyAuthorized()\r\n        notZeroAddress(_address)\r\n        returns (bool)\r\n    {\r\n        contractsRegistry = IAuctionRegistery(_address);\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**@dev updates the address from the registry contract*/\r\n\r\n    function getAddressOf(bytes32 _contractName)\r\n        internal\r\n        view\r\n        returns (address payable)\r\n    {\r\n        return contractsRegistry.getAddressOf(_contractName);\r\n    }\r\n\r\n    /**@dev updates all the address from the registry contract\r\n    this decision was made to save gas that occurs from calling an external view function */\r\n\r\n    function _updateAddresses() internal {\r\n        whiteListAddress = getAddressOf(WHITE_LIST);\r\n        smartSwapAddress = getAddressOf(SMART_SWAP);\r\n        currencyPricesAddress = getAddressOf(CURRENCY);\r\n        vaultAddress = getAddressOf(VAULT);\r\n        mainTokenAddress = getAddressOf(MAIN_TOKEN);\r\n        liquidityAddress = getAddressOf(LIQUIDITY);\r\n        companyFundWalletAddress = getAddressOf(COMPANY_FUND_WALLET);\r\n        escrowAddress = getAddressOf(ESCROW);\r\n        auctionProtectionAddress = getAddressOf(AUCTION_PROTECTION);\r\n\r\n    }\r\n\r\n    function updateAddresses() external returns (bool) {\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract AuctionUtils is RegisteryAuction{\r\n    \r\n    \r\n     function initializeStorage() internal {\r\n        auctionDay = 1;\r\n        totalContribution = 2500000 * PRICE_NOMINATOR;\r\n        yesterdayContribution = 500 * PRICE_NOMINATOR;\r\n        allowMaxContribution = 500 * PRICE_NOMINATOR;\r\n        todaySupply = 50000 * DECIMAL_NOMINATOR;\r\n        maxContributionAllowed = 150;\r\n        managementFee = 2;\r\n        staking = 1;\r\n        downSideProtectionRatio = 90;\r\n        fundWalletRatio = 90;\r\n        groupBonusRatio = 2;\r\n        mainTokenRatio = 100;\r\n        averageDay = 10;\r\n    }\r\n\r\n    function setGroupBonusRatio(uint256 _groupBonusRatio)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        groupBonusRatio = _groupBonusRatio;\r\n        return true;\r\n    }\r\n\r\n    function setDownSideProtectionRatio(uint256 _ratio)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        require(_ratio < 100, \"ERR_SHOULD_BE_LESS_THAN_100\");\r\n        downSideProtectionRatio = _ratio;\r\n        return true;\r\n    }\r\n\r\n    function setfundWalletRatio(uint256 _ratio)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        require(_ratio < 100, \"ERR_SHOULD_BE_LESS_THAN_100\");\r\n        fundWalletRatio = _ratio;\r\n        return true;\r\n    }\r\n\r\n    function setMainTokenRatio(uint256 _ratio)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        mainTokenRatio = _ratio;\r\n        return true;\r\n    }\r\n\r\n    function setMainTokenCheckDay(uint256 _mainTokencheckDay)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        mainTokencheckDay = _mainTokencheckDay;\r\n        return true;\r\n    }\r\n\r\n    function setMaxContributionAllowed(uint256 _maxContributionAllowed)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        maxContributionAllowed = _maxContributionAllowed;\r\n        return true;\r\n    }\r\n\r\n    function setstakingPercent(uint256 _staking)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        staking = _staking;\r\n        return true;\r\n    }\r\n    \r\n    function setAverageDays(uint256 _averageDay)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        averageDay = _averageDay;\r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\ncontract AuctionFormula is SafeMath, TokenTransfer {\r\n    \r\n    // calculate Funds On each day to see how much the user receives\r\n    // split between  _returnAmount totalAmount which the user receives\r\n    // _userAmount is which user get other token is locked\r\n    function calcuateAuctionTokenDistrubution(\r\n        uint256 dayWiseContributionByWallet,\r\n        uint256 dayWiseSupplyCore,\r\n        uint256 dayWiseSupplyBonus,\r\n        uint256 dayWiseContribution,\r\n        uint256 downSideProtectionRatio\r\n    ) internal pure returns (uint256, uint256) {\r\n        uint256 _dayWiseSupplyCore = safeDiv(\r\n            safeMul(dayWiseSupplyCore, dayWiseContributionByWallet),\r\n            dayWiseContribution\r\n        );\r\n\r\n        uint256 _dayWiseSupplyBonus = 0;\r\n        if (dayWiseSupplyBonus > 0)\r\n            _dayWiseSupplyBonus = safeDiv(\r\n                safeMul(dayWiseSupplyBonus, dayWiseContributionByWallet),\r\n                dayWiseContribution\r\n            );\r\n        uint256 _returnAmount = safeAdd(\r\n            _dayWiseSupplyCore,\r\n            _dayWiseSupplyBonus\r\n        );\r\n\r\n        // user receives only 10% - downSideProtectionRatio(90) fund receives the other 90% which is locked\r\n        uint256 _userAmount = safeDiv(\r\n            safeMul(_dayWiseSupplyCore, safeSub(100, downSideProtectionRatio)),\r\n            100\r\n        );\r\n\r\n        return (_returnAmount, _userAmount);\r\n    }\r\n\r\n    \r\n    function calculateNewSupply(\r\n        uint256 todayContribution,\r\n        uint256 tokenPrice,\r\n        uint256 decimal\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            safeDiv(\r\n                safeMul(todayContribution, safeExponent(10, decimal)),\r\n                tokenPrice\r\n            );\r\n    }\r\n\r\n    function calculateSupplyPercent(uint256 _supply, uint256 _percent)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 _tempSupply = safeDiv(\r\n            safeMul(_supply, 100),\r\n            safeSub(100, _percent)\r\n        );\r\n        uint256 _managementFee = safeSub(_tempSupply, _supply);\r\n        return _managementFee;\r\n    }\r\n}\r\n\r\n\r\ncontract IndividualBonus is AuctionFormula,AuctionUtils {\r\n    \r\n    function updateIndividualBonusRatio(\r\n        uint256 X1,\r\n        uint256 X2,\r\n        uint256 X3,\r\n        uint256 X4,\r\n        uint256 X5\r\n    ) external onlyAuthorized() returns (bool) {\r\n        indexReturn[1] = X1;\r\n        indexReturn[2] = X2;\r\n        indexReturn[3] = X3;\r\n        indexReturn[4] = X4;\r\n        indexReturn[5] = X5;\r\n        return true;\r\n    }\r\n\r\n    function _compareForGroupBonus(address _from) internal {\r\n        address contributor;\r\n        uint256 topContributor;\r\n        bool replaced = false;\r\n        address replaceWith;\r\n\r\n\r\n            uint256 contributionByUser\r\n         = walletDayWiseContribution[auctionDay][_from];\r\n\r\n\r\n        uint256 smallestContributionByUser\r\n         = walletDayWiseContribution[auctionDay][topFiveContributor[auctionDay][5]];\r\n        \r\n        if (contributionByUser > smallestContributionByUser) {\r\n            \r\n            for (uint256 x = 1; x <= 5; x++) {\r\n                contributor = topFiveContributor[auctionDay][x];\r\n                topContributor = walletDayWiseContribution[auctionDay][contributor];\r\n                if (\r\n                    contributionByUser >= topContributor && replaced == false\r\n                ) {\r\n                    if (\r\n                        contributor != _from &&\r\n                        contributionByUser > topContributor\r\n                    ) {\r\n                        topFiveContributor[auctionDay][x] = _from;\r\n                        topContributorIndex[auctionDay][_from] = x;\r\n                        replaceWith = contributor;\r\n                        replaced = true;\r\n                    } else if (contributor == _from) {\r\n                        replaceWith = contributor;\r\n                        replaced = true;\r\n                    }\r\n                } else if (replaced && replaceWith != _from) {\r\n                    topFiveContributor[auctionDay][x] = replaceWith;\r\n                    topContributorIndex[auctionDay][replaceWith] = x;\r\n                    replaceWith = contributor;\r\n                }\r\n            }\r\n            \r\n            if (replaceWith != address(0) && replaceWith != _from)\r\n                topContributorIndex[auctionDay][replaceWith] = 0;\r\n        }\r\n    }\r\n\r\n    function calculateBouns(uint256 _auctionDay, address _from)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _calculateBouns(_auctionDay, _from);\r\n    }\r\n\r\n    function _calculateBouns(uint256 _auctionDay, address _from)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return indexReturn[topContributorIndex[_auctionDay][_from]];\r\n    }\r\n}\r\n\r\ncontract AuctionFundCollector is IndividualBonus {\r\n    \r\n    // check before contribution\r\n    function _checkContribution(address _from) internal view returns (bool) {\r\n        require(\r\n            IWhiteList(whiteListAddress).isAllowedInAuction(_from),\r\n            \"ERR_NOT_ALLOWED_IN_AUCTION\"\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function mainTokenCheck(address _from, uint256 _contributedAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        IERC20Token mainToken = IERC20Token(mainTokenAddress);\r\n        \r\n        uint256 _mainTokenPrice = currentMarketPrice;\r\n\r\n        require(_mainTokenPrice > 0, \"ERR_TOKEN_PRICE_NOT_SET\");\r\n        \r\n        uint256 lockToken = safeDiv(\r\n            safeMul(safeAdd(\r\n                mainTokenCheckDayWise[auctionDay][_from],\r\n                _contributedAmount\r\n            ),safeExponent(10, mainToken.decimals()))\r\n            ,\r\n            _mainTokenPrice\r\n        );\r\n        \r\n        require(\r\n            mainToken.balanceOf(_from) >= safeDiv(safeMul(lockToken,mainTokenRatio),100),\r\n            \"ERR_USER_DOES_NOT_HAVE_EQUAL_BALANCE\"\r\n        );\r\n        \r\n        IToken(mainTokenAddress).lockToken(_from, lockToken, now);\r\n        return true;\r\n    }\r\n\r\n    // check whether the user sends more funds, if yes\r\n    // revert whatever user send extra revert back to user\r\n    function calculateFund(\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _decimal\r\n    ) internal view returns (uint256,uint256) {\r\n        \r\n        uint256 _currencyPrices = ICurrencyPrices(currencyPricesAddress)\r\n            .getCurrencyPrice(_token);\r\n\r\n        require(_currencyPrices > 0, \"ERR_TOKEN_PRICE_NOT_SET\");\r\n\r\n        uint256 _contributedAmount = safeDiv(\r\n            safeMul(_amount, _currencyPrices),\r\n            safeExponent(10, _decimal)\r\n        );\r\n\r\n        if (\r\n            safeAdd(todayContribution, _contributedAmount) >\r\n            allowMaxContribution\r\n        ) {\r\n            uint256 extraAmount = safeSub(\r\n                safeAdd(todayContribution, _contributedAmount),\r\n                allowMaxContribution\r\n            );\r\n            return\r\n                (safeDiv(\r\n                    safeMul(extraAmount, safeExponent(10, _decimal)),\r\n                    _currencyPrices\r\n                ),_currencyPrices);\r\n        }\r\n        return (0,_currencyPrices);\r\n    }\r\n\r\n    function fundAdded(\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _decimal,\r\n        address _caller,\r\n        address _recipient,\r\n        uint256 _currencyPrice\r\n    ) internal returns (bool){\r\n        \r\n\r\n        uint256 _contributedAmount = safeDiv(\r\n            safeMul(_amount, _currencyPrice),\r\n            safeExponent(10, _decimal)\r\n        );\r\n        \r\n        // Here we check caller balance \r\n        if (auctionDay >= mainTokencheckDay) {\r\n            mainTokenCheck(_caller, _contributedAmount);\r\n        }\r\n\r\n        todayContribution = safeAdd(todayContribution, _contributedAmount);\r\n        \r\n        mainTokenCheckDayWise[auctionDay][_caller] = safeAdd(\r\n            walletDayWiseContribution[auctionDay][_caller],\r\n            _contributedAmount\r\n        );\r\n        \r\n        walletDayWiseContribution[auctionDay][_recipient] = safeAdd(\r\n            walletDayWiseContribution[auctionDay][_recipient],\r\n            _contributedAmount\r\n        );\r\n\r\n        userTotalFund[_recipient] = safeAdd(\r\n            userTotalFund[_recipient],\r\n            _contributedAmount\r\n        );\r\n\r\n        dayWiseContribution[auctionDay] = safeAdd(\r\n            dayWiseContribution[auctionDay],\r\n            _contributedAmount\r\n        );\r\n\r\n        _compareForGroupBonus(_recipient);\r\n\r\n        emit FundAdded(\r\n            auctionDay,\r\n            todayContribution,\r\n            _recipient,\r\n            _token,\r\n            _amount,\r\n            _contributedAmount,\r\n            walletDayWiseContribution[auctionDay][_recipient],\r\n            currentMarketPrice\r\n        );\r\n        \r\n        if(_caller != _recipient){\r\n            emit FundAddedBehalf(_caller,_recipient);\r\n        }\r\n            \r\n        return true;\r\n    }\r\n\r\n    function _contributeWithEther(uint256 _value,address _caller,address payable _recipient)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        (uint256 returnAmount,uint256 _currencyPrice) = calculateFund(address(0), _value, 18);\r\n        \r\n        // transfer Back Extra Amount To the _recipient\r\n        if (returnAmount != 0) {\r\n            _recipient.transfer(returnAmount);\r\n            _value = safeSub(_value, returnAmount);\r\n        }\r\n        \r\n        uint256 downSideAmount = safeDiv(safeMul(_value,dayWiseDownSideProtectionRatio[auctionDay]),100);\r\n        \r\n        IAuctionProtection(auctionProtectionAddress).lockEther.value(downSideAmount)(auctionDay,_recipient);\r\n        \r\n        return fundAdded(address(0), _value, 18, _caller , _recipient,_currencyPrice);\r\n    }\r\n\r\n    // we only start with ether we dont need any token right now\r\n    function contributeWithEther() external payable returns (bool) {\r\n        \r\n        require(_checkContribution(msg.sender));\r\n        \r\n        return _contributeWithEther(msg.value,msg.sender,msg.sender);\r\n    }\r\n    \r\n    // This Method For Exchange \r\n    // Exchange invests on behalf of their users\r\n    // so we check caller maintoken balance \r\n    function contributeWithEtherBehalf(address payable _whom) external payable returns (bool) {\r\n        \r\n        require(IWhiteList(whiteListAddress).isExchangeAddress(msg.sender),ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        \r\n        if(IWhiteList(whiteListAddress).address_belongs(_whom) == address(0)){\r\n            IWhiteList(whiteListAddress).addWalletBehalfExchange(msg.sender,_whom);\r\n        }\r\n        \r\n        require(IWhiteList(whiteListAddress).address_belongs(_whom) == msg.sender);\r\n        \r\n        return _contributeWithEther(msg.value,msg.sender,_whom);\r\n    }\r\n    \r\n    function updateCurrentMarketPrice() external returns (bool){\r\n        currentMarketPrice = ICurrencyPrices(currencyPricesAddress)\r\n            .getCurrencyPrice(mainTokenAddress);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    \r\n    function pushEthToLiquidity() external returns(bool){\r\n        return _pushEthToLiquidity();\r\n    }\r\n    \r\n    function _pushEthToLiquidity() internal returns(bool){\r\n        \r\n        uint256 pushToLiquidity = address(this).balance;\r\n        \r\n        if(pushToLiquidity > 0){\r\n            \r\n            uint256 realEstateAmount = safeDiv(safeMul(pushToLiquidity,fundWalletRatio),100);                \r\n            companyFundWalletAddress.transfer(realEstateAmount); \r\n            uint256 reserveAmount = safeSub(pushToLiquidity,realEstateAmount);\r\n            currentMarketPrice = IAuctionLiquidity(liquidityAddress)\r\n             .contributeWithEther\r\n             .value(reserveAmount)();\r\n             \r\n        }\r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\ncontract Auction is Upgradeable, AuctionFundCollector, AuctionInitializeInterface {\r\n    \r\n\r\n    function changeTimings(uint256 _flag, uint256 _time)\r\n        external\r\n        onlyAuthorized()\r\n        returns (bool)\r\n    {\r\n        if (_flag == 1) MIN_AUCTION_END_TIME = _time;\r\n        else if (_flag == 2) LAST_AUCTION_START == _time;\r\n        else if (_flag == 3) INTERVAL == _time;\r\n        return true;\r\n    }\r\n\r\n    function initialize(\r\n        uint256 _startTime,\r\n        uint256 _minAuctionTime,\r\n        uint256 _interval,\r\n        uint256 _mainTokenCheckDay,\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _multisigAddress,\r\n        address _registryaddress\r\n    ) public {\r\n        super.initialize();\r\n        initializeOwner(_primaryOwner, _systemAddress, _multisigAddress);\r\n        contractsRegistry = IAuctionRegistery(_registryaddress);\r\n        initializeStorage();\r\n        _updateAddresses();\r\n        dayWiseDownSideProtectionRatio[auctionDay] = downSideProtectionRatio;\r\n        LAST_AUCTION_START = _startTime;\r\n        MIN_AUCTION_END_TIME = _minAuctionTime;\r\n        INTERVAL = _interval;\r\n        mainTokencheckDay = _mainTokenCheckDay;\r\n        indexReturn[1] = 50;\r\n        indexReturn[2] = 40;\r\n        indexReturn[3] = 30;\r\n        indexReturn[4] = 20;\r\n        indexReturn[5] = 10;\r\n    }\r\n\r\n\r\n    function getAuctionDetails()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _todaySupply,\r\n            uint256 _yesterdaySupply,\r\n            uint256 _todayContribution,\r\n            uint256 _yesterdayContribution,\r\n            uint256 _totalContribution,\r\n            uint256 _maxContributionAllowed,\r\n            uint256 _marketPrice\r\n        )\r\n    {\r\n        uint256 _mainTokenPrice = ICurrencyPrices(currencyPricesAddress)\r\n            .getCurrencyPrice(mainTokenAddress);\r\n\r\n        return (\r\n            todaySupply,\r\n            yesterdaySupply,\r\n            todayContribution,\r\n            yesterdayContribution,\r\n            totalContribution,\r\n            allowMaxContribution,\r\n            _mainTokenPrice\r\n        );\r\n    }\r\n\r\n    // any one can call this method\r\n    \r\n    function auctionEnd() external returns (bool) {\r\n        require(\r\n            now >= safeAdd(LAST_AUCTION_START, MIN_AUCTION_END_TIME),\r\n            \"ERR_MIN_TIME_IS_NOT_OVER\"\r\n        );\r\n\r\n        _pushEthToLiquidity();\r\n        \r\n        uint256 _mainTokenPrice = currentMarketPrice;\r\n        \r\n        if (todayContribution == 0) {\r\n            \r\n            uint256 _ethPrice = ICurrencyPrices(currencyPricesAddress)\r\n                .getCurrencyPrice(address(0));\r\n\r\n            uint256 mainReserveAmount = IAuctionLiquidity(liquidityAddress)\r\n                .contributeTowardMainReserve();\r\n\r\n            uint256 mainReserveAmountUsd = safeDiv(\r\n                safeMul(mainReserveAmount, _ethPrice),\r\n                DECIMAL_NOMINATOR\r\n            );\r\n\r\n            dayWiseContribution[auctionDay] = mainReserveAmountUsd;\r\n\r\n            todayContribution = mainReserveAmountUsd;\r\n\r\n            walletDayWiseContribution[auctionDay][vaultAddress] = mainReserveAmountUsd;\r\n\r\n            _mainTokenPrice = ICurrencyPrices(currencyPricesAddress)\r\n                .getCurrencyPrice(mainTokenAddress);\r\n\r\n            _compareForGroupBonus(vaultAddress);\r\n\r\n            emit FundAdded(\r\n                auctionDay,\r\n                todayContribution,\r\n                vaultAddress,\r\n                address(0),\r\n                mainReserveAmount,\r\n                mainReserveAmountUsd,\r\n                mainReserveAmountUsd,\r\n                _mainTokenPrice\r\n            );\r\n        }\r\n\r\n        uint256 bonusSupply = 0;\r\n\r\n        allowMaxContribution = safeDiv(\r\n            safeMul(todayContribution, maxContributionAllowed),\r\n            100\r\n        );\r\n\r\n        if (todayContribution > yesterdayContribution) {\r\n            uint256 _groupBonusRatio = safeMul(\r\n                safeDiv(\r\n                    safeMul(todayContribution, DECIMAL_NOMINATOR),\r\n                    yesterdayContribution\r\n                ),\r\n                groupBonusRatio\r\n            );\r\n\r\n            bonusSupply = safeSub(\r\n                safeDiv(\r\n                    safeMul(todaySupply, _groupBonusRatio),\r\n                    DECIMAL_NOMINATOR\r\n                ),\r\n                todaySupply\r\n            );\r\n        }\r\n\r\n        uint256 _avgDays = averageDay;\r\n        uint256 _avgInvestment = 0;\r\n\r\n        if (auctionDay < 11 && auctionDay > 1) {\r\n            _avgDays = safeSub(auctionDay, 1);\r\n        }\r\n\r\n        if (auctionDay > 1) {\r\n            for (uint32 tempX = 1; tempX <= _avgDays; tempX++) {\r\n                _avgInvestment = safeAdd(\r\n                    _avgInvestment,\r\n                    dayWiseContribution[safeSub(auctionDay, tempX)]\r\n                );\r\n            }\r\n\r\n            _avgInvestment = safeDiv(\r\n                safeMul(\r\n                    safeDiv(_avgInvestment, _avgDays),\r\n                    maxContributionAllowed\r\n                ),\r\n                100\r\n            );\r\n        }\r\n\r\n        if (_avgInvestment > allowMaxContribution) {\r\n            allowMaxContribution = _avgInvestment;\r\n        }\r\n\r\n        dayWiseSupplyCore[auctionDay] = todaySupply;\r\n        dayWiseSupplyBonus[auctionDay] = bonusSupply;\r\n        dayWiseSupply[auctionDay] = safeAdd(todaySupply, bonusSupply);\r\n\r\n        uint256 stakingAmount = safeDiv(\r\n            safeMul(dayWiseSupply[auctionDay], staking),\r\n            100\r\n        );\r\n        uint256 fee = calculateSupplyPercent(\r\n            safeAdd(stakingAmount, dayWiseSupply[auctionDay]),\r\n            managementFee\r\n        );\r\n\r\n        IToken(mainTokenAddress).mintTokens(safeAdd(fee, stakingAmount));\r\n        \r\n        approveTransferFrom(\r\n            IERC20Token(mainTokenAddress),\r\n            escrowAddress,\r\n            fee\r\n        );\r\n        \r\n        IEscrow(escrowAddress).depositFee(fee);\r\n        \r\n        approveTransferFrom(\r\n            IERC20Token(mainTokenAddress),\r\n            auctionProtectionAddress,\r\n            stakingAmount\r\n        );\r\n        \r\n        IAuctionProtection(auctionProtectionAddress).stackFund(stakingAmount);\r\n    \r\n        uint256 _tokenPrice = safeDiv(\r\n            safeMul(todayContribution, DECIMAL_NOMINATOR),\r\n            dayWiseSupply[auctionDay]\r\n        );\r\n\r\n        dayWiseMarketPrice[auctionDay] = _mainTokenPrice;\r\n\r\n        todaySupply = safeDiv(\r\n            safeMul(todayContribution, DECIMAL_NOMINATOR),\r\n            _mainTokenPrice\r\n        );\r\n\r\n        totalContribution = safeAdd(totalContribution, todayContribution);\r\n        yesterdaySupply = dayWiseSupply[auctionDay];\r\n        yesterdayContribution = todayContribution;\r\n        auctionDay = safeAdd(auctionDay, 1);\r\n        IAuctionLiquidity(liquidityAddress).auctionEnded();\r\n        dayWiseDownSideProtectionRatio[auctionDay] = downSideProtectionRatio;\r\n        LAST_AUCTION_START = safeAdd(LAST_AUCTION_START, INTERVAL);\r\n        todayContribution = 0;\r\n        emit AuctionEnded(\r\n            auctionDay,\r\n            todaySupply,\r\n            yesterdaySupply,\r\n            todayContribution,\r\n            yesterdayContribution,\r\n            totalContribution,\r\n            allowMaxContribution,\r\n            _tokenPrice,\r\n            _mainTokenPrice\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function disturbuteTokenInternal(uint256 dayId, address _which)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(\r\n            returnToken[dayId][_which] == false,\r\n            \"ERR_ALREADY_TOKEN_DISTBUTED\"\r\n        );\r\n\r\n\r\n            uint256 dayWiseContributionByWallet\r\n         = walletDayWiseContribution[dayId][_which];\r\n\r\n        uint256 dayWiseContribution = dayWiseContribution[dayId];\r\n\r\n        (\r\n            uint256 returnAmount,\r\n            uint256 _userAmount\r\n        ) = calcuateAuctionTokenDistrubution(\r\n            dayWiseContributionByWallet,\r\n            dayWiseSupplyCore[dayId],\r\n            dayWiseSupplyBonus[dayId],\r\n            dayWiseContribution,\r\n            dayWiseDownSideProtectionRatio[dayId]\r\n        );\r\n\r\n        uint256 _percent = _calculateBouns(dayId, _which);\r\n\r\n        uint256 newReturnAmount = 0;\r\n\r\n        uint256 fee = 0;\r\n\r\n        if (_percent > 0) {\r\n            newReturnAmount = safeDiv(safeMul(returnAmount, _percent), 100);\r\n            fee = calculateSupplyPercent(newReturnAmount, managementFee);\r\n        }\r\n\r\n        newReturnAmount = safeAdd(returnAmount, newReturnAmount);\r\n        IToken(mainTokenAddress).mintTokens(safeAdd(newReturnAmount, fee));\r\n\r\n        // here the last auction is checked because the user can invest after auction starts\r\n        IToken(mainTokenAddress).lockToken(_which, 0, LAST_AUCTION_START);\r\n\r\n        approveTransferFrom(\r\n            IERC20Token(mainTokenAddress),\r\n            escrowAddress,\r\n            fee\r\n        );\r\n        IEscrow(escrowAddress).depositFee(fee);\r\n        \r\n        ensureTransferFrom(\r\n            IERC20Token(mainTokenAddress),\r\n            address(this),\r\n            _which,\r\n            _userAmount\r\n        );\r\n        \r\n        approveTransferFrom(\r\n            IERC20Token(mainTokenAddress),\r\n            auctionProtectionAddress,\r\n            safeSub(newReturnAmount, _userAmount)\r\n        );\r\n    \r\n        IAuctionProtection(auctionProtectionAddress).depositToken(dayId,_which,safeSub(newReturnAmount, _userAmount));\r\n        \r\n        returnToken[dayId][_which] = true;\r\n        \r\n        emit TokenDistrubuted(\r\n            _which,\r\n            dayId,\r\n            newReturnAmount,\r\n            safeSub(newReturnAmount, _userAmount),\r\n            _userAmount\r\n        );\r\n        return true;\r\n    }\r\n    \r\n    // anyone can call this method \r\n    function disturbuteTokens(uint256 dayId, address[] calldata _which)\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(dayId < auctionDay, \"ERR_AUCTION_DAY\");\r\n        for (uint256 tempX = 0; tempX < _which.length; tempX++) {\r\n            if (returnToken[dayId][_which[tempX]] == false)\r\n                disturbuteTokenInternal(dayId, _which[tempX]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function disturbuteTokens(uint256 dayId) external returns (bool) {\r\n        require(dayId < auctionDay, \"ERR_AUCTION_DAY\");\r\n        return disturbuteTokenInternal(dayId, msg.sender);\r\n    }\r\n    \r\n    \r\n\r\n    //In case if there is other tokens into contract\r\n    function returnFund(\r\n        IERC20Token _token,\r\n        uint256 _value,\r\n        address payable _which\r\n    ) external onlyAuthorized() returns (bool) {\r\n        \r\n        require(address(_token) != mainTokenAddress ,\"ERR_CANT_TAKE_OUT_MAIN_TOKEN\");\r\n        ensureTransferFrom(_token, address(this), _which, _value);\r\n        return true;\r\n        \r\n    }\r\n\r\n    function() external payable {\r\n         revert(\"ERR_CAN'T_FORCE_ETH\");\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeSystemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMarketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_auctionDay\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"calculateBouns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrowAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LAST_AUCTION_START\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionProtectionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"topContributorIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayWiseSupplyBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"todaySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayWiseSupplyCore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mainTokenCheckDayWise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletDayWiseContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayWiseSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"auctionEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"contributeWithEtherBehalf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"downSideProtectionRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changePrimaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dayId\",\"type\":\"uint256\"},{\"name\":\"_which\",\"type\":\"address[]\"}],\"name\":\"disturbuteTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_minAuctionTime\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"},{\"name\":\"_mainTokenCheckDay\",\"type\":\"uint256\"},{\"name\":\"_primaryOwner\",\"type\":\"address\"},{\"name\":\"_systemAddress\",\"type\":\"address\"},{\"name\":\"_multisigAddress\",\"type\":\"address\"},{\"name\":\"_registryaddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctionDetails\",\"outputs\":[{\"name\":\"_todaySupply\",\"type\":\"uint256\"},{\"name\":\"_yesterdaySupply\",\"type\":\"uint256\"},{\"name\":\"_todayContribution\",\"type\":\"uint256\"},{\"name\":\"_yesterdayContribution\",\"type\":\"uint256\"},{\"name\":\"_totalContribution\",\"type\":\"uint256\"},{\"name\":\"_maxContributionAllowed\",\"type\":\"uint256\"},{\"name\":\"_marketPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMAL_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwnerInitialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayWiseDownSideProtectionRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalReturnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowMaxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"yesterdaySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pushEthToLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxContributionAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_averageDay\",\"type\":\"uint256\"}],\"name\":\"setAverageDays\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyFundWalletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"X1\",\"type\":\"uint256\"},{\"name\":\"X2\",\"type\":\"uint256\"},{\"name\":\"X3\",\"type\":\"uint256\"},{\"name\":\"X4\",\"type\":\"uint256\"},{\"name\":\"X5\",\"type\":\"uint256\"}],\"name\":\"updateIndividualBonusRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_flag\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"changeTimings\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundWalletRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_groupBonusRatio\",\"type\":\"uint256\"}],\"name\":\"setGroupBonusRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"yesterdayContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"averageDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"groupBonusRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainTokencheckDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"returnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dayId\",\"type\":\"uint256\"}],\"name\":\"disturbuteTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mainTokencheckDay\",\"type\":\"uint256\"}],\"name\":\"setMainTokenCheckDay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayWiseMarketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managementFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_AUCTION_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainTokenRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateCurrentMarketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENT_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contributeWithEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"returnFund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateRegistery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"smartSwapAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"setMainTokenRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currencyPricesAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"todayContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxContributionAllowed\",\"type\":\"uint256\"}],\"name\":\"setMaxContributionAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topFiveContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"setDownSideProtectionRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"setfundWalletRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staking\",\"type\":\"uint256\"}],\"name\":\"setstakingPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayWiseContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_auctionDayId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_todayContribution\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_fundBy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_fundToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fundAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fundValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalFund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_marketPrice\",\"type\":\"uint256\"}],\"name\":\"FundAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"FundAddedBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_auctionDayId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_todaySupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_yesterdaySupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_todayContribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_yesterdayContribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalContribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_maxContributionAllowed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenMarketPrice\",\"type\":\"uint256\"}],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_whom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dayId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockedToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_userToken\",\"type\":\"uint256\"}],\"name\":\"TokenDistrubuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerType\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AuthorityAddressChnageCall\",\"type\":\"event\"}]","ContractName":"Auction","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1618d9d97319acdb9ed673ede3ffc7403fd0bb80e5b02ead15b7e6c9e5ca73eb"}]}