{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.1.0\r\n\r\nMAX_COINS: constant(int128) = 8\r\n\r\nZA: constant(address) = ZERO_ADDRESS\r\nEMPTY_ADDRESS_ARRAY: constant(address[MAX_COINS]) = [ZA, ZA, ZA, ZA, ZA, ZA, ZA, ZA]\r\n\r\nZERO: constant(uint256) = convert(0, uint256)\r\nEMPTY_UINT256_ARRAY: constant(uint256[MAX_COINS]) = [ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]\r\n\r\nCALC_INPUT_SIZE: constant(int128) = 100\r\n\r\n\r\nstruct PoolArray:\r\n    location: uint256\r\n    decimals: bytes32\r\n    underlying_decimals: bytes32\r\n    rate_method_id: bytes32\r\n    lp_token: address\r\n    coins: address[MAX_COINS]\r\n    ul_coins: address[MAX_COINS]\r\n    calculator: address\r\n\r\nstruct PoolCoins:\r\n    coins: address[MAX_COINS]\r\n    underlying_coins: address[MAX_COINS]\r\n    decimals: uint256[MAX_COINS]\r\n    underlying_decimals: uint256[MAX_COINS]\r\n\r\nstruct PoolInfo:\r\n    balances: uint256[MAX_COINS]\r\n    underlying_balances: uint256[MAX_COINS]\r\n    decimals: uint256[MAX_COINS]\r\n    underlying_decimals: uint256[MAX_COINS]\r\n    lp_token: address\r\n    A: uint256\r\n    fee: uint256\r\n\r\n\r\ncontract ERC20:\r\n    def decimals() -> uint256: constant\r\n    def balanceOf(addr: address) -> uint256: constant\r\n    def approve(spender: address, amount: uint256) -> bool: modifying\r\n    def transfer(to: address, amount: uint256) -> bool: modifying\r\n    def transferFrom(spender: address, to: address, amount: uint256) -> bool: modifying\r\n\r\ncontract CurvePool:\r\n    def A() -> uint256: constant\r\n    def fee() -> uint256: constant\r\n    def coins(i: int128) -> address: constant\r\n    def underlying_coins(i: int128) -> address: constant\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: constant\r\n    def get_dy_underlying(i: int128, j: int128, dx: uint256) -> uint256: constant\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): modifying\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): modifying\r\n\r\ncontract GasEstimator:\r\n    def estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256: constant\r\n\r\ncontract Calculator:\r\n    def get_dx(n_coins: int128, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS], underlying: bool,\r\n               i: int128, j: int128, dx: uint256) -> uint256: constant\r\n    def get_dy(n_coins: int128, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS], underlying: bool,\r\n               i: int128, j: int128, dx: uint256[CALC_INPUT_SIZE]) -> uint256[CALC_INPUT_SIZE]: constant\r\n\r\n\r\nCommitNewAdmin: event({deadline: indexed(uint256), admin: indexed(address)})\r\nNewAdmin: event({admin: indexed(address)})\r\nTokenExchange: event({\r\n    buyer: indexed(address),\r\n    pool: indexed(address),\r\n    token_sold: address,\r\n    token_bought: address,\r\n    amount_sold: uint256,\r\n    amount_bought: uint256\r\n})\r\nPoolAdded: event({pool: indexed(address), rate_method_id: bytes[4]})\r\nPoolRemoved: event({pool: indexed(address)})\r\n\r\n\r\nadmin: public(address)\r\ntransfer_ownership_deadline: uint256\r\nfuture_admin: address\r\n\r\npool_list: public(address[65536])   # master list of pools\r\npool_count: public(uint256)         # actual length of pool_list\r\n\r\npool_data: map(address, PoolArray)\r\nreturns_none: map(address, bool)\r\n\r\n# mapping of estimated gas costs for pools and coins\r\n# for a pool the values are [wrapped exchange, underlying exchange]\r\n# for a coin the values are [transfer cost, 0]\r\ngas_estimate_values: map(address, uint256[2])\r\n\r\n# pool -> gas estimation contract\r\n# used when gas costs for a pool are too complex to be handled by summing\r\n# values in `gas_estimate_values`\r\ngas_estimate_contracts: map(address, address)\r\n\r\n# mapping of coin -> coin -> pools for trading\r\n# all addresses are converted to uint256 prior to storage. coin addresses are stored\r\n# using the smaller value first. within each pool address array, the first value\r\n# is shifted 16 bits to the left, and these 16 bits are used to store the array length.\r\n\r\nmarkets: map(uint256, map(uint256, uint256[65536]))\r\n\r\n\r\n@public\r\ndef __init__(_returns_none: address[4]):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    @param _returns_none Token addresses that return None on a successful transfer\r\n    \"\"\"\r\n    self.admin = msg.sender\r\n    for _addr in _returns_none:\r\n        if _addr == ZERO_ADDRESS:\r\n            break\r\n        self.returns_none[_addr] = True\r\n\r\n\r\n@public\r\n@payable\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@public\r\n@constant\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @dev For coins where there is no underlying coin, or where\r\n         the underlying coin cannot be swapped, the rate is\r\n         given as 1e18\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n\r\n    _first: uint256 = min(convert(_from, uint256), convert(_to, uint256))\r\n    _second: uint256 = max(convert(_from, uint256), convert(_to, uint256))\r\n\r\n    if i == 0:\r\n        _addr: uint256 = shift(self.markets[_first][_second][0], -16)\r\n        return convert(convert(_addr, bytes32), address)\r\n\r\n    return convert(convert(self.markets[_first][_second][i], bytes32), address)\r\n\r\n\r\n@public\r\n@constant\r\ndef get_pool_coins(_pool: address) -> PoolCoins:\r\n    \"\"\"\r\n    @notice Get information on coins in a pool\r\n    @dev Empty values in the returned arrays may be ignored\r\n    @param _pool Pool address\r\n    @return Coin addresses, underlying coin addresses, underlying coin decimals\r\n    \"\"\"\r\n    _coins: PoolCoins = PoolCoins({\r\n        coins: EMPTY_ADDRESS_ARRAY,\r\n        underlying_coins: EMPTY_ADDRESS_ARRAY,\r\n        decimals: EMPTY_UINT256_ARRAY,\r\n        underlying_decimals: EMPTY_UINT256_ARRAY,\r\n    })\r\n    _decimals_packed: bytes32 = self.pool_data[_pool].decimals\r\n    _udecimals_packed: bytes32 = self.pool_data[_pool].underlying_decimals\r\n\r\n    for i in range(MAX_COINS):\r\n        _coins.coins[i] = self.pool_data[_pool].coins[i]\r\n        if _coins.coins[i] == ZERO_ADDRESS:\r\n            break\r\n        _coins.underlying_coins[i] = self.pool_data[_pool].ul_coins[i]\r\n        _coins.decimals[i] = convert(slice(_decimals_packed, i, 1), uint256)\r\n        _coins.underlying_decimals[i] = convert(slice(_udecimals_packed, i, 1), uint256)\r\n\r\n    return _coins\r\n\r\n\r\n@public\r\ndef get_pool_info(_pool: address) -> PoolInfo:\r\n    \"\"\"\r\n    @notice Get information on a pool\r\n    @dev Reverts if the pool address is unknown\r\n    @param _pool Pool address\r\n    @return balances, underlying balances, decimals, underlying decimals,\r\n            lp token, amplification coefficient, fees\r\n    \"\"\"\r\n    _pool_info: PoolInfo = PoolInfo({\r\n        balances: EMPTY_UINT256_ARRAY,\r\n        underlying_balances: EMPTY_UINT256_ARRAY,\r\n        decimals: EMPTY_UINT256_ARRAY,\r\n        underlying_decimals: EMPTY_UINT256_ARRAY,\r\n        lp_token: self.pool_data[_pool].lp_token,\r\n        A: CurvePool(_pool).A(),\r\n        fee: CurvePool(_pool).fee()\r\n    })\r\n\r\n    _rate_method_id: bytes[4] = slice(self.pool_data[_pool].rate_method_id, 0, 4)\r\n    _decimals_packed: bytes32 = self.pool_data[_pool].decimals\r\n    _udecimals_packed: bytes32 = self.pool_data[_pool].underlying_decimals\r\n\r\n    for i in range(MAX_COINS):\r\n        _coin: address = self.pool_data[_pool].coins[i]\r\n        if _coin == ZERO_ADDRESS:\r\n            assert i != 0\r\n            break\r\n\r\n        _pool_info.decimals[i] = convert(slice(_decimals_packed, i, 1), uint256)\r\n        _pool_info.underlying_decimals[i] = convert(slice(_udecimals_packed, i, 1), uint256)\r\n\r\n        if _coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            _pool_info.balances[i] = as_unitless_number(self.balance)\r\n        else:\r\n            _pool_info.balances[i] = ERC20(_coin).balanceOf(_pool)\r\n\r\n        _underlying_coin: address = self.pool_data[_pool].ul_coins[i]\r\n        if _coin == _underlying_coin:\r\n            _pool_info.underlying_balances[i] = _pool_info.balances[i]\r\n        elif _underlying_coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            _pool_info.underlying_balances[i] = as_unitless_number(self.balance)\r\n        elif _underlying_coin != ZERO_ADDRESS:\r\n            _response: bytes[32] = raw_call(_coin, _rate_method_id, outsize=32)  # dev: bad response\r\n            _rate: uint256 = convert(_response, uint256)\r\n            _pool_info.underlying_balances[i] = _pool_info.balances[i] * _rate / 10 ** 18\r\n\r\n    return _pool_info\r\n\r\n\r\n@public\r\ndef get_pool_rates(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get rates between coins and underlying coins\r\n    @dev For coins where there is no underlying coin, or where\r\n         the underlying coin cannot be swapped, the rate is\r\n         given as 1e18\r\n    @param _pool Pool address\r\n    @return Rates between coins and underlying coins\r\n    \"\"\"\r\n    _rates: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _rate_method_id: bytes[4] = slice(self.pool_data[_pool].rate_method_id, 0, 4)\r\n    for i in range(MAX_COINS):\r\n        _coin: address = self.pool_data[_pool].coins[i]\r\n        if _coin == ZERO_ADDRESS:\r\n            break\r\n        if _coin == self.pool_data[_pool].ul_coins[i]:\r\n            _rates[i] = 10 ** 18\r\n        else:\r\n            _response: bytes[32] = raw_call(_coin, _rate_method_id, outsize=32)  # dev: bad response\r\n            _rates[i] = convert(_response, uint256)\r\n\r\n    return _rates\r\n\r\n\r\n@private\r\n@constant\r\ndef _get_token_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (int128, int128, bool):\r\n    \"\"\"\r\n    Convert coin addresses to indices for use with pool methods.\r\n    \"\"\"\r\n    i: int128 = -1\r\n    j: int128 = -1\r\n    _coin: address = ZERO_ADDRESS\r\n    _check_underlying: bool = True\r\n\r\n    # check coin markets\r\n    for x in range(MAX_COINS):\r\n        _coin = self.pool_data[_pool].coins[x]\r\n        if _coin == _from:\r\n            i = x\r\n        elif _coin == _to:\r\n            j = x\r\n        elif _coin == ZERO_ADDRESS:\r\n            break\r\n        else:\r\n            continue\r\n        if min(i, j) > -1:\r\n            return i, j, False\r\n        if _coin != self.pool_data[_pool].ul_coins[x]:\r\n            _check_underlying = False\r\n\r\n    assert _check_underlying, \"No available market\"\r\n\r\n    # check underlying coin markets\r\n    for x in range(MAX_COINS):\r\n        _coin = self.pool_data[_pool].ul_coins[x]\r\n        if _coin == _from:\r\n            i = x\r\n        elif _coin == _to:\r\n            j = x\r\n        elif _coin == ZERO_ADDRESS:\r\n            break\r\n        else:\r\n            continue\r\n        if min(i, j) > -1:\r\n            return i, j, True\r\n\r\n    raise \"No available market\"\r\n\r\n\r\n@public\r\n@constant\r\ndef estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256:\r\n    \"\"\"\r\n    @notice Estimate the gas used in an exchange.\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @return Upper-bound gas estimate, in wei\r\n    \"\"\"\r\n    _estimator: address = self.gas_estimate_contracts[_pool]\r\n    if _estimator != ZERO_ADDRESS:\r\n        return GasEstimator(_estimator).estimate_gas_used(_pool, _from, _to)\r\n\r\n    # here we call `_get_token_indices` to find out if the exchange involves\r\n    # wrapped or underlying coins, and convert the result to an integer that we\r\n    # use as an index for `gas_estimate_values`\r\n    # 0 == wrapped   1 == underlying\r\n    _idx_underlying: int128 = convert(\r\n        self._get_token_indices(_pool, _from, _to)[2],\r\n        int128\r\n    )\r\n\r\n    _total: uint256 = self.gas_estimate_values[_pool][_idx_underlying]\r\n    assert _total != 0  # dev: pool value not set\r\n\r\n    for _addr in [_from, _to]:\r\n        _gas: uint256 = self.gas_estimate_values[_addr][0]\r\n        assert _gas != 0  # dev: coin value not set\r\n        _total += _gas\r\n\r\n    return _total\r\n\r\n\r\n@public\r\n@constant\r\ndef get_exchange_amount(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    _is_underlying: bool = False\r\n    i, j, _is_underlying = self._get_token_indices(_pool, _from, _to)\r\n\r\n    if _is_underlying:\r\n        return CurvePool(_pool).get_dy_underlying(i, j, _amount)\r\n    else:\r\n        return CurvePool(_pool).get_dy(i, j, _amount)\r\n\r\n\r\n@public\r\n@payable\r\n@nonreentrant(\"lock\")\r\ndef exchange(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Perform an exchange.\r\n    @dev Prior to calling this function you must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @return True\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    _is_underlying: bool = False\r\n    i, j, _is_underlying = self._get_token_indices(_pool, _from, _to)\r\n\r\n    # record initial balance\r\n    _initial_balance: uint256 = 0\r\n    if _to == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        _initial_balance = as_unitless_number(self.balance - msg.value)\r\n    else:\r\n        _initial_balance = ERC20(_to).balanceOf(self)\r\n\r\n    # perform / verify input transfer\r\n    if _from == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        assert _amount == msg.value, \"Incorrect ETH amount\"\r\n    elif self.returns_none[_from]:\r\n        ERC20(_from).transferFrom(msg.sender, self, _amount)\r\n    else:\r\n        assert_modifiable(ERC20(_from).transferFrom(msg.sender, self, _amount))\r\n\r\n    # perform coin exchange\r\n    if _is_underlying:\r\n        CurvePool(_pool).exchange_underlying(i, j, _amount, _expected, value=msg.value)\r\n    else:\r\n        CurvePool(_pool).exchange(i, j, _amount, _expected, value=msg.value)\r\n\r\n    # perform output transfer\r\n    _received: uint256 = 0\r\n    if _to == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        _received = as_unitless_number(self.balance) - _initial_balance\r\n        send(msg.sender, _received)\r\n    else:\r\n        _received = ERC20(_to).balanceOf(self) - _initial_balance\r\n        if self.returns_none[_to]:\r\n            ERC20(_to).transfer(msg.sender, _received)\r\n        else:\r\n            assert_modifiable(ERC20(_to).transfer(msg.sender, _received))\r\n\r\n    log.TokenExchange(msg.sender, _pool, _from, _to, _amount, _received)\r\n\r\n    return True\r\n\r\n\r\n@public\r\ndef get_input_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins required to receive the given amount in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_to` to be received\r\n    @return Quantity of `_from` to be sent\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    _is_underlying: bool = False\r\n    i, j, _is_underlying = self._get_token_indices(_pool, _from, _to)\r\n\r\n    _amp: uint256 = CurvePool(_pool).A()\r\n    _fee: uint256 = CurvePool(_pool).fee()\r\n\r\n    _decimals_packed: bytes32 = EMPTY_BYTES32\r\n    if _is_underlying:\r\n        _decimals_packed = self.pool_data[_pool].underlying_decimals\r\n    else:\r\n        _decimals_packed = self.pool_data[_pool].decimals\r\n\r\n    _rates: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _balances: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _precisions: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _n_coins: int128 = 0\r\n    _coin: address = ZERO_ADDRESS\r\n    for x in range(MAX_COINS):\r\n        _coin = self.pool_data[_pool].coins[x]\r\n\r\n        if _coin == ZERO_ADDRESS:\r\n            _n_coins = x\r\n            break\r\n\r\n        if _coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            _balances[x] = as_unitless_number(self.balance)\r\n        else:\r\n            _balances[x] = ERC20(_coin).balanceOf(_pool)\r\n\r\n\r\n        _decimals: uint256 = convert(slice(_decimals_packed, x, 1), uint256)\r\n        _precisions[x] = 10 ** (18 - _decimals)\r\n\r\n        if _coin == self.pool_data[_pool].ul_coins[x]:\r\n            _rates[x] = 10 ** 18\r\n        else:\r\n            _rate_method_id: bytes[4] = slice(self.pool_data[_pool].rate_method_id, 0, 4)\r\n            _response: bytes[32] = raw_call(_coin, _rate_method_id, outsize=32)  # dev: bad response\r\n            _rates[x] = convert(_response, uint256)\r\n\r\n    return Calculator(self.pool_data[_pool].calculator).get_dx(\r\n        _n_coins, _balances, _amp, _fee, _rates, _precisions, _is_underlying, i, j, _amount\r\n    )\r\n\r\n\r\n@public\r\ndef get_exchange_amounts(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amounts: uint256[CALC_INPUT_SIZE]\r\n) -> uint256[CALC_INPUT_SIZE]:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in exchanges of varying amounts\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amounts Array of quantities of `_from` to be sent\r\n    @return Array of quantities of `_to` to be received\r\n    \"\"\"\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    _is_underlying: bool = False\r\n    i, j, _is_underlying = self._get_token_indices(_pool, _from, _to)\r\n\r\n    _amp: uint256 = CurvePool(_pool).A()\r\n    _fee: uint256 = CurvePool(_pool).fee()\r\n\r\n    _decimals_packed: bytes32 = EMPTY_BYTES32\r\n    if _is_underlying:\r\n        _decimals_packed = self.pool_data[_pool].underlying_decimals\r\n    else:\r\n        _decimals_packed = self.pool_data[_pool].decimals\r\n\r\n    _rates: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _balances: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _precisions: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _n_coins: int128 = 0\r\n    _coin: address = ZERO_ADDRESS\r\n    for x in range(MAX_COINS):\r\n        _coin = self.pool_data[_pool].coins[x]\r\n\r\n        if _coin == ZERO_ADDRESS:\r\n            _n_coins = x\r\n            break\r\n\r\n        if _coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            _balances[x] = as_unitless_number(self.balance)\r\n        else:\r\n            _balances[x] = ERC20(_coin).balanceOf(_pool)\r\n\r\n        _decimals: uint256 = convert(slice(_decimals_packed, x, 1), uint256)\r\n        _precisions[x] = 10 ** (18 - _decimals)\r\n\r\n        if _coin == self.pool_data[_pool].ul_coins[x]:\r\n            _rates[x] = 10 ** 18\r\n        else:\r\n            _rate_method_id: bytes[4] = slice(self.pool_data[_pool].rate_method_id, 0, 4)\r\n            _response: bytes[32] = raw_call(_coin, _rate_method_id, outsize=32)  # dev: bad response\r\n            _rates[x] = convert(_response, uint256)\r\n\r\n    return Calculator(self.pool_data[_pool].calculator).get_dy(\r\n        _n_coins, _balances, _amp, _fee, _rates, _precisions, _is_underlying, i, j, _amounts\r\n    )\r\n\r\n\r\n# Admin functions\r\n\r\n@private\r\ndef _add_pool(\r\n    _pool: address,\r\n    _n_coins: int128,\r\n    _lp_token: address,\r\n    _calculator: address,\r\n    _rate_method_id: bytes32,\r\n    _coins: address[MAX_COINS],\r\n    _ucoins: address[MAX_COINS],\r\n    _decimals: bytes32,\r\n    _udecimals: bytes32,\r\n):\r\n    # add pool to pool_list\r\n    _length: uint256 = self.pool_count\r\n    self.pool_list[_length] = _pool\r\n    self.pool_count = _length + 1\r\n    self.pool_data[_pool].location = _length\r\n    self.pool_data[_pool].lp_token = _lp_token\r\n    self.pool_data[_pool].calculator = _calculator\r\n    self.pool_data[_pool].rate_method_id = _rate_method_id\r\n\r\n    _decimals_packed: uint256 = 0\r\n    _udecimals_packed: uint256 = 0\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        # add decimals\r\n        _value: uint256 = convert(slice(_decimals, i, 1), uint256)\r\n        if _value == 0:\r\n            if _coins[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n                _value = 18\r\n            else:\r\n                _value = ERC20(_coins[i]).decimals()\r\n                assert _value < 256  # dev: decimal overflow\r\n\r\n        _decimals_packed += shift(_value, (31-i) * 8)\r\n\r\n        if _ucoins[i] != ZERO_ADDRESS:\r\n            _value = convert(slice(_udecimals, i, 1), uint256)\r\n            if _value == 0:\r\n                if _ucoins[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n                    _value = 18\r\n                else:\r\n                    _value = ERC20(_ucoins[i]).decimals()\r\n                    assert _value < 256  # dev: decimal overflow\r\n\r\n            _udecimals_packed += shift(_value, (31-i) * 8)\r\n\r\n        # add pool to markets\r\n        for x in range(i, i + MAX_COINS):\r\n            if x == i:\r\n                continue\r\n            if x == _n_coins:\r\n                break\r\n\r\n            _first: uint256 = min(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n            _second: uint256 = max(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n\r\n            _pool_zero: uint256 = self.markets[_first][_second][0]\r\n            if _pool_zero != 0:\r\n                _length = _pool_zero % 65536\r\n                self.markets[_first][_second][_length] = convert(_pool, uint256)\r\n                self.markets[_first][_second][0] = _pool_zero + 1\r\n            else:\r\n                self.markets[_first][_second][0] = shift(convert(_pool, uint256), 16) + 1\r\n\r\n            if _ucoins[i] == ZERO_ADDRESS:\r\n                continue\r\n            if _ucoins[x] == ZERO_ADDRESS:\r\n                continue\r\n            if _ucoins[i] == _coins[i] and _ucoins[x] == _coins[x]:\r\n                continue\r\n\r\n            _first = min(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n            _second = max(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n\r\n            _pool_zero = self.markets[_first][_second][0]\r\n\r\n            if _pool_zero != 0:\r\n                _length = _pool_zero % 65536\r\n                self.markets[_first][_second][_length] = convert(_pool, uint256)\r\n                self.markets[_first][_second][0] = _pool_zero + 1\r\n            else:\r\n                self.markets[_first][_second][0] = shift(convert(_pool, uint256), 16) + 1\r\n\r\n    self.pool_data[_pool].decimals = convert(_decimals_packed, bytes32)\r\n    self.pool_data[_pool].underlying_decimals = convert(_udecimals_packed, bytes32)\r\n    log.PoolAdded(_pool, slice(_rate_method_id, 0, 4))\r\n\r\n\r\n@public\r\ndef add_pool(\r\n    _pool: address,\r\n    _n_coins: int128,\r\n    _lp_token: address,\r\n    _calculator: address,\r\n    _rate_method_id: bytes32,\r\n    _decimals: bytes32,\r\n    _underlying_decimals: bytes32,\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _rate_method_id Encoded four-byte function signature to query\r\n                           coin rates, right padded to bytes32\r\n    @param _decimals Coin decimal values, tightly packed as uint8 and right\r\n                     padded as bytes32\r\n    @param _underlying_decimals Underlying coin decimal values, tightly packed\r\n                                as uint8 and right padded as bytes32\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n\r\n    _coins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n    _ucoins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        # add coin\r\n        _coins[i] = CurvePool(_pool).coins(i)\r\n        if _coins[i] != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            ERC20(_coins[i]).approve(_pool, MAX_UINT256)\r\n        self.pool_data[_pool].coins[i] = _coins[i]\r\n\r\n        # add underlying coin\r\n        _ucoins[i] = CurvePool(_pool).underlying_coins(i)\r\n        if _ucoins[i] != _coins[i]:\r\n            if _ucoins[i] != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n                ERC20(_ucoins[i]).approve(_pool, MAX_UINT256)\r\n        self.pool_data[_pool].ul_coins[i] = _ucoins[i]\r\n\r\n    self._add_pool(\r\n        _pool,\r\n        _n_coins,\r\n        _lp_token,\r\n        _calculator,\r\n        _rate_method_id,\r\n        _coins,\r\n        _ucoins,\r\n        _decimals,\r\n        _underlying_decimals\r\n    )\r\n\r\n\r\n@public\r\ndef add_pool_without_underlying(\r\n    _pool: address,\r\n    _n_coins: int128,\r\n    _lp_token: address,\r\n    _calculator: address,\r\n    _rate_method_id: bytes32,\r\n    _decimals: bytes32,\r\n    _use_rates: bytes32,\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _rate_method_id Encoded four-byte function signature to query\r\n                           coin rates, right padded as bytes32\r\n    @param _decimals Coin decimal values, tightly packed as uint8 and right\r\n                     padded as bytes32\r\n    @param _use_rates Boolean array indicating which coins use lending rates,\r\n                      tightly packed and right padded as bytes32\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n\r\n    _coins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n    _ucoins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n    _use_rates_mem: bytes32 = _use_rates\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        # add coin\r\n        _coins[i] = CurvePool(_pool).coins(i)\r\n        if _coins[i] != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            ERC20(_coins[i]).approve(_pool, MAX_UINT256)\r\n        self.pool_data[_pool].coins[i] = _coins[i]\r\n\r\n        # add underlying coin\r\n        if not convert(slice(_use_rates_mem, i, 1), bool):\r\n            _ucoins[i] = _coins[i]\r\n            self.pool_data[_pool].ul_coins[i] = _ucoins[i]\r\n\r\n    self._add_pool(\r\n        _pool,\r\n        _n_coins,\r\n        _lp_token,\r\n        _calculator,\r\n        _rate_method_id,\r\n        _coins,\r\n        _ucoins,\r\n        _decimals,\r\n        EMPTY_BYTES32\r\n    )\r\n\r\n\r\n@public\r\ndef remove_pool(_pool: address):\r\n    \"\"\"\r\n    @notice Remove a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to remove\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS  # dev: pool does not exist\r\n\r\n    # remove _pool from pool_list\r\n    _location: uint256 = self.pool_data[_pool].location\r\n    _length: uint256 = self.pool_count - 1\r\n\r\n    if _location < _length:\r\n        # replace _pool with final value in pool_list\r\n        _addr: address = self.pool_list[_length]\r\n        self.pool_list[_location] = _addr\r\n        self.pool_data[_addr].location = _location\r\n\r\n    # delete final pool_list value\r\n    self.pool_list[_length] = ZERO_ADDRESS\r\n    self.pool_count = _length\r\n\r\n    _coins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n    _ucoins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n\r\n    for i in range(MAX_COINS):\r\n        _coins[i] = self.pool_data[_pool].coins[i]\r\n        if _coins[i] == ZERO_ADDRESS:\r\n            break\r\n\r\n        # delete coin address from pool_data\r\n        self.pool_data[_pool].coins[i] = ZERO_ADDRESS\r\n\r\n        # delete underlying_coin from pool_data\r\n        _ucoins[i] = self.pool_data[_pool].ul_coins[i]\r\n        self.pool_data[_pool].ul_coins[i] = ZERO_ADDRESS\r\n\r\n    for i in range(MAX_COINS):\r\n        if _coins[i] == ZERO_ADDRESS:\r\n            break\r\n\r\n        # remove pool from markets\r\n        for x in range(i, i + MAX_COINS):\r\n            if x == i:\r\n                continue\r\n            if _coins[x] == ZERO_ADDRESS:\r\n                break\r\n\r\n            _first: uint256 = min(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n            _second: uint256 = max(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n\r\n            _pool_zero: uint256 = self.markets[_first][_second][0]\r\n            _length = _pool_zero % 65536 - 1\r\n            if _length == 0:\r\n                self.markets[_first][_second][0] = 0\r\n            elif shift(_pool_zero, -16) == convert(_pool, uint256):\r\n                self.markets[_first][_second][0] = shift(self.markets[_first][_second][_length], 16) + _length\r\n                self.markets[_first][_second][_length] = 0\r\n            else:\r\n                self.markets[_first][_second][0] = _pool_zero - 1\r\n                for n in range(1, 65536):\r\n                    if n == convert(_length, int128):\r\n                        break\r\n                    if self.markets[_first][_second][n] == convert(_pool, uint256):\r\n                        self.markets[_first][_second][n] = self.markets[_first][_second][_length]\r\n                self.markets[_first][_second][_length] = 0\r\n\r\n            if _ucoins[i] == _coins[i] and _ucoins[x] == _coins[x]:\r\n                continue\r\n\r\n            _first = min(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n            _second = max(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n            _pool_zero = self.markets[_first][_second][0]\r\n            _length = _pool_zero % 65536 - 1\r\n            if _length == 0:\r\n                self.markets[_first][_second][0] = 0\r\n            elif shift(_pool_zero, -16) == convert(_pool, uint256):\r\n                self.markets[_first][_second][0] = shift(self.markets[_first][_second][_length], 16) + _length\r\n                self.markets[_first][_second][_length] = 0\r\n            else:\r\n                self.markets[_first][_second][0] = _pool_zero - 1\r\n                for n in range(1, 65536):\r\n                    if n == convert(_length, int128):\r\n                        break\r\n                    if self.markets[_first][_second][n] == convert(_pool, uint256):\r\n                        self.markets[_first][_second][n] = self.markets[_first][_second][_length]\r\n                self.markets[_first][_second][_length] = 0\r\n\r\n    log.PoolRemoved(_pool)\r\n\r\n\r\n@public\r\ndef set_returns_none(_addr: address, _is_returns_none: bool):\r\n    \"\"\"\r\n    @notice Set `returns_none` value for a coin\r\n    @param _addr Coin address\r\n    @param _is_returns_none if True, coin returns None on a successful transfer\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.returns_none[_addr] = _is_returns_none\r\n\r\n\r\n@public\r\ndef set_pool_gas_estimates(_addr: address[5], _amount: uint256[2][5]):\r\n    \"\"\"\r\n    @notice Set gas estimate amounts\r\n    @param _addr Array of pool addresses\r\n    @param _amount Array of gas estimate amounts as `[(wrapped, underlying), ..]`\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    for i in range(5):\r\n        if _addr[i] == ZERO_ADDRESS:\r\n            break\r\n        self.gas_estimate_values[_addr[i]] = _amount[i]\r\n\r\n\r\n@public\r\ndef set_coin_gas_estimates(_addr: address[10], _amount: uint256[10]):\r\n    \"\"\"\r\n    @notice Set gas estimate amounts\r\n    @param _addr Array of coin addresses\r\n    @param _amount Array of gas estimate amounts\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    for i in range(10):\r\n        if _addr[i] == ZERO_ADDRESS:\r\n            break\r\n        self.gas_estimate_values[_addr[i]][0] = _amount[i]\r\n\r\n\r\n@public\r\ndef set_gas_estimate_contract(_pool: address, _estimator: address):\r\n    \"\"\"\r\n    @notice Set gas estimate contract\r\n    @param _pool Pool address\r\n    @param _estimator GasEstimator address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.gas_estimate_contracts[_pool] = _estimator\r\n\r\n\r\n@public\r\ndef set_calculator(_pool: address, _calculator: address):\r\n    \"\"\"\r\n    @notice Set calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _pool Pool address\r\n    @param _calculator `CurveCalc` address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.pool_data[_pool].calculator = _calculator\r\n\r\n\r\n@public\r\n@constant\r\ndef get_calculator(_pool: address) -> address:\r\n    return self.pool_data[_pool].calculator\r\n\r\n\r\n@public\r\ndef commit_transfer_ownership(_new_admin: address):\r\n    \"\"\"\r\n    @notice Initiate a transfer of contract ownership\r\n    @dev Once initiated, the actual transfer may be performed three days later\r\n    @param _new_admin Address of the new owner account\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.transfer_ownership_deadline == 0  # dev: transfer already active\r\n\r\n    _deadline: uint256 = as_unitless_number(block.timestamp) + 3*86400\r\n    self.transfer_ownership_deadline = _deadline\r\n    self.future_admin = _new_admin\r\n\r\n    log.CommitNewAdmin(_deadline, _new_admin)\r\n\r\n\r\n@public\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Finalize a transfer of contract ownership\r\n    @dev May only be called by the current owner, three days after a\r\n         call to `commit_transfer_ownership`\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.transfer_ownership_deadline != 0  # dev: transfer not active\r\n    assert block.timestamp >= self.transfer_ownership_deadline  # dev: now < deadline\r\n\r\n    _new_admin: address = self.future_admin\r\n    self.admin = _new_admin\r\n    self.transfer_ownership_deadline = 0\r\n\r\n    log.NewAdmin(_new_admin)\r\n\r\n\r\n@public\r\ndef revert_transfer_ownership():\r\n    \"\"\"\r\n    @notice Revert a transfer of contract ownership\r\n    @dev May only be called by the current owner\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.transfer_ownership_deadline = 0\r\n\r\n\r\n@public\r\ndef claim_token_balance(_token: address):\r\n    \"\"\"\r\n    @notice Transfer any ERC20 balance held by this contract\r\n    @dev The entire balance is transferred to `self.admin`\r\n    @param _token Token address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    _balance: uint256 = ERC20(_token).balanceOf(self)\r\n    ERC20(_token).transfer(msg.sender, _balance)\r\n\r\n\r\n@public\r\ndef claim_eth_balance():\r\n    \"\"\"\r\n    @notice Transfer ether balance held by this contract\r\n    @dev The entire balance is transferred to `self.admin`\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    send(msg.sender, self.balance)","ABI":"[{\"name\":\"CommitNewAdmin\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"deadline\",\"indexed\":true},{\"type\":\"address\",\"name\":\"admin\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewAdmin\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchange\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true},{\"type\":\"address\",\"name\":\"token_sold\",\"indexed\":false},{\"type\":\"address\",\"name\":\"token_bought\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount_sold\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount_bought\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true},{\"type\":\"bytes\",\"name\":\"rate_method_id\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolRemoved\",\"inputs\":[{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address[4]\",\"name\":\"_returns_none\"}],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"constant\":false,\"payable\":true,\"type\":\"fallback\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"constant\":true,\"payable\":false,\"type\":\"function\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"i\"}],\"constant\":true,\"payable\":false,\"type\":\"function\"},{\"name\":\"get_pool_coins\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"address[8]\",\"name\":\"coins\"},{\"type\":\"address[8]\",\"name\":\"underlying_coins\"},{\"type\":\"uint256[8]\",\"name\":\"decimals\"},{\"type\":\"uint256[8]\",\"name\":\"underlying_decimals\"}]}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":45681},{\"name\":\"get_pool_info\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"uint256[8]\",\"name\":\"balances\"},{\"type\":\"uint256[8]\",\"name\":\"underlying_balances\"},{\"type\":\"uint256[8]\",\"name\":\"decimals\"},{\"type\":\"uint256[8]\",\"name\":\"underlying_decimals\"},{\"type\":\"address\",\"name\":\"lp_token\"},{\"type\":\"uint256\",\"name\":\"A\"},{\"type\":\"uint256\",\"name\":\"fee\"}]}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":87733},{\"name\":\"get_pool_rates\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":44706},{\"name\":\"estimate_gas_used\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":50163},{\"name\":\"get_exchange_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":45192},{\"name\":\"exchange\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":198813},{\"name\":\"get_input_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":135410},{\"name\":\"get_exchange_amounts\",\"outputs\":[{\"type\":\"uint256[100]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256[100]\",\"name\":\"_amounts\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":138709},{\"name\":\"add_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"int128\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"bytes32\",\"name\":\"_rate_method_id\"},{\"type\":\"bytes32\",\"name\":\"_decimals\"},{\"type\":\"bytes32\",\"name\":\"_underlying_decimals\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":10290194},{\"name\":\"add_pool_without_underlying\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"int128\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"bytes32\",\"name\":\"_rate_method_id\"},{\"type\":\"bytes32\",\"name\":\"_decimals\"},{\"type\":\"bytes32\",\"name\":\"_use_rates\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":10273690},{\"name\":\"remove_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":317792223500},{\"name\":\"set_returns_none\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_addr\"},{\"type\":\"bool\",\"name\":\"_is_returns_none\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":36818},{\"name\":\"set_pool_gas_estimates\",\"outputs\":[],\"inputs\":[{\"type\":\"address[5]\",\"name\":\"_addr\"},{\"type\":\"uint256[2][5]\",\"name\":\"_amount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":354727},{\"name\":\"set_coin_gas_estimates\",\"outputs\":[],\"inputs\":[{\"type\":\"address[10]\",\"name\":\"_addr\"},{\"type\":\"uint256[10]\",\"name\":\"_amount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":356796},{\"name\":\"set_gas_estimate_contract\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_estimator\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":36911},{\"name\":\"set_calculator\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_calculator\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37019},{\"name\":\"get_calculator\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1953},{\"name\":\"commit_transfer_ownership\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_admin\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":74452},{\"name\":\"apply_transfer_ownership\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":60590},{\"name\":\"revert_transfer_ownership\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":21865},{\"name\":\"claim_token_balance\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":4854},{\"name\":\"claim_eth_balance\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":36726},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1901},{\"name\":\"pool_list\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"int128\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2130},{\"name\":\"pool_count\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1961}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b17","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}