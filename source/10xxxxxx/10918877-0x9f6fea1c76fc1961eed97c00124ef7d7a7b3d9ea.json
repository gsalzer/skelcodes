{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\npragma solidity 0.7.1;\r\n\r\ncontract EtherSwap {\r\n    uint8 constant public version = 1;\r\n\r\n    mapping (bytes32 => bool) public swaps;\r\n\r\n    event Lockup(\r\n        bytes32 indexed preimageHash,\r\n        uint amount,\r\n        address claimAddress,\r\n        address indexed refundAddress,\r\n        uint timelock\r\n    );\r\n\r\n    event Claim(bytes32 indexed preimageHash, bytes32 preimage);\r\n    event Refund(bytes32 indexed preimageHash);\r\n\r\n    function hashValues(\r\n        bytes32 preimageHash,\r\n        uint amount,\r\n        address claimAddress,\r\n        address refundAddress,\r\n        uint timelock\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n            preimageHash,\r\n            amount,\r\n            claimAddress,\r\n            refundAddress,\r\n            timelock\r\n        ));\r\n    }\r\n\r\n    function transferEtherToSender(\r\n        uint amount\r\n    ) private {\r\n        (bool success, ) = msg.sender.call{ value: amount }(\"\");\r\n        require(success, \"EtherSwap: Ether transfer failed\");\r\n    }\r\n\r\n    function checkSwapExists(bytes32 hash) private view {\r\n        require(swaps[hash] == true, \"EtherSwap: swap does not exist\");\r\n    }\r\n\r\n    function lock(bytes32 preimageHash, address claimAddress, uint timelock) external payable {\r\n        require(msg.value > 0, \"EtherSwap: amount must not be zero\");\r\n\r\n        bytes32 hash = hashValues(\r\n            preimageHash,\r\n            msg.value,\r\n            claimAddress,\r\n            msg.sender,\r\n            timelock\r\n        );\r\n\r\n        require(swaps[hash] == false, \"EtherSwap: swap exists already\");\r\n        swaps[hash] = true;\r\n\r\n        emit Lockup(preimageHash, msg.value, claimAddress, msg.sender, timelock);\r\n    }\r\n\r\n    function claim(\r\n        bytes32 preimage,\r\n        uint amount,\r\n        address refundAddress,\r\n        uint timelock\r\n    ) external {\r\n        bytes32 preimageHash = sha256(abi.encodePacked(preimage));\r\n        bytes32 hash = hashValues(\r\n            preimageHash,\r\n            amount,\r\n            msg.sender,\r\n            refundAddress,\r\n            timelock\r\n        );\r\n\r\n        checkSwapExists(hash);\r\n        delete swaps[hash];\r\n\r\n        emit Claim(preimageHash, preimage);\r\n\r\n        transferEtherToSender(amount);\r\n    }\r\n\r\n    function refund(\r\n        bytes32 preimageHash,\r\n        uint amount,\r\n        address claimAddress,\r\n        uint timelock\r\n    ) external {\r\n        require(timelock <= block.number, \"EtherSwap: swap has not timed out yet\");\r\n\r\n        bytes32 hash = hashValues(\r\n            preimageHash,\r\n            amount,\r\n            claimAddress,\r\n            msg.sender,\r\n            timelock\r\n        );\r\n\r\n        checkSwapExists(hash);\r\n        delete swaps[hash];\r\n\r\n        emit Refund(preimageHash);\r\n\r\n        transferEtherToSender(amount);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"preimageHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"preimage\",\"type\":\"bytes32\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"preimageHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"Lockup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"preimageHash\",\"type\":\"bytes32\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"preimage\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"preimageHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"preimageHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EtherSwap","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8ba5aa230e5075b8c125fcbf119f1e8d29995835e64c43fed09b678890128e58"}]}