{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright 2017-2020, bZeroX, LLC <https://bzx.network/>. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ncontract IERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Copyright (C) 2019 Aragon One <https://aragon.one/>\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n *\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n *\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/**\r\n * @title Checkpointing\r\n * @notice Checkpointing library for keeping track of historical values based on an arbitrary time\r\n *         unit (e.g. seconds or block numbers).\r\n * @dev Adapted from:\r\n *   - Checkpointing  (https://github.com/aragonone/voting-connectors/blob/master/shared/contract-utils/contracts/Checkpointing.sol)\r\n */\r\nlibrary Checkpointing {\r\n\r\n    struct Checkpoint {\r\n        uint256 time;\r\n        uint256 value;\r\n    }\r\n\r\n    struct History {\r\n        Checkpoint[] history;\r\n    }\r\n\r\n    function addCheckpoint(\r\n        History storage _self,\r\n        uint256 _time,\r\n        uint256 _value)\r\n        internal\r\n    {\r\n        uint256 length = _self.history.length;\r\n        if (length == 0) {\r\n            _self.history.push(Checkpoint(_time, _value));\r\n        } else {\r\n            Checkpoint storage currentCheckpoint = _self.history[length - 1];\r\n            uint256 currentCheckpointTime = currentCheckpoint.time;\r\n\r\n            if (_time > currentCheckpointTime) {\r\n                _self.history.push(Checkpoint(_time, _value));\r\n            } else if (_time == currentCheckpointTime) {\r\n                currentCheckpoint.value = _value;\r\n            } else { // ensure list ordering\r\n                revert(\"past-checkpoint\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function getValueAt(\r\n        History storage _self,\r\n        uint256 _time)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getValueAt(_self, _time);\r\n    }\r\n\r\n    function lastUpdated(\r\n        History storage _self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 length = _self.history.length;\r\n        if (length != 0) {\r\n            return _self.history[length - 1].time;\r\n        }\r\n    }\r\n\r\n    function latestValue(\r\n        History storage _self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 length = _self.history.length;\r\n        if (length != 0) {\r\n            return _self.history[length - 1].value;\r\n        }\r\n    }\r\n\r\n    function _getValueAt(\r\n        History storage _self,\r\n        uint256 _time)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 length = _self.history.length;\r\n\r\n        // Short circuit if there's no checkpoints yet\r\n        // Note that this also lets us avoid using SafeMath later on, as we've established that\r\n        // there must be at least one checkpoint\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Check last checkpoint\r\n        uint256 lastIndex = length - 1;\r\n        Checkpoint storage lastCheckpoint = _self.history[lastIndex];\r\n        if (_time >= lastCheckpoint.time) {\r\n            return lastCheckpoint.value;\r\n        }\r\n\r\n        // Check first checkpoint (if not already checked with the above check on last)\r\n        if (length == 1 || _time < _self.history[0].time) {\r\n            return 0;\r\n        }\r\n\r\n        // Do binary search\r\n        // As we've already checked both ends, we don't need to check the last checkpoint again\r\n        uint256 low = 0;\r\n        uint256 high = lastIndex - 1;\r\n\r\n        while (high != low) {\r\n            uint256 mid = (high + low + 1) / 2; // average, ceil round\r\n            Checkpoint storage checkpoint = _self.history[mid];\r\n            uint256 midTime = checkpoint.time;\r\n\r\n            if (_time > midTime) {\r\n                low = mid;\r\n            } else if (_time < midTime) {\r\n                // Note that we don't need SafeMath here because mid must always be greater than 0\r\n                // from the while condition\r\n                high = mid - 1;\r\n            } else {\r\n                // _time == midTime\r\n                return checkpoint.value;\r\n            }\r\n        }\r\n\r\n        return _self.history[low].value;\r\n    }\r\n}\r\n\r\ncontract CheckpointingToken is IERC20 {\r\n    using Checkpointing for Checkpointing.History;\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowances_;\r\n\r\n    mapping (address => Checkpointing.History) internal balancesHistory_;\r\n\r\n    struct Checkpoint {\r\n        uint256 time;\r\n        uint256 value;\r\n    }\r\n\r\n    struct History {\r\n        Checkpoint[] history;\r\n    }\r\n\r\n    // override this function if a totalSupply should be tracked\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    function balanceOfAt(\r\n        address _owner,\r\n        uint256 _blockNumber)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balancesHistory_[_owner].getValueAt(_blockNumber);\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowances_[_owner][_spender];\r\n    }\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowances_[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        return transferFrom(\r\n            msg.sender,\r\n            _to,\r\n            _value\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\r\n        require(previousBalanceFrom >= _value, \"insufficient-balance\");\r\n\r\n        if (_from != msg.sender && allowances_[_from][msg.sender] != uint(-1)) {\r\n            require(allowances_[_from][msg.sender] >= _value, \"insufficient-allowance\");\r\n            allowances_[_from][msg.sender] = allowances_[_from][msg.sender] - _value; // overflow not possible\r\n        }\r\n\r\n        balancesHistory_[_from].addCheckpoint(\r\n            block.number,\r\n            previousBalanceFrom - _value // overflow not possible\r\n        );\r\n\r\n        balancesHistory_[_to].addCheckpoint(\r\n            block.number,\r\n            add(\r\n                balanceOfAt(_to, block.number),\r\n                _value\r\n            )\r\n        );\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function _getBlockNumber()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return block.number;\r\n    }\r\n\r\n    function _getTimestamp()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function add(\r\n        uint256 x,\r\n        uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        require((c = x + y) >= x, \"addition-overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 x,\r\n        uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        require((c = x - y) <= x, \"subtraction-overflow\");\r\n    }\r\n\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require((c = a * b) / a == b, \"multiplication-overflow\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        require(b != 0, \"division by zero\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract BZRXToken is CheckpointingToken {\r\n\r\n    string public constant name = \"bZx Protocol Token\";\r\n    string public constant symbol = \"BZRX\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    uint256 internal constant totalSupply_ = 1030000000e18; // 1,030,000,000 BZRX\r\n\r\n    constructor(\r\n        address _to)\r\n        public\r\n    {\r\n        balancesHistory_[_to].addCheckpoint(_getBlockNumber(), totalSupply_);\r\n        emit Transfer(address(0), _to, totalSupply_);\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BZRXToken","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b7f72028d9b502dc871c444363a7ac5a52546608","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://498d706e06ca6ca8b3ed63e669a559c58be6d16bcf662e1bb592d158569bd684"}]}