{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\ninterface ERC20\r\n{\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function balanceOf(address owner) external view returns (uint);\r\n}\r\n\r\ninterface UniswapRouter\r\n{\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n        \r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Factory\r\n{\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair\r\n{\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n}\r\n\r\nlibrary SafeMath\r\n{\r\n    function add(uint256 x, uint256 y) public pure returns (uint256 z)\r\n    {\r\n        require((z = x + y) >= x, 'math-add-overflow');\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) public pure returns (uint256 z)\r\n    {\r\n        require((z = x - y) <= x, 'math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) public pure returns (uint256 z)\r\n    {\r\n        require(y == 0 || (z = x * y) / y == x, 'math-mul-overflow');\r\n    }\r\n}\r\n\r\ncontract Wrapper\r\n{\r\n    using SafeMath for uint256;\r\n        \r\n    address constant public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    UniswapRouter constant public ROUTER = UniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\tIUniswapV2Factory constant public FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n\t\r\n    address public owner;\r\n\tmapping (address => bool) public allow_list;\r\n\t\r\n\tmodifier onlyOwner\r\n    {\r\n        require(tx.origin == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWorker\r\n    {\r\n        require(allow_list[tx.origin], \"Only allowed worker\");\r\n        _;\r\n    }\r\n    \r\n\tconstructor() public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n        \r\n    receive() external payable\r\n    {\r\n        \r\n    }\r\n\r\n    function pull_eth(uint256 value) public payable onlyOwner\r\n    {\r\n        msg.sender.transfer(value);\r\n    }\r\n    \r\n    function pull_eth_to(address payable receiver, uint256 value) public payable onlyOwner\r\n    {\r\n        receiver.transfer(value);\r\n    }\r\n    \r\n    function pull_token(address token, uint256 value) public onlyOwner\r\n    {\r\n        ERC20(token).transfer(msg.sender, value);\r\n    }\r\n    \r\n    function pull_token_to(address receiver, address token, uint256 value) public onlyOwner\r\n    {\r\n        ERC20(token).transfer(receiver, value);\r\n    }\r\n    \r\n    function allow_address(address a) public onlyOwner\r\n    {\r\n        allow_list[a] = true;\r\n    }\r\n    \r\n    function allow_addresses(address[] memory array) public onlyOwner\r\n    {\r\n        for(uint256 i = 0; i < array.length; i++) allow_list[array[i]] = true;\r\n    }\r\n    \r\n    function cancel_addresses(address[] memory array) public onlyOwner\r\n    {\r\n        for(uint256 i = 0; i < array.length; i++) delete allow_list[array[i]];\r\n    }\r\n    \r\n    function charge_addresses(uint256 limit, address[] memory array) public payable onlyOwner\r\n    {\r\n        uint256 avail = msg.value;\r\n        \r\n        for(uint256 i = 0; i < array.length; i++)\r\n        {\r\n            if(avail == 0) break;\r\n            \r\n            address payable worker = payable(array[i]);\r\n            if(worker.balance < limit)\r\n            {\r\n                uint256 need = limit - worker.balance;\r\n                if(need > avail) need = avail;\r\n                \r\n                worker.transfer(need);\r\n                \r\n                avail -= need;\r\n            }\r\n        }\r\n        \r\n        if(avail > 0) msg.sender.transfer(avail);\r\n    }\r\n    \r\n    function do_direct_call(uint256 _value, address _target, bytes memory _data) public payable onlyWorker returns (bytes memory response)\r\n    {\r\n        (bool success, bytes memory ret) = _target.call{value: _value}(_data);\r\n        require(success);\r\n        response = ret;\r\n    }\r\n    \r\n    function direct_swap(uint256 swapEth, uint256 swapToken, address token) public payable onlyWorker\r\n    {\r\n        require(address(this).balance >= swapEth, \"empty\");\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = token;\r\n        ROUTER.swapExactETHForTokens{value: swapEth}(swapToken, path, address(this), now + 60 minutes);\r\n    }\r\n    \r\n    function packed_swap(uint256 pack) public payable onlyWorker\r\n    {\r\n        uint256 swapEth = uint256(uint48(pack >> 208))*10e18;\r\n        \r\n        require(address(this).balance >= swapEth, \"empty\");\r\n        \r\n        uint256 swapToken = uint256(uint48(pack >> 160))*10e18;\r\n        address token = address(uint160(pack));\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = token;\r\n        ROUTER.swapExactETHForTokens{value: swapEth}(swapToken, path, address(this), now + 60 minutes);\r\n    }\r\n    \r\n    function swap_eth_token0(address token) public payable\r\n    {\r\n        uint256 swapEth = msg.value;\r\n        \r\n        IUniswapV2Pair pair = IUniswapV2Pair(FACTORY.getPair(WETH, token));\r\n        \r\n        (uint256 reserveToken, uint256 reserveEth, ) = pair.getReserves();\r\n        \r\n        uint amountInWithFee = swapEth.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveToken);\r\n        uint denominator = reserveEth.mul(1000).add(amountInWithFee);\r\n        uint256 swapToken = numerator / denominator;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = token;\r\n        ROUTER.swapExactETHForTokens{value: swapEth}(swapToken, path, msg.sender, now + 5 minutes);\r\n    }\r\n    \r\n    function swap_eth_token1(address token) public payable\r\n    {\r\n        uint256 swapEth = msg.value;\r\n        \r\n        IUniswapV2Pair pair = IUniswapV2Pair(FACTORY.getPair(WETH, token));\r\n        \r\n        (uint256 reserveEth, uint256 reserveToken, ) = pair.getReserves();\r\n        \r\n        uint amountInWithFee = swapEth.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveToken);\r\n        uint denominator = reserveEth.mul(1000).add(amountInWithFee);\r\n        uint256 swapToken = numerator / denominator;\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = token;\r\n        ROUTER.swapExactETHForTokens{value: swapEth}(swapToken, path, msg.sender, now + 5 minutes);\r\n    }\r\n    \r\n    function swap_token0_eth(address token, uint256 swapToken) public\r\n    {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(FACTORY.getPair(WETH, token));\r\n        \r\n        (uint256 reserveToken, uint256 reserveEth, ) = pair.getReserves();\r\n        \r\n        uint amountInWithFee = swapToken.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveEth);\r\n        uint denominator = reserveToken.mul(1000).add(amountInWithFee);\r\n        uint256 swapEth = numerator / denominator;\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = WETH;\r\n        ROUTER.swapExactTokensForETH(swapToken, swapEth, path, msg.sender, now + 5 minutes);\r\n    }\r\n    \r\n    function swap_token1_eth(address token, uint256 swapToken) public\r\n    {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(FACTORY.getPair(WETH, token));\r\n        \r\n        (uint256 reserveEth, uint256 reserveToken, ) = pair.getReserves();\r\n        \r\n        uint amountInWithFee = swapToken.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveEth);\r\n        uint denominator = reserveToken.mul(1000).add(amountInWithFee);\r\n        uint256 swapEth = numerator / denominator;\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = WETH;\r\n        ROUTER.swapExactTokensForETH(swapToken, swapEth, path, msg.sender, now + 5 minutes);\r\n    }\r\n    \r\n    function swap_all_token0_eth(address token) public\r\n    {\r\n        swap_token0_eth(token, ERC20(token).balanceOf(msg.sender));\r\n    }\r\n    \r\n    function swap_all_token1_eth(address token) public\r\n    {\r\n        swap_token1_eth(token, ERC20(token).balanceOf(msg.sender));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"mul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"sub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"SafeMath","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2d2b7f8eda2c3c55f64be68daf2caf7fa859138a0c852b6419a6fdd4749651b4"}]}