{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-05-05\r\n*/\r\n\r\npragma solidity 0.5.16; /*\r\n\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n\r\n ██████╗ ██╗██╗     ██╗     ██╗ ██████╗ ███╗   ██╗    ███╗   ███╗ ██████╗ ███╗   ██╗███████╗██╗   ██╗\r\n ██╔══██╗██║██║     ██║     ██║██╔═══██╗████╗  ██║    ████╗ ████║██╔═══██╗████╗  ██║██╔════╝╚██╗ ██╔╝\r\n ██████╔╝██║██║     ██║     ██║██║   ██║██╔██╗ ██║    ██╔████╔██║██║   ██║██╔██╗ ██║█████╗   ╚████╔╝ \r\n ██╔══██╗██║██║     ██║     ██║██║   ██║██║╚██╗██║    ██║╚██╔╝██║██║   ██║██║╚██╗██║██╔══╝    ╚██╔╝  \r\n ██████╔╝██║███████╗███████╗██║╚██████╔╝██║ ╚████║    ██║ ╚═╝ ██║╚██████╔╝██║ ╚████║███████╗   ██║   \r\n ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   \r\n                                                                                            \r\n\r\n\r\n-------------------------------------------------------------------\r\n Copyright (c) 2020 onwards Billion Money Inc. ( https://billionmoney.live )\r\n-------------------------------------------------------------------\r\n */\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\ncontract owned {\r\n    address payable public owner;\r\n    address payable internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         PAX interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface paxInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n }\r\n\r\ninterface oldContractInerface\r\n{\r\n    function userInfos(address user) external view returns(bool,uint32,uint32);\r\n    function findFreeReferrer(address _user) external view returns(address);\r\n    function userAddressByID(uint id) external view returns(address payable);\r\n    function viewUserLevelExpired(address _user, uint _level) external view returns(uint);\r\n    function totalDivCollection() external view returns(uint128);\r\n    function thisMonthEnd() external view returns(uint32);\r\n    function nextMemberFillIndex(uint) external view returns(uint32);\r\n    function nextMemberFillBox(uint) external view returns(uint32); \r\n    function autoPoolLevel(uint _lvl, uint _index) external view returns (uint32, uint32);     \r\n}\r\n\r\n\r\n//*******************************************************************//\r\n//------------------        MAIN contract         -------------------//\r\n//*******************************************************************//\r\n\r\ncontract billionMoney is owned {\r\n\r\n    address public specialAddress1;\r\n    address public specialAddress2;\r\n    bool stopSwap;\r\n    uint[10] autoPoolCount;  // This variable is only useful for fetching auto pool records from old contract, once all records fetched it has no use\r\n    \r\n    address public paxTokenAddress; \r\n    uint32 public levelLifeTime = 15552000;  // =180 days;\r\n    uint32 public lastIDCount = 0;\r\n    uint32 public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\r\n    \r\n    address public oldBMContractAddress;\r\n    uint16 public lastIDofOldContract;\r\n    uint8 public maxDownLimit = 2;\r\n    uint32 public oneMonthDuration = 2592000; // = 30 days\r\n    uint32 public thisMonthEnd;\r\n\r\n    struct userInfo {\r\n        address[] referral;\r\n        uint32 id;\r\n        uint32 referrerID;\r\n        uint16 directCount;\r\n        bool joined;       \r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n\r\n    mapping(uint => uint128) public priceOfLevel;\r\n    mapping(uint => uint128) public distForLevel;\r\n    mapping(uint => uint128) public autoPoolDist;\r\n    mapping(uint => uint128) public uniLevelDistPart;\r\n    uint128 public totalDivCollection;\r\n    uint128 public globalDivDistPart = 0.6 ether;\r\n    uint128 public systemDistPart = 1 ether;\r\n    \r\n\r\n    struct divPoolRecord\r\n    {\r\n        uint128 totalDividendCollection;\r\n        uint128 totalEligibleCount;\r\n    }\r\n    divPoolRecord[] public divPoolRecords;\r\n    mapping ( address => uint16) public eligibleUser; // if val > 0 then user is eligible from this divPoolRecords;\r\n    mapping(uint16 => mapping ( address => bool)) public dividendReceived; // dividend index => user => true/false\r\n    mapping(uint16 => bool) directUpdated;\r\n\r\n    struct autoPool\r\n    {\r\n        uint32 userID;\r\n        uint32 autoPoolParent;\r\n    }\r\n    mapping(uint8 => autoPool[]) public autoPoolLevel;  // users lavel records under auto pool scheme\r\n    mapping(address => mapping(uint8 => uint32)) public autoPoolIndex; //to find index of user inside auto pool\r\n    uint32[10] public nextMemberFillIndex;  // which auto pool index is in top of queue to fill in \r\n    uint32[10] public nextMemberFillBox;   // 3 downline to each, so which downline need to fill in\r\n\r\n    uint[10][10] public autoPoolSubDist;\r\n\r\n    \r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint32 => address payable) public userAddressByID;\r\n\r\n    mapping(address => uint128) public totalGainInMainNetwork; //Main lavel income system income will go here with owner mapping\r\n    mapping(address => uint128) public totalGainInUniLevel; \r\n    mapping(address => uint128) public totalGainInAutoPool;\r\n    mapping(address => uint128) public netTotalUserWithdrawable;  //Dividend is not included in it\r\n\r\n\r\n    event regLevelEv(address indexed _userWallet, uint indexed _userID, uint indexed _referrerID, uint _time, address _refererWallet, uint _originalReferrer);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    event lostForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    event payDividendEv(uint timeNow,uint payAmount,address paitTo);\r\n    event updateAutoPoolEv(uint timeNow,uint autoPoolLevelIndex,uint userIndexInAutoPool, address user);\r\n    event autoPoolPayEv(uint timeNow,address paidTo,uint paidForLevel, uint paidAmount, address paidAgainst);\r\n    event paidForUniLevelEv(uint timeNow,address PaitTo,uint Amount);\r\n    \r\n    constructor(address payable ownerAddress) public {\r\n        owner = ownerAddress;\r\n\r\n        emit OwnershipTransferred(address(0), owner);\r\n\r\n        priceOfLevel[1] = 20 ether;\r\n        priceOfLevel[2] = 20 ether;\r\n        priceOfLevel[3] = 40 ether;\r\n        priceOfLevel[4] = 140 ether;\r\n        priceOfLevel[5] = 600 ether;\r\n        priceOfLevel[6] = 5000 ether;\r\n        priceOfLevel[7] = 5500 ether;\r\n        priceOfLevel[8] = 10000 ether;\r\n        priceOfLevel[9] = 20000 ether;\r\n        priceOfLevel[10] = 40000 ether;\r\n\r\n        distForLevel[1] = 10 ether;\r\n        distForLevel[2] = 15 ether;\r\n        distForLevel[3] = 30 ether;\r\n        distForLevel[4] = 120 ether;\r\n        distForLevel[5] = 500 ether;\r\n        distForLevel[6] = 4700 ether;\r\n        distForLevel[7] = 5000 ether;\r\n        distForLevel[8] = 9000 ether;\r\n        distForLevel[9] = 18000 ether;\r\n        distForLevel[10] = 35000 ether;\r\n\r\n        autoPoolDist[1] = 4 ether;\r\n        autoPoolDist[2] = 5 ether;\r\n        autoPoolDist[3] = 10 ether;\r\n        autoPoolDist[4] = 20 ether;\r\n        autoPoolDist[5] = 100 ether;\r\n        autoPoolDist[6] = 300 ether;\r\n        autoPoolDist[7] = 500 ether;\r\n        autoPoolDist[8] = 1000 ether;\r\n        autoPoolDist[9] = 2000 ether;\r\n        autoPoolDist[10] = 5000 ether;        \r\n\r\n        uniLevelDistPart[1] = 1 ether;\r\n        uniLevelDistPart[2] = 0.6 ether;\r\n        uniLevelDistPart[3] = 0.4 ether;\r\n\r\n        for (uint i = 4 ; i < 11; i++)\r\n        {\r\n           uniLevelDistPart[i] =  0.2 ether;\r\n        } \r\n\r\n        autoPool memory temp;\r\n        for (uint8 i = 11 ; i < 21; i++)\r\n        {\r\n           uniLevelDistPart[i] =  0.1 ether;\r\n           uint8 a = i-11;\r\n           autoPoolLevel[a].push(temp);\r\n           uint distPart = autoPoolDist[a+1];\r\n           autoPoolSubDist[a][0] = distPart * 1250 / 10000;\r\n           autoPoolSubDist[a][1] = distPart * 1250 / 10000;\r\n           autoPoolSubDist[a][2] = distPart * 1000 / 10000;\r\n           autoPoolSubDist[a][3] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][4] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][5] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][6] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][7] = distPart * 1000 / 10000;\r\n           autoPoolSubDist[a][8] = distPart * 1250 / 10000;                                                                             \r\n           autoPoolSubDist[a][9] = distPart * 1250 / 10000;\r\n        } \r\n\r\n    }\r\n\r\n    function () external {\r\n        revert();\r\n    }\r\n\r\n    function regUser(uint32 _referrerID) public returns(bool)\r\n    {\r\n        if (_referrerID > lastIDofOldContract )\r\n        {\r\n            _regUser(_referrerID);\r\n        }\r\n        else\r\n        {\r\n            _regUser2(_referrerID);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function _regUser(uint32 _referrerID) internal returns(bool) \r\n    {\r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender; \r\n        uint32 originalReferrer = _referrerID;\r\n\r\n        //checking all conditions\r\n        require(!userInfos[msgSender].joined, 'User exist');\r\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) _referrerID = defaultRefID;\r\n        uint128 fct = 1;\r\n        _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\r\n\r\n\r\n        //transferring PAX tokens from smart user to smart contract for level 1\r\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\r\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[1]),\"token transfer failed\");\r\n        }\r\n        else\r\n        {\r\n            fct = 0;\r\n        }\r\n        \r\n        //update variables\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: _referrerID,\r\n            directCount: 0,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[lastIDCount] = msg.sender;\r\n\r\n        userInfos[msgSender].levelExpired[1] = now + levelLifeTime;\r\n\r\n        userInfos[userAddressByID[_referrerID]].referral.push(msgSender);\r\n        userInfos[userAddressByID[originalReferrer]].directCount++;\r\n        totalGainInMainNetwork[owner] += systemDistPart * fct;\r\n        netTotalUserWithdrawable[owner] += systemDistPart * fct;\r\n\r\n        if(thisMonthEnd < now) startNextMonth();\r\n\r\n        uint16 lastDivPoolIndex = uint16(divPoolRecords.length -1);\r\n        divPoolRecords[lastDivPoolIndex].totalDividendCollection += globalDivDistPart * fct;\r\n        totalDivCollection += globalDivDistPart * fct;\r\n\r\n        address usr = userAddressByID[originalReferrer];\r\n        if(eligibleUser[usr] == 0 && userInfos[usr].directCount == 10)\r\n        {\r\n            eligibleUser[usr] = lastDivPoolIndex + 1;\r\n            divPoolRecords[lastDivPoolIndex].totalEligibleCount++;\r\n        }\r\n\r\n        require(payForLevel(1, msgSender,fct),\"pay for level fail\");\r\n        emit regLevelEv(msgSender, lastIDCount, _referrerID, now,userAddressByID[_referrerID], originalReferrer );\r\n        emit levelBuyEv(msgSender, 1, priceOfLevel[1] * fct, now);\r\n        require(updateNPayAutoPool(1,msgSender,fct),\"auto pool update fail\");\r\n        return true;\r\n    }\r\n\r\n\r\n    function _regUser2(uint32 _referrerID) internal returns(bool) \r\n    {\r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender; \r\n        uint32 originalReferrer = _referrerID;\r\n\r\n        updateFromOld(_referrerID);\r\n\r\n        //checking all conditions\r\n        require(!userInfos[msgSender].joined, 'User exist');\r\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) \r\n        {\r\n            _referrerID = defaultRefID;\r\n        }\r\n        else\r\n        {\r\n            _referrerID = userInfos[oldContractInerface(oldBMContractAddress).findFreeReferrer(userAddressByID[_referrerID])].id;\r\n        }\r\n        uint128 fct = 1;\r\n        \r\n\r\n\r\n        //transferring PAX tokens from smart user to smart contract for level 1\r\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\r\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[1]),\"token transfer failed\");\r\n        }\r\n        else\r\n        {\r\n            fct = 0;\r\n        }\r\n        \r\n        //update variables\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: _referrerID,\r\n            directCount: 0,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[lastIDCount] = msg.sender;\r\n\r\n        userInfos[msgSender].levelExpired[1] = now + levelLifeTime;\r\n\r\n        userInfos[userAddressByID[_referrerID]].referral.push(msgSender);\r\n        userInfos[userAddressByID[originalReferrer]].directCount++;\r\n\r\n        totalGainInMainNetwork[owner] += systemDistPart * fct;\r\n        netTotalUserWithdrawable[owner] += systemDistPart * fct;\r\n\r\n        if(thisMonthEnd < now) startNextMonth();\r\n\r\n        uint lastDivPoolIndex = divPoolRecords.length -1;\r\n        divPoolRecords[lastDivPoolIndex].totalDividendCollection += globalDivDistPart * fct;\r\n        totalDivCollection += globalDivDistPart * fct;\r\n\r\n        address usr = userAddressByID[originalReferrer];\r\n        if(eligibleUser[usr] == 0 && userInfos[usr].directCount == 10)\r\n        {\r\n                eligibleUser[usr] = uint16(lastDivPoolIndex + 1);\r\n                divPoolRecords[lastDivPoolIndex].totalEligibleCount++;\r\n        }\r\n\r\n        require(payForLevel(1, msgSender,fct),\"pay for level fail\");\r\n        emit regLevelEv(msgSender, lastIDCount, _referrerID, now,userAddressByID[_referrerID], originalReferrer );\r\n        emit levelBuyEv(msgSender, 1, priceOfLevel[1] * fct, now);\r\n        require(updateNPayAutoPool(1,msgSender,fct),\"auto pool update fail\");\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n    function viewCurrentMonthDividend() public view returns(uint256 amount, uint256 indexCount)\r\n    {\r\n        uint256 length = divPoolRecords.length;\r\n        return (divPoolRecords[length-1].totalDividendCollection,length);\r\n    }\r\n\r\n\r\n    function buyLevel(uint8 _level) public returns(bool){\r\n        \r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender;  \r\n\r\n        updateFromOld(userInfos[msgSender].id);\r\n      \r\n        \r\n        //checking conditions\r\n        require(userInfos[msgSender].joined, 'User not exist'); \r\n        uint128 fct=1;\r\n        require(_level >= 1 && _level <= 10, 'Incorrect level');\r\n        \r\n        //transfer tokens\r\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\r\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[_level]),\"token transfer failed\");\r\n        }\r\n        else\r\n        {\r\n            fct = 0;\r\n        }\r\n        \r\n        \r\n        //updating variables\r\n        if(_level == 1) {\r\n            userInfos[msgSender].levelExpired[1] += levelLifeTime;\r\n        }\r\n        else {\r\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[msgSender].levelExpired[l] >= now, 'Buy the previous level');\r\n\r\n            if(userInfos[msgSender].levelExpired[_level] == 0) userInfos[msgSender].levelExpired[_level] = now + levelLifeTime;\r\n            else userInfos[msgSender].levelExpired[_level] += levelLifeTime;\r\n        }\r\n\r\n        require(payForLevel(_level, msgSender,fct),\"pay for level fail\");\r\n        emit levelBuyEv(msgSender, _level, priceOfLevel[_level] * fct, now);\r\n        require(updateNPayAutoPool(_level,msgSender,fct),\"auto pool update fail\");\r\n        return true;\r\n    }\r\n    \r\n\r\n    function payForLevel(uint _level, address _user,uint128 fct) internal returns (bool){\r\n        address referer;\r\n\r\n\r\n        uint32 _id = userInfos[_user].referrerID;\r\n        if(_id <=lastIDofOldContract ) updateFromOld(_id );\r\n        if(_level == 1 || _level == 6) {\r\n            referer = userAddressByID[_id ];\r\n            payForUniLevel(_id,fct);\r\n            totalGainInMainNetwork[owner] += systemDistPart * fct;\r\n            netTotalUserWithdrawable[owner] += systemDistPart * fct;\r\n        }\r\n        else if(_level == 2 || _level == 7) {\r\n            referer = userAddressByID[_id];\r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id];          \r\n        }\r\n        else if(_level == 3 || _level == 8) {\r\n            referer = userAddressByID[_id];\r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id]; \r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id];             \r\n        }\r\n        else if(_level == 4 || _level == 9) {\r\n            referer = userAddressByID[_id];\r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id]; \r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id];\r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id];            \r\n        }\r\n        else if(_level == 5 || _level == 10) {\r\n            referer = userAddressByID[_id];\r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id]; \r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id];\r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id];\r\n            _id = userInfos[referer].referrerID;\r\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \r\n            referer = userAddressByID[_id];            \r\n        }\r\n\r\n\r\n        if(!userInfos[referer].joined) referer = userAddressByID[defaultRefID];\r\n\r\n       \r\n        if(userInfos[referer].levelExpired[_level] >= now) {\r\n            totalGainInMainNetwork[referer] += distForLevel[_level] * fct;\r\n            netTotalUserWithdrawable[referer] += distForLevel[_level] * fct;\r\n            emit paidForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\r\n\r\n        }\r\n        else{\r\n\r\n            emit lostForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\r\n            payForLevel(_level, referer,fct);\r\n\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        if(userInfos[_user].referral.length < maxDownLimit) return _user;\r\n\r\n        address[] memory referrals = new address[](126);\r\n        referrals[0] = userInfos[_user].referral[0];\r\n        referrals[1] = userInfos[_user].referral[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\r\n                if(i < 62) {\r\n                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\r\n                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n\r\n    function payForUniLevel(uint32 _referrerID, uint128 fct) internal returns(bool)\r\n    {\r\n        uint256 endID = 21;\r\n        for (uint i = 0 ; i < endID; i++)\r\n        {\r\n            address usr = userAddressByID[_referrerID];\r\n            _referrerID = userInfos[usr].referrerID;\r\n            if(_referrerID<=lastIDofOldContract ) updateFromOld(_referrerID );\r\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n            uint128 Amount = uniLevelDistPart[i + 1 ]  * fct;\r\n            totalGainInUniLevel[usr] += Amount;\r\n            netTotalUserWithdrawable[usr] += Amount;\r\n            emit paidForUniLevelEv(now,usr, Amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    event withdrawMyGainEv(uint timeNow,address caller,uint totalAmount);\r\n    function withdrawMyDividendNAll() public returns(uint)\r\n    {\r\n        address payable caller = msg.sender;\r\n        require(userInfos[caller].joined, 'User not exist');\r\n        uint from = eligibleUser[caller];\r\n        uint128 totalAmount;\r\n        if(from > 0)\r\n        {\r\n            from --;\r\n            uint lastDivPoolIndex = divPoolRecords.length;\r\n            if( lastDivPoolIndex > 1 )\r\n            {\r\n                lastDivPoolIndex = lastDivPoolIndex -2;\r\n\r\n                for(uint i=0;i<150;i++)\r\n                {\r\n                    if(lastDivPoolIndex < i) break;\r\n                    uint16 curIndex = uint16(lastDivPoolIndex - i);\r\n                    if( curIndex >= from && !dividendReceived[curIndex][caller] )\r\n                    {\r\n                        totalAmount +=  ( divPoolRecords[curIndex].totalDividendCollection * 10000000000 /  divPoolRecords[curIndex].totalEligibleCount ) / 10000000000;\r\n                        dividendReceived[curIndex][caller] = true;\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n        if(totalAmount > 0)\r\n        {\r\n            totalDivCollection -= totalAmount;\r\n            emit payDividendEv(now, totalAmount, caller);\r\n        }\r\n        totalAmount = totalAmount + netTotalUserWithdrawable[caller];\r\n        netTotalUserWithdrawable[caller] = 0;\r\n        totalGainInAutoPool[caller] = 0;\r\n        totalGainInMainNetwork[caller] = 0;\r\n        totalGainInUniLevel[caller] = 0;\r\n        require(paxInterface(paxTokenAddress).transfer(msg.sender, totalAmount),\"token transfer failed\");\r\n        emit withdrawMyGainEv(now, caller, totalAmount);\r\n        \r\n    }\r\n\r\n    function viewMyDividendPotential(address user) public view returns(uint256 totalDivPotential, uint16 lastUnPaidIndex)\r\n    {\r\n        if (eligibleUser[user] > 0 )\r\n        {\r\n            uint16 i;\r\n            uint16 lastIndex = uint16(divPoolRecords.length -1);\r\n            for(i=1;i<50;i++)\r\n            {\r\n                lastUnPaidIndex = lastIndex - i;\r\n                if(dividendReceived[lastUnPaidIndex][user] == true) break;\r\n                totalDivPotential = totalDivPotential + ( divPoolRecords[lastUnPaidIndex].totalDividendCollection * 10000000000 /  divPoolRecords[lastUnPaidIndex].totalEligibleCount);               \r\n            }\r\n            return (totalDivPotential, lastUnPaidIndex + 1);\r\n        }\r\n        return (0,0);\r\n    }\r\n\r\n    function viewTimestampSinceJoined(address usr) public view returns(uint256[10] memory timeSinceJoined )\r\n    {\r\n        if(userInfos[usr].joined)\r\n        {\r\n            for(uint256 i=0;i<10;i++)\r\n            {\r\n                uint256 t = userInfos[usr].levelExpired[i+1];\r\n                if(t>now)\r\n                {\r\n                    timeSinceJoined[i] = (t-now);\r\n                }\r\n            }\r\n        }\r\n        return timeSinceJoined;\r\n    }\r\n\r\n    \r\n    \r\n    function divPoolAllLevel() public view returns (uint256[10] memory divPoolArray)\r\n    {\r\n        for(uint256 i=0;i<10;i++)\r\n        {\r\n            divPoolArray[i] = divPoolRecords[i].totalDividendCollection;\r\n        }\r\n        return divPoolArray;\r\n    }\r\n    \r\n\r\n    function startNextMonth() internal returns(bool)\r\n    {\r\n        require(thisMonthEnd < now,\"month end not reached\");\r\n        thisMonthEnd = uint32(now + oneMonthDuration);\r\n        divPoolRecord memory temp;\r\n        temp.totalEligibleCount = 1;\r\n        divPoolRecords.push(temp);\r\n        uint lastDivPoolIndex = divPoolRecords.length -1;\r\n        if (lastDivPoolIndex > 0)\r\n        {\r\n            divPoolRecords[lastDivPoolIndex].totalEligibleCount = divPoolRecords[lastDivPoolIndex -1].totalEligibleCount;\r\n        }\r\n        return (true);\r\n    }\r\n\r\n    function updateNPayAutoPool(uint8 _level,address _user, uint128 fct) internal returns (bool)\r\n    {\r\n        uint8 a = _level -1;\r\n        uint len = autoPoolLevel[a].length;\r\n        autoPool memory temp;\r\n        temp.userID = userInfos[_user].id;\r\n        temp.autoPoolParent = nextMemberFillIndex[a];       \r\n        autoPoolLevel[a].push(temp);        \r\n        uint idx = nextMemberFillIndex[a];\r\n\r\n        address payable usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n        if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n        for(uint i=0;i<10;i++)\r\n        {\r\n            uint128 amount = uint128(autoPoolSubDist[a][i]  * fct);\r\n            totalGainInAutoPool[usr] += amount;\r\n            netTotalUserWithdrawable[usr] += amount;\r\n            emit autoPoolPayEv(now, usr,a+1, amount, _user);\r\n            idx = autoPoolLevel[a][idx].autoPoolParent; \r\n            usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n        }\r\n\r\n        if(nextMemberFillBox[a] == 0)\r\n        {\r\n            nextMemberFillBox[a] = 1;\r\n        }   \r\n        else if (nextMemberFillBox[a] == 1)\r\n        {\r\n            nextMemberFillBox[a] = 2;\r\n        }\r\n        else\r\n        {\r\n            nextMemberFillIndex[a]++;\r\n            nextMemberFillBox[a] = 0;\r\n        }\r\n        autoPoolIndex[_user][_level - 1] = uint32(len);\r\n        emit updateAutoPoolEv(now, _level, len, _user);\r\n        return true;\r\n    }\r\n\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return userInfos[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    \r\n    \r\n    /*======================================\r\n    =            ADMIN FUNCTIONS           =\r\n    ======================================*/\r\n    \r\n    function changePAXaddress(address newPAXaddress) onlyOwner public returns(string memory){\r\n        //if owner makes this 0x0 address, then it will halt all the operation of the contract. This also serves as security feature.\r\n        //so owner can halt it in any problematic situation. Owner can then input correct address to make it all come back to normal.\r\n        paxTokenAddress = newPAXaddress;\r\n        return(\"PAX address updated successfully\");\r\n    }\r\n    \r\n    function changeDefaultRefID(uint32 newDefaultRefID) onlyOwner public returns(string memory){\r\n        //this ref ID will be assigned to user who joins without any referral ID.\r\n        defaultRefID = newDefaultRefID;\r\n        return(\"Default Ref ID updated successfully\");\r\n    }\r\n\r\n\r\n    //Below functions are only for swaping purpose\r\n\r\n    function setLastIDCount(uint32 _lastIDCountOfOldContract) public onlyOwner returns(bool)\r\n    {\r\n        require(lastIDCount == 0, \"can't run twice\");\r\n        lastIDCount = _lastIDCountOfOldContract;\r\n        lastIDofOldContract = uint16(_lastIDCountOfOldContract);\r\n        return true;\r\n    }\r\n\r\n    function updateAddresses(address _paxTokenAddress,address _oldBMContractAddress,address _specialAddress1,address _specialAddress2 ) public onlyOwner returns (bool)\r\n    {\r\n        require(!stopSwap , \"can't run now was for swaping only\");\r\n        paxTokenAddress = _paxTokenAddress;\r\n        oldBMContractAddress = _oldBMContractAddress;\r\n        specialAddress1 = _specialAddress1;\r\n        specialAddress2 = _specialAddress2;\r\n        return true;\r\n    }\r\n\r\n    function adjustDirectCount(uint16 _ID, uint16 _directCount, uint16 _eligibleCount) onlyOwner public returns(bool)\r\n    {\r\n        address usr = oldContractInerface(oldBMContractAddress).userAddressByID(_ID); \r\n        require(_ID <= lastIDofOldContract, \"invalid ID\");\r\n        require(!directUpdated[_ID], \"already updated for this ID\");\r\n        userInfos[usr].directCount = _directCount;\r\n        eligibleUser[usr] = _eligibleCount;\r\n        directUpdated[_ID] = true;\r\n        return true;\r\n    }\r\n\r\n    function updateFromOld(uint32 id) public returns (bool)\r\n    {\r\n        if( userAddressByID[id] == address(0) && id <= lastIDofOldContract )\r\n        {\r\n            userInfo memory tmp;\r\n            address payable usr = oldContractInerface(oldBMContractAddress).userAddressByID(id);\r\n            (tmp.joined,tmp.id,tmp.referrerID) = oldContractInerface(oldBMContractAddress).userInfos(usr);\r\n            userInfos[usr] = tmp;\r\n            userAddressByID[id] = usr;\r\n            uint _levelExpired;\r\n            for(uint i = 1; i <= 10; i++) {\r\n                _levelExpired = oldContractInerface(oldBMContractAddress).viewUserLevelExpired(usr, i);\r\n                userInfos[usr].levelExpired[i] = _levelExpired;\r\n            }             \r\n\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setDividendPoolData(uint128 _totalDividendCollection, uint128 _totalDividendCollection2 ) public onlyOwner returns(bool)\r\n    {\r\n        require(totalDivCollection == 0, \"can't run twice\");\r\n        divPoolRecord memory temp;\r\n        temp.totalDividendCollection = _totalDividendCollection;\r\n        divPoolRecords.push(temp);\r\n        divPoolRecord memory temp2;\r\n        temp2.totalDividendCollection = _totalDividendCollection2;\r\n        divPoolRecords.push(temp);        \r\n        return (true);\r\n    }\r\n\r\n\r\n    function setGlobalVariables() public onlyOwner returns(bool)\r\n    {\r\n        require(thisMonthEnd==0, \"can't be called twice\");\r\n        totalDivCollection = oldContractInerface(oldBMContractAddress).totalDivCollection();\r\n        thisMonthEnd = oldContractInerface(oldBMContractAddress).thisMonthEnd();\r\n        for(uint i =0; i < 10; i++)\r\n        {\r\n            nextMemberFillIndex[i] = oldContractInerface(oldBMContractAddress).nextMemberFillIndex(i);\r\n            nextMemberFillBox[i] = oldContractInerface(oldBMContractAddress).nextMemberFillBox(i);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setAutoPool(uint8 level, uint recordCount) public onlyOwner returns(bool)\r\n    {\r\n        require(level <= 10 && level > 0, \"invalid level\");\r\n        require(!stopSwap , \"run time is over\");\r\n        uint8 a = level -1;\r\n        uint tmp = autoPoolCount[a];\r\n        autoPool memory temp;\r\n        for (uint i = autoPoolCount[a]; i<tmp + recordCount; i++)\r\n        {\r\n            (uint32 _id,uint32 _referrerID) = oldContractInerface(oldBMContractAddress).autoPoolLevel(a ,i);\r\n            if(_id > 1 )\r\n            {\r\n                temp.userID = _id;\r\n                temp.autoPoolParent = _referrerID;\r\n                autoPoolLevel[a].push(temp);\r\n                autoPoolIndex[userAddressByID[_id]][a] = uint32(autoPoolLevel[a].length -1);\r\n            }\r\n        }\r\n        autoPoolCount[a] = tmp + recordCount; \r\n        return true;\r\n    }\r\n    \r\n    function swapSetupFinished() public onlyOwner returns(bool)\r\n    {\r\n        stopSwap = true;\r\n        return true;\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"ownerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidForLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidAgainst\",\"type\":\"address\"}],\"name\":\"autoPoolPayEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lostForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paidForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"PaitTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"paidForUniLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paitTo\",\"type\":\"address\"}],\"name\":\"payDividendEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_originalReferrer\",\"type\":\"uint256\"}],\"name\":\"regLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"autoPoolLevelIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userIndexInAutoPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateAutoPoolEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawMyGainEv\",\"type\":\"event\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_ID\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_directCount\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_eligibleCount\",\"type\":\"uint16\"}],\"name\":\"adjustDirectCount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPoolDist\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"autoPoolIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPoolLevel\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"userID\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"autoPoolParent\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"autoPoolSubDist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"buyLevel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newDefaultRefID\",\"type\":\"uint32\"}],\"name\":\"changeDefaultRefID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPAXaddress\",\"type\":\"address\"}],\"name\":\"changePAXaddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultRefID\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distForLevel\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divPoolAllLevel\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"divPoolArray\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"divPoolRecords\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"totalDividendCollection\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalEligibleCount\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dividendReceived\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"eligibleUser\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalDivDistPart\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastIDofOldContract\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levelLifeTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"netTotalUserWithdrawable\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillBox\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldBMContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oneMonthDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paxTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfLevel\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_referrerID\",\"type\":\"uint32\"}],\"name\":\"regUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"recordCount\",\"type\":\"uint256\"}],\"name\":\"setAutoPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_totalDividendCollection\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_totalDividendCollection2\",\"type\":\"uint128\"}],\"name\":\"setDividendPoolData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setGlobalVariables\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_lastIDCountOfOldContract\",\"type\":\"uint32\"}],\"name\":\"setLastIDCount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"specialAddress1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"specialAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapSetupFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemDistPart\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thisMonthEnd\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDivCollection\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalGainInAutoPool\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalGainInMainNetwork\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalGainInUniLevel\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniLevelDistPart\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paxTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldBMContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_specialAddress1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_specialAddress2\",\"type\":\"address\"}],\"name\":\"updateAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"}],\"name\":\"updateFromOld\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"referrerID\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"directCount\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewCurrentMonthDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"viewMyDividendPotential\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDivPotential\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"lastUnPaidIndex\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"viewTimestampSinceJoined\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"timeSinceJoined\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawMyDividendNAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"billionMoney","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000765d4557e27415a39b44521b89464844dd677530","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4beed7d1f72604cda1e9e60fd5966052c024015c5781cf416cd4042379e1e835"}]}