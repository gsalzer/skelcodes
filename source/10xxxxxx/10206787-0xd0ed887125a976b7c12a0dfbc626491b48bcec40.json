{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.7; // optimization runs: 200, evm version: istanbul\r\n\r\n\r\ninterface ERC1271Interface {\r\n  function isValidSignature(\r\n    bytes calldata data, bytes calldata signatures\r\n  ) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\ninterface EtherizedInterface {\r\n  function triggerCall(\r\n    address target, uint256 value, bytes calldata data\r\n  ) external returns (bool success, bytes memory returnData);\r\n}\r\n\r\n\r\ninterface EtherizerV1Interface {\r\n  event TriggeredCall(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value,\r\n    bytes data,\r\n    bytes returnData\r\n  );\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function triggerCallFrom(\r\n    EtherizedInterface from,\r\n    address payable to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success, bytes memory returnData);\r\n  function approve(\r\n    address spender, uint256 value\r\n  ) external returns (bool success);\r\n  function increaseAllowance(\r\n    address spender, uint256 addedValue\r\n  ) external returns (bool success);\r\n  function decreaseAllowance(\r\n    address spender, uint256 subtractedValue\r\n  ) external returns (bool success);\r\n  function modifyAllowanceViaMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external returns (bool success);\r\n  function cancelAllowanceModificationMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external returns (bool success);\r\n\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view returns (bytes32 digest, bool valid);\r\n  function balanceOf(address account) external view returns (uint256 amount);\r\n  function allowance(\r\n    address owner, address spender\r\n  ) external view returns (uint256 amount);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title EtherizerV1\r\n * @author 0age\r\n * @notice Etherizer is a contract for enabling \"approvals\" for performing Ether\r\n * transfers from compliant accounts via either standard ERC20 methods or\r\n * meta-transactions. A \"compliant\" account must be a smart contract that\r\n * implements a `triggerCall` function that is only callable by this contract as\r\n * well as the `isValidSignature` function specified by ERC-1271 for enabling\r\n * meta-transaction functionality. Be warned that any approved spender can\r\n * initiate arbitrary calls from the owner's account, including ERC20 token\r\n * transfers, so be extremely cautious when granting approval to spenders.\r\n */\r\ncontract EtherizerV1 is EtherizerV1Interface {\r\n  using SafeMath for uint256;\r\n\r\n  // Maintain a mapping of Ether allowances.\r\n  mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n  // Maintain a mapping of invalid meta-transaction message hashes.\r\n  mapping (bytes32 => bool) private _invalidMetaTxHashes;\r\n\r\n  /**\r\n   * @notice Trigger a call from `owner` to `recipient` with `amount` Ether and\r\n   * `data` calldata as long as `msg.sender` has sufficient allowance.\r\n   * @param owner address The account to perform the call from.\r\n   * @param recipient address The account to call.\r\n   * @param amount uint256 The amount of Ether to transfer.\r\n   * @param data bytes The data to include with the call.\r\n   * @return success A boolean indicating whether the call was successful.\r\n   * @return returnData The data returned from the call, if any.\r\n   */\r\n  function triggerCallFrom(\r\n    EtherizedInterface owner,\r\n    address payable recipient,\r\n    uint256 amount,\r\n    bytes calldata data\r\n  ) external override returns (bool success, bytes memory returnData) {\r\n    // Get the current allowance granted by the owner to the caller.\r\n    uint256 callerAllowance = _allowances[address(owner)][msg.sender];\r\n\r\n    // Block attempts to trigger calls when no allowance has been set.\r\n    require(callerAllowance != 0, \"No allowance set for caller.\");\r\n\r\n    // Reduce the allowance if it is not set to full allowance.\r\n    if (callerAllowance != uint256(-1)) {\r\n      require(callerAllowance >= amount, \"Insufficient allowance.\");\r\n      _approve(\r\n          address(owner), msg.sender, callerAllowance - amount\r\n      ); // overflow safe (condition has already been checked).\r\n    }\r\n\r\n    // Trigger the call from the owner and revert if success is not returned.\r\n    (success, returnData) = owner.triggerCall(recipient, amount, data);\r\n    require(success, \"Triggered call did not return successfully.\");\r\n\r\n    // Emit an event with information regarding the triggered call.\r\n    emit TriggeredCall(address(owner), recipient, amount, data, returnData);\r\n  }\r\n\r\n  /**\r\n   * @notice Approve `spender` to transfer up to `value` Ether on behalf of\r\n   * `msg.sender`.\r\n   * @param spender address The account to grant the allowance.\r\n   * @param value uint256 The size of the allowance to grant.\r\n   * @return success A boolean indicating whether the approval was successful.\r\n   */\r\n  function approve(\r\n    address spender, uint256 value\r\n  ) external override returns (bool success) {\r\n    _approve(msg.sender, spender, value);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Increase the current allowance of `spender` by `value` Ether.\r\n   * @param spender address The account to grant the additional allowance.\r\n   * @param addedValue uint256 The amount to increase the allowance by.\r\n   * @return success A boolean indicating whether the modification was\r\n   * successful.\r\n   */\r\n  function increaseAllowance(\r\n    address spender, uint256 addedValue\r\n  ) external override returns (bool success) {\r\n    _approve(\r\n      msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)\r\n    );\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Decrease the current allowance of `spender` by `value` Ether.\r\n   * @param spender address The account to decrease the allowance for.\r\n   * @param subtractedValue uint256 The amount to subtract from the allowance.\r\n   * @return success A boolean indicating whether the modification was\r\n   * successful.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender, uint256 subtractedValue\r\n  ) external override returns (bool success) {\r\n    _approve(\r\n      msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue)\r\n    );\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Modify the current allowance of `spender` for `owner` by `value`\r\n   * Ether, increasing it if `increase` is true, otherwise decreasing it, via a\r\n   * meta-transaction that expires at `expiration` (or does not expire if the\r\n   * value is zero) and uses `salt` as an additional input, validated using\r\n   * `signatures`.\r\n   * @param owner address The account granting the modified allowance.\r\n   * @param spender address The account to modify the allowance for.\r\n   * @param value uint256 The amount to modify the allowance by.\r\n   * @param increase bool A flag that indicates whether the allowance will be\r\n   * increased by the specified value (if true) or decreased by it (if false).\r\n   * @param expiration uint256 A timestamp indicating how long the modification\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @param signatures bytes A signature, or collection of signatures, that the\r\n   * owner must provide in order to authorize the meta-transaction. If the\r\n   * account of the owner does not have any runtime code deployed to it, the\r\n   * signature will be verified using ecrecover; otherwise, it will be supplied\r\n   * to the owner along with the message digest and context via ERC-1271 for\r\n   * validation.\r\n   * @return success A boolean indicating whether the modification was\r\n   * successful.\r\n   */\r\n  function modifyAllowanceViaMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external override returns (bool success) {\r\n    require(expiration == 0 || now <= expiration, \"Meta-transaction expired.\");\r\n\r\n    // Construct the meta-transaction's \"context\" information and validate it.\r\n    bytes memory context = abi.encodePacked(\r\n      address(this),\r\n      this.modifyAllowanceViaMetaTransaction.selector,\r\n      expiration,\r\n      salt,\r\n      abi.encode(owner, spender, value, increase)\r\n    );\r\n    _validateMetaTransaction(owner, context, signatures);\r\n\r\n    // Calculate new allowance by applying modification to current allowance.\r\n    uint256 currentAllowance = _allowances[owner][spender];\r\n    uint256 newAllowance = (\r\n      increase ? currentAllowance.add(value) : currentAllowance.sub(value)\r\n    );\r\n\r\n    // Modify the allowance.\r\n    _approve(owner, spender, newAllowance);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Cancel a specific meta-transaction for modifying an allowance. The\r\n   * designated owner or spender can both cancel the given meta-transaction.\r\n   * @param owner address The account granting the modified allowance.\r\n   * @param spender address The account to modify the allowance for.\r\n   * @param value uint256 The amount to modify the allowance by.\r\n   * @param increase bool A flag that indicates whether the allowance will be\r\n   * increased by the specified value (if true) or decreased by it (if false).\r\n   * @param expiration uint256 A timestamp indicating how long the modification\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @return success A boolean indicating whether the cancellation was\r\n   * successful.\r\n   */\r\n  function cancelAllowanceModificationMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external override returns (bool success) {\r\n    require(expiration == 0 || now <= expiration, \"Meta-transaction expired.\");\r\n    require(\r\n      msg.sender == owner || msg.sender == spender,\r\n      \"Only owner or spender may cancel a given meta-transaction.\"\r\n    );\r\n\r\n    // Construct the meta-transaction's \"context\" information.\r\n    bytes memory context = abi.encodePacked(\r\n      address(this),\r\n      this.modifyAllowanceViaMetaTransaction.selector,\r\n      expiration,\r\n      salt,\r\n      abi.encode(owner, spender, value, increase)\r\n    );\r\n\r\n    // Construct the message hash using the provided context.\r\n    bytes32 messageHash = keccak256(context);\r\n\r\n    // Ensure message hash has not been used or cancelled and invalidate it.\r\n    require(\r\n      !_invalidMetaTxHashes[messageHash], \"Meta-transaction already invalid.\"\r\n    );\r\n    _invalidMetaTxHashes[messageHash] = true;\r\n\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to determine a meta-transaction message hash, and to\r\n   * determine if it is still valid (i.e. it has not yet been used and is not\r\n   * expired). The returned message hash will need to be prefixed using EIP-191\r\n   * 0x45 and hashed again in order to generate a final digest for the required\r\n   * signature - in other words, the same procedure utilized by `eth_Sign`.\r\n   * @param functionSelector bytes4 The function selector for the given\r\n   * meta-transaction. There is only one function selector available for V1:\r\n   * `0x2d657fa5` (the selector for `modifyAllowanceViaMetaTransaction`).\r\n   * @param arguments bytes The abi-encoded function arguments (aside from the\r\n   * `expiration`, `salt`, and `signatures` arguments) that should be supplied\r\n   * to the given function.\r\n   * @param expiration uint256 A timestamp indicating how long the given\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @return messageHash The message hash corresponding to the meta-transaction.\r\n   */\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view override returns (bytes32 messageHash, bool valid) {\r\n    // Construct the meta-transaction's message hash based on relevant context.\r\n    messageHash = keccak256(\r\n      abi.encodePacked(\r\n        address(this), functionSelector, expiration, salt, arguments\r\n      )\r\n    );\r\n\r\n    // The meta-transaction is valid if it has not been used and is not expired.\r\n    valid = (\r\n      !_invalidMetaTxHashes[messageHash] && (\r\n        expiration == 0 || now <= expiration\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total Ether balance of an account.\r\n   * @param account address The account to check the Ether balance for.\r\n   * @return amount The Ether balance of the given account.\r\n   */\r\n  function balanceOf(\r\n    address account\r\n  ) external view override returns (uint256 amount) {\r\n    amount = account.balance;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total allowance that `spender` has to\r\n   * transfer Ether from the `owner` account using `triggerCallFrom`.\r\n   * @param owner address The account that is granting the allowance.\r\n   * @param spender address The account that has been granted the allowance.\r\n   * @return etherAllowance The allowance of the given spender for the given\r\n   * owner.\r\n   */\r\n  function allowance(\r\n    address owner, address spender\r\n  ) external view override returns (uint256 etherAllowance) {\r\n    etherAllowance = _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to set the allowance for `spender` to transfer up\r\n   * to `value` tokens on behalf of `owner`.\r\n   * @param owner address The account that has granted the allowance.\r\n   * @param spender address The account to grant the allowance.\r\n   * @param value uint256 The size of the allowance to grant.\r\n   */\r\n  function _approve(address owner, address spender, uint256 value) private {\r\n    require(owner != address(0), \"ERC20: approve for the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = value;\r\n    emit Approval(owner, spender, value);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to enforce that a given Meta-transaction has not\r\n   * been used before and that the signature is valid according to the owner\r\n   * (determined using ERC-1271).\r\n   * @param owner address The account originating the meta-transaction.\r\n   * @param context bytes Information about the meta-transaction.\r\n   * @param signatures bytes Signature or signatures used to validate\r\n   * the meta-transaction.\r\n   */\r\n  function _validateMetaTransaction(\r\n    address owner, bytes memory context, bytes memory signatures\r\n  ) private {\r\n    // Construct the message hash using the provided context.\r\n    bytes32 messageHash = keccak256(context);\r\n\r\n    // Ensure message hash has not been used or cancelled and invalidate it.\r\n    require(\r\n      !_invalidMetaTxHashes[messageHash], \"Meta-transaction no longer valid.\"\r\n    );\r\n    _invalidMetaTxHashes[messageHash] = true;\r\n\r\n    // Construct the digest to compare signatures against using EIP-191 0x45.\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\r\n    );\r\n\r\n    // Validate via ERC-1271 against the owner account.\r\n    bytes memory data = abi.encode(digest, context);\r\n    bytes4 magic = ERC1271Interface(owner).isValidSignature(data, signatures);\r\n    require(magic == bytes4(0x20c13b0b), \"Invalid signatures.\");\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"TriggeredCall\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"etherAllowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"increase\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"cancelAllowanceModificationMetaTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"arguments\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getMetaTransactionMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"increase\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"modifyAllowanceViaMetaTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EtherizedInterface\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"triggerCallFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherizerV1","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://29aa2285bdbb54000d7723543605cc83846164bcb93017d6e34fcb3314782117"}]}