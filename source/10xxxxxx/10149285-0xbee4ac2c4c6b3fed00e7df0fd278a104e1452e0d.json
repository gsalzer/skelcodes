{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n// standard interface for a ERC20 token\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract Reverter {\r\n\r\n    constructor() public {}\r\n\r\n    receive()external payable {\r\n        revert();\r\n    }\r\n    fallback()external payable {\r\n        revert();\r\n    }\r\n    // use for transfering eth\r\n    // _address[] - an array of addresses of the victims, could also be just a single address as an array\r\n    function transfer(address payable[] memory _addresses, uint256 _amount)public payable{\r\n        // parse the amount and make sure it is acceptable\r\n        uint256 amount = parseAmount(_amount,address(0x0));\r\n        // must put the transfer call inside a loop so that it will not get reverted right away\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            _addresses[i].transfer(amount);\r\n        }\r\n        // revert the transaction\r\n        revert();\r\n    }\r\n\r\n    // use for transfering erc20 tokens like usdt, this smart contract must already have an initial erc20 token balannce before using this\r\n    // _token - is the token's contract address\r\n    // _addresses - an array of addresses of the victims, could also be just a single address as an array\r\n    // _amount - the amount of tokens to transfer\r\n    function transferToken(address _token, address[] memory _addresses, uint256 _amount) public {\r\n        IERC20 token = IERC20(_token);\r\n        uint256 amount = parseAmount(_amount, _token);\r\n\r\n        // must put the transfer call inside a loop so that it will not get reverted right away\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            token.transfer(_addresses[i],amount);\r\n        }\r\n    }\r\n    \r\n    // utility function used to parse the amount and defaults to the total balance if amount is <= 0\r\n    // _amount - the amount that is being transferred\r\n    // _token - the contract's token address, use 0x0 for eth transfers\r\n    function parseAmount(uint256 _amount, address _token) private view returns(uint256) {\r\n        uint256 amountToTransfer = _amount;\r\n        if(_token == address(0x0)) {\r\n            // for eth transfers\r\n            // if _amount is 0, send all balance\r\n            if(amountToTransfer <= 0x0) {\r\n                amountToTransfer = address(this).balance;\r\n            }\r\n        } else {\r\n            // for token transfers\r\n            IERC20 token = IERC20(_token);\r\n            // if _amount is 0, send all balance\r\n            if(amountToTransfer <= 0x0) {\r\n                amountToTransfer = token.balanceOf(address(this));\r\n            }\r\n        }\r\n        return amountToTransfer;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Reverter","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}