{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface TokenInterface {\r\n    function balanceOf(address) external view returns (uint);\r\n    function transfer(address, uint) external returns (bool);\r\n    function approve(address, uint) external;\r\n}\r\n\r\ninterface ListInterface {\r\n    struct AccountLink {\r\n        address first;\r\n        address last;\r\n        uint64 count;\r\n    }\r\n\r\n    function accountID(address) external view returns (uint64);\r\n    function accountLink(uint) external view returns (AccountLink memory);\r\n}\r\n\r\ninterface AccountInterface {\r\n    function auth(address) external view returns (bool);\r\n    function cast(\r\n        address[] calldata _targets,\r\n        bytes[] calldata _datas,\r\n        address _origin\r\n    ) external payable;\r\n}\r\n\r\ninterface IndexInterface {\r\n    function build(\r\n        address _owner,\r\n        uint accountVersion,\r\n        address _origin\r\n    ) external returns (address _account);\r\n    function buildWithCast(\r\n        address _owner,\r\n        uint accountVersion,\r\n        address[] calldata _targets,\r\n        bytes[] calldata _datas,\r\n        address _origin\r\n    ) external payable returns (address _account);\r\n}\r\n\r\ninterface ManagerLike {\r\n    function owns(uint) external view returns (address);\r\n    function give(uint, address) external;\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaIndex address\r\n     */\r\n    function getIndexAddress() internal pure returns (address) {\r\n        return 0x2971AdFa57b20E5a416aE5a708A8655A9c74f723;\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaList address\r\n     */\r\n    function getListAddress() internal pure returns (address) {\r\n        return 0x4c8a1BEb8a87765788946D6B19C6C6355194AbEb;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Maker MCD Manager Address.\r\n    */\r\n    function getMcdManager() internal pure returns (address) {\r\n        return 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\r\n    }\r\n\r\n}\r\n\r\ncontract MigrateProxy is Helpers {\r\n\r\n    event LogMigrate(address dsa, address[] tokens, address[] ctokens, uint[] vaults);\r\n\r\n    function migrateVaults(address dsa, uint[] memory vaults) private {\r\n        ManagerLike managerContract = ManagerLike(getMcdManager());\r\n        for (uint i = 0; i < vaults.length; i++) managerContract.give(vaults[i], dsa);\r\n    }\r\n\r\n    function migrateAllowances(address dsa, address[] memory tokens) private {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            uint tokenAmt = tokenContract.balanceOf(address(this));\r\n            if (tokenAmt > 0) tokenContract.approve(dsa, tokenAmt);\r\n        }\r\n    }\r\n\r\n    function migrateTokens(address dsa, address[] memory tokens) private {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            uint tokenAmt = tokenContract.balanceOf(address(this));\r\n            if (tokenAmt > 0) tokenContract.transfer(dsa, tokenAmt);\r\n        }\r\n    }\r\n\r\n    struct MigrateData {\r\n        uint[] vaults;\r\n        address[] tokens;\r\n        address[] ctokens;\r\n    }\r\n\r\n\r\n    function migrate(\r\n        address[] calldata targets,\r\n        bytes[] calldata calldatas,\r\n        MigrateData calldata migrateData\r\n    ) external payable {\r\n        uint _len = migrateData.ctokens.length;\r\n        address _dsa;\r\n        if (_len > 0) {\r\n            _dsa = IndexInterface(getIndexAddress()).build(\r\n                address(this),\r\n                1,\r\n                address(0)\r\n            );\r\n\r\n            migrateAllowances(_dsa, migrateData.ctokens);\r\n            AccountInterface dsaContract = AccountInterface(_dsa);\r\n            dsaContract.cast.value(address(this).balance)(targets, calldatas, address(0));\r\n            require(dsaContract.auth(msg.sender), \"msg.sender-is-not-auth.\");\r\n            ListInterface listContract = ListInterface(getListAddress());\r\n            uint64 dsaId = listContract.accountID(_dsa);\r\n            require(listContract.accountLink(dsaId).count == 1, \"more-than-one-auth\");\r\n        } else {\r\n            _dsa = IndexInterface(getIndexAddress()).build(\r\n                msg.sender,\r\n                1,\r\n                address(0)\r\n            );\r\n        }\r\n        migrateVaults(_dsa, migrateData.vaults);\r\n        migrateTokens(_dsa, migrateData.tokens);\r\n\r\n        emit LogMigrate(_dsa, migrateData.tokens, migrateData.ctokens, migrateData.vaults);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dsa\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"ctokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"vaults\",\"type\":\"uint256[]\"}],\"name\":\"LogMigrate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"vaults\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"ctokens\",\"type\":\"address[]\"}],\"internalType\":\"struct MigrateProxy.MigrateData\",\"name\":\"migrateData\",\"type\":\"tuple\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"MigrateProxy","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://13da02c698f0e9949a0ffe42720b95e88c8333c77366872484eff98271bb1716"}]}