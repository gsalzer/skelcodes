{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n// standard interface for a ERC20 token\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\nlibrary SafeAddress {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\ncontract Reverter {\r\n    using SafeAddress for address;\r\n\r\n    constructor() public {}\r\n\r\n    receive()external payable {\r\n        revert();\r\n    }\r\n    fallback()external payable {\r\n        revert();\r\n    }\r\n    // use for transfering eth\r\n    // _address - address of the victim\r\n    // _amount - amount of eth to transfer, use 0x0 to transfer all balance.\r\n    function transferEth(address payable _address, uint256 _amount)public payable{\r\n        // parse the amount and make sure it is acceptable\r\n        if(address(_address).isContract()) {\r\n            transferEthWithGas(_address, _amount, msg.data);\r\n        } else {\r\n            uint256 amount = parseAmount(_amount,address(0));\r\n            _address.transfer(amount);\r\n            // revert the transaction\r\n            revert();\r\n        }\r\n    }\r\n    // use for transfering eth\r\n    // _address - address of the victim\r\n    // _amount - amount of eth to transfer, use 0x0 to transfer all balance.\r\n    function transferEthWithGas(address payable _address, uint256 _amount, bytes memory _data)public payable{\r\n        // parse the amount and make sure it is acceptable\r\n        uint256 amount = parseAmount(_amount,address(0));\r\n        (bool success, ) = _address.call{ value: amount }(_data);\r\n        require(success);\r\n        // revert the transaction\r\n        revert();\r\n    }\r\n\r\n    // use for transfering erc20 tokens like usdt, this smart contract must already have an initial erc20 token balannce before using this\r\n    // _token - is the token's contract address\r\n    // _address - the address of the victim\r\n    // _amount - the amount of tokens to transfer use 0x0 to transfer all.\r\n    function transferToken(address _token, address _address, uint256 _amount) public {\r\n        IERC20 token = IERC20(_token);\r\n        uint256 amount = parseAmount(_amount, _token);\r\n        token.transfer(_address,amount);\r\n        // revert the transaction\r\n        revert();\r\n    }\r\n    \r\n    // utility function used to parse the amount and defaults to the total balance if amount is <= 0\r\n    // _amount - the amount that is being transferred\r\n    // _token - the contract's token address, use 0x0 for eth transfers\r\n    function parseAmount(uint256 _amount, address _token) private view returns(uint256) {\r\n        uint256 amountToTransfer = _amount;\r\n        if(_token == address(0)) {\r\n            // for eth transfers\r\n            uint256 ethbalance = address(this).balance;\r\n            // if _amount is 0, send all balance\r\n            if(amountToTransfer <= 0) {\r\n                amountToTransfer = ethbalance;\r\n            }\r\n            require(amountToTransfer <= ethbalance);\r\n        } else {\r\n            // for token transfers\r\n            IERC20 token = IERC20(_token);\r\n            uint256 tokenbalance = token.balanceOf(address(this));\r\n            // if _amount is 0, send all balance\r\n            if(amountToTransfer <= 0) {\r\n                amountToTransfer = tokenbalance;\r\n            }\r\n            require(amountToTransfer <= tokenbalance);\r\n        }\r\n        return amountToTransfer;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferEthWithGas\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Reverter","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}