{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\ncontract IERC20 {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\ncontract Admin{\r\n  mapping(address=>bool) public admin;\r\n  constructor() public{\r\n    admin[msg.sender]=true;\r\n    admin[address(this)]=true;\r\n  }\r\n  function addAdmin(address newadmin) public{\r\n    require(admin[msg.sender],\"caller must be admin\");\r\n    admin[newadmin]=true;\r\n  }\r\n  function isAdmin(address tocheck) public view returns(bool){\r\n    return admin[tocheck];\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a,\"addition failed\");\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a,\"subtraction failed\");\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b,\"multiplication failed\");\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0,\"division failed\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Lottery contract\r\n *\r\n *\r\n */\r\n\r\n contract Lottery{\r\n  using SafeMath for uint256;\r\n  mapping(uint => mapping (uint => uint)) public token_map;\r\n  mapping(uint => mapping (uint => address)) public entry_map;\r\n  mapping(uint => mapping (uint => uint)) public entry_position_map;\r\n  mapping (address => uint) public token_count_by_address;\r\n  uint public current_round;\r\n  uint public entry_cursor;\r\n  uint public cursor;\r\n  IERC20 public token;\r\n  IERC20 public ghostToken;\r\n  Admin public administration; //other contracts allowed to access functions\r\n  address public contractCreator; //contract creator allowed to access different functions\r\n  bool public setup_phase=true;//SHOULD BE FALSE. This allows universal whitelisting etc. for the sake of smoother initialization of the whole system.\r\n  //bytes32 public datakey;//the key for retrieving random value\r\n  bytes32 public entropyHash;//secret for preventing miner manipulation of random\r\n  uint256 public finalizationBlock;//the block from which random winner will be derived\r\n  uint256 public winningIndex;\r\n  bool public withdrawOccurred=false;\r\n\r\n  //timing variables\r\n  uint public staking_period=18 days;\r\n  uint public pre_staking_period=0;//60*60*24;\r\n  uint public staking_becomes_available_time;\r\n  uint public finalization_time;\r\n\r\n  modifier isSetup(){\r\n    require(setup_phase,\"not setup phase\");\r\n    _;\r\n  }\r\n  modifier isCreator(){\r\n    require(contractCreator==msg.sender,\"is not creator\");\r\n    _;\r\n  }\r\n  modifier isAdmin(){\r\n    require(administration.isAdmin(msg.sender),\"is not admin\");\r\n    _;\r\n  }\r\n  modifier isPreStakingTime(){\r\n    require(now<staking_becomes_available_time,\"is not prestakingtime\");\r\n    _;\r\n  }\r\n  modifier isStakingTime(){\r\n    require(now>=staking_becomes_available_time && now<finalization_time,\"is not staking time\");\r\n    _;\r\n  }\r\n  modifier contestFinalized(){\r\n    require(now>=finalization_time && getWinningIndex()>0,\"is not contestfinalized\");\r\n    _;\r\n  }\r\n  constructor(address token,address ghost3dcontract) public{\r\n    ghostToken=IERC20(token);\r\n    administration=new Admin();\r\n    administration.addAdmin(ghost3dcontract);\r\n    contractCreator=msg.sender;\r\n    _reset();\r\n  }\r\n\r\n\r\n  function setWinningIndex1(bytes32 eh) public isCreator{\r\n    require(now>=finalization_time,\"is not finalization time\");\r\n    require(finalizationBlock==0,\"finalization block is already set\");\r\n    entropyHash=eh;\r\n    finalizationBlock=block.number+1;\r\n  }\r\n  //must call this before 256 blocks pass from setWinnngIndex1\r\n  function setWinningIndex2(uint a,uint b) public isCreator{\r\n    require(finalizationBlock!=0,\"fblock is zero\");\r\n    require(block.number>=finalizationBlock,\"block number not large enough yet\");\r\n    require(block.number<finalizationBlock+256,\"block number progressed too far\");\r\n    require(keccak256(abi.encodePacked(a,b))==entropyHash,\"hash does not match\");\r\n    winningIndex=random(cursor,finalizationBlock,a);\r\n  }\r\n  function getWinningIndex() public view returns(uint256){\r\n    return winningIndex;//rp.data(datakey);\r\n  }\r\n  function getHashCombo(uint a,uint b) pure returns(bytes32){\r\n    return keccak256(abi.encodePacked(a,b));\r\n  }\r\n  function maxRandom(uint blockn, uint256 entropy)\r\n    internal\r\n    returns (uint256 randomNumber)\r\n    {\r\n        return uint256(keccak256(\r\n            abi.encodePacked(\r\n              blockhash(blockn),\r\n              entropy)\r\n        ));\r\n    }\r\n  function random(uint256 upper, uint256 blockn, uint256 entropy)\r\n    internal\r\n    returns (uint256 randomNumber)\r\n    {\r\n        return maxRandom(blockn, entropy) % upper + 1;\r\n    }\r\n\r\n\r\n  //progress to the next round if no one entered the contest\r\n  //unneeded because only one round\r\n  /*\r\n  function progressUnused() public isAdmin {\r\n    require(now>=finalization_time && entry_cursor==0,\"progressUnused failed\");\r\n    _reset();\r\n  }\r\n  */\r\n  /*\r\n    Only callable by contracts listed in isAdmin\r\n  */\r\n  function lockTokens(address entrant,uint toLock) public isStakingTime isAdmin{\r\n    require(toLock>3);\r\n    entry_cursor=entry_cursor.add(1);\r\n    token_map[current_round][cursor.add(1)]=entry_cursor;\r\n    token_map[current_round][cursor.add(toLock)]=entry_cursor;\r\n    entry_position_map[current_round][entry_cursor]=cursor.add(1);\r\n    cursor=cursor.add(toLock);\r\n    entry_map[current_round][entry_cursor]=entrant;//msg.sender;\r\n    token_count_by_address[entrant]=token_count_by_address[entrant].add(toLock);\r\n    //token.transferFrom(entrant,this,toLock);\r\n  }\r\n  function withdrawMyFunds(uint left, uint right){\r\n    withdrawFunds(left,right,msg.sender);\r\n  }\r\n  function withdrawFunds(uint left,uint right,address winner) public contestFinalized{//contestFinalized\r\n    require(getWinningIndex().sub(left)!=getWinningIndex().add(right),\"w1\");//checked indexes should be different positions\r\n    require(getWinningIndex()!=0,\"w2\");\r\n    require(!withdrawOccurred);//can only be done once\r\n    uint leftval=token_map[current_round][getWinningIndex().sub(left)];\r\n    uint rightval=token_map[current_round][getWinningIndex().add(right)];\r\n    require(leftval!=0,\"w3\");//both checked indexes should be nonzero\r\n    require(leftval==rightval,\"w4\");//both checked values should be the same\r\n    require(winner == entry_map[current_round][leftval],\"w5\");//check that the proposed winner actually submitted the given entry\r\n\r\n    ghostToken.transfer(winner,ghostToken.balanceOf(address(this)));\r\n    withdrawOccurred=true;\r\n  }\r\n  function _reset() private{\r\n    current_round=current_round.add(1);\r\n    cursor=0;\r\n    entry_cursor=0;\r\n    staking_becomes_available_time=now.add(pre_staking_period);\r\n    finalization_time=staking_becomes_available_time.add(staking_period);\r\n  }\r\n  /*\r\n    In case tokens are sent after lottery conclusion\r\n  */\r\n  function withdrawTokensAfter(address tokenAddr,address sendTo) public isCreator{\r\n    require(withdrawOccurred); //only possible after winner has been paid.\r\n    IERC20(tokenAddr).transfer(sendTo,IERC20(tokenAddr).balanceOf(address(this)));\r\n  }\r\n  function getWinningAddress() public view returns(address){\r\n    var (l,r) = getWinningOffsets();\r\n    return entry_map[current_round][token_map[current_round][getWinningIndex()-l]];\r\n  }\r\n  function getWinningOffsets() public view returns(uint,uint){\r\n    if(getWinningIndex()==0 || entry_cursor<1){\r\n      return(0,0);\r\n    }\r\n    if(entry_cursor==1){\r\n      return (getWinningIndex()-1,cursor-getWinningIndex());//then return the first entry (the only one)\r\n    }\r\n    for(uint i=2;i<=entry_cursor;i++){\r\n      if(entry_position_map[current_round][i]>getWinningIndex()){\r\n        return (getWinningIndex()-entry_position_map[current_round][i-1],entry_position_map[current_round][i]-1-getWinningIndex());\r\n      }\r\n    }\r\n    return (getWinningIndex()-entry_position_map[current_round][entry_cursor],cursor-getWinningIndex());\r\n  }\r\n  function getEthBalance() public view returns(uint){\r\n    return address(this).balance;\r\n  }\r\n  function contestOver() public view returns(bool){\r\n    return now>=finalization_time;\r\n  }\r\n  function timeToFinalization() public view returns(uint256){\r\n    if(now<finalization_time){\r\n      return finalization_time-now;\r\n    }\r\n    else{\r\n      return 0;\r\n    }\r\n  }\r\n  //fallback function\r\n  function () public payable{\r\n    revert();\r\n  }\r\n  //ends setup phase. Must call this after deploying all the contracts.\r\n  function endSetup() public{\r\n    setup_phase=false;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"finalizationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staking_becomes_available_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cursor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administration\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"left\",\"type\":\"uint256\"},{\"name\":\"right\",\"type\":\"uint256\"}],\"name\":\"withdrawMyFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setup_phase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeToFinalization\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entry_position_map\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"setWinningIndex2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"getHashCombo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSetup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawOccurred\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entry_map\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entry_cursor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ghostToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"token_count_by_address\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eh\",\"type\":\"bytes32\"}],\"name\":\"setWinningIndex1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"left\",\"type\":\"uint256\"},{\"name\":\"right\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entropyHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalization_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entrant\",\"type\":\"address\"},{\"name\":\"toLock\",\"type\":\"uint256\"}],\"name\":\"lockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contestOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"token_map\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staking_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningOffsets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pre_staking_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawTokensAfter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"ghost3dcontract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004c327471c44b2dacd6e90525f9d629bd2e4f662c000000000000000000000000de49f6f7505275fcc3d3e8fbc9bc1c034c096877","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6835c63ed9e15c7144cbc1b6719e6ef04cbc17e13f36b13d47b749802750c513"}]}