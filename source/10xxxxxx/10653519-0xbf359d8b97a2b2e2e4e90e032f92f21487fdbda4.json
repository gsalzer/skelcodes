{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface TestyInterface {\r\n  event CallSuccess(\r\n    bytes32 actionID,\r\n    bool rolledBack,\r\n    uint256 nonce,\r\n    address to,\r\n    bytes data,\r\n    bytes returnData\r\n  );\r\n\r\n  event CallFailure(\r\n    bytes32 actionID,\r\n    uint256 nonce,\r\n    address to,\r\n    bytes data,\r\n    string revertReason\r\n  );\r\n\r\n  // ABIEncoderV2 uses an array of Calls for executing generic batch calls.\r\n  struct Call {\r\n    address to;\r\n    bytes data;\r\n  }\r\n\r\n  // ABIEncoderV2 uses an array of CallReturns for handling generic batch calls.\r\n  struct CallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n  }\r\n\r\n  function executeAction(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok, bytes memory returnData);\r\n\r\n  function executeActionWithAtomicBatchCalls(\r\n    Call[] calldata calls,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool[] memory ok, bytes[] memory returnData);\r\n}\r\n\r\n\r\n// TOTALLY PUBLIC CONTRACT, DON'T SEND ME ANY MONEY!\r\ncontract Testy is TestyInterface {\r\n  function executeAction(\r\n    address to,\r\n    bytes calldata data,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok, bytes memory returnData) {\r\n    (ok, returnData) = to.call(data);\r\n    \r\n    // Emit a CallSuccess or CallFailure event based on the outcome of the call.\r\n    if (ok) {\r\n      // Note: while the call succeeded, the action may still have \"failed\"\r\n      // (for example, successful calls to Compound can still return an error).\r\n      emit CallSuccess(bytes32(\"actionID\"), false, 1, to, data, returnData);\r\n    } else {\r\n      // Note: while the call failed, the nonce will still be incremented, which\r\n      // will invalidate all supplied signatures.\r\n      emit CallFailure(bytes32(\"actionID\"), 1, to, data, string(returnData));\r\n    }\r\n  }\r\n\r\n  function executeActionWithAtomicBatchCalls(\r\n    Call[] memory calls,\r\n    uint256 minimumActionGas,\r\n    bytes memory userSignature,\r\n    bytes memory dharmaSignature\r\n  ) public returns (bool[] memory ok, bytes[] memory returnData) {\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._executeActionWithAtomicBatchCallsAtomic.selector, calls\r\n      )\r\n    );\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      Call memory currentCall = calls[i];\r\n\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\r\n      if (callResults[i].ok) {\r\n        // Note: while the call succeeded, the action may still have \"failed\".\r\n        emit CallSuccess(\r\n          bytes32(\"actionID\"),\r\n          !externalOk, // If another call failed this will have been rolled back\r\n          1,\r\n          currentCall.to,\r\n          currentCall.data,\r\n          callResults[i].returnData\r\n        );\r\n      } else {\r\n        // Note: while the call failed, the nonce will still be incremented,\r\n        // which will invalidate all supplied signatures.\r\n        emit CallFailure(\r\n          bytes32(\"actionID\"),\r\n          1,\r\n          currentCall.to,\r\n          currentCall.data,\r\n          string(callResults[i].returnData)\r\n        );\r\n\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _executeActionWithAtomicBatchCallsAtomic(\r\n    Call[] memory calls\r\n  ) public returns (CallReturn[] memory callResults) {\r\n    bool rollBack = false;\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = calls[i].to.call(calls[i].data);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        rollBack = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (rollBack) {\r\n      // Wrap in length encoding and revert (provide data instead of a string).\r\n      bytes memory callResultsBytes = abi.encode(callResults);\r\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n    }\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"revertReason\",\"type\":\"string\"}],\"name\":\"CallFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rolledBack\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"CallSuccess\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TestyInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_executeActionWithAtomicBatchCallsAtomic\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"internalType\":\"struct TestyInterface.CallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"executeAction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TestyInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"executeActionWithAtomicBatchCalls\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"ok\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Testy","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2318d29f4b05f1bedfce991ce942bf9cffeaa6cb7197a8eb2b506fd7da91462c"}]}