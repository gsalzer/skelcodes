{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n*\r\n* SmartCity\r\n* https://ethercity.io\r\n* (only for ethercity.io Community)\r\n* Version 2.0\r\n*\r\n**/\r\n\r\n\r\npragma solidity ^0.5.15;\r\n\r\ncontract EtherCity {\r\n\r\n    struct User {\r\n        uint id;\r\n        address refBy;\r\n        address[] refs;\r\n        uint refsCount;\r\n        uint teamCount;\r\n        // uint networkSize;\r\n\r\n        mapping(uint => bool) activeMember;\r\n\r\n        mapping(uint => Matrix) CityMatrix;\r\n\r\n        mapping(uint => Myearnings) earnings;\r\n    }\r\n\r\n    struct Matrix {\r\n        address refBy;\r\n        address[] refs1;\r\n        address[] refs2;\r\n        bool active;\r\n        uint expiresOn;\r\n        uint reinvestCount;\r\n    }\r\n\r\n    struct Myearnings{\r\n        uint dreEarnings;\r\n        uint matrixEarnings;\r\n        uint missedEarnings;\r\n        uint matchingBonus;\r\n        uint missedBonus;\r\n    }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n    mapping(uint => address) public userIds;\r\n    mapping(address => uint) public balances;\r\n    \r\n    bool public matrixInitialized = false;\r\n    \r\n    address private vaultMissed = 0x217E758839395FCd954C912519f5b8FB7F22E393;\r\n    address public contractor;\r\n    uint private MatrixexpiresOn_0 = 100000 days;\r\n    uint private MatrixexpiresOn_1 = 30 days;\r\n    uint private MatrixexpiresOn_2 = 60 days;\r\n    uint private MatrixexpiresOn_3 = 90 days;\r\n    uint private MatrixexpiresOn_4 = 120 days;\r\n    \r\n    \r\n    uint public lastUserId = 1;\r\n    uint public activeUsers = 1;\r\n    uint public raisedToday = 0 ether;\r\n    uint public raisedTotal = 0 ether;\r\n    uint public distEarning = 0 ether;\r\n    uint public lostEarnings = 0 ether;\r\n    uint public matrixIncomes = 0 ether;\r\n    uint public matchIncomes = 0 ether;\r\n    uint public joinedToday = 0;\r\n    uint public lasUpdate = now;\r\n\r\n    uint private dre    = 10;\r\n    uint private refs1  = 18;\r\n    uint private refs1b = 9;\r\n    uint private refs2  = 40;\r\n    uint private refs2b = 20;\r\n    uint private fees   = 1; // x3\r\n\r\n    mapping(address => Initialisation) private inits;\r\n\r\n    struct Initialisation{\r\n        address[] members;\r\n    }\r\n\r\n    // address[] inits;\r\n\r\n    mapping(uint => uint) public levelPrice;\r\n\r\n    event NewUser(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    event Renewal(address indexed user, address indexed referrer, address indexed caller, uint matrix, uint level);\r\n    event Upgrade(address indexed user, address indexed referrer, uint matrix);\r\n    event NewDownline(address indexed user, address indexed referrer, uint level, uint generation, uint count);\r\n    event DividentReceived(address indexed from, address indexed receiver, uint matrix, uint level);\r\n    event MissedDivident(address indexed receiver, address indexed from, uint matrix, uint level, uint _type);\r\n    event MissedEarnings(address indexed _beneficiary, uint _level, uint _position, uint _amount);\r\n\r\n    constructor() public {\r\n\r\n        contractor = msg.sender;\r\n\r\n        User memory user = User({\r\n            id: 1,\r\n            refBy: address(0),\r\n            refs: new address[](0),\r\n            refsCount: uint(0),\r\n            teamCount: uint(0)\r\n        });\r\n\r\n        users[contractor] = user;\r\n        idToAddress[lastUserId] = contractor;\r\n        userIds[lastUserId] = contractor;\r\n\r\n\r\n        lastUserId++;\r\n        joinedToday++;\r\n\r\n        for (uint i = 1; i <= 12; i++) {\r\n            users[contractor].activeMember[i] = true;\r\n            users[contractor].CityMatrix[i].expiresOn = now + MatrixexpiresOn_0;\r\n            users[contractor].CityMatrix[i].active = true;\r\n        }\r\n        // matrixInitialisation();\r\n\r\n    }\r\n\r\n    function() external payable {\r\n        if(msg.data.length == 0) {\r\n            return registration(msg.sender, contractor);\r\n        }\r\n\r\n        registration(msg.sender, bytesToAddress(msg.data));\r\n    }\r\n\r\n    modifier validMatrixId(uint _matrixId) {\r\n        require(_matrixId > 0 && _matrixId < 13, 'Invalid MatrixId');\r\n        _;\r\n    }\r\n    \r\n    modifier validateContractor(address _userId){\r\n        require(_userId == contractor && address(this).balance > 0);\r\n        _;\r\n    }\r\n    \r\n    function afterOneDay(uint _lastUpdate) private view returns(bool){\r\n        if(now >= _lastUpdate + 1 * 1 days){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function cannotJumpStages(address _userId, uint _matrixId) private view returns(bool canJoin){\r\n        canJoin = true;\r\n        for(uint p = _matrixId - 1; p > 0; p--){\r\n            canJoin = users[_userId].CityMatrix[p].active;\r\n        }\r\n    }\r\n    \r\n    function highestStage(address _userId) public view returns(uint){\r\n        uint p = 12;\r\n        for(p - 1; p > 0; p--){\r\n            if(users[_userId].CityMatrix[p].active){\r\n                break;\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n    \r\n    function newSignup(address _sponsor) external payable{\r\n        require(msg.value == levelPrice[1], 'To register you Must Buy House 1 which costs 0.025 ether');\r\n        require(!isUserExists(msg.sender), 'Already Registered');\r\n        require(isUserExists(_sponsor), 'Invalid Sponsor Id');\r\n        registration(msg.sender, _sponsor);\r\n    }\r\n    \r\n    function registration(address _userId, address _sponsor) private{\r\n        User memory user = User({\r\n            id: lastUserId,\r\n            refBy: _sponsor,\r\n            refs: new address[](0),\r\n            refsCount: uint(0),\r\n            teamCount: uint(0)\r\n        });\r\n        \r\n        users[_userId] = user;\r\n        idToAddress[lastUserId] = _userId;\r\n        userIds[lastUserId] = _userId;\r\n        users[_userId].refBy = _sponsor;\r\n        lastUserId++;\r\n\r\n        users[_sponsor].refs.push(_userId);\r\n        users[_sponsor].refsCount++;\r\n        // Activates House1\r\n        getProperty(_userId, 1);\r\n        activeUsers++;\r\n        if(afterOneDay(lasUpdate)){\r\n            joinedToday = 0;\r\n        }\r\n        else{\r\n            joinedToday++;\r\n        }\r\n        updateTeamData(_userId);\r\n        // mPurchases += msg.value;\r\n        emit NewUser(_userId, _sponsor, users[_userId].id, users[_sponsor].id);\r\n    }\r\n    \r\n    function buyNewProperty(uint _matrixId) external payable validMatrixId(_matrixId){\r\n        address _userId = msg.sender;\r\n        require(isUserExists(_userId), 'You Must be a Registered Member');\r\n        require(msg.value ==  levelPrice[_matrixId], 'Invalid amount');\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_userId)\r\n        }\r\n        require(size == 0, \"cannot be a contract\");\r\n        if(_matrixId > 1){\r\n            require(cannotJumpStages(_userId, _matrixId), 'You cannot Jump Stages');\r\n        }\r\n        getProperty(_userId, _matrixId);\r\n    }\r\n    \r\n    function getProperty(address _userId, uint _matrixId) private {\r\n        uint cost = levelPrice[_matrixId];\r\n        \r\n        uint _level = _matrixId;\r\n        uint expiresOn = 0;\r\n        if(users[_userId].id < 5){\r\n            users[_userId].CityMatrix[_level].expiresOn = MatrixexpiresOn_0;\r\n        }\r\n        else{\r\n           if(_level >= 1 && _level < 4){\r\n               expiresOn = MatrixexpiresOn_1;\r\n           }\r\n           if(_level >= 4 && _level < 7){\r\n               expiresOn = MatrixexpiresOn_2;\r\n           }\r\n           if(_level >= 7 && _level < 10){\r\n               expiresOn = MatrixexpiresOn_3;\r\n           }\r\n           if(_level >= 10 && _level < 13){\r\n               expiresOn = MatrixexpiresOn_4;\r\n           }\r\n\r\n           if(users[_userId].CityMatrix[_level].expiresOn < now || users[_userId].CityMatrix[_level].expiresOn == 0){\r\n               users[_userId].CityMatrix[_level].expiresOn = now + expiresOn;\r\n           }else{\r\n               users[_userId].CityMatrix[_level].expiresOn += expiresOn;\r\n           }\r\n        }\r\n\r\n        adminDivident(cost, 1);\r\n\r\n        if(users[_userId].CityMatrix[_level].reinvestCount >= 1){\r\n            // Renewal\r\n            address _firstUpline = users[_userId].CityMatrix[_level].refBy;\r\n            address _secondUpline = users[_firstUpline].refBy;\r\n            processLevel(_firstUpline, _secondUpline, _level);\r\n            users[_userId].CityMatrix[_level].reinvestCount++;\r\n        }else{\r\n            users[_userId].activeMember[_level] = true;\r\n            users[_userId].CityMatrix[_level].active = true;\r\n            users[_userId].CityMatrix[_level].reinvestCount = 1;\r\n            DirectReferral(users[_userId].refBy, cost);\r\n            // update Upline\r\n            updateMatrixUpliner(_userId, getUpline(_userId, users[_userId].refBy, _level, 1), _matrixId);\r\n        }\r\n        if(afterOneDay(lasUpdate)){\r\n            lasUpdate = now;\r\n            raisedToday = 0;\r\n        }\r\n        else{\r\n            raisedToday += cost;\r\n        }\r\n        raisedTotal += cost;\r\n        emit Upgrade(_userId, users[_userId].refBy, _matrixId);\r\n    }\r\n\r\n    function getUpline(address _self, address _userId, uint _level, uint up) private returns(address){\r\n        if(guDownlines(_userId, _level) < 3){\r\n            if(checkActiveStatus(_userId, _level)){\r\n                return _userId;\r\n            }\r\n            else{\r\n                if(up == 1){\r\n                    // Missed Income\r\n                    // missedEarnings(_userId, _level);\r\n                    // next Availble Upline\r\n                    return getUpline(_self, users[_userId].refBy, _level, 2);\r\n                }\r\n                if(up == 2){\r\n                    return getUpline(_self, contractor, _level, 3);\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            return spillOver(_self, _userId, _level);\r\n        }\r\n    }\r\n    \r\n    function spillOver(address _self, address _userId, uint _level) private returns(address){\r\n        uint v = 0;\r\n        while(v < 3){\r\n            address downline = users[_userId].CityMatrix[_level].refs1[v];\r\n            if(guDownlines(downline, _level) < 3){\r\n                if(checkActiveStatus(downline, _level)){\r\n                    return downline;\r\n                }\r\n            }\r\n            v++;\r\n        }\r\n        uint d = 0;\r\n        for(uint e = 0; e < users[_userId].refs.length; e++){\r\n            address ddownline = users[_userId].refs[e];\r\n            if(ddownline != _self){\r\n                if(guDownlines(ddownline, _level) < 3){\r\n                    if(checkActiveStatus(ddownline, _level)){\r\n                        return ddownline;\r\n                    }\r\n                }\r\n                else{\r\n                    while(d < 3){\r\n                        address dddownline = users[ddownline].CityMatrix[_level].refs1[d];\r\n                        if(guDownlines(dddownline, _level) < 3){\r\n                            if(checkActiveStatus(dddownline, _level)){\r\n                                return dddownline;\r\n                            }\r\n                        }\r\n                        d++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function updateTeamData(address _userId) private returns(bool){\r\n        while(users[_userId].refBy != address(0)){\r\n            users[users[_userId].refBy].teamCount++;\r\n            _userId = users[_userId].refBy;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function updateMatrixUpliner(address _userId, address _upline, uint _level) private {\r\n        users[_userId].CityMatrix[_level].refBy = _upline;\r\n        users[_upline].CityMatrix[_level].refs1.push(_userId); // Level 1\r\n        address _upline2 = users[_upline].CityMatrix[_level].refBy;\r\n        users[_upline2].CityMatrix[_level].refs2.push(_userId); // Level 2\r\n        processLevel(_upline, _upline2, _level);\r\n        emit NewDownline(_userId, _upline, _level, 1, uint(users[_upline].CityMatrix[_level].refs1.length));\r\n        emit NewDownline(_userId, _upline2, _level, 2, uint(users[_upline2].CityMatrix[_level].refs2.length));\r\n    }\r\n\r\n    function processLevel(address _firstUpline, address _secondUpline, uint _level) private{\r\n        matrixIncome(_firstUpline, levelPrice[_level], _level, 1); // MI1\r\n        matchIncome(users[_firstUpline].refBy, levelPrice[_level], _level, 1); // MB1\r\n        matrixIncome(_secondUpline, levelPrice[_level], _level, 2); // MI2\r\n        matchIncome(users[_secondUpline].refBy, levelPrice[_level], _level, 2); // MB2\r\n    }\r\n\r\n    function DirectReferral(address _userId, uint _amount) private{\r\n        uint payDre = dre * _amount / 100;\r\n        users[_userId].earnings[0].dreEarnings += payDre;\r\n        dividentDistribution(_userId, payDre);\r\n    }\r\n    \r\n    function matrixIncome(address _userId, uint _amount, uint _level, uint _position) private{\r\n        uint refsc;\r\n        if(_position == 1){\r\n            refsc = refs1;\r\n        }else{\r\n            refsc = refs2;\r\n        }\r\n        \r\n        uint payLevel = refsc * _amount / 100;\r\n        users[_userId].earnings[0].matrixEarnings += payLevel;\r\n        matrixIncomes += payLevel;\r\n        address beneficiray;\r\n        if(users[_userId].id > 1){\r\n            beneficiray = checkBeneficiary(_userId, _level, 1, payLevel);\r\n        }\r\n        else{\r\n            beneficiray = _userId;\r\n        }\r\n        dividentDistribution(beneficiray, payLevel);\r\n    }\r\n\r\n    function matchIncome(address _userId, uint _amount, uint _level, uint _position) private{\r\n        uint refsb;\r\n        if(_position == 1){\r\n            refsb = refs1b;\r\n        }else{\r\n            refsb = refs2b;\r\n        }\r\n    \r\n        uint payMb = refsb * _amount / 100;\r\n        users[_userId].earnings[0].matchingBonus += payMb;\r\n        matchIncomes += payMb;\r\n        dividentDistribution(checkBeneficiary(_userId, _level, 2, payMb), payMb);\r\n    }\r\n    \r\n    function dividentDistribution(address _userId, uint _amount) internal returns(bool){\r\n        if(users[_userId].id == 1){\r\n            adminDivident(_amount, 2);\r\n        }\r\n        else if(users[_userId].id == 3){\r\n            contractDivident(_userId, _amount);\r\n        }\r\n        else{\r\n            address(uint160(_userId)).transfer(_amount);\r\n        }\r\n        distEarning += _amount;\r\n        // Emit Earnings Received\r\n        return true;\r\n    }\r\n\r\n    function adminDivident(uint _amount, uint _type) internal returns(bool){\r\n        uint pay;\r\n        // uint div = _amount / 100;\r\n        if(_type == 1){\r\n            pay = _amount * fees / 100;\r\n        }\r\n        else{\r\n            // pay = _amount * 33 / 100;\r\n            pay = _amount / 3;\r\n        }\r\n        for(uint m = 0; m < 3; m++){\r\n            address _admin = users[contractor].refs[m];\r\n            if(m == 1){\r\n                contractDivident(_admin, pay);\r\n            }else{\r\n                address(uint160(_admin)).transfer(pay);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function contractDivident(address _userId, uint _amount) internal returns(bool){\r\n        uint pay1 = _amount * 60 / 100;\r\n        uint pay2 = _amount * 40 / 100;\r\n        address(uint160(_userId)).transfer(pay1);\r\n        address(uint160(contractor)).transfer(pay2);\r\n        return true;\r\n    }\r\n\r\n    function checkBeneficiary(address _userId, uint _level, uint _type, uint _amount) private returns(address _beneficiary){\r\n        if(checkActiveStatus(_userId, _level)){\r\n            _beneficiary = _userId;\r\n        }\r\n        else{\r\n            emit MissedEarnings(_userId, _level, _type, _amount);\r\n            if(_type == 1){\r\n                users[_userId].earnings[0].missedEarnings += _amount;\r\n            }else{\r\n                users[_userId].earnings[0].missedBonus += _amount;\r\n            }\r\n            lostEarnings += _amount;\r\n            _beneficiary = vaultMissed;\r\n        }\r\n    }\r\n    \r\n    function getFallBackEther() public payable validateContractor(msg.sender){\r\n        address(uint160(contractor)).transfer(address(this).balance);\r\n    }\r\n    \r\n    function guDownlines(address _userId, uint _level) public view returns(uint){\r\n        return users[_userId].CityMatrix[_level].refs1.length;\r\n    }\r\n\r\n    function checkActiveStatus(address _userId, uint _level) private returns(bool){\r\n        if(!users[_userId].activeMember[_level] || users[_userId].CityMatrix[_level].expiresOn < now){\r\n            users[_userId].activeMember[_level] = false;\r\n            users[_userId].CityMatrix[_level].active = false;\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function matrixInitialisation() public returns(bool){\r\n        require(msg.sender == contractor, 'Sorry you cannot Run this Function');\r\n        \r\n        require(matrixInitialized == false, 'Matrix Already Initialized');\r\n        \r\n        levelPrice[1] = 0.025 ether;\r\n        for (uint i = 2; i <= 12; i++) {\r\n            levelPrice[i] = levelPrice[i-1] * 2;\r\n        }\r\n        \r\n        users[contractor].refs.push(0x4cDd2f156534d62b872B3C9E1876925207141a5e); // 0x4cDd2f156534d62b872B3C9E1876925207141a5e\r\n\r\n        users[contractor].refs.push(0xA652D6520e3f092eB0Acf7F0DB9A1bC097AA5147); // 0xc12f180e02fb1b401946bd943d6de5150d5e4fc7\r\n\r\n        users[contractor].refs.push(0xB9d504c6826875635C5f1F94E30F61E8D533a8Bd); // 0xB9d504c6826875635C5f1F94E30F61E8D533a8Bd\r\n\r\n        for(uint i = 0; i < users[contractor].refs.length; i++){\r\n            address _userId = users[contractor].refs[i];\r\n            User memory user = User({\r\n                id: lastUserId,\r\n                refBy: address(contractor),\r\n                refs: new address[](0),\r\n                refsCount: uint(0),\r\n                teamCount: uint(0)\r\n            });\r\n\r\n            users[_userId] = user;\r\n            idToAddress[lastUserId] = _userId;\r\n            userIds[lastUserId] = _userId;\r\n            for (uint b = 1; b <= 12; b++) {\r\n                users[_userId].activeMember[b] = true;\r\n                users[_userId].CityMatrix[b].active = true;\r\n                users[_userId].CityMatrix[b].expiresOn = now + MatrixexpiresOn_0;\r\n            }\r\n\r\n            users[contractor].refsCount++;\r\n            activeUsers++;\r\n\r\n            lastUserId++;\r\n            joinedToday++;\r\n            \r\n            updateTeamData(_userId);\r\n        }\r\n        \r\n\r\n        address _upline = users[contractor].refs[1];\r\n        users[_upline].refs.push(0x22cFacA660BcaB211F9AbefD96396C8019fb6e5F);\r\n        \r\n        for(uint mi = 1; mi <= 12; mi++){\r\n            if(users[contractor].CityMatrix[mi].refs1.length < 3){\r\n                for(uint downe = 0; downe < users[contractor].refs.length; downe++){\r\n                    address _userId = users[contractor].refs[downe];\r\n                    users[_userId].CityMatrix[mi].refBy = contractor;\r\n                    users[contractor].CityMatrix[mi].refs1.push(_userId);\r\n                }\r\n            }\r\n        }\r\n        \r\n        User memory user = User({\r\n            id: lastUserId,\r\n            refBy: address(users[contractor].refs[1]),\r\n            refs: new address[](0),\r\n            refsCount: uint(0),\r\n            teamCount: uint(0)\r\n        });\r\n        \r\n        address _userId = users[_upline].refs[0];\r\n        users[_userId] = user;\r\n        idToAddress[lastUserId] = _userId;\r\n        userIds[lastUserId] = _userId;\r\n        for (uint b = 1; b <= 12; b++) {\r\n            users[_userId].activeMember[b] = true;\r\n            users[_userId].CityMatrix[b].active = true;\r\n            users[_userId].CityMatrix[b].expiresOn = now + MatrixexpiresOn_0;\r\n        }\r\n        users[_upline].refsCount++;\r\n        for(uint mi = 1; mi <= 12; mi++){\r\n            if(users[_upline].CityMatrix[mi].refs1.length < 3){\r\n                users[_userId].CityMatrix[mi].refBy = _upline;\r\n                users[_upline].CityMatrix[mi].refs1.push(_userId);\r\n                users[contractor].CityMatrix[mi].refs2.push(_userId);\r\n            }\r\n        }\r\n        \r\n        activeUsers++;\r\n        lastUserId++;\r\n        joinedToday++;\r\n        \r\n        updateTeamData(_userId);\r\n            \r\n        matrixInitialized = true;\r\n        return true;\r\n    }\r\n    \r\n    function stats() public view returns(uint lId, uint aU, uint rT, uint rTl, uint dE, uint lE, uint mI, uint mCI, uint jT){\r\n        return (lastUserId, activeUsers, raisedToday, raisedTotal, distEarning, lostEarnings, matrixIncomes, matchIncomes, joinedToday);\r\n    }\r\n\r\n    function getUserData(address _userId) public view returns(address _refBy, uint _refs, uint _myTeam, uint _earnings, uint _dearnings, uint _mearnings, uint _maearnings, uint _missedEarning){\r\n        require(isUserExists(_userId), 'Sorry No User Found with matching ETH Address!');\r\n        _refBy = users[_userId].refBy;\r\n        _refs = users[_userId].refsCount;\r\n        _dearnings = users[_userId].earnings[0].dreEarnings;\r\n        _mearnings = users[_userId].earnings[0].matrixEarnings;\r\n        _maearnings = users[_userId].earnings[0].matchingBonus;\r\n        _earnings = _dearnings + _maearnings + _mearnings;\r\n        _missedEarning = users[_userId].earnings[0].missedEarnings + users[_userId].earnings[0].missedBonus;\r\n        _myTeam = users[_userId].teamCount;\r\n    }\r\n\r\n    function isUserExists(address _userAddress) public view returns (bool) {\r\n        return (users[_userAddress].id != 0);\r\n    }\r\n    \r\n    function usersActiveCityMatrix(address _userId, uint _level) public view returns(bool){\r\n        return users[_userId].activeMember[_level];\r\n    }\r\n\r\n    function userMatrixExpiration(address _userId, uint _level) public view returns(uint){\r\n        return users[_userId].CityMatrix[_level].expiresOn;\r\n    }\r\n\r\n    function usersMatrix(address _userId, uint _level) public view returns(address, address[] memory, address[] memory, bool) {\r\n        return (users[_userId].CityMatrix[_level].refBy,\r\n                users[_userId].CityMatrix[_level].refs1,\r\n                users[_userId].CityMatrix[_level].refs2, users[_userId].CityMatrix[_level].active);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}\r\n\r\ncontract EtherCity2 {\r\n    \r\n    EtherCity internal EtherCity_v1;\r\n\r\n    struct User {\r\n        uint id;\r\n        bool isSynched;\r\n        address refBy;\r\n        address[] refs;\r\n        uint afund;\r\n        uint pool_bonus;\r\n        uint withdrawn;\r\n        uint dreEarnings;\r\n        uint matrixEarnings;\r\n        uint missedEarnings;\r\n        uint matchingBonus;\r\n        uint missedBonus;\r\n        uint refsCount;\r\n        uint teamCount;\r\n        uint teamvolume; // Resets Weekly\r\n\r\n        mapping(uint => bool) activeMember;\r\n\r\n        mapping(uint => Matrix) CityMatrix;\r\n    }\r\n\r\n    struct Matrix {\r\n        address refBy;\r\n        address[] refs1;\r\n        address[] refs2;\r\n        uint earnings;\r\n        bool computed;\r\n        bool active;\r\n        uint expiresOn;\r\n        uint reinvestCount;\r\n    }\r\n    \r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n    mapping(uint => address) public userIds;\r\n    mapping(uint => address) public pool_lead;\r\n    \r\n    mapping(uint => uint) internal levelPrice;\r\n    mapping(uint => uint) internal poolPrizes;\r\n    mapping(uint => mapping(address => uint)) internal pool_users_balance;\r\n    uint internal pool_last_draw = uint(block.timestamp);\r\n    uint internal nexpool = 1;\r\n    \r\n    uint internal MatrixexpiresOn = 100 days;\r\n    \r\n    uint public lastUserId = 1;\r\n    uint internal activeUsers = 1;\r\n    uint internal raisedToday = 0 ether;\r\n    uint internal raisedTotal = 0 ether;\r\n    uint internal distEarning = 0 ether;\r\n    uint internal lostEarnings = 0 ether;\r\n    uint internal matrixIncomes = 0 ether;\r\n    uint internal matchIncomes = 0 ether;\r\n    uint internal joinedToday;\r\n    uint internal pool_balance = 0 ether;\r\n    uint internal safety_funds = 0 ether;\r\n    uint internal lastUpdate = uint(block.timestamp);\r\n    uint internal lastSynched = 1;\r\n    \r\n    bool internal matrixInitialized;\r\n    bool internal treeSynched;\r\n\r\n    uint internal constant dre    = 10;\r\n    uint internal constant refs1  = 10;\r\n    uint internal constant refs1b = 5;\r\n    uint internal constant refs2  = 30;\r\n    uint internal constant refs2b = 15;\r\n    uint internal constant system = 5;\r\n    uint internal constant safetyR = 20;\r\n    uint internal constant poolR = 5;\r\n    uint internal constant poolShare = 15;\r\n    uint internal constant divider = 100;\r\n    \r\n    address internal constant vaultMissed = 0x217E758839395FCd954C912519f5b8FB7F22E393;\r\n    address internal contractor;\r\n\r\n    event NewUser(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    event Renewal(address indexed user, address indexed referrer, address indexed caller, uint matrix, uint level);\r\n    event Upgrade(address indexed user, address indexed referrer, uint matrix);\r\n    event NewDownline(address indexed user, address indexed referrer, uint level, uint generation, uint count);\r\n    event DividentReceived(address indexed from, address indexed receiver, uint matrix, uint level);\r\n    event MissedDivident(address indexed receiver, address indexed from, uint matrix, uint level, uint _type);\r\n    event MissedEarnings(address indexed _beneficiary, uint _level, uint _position, uint _amount);\r\n\r\n    constructor() public {\r\n        contractor = msg.sender;\r\n    }\r\n\r\n    function() external payable {\r\n        if(msg.data.length == 0) {\r\n            return registration(msg.sender, contractor);\r\n        }\r\n\r\n        registration(msg.sender, bytesToAddress(msg.data));\r\n    }\r\n    \r\n    modifier onlyContractor(){\r\n        require(msg.sender == contractor, 'You do not have Permission to Proceed!');\r\n        _;\r\n    }\r\n    \r\n    function newSignup(address _sponsor) public payable{\r\n        address _userId = msg.sender;\r\n        require(msg.value == levelPrice[1], 'To register you Must Buy House 1 which costs 0.025 ether');\r\n        require(!isUserExists(_userId), 'Already Registered');\r\n        require(isUserExists(_sponsor), 'Invalid Sponsor Id');\r\n        \r\n        registration(_userId, _sponsor);\r\n        activeUsers++;\r\n        joinedToday++;\r\n        lastUserId++;\r\n        updateTeamData(_userId);\r\n        getProperty(_userId, 1);\r\n        \r\n        emit NewUser(_userId, _sponsor, users[_userId].id, users[_sponsor].id);\r\n    }\r\n    \r\n    function registration(address _userId, address _sponsor) internal{\r\n        \r\n        User memory user = User({\r\n            id: lastUserId,\r\n            isSynched: true,\r\n            refBy: _sponsor,\r\n            refs: new address[](0),\r\n            afund: uint(0),\r\n            pool_bonus: uint(0),\r\n            withdrawn: uint(0),\r\n            dreEarnings: uint(0),\r\n            matrixEarnings: uint(0),\r\n            missedEarnings: uint(0),\r\n            matchingBonus: uint(0),\r\n            missedBonus: uint(0),\r\n            refsCount: uint(0),\r\n            teamCount: uint(0),\r\n            teamvolume: uint(0)\r\n        });\r\n        \r\n        users[_userId] = user;\r\n        idToAddress[lastUserId] = _userId;\r\n        userIds[lastUserId] = _userId;\r\n        users[_userId].refBy = _sponsor;\r\n        \r\n        users[_sponsor].refs.push(_userId);\r\n        users[_sponsor].refsCount++;\r\n        \r\n    }\r\n    \r\n    function buyNewProperty(uint _matrixId) public payable {\r\n        require(_matrixId > 0 && _matrixId < 13, 'Wrong Matrix');\r\n        address _userId = msg.sender;\r\n        require(isUserExists(_userId), 'You Must be a Registered Member');\r\n        require(msg.value ==  levelPrice[_matrixId], 'Invalid amount');\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_userId)\r\n        }\r\n        require(size == 0, \"cannot be a contract\");\r\n        bool canJoin = true;\r\n        if(_matrixId > 1){\r\n            for(uint p = _matrixId - 1; p > 0; p--){\r\n                canJoin = users[_userId].CityMatrix[p].active;\r\n            }\r\n        }\r\n        require(canJoin, 'Cannot Jump Stages');\r\n        getProperty(_userId, _matrixId);\r\n    }\r\n    \r\n    function getProperty(address _userId, uint _matrixId) internal {\r\n        \r\n        uint cost = levelPrice[_matrixId];\r\n        \r\n        uint _level = _matrixId;\r\n        \r\n        incentivePool(_userId, _level);\r\n\r\n        if(users[_userId].CityMatrix[_level].expiresOn < block.timestamp || users[_userId].CityMatrix[_level].expiresOn == 0){\r\n            users[_userId].CityMatrix[_level].expiresOn = uint(block.timestamp) + MatrixexpiresOn;\r\n        }else{\r\n            users[_userId].CityMatrix[_level].expiresOn += MatrixexpiresOn;\r\n        }\r\n        \r\n        uint payDre = cost * dre / divider;\r\n        users[users[_userId].refBy].dreEarnings += payDre;\r\n        dividentDistribution(users[_userId].refBy, payDre, _level);\r\n\r\n        if(users[_userId].CityMatrix[_level].reinvestCount >= 1){\r\n            // Renewal\r\n            address _firstUpline = users[_userId].CityMatrix[_level].refBy;\r\n            address _secondUpline = users[_firstUpline].refBy;\r\n            processLevel(_firstUpline, _secondUpline, _level);\r\n            users[_userId].CityMatrix[_level].reinvestCount++;\r\n        }else{\r\n            users[_userId].activeMember[_level] = true;\r\n            users[_userId].CityMatrix[_level].active = true;\r\n            users[_userId].CityMatrix[_level].reinvestCount = 1;\r\n            // update Upline\r\n            updateMatrixUpliner(_userId, getUpline(_userId, users[_userId].refBy, _level, 1), _matrixId);\r\n        }\r\n        \r\n        users[_userId].CityMatrix[_level].computed = false;\r\n        \r\n        incomeDistribution(cost, 1);\r\n        \r\n        raisedToday += cost;\r\n        \r\n        if(block.timestamp >= lastUpdate + 1 days){\r\n            joinedToday = 0;\r\n            raisedToday = 0;\r\n            lastUpdate = uint(block.timestamp);\r\n        }\r\n        raisedTotal += cost;\r\n        if(block.timestamp >= pool_last_draw + 7 days){\r\n            drawPool();\r\n        }\r\n        \r\n        emit Upgrade(_userId, users[_userId].refBy, _matrixId);\r\n    }\r\n    \r\n    function incentivePool(address _userId, uint _level) internal{\r\n        address upline = users[_userId].refBy;\r\n        uint _amount = levelPrice[_level];\r\n        if(upline != address(0)){\r\n            users[upline].teamvolume += _amount;\r\n            pool_users_balance[nexpool][upline] += _amount;\r\n            for(uint i = 0; i < 5; i++){\r\n                if(pool_lead[i] == upline){\r\n                    break;\r\n                }\r\n                else if(pool_lead[i] == address(0)){\r\n                    pool_lead[i] = upline;\r\n                    break;\r\n                }\r\n                if(pool_users_balance[nexpool][upline] > pool_users_balance[nexpool][pool_lead[i]]){\r\n                    for(uint p = i + 1; p < 5; p++){\r\n                        if(pool_lead[p] == upline){\r\n                            for(uint k = p; k <= 5; k++){\r\n                                pool_lead[k] = pool_lead[k + 1];\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n    \r\n                    for(uint p = 4; p > i; p--) {\r\n                        pool_lead[p] = pool_lead[p - 1];\r\n                    }\r\n    \r\n                    pool_lead[i] = upline;\r\n    \r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUpline(address _self, address _userId, uint _level, uint up) internal returns(address){\r\n        if(guDownlines(_userId, _level) < 3){\r\n            if(checkActiveStatus(_userId, _level)){\r\n                return _userId;\r\n            }\r\n            else{\r\n                if(up == 1){\r\n                    // Missed Income\r\n                    // missedEarnings(_userId, _level);\r\n                    // next Availble Upline\r\n                    return getUpline(_self, users[_userId].refBy, _level, 2);\r\n                }\r\n                if(up == 2){\r\n                    return getUpline(_self, contractor, _level, 3);\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            uint v = 0;\r\n            while(v < 3){\r\n                address downline = users[_userId].CityMatrix[_level].refs1[v];\r\n                if(guDownlines(downline, _level) < 3){\r\n                    if(checkActiveStatus(downline, _level)){\r\n                        return downline;\r\n                    }\r\n                }\r\n                v++;\r\n            }\r\n            uint d = 0;\r\n            for(uint e = 0; e < users[_userId].refs.length; e++){\r\n                address ddownline = users[_userId].refs[e];\r\n                if(ddownline != _self){\r\n                    if(guDownlines(ddownline, _level) < 3){\r\n                        if(checkActiveStatus(ddownline, _level)){\r\n                            return ddownline;\r\n                        }\r\n                    }\r\n                    else{\r\n                        while(d < 3){\r\n                            address dddownline = users[ddownline].CityMatrix[_level].refs1[d];\r\n                            if(guDownlines(dddownline, _level) < 3){\r\n                                if(checkActiveStatus(dddownline, _level)){\r\n                                    return dddownline;\r\n                                }\r\n                            }\r\n                            d++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function highestStage(address _userId) public view returns(uint){\r\n        uint p = 12;\r\n        for(p - 1; p > 0; p--){\r\n            if(users[_userId].CityMatrix[p].active){\r\n                break;\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n    \r\n    function updateTeamData(address _userId) internal returns(bool){\r\n        while(users[_userId].refBy != address(0)){\r\n            users[users[_userId].refBy].teamCount++;\r\n            _userId = users[_userId].refBy;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function updateMatrixUpliner(address _userId, address _upline, uint _level) internal {\r\n        users[_userId].CityMatrix[_level].refBy = _upline;\r\n        users[_upline].CityMatrix[_level].refs1.push(_userId); // Level 1\r\n        address _upline2 = users[_upline].CityMatrix[_level].refBy;\r\n        users[_upline2].CityMatrix[_level].refs2.push(_userId); // Level 2\r\n        processLevel(_upline, _upline2, _level);\r\n        // emit NewDownline(_userId, _upline, _level, 1, uint(users[_upline].CityMatrix[_level].refs1.length));\r\n        // emit NewDownline(_userId, _upline2, _level, 2, uint(users[_upline2].CityMatrix[_level].refs2.length));\r\n    }\r\n\r\n    function processLevel(address _firstUpline, address _secondUpline, uint _level) internal{\r\n        matrixIncome(_firstUpline, levelPrice[_level], _level, 1); // MI1\r\n        if(users[_firstUpline].refBy != address(0)){\r\n            matchIncome(users[_firstUpline].refBy, levelPrice[_level], _level, 1); // MB1\r\n            matrixIncome(_secondUpline, levelPrice[_level], _level, 2); // MI2\r\n            matchIncome(users[_secondUpline].refBy, levelPrice[_level], _level, 2); // MB2\r\n        }\r\n    }\r\n    \r\n    function matrixIncome(address _userId, uint _amount, uint _level, uint _position) internal{\r\n        uint refsc;\r\n        if(_position == 1){\r\n            refsc = refs1;\r\n        }else{\r\n            refsc = refs2;\r\n        }\r\n        \r\n        // uint payLevel = SafeMath.mul(_amount , SafeMath.div(refsc , divider));\r\n        uint payLevel = _amount * refsc / divider;\r\n        users[_userId].matrixEarnings += payLevel;\r\n        matrixIncomes += payLevel;\r\n        address beneficiray;\r\n        if(users[_userId].id > 1){\r\n            beneficiray = checkBeneficiary(_userId, _level, 1, payLevel);\r\n        }\r\n        else{\r\n            beneficiray = _userId;\r\n        }\r\n        dividentDistribution(beneficiray, payLevel, _level);\r\n    }\r\n\r\n    function matchIncome(address _userId, uint _amount, uint _level, uint _position) internal{\r\n        uint refsb;\r\n        if(_position == 1){\r\n            refsb = refs1b;\r\n        }else{\r\n            refsb = refs2b;\r\n        }\r\n    \r\n        // uint payMb = SafeMath.mul(_amount, SafeMath.div(refsb , divider));\r\n        uint payMb = _amount * refsb / divider;\r\n        users[_userId].matchingBonus += payMb;\r\n        matchIncomes += payMb;\r\n        dividentDistribution(checkBeneficiary(_userId, _level, 2, payMb), payMb, _level);\r\n    }\r\n    \r\n    function dividentDistribution(address _userId, uint _amount, uint _level) internal returns(bool){\r\n        if(users[_userId].id == 1){\r\n            incomeDistribution(_amount, 2);\r\n        }\r\n        else{\r\n            // address(uint160(_userId)).transfer(_amount);\r\n            users[_userId].afund += _amount;\r\n            users[_userId].CityMatrix[_level].earnings += _amount;\r\n        }\r\n        distEarning += _amount;\r\n        // Emit Earnings Received\r\n        return true;\r\n    }\r\n\r\n    function incomeDistribution(uint _amount, uint _type) internal returns(bool){\r\n        uint pay;\r\n        if(_type == 1){\r\n            // pay = SafeMath.div(SafeMath.mul(_amount, SafeMath.div(system, divider)), 4);\r\n            \r\n            uint rpay = _amount * system / divider;\r\n            pay = rpay  / 4;\r\n            // safety_funds += SafeMath.mul(_amount, SafeMath.div(safetyR, divider));\r\n            // pool_balance += SafeMath.mul(_amount, SafeMath.div(poolR, divider));\r\n            safety_funds += _amount * safetyR / divider;\r\n            pool_balance += _amount * poolR / divider;\r\n        }\r\n        else{\r\n            pay = _amount / 4;\r\n        }\r\n        for(uint m = 2; m <= 5; m++){\r\n            address _admin = userIds[m];\r\n            users[_admin].afund += pay;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function checkBeneficiary(address _userId, uint _level, uint _type, uint _amount) internal returns(address _beneficiary){\r\n        if(checkActiveStatus(_userId, _level)){\r\n            _beneficiary = _userId;\r\n        }\r\n        else{\r\n            emit MissedEarnings(_userId, _level, _type, _amount);\r\n            if(_type == 1){\r\n                users[_userId].missedEarnings += _amount;\r\n            }else{\r\n                users[_userId].missedBonus += _amount;\r\n            }\r\n            lostEarnings += _amount;\r\n            _beneficiary = userIds[1];\r\n        }\r\n    }\r\n    \r\n    function drawPool() internal {\r\n        pool_last_draw = uint(block.timestamp);\r\n        nexpool++;\r\n        for(uint i = 0; i < 5; i++){\r\n           uint _amount = pool_balance * poolPrizes[i + 1] / divider;\r\n           users[pool_lead[i]].afund += _amount;\r\n           users[pool_lead[i]].pool_bonus += _amount;\r\n        }\r\n        \r\n        pool_balance -= pool_balance * poolShare  / divider;\r\n      \r\n        for(uint8 i = 0; i < 5; i++) {\r\n            pool_lead[i] = address(0);\r\n        }\r\n    }\r\n\r\n    function aDrawPool() public {\r\n        require(msg.sender == address(vaultMissed),  'Soryry you do not have permission to Proceed!');\r\n        require(block.timestamp >= pool_last_draw + 7 days, 'Sorry only possible once a week!');\r\n        drawPool();\r\n    } \r\n    \r\n    function computeSafety(address _userId, uint _level) public payable {\r\n        // require(_expiresOn <= block.timestamp, 'Wait expiration');\r\n        require(block.timestamp >= users[_userId].CityMatrix[_level].expiresOn && earningsRatio(_userId, _level) > 0, 'Wait expiration!');\r\n        require(!users[_userId].CityMatrix[_level].computed, 'Already Computed!');\r\n        uint _amount = users[_userId].afund + earningsRatio(_userId, _level);\r\n        require(address(this).balance > _amount + _amount * 15  / divider, 'Unavailable Funds!');\r\n        users[_userId].afund = 0;\r\n        users[msg.sender].withdrawn += _amount;\r\n        safety_funds -= earningsRatio(_userId, _level);\r\n        users[_userId].CityMatrix[_level].earnings += earningsRatio(_userId, _level);\r\n        users[_userId].CityMatrix[_level].computed = true;\r\n        address(uint160(msg.sender)).transfer(_amount);\r\n    }\r\n    \r\n    function earningsRatio(address _userId, uint _level) internal view returns(uint){\r\n        if(users[_userId].CityMatrix[_level].reinvestCount >= 1){\r\n            uint safetyProfit = users[_userId].CityMatrix[_level].reinvestCount * levelPrice[_level] * 120 / divider;\r\n            uint actualProfit = users[_userId].CityMatrix[_level].earnings;\r\n            if(actualProfit < safetyProfit){\r\n                return safetyProfit - actualProfit;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function syncOldUsers(uint limit) public {\r\n        if(address(EtherCity_v1) == address(0)){\r\n            EtherCity_v1 = EtherCity(0xea1CdB66886CC2d0C6c60F8BbD4aEd37E6A88062);\r\n        }\r\n        \r\n        require(!matrixInitialized, 'Initialize closed');\r\n        require(msg.sender == contractor, 'Access denied');\r\n\r\n        for(uint i = 0; i < limit; i++) {\r\n            // GetUserAddress\r\n            (address _userId) = EtherCity_v1.userIds(lastUserId);\r\n            if(_userId != address(0)){\r\n                if(!isUserExists(_userId)){\r\n                    (address _refBy, uint refs, uint _myTeam, uint earnings, uint _dearnings, uint _mearnings, uint _maearnings, uint _missedEarning) = EtherCity_v1.getUserData(_userId);\r\n                    // Registered\r\n                    registration(_userId, _refBy);\r\n                    users[_userId].isSynched = false;\r\n                    users[_userId].withdrawn = earnings;\r\n                    users[_userId].dreEarnings = _dearnings;\r\n                    users[_userId].matrixEarnings = _mearnings;\r\n                    users[_userId].missedEarnings = _missedEarning * 0;\r\n                    users[_userId].matchingBonus = _maearnings;\r\n                    users[_userId].refsCount = refs;\r\n                    users[_userId].teamCount = _myTeam;\r\n                    lastUserId++;\r\n                    // Restructure Matrix Here\r\n                    // synchMatrix(_userId);\r\n                }\r\n            }\r\n        }\r\n        if(lastUserId >= EtherCity_v1.lastUserId()){\r\n            (uint  old_lastUserId, uint  old_activeUsers, uint  old_raisedToday, \r\n            uint  old_raisedTotal, uint  old_distEarning, uint  old_lostEarnings, \r\n            uint  old_matrixIncomes, uint  old_matchIncomes, uint  old_joinedToday) = EtherCity_v1.stats();\r\n            if(lastUserId < old_lastUserId){\r\n                lastUserId = lastUserId + old_activeUsers - lastUserId;\r\n            }\r\n            activeUsers += old_activeUsers;\r\n            raisedToday += old_raisedToday;\r\n            raisedTotal += old_raisedTotal;\r\n            distEarning += old_distEarning;\r\n            lostEarnings += old_lostEarnings;\r\n            matrixIncomes += old_matrixIncomes;\r\n            matchIncomes += old_matchIncomes;\r\n            joinedToday += old_joinedToday;\r\n            // End Synch\r\n            \r\n            levelPrice[1] = 0.025 ether;\r\n            for (uint i = 2; i <= 12; i++) {\r\n                levelPrice[i] = levelPrice[i-1] * 2;\r\n            }\r\n            \r\n            for(uint p = 0; p < 5; p++){\r\n                pool_lead[p] = address(0);\r\n            }\r\n            \r\n            poolPrizes[1] = 5;\r\n            poolPrizes[2] = 4;\r\n            poolPrizes[3] = 3;\r\n            poolPrizes[4] = 2;\r\n            poolPrizes[5] = 1;\r\n            \r\n            matrixInitialized = true;\r\n            // EtherCity_v1 = EtherCity(0);\r\n        }\r\n    }\r\n    \r\n    function synchMatrix(uint _syncUsers) public onlyContractor{\r\n        require(!treeSynched, 'Tree already Fully Synched');\r\n        for(uint s = lastSynched; s <= _syncUsers; s++){\r\n            address _userId = EtherCity_v1.userIds(s);\r\n            if(isUserExists(_userId) && !users[_userId].isSynched){\r\n                for(uint i = 1; i <= 12; i++){\r\n                    (address _sponsor, address[] memory level1, address[] memory level2, bool status) = EtherCity_v1.usersMatrix(_userId, i);\r\n                    if(status){\r\n                        users[_userId].CityMatrix[i].active = true;\r\n                        users[_userId].activeMember[i] = true;\r\n                        users[_userId].CityMatrix[i].expiresOn = EtherCity_v1.userMatrixExpiration(_userId, i);\r\n                        if(_sponsor != address(0)){\r\n                            users[_userId].CityMatrix[i].refBy = _sponsor;\r\n                        }\r\n                        else{\r\n                            users[_userId].CityMatrix[i].refBy = address(0);\r\n                        }\r\n                        \r\n                        for(uint d = 0; d < level1.length; d++){\r\n                           users[_userId].CityMatrix[i].refs1.push(level1[d]);\r\n                        }\r\n                        \r\n                        for(uint e = 0; e < level2.length; e++){\r\n                            users[_userId].CityMatrix[i].refs2.push(level2[e]);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                users[_userId].isSynched = true;\r\n                lastSynched++;\r\n            }\r\n            \r\n            if(lastSynched >= EtherCity_v1.lastUserId()){\r\n                treeSynched = true;\r\n            }\r\n            \r\n        }\r\n    }\r\n    \r\n    function withdraw() public {\r\n        require(users[msg.sender].afund > 0 \r\n        && address(this).balance > users[msg.sender].afund + users[msg.sender].afund * 15 / divider, \r\n        'Insufficient Balance');\r\n        uint _amount = users[msg.sender].afund;\r\n        users[msg.sender].afund = 0;\r\n        users[msg.sender].withdrawn += _amount;\r\n        address(uint160(msg.sender)).transfer(_amount);\r\n    }\r\n\r\n    function isUserExists(address _userAddress) internal view returns (bool) {\r\n        return (users[_userAddress].id != 0);\r\n    }\r\n\r\n    function checkActiveStatus(address _userId, uint _level) internal returns(bool){\r\n        if(!users[_userId].activeMember[_level] || users[_userId].CityMatrix[_level].expiresOn < now){\r\n            users[_userId].activeMember[_level] = false;\r\n            users[_userId].CityMatrix[_level].active = false;\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function guDownlines(address _userId, uint _level) internal view returns(uint){\r\n        return users[_userId].CityMatrix[_level].refs1.length;\r\n    }\r\n    \r\n    function usersActiveCityMatrix(address _userId, uint _level) external view returns(bool active, uint){\r\n        return (users[_userId].activeMember[_level],  users[_userId].CityMatrix[_level].expiresOn);\r\n    }\r\n\r\n    function usersMatrix(address _userId, uint _level) public view returns(address, address[] memory, address[] memory, bool) {\r\n        return (users[_userId].CityMatrix[_level].refBy,\r\n                users[_userId].CityMatrix[_level].refs1,\r\n                users[_userId].CityMatrix[_level].refs2, users[_userId].CityMatrix[_level].active);\r\n    }\r\n    \r\n    function stats() public view returns(uint lId, uint aU, uint rT, uint rTl, uint dE, uint lE, uint mI, uint mCI, uint jT, uint sF, uint pB){\r\n        return (lastUserId, activeUsers, raisedToday, raisedTotal, distEarning, lostEarnings, matrixIncomes, matchIncomes, joinedToday, safety_funds, pool_balance);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matrix\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"DividentReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matrix\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"MissedDivident\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_position\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"MissedEarnings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"NewDownline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"NewUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matrix\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"Renewal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matrix\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"aDrawPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_matrixId\",\"type\":\"uint256\"}],\"name\":\"buyNewProperty\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"computeSafety\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userId\",\"type\":\"address\"}],\"name\":\"highestStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"}],\"name\":\"newSignup\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pool_lead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aU\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rTl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mCI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sF\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pB\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"syncOldUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_syncUsers\",\"type\":\"uint256\"}],\"name\":\"synchMatrix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userIds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSynched\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"refBy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"afund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dreEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matrixEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"missedEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matchingBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"missedBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamvolume\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"usersActiveCityMatrix\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"usersMatrix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherCity2","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://369f3ca89559295d8fff7b5d3bb6ecdbcd9c476d29434915ddcebd274a716131"}]}