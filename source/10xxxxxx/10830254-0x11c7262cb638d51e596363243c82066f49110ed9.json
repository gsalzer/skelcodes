{"status":"1","message":"OK","result":[{"SourceCode":"{\"CarefulMath.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\n/**\\n  * @title Careful Math\\n  * @author Compound\\n  * @notice Derived from OpenZeppelin\\u0027s SafeMath library\\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n  */\\ncontract CarefulMath {\\n\\n    /**\\n     * @dev Possible error codes that we can return\\n     */\\n    enum MathError {\\n        NO_ERROR,\\n        DIVISION_BY_ZERO,\\n        INTEGER_OVERFLOW,\\n        INTEGER_UNDERFLOW\\n    }\\n\\n    /**\\n    * @dev Multiplies two numbers, returns an error on overflow.\\n    */\\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b \\u003c= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, returns an error on overflow.\\n    */\\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        uint c = a + b;\\n\\n        if (c \\u003e= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev add a and b and then subtract c\\n    */\\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\\n        (MathError err0, uint sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n}\"},\"EIP20Interface.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"},\"ErrorReporter.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\ncontract WanttrollerErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        DIVISION_BY_ZERO,\\n        INTEGER_OVERFLOW,\\n        INTEGER_UNDERFLOW,\\n        UNAUTHORIZED\\n    }   \\n\\n    enum FailureInfo {\\n      ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n      ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n      SET_PENDING_ADMIN_OWNER_CHECK,\\n      SET_PAUSE_GUARDIAN_OWNER_CHECK,\\n      SET_IMPLEMENTATION_OWNER_CHECK,\\n      SET_PENDING_IMPLEMENTATION_OWNER_CHECK\\n    }   \\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\\n\"},\"Exponential.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\nimport \\\"./CarefulMath.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract Exponential is CarefulMath {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Creates an exponential from numerator and denominator values.\\n     *      Note: Returns an error if (`num` * 10e18) \\u003e MAX_INT,\\n     *            or if `denom` is zero.\\n     */\\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n    }\\n\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\\n     */\\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(product));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return addUInt(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Divide an Exp by a scalar, returning a new Exp.\\n     */\\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, returning a new Exp.\\n     */\\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\\n        /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n        return getExp(numerator, divisor.mantissa);\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n     */\\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(fraction));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n\\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        // We add half the scale before dividing so that we get rounding instead of truncation.\\n        //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n     */\\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n     */\\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        return getExp(a.mantissa, b.mantissa);\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we\\u0027re performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa \\u003c right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp \\u003c= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa \\u003c= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp \\u003e right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa \\u003e right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\n        require(n \\u003c 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\n        require(n \\u003c 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return add_(a, b, \\\"addition overflow\\\");\\n    }\\n\\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c \\u003e= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return sub_(a, b, \\\"subtraction underflow\\\");\\n    }\\n\\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return mul_(a, b, \\\"multiplication overflow\\\");\\n    }\\n\\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, errorMessage);\\n        return c;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return div_(a, b, \\\"divide by zero\\\");\\n    }\\n\\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"Unitroller.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./WanttrollerStorage.sol\\\";\\n/**\\n * @title WanttrollerCore\\n * @dev Storage for the wanttroller is at this address, while execution is delegated to the `wanttrollerImplementation`.\\n */\\ncontract Unitroller is UnitrollerAdminStorage, WanttrollerErrorReporter {\\n\\n    /**\\n      * @notice Emitted when pendingWanttrollerImplementation is changed\\n      */\\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingWanttrollerImplementation is accepted, which means wanttroller implementation is updated\\n      */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is changed\\n      */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n      */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() public {\\n        // Set admin to caller\\n        admin = msg.sender;\\n    }\\n\\n    /*** Admin Functions ***/\\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\\n\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\\n        }\\n\\n        address oldPendingImplementation = pendingWanttrollerImplementation;\\n\\n        pendingWanttrollerImplementation = newPendingImplementation;\\n\\n        emit NewPendingImplementation(oldPendingImplementation, pendingWanttrollerImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n    * @notice Accepts new implementation of wanttroller. msg.sender must be pendingImplementation\\n    * @dev Admin function for new implementation to accept it\\u0027s role as implementation\\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n    */\\n    function _acceptImplementation() public returns (uint) {\\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\\n        if (msg.sender != pendingWanttrollerImplementation || pendingWanttrollerImplementation == address(0)) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldImplementation = wanttrollerImplementation;\\n        address oldPendingImplementation = pendingWanttrollerImplementation;\\n\\n        wanttrollerImplementation = pendingWanttrollerImplementation;\\n\\n        pendingWanttrollerImplementation = address(0);\\n\\n        emit NewImplementation(oldImplementation, wanttrollerImplementation);\\n        emit NewPendingImplementation(oldPendingImplementation, pendingWanttrollerImplementation);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n\\n    function _transferOwnership(address newAdmin) public returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n        }\\n        emit NewAdmin(admin, newAdmin);\\n        admin = newAdmin;\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() public returns (uint) {\\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * It returns to the external caller whatever the implementation returns\\n     * or forwards reverts.\\n     */\\n    function () payable external {\\n        // delegate all other functions to current implementation\\n        (bool success, ) = wanttrollerImplementation.delegatecall(msg.data);\\n\\n        assembly {\\n              let free_mem_ptr := mload(0x40)\\n              returndatacopy(free_mem_ptr, 0, returndatasize)\\n\\n              switch success\\n              case 0 { revert(free_mem_ptr, returndatasize) }\\n              default { return(free_mem_ptr, returndatasize) }\\n        }\\n    }\\n}\\n\"},\"WantFaucet.sol\":{\"content\":\"pragma solidity ^0.5.16;\\nimport \\\"./Exponential.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\ncontract WantFaucet is Exponential {\\n  using SafeMath for uint256;\\n\\n  // Min time between drips \\n  uint dripInterval = 200;\\n\\n  address admin;\\n  address teamWallet; \\n\\n  address wantAddress;\\n\\n  uint constant teamFactor = 0.01e18;\\n\\n  constructor(address _admin, address _teamWallet, address _wantAddress) public {\\n    admin = _admin;\\n    teamWallet = _teamWallet;\\n    wantAddress = _wantAddress;\\n  }\\n\\n  function setAdmin(address _admin) public {\\n    require(msg.sender == admin);\\n    admin = _admin;\\n  }\\n\\n  function drip(uint amount) public {\\n    EIP20Interface want = EIP20Interface(wantAddress);\\n    require(msg.sender == admin, \\\"drip(): Only admin may call this function\\\");\\n    \\n    // Compute team amount: 1%\\n    (MathError err, Exp memory teamAmount) = mulExp(Exp({ mantissa: amount }), Exp({ mantissa: teamFactor }));\\n    require(err == MathError.NO_ERROR);\\n    \\n    // Check balance requested for withdrawal \\n    require(amount.add(teamAmount.mantissa) \\u003c want.balanceOf(address(this)), \\\"Insufficent balance for drip\\\");\\n    \\n    // Transfer team amount\\n    bool success = want.transfer(teamWallet, teamAmount.mantissa); \\n    require(success, \\\"collectRewards(): Unable to send team tokens\\\");\\n \\n    // Transfer admin amount \\n    success = want.transfer(admin, amount); \\n    require(success, \\\"collectRewards(): Unable to send admin tokens\\\");\\n  }\\n}\\n\"},\"Wanttroller.sol\":{\"content\":\"pragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./Exponential.sol\\\";\\nimport \\\"./WantFaucet.sol\\\";\\nimport \\\"./WanttrollerStorage.sol\\\";\\nimport \\\"./Unitroller.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract Wanttroller is WanttrollerV1Storage, WanttrollerErrorReporter {\\n  using SafeMath for uint256;\\n\\n  uint constant initialReward = 50e18;\\n\\n  event WantDropIndex(address account, uint index);\\n  event CollectRewards(address owner, uint rewardsAmount);\\n  event AccrueRewards(address owner, uint rewardsAmount);\\n  \\n  constructor() public {\\n    admin = msg.sender;\\n  }\\n\\n//--------------------\\n// Main actions\\n// -------------------\\n\\n  /**\\n   * @notice Redeem rewards earned in wallet and register for next drop \\n   */\\n  function collectRewards() public {\\n    // Register for next drop, accrue last reward if applicable \\n    registerForDrop();\\n\\n    if (_needsDrip()){\\n      _dripFaucet();\\n    }\\n\\n    // send accrued reward to sender\\n    EIP20Interface want = EIP20Interface(wantTokenAddress);\\n    bool success = want.transfer(msg.sender, accruedRewards[msg.sender]);\\n    require(success, \\\"collectRewards(): Unable to send tokens\\\");\\n    \\n    // emit\\n    emit CollectRewards(msg.sender, accruedRewards[msg.sender]);\\n    \\n    // Reset accrued to zero \\n    accruedRewards[msg.sender] = 0; \\n  }\\n\\n  /**\\n   * @notice Register to receive reward in next WantDrop, accrues any rewards from the last drop \\n   */\\n  function registerForDrop() public {\\n    // If previous drop has finished, start a new drop\\n    if (isDropOver()) {\\n      _startNewDrop();\\n    }\\n\\n    // Add rewards to balance\\n    _accrueRewards();\\n    \\n    // Update want index\\n    if (lastDropRegistered[msg.sender] != currentDropIndex) {\\n      // Store index for account\\n      lastDropRegistered[msg.sender] = currentDropIndex;\\n      \\n      // Bump total registered count for this drop\\n      uint _numRegistrants = wantDropState[currentDropIndex].numRegistrants;\\n      wantDropState[currentDropIndex].numRegistrants = _numRegistrants.add(1);\\n    \\n      // Add to array of those on drop \\n      accountsRegisteredForDrop.push(msg.sender);\\n\\n      // Emit event\\n      emit WantDropIndex(msg.sender, currentDropIndex);\\n    }\\n    \\n    // Track sender registered for current drop \\n    lastDropRegistered[msg.sender] = currentDropIndex;\\n  }\\n\\n  /**\\n   * @notice Register to receive reward in next WantDrop, accrues any rewards from the last drop, \\n   *         sends all rewards to wallet \\n   */\\n  function registerAndCollect() public {\\n    registerForDrop();\\n    collectRewards();\\n  }\\n\\n//---------------------\\n// Statuses \\u0026 getters\\n//---------------------\\n  \\n  /**\\n   * @notice Gets most current drop index. If current drop has finished, returns next drop index \\n   */\\n  function getCurrentDropIndex() public view returns(uint) {\\n    if (isDropOver())\\n      return currentDropIndex.add(1);\\n    else\\n      return currentDropIndex;\\n  }\\n  \\n  /**\\n   * @notice True if registered for most current drop \\n   */\\n  function registeredForNextDrop() public view returns(bool) {\\n    if (isDropOver())\\n      return false;\\n    else if (lastDropRegistered[msg.sender] == currentDropIndex)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  /**\\n    * @notice Blocks remaining to register for stake drop\\n    */\\n  function blocksRemainingToRegister() public view returns(uint) {\\n    if (isDropOver() || currentDropIndex == 0){\\n      return waitblocks; \\n    }\\n    else {\\n      return currentDropStartBlock.add(waitblocks).sub(block.number);\\n    }\\n  }\\n\\n  /**\\n   * @notice True if waitblocks have passed since drop registration started \\n   */\\n  function isDropOver() public view returns(bool) {\\n    // If current block is beyond start + waitblocks, drop registration over\\n    if (block.number \\u003e= currentDropStartBlock.add(waitblocks))\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  function getTotalCurrentDropReward() public view returns(uint) {\\n    if (isDropOver()) {\\n      return _nextReward(currentReward);\\n    }\\n    else {\\n      return currentReward;\\n    }\\n  }\\n\\n  /**\\n   * @notice returns expected drop based on how many registered\\n   */\\n  function getExpectedReward() public view returns(uint) {\\n    if (isDropOver()) {\\n      return _nextReward(currentReward);\\n    }\\n    \\n    // total reward / num registrants\\n    (MathError err, Exp memory result) = divScalar(Exp({mantissa: wantDropState[currentDropIndex].totalDrop}), wantDropState[currentDropIndex].numRegistrants ); \\n    require(err == MathError.NO_ERROR);\\n    return result.mantissa;\\n  }\\n\\n  /**\\n   * @notice Gets the sender\\u0027s total accrued rewards \\n   */\\n  function getRewards() public view returns(uint) {\\n    uint pendingRewards = _pendingRewards();\\n     \\n    if (pendingRewards \\u003e 0) { \\n      return accruedRewards[msg.sender].add(pendingRewards);\\n    }\\n    else {\\n      return accruedRewards[msg.sender];\\n    }\\n  }\\n\\n\\n  /**\\n   * @notice Return stakers list for  \\n   */\\n  function getAccountsRegisteredForDrop() public view returns(address[] memory) {\\n    if (isDropOver()){\\n      address[] memory blank;\\n      return blank;\\n    }\\n    else\\n      return accountsRegisteredForDrop;\\n  }\\n\\n// --------------------------------\\n// Reward computation and helpers\\n// --------------------------------\\n  \\n  /**\\n   * @notice Used to compute any pending reward not yet accrued onto a users accruedRewards  \\n   */\\n  function _pendingRewards() internal view returns(uint) {\\n    // Last drop user wanted\\n    uint _lastDropRegistered = lastDropRegistered[msg.sender];\\n    \\n    // If new account, no rewards\\n    if (_lastDropRegistered == 0) \\n      return 0;\\n\\n    // If drop requested has completed, accrue rewards\\n    if (_lastDropRegistered \\u003c currentDropIndex) {\\n      // Accrued = accrued + reward for last drop\\n      return _computeRewardMantissa(_lastDropRegistered);\\n    }\\n    else if (isDropOver()) {\\n      // Accrued = accrued + reward for last drop\\n      return _computeRewardMantissa(_lastDropRegistered);\\n    }\\n    else {\\n      return 0;\\n    }\\n  }\\n  \\n  /**\\n   * @notice Used to add rewards from last drop user was in to their accuedRewards balances \\n   */\\n  function _accrueRewards() internal {\\n    uint pendingRewards = _pendingRewards();\\n     \\n    if (pendingRewards \\u003e 0) { \\n      accruedRewards[msg.sender] = accruedRewards[msg.sender].add(pendingRewards);\\n      emit AccrueRewards(msg.sender, pendingRewards);\\n    }\\n  }\\n\\n  /**\\n   * @notice Compute how much reward each participant in the drop received \\n   */\\n  function _computeRewardMantissa(uint index) internal view returns(uint) {\\n    WantDrop memory wantDrop = wantDropState[index]; \\n    \\n    // Total Reward / Total participants\\n    (MathError err, Exp memory reward) = divScalar(Exp({ mantissa: wantDrop.totalDrop }), wantDrop.numRegistrants);\\n    require(err == MathError.NO_ERROR, \\\"ComputeReward() Division error\\\");\\n    return reward.mantissa;\\n  }\\n\\n//------------------------------\\n// Drop management\\n//------------------------------\\n  /**\\n   * @notice Sets up state for new drop state and drips from faucet if rewards getting low \\n   */\\n  function _startNewDrop() internal {\\n    // Bump drop index\\n    currentDropIndex = currentDropIndex.add(1);\\n    \\n    // Update current drop start to now\\n    currentDropStartBlock = block.number;\\n\\n    // Compute next drop reward \\n    uint nextReward = _nextReward(currentReward);\\n    \\n    // Update global for total dropped\\n    totalDropped = totalDropped.add(nextReward);\\n    \\n    // Init next drop state\\n    wantDropState[currentDropIndex] = WantDrop({ \\n      totalDrop:  nextReward,\\n      numRegistrants: 0\\n    });\\n   \\n    // Clear registrants\\n    delete accountsRegisteredForDrop; \\n\\n    // Update currentReward\\n    currentReward = nextReward;\\n  }\\n  \\n  /**\\n   * @notice Compute next drop reward, based on current reward \\n   * @param _currentReward the current block reward for reference\\n   */\\n  function _nextReward(uint _currentReward) private view returns(uint) {\\n    if (currentDropIndex == 1) { \\n      return initialReward; \\n    }\\n    else {\\n      (MathError err, Exp memory newRewardExp) = mulExp(Exp({mantissa: discountFactor }), Exp({mantissa: _currentReward }));\\n      require(err == MathError.NO_ERROR);\\n      return newRewardExp.mantissa;\\n    }\\n  }\\n\\n//------------------------------\\n// Receiving from faucet \\n//------------------------------\\n  /**\\n   * @notice checks if balance is too low and needs to visit the WANT faucet \\n   */\\n  function _needsDrip() internal view returns(bool) {\\n    EIP20Interface want = EIP20Interface(wantTokenAddress);\\n    uint curBalance = want.balanceOf(address(this));\\n    if (curBalance \\u003c currentReward || curBalance \\u003c accruedRewards[msg.sender]) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @notice Receive WANT from the want. Attempts to get about 10x more than it needs to reduce need to call so frequently. \\n   */\\n  function _dripFaucet() internal {\\n    EIP20Interface want = EIP20Interface(wantTokenAddress);\\n    uint faucetBlance = want.balanceOf(wantFaucetAddress);\\n\\n    // Let\\u0027s bulk drip for the next ~ 25 drops\\n    (MathError err, Exp memory toDrip) = mulScalar(Exp({ mantissa: currentReward }), 25);\\n    require(err == MathError.NO_ERROR);\\n    \\n    WantFaucet faucet = WantFaucet(wantFaucetAddress);\\n   \\n    if (toDrip.mantissa.add(faucetBlance) \\u003c accruedRewards[msg.sender]) {\\n      toDrip.mantissa = accruedRewards[msg.sender];\\n    }\\n\\n    // If the facuet is ~empty, empty it \\n    if (faucetBlance \\u003c toDrip.mantissa) {\\n      faucet.drip(faucetBlance);\\n    }\\n    else {\\n      faucet.drip(toDrip.mantissa);\\n    }\\n   }\\n\\n///------------------------------------\\n// Admin functions: require governance\\n// ------------------------------------\\n  function _setWantFacuet(address newFacuetAddress) public  {\\n    require(adminOrInitializing());\\n    wantFaucetAddress = newFacuetAddress;\\n  }\\n  \\n  function _setWantAddress(address newWantAddress) public {\\n    require(adminOrInitializing());\\n    wantTokenAddress = newWantAddress;\\n  }\\n  \\n  function _setDiscountFactor(uint256 newDiscountFactor) public {\\n    require(adminOrInitializing());\\n    discountFactor = newDiscountFactor;\\n  }\\n  \\n  function _setWaitBlocks(uint256 newWaitBlocks) public {\\n    require(adminOrInitializing(), \\\"not an admin\\\");\\n    waitblocks = newWaitBlocks;\\n  }\\n  \\n  function _setCurrentReward(uint256 _currentReward) public {\\n    require(adminOrInitializing(), \\\"not an admin\\\");\\n    currentReward = _currentReward;\\n  }\\n  \\n  function _become(Unitroller unitroller) public {\\n      require(msg.sender == unitroller.admin(), \\\"only unitroller admin can change brains\\\");\\n      require(unitroller._acceptImplementation() == 0, \\\"change not authorized\\\"); \\n  }\\n\\n  /**\\n   * @notice Checks caller is admin, or this contract is becoming the new implementation\\n   */\\n  function adminOrInitializing() internal view returns (bool) {\\n      return msg.sender == admin || msg.sender == wanttrollerImplementation;\\n  }\\n\\n  // Used for testing\\n  function tick() public {\\n  }\\n}\\n\"},\"WanttrollerStorage.sol\":{\"content\":\"pragma solidity ^0.5.16;\\nimport \\\"./Exponential.sol\\\";\\ncontract UnitrollerAdminStorage {\\n    /**\\n    * @notice Administrator for this contract\\n    */\\n    address public admin;\\n\\n    /**\\n    * @notice Pending administrator for this contract\\n    */\\n    address public pendingAdmin;\\n\\n    /**\\n    * @notice Active brains of Unitroller\\n    */\\n    address public wanttrollerImplementation;\\n\\n    /**\\n    * @notice Pending brains of Unitroller\\n    */\\n    address public pendingWanttrollerImplementation;\\n}\\ncontract WanttrollerV1Storage is UnitrollerAdminStorage, Exponential {\\n  struct WantDrop {\\n    /// @notice Total accounts requesting piece of drop \\n    uint numRegistrants;\\n    \\n    /// @notice Total amount to be dropped\\n    uint totalDrop;\\n  }\\n\\n  // @notice Total amount dropped\\n  uint public totalDropped;\\n  \\n  // @notice Min time between drops\\n  uint public waitblocks = 200; \\n\\n  // @notice Tracks beginning of this drop \\n  uint public currentDropStartBlock;\\n  \\n  // @notice Tracks the index of the current drop\\n  uint public currentDropIndex;\\n  \\n  /// @notice Store total registered and total reward for that drop \\n  mapping(uint =\\u003e WantDrop) public wantDropState;\\n\\n  /// @notice Any WANT rewards accrued but not yet collected \\n  mapping(address =\\u003e uint) public accruedRewards;\\n  \\n  /// @notice Track the last drop this account was part of \\n  mapping(address =\\u003e uint) public lastDropRegistered;\\n\\n  address wantTokenAddress;\\n\\n  address[] public accountsRegisteredForDrop;\\n\\n  /// @notice Stores the current amount of drop being awarded\\n  uint public currentReward;\\n  \\n  /// @notice Each time rewards are distributed next rewards reduced by applying this factor\\n  uint public discountFactor = 0.9995e18;\\n\\n  // Store faucet address \\n  address public wantFaucetAddress;\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsAmount\",\"type\":\"uint256\"}],\"name\":\"AccrueRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsAmount\",\"type\":\"uint256\"}],\"name\":\"CollectRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"WantDropIndex\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Unitroller\",\"name\":\"unitroller\",\"type\":\"address\"}],\"name\":\"_become\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentReward\",\"type\":\"uint256\"}],\"name\":\"_setCurrentReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDiscountFactor\",\"type\":\"uint256\"}],\"name\":\"_setDiscountFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWaitBlocks\",\"type\":\"uint256\"}],\"name\":\"_setWaitBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWantAddress\",\"type\":\"address\"}],\"name\":\"_setWantAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFacuetAddress\",\"type\":\"address\"}],\"name\":\"_setWantFacuet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsRegisteredForDrop\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accruedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksRemainingToRegister\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDropIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDropStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discountFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountsRegisteredForDrop\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDropIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExpectedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalCurrentDropReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDropOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastDropRegistered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingWanttrollerImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerAndCollect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerForDrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registeredForNextDrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tick\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDropped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitblocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wantDropState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numRegistrants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDrop\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wantFaucetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wanttrollerImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Wanttroller","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ba74370b6e34e4fb281e88f1312ca0ce38bfaa4a8dac464a9687dcc097ac4574"}]}