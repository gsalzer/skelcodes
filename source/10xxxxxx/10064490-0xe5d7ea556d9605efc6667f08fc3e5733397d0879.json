{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20 {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool); //real elf\r\n  //function transfer(address _to, uint256 _value) public;\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  //function burnTokens(uint256 _amount) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract LockMapping is Owned {\r\n\r\n    using SafeMath for uint256;\r\n\tevent NewReceipt(uint256 receiptId, address asset, address owner, uint256 endTime);\r\n\r\n\taddress public asset = 0xbf2179859fc6D5BEE9Bf9158632Dc51678a4100e;\r\n\tuint256 public saveTime = 86400*30; //30 days;\r\n    uint256 public receiptCount = 0;\r\n\r\n\tstruct Receipt {\r\n\r\n\t\taddress asset;\t\t//token to deposit  ELF:0xbf2179859fc6d5bee9bf9158632dc51678a4100e\r\n\t    address owner;\t\t//owner of this receipt\r\n\t    string targetAddress;\r\n\t    uint256 amount;\r\n\t    uint256 startTime;\r\n\t    uint256 endTime;\r\n\t    bool finished;\r\n\r\n  \t}\r\n\r\n\r\n  \tReceipt[] public receipts;\r\n\r\n  \tmapping (uint256 => address) private receiptToOwner;\r\n  \tmapping (address => uint256[]) private ownerToReceipts;\r\n\r\n\r\n  \tmodifier haveAllowance(address _asset, uint256 _amount) {\r\n\r\n  \t\tuint256 allowance = ERC20(asset).allowance(msg.sender, address(this));\r\n\t    require(allowance >= _amount);\r\n\t    _;\r\n\t}\r\n\r\n\tmodifier exceedEndtime(uint256 _id) {\r\n\r\n\t    require(receipts[_id].endTime != 0 && receipts[_id].endTime <= now);\r\n\t    _;\r\n\t}\r\n\r\n\tmodifier notFinished(uint256 _id) {\r\n\r\n\t    require(receipts[_id].finished == false);\r\n\t    _;\r\n\t}\r\n\r\n\r\n  \tfunction _createReceipt(\r\n  \t\taddress _asset,\r\n  \t\taddress _owner,\r\n  \t\tstring _targetAddress,\r\n  \t\tuint256 _amount,\r\n  \t\tuint256 _startTime,\r\n  \t\tuint256 _endTime,\r\n  \t\tbool _finished\r\n  \t\t) internal {\r\n\r\n\t    uint256 id = receipts.push(Receipt(_asset, _owner, _targetAddress, _amount, _startTime, _endTime, _finished)) - 1;\r\n\r\n        receiptCount = id + 1;\r\n\t    receiptToOwner[id] = msg.sender;\r\n\t    ownerToReceipts[msg.sender].push(id);\r\n\t    emit NewReceipt(id, _asset, _owner, _endTime);\r\n\t}\r\n\r\n\r\n\t//create new receipt\r\n\tfunction createReceipt(uint256 _amount, string targetAddress) external haveAllowance(asset,_amount) {\r\n\r\n\t\t//other processes\r\n\r\n\t\t//deposit token to this contract\r\n\t\trequire (ERC20(asset).transferFrom(msg.sender, address(this), _amount));\r\n\r\n\t\t//\r\n\t    _createReceipt(asset, msg.sender, targetAddress, _amount, now, now + saveTime, false );\r\n  \t}\r\n\r\n  \t//finish the receipt and withdraw bonus and token\r\n  \tfunction finishReceipt(uint256 _id) external notFinished(_id) exceedEndtime(_id) {\r\n        // only receipt owner can finish receipt\r\n        require (msg.sender == receipts[_id].owner);\r\n        ERC20(asset).transfer(receipts[_id].owner, receipts[_id].amount );\r\n\t    receipts[_id].finished = true;\r\n  \t}\r\n\r\n    function getMyReceipts(address _address) external view returns (uint256[]){\r\n\r\n        return ownerToReceipts[_address];\r\n\r\n    }\r\n\r\n    function getLockTokens(address _address) external view returns (uint256){\r\n        uint256[] memory myReceipts = ownerToReceipts[_address!=address(0) ? _address:msg.sender];\r\n        uint256 amount = 0;\r\n\r\n        for(uint256 i=0; i< myReceipts.length; i++) {\r\n            if(receipts[myReceipts[i]].finished == false){\r\n                amount += receipts[myReceipts[i]].amount;\r\n            }\r\n\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n  \tfunction fixSaveTime(uint256 _period) external onlyOwner {\r\n  \t\tsaveTime = _period;\r\n  \t}\r\n\r\n    function getReceiptInfo(uint256 index) public view returns(bytes32, string, uint256, bool){\r\n\r\n        return (sha256(index), receipts[index].targetAddress, receipts[index].amount, receipts[index].finished);\r\n\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"receipts\",\"outputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"targetAddress\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saveTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getMyReceipts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"targetAddress\",\"type\":\"string\"}],\"name\":\"createReceipt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"fixSaveTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiptCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLockTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"finishReceipt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getReceiptInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiptId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"NewReceipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LockMapping","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3b241ac4adf3471053a9afaf13293a9df868b3f256fb23b835f65a3e3e316078"}]}