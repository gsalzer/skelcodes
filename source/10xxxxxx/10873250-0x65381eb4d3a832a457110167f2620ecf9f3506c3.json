{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor(address initialOwner) public {\r\n        require(initialOwner != address(0));\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract TriangleRooms is Ownable, ReentrancyGuard {\r\n    enum State {Stopped, Paused, Game, Drawing}\r\n    State public state = State.Stopped;\r\n\r\n    uint256 _nextPrice;\r\n    uint256 _nextPrize;\r\n    uint256 _nextLimit;\r\n\r\n    uint256 public blockDelay;\r\n\r\n    uint256 public gameCount;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) internal _tickets;\r\n    mapping(uint256 => bytes32) internal _blockhashes;\r\n    mapping(uint256 => Round) internal _rounds;\r\n\r\n    struct Round {\r\n        uint256 price;\r\n        uint256 prize;\r\n        uint256 limit;\r\n        uint256 sold;\r\n        uint256 futureblock;\r\n        mapping(uint256 => address payable) players;\r\n    }\r\n\r\n    uint256 public availableFee;\r\n    Wallet[] public wallets;\r\n\r\n    struct Wallet {\r\n        address payable account;\r\n        uint256 share;\r\n    }\r\n\r\n    event RoundStarted(uint256 gameCount);\r\n    event NewPlayer(\r\n        address indexed addr,\r\n        uint256 amount,\r\n        uint256 available,\r\n        uint256 gameCount\r\n    );\r\n    event PayBack(address indexed addr, uint256 value, string cause);\r\n    event AllBetsAreIn(uint256 tickets, uint256 gameCount);\r\n    event FutureBlock(uint256 blocknumber, uint256 delay, uint256 gameCount);\r\n    event GameOver(\r\n        uint256 gameCount,\r\n        uint256 futureblock,\r\n        bytes32 hash,\r\n        uint256 seed,\r\n        uint256 winnerTicket,\r\n        address indexed winner,\r\n        uint256 prize,\r\n        uint256 fee\r\n    );\r\n\r\n    modifier onState(State requiredState) {\r\n        require(_isState(requiredState), \"Wrong state\");\r\n        _;\r\n    }\r\n\r\n    modifier notOnPause() {\r\n        require(!_isState(State.Stopped) && !_isState(State.Paused));\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 price,\r\n        uint256 prize,\r\n        uint256 limit,\r\n        uint256 delay,\r\n        address payable initialWallet\r\n    ) public Ownable(msg.sender) {\r\n        require(delay > 0);\r\n        setParameters(price, prize, limit);\r\n        wallets.push(Wallet(initialWallet, 10000));\r\n        blockDelay = delay;\r\n    }\r\n\r\n    function start(\r\n        address payable[] calldata addresses,\r\n        uint256[] calldata amounts\r\n    ) external payable onlyOwner onState(State.Stopped) {\r\n        require(addresses.length == amounts.length, \"Arrays are not equal\");\r\n\r\n        _startRound();\r\n\r\n        Round storage round = _rounds[gameCount];\r\n\r\n        uint256 totalValue;\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            round.players[round.sold] = addresses[i];\r\n            round.sold += amounts[i];\r\n\r\n            _tickets[addresses[i]][gameCount] += amounts[i];\r\n\r\n            emit NewPlayer(\r\n                addresses[i],\r\n                amounts[i],\r\n                round.limit - round.sold,\r\n                gameCount\r\n            );\r\n\r\n            totalValue += amounts[i] * round.price;\r\n        }\r\n\r\n        require(\r\n            totalValue <= round.limit * round.price,\r\n            \"Round limit overflow\"\r\n        );\r\n        require(msg.value >= totalValue, \"Not enough of ether\");\r\n\r\n        uint256 change = msg.value - totalValue;\r\n        if (change > 0) {\r\n            if (msg.sender.send(change)) {\r\n                emit PayBack(msg.sender, change, \"Limit\");\r\n            }\r\n        }\r\n\r\n        if (round.sold >= round.limit) {\r\n            state = State.Drawing;\r\n            emit AllBetsAreIn(round.sold, gameCount);\r\n            draw();\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        if (_isState(State.Game)) {\r\n            play();\r\n        } else if (_isState(State.Drawing)) {\r\n            bool result = draw();\r\n            if (!result && msg.value > 0) {\r\n                if (msg.sender.send(msg.value)) {\r\n                    emit PayBack(msg.sender, msg.value, \"Draw\");\r\n                }\r\n            }\r\n        } else revert();\r\n    }\r\n\r\n    function play() public payable notOnPause nonReentrant {\r\n        if (_isState(State.Game)) {\r\n            Round storage round = _rounds[gameCount];\r\n\r\n            uint256 amount = msg.value / round.price;\r\n\r\n            require(amount > 0);\r\n\r\n            uint256 change;\r\n            string memory comment;\r\n            uint256 available = getAvailableTickets();\r\n\r\n            if (amount > available) {\r\n                amount = available;\r\n                change = msg.value - (available * round.price);\r\n                comment = \"Limit\";\r\n            } else if (msg.value > amount * round.price) {\r\n                change = msg.value % round.price;\r\n                comment = \"Change\";\r\n            }\r\n\r\n            if (amount > 0) {\r\n                round.players[round.sold] = msg.sender;\r\n                round.sold += amount;\r\n\r\n                _tickets[msg.sender][gameCount] += amount;\r\n            }\r\n\r\n            emit NewPlayer(\r\n                msg.sender,\r\n                amount,\r\n                round.limit - round.sold,\r\n                gameCount\r\n            );\r\n\r\n            if (round.sold >= round.limit) {\r\n                state = State.Drawing;\r\n                emit AllBetsAreIn(round.sold, gameCount);\r\n            }\r\n\r\n            if (change > 0) {\r\n                if (msg.sender.send(change)) {\r\n                    emit PayBack(msg.sender, change, comment);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (_isState(State.Drawing)) {\r\n            draw();\r\n        }\r\n    }\r\n\r\n    function draw() public payable onState(State.Drawing) returns (bool) {\r\n        Round storage round = _rounds[gameCount];\r\n\r\n        if (round.futureblock == 0 || block.number > round.futureblock + 254) {\r\n            round.futureblock = block.number + blockDelay;\r\n\r\n            emit FutureBlock(round.futureblock, blockDelay, gameCount);\r\n            return false;\r\n        }\r\n\r\n        require(\r\n            block.number > round.futureblock,\r\n            \"Awaiting for the future block\"\r\n        );\r\n\r\n        uint256 fee = address(this).balance - round.prize - msg.value;\r\n        availableFee += fee;\r\n\r\n        (\r\n            uint256 futureblock,\r\n            bytes32 hash,\r\n            uint256 seed,\r\n            uint256 winnerTicket,\r\n            address payable winnerAddr\r\n        ) = getRoundWinner(gameCount);\r\n        _blockhashes[futureblock] = hash;\r\n        (winnerAddr.send(round.prize));\r\n\r\n        emit GameOver(\r\n            gameCount,\r\n            futureblock,\r\n            hash,\r\n            seed,\r\n            winnerTicket,\r\n            winnerAddr,\r\n            round.prize,\r\n            fee\r\n        );\r\n\r\n        _startRound();\r\n\r\n        if (msg.value >= _rounds[gameCount].price) {\r\n            play();\r\n        } else if (msg.value > 0) {\r\n            if (msg.sender.send(msg.value)) {\r\n                emit PayBack(msg.sender, msg.value, \"Change\");\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _startRound() internal {\r\n        gameCount++;\r\n\r\n        Round storage round = _rounds[gameCount];\r\n\r\n        round.price = _nextPrice;\r\n        round.prize = _nextPrize;\r\n        round.limit = _nextLimit;\r\n\r\n        state = State.Game;\r\n\r\n        emit RoundStarted(gameCount);\r\n    }\r\n\r\n    function donate() external payable {}\r\n\r\n    function pause() external onlyOwner onState(State.Game) {\r\n        state = State.Paused;\r\n    }\r\n\r\n    function unpause() external onlyOwner onState(State.Paused) {\r\n        state = State.Game;\r\n    }\r\n\r\n    function setWallets(\r\n        address payable[] memory initialWallets,\r\n        uint256[] memory shares\r\n    ) public onlyOwner {\r\n        require(initialWallets.length == shares.length);\r\n\r\n        if (availableFee > 0) {\r\n            withdrawFee();\r\n        }\r\n\r\n        delete wallets;\r\n\r\n        uint256 totalShare;\r\n        for (uint256 i = 0; i < initialWallets.length; i++) {\r\n            require(!_isContract(initialWallets[i]));\r\n            wallets.push(Wallet(initialWallets[i], shares[i]));\r\n            totalShare += shares[i];\r\n        }\r\n\r\n        require(totalShare == 10000, \"Total sum of shares must be 10000\");\r\n    }\r\n\r\n    function setParameters(\r\n        uint256 newPrice,\r\n        uint256 newPrize,\r\n        uint256 newLimit\r\n    ) public onlyOwner {\r\n        require(newPrice > 0 && newPrize > 0 && newLimit > 0);\r\n        require(newPrize < newPrice * newLimit);\r\n\r\n        _nextPrice = newPrice;\r\n        _nextPrize = newPrize;\r\n        _nextLimit = newLimit;\r\n    }\r\n\r\n    function withdrawFee() public onlyOwner {\r\n        uint256 payout = availableFee;\r\n        if (payout > 0) {\r\n            availableFee = 0;\r\n            for (uint256 i; i < wallets.length; i++) {\r\n                wallets[i].account.transfer(\r\n                    (payout * wallets[i].share) / 10000\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawERC20(address ERC20Token, address recipient)\r\n        external\r\n        onlyOwner\r\n    {\r\n        uint256 amount = IERC20(ERC20Token).balanceOf(address(this));\r\n        IERC20(ERC20Token).transfer(recipient, amount);\r\n    }\r\n\r\n    function getRoundWinner(uint256 roundIdx)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 futureblock,\r\n            bytes32 hash,\r\n            uint256 seed,\r\n            uint256 winnerTicket,\r\n            address payable winnerAddr\r\n        )\r\n    {\r\n        require(roundIdx <= gameCount);\r\n\r\n        futureblock = getRoundFutureBlock(roundIdx);\r\n        hash = getBlockHash(futureblock);\r\n        seed = getSeed(hash);\r\n        winnerTicket = getWinnerTicket(roundIdx, seed);\r\n        winnerAddr = getWinnerAddress(roundIdx, winnerTicket);\r\n\r\n        return (futureblock, hash, seed, winnerTicket, winnerAddr);\r\n    }\r\n\r\n    function getRoundFutureBlock(uint256 roundIdx)\r\n        public\r\n        view\r\n        returns (uint256 blocknumber)\r\n    {\r\n        blocknumber = _rounds[roundIdx].futureblock;\r\n        return blocknumber;\r\n    }\r\n\r\n    function getBlockHash(uint256 blocknumber)\r\n        public\r\n        view\r\n        returns (bytes32 hash)\r\n    {\r\n        require(block.number > blocknumber, \"Awaiting for the future block\");\r\n\r\n        if (block.number < blocknumber + 254) {\r\n            hash = blockhash(blocknumber);\r\n        } else {\r\n            hash = _blockhashes[blocknumber];\r\n        }\r\n\r\n        return hash;\r\n    }\r\n\r\n    function getSeed(bytes32 hash) public pure returns (uint256 seed) {\r\n        require(hash > 0, \"Hash is the zero value\");\r\n        return uint256(hash);\r\n    }\r\n\r\n    function getWinnerTicket(uint256 roundIdx, uint256 seed)\r\n        public\r\n        view\r\n        returns (uint256 winnerTicket)\r\n    {\r\n        require(roundIdx <= gameCount);\r\n\r\n        winnerTicket = (seed % _rounds[roundIdx].limit) + 1;\r\n\r\n        return winnerTicket;\r\n    }\r\n\r\n    function getWinnerAddress(uint256 roundIdx, uint256 winnerTicket)\r\n        public\r\n        view\r\n        returns (address payable winnerAddr)\r\n    {\r\n        require(roundIdx <= gameCount);\r\n\r\n        Round storage round = _rounds[roundIdx];\r\n\r\n        for (uint256 i = 0; i <= winnerTicket; i++) {\r\n            if (round.players[winnerTicket - i] != address(0)) {\r\n                winnerAddr = round.players[winnerTicket - i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        return winnerAddr;\r\n    }\r\n\r\n    function getRoundParameters(uint256 roundIdx)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 price,\r\n            uint256 prize,\r\n            uint256 limit\r\n        )\r\n    {\r\n        Round memory round = _rounds[roundIdx];\r\n\r\n        return (round.price, round.prize, round.limit);\r\n    }\r\n\r\n    function getCurrentParameters()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 price,\r\n            uint256 prize,\r\n            uint256 limit\r\n        )\r\n    {\r\n        return getRoundParameters(gameCount);\r\n    }\r\n\r\n    function getNextParameters()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 price,\r\n            uint256 prize,\r\n            uint256 limit\r\n        )\r\n    {\r\n        return (_nextPrice, _nextPrize, _nextLimit);\r\n    }\r\n\r\n    function getAvailableTickets() public view returns (uint256) {\r\n        Round memory round = _rounds[gameCount];\r\n        return (round.limit - round.sold);\r\n    }\r\n\r\n    function getTicketsOf(address account, uint256 roundIdx)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _tickets[account][roundIdx];\r\n    }\r\n\r\n    function getCurrentTicketsOf(address account)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _tickets[account][gameCount];\r\n    }\r\n\r\n    function _isState(State requiredState) internal view returns (bool) {\r\n        return (state == requiredState);\r\n    }\r\n\r\n    function _isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"draw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"newPrize\",\"type\":\"uint256\"},{\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentParameters\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"prize\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIdx\",\"type\":\"uint256\"}],\"name\":\"getRoundWinner\",\"outputs\":[{\"name\":\"futureblock\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"winnerTicket\",\"type\":\"uint256\"},{\"name\":\"winnerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIdx\",\"type\":\"uint256\"}],\"name\":\"getRoundFutureBlock\",\"outputs\":[{\"name\":\"blocknumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"start\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentTicketsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"share\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIdx\",\"type\":\"uint256\"},{\"name\":\"winnerTicket\",\"type\":\"uint256\"}],\"name\":\"getWinnerAddress\",\"outputs\":[{\"name\":\"winnerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"play\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ERC20Token\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIdx\",\"type\":\"uint256\"},{\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"getWinnerTicket\",\"outputs\":[{\"name\":\"winnerTicket\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"getSeed\",\"outputs\":[{\"name\":\"seed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIdx\",\"type\":\"uint256\"}],\"name\":\"getRoundParameters\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"prize\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"roundIdx\",\"type\":\"uint256\"}],\"name\":\"getTicketsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"initialWallets\",\"type\":\"address[]\"},{\"name\":\"shares\",\"type\":\"uint256[]\"}],\"name\":\"setWallets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blocknumber\",\"type\":\"uint256\"}],\"name\":\"getBlockHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextParameters\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"prize\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"prize\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"delay\",\"type\":\"uint256\"},{\"name\":\"initialWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"available\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"NewPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cause\",\"type\":\"string\"}],\"name\":\"PayBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tickets\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"AllBetsAreIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"delay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameCount\",\"type\":\"uint256\"}],\"name\":\"FutureBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"futureblock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerTicket\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"GameOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TriangleRooms","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000002714711487800000000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000000100000000000000000000000025e5cbf7a30dbaae37506a8cfbb76e6855ba1af9","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://12fc5bccf5187ee3e99bf9be04e5a750b7983562241e2852060ff60af5c2d48a"}]}