{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/hardworkInterface/IVault.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\ninterface IVault {\r\n    // the IERC20 part is the share\r\n\r\n    function underlyingBalanceInVault() external view returns (uint256);\r\n    function underlyingBalanceWithInvestment() external view returns (uint256);\r\n\r\n    function governance() external view returns (address);\r\n    function controller() external view returns (address);\r\n    function underlying() external view returns (address);\r\n    function strategy() external view returns (address);\r\n\r\n    function setStrategy(address _strategy) external;\r\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\r\n\r\n    function deposit(uint256 amountWei) external;\r\n    function depositFor(uint256 amountWei, address holder) external;\r\n\r\n    function withdrawAll() external;\r\n    function withdraw(uint256 numberOfShares) external;\r\n    function getPricePerFullShare() external view returns (uint256);\r\n\r\n    function underlyingBalanceWithInvestmentForHolder(address holder) view external returns (uint256);\r\n\r\n    // hard work should be callable only by the controller (by the hard worker) or by governance\r\n    function doHardWork() external;\r\n    function rebalance() external;\r\n}\r\n\r\n// File: contracts/Storage.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ncontract Storage {\r\n\r\n  address public governance;\r\n  address public controller;\r\n\r\n  constructor() public {\r\n    governance = msg.sender;\r\n  }\r\n\r\n  modifier onlyGovernance() {\r\n    require(isGovernance(msg.sender), \"Not governance\");\r\n    _;\r\n  }\r\n\r\n  function setGovernance(address _governance) public onlyGovernance {\r\n    require(_governance != address(0), \"new governance shouldn't be empty\");\r\n    governance = _governance;\r\n  }\r\n\r\n  function setController(address _controller) public onlyGovernance {\r\n    require(_controller != address(0), \"new controller shouldn't be empty\");\r\n    controller = _controller;\r\n  }\r\n\r\n  function isGovernance(address account) public view returns (bool) {\r\n    return account == governance;\r\n  }\r\n\r\n  function isController(address account) public view returns (bool) {\r\n    return account == controller;\r\n  }\r\n}\r\n\r\n// File: contracts/Governable.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\ncontract Governable {\r\n\r\n  Storage public store;\r\n\r\n  constructor(address _store) public {\r\n    require(_store != address(0), \"new storage shouldn't be empty\");\r\n    store = Storage(_store);\r\n  }\r\n\r\n  modifier onlyGovernance() {\r\n    require(store.isGovernance(msg.sender), \"Not governance\");\r\n    _;\r\n  }\r\n\r\n  function setStorage(address _store) public onlyGovernance {\r\n    require(_store != address(0), \"new storage shouldn't be empty\");\r\n    store = Storage(_store);\r\n  }\r\n\r\n  function governance() public view returns (address) {\r\n    return store.governance();\r\n  }\r\n}\r\n\r\n// File: contracts/Controllable.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\ncontract Controllable is Governable {\r\n\r\n  constructor(address _storage) Governable(_storage) public {\r\n  }\r\n\r\n  modifier onlyController() {\r\n    require(store.isController(msg.sender), \"Not a controller\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyControllerOrGovernance(){\r\n    require((store.isController(msg.sender) || store.isGovernance(msg.sender)),\r\n      \"The caller must be controller or governance\");\r\n    _;\r\n  }\r\n\r\n  function controller() public view returns (address) {\r\n    return store.controller();\r\n  }\r\n}\r\n\r\n// File: contracts/StrategySwitchHelper.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\ncontract StrategySwitchHelper is Controllable {\r\n\r\n  constructor(address _storage)\r\n  Controllable(_storage) public {}\r\n\r\n  /**\r\n    This contract is used to do withdraw and reinvest atomically to prevent arbitrage. \r\n  */\r\n  function setStrategyDoHardWork(address vault, address newStrategy) external onlyGovernance {\r\n    IVault(vault).setStrategy(newStrategy);\r\n    IVault(vault).doHardWork();\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_storage\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_store\",\"type\":\"address\"}],\"name\":\"setStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"setStrategyDoHardWork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"store\",\"outputs\":[{\"internalType\":\"contract Storage\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StrategySwitchHelper","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"150","ConstructorArguments":"000000000000000000000000c95cbe4ca30055c787cb784be99d6a8494d0d197","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d6e4613353a1caf29485aaf2d32104aa36695d93476f0fcad0a66399aba63137"}]}