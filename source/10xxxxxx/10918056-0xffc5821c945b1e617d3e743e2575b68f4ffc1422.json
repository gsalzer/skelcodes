{"status":"1","message":"OK","result":[{"SourceCode":"//   _    _ _   _                __ _                            \r\n//  | |  (_) | | |              / _(_)                           \r\n//  | | ___| |_| |_ ___ _ __   | |_ _ _ __   __ _ _ __   ___ ___ \r\n//  | |/ / | __| __/ _ \\ '_ \\  |  _| | '_ \\ / _` | '_ \\ / __/ _ \\\r\n//  |   <| | |_| ||  __/ | | |_| | | | | | | (_| | | | | (_|  __/\r\n//  |_|\\_\\_|\\__|\\__\\___|_| |_(_)_| |_|_| |_|\\__,_|_| |_|\\___\\___|\r\n//\r\npragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface kBASEv0 {\r\n  function allowance ( address owner, address spender ) external view returns ( uint256 );\r\n  function approve ( address spender, uint256 amount ) external returns ( bool );\r\n  function balanceOf ( address account ) external view returns ( uint256 );\r\n  function decimals (  ) external view returns ( uint8 );\r\n  function decreaseAllowance ( address spender, uint256 subtractedValue ) external returns ( bool );\r\n  function governance (  ) external view returns ( address );\r\n  function increaseAllowance ( address spender, uint256 addedValue ) external returns ( bool );\r\n  function monetaryPolicy (  ) external view returns ( address );\r\n  function name (  ) external view returns ( string memory );\r\n  function rebase ( uint256 epoch, int256 supplyDelta ) external returns ( uint256 );\r\n  function setGovernance ( address _governance ) external;\r\n  function setMonetaryPolicy ( address monetaryPolicy_ ) external;\r\n  function symbol (  ) external view returns ( string memory );\r\n  function totalSupply (  ) external view returns ( uint256 );\r\n  function transfer ( address recipient, uint256 amount ) external returns ( bool );\r\n  function transferFrom ( address sender, address recipient, uint256 amount ) external returns ( bool );\r\n}\r\n\r\ncontract kBASEPolicyV0 {\r\n    using SafeMath for uint;\r\n\r\n    uint public constant PERIOD = 10 minutes; // will be 10 minutes in REAL CONTRACT\r\n\r\n    IUniswapV2Pair public pair;\r\n    kBASEv0 public token;\r\n\r\n    uint    public price0CumulativeLast = 0;\r\n    uint32  public blockTimestampLast = 0;\r\n    uint224 public price0RawAverage = 0;\r\n    \r\n    uint    public epoch = 0;\r\n\r\n    constructor(address _pair) public {\r\n        pair = IUniswapV2Pair(_pair);\r\n        token = kBASEv0(pair.token0());\r\n        price0CumulativeLast = pair.price0CumulativeLast();\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\r\n        require(reserve0 != 0 && reserve1 != 0, 'NO_RESERVES');\r\n    }\r\n    \r\n    uint private constant MAX_INT256 = ~(uint(1) << 255);\r\n    function toInt256Safe(uint a) internal pure returns (int) {\r\n        require(a <= MAX_INT256);\r\n        return int(a);\r\n    }\r\n\r\n    function rebase() external {\r\n        uint timestamp = block.timestamp;\r\n        require(timestamp % 3600 < 3 * 60); // rebase can only happen between XX:00:00 ~ XX:02:59 of every hour\r\n        \r\n        uint price0Cumulative = pair.price0CumulativeLast();\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        uint32 blockTimestamp;\r\n        (reserve0, reserve1, blockTimestamp) = pair.getReserves();\r\n        require(reserve0 != 0 && reserve1 != 0, 'NO_RESERVES');\r\n        \r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n\r\n        // ensure that at least one full period has passed since the last update\r\n        require(timeElapsed >= PERIOD, 'PERIOD_NOT_ELAPSED');\r\n\r\n        // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        price0RawAverage = uint224((price0Cumulative - price0CumulativeLast) / timeElapsed);\r\n\r\n        price0CumulativeLast = price0Cumulative;\r\n        blockTimestampLast = blockTimestamp;\r\n        \r\n        // compute rebase\r\n        \r\n        uint price = price0RawAverage;\r\n        price = price.mul(10 ** 17).div(2 ** 112); // USDC decimals = 6, 100000 = 10^5, 18 - 6 + 5 = 17\r\n \r\n        require(price != 100000, 'NO_NEED_TO_REBASE'); // don't rebase if price = 1.00000\r\n        \r\n        // rebase & sync\r\n        \r\n        if (price > 100000) { // positive rebase\r\n            uint delta = price.sub(100000);\r\n            token.rebase(epoch, toInt256Safe(token.totalSupply().mul(delta).div(100000 * 10))); // rebase using 10% of price delta\r\n        } \r\n        else { // negative rebase\r\n            uint delta = 100000;\r\n            delta = delta.sub(price);\r\n            token.rebase(epoch, -toInt256Safe(token.totalSupply().mul(delta).div(100000 * 2))); // get out of \"death spiral\" ASAP\r\n        }\r\n        \r\n        pair.sync();\r\n        epoch = epoch.add(1);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price0RawAverage\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"\",\"type\":\"uint224\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract kBASEv0\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"kBASEPolicyV0","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c39180720b4b4df561a35366da122fba006fbc17","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3db480ef1ed9ac564f2779729a35e663da3908b01219acb2672c8a1b7e31f4f7"}]}