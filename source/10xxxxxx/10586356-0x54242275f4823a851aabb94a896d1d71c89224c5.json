{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin\\upgrades\\contracts\\Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\multisig\\MultiOwnable.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\ncontract MultiOwnable is\r\n    Initializable\r\n{\r\n\r\n    struct VoteInfo {\r\n        uint16 votesCounter;\r\n        uint64 curVote;\r\n        mapping(uint => mapping (address => bool)) isVoted; // [curVote][owner]\r\n    }\r\n\r\n\r\n    uint public constant MIN_VOTES = 2;\r\n\r\n    mapping(bytes => VoteInfo) public votes;\r\n    mapping(address => bool) public  multiOwners;\r\n\r\n    uint public multiOwnersCounter;\r\n\r\n\r\n    event VoteForCalldata(address _owner, bytes _data);\r\n\r\n\r\n    modifier onlyMultiOwners {\r\n        require(multiOwners[msg.sender], \"Permission denied\");\r\n\r\n        uint curVote = votes[msg.data].curVote;\r\n\r\n        // vote for current call\r\n        if (!votes[msg.data].isVoted[curVote][msg.sender]) {\r\n            votes[msg.data].isVoted[curVote][msg.sender] = true;\r\n            votes[msg.data].votesCounter++;\r\n        }\r\n\r\n        if (votes[msg.data].votesCounter >= MIN_VOTES ||\r\n            votes[msg.data].votesCounter >= multiOwnersCounter\r\n        ){\r\n            // iterate to new vote for this msg.data\r\n            votes[msg.data].votesCounter = 0;\r\n            votes[msg.data].curVote++;\r\n            _;\r\n        } else {\r\n            emit VoteForCalldata(msg.sender, msg.data);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    // ** INITIALIZERS **\r\n\r\n    function initialize() public initializer {\r\n        _addOwner(msg.sender);\r\n    }\r\n\r\n    function initialize(address[] memory _newOwners) public initializer {\r\n        require(_newOwners.length > 0, \"Array lengths have to be greater than zero\");\r\n\r\n        for (uint i = 0; i < _newOwners.length; i++) {\r\n            _addOwner(_newOwners[i]);\r\n        }\r\n    }\r\n\r\n\r\n    // ** ONLY_MULTI_OWNERS functions **\r\n\r\n\r\n    function addOwner(address _newOwner) public onlyMultiOwners {\r\n        _addOwner(_newOwner);\r\n    }\r\n\r\n\r\n    function addOwners(address[] memory _newOwners) public onlyMultiOwners {\r\n        require(_newOwners.length > 0, \"Array lengths have to be greater than zero\");\r\n\r\n        for (uint i = 0; i < _newOwners.length; i++) {\r\n            _addOwner(_newOwners[i]);\r\n        }\r\n    }\r\n\r\n    function removeOwner(address _exOwner) public onlyMultiOwners {\r\n        _removeOwner(_exOwner);\r\n    }\r\n\r\n    function removeOwners(address[] memory _exOwners) public onlyMultiOwners {\r\n        require(_exOwners.length > 0, \"Array lengths have to be greater than zero\");\r\n\r\n        for (uint i = 0; i < _exOwners.length; i++) {\r\n            _removeOwner(_exOwners[i]);\r\n        }\r\n    }\r\n\r\n\r\n    // ** INTERNAL functions **\r\n\r\n    function _addOwner(address _newOwner) internal {\r\n        require(!multiOwners[_newOwner], \"The owner has already been added\");\r\n\r\n        // UPD states\r\n        multiOwners[_newOwner] = true;\r\n        multiOwnersCounter++;\r\n    }\r\n\r\n    function _removeOwner(address _exOwner) internal {\r\n        require(multiOwners[_exOwner], \"This address is not the owner\");\r\n        require(multiOwnersCounter > 1, \"At least one owner required\");\r\n\r\n        // UPD states\r\n        multiOwners[_exOwner] = false;\r\n        multiOwnersCounter--;   // safe\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\multisig\\interfaces\\IAdminUpgradeabilityProxy.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ninterface IAdminUpgradeabilityProxy {\r\n    function changeAdmin(address newAdmin) external;\r\n    function upgradeTo(address newImplementation) external;\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\r\n}\r\n\r\n// File: contracts\\multisig\\ProxyAdminMultisig.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n// **INTERFACES**\r\n\r\n\r\n\r\n/**\r\n * @title ProxyAdminMultisig\r\n * @dev This contract is the admin of a proxy, and is in charge\r\n * of upgrading it as well as transferring it to another admin.\r\n */\r\ncontract ProxyAdminMultisig is MultiOwnable {\r\n\r\n    constructor() public {\r\n        address[] memory newOwners = new address[](2);\r\n        newOwners[0] = 0xdAE0aca4B9B38199408ffaB32562Bf7B3B0495fE;\r\n        newOwners[1] = 0xBE1A1E7304E397A765aB0837ea2f5Cb7b4ca125C;\r\n        initialize(newOwners);\r\n    }\r\n    /**\r\n     * @dev Returns the current implementation of a proxy.\r\n     * This is needed because only the proxy admin can query it.\r\n     * @return The address of the current implementation of the proxy.\r\n     */\r\n    function getProxyImplementation(IAdminUpgradeabilityProxy proxy) public view returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin of a proxy. Only the admin can query it.\r\n     * @return The address of the current admin of the proxy.\r\n     */\r\n    function getProxyAdmin(IAdminUpgradeabilityProxy proxy) public view returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of a proxy.\r\n     * @param proxy Proxy to change admin.\r\n     * @param newAdmin Address to transfer proxy administration to.\r\n     */\r\n    function changeProxyAdmin(IAdminUpgradeabilityProxy proxy, address newAdmin) public onlyMultiOwners {\r\n        proxy.changeAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades a proxy to the newest implementation of a contract.\r\n     * @param proxy Proxy to be upgraded.\r\n     * @param implementation the address of the Implementation.\r\n     */\r\n    function upgrade(IAdminUpgradeabilityProxy proxy, address implementation) public onlyMultiOwners {\r\n        proxy.upgradeTo(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\r\n     * This is useful to initialize the proxied contract.\r\n     * @param proxy Proxy to be upgraded.\r\n     * @param implementation Address of the Implementation.\r\n     * @param data Data to send as msg.data in the low level call.\r\n     * It should include the signature and the parameters of the function to be called, as described in\r\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n     */\r\n    function upgradeAndCall(IAdminUpgradeabilityProxy proxy, address implementation, bytes memory data) public payable onlyMultiOwners {\r\n        proxy.upgradeToAndCall.value(msg.value)(implementation, data);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"VoteForCalldata\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_VOTES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newOwners\",\"type\":\"address[]\"}],\"name\":\"addOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newOwners\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"multiOwners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiOwnersCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exOwner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_exOwners\",\"type\":\"address[]\"}],\"name\":\"removeOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"votesCounter\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"curVote\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProxyAdminMultisig","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ba3ab599eeb67c68521c7ef6cc7a2059b7d902d700b17515a2b09200fc0abaa7"}]}