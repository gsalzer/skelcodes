{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *\r\n * $$$$$$\\                                 $$\\               $$$$$$$\\                                $$\\\r\n * $$  __$$\\                                $$ |              $$  __$$\\                               $$ |\r\n * $$ /  \\__| $$$$$$\\  $$\\   $$\\  $$$$$$\\ $$$$$$\\    $$$$$$\\  $$ |  $$ | $$$$$$\\  $$$$$$$\\   $$$$$$$\\ $$$$$$$\\\r\n * $$ |      $$  __$$\\ $$ |  $$ |$$  __$$\\\\_$$  _|  $$  __$$\\ $$$$$$$  | \\____$$\\ $$  __$$\\ $$  _____|$$  __$$\\\r\n * $$ |      $$ |  \\__|$$ |  $$ |$$ /  $$ | $$ |    $$ /  $$ |$$  __$$<  $$$$$$$ |$$ |  $$ |$$ /      $$ |  $$ |\r\n * $$ |  $$\\ $$ |      $$ |  $$ |$$ |  $$ | $$ |$$\\ $$ |  $$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$ |      $$ |  $$ |\r\n * \\$$$$$$  |$$ |      \\$$$$$$$ |$$$$$$$  | \\$$$$  |\\$$$$$$  |$$ |  $$ |\\$$$$$$$ |$$ |  $$ |\\$$$$$$$\\ $$ |  $$ |\r\n * \\______/ \\__|       \\____$$ |$$  ____/   \\____/  \\______/ \\__|  \\__| \\_______|\\__|  \\__| \\_______|\\__|  \\__|\r\n *                    $$\\   $$ |$$ |\r\n *                    \\$$$$$$  |$$ |\r\n *                     \\______/ \\__|\r\n *\r\n *\r\n * WEBSITE URL: https://cryptoranch.io/\r\n*/\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n    address payable public developer;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only Owner Can Do This\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address payable _newOwner) internal {\r\n        require(_newOwner != address(0), \"New Owner's Address is Required\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Ranch is Ownable, Pausable{\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint[9] _ranchSize = [0,2000,3000,4000,7000,9000,10000,14000,17000];\r\n    uint[9] _ranchGradeByNum = [0,1,5,10,30,50,100,150,200];\r\n\r\n    address private cryptoRanchAddress;\r\n\r\n    event OnSetCryptoRanchAddress(address cryptoRanchAddress,  uint timestamp);\r\n\r\n    constructor(address cryptoRanchAddr) public {\r\n        cryptoRanchAddress = cryptoRanchAddr;\r\n    }\r\n\r\n    modifier onlyForCryptoRanch() {\r\n        require(cryptoRanchAddress == msg.sender, \"Only for cryptoRanch contract!\");\r\n        _;\r\n    }\r\n\r\n    function setCryptoRanchAddress(address cryptoRanchAddr) public onlyOwner {\r\n        cryptoRanchAddress = cryptoRanchAddr;\r\n        emit OnSetCryptoRanchAddress(cryptoRanchAddress, now);\r\n    }\r\n\r\n    function getCryptoRanchAddress() public view returns (address) {\r\n        return cryptoRanchAddress;\r\n    }\r\n\r\n    // for upgrade, reset the attributes of ranch\r\n    function ranch(uint totalSheepPrice, uint sheepNum) public view onlyForCryptoRanch returns(uint, uint, uint, uint) {\r\n        uint ranchGrade = getRanchGrade(sheepNum);\r\n        uint ranchSize = getRanchSize(ranchGrade);\r\n        uint admissionPrice = getAdmissionPrice(totalSheepPrice);\r\n        uint maxProfitability = getMaxProfitability(ranchGrade, admissionPrice);\r\n\r\n        return (\r\n        ranchGrade,\r\n        ranchSize,\r\n        admissionPrice,\r\n        maxProfitability\r\n        );\r\n    }\r\n\r\n    function getRanchGrade(uint sheepNum) public view onlyForCryptoRanch returns (uint) {\r\n        for (uint i = 0; i < 9; i++) {\r\n            if (sheepNum == _ranchGradeByNum[i]) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getRanchSize(uint ranchGrade) public view onlyForCryptoRanch returns(uint) {\r\n        return _ranchSize[ranchGrade];\r\n    }\r\n\r\n    function getMaxProfitability(uint ranchGrade, uint admissionPrice) public view onlyForCryptoRanch returns(uint) {\r\n        return admissionPrice.mul(getRanchSize(ranchGrade));\r\n    }\r\n\r\n    function getAdmissionPrice(uint totalSheepPrice) public view onlyForCryptoRanch returns(uint) {\r\n        return totalSheepPrice.mul(2);\r\n    }\r\n\r\n    function multipleBuy(uint totalSheepPrice, uint oldAdmissionPrice, uint oldMaxProfitability)\r\n    public view onlyForCryptoRanch returns(uint, uint){\r\n        uint admissionPrice = getAdmissionPrice(totalSheepPrice);\r\n        uint newAdmissionPrice = admissionPrice.add(oldAdmissionPrice);\r\n        uint newMaxProfitability = getMaxProfitability(8, admissionPrice).add(oldMaxProfitability);\r\n        return (newAdmissionPrice, newMaxProfitability);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Commission is Ownable, Pausable{\r\n    using SafeMath for uint;\r\n\r\n    uint[9] gradeToCommission = [100,400,400,500,500,600,600,700,700];\r\n    uint[9] ranchGrow = [0,0,0,0,0,0,0,0,1000];\r\n\r\n    address private cryptoRanchAddress;\r\n\r\n    struct Generation {\r\n        uint[] ancestorList; //up-line\r\n        uint[] inviteesList; //down-line\r\n    }\r\n\r\n    mapping (uint => Generation) generations;\r\n\r\n    event OnSetCryptoRanchAddress(address cryptoRanchAddress, uint timestamp);\r\n\r\n    constructor (address cryptoRanchAddr) public {\r\n        cryptoRanchAddress = cryptoRanchAddr;\r\n    }\r\n\r\n    modifier onlyForCryptoRanch() {\r\n        require(cryptoRanchAddress == msg.sender, \"Only for cryptoRanch contract!\");\r\n        _;\r\n    }\r\n\r\n    // link to the reference contract\r\n    function setCryptoRanchAddress(address cryptoRanchAddr) public onlyOwner{\r\n        cryptoRanchAddress = cryptoRanchAddr;\r\n        emit OnSetCryptoRanchAddress(cryptoRanchAddress, now);\r\n    }\r\n\r\n    function joinGame(uint pID, uint inviterID) public onlyForCryptoRanch{\r\n\r\n        uint len = generations[inviterID].ancestorList.length;\r\n        if (len == 0) {\r\n            generations[pID].ancestorList.push(inviterID);\r\n        } else if (len < 10) {\r\n            generations[pID].ancestorList.push(inviterID);\r\n            for(uint i = 0; i < len; i++) {\r\n                generations[pID].ancestorList.push(generations[inviterID].ancestorList[i]);\r\n            }\r\n        } else if (len >= 10) {\r\n            generations[pID].ancestorList.push(inviterID);\r\n            for(uint i = 0; i < 9; i++) {\r\n                generations[pID].ancestorList.push(generations[inviterID].ancestorList[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function inviteNewUser(uint inviterID, uint inviterRanchSize, bool inviterIsAlive, uint invitee, uint inviteeRanchGrade)\r\n    public onlyForCryptoRanch returns(uint){\r\n        generations[inviterID].inviteesList.push(invitee);\r\n        if (inviterIsAlive) {\r\n            uint newRanchSize = inviterRanchSize.add(ranchGrow[inviteeRanchGrade]);\r\n            return newRanchSize;\r\n        } else {\r\n            return inviterRanchSize;\r\n        }\r\n    }\r\n\r\n    // your upLine\r\n    function getMotherGeneration(uint pID) external view onlyForCryptoRanch returns(uint) {\r\n        require(generations[pID].ancestorList.length != 0, \"You are the first generation!\");\r\n        return generations[pID].ancestorList[0];\r\n    }\r\n\r\n    function getAncestorList(uint pID) external view onlyForCryptoRanch returns(uint[] memory){\r\n        require(generations[pID].ancestorList.length != 0, \"You are the first generation!\");\r\n\r\n        uint[] memory ancestorList = new uint[](generations[pID].ancestorList.length);\r\n        for(uint i = 0; i < generations[pID].ancestorList.length; i++){\r\n            ancestorList[i] = generations[pID].ancestorList[i];\r\n        }\r\n        return ancestorList;\r\n    }\r\n\r\n    function getInviteesList(uint pID) external view onlyForCryptoRanch returns(uint[] memory){\r\n        require(generations[pID].inviteesList.length != 0, \"You don't have downline!\");\r\n\r\n        uint[] memory inviteesList = new uint[](generations[pID].inviteesList.length);\r\n        for(uint i = 0; i < generations[pID].inviteesList.length; i++){\r\n            inviteesList[i] = generations[pID].inviteesList[i];\r\n        }\r\n        return inviteesList;\r\n    }\r\n\r\n    function getInviteesCount(uint pID) external view returns(uint){\r\n        return generations[pID].inviteesList.length;\r\n    }\r\n\r\n    function getAncestorCount(uint pID) external view returns(uint){\r\n        return generations[pID].ancestorList.length;\r\n    }\r\n}\r\n\r\n\r\ncontract TransactionSystem is Ownable{\r\n    using SafeMath for uint;\r\n\r\n    uint constant SHEEP_INIT_NUMBER = 10000;\r\n    uint constant SHEEP_INIT_PRICE = 50 finney;\r\n\r\n    event OnPriceChange(uint indexed price, uint timestamp);\r\n    event OnFleshUp(uint indexed price, uint fleshUpCount, uint timestamp);\r\n    event OnOrderAdd(address indexed from, uint number, uint timestamp);\r\n    event OnOrderCancel(address indexed from, uint number, uint timestamp);\r\n    event OnSetCryptoRanchAddress(address cryptoRanchAddress,  uint timestamp);\r\n\r\n\r\n    struct GlobalData {\r\n        uint sheepNum;\r\n        uint sheepPrice;\r\n        uint sysInSaleNum;\r\n        uint sysSoldNum;\r\n        uint[7] priceInterval;\r\n    }\r\n    struct OrderQueue {\r\n        uint[] idList;\r\n        uint front;\r\n    }\r\n\r\n    struct Order {\r\n        uint ownerID;\r\n        uint sheepNum;\r\n        uint sheepPrice;\r\n        uint round;\r\n    }\r\n\r\n    GlobalData global;\r\n    Order[] sellOrders;\r\n    uint[] private reproductionBlkNums;\r\n\r\n    CryptoRanch cryptoRanch = CryptoRanch(0x0);\r\n    address payable cryptoRanchAddress;\r\n\r\n    bool isFleshUp = false;\r\n    uint fleshUpCount = 0;\r\n    uint priceCumulativeCount;\r\n\r\n\r\n    mapping (uint => uint) orderIDByPID;               // pID => orderID\r\n    mapping (uint => OrderQueue) priceOrderQueue;      // price => orders queue on the price level\r\n    mapping (uint => uint) sysPriceSheepNum;           // price => total sheep number of sys on the price level\r\n    mapping (uint => uint) usrPriceSheepNum;           // price => total sheep number of usr orders on the price level\r\n\r\n    constructor () public{\r\n        global = GlobalData({\r\n            sheepNum: SHEEP_INIT_NUMBER,\r\n            sheepPrice: SHEEP_INIT_PRICE,\r\n            sysInSaleNum: SHEEP_INIT_NUMBER,\r\n            sysSoldNum: 0,\r\n            priceInterval: [uint256(50 finney), uint256(51 finney), uint256(52 finney), uint256(53 finney), uint256(54 finney), uint256(55 finney), uint256(56 finney)]\r\n            });\r\n\r\n        uint initSheepNum = global.sheepNum.div(50);\r\n\r\n        for (uint i = 50 finney; i <= 56 finney; i = i.add(1 finney)) {\r\n            sysPriceSheepNum[i] = initSheepNum;\r\n        }\r\n\r\n        reproductionBlkNums.push(0);\r\n\r\n        priceCumulativeCount = 56 finney;\r\n    }\r\n\r\n    modifier onlyForCryptoRanch() {\r\n        require(cryptoRanchAddress == msg.sender, \"Only for cryptoRanch contract!\");\r\n        _;\r\n    }\r\n\r\n    function() payable external{\r\n        cryptoRanchAddress.transfer(msg.value);\r\n    }\r\n\r\n    // link to the reference contract\r\n    function setCryptoRanchAddress(address payable cryptoRanchAddr) external onlyOwner {\r\n        cryptoRanchAddress = cryptoRanchAddr;\r\n        cryptoRanch = CryptoRanch(cryptoRanchAddress);\r\n\r\n        emit OnSetCryptoRanchAddress(cryptoRanchAddress, now);\r\n    }\r\n\r\n    function getCryptoRanchAddress() public view returns (address) {\r\n        return cryptoRanchAddress;\r\n    }\r\n\r\n\r\n    // purchase sheep, only call from CryptoRanch contract\r\n    function buySheepFromOrders(uint buyerID, uint balance, uint sheepNum, bool isRebuy) public onlyForCryptoRanch {\r\n\r\n        uint addSheepNum = 0; // accumulated sold sheep in this tx\r\n        uint sheepPrice = global.sheepPrice;\r\n        uint totalCost = 0;\r\n        uint cost = 0;\r\n        uint tmpRound = cryptoRanch.getReproductionRound();\r\n        OrderQueue storage Q = priceOrderQueue[sheepPrice];\r\n\r\n        while (sheepNum > 0) {\r\n            /* process the system order */\r\n            if (sysPriceSheepNum[sheepPrice] > 0) {\r\n                // enough sheep to meet the demand on current price\r\n                if (sysPriceSheepNum[sheepPrice] >= sheepNum) {\r\n                    // total sheep to be sold\r\n                    addSheepNum = addSheepNum.add(sheepNum);\r\n                    // deduct the cost\r\n                    cost = sheepNum.mul(sheepPrice);  // cost in this turn\r\n                    totalCost = totalCost.add(cost);  // forage fee, cumulated\r\n                    balance = balance.sub(cost);\r\n\r\n                    // renew the global data\r\n                    global.sysSoldNum = global.sysSoldNum.add(sheepNum);\r\n                    global.sysInSaleNum = global.sysInSaleNum.sub(sheepNum);\r\n                    // renew the sheep data on cur price\r\n                    sysPriceSheepNum[sheepPrice] = sysPriceSheepNum[sheepPrice].sub(sheepNum);\r\n                    sheepNum = 0;\r\n\r\n                    /* end the tx */\r\n                    // renew the revenue of seller\r\n                    cryptoRanch.processSellerProfit(0, cost);\r\n                    // renew the sheep number of buyer and distribute the commission\r\n                    cryptoRanch.addSheepNumber(buyerID, addSheepNum, totalCost, true);\r\n\r\n                    // refund the overage of balance\r\n                    if (balance > 0 && isRebuy == false) {\r\n                        uint tmpBalance = balance;\r\n                        balance = 0;\r\n                        cryptoRanch.buyOrderRefund(buyerID, tmpBalance);\r\n                    }\r\n\r\n                    // price change\r\n                    if (sysPriceSheepNum[sheepPrice] == 0 && usrPriceSheepNum[sheepPrice] == 0) {\r\n                        changePriceInterval(sheepPrice);\r\n                    }\r\n                    break;\r\n\r\n                } else {\r\n                    addSheepNum = addSheepNum.add(sysPriceSheepNum[sheepPrice]);\r\n                    cost = sysPriceSheepNum[sheepPrice].mul(sheepPrice);\r\n                    totalCost = totalCost.add(cost);\r\n                    balance = balance.sub(cost);\r\n\r\n                    global.sysSoldNum = global.sysSoldNum.add(sysPriceSheepNum[sheepPrice]);\r\n                    global.sysInSaleNum = global.sysInSaleNum.sub(sysPriceSheepNum[sheepPrice]);\r\n                    sheepNum = sheepNum.sub(sysPriceSheepNum[sheepPrice]);\r\n\r\n                    sysPriceSheepNum[sheepPrice] = 0;\r\n\r\n                    cryptoRanch.processSellerProfit(0, cost);\r\n                }\r\n            }\r\n\r\n            /* process the user orders */\r\n            // if no user order, price change\r\n            if (usrPriceSheepNum[sheepPrice] == 0) {\r\n                changePriceInterval(sheepPrice);\r\n                sheepPrice = global.sheepPrice;\r\n                Q = priceOrderQueue[sheepPrice]; //point to the orders queue of new price\r\n                // normalize the number of sheep bought, if the reproduction triggered\r\n                if (tmpRound < cryptoRanch.getReproductionRound()) {\r\n                    addSheepNum = addSheepNum.mul(2);\r\n                    tmpRound = cryptoRanch.getReproductionRound();\r\n                }\r\n                continue; // start with system order on new price\r\n            }\r\n\r\n            // check the order on list\r\n            while(sellOrders[Q.idList[Q.front]].sheepNum <= 0) {\r\n                Q.front ++ ;\r\n            }\r\n\r\n            // get the order\r\n            uint orderID = Q.idList[Q.front];\r\n            Order storage order = sellOrders[orderID];\r\n\r\n            // get the normalized number of sheep on order\r\n            uint realNum = order.sheepNum.mul(2**(cryptoRanch.getReproductionRound().sub(order.round)));\r\n\r\n            // the sheep of the order can be sold out\r\n            if (realNum <= sheepNum) {\r\n                addSheepNum = addSheepNum.add(realNum);\r\n                cost = realNum.mul(sheepPrice);\r\n                totalCost = totalCost.add(cost);\r\n                balance = balance.sub(cost);\r\n\r\n                // renew the global data\r\n                global.sysSoldNum = global.sysSoldNum.add(realNum);\r\n                usrPriceSheepNum[sheepPrice] = usrPriceSheepNum[sheepPrice].sub(realNum);\r\n\r\n                sheepNum = sheepNum.sub(realNum);\r\n\r\n                // renew the revenue of order owner\r\n                cryptoRanch.processSellerProfit(order.ownerID, cost);\r\n\r\n                // delete order\r\n                orderIDByPID[order.ownerID] = 0;\r\n                delete sellOrders[orderID];\r\n                delete Q.idList[Q.front];\r\n                // next order\r\n                Q.front++;\r\n\r\n                // if the sheep on cur price sold out and meet the purchased demand\r\n                if(usrPriceSheepNum[sheepPrice] == 0 && sheepNum == 0) {\r\n                    /* end the tx */\r\n                    // renew the sheep number of buyer and distribute the commission\r\n                    cryptoRanch.addSheepNumber(buyerID, addSheepNum, totalCost, true);\r\n                    // price change\r\n                    changePriceInterval(sheepPrice);\r\n\r\n                    // refund the overage of balance\r\n                    if (balance > 0 && isRebuy == false) {\r\n                        uint tmpBalance = balance;\r\n                        balance = 0;\r\n                        cryptoRanch.buyOrderRefund(buyerID, tmpBalance);\r\n                    }\r\n                    break;\r\n                }\r\n                // the sheep of the order over the purchased demand\r\n            } else {\r\n                addSheepNum = addSheepNum.add(sheepNum);\r\n                cost = sheepNum.mul(sheepPrice);\r\n                totalCost = totalCost.add(cost);\r\n                balance = balance.sub(cost);\r\n\r\n                // renew the global data\r\n                global.sysSoldNum = global.sysSoldNum.add(sheepNum);\r\n                usrPriceSheepNum[sheepPrice] = usrPriceSheepNum[sheepPrice].sub(sheepNum);\r\n\r\n                // renew and normalize the order data\r\n                sellOrders[orderID].sheepNum = realNum.sub(sheepNum);\r\n                sellOrders[orderID].round = cryptoRanch.getReproductionRound();\r\n\r\n                // clear the sheep number of demand\r\n                sheepNum = 0;\r\n                // renew the revenue of order owner\r\n                cryptoRanch.processSellerProfit(order.ownerID, cost);\r\n\r\n                /* end the tx */\r\n                // renew the sheep number of buyer and distribute the commission\r\n                cryptoRanch.addSheepNumber(buyerID, addSheepNum, totalCost, true);\r\n                // refund the overage of balance\r\n                if (balance > 0 && isRebuy == false) {\r\n                    uint tmpBalance = balance;\r\n                    balance = 0;\r\n                    cryptoRanch.buyOrderRefund(buyerID, tmpBalance);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Add new order to the contract\r\n    function addNewSellOrder(uint sellerID,  uint sheepNum, uint sheepPrice) public onlyForCryptoRanch {\r\n        // can't add order on \"Growing\" stage\r\n        require(isFleshUp == false, \"isFleshUp\");\r\n        // check price on the legal price interval\r\n        require(sheepPrice != global.sheepPrice && sheepPrice > global.sheepPrice && sheepPrice <= global.priceInterval[6], \"out of range\");\r\n\r\n        // only price = 99 then allow price = 100 order\r\n        if (global.sheepPrice < 99 finney && sheepPrice > 99 finney) {\r\n            revert(\"out of range\");\r\n        }\r\n        // if global price >= 99 only 0.1eth orders is allowed\r\n        if (global.sheepPrice >= 99 finney && sheepPrice != 100 finney) {\r\n            revert(\"0.099 only allowed 0.1 eth\");\r\n        }\r\n\r\n        // legal total number of sheep on current price ( 2% of global sheep )\r\n        if (sysPriceSheepNum[sheepPrice].add(usrPriceSheepNum[sheepPrice]).add(sheepNum).mul(50) > global.sheepNum) {\r\n            revert(\"no more than 2% global sheepNumber\");\r\n        }\r\n        // price=99, legal number limitation\r\n        if (global.sheepPrice == 99 finney && sysPriceSheepNum[50 finney].add(usrPriceSheepNum[50 finney]).add(sheepNum).mul(25) > global.sheepNum){\r\n            revert(\"no more than 2% global sheepNumber\");\r\n        }\r\n\r\n        // check whether has order in sale\r\n        require(sellOrders.length == 0 || sellOrders[orderIDByPID[sellerID]].ownerID != sellerID, \"already exist\");\r\n\r\n        // reduce the sheep of ranch\r\n        cryptoRanch.minusSheepNum(sellerID, sheepNum); //notice\r\n\r\n        // add order\r\n        uint orderID = sellOrders.length;\r\n        if (sheepPrice == 100 finney) {\r\n            sheepNum = sheepNum.mul(2);\r\n            sheepPrice = 50 finney;\r\n            sellOrders.push(Order({\r\n                ownerID: sellerID,\r\n                sheepNum: sheepNum,\r\n                sheepPrice: sheepPrice,\r\n                round: cryptoRanch.getReproductionRound().add(1)\r\n                }));\r\n        } else {\r\n            sellOrders.push(Order({\r\n                ownerID: sellerID,\r\n                sheepNum: sheepNum,\r\n                sheepPrice: sheepPrice,\r\n                round: cryptoRanch.getReproductionRound()\r\n                }));\r\n        }\r\n        orderIDByPID[sellerID] = orderID;\r\n        priceOrderQueue[sheepPrice].idList.push(orderID);\r\n        // renew the global sheep data\r\n        usrPriceSheepNum[sheepPrice] = usrPriceSheepNum[sheepPrice].add(sheepNum);\r\n\r\n        emit OnOrderAdd(cryptoRanch.getAddrByPID(sellerID), sheepNum, now);\r\n    }\r\n\r\n    // Cancel sell order\r\n    function cancelSellOrder(uint sellerID) public onlyForCryptoRanch {\r\n        require(isFleshUp == false, \"isFleshUp\");\r\n        // id check\r\n        uint orderID = orderIDByPID[sellerID];\r\n        require(orderID > 0 && sellOrders.length >= orderID, \"Id error!\");\r\n        // owner check\r\n        Order storage order = sellOrders[orderID];\r\n        require(order.ownerID == sellerID, \"no exist\");\r\n\r\n        if (global.sheepPrice == 99 finney && order.sheepPrice == 50 finney) {\r\n            revert(\"0.099 not allowed cancel 0.1 eth order\");\r\n        }\r\n\r\n        uint tmpPrice = order.sheepPrice;\r\n        // normalize sheep number\r\n        uint tmpSheepNum = order.sheepNum.mul(2**(cryptoRanch.getReproductionRound().sub(order.round)));\r\n        delete sellOrders[orderID];\r\n\r\n        cryptoRanch.addSheepNumber(sellerID, tmpSheepNum, 0, false);\r\n        usrPriceSheepNum[tmpPrice] = usrPriceSheepNum[tmpPrice].sub(tmpSheepNum);\r\n\r\n        orderIDByPID[sellerID] = 0;\r\n\r\n        emit OnOrderCancel(cryptoRanch.getAddrByPID(sellerID), tmpSheepNum, now);\r\n    }\r\n\r\n    // burn the overloaded sheep\r\n    function burnSheepGlobal(uint sheepNum) external onlyForCryptoRanch{\r\n        global.sheepNum = global.sheepNum.sub(sheepNum);\r\n    }\r\n\r\n    // find the next price which has sheep\r\n    function determineForwardSheepPrice(uint start) private {\r\n        for (uint i =  start; i < 100 finney; i = i.add(1 finney)) {\r\n            if (sysPriceSheepNum[i] > 0 || usrPriceSheepNum[i] > 0) {\r\n                global.sheepPrice = i;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // renew the price interval\r\n    function determinePriceInterval(uint sheepPrice) private {\r\n        if (isFleshUp == false && sheepPrice.add(3 finney) > priceCumulativeCount && priceCumulativeCount < 99 finney) {\r\n            uint newPrice = sheepPrice.add(3 finney);\r\n            uint addSheepNum = global.sysInSaleNum.div(50);\r\n            //renew the sysPriceSheepNum\r\n            for (uint i = sheepPrice; i <= newPrice; i = i.add(1 finney)) {\r\n                if (sysPriceSheepNum[i] == 0) sysPriceSheepNum[i] = addSheepNum;\r\n            }\r\n            priceCumulativeCount = newPrice;\r\n\r\n            global.priceInterval[0] = newPrice.sub(6 finney);\r\n            global.priceInterval[1] = newPrice.sub(5 finney);\r\n            global.priceInterval[2] = newPrice.sub(4 finney);\r\n            global.priceInterval[3] = newPrice.sub(3 finney);\r\n            global.priceInterval[4] = newPrice.sub(2 finney);\r\n            global.priceInterval[5] = newPrice.sub(1 finney);\r\n            global.priceInterval[6] = newPrice;\r\n        } else if (isFleshUp == false && sheepPrice.sub(3 finney) >= 50 finney && sheepPrice <= 96 finney)  {\r\n            global.priceInterval[0] = sheepPrice.sub(3 finney);\r\n            global.priceInterval[1] = sheepPrice.sub(2 finney);\r\n            global.priceInterval[2] = sheepPrice.sub(1 finney);\r\n            global.priceInterval[3] = sheepPrice;\r\n            global.priceInterval[4] = sheepPrice.add(1 finney);\r\n            global.priceInterval[5] = sheepPrice.add(2 finney);\r\n            global.priceInterval[6] = sheepPrice.add(3 finney);\r\n        } else if (sheepPrice == 99 finney) {\r\n            //preprocess the sheep number on 50 price after the reproduction\r\n            uint addSheepNum = global.sysInSaleNum.sub(sysPriceSheepNum[99 finney]).div(25);\r\n            sysPriceSheepNum[50 finney] = sysPriceSheepNum[50 finney].mul(2).add(addSheepNum);\r\n            usrPriceSheepNum[50 finney] = usrPriceSheepNum[50 finney].mul(2);\r\n\r\n            global.priceInterval[0] = 94 finney;\r\n            global.priceInterval[1] = 95 finney;\r\n            global.priceInterval[2] = 96 finney;\r\n            global.priceInterval[3] = 97 finney;\r\n            global.priceInterval[4] = 98 finney;\r\n            global.priceInterval[5] = 99 finney;\r\n            global.priceInterval[6] = 100 finney;\r\n        }\r\n\r\n        emit OnPriceChange(global.sheepPrice, now);\r\n    }\r\n\r\n    function changePriceInterval(uint sheepPrice) private {\r\n        // check whether on \"Growing\" stage\r\n        // the accumulated sold sheep beyond the 2% of global sheep\r\n        if (isFleshUp || global.sysSoldNum.mul(50) >= global.sheepNum) {\r\n            // first time enter, the locked sheep reset to 0\r\n            if (isFleshUp == false) fleshUpCount = 0;\r\n\r\n            bool haveSheep = false;\r\n            for (uint i = global.priceInterval[0]; i <= global.priceInterval[6]; i = i.add(1 finney)) {\r\n                if (sysPriceSheepNum[i] > 0 || usrPriceSheepNum[i] > 0) {\r\n                    if (haveSheep == false) {\r\n                        haveSheep = true;\r\n                        global.sheepPrice = i; // determine the next price\r\n                        sheepPrice = i;\r\n                    }\r\n                    // Count the remaining sheep on price interval\r\n                    if (isFleshUp == false) fleshUpCount = fleshUpCount.add(sysPriceSheepNum[i]).add(usrPriceSheepNum[i]);\r\n                    else break;\r\n                }\r\n            }\r\n            isFleshUp = true;      // \"Growing\" stage start\r\n            global.sysSoldNum = 0; // clear the accumulated sold sheep\r\n\r\n            if (fleshUpCount == 0) {\r\n                isFleshUp = false;\r\n                // determine the next price\r\n                determineForwardSheepPrice(global.priceInterval[0]);\r\n                sheepPrice = global.sheepPrice;\r\n            } else if (haveSheep == false) { // end of the \"Growing\" stage\r\n                isFleshUp = false;\r\n                global.sysSoldNum = 0;\r\n                if (sheepPrice == 99 finney) { //preprocess for the reproduction\r\n                    global.sheepPrice = 100 finney;\r\n                    sheepPrice = 100 finney;\r\n                } else { // price jump\r\n                    uint addPrice = (fleshUpCount.mul(100).div(global.sheepNum)).mul(1 finney);\r\n                    if ( fleshUpCount.mul(100) % global.sheepNum != 0) {\r\n                        addPrice = addPrice.add(1 finney);\r\n                    }\r\n                    sheepPrice =  sheepPrice.add(addPrice);\r\n\r\n                    if (sheepPrice <= priceCumulativeCount) {  // jump to the old price\r\n                        determineForwardSheepPrice(sheepPrice);// 99 price has sheep\r\n                        sheepPrice = global.sheepPrice;\r\n                    } else {                                   // jump to the new price,\r\n                        if (sheepPrice > 99 finney) {\r\n                            global.sheepPrice = 99 finney;     // will be assigned value later\r\n                            sheepPrice = 99 finney;\r\n                        } else {\r\n                            global.sheepPrice = sheepPrice;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else { // general price rise\r\n            if (sheepPrice == 99 finney) { //99 price sold out, preprocess for the reproduction\r\n                global.sheepPrice = 100 finney;\r\n                sheepPrice = 100 finney;\r\n            } else {\r\n                // determine the next price\r\n                determineForwardSheepPrice(global.priceInterval[0]);\r\n                sheepPrice = global.sheepPrice;\r\n            }\r\n        }\r\n\r\n        // reproduce\r\n        if (sheepPrice > 99 finney) {\r\n            reproductionStage();\r\n            return;\r\n        }\r\n\r\n        // determine the price interval\r\n        determinePriceInterval(sheepPrice);\r\n    }\r\n\r\n    /* reproduce */\r\n    function reproductionStage() private {\r\n        // double the sheep & renew the price interval\r\n        global.sheepNum = global.sheepNum.mul(2);\r\n        global.sysInSaleNum = global.sysInSaleNum.mul(2);\r\n        global.sheepPrice = 50 finney;\r\n        global.sysSoldNum = 0;\r\n        priceCumulativeCount = 56 finney;\r\n        isFleshUp = false;\r\n\r\n        uint addSheepNum = global.sysInSaleNum.div(50);\r\n        uint j = 1;\r\n\r\n        global.priceInterval[0] = 50 finney;\r\n\r\n        for (uint i = 51 finney; i <= 98 finney; i=i.add(1 finney)) { //99 price just sold out\r\n            // double the remaining sheep on the price in range of 51 ~ 98\r\n            // 50 price has setup before the reproduction\r\n            if (sysPriceSheepNum[i] > 0) sysPriceSheepNum[i] = sysPriceSheepNum[i].mul(2);\r\n            if (usrPriceSheepNum[i] > 0) usrPriceSheepNum[i] = usrPriceSheepNum[i].mul(2);\r\n            // renew the price interval\r\n            if (j <= 6) {\r\n                sysPriceSheepNum[i] = sysPriceSheepNum[i].add(addSheepNum);\r\n                global.priceInterval[j] = i;\r\n                j++;\r\n            }\r\n        }\r\n\r\n        cryptoRanch.addReproductionRound();\r\n        reproductionBlkNums.push(block.number);\r\n\r\n        emit OnPriceChange(global.sheepPrice, now);\r\n    }\r\n\r\n    function getEstimatedPrice(uint sheepNum) external view returns(uint){\r\n        uint balance = 0;\r\n        uint tmpPrice = global.sheepPrice;\r\n        uint tmpNum = sheepNum;\r\n        uint tmpFleshUpCount = fleshUpCount;\r\n        bool jumpPrice = isFleshUp;\r\n\r\n        while(tmpNum > 0) {\r\n            // system order can afford the demand\r\n            if (sysPriceSheepNum[tmpPrice] >= tmpNum || tmpPrice > global.priceInterval[6]) {\r\n                balance = balance.add(tmpNum.mul(tmpPrice));\r\n                tmpNum = 0;\r\n                break;\r\n            } else {\r\n                balance = balance.add(sysPriceSheepNum[tmpPrice].mul(tmpPrice));\r\n                tmpNum = tmpNum.sub(sysPriceSheepNum[tmpPrice]);\r\n                //user order can afford the demand\r\n                if (usrPriceSheepNum[tmpPrice] > tmpNum) {\r\n                    balance = balance.add(tmpNum.mul(tmpPrice));\r\n                    tmpNum = 0;\r\n                    break;\r\n                } else {\r\n                    balance = balance.add(usrPriceSheepNum[tmpPrice].mul(tmpPrice));\r\n                    tmpNum = tmpNum.sub(usrPriceSheepNum[tmpPrice]);\r\n                }\r\n            }\r\n\r\n            /*   price rise  */\r\n            // on \"Growing\" stage or trigger the \"Growing\"\r\n            if (jumpPrice == true || global.sysSoldNum.add(sheepNum.sub(tmpNum)).mul(50)>= global.sheepNum) {\r\n                if (jumpPrice == false) {\r\n                    tmpFleshUpCount = 0;\r\n                }\r\n                for (uint i = global.priceInterval[0]; i < global.priceInterval[6] && jumpPrice == false; i = i.add(1 finney) ){\r\n                    tmpFleshUpCount = tmpFleshUpCount.add(sysPriceSheepNum[i]).add(usrPriceSheepNum[i]);\r\n                }\r\n                jumpPrice = true;\r\n                // end of \"Growing\", price jump\r\n                if(tmpPrice >= global.priceInterval[6]) {\r\n                    jumpPrice = false;\r\n                    if (tmpPrice == 99 finney) {\r\n                        tmpPrice = 100 finney;\r\n                    } else {\r\n                        tmpPrice = tmpPrice.add(tmpFleshUpCount.mul(100).div(global.sheepNum).mul(1 finney));\r\n                        if (tmpFleshUpCount.mul(100) % global.sheepNum != 0) {\r\n                            tmpPrice = tmpPrice.add(1 finney);\r\n                        }\r\n                        if (tmpPrice > 99 finney) {\r\n                            tmpPrice = 101 finney;\r\n                        }\r\n                    }\r\n                    // price rise\r\n                } else {\r\n                    tmpPrice = tmpPrice.add(1 finney);\r\n                }\r\n                // general price rise\r\n            } else {\r\n                if (tmpPrice == 99 finney) {\r\n                    tmpPrice = 100 finney;\r\n                } else {\r\n                    tmpPrice = tmpPrice.add(1 finney);\r\n                    for(uint i = tmpPrice; i < 100 finney; i = i.add(1 finney)){\r\n                        if (sysPriceSheepNum[i] > 0 || usrPriceSheepNum[i] > 0) {\r\n                            tmpPrice = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        balance = balance.mul(110).div(100);\r\n\r\n        return balance;\r\n    }\r\n\r\n    //show to view-tier\r\n\r\n    function showGlobalData() public view returns(uint, uint, uint, uint, uint, bool) {\r\n        return (\r\n        global.sheepNum,\r\n        global.sheepPrice,\r\n        global.sysSoldNum,\r\n        global.sysInSaleNum,\r\n        fleshUpCount,\r\n        isFleshUp\r\n        );\r\n    }\r\n\r\n    function showAvailablePriceInterval() public view returns(uint[7] memory) {\r\n        return global.priceInterval;\r\n    }\r\n\r\n    function showSheepNumOfPriceInterval() public view returns(uint[7] memory) {\r\n        uint[7] memory tmpSheepNumInterval;\r\n        for (uint i = 0; i < 7; i++) {\r\n            uint tmpPrice = global.priceInterval[i];\r\n            if (tmpPrice == 100 finney) {\r\n                tmpSheepNumInterval[i] = (sysPriceSheepNum[50 finney].add(usrPriceSheepNum[50 finney]))/2;\r\n            } else {\r\n                tmpSheepNumInterval[i] = sysPriceSheepNum[tmpPrice].add(usrPriceSheepNum[tmpPrice]);\r\n            }\r\n        }\r\n        return tmpSheepNumInterval;\r\n    }\r\n\r\n    function hasOrderInSale(uint sellerID) public view returns(bool) {\r\n        if (sellOrders.length > 0) {\r\n            return  sellOrders[orderIDByPID[sellerID]].ownerID == sellerID;//error first order id = 0\r\n        } else return false;\r\n    }\r\n\r\n    function showOrderDetails(uint sellerID) public view returns(uint, uint, uint) {\r\n        require(sellerID > 0 && sellOrders.length > 0 && sellOrders[orderIDByPID[sellerID]].ownerID == sellerID, 'no order');\r\n        uint orderID = orderIDByPID[sellerID];\r\n\r\n        return(\r\n        sellOrders[orderID].sheepNum,\r\n        sellOrders[orderID].sheepPrice,\r\n        sellOrders[orderID].round\r\n        );\r\n    }\r\n\r\n    function getReproductionBlkNums() external view returns (uint[] memory){\r\n        return reproductionBlkNums;\r\n    }\r\n}\r\n\r\ncontract CryptoRanch is Ownable, Pausable {\r\n    using SafeMath for uint;\r\n\r\n    //mark the current status of a player\r\n    enum PlayerStatus { NOT_JOINED, NORMAL, OVERLOADED }\r\n\r\n    uint[9] public ranchInitSheepNumList = [0,1,5,10,30,50,100,150,200];\r\n\r\n    uint constant public BONUS_TIMEOUT_FINAL = 33200;\r\n    uint constant public BONUS_TIMEOUT_WEEK = 46500;\r\n\r\n    event OnFirstGenerationJoinGame(address indexed player, uint sheepNum, uint value,uint timestamp);\r\n    event OnJoinGame(address indexed newPlayer, uint sheepNum, uint totalPrice, address inviter, uint timestamp);\r\n    event OnRanchSizeIncrease(address indexed buyer, uint sheepNum, uint value, uint timestamp);\r\n    event OnReBuy(address indexed buyer, uint sheepNum, uint value, uint timestamp);\r\n    event OnBuyOrderRefund(address indexed refunder, uint refundValue, uint timestamp);\r\n    event OnSellerProcessProfit(address indexed seller, uint totalValue, uint timestamp);\r\n    event OnAddSheepNumber(address indexed buyer, uint successBuyNum, uint totalCost, uint timestamp);\r\n    event OnCommissionDistribute(address indexed player, uint forageFee, address[] ancestorList, uint bonusPot, uint timestamp);\r\n\r\n    event OnWeekBonus(address indexed player, uint bonus, uint timestamp);\r\n    event OnFinalBonus(address indexed player, uint bonus, uint timestamp);\r\n\r\n    event OnWithdrawProfit(address indexed player, uint profit, uint bonus, uint timestamp);\r\n    event OnWithdrawOwnerProfit(address indexed owner, uint profit);\r\n\r\n    // player data-structure\r\n    struct Player {\r\n        address payable addr;\r\n        //pricing data\r\n        uint admissionPrice;\r\n        uint accumulatedProfits;\r\n        uint maxProfitability;    //ranch max production capacity\r\n        uint referralBonus;\r\n        uint profit;\r\n        uint rebuy;\r\n        // ranch data of the player\r\n        uint ranchSize;\r\n        uint ranchGrade;\r\n        uint sheepNum;\r\n        // status of player\r\n        PlayerStatus status;\r\n        // reproduction round\r\n        uint round;\r\n        // weekly data\r\n        uint weekSheepCount;\r\n        uint weekRound;\r\n        // restrict the multiply buy\r\n        uint joinRound;\r\n        // is first generation\r\n        bool isFirstGeneration;\r\n    }\r\n\r\n    // bonus pool data-structure\r\n    struct BonusPot {\r\n        uint totalAmount;\r\n        uint weekBlock;\r\n        uint finalBlock;\r\n        address payable weekWinner;\r\n        address payable finalWinner;\r\n    }\r\n\r\n    BonusPot bonusPot;\r\n\r\n    //outer contracts\r\n    Ranch ranch;\r\n    Commission commission;\r\n    TransactionSystem txSystem;\r\n    address payable public ranchAddress;\r\n    address payable public commissionAddress;\r\n    address payable public txSysAddress;\r\n\r\n    // global player id number\r\n    uint pID_ = 0;\r\n\r\n    uint reproductionRound;\r\n    uint globalWeekRound;\r\n\r\n    uint ghostProfit;\r\n\r\n    uint [3] private weekRank; //0 < 1 < 2\r\n\r\n    // game books data-structure\r\n    mapping(uint => Player) usrBook;           // pID => Player\r\n    mapping(address => uint) pIDByAddr;        // address => pID\r\n    mapping(uint => uint) usrLastTotalCost;    // pID => last investment\r\n    mapping(address => bool) whiteList;\r\n\r\n    // check that the number of sheep is in valid range.\r\n    modifier isValidSheepNum (uint sheepNum) {\r\n        require(\r\n            sheepNum == ranchInitSheepNumList[0] ||\r\n            sheepNum == ranchInitSheepNumList[1] ||\r\n            sheepNum == ranchInitSheepNumList[2] ||\r\n            sheepNum == ranchInitSheepNumList[3] ||\r\n            sheepNum == ranchInitSheepNumList[4] ||\r\n            sheepNum == ranchInitSheepNumList[5] ||\r\n            sheepNum == ranchInitSheepNumList[6] ||\r\n            sheepNum == ranchInitSheepNumList[7] ||\r\n            sheepNum == ranchInitSheepNumList[8] ,\r\n            \"Invalid Sheep number!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // only transaction system can call\r\n    modifier onlyForTxSystem() {\r\n        require(txSysAddress == msg.sender, \"Only for TransactionSystem contract!\");\r\n        _;\r\n    }\r\n\r\n    // player joined and not exceeding can call\r\n    modifier playerIsAlive() {\r\n        require(pIDByAddr[msg.sender]!= 0 && usrBook[pIDByAddr[msg.sender]].status == PlayerStatus.NORMAL, \"Exceed or not Join!\");\r\n        _;\r\n    }\r\n\r\n    // contract address is not allowed\r\n    modifier isHuman() {\r\n        address addr = msg.sender;\r\n        uint256 codeLength;\r\n        assembly {codeLength := extcodesize(addr)}\r\n\r\n        require(codeLength == 0, \"Addresses not owned by human are forbidden\");\r\n        require(tx.origin == addr, \"Called by contract\");\r\n        _;\r\n    }\r\n\r\n    function() payable external { owner.transfer(msg.value); }\r\n\r\n    constructor() public payable{\r\n        reproductionRound = 1;\r\n        ghostProfit = 0;\r\n        globalWeekRound = 1;\r\n        bonusPot = BonusPot(0, block.number, block.number, address(0), address(0));\r\n        whiteList[owner] = true;\r\n        whiteList[0xF3827f73D18C80CEFdBc6d38946aB928F4AdbDe9] = true;\r\n    }\r\n\r\n    // owner function, link to the ranch contract\r\n    function setRanchAddress(address payable ranchAddr) public onlyOwner(){\r\n        ranchAddress = ranchAddr;\r\n        ranch = Ranch(ranchAddr);\r\n    }\r\n    // owner function, link to the commission contract\r\n    function setCommissionAddress(address payable commissionAddr) public onlyOwner(){\r\n        commissionAddress = commissionAddr;\r\n        commission = Commission(commissionAddr);\r\n    }\r\n    // owner function, link to the transaction system contract\r\n    function setTransactionSystemAddress(address payable txSysAddr) public onlyOwner(){\r\n        txSysAddress = txSysAddr;\r\n        txSystem = TransactionSystem(txSysAddr);\r\n    }\r\n\r\n\r\n    function setWhiteList(address player, bool val) external onlyOwner(){\r\n        whiteList[player] = val;\r\n    }\r\n\r\n    function getWhiteList() external view returns(bool){\r\n        return whiteList[msg.sender];\r\n    }\r\n\r\n\r\n    // a function that allows owner to add\r\n    function firstGenerationJoinGame(uint sheepNum) payable public isHuman() isValidSheepNum(sheepNum){\r\n        require(whiteList[msg.sender] == true, 'Invalid user');\r\n        require(pIDByAddr[msg.sender] == 0, 'Player has joined!');\r\n\r\n        uint buyerID = makePlayerID(msg.sender);\r\n        uint balance = msg.value;\r\n\r\n        usrBook[buyerID].isFirstGeneration = true;\r\n        emit OnFirstGenerationJoinGame(msg.sender, sheepNum, balance, now);\r\n\r\n        initRanchData(buyerID, sheepNum);\r\n\r\n        txSystem.buySheepFromOrders(buyerID, balance, sheepNum, false);\r\n        initSalesData(buyerID, usrLastTotalCost[buyerID]);\r\n    }\r\n\r\n    // player join the game by the ranch plan at first time\r\n    function joinGame(uint sheepNum, address payable inviter) payable public isHuman() isValidSheepNum(sheepNum){\r\n        require(pIDByAddr[msg.sender] == 0, 'Player has joined!');\r\n        uint inviterID = pIDByAddr[inviter];\r\n        require(inviterID != 0, \"No such Inviter!\");\r\n\r\n        uint buyerID = makePlayerID(msg.sender);\r\n        uint value = msg.value;\r\n        uint balance = value.div(2);\r\n        usrBook[buyerID].isFirstGeneration = false;\r\n\r\n        //add the buyer to the 1st line of franchisees of inviter\r\n        commission.joinGame(buyerID, inviterID);\r\n        emit OnJoinGame(msg.sender, sheepNum, value, inviter, now);\r\n\r\n        initRanchData(buyerID, sheepNum);\r\n\r\n        // reset the consultant ranch data, only valid before the ranch is overload.\r\n        bool inviterIsAlive = false;\r\n        if (usrBook[inviterID].status == PlayerStatus.NORMAL) inviterIsAlive = true;\r\n        usrBook[inviterID].ranchSize = commission.inviteNewUser(inviterID, usrBook[inviterID].ranchSize, inviterIsAlive, buyerID, usrBook[buyerID].ranchGrade);\r\n        if (inviterIsAlive){\r\n            usrBook[inviterID].maxProfitability = usrBook[inviterID].ranchSize.mul(usrBook[inviterID].admissionPrice);\r\n        }\r\n\r\n        // renew the inviter weekly data\r\n        if (usrBook[inviterID].weekRound != globalWeekRound) {\r\n            usrBook[inviterID].weekRound = globalWeekRound;\r\n            usrBook[inviterID].weekSheepCount = 0;\r\n        }\r\n\r\n        // refresh the enrolled sheep num of inviter and sort week rank list\r\n        if (sheepNum > 0) {\r\n            reorderWeekRank(inviterID, sheepNum);\r\n        }\r\n\r\n        // purchase sheep from orders\r\n        txSystem.buySheepFromOrders(buyerID, balance, sheepNum, false);\r\n        // refresh the pricing data\r\n        initSalesData(buyerID, usrLastTotalCost[buyerID]);\r\n    }\r\n\r\n    // upgrade the ranch size, need to lager than current size\r\n    function improveRanchSizeFromWallet(uint sheepNum) payable public isHuman() playerIsAlive() isValidSheepNum(sheepNum) {\r\n        uint buyerID = pIDByAddr[msg.sender];\r\n        uint value = msg.value;\r\n\r\n        uint balance = usrBook[buyerID].isFirstGeneration? value : value.div(2);\r\n\r\n        require( usrBook[buyerID].ranchGrade <= 8 && usrBook[buyerID].ranchGrade >= 0, \"Invalid ranch grade!\");\r\n        require( ranch.getRanchGrade(sheepNum) >= usrBook[buyerID].ranchGrade, \"Should buy more sheep to upgrade!\" );\r\n\r\n        uint preRanchSize = usrBook[buyerID].ranchSize;\r\n        // upgrade\r\n        if (usrBook[buyerID].ranchGrade < 8 && usrBook[buyerID].ranchGrade > 0) {\r\n            txSystem.buySheepFromOrders( buyerID, balance, sheepNum, false);\r\n            (usrBook[buyerID].ranchGrade, usrBook[buyerID].ranchSize, usrBook[buyerID].admissionPrice, usrBook[buyerID].maxProfitability) = ranch.ranch(usrLastTotalCost[buyerID], sheepNum);\r\n            // multiply buy\r\n        } else if (usrBook[buyerID].ranchGrade == 8 && usrBook[buyerID].joinRound == reproductionRound) {\r\n            txSystem.buySheepFromOrders( buyerID, balance, sheepNum, false);\r\n            (usrBook[buyerID].admissionPrice, usrBook[buyerID].maxProfitability) = ranch.multipleBuy(usrLastTotalCost[buyerID], usrBook[buyerID].admissionPrice, usrBook[buyerID].maxProfitability);\r\n\r\n            if (usrBook[buyerID].isFirstGeneration == false) {\r\n                uint inviterID = commission.getMotherGeneration(buyerID);\r\n                // renew the inviter weekly data\r\n                if (usrBook[inviterID].weekRound != globalWeekRound) {\r\n                    usrBook[inviterID].weekRound = globalWeekRound;\r\n                    usrBook[inviterID].weekSheepCount = 0;\r\n                }\r\n                // refresh the enrolled sheep num and sort rank list\r\n                reorderWeekRank(inviterID, sheepNum);\r\n            }\r\n        } else {\r\n            revert(\"out of join round\");\r\n        }\r\n\r\n        if (usrBook[buyerID].ranchSize <= preRanchSize) {\r\n            usrBook[buyerID].ranchSize = preRanchSize;\r\n            usrBook[buyerID].maxProfitability = usrBook[buyerID].ranchSize.mul(usrBook[buyerID].admissionPrice);\r\n        }\r\n\r\n        emit OnRanchSizeIncrease(usrBook[buyerID].addr, sheepNum, balance, now);\r\n    }\r\n\r\n    // player purchase sheep via the operating capital\r\n    function rebuyForSheep(uint sheepNum, uint value) isHuman() playerIsAlive() public{\r\n        uint buyerID = pIDByAddr[msg.sender];\r\n        require(usrBook[buyerID].rebuy >= value, \"Invalid rebuy value!\");\r\n\r\n        uint balance = usrBook[buyerID].isFirstGeneration? value : value.div(2);\r\n\r\n        txSystem.buySheepFromOrders(buyerID, balance, sheepNum, true);\r\n        uint actualRebuy = usrBook[buyerID].isFirstGeneration? usrLastTotalCost[buyerID] : usrLastTotalCost[buyerID].mul(2);\r\n        usrBook[buyerID].rebuy = usrBook[buyerID].rebuy.sub(actualRebuy);\r\n\r\n        emit OnReBuy(usrBook[buyerID].addr, sheepNum, actualRebuy, now);\r\n    }\r\n\r\n    // Add new sale order to the contract\r\n    function addNewSellOrder(uint sheepNum,  uint sheepPrice) isHuman() playerIsAlive() public {\r\n        uint sellerID = pIDByAddr[msg.sender];\r\n        require(sheepNum > 0, \"Not allow zero sheep number\");\r\n        require(sheepPrice % (1 finney) == 0, \"Illegal price\");\r\n        // normalize the sheep number of seller\r\n        normalizeSheepNum(sellerID);\r\n\r\n        //the max sheep of order can't exceed the 10% global sheep\r\n        uint quo = usrBook[sellerID].sheepNum.div(10);\r\n        uint rem = usrBook[sellerID].sheepNum % 10;\r\n        if (rem > 0) quo = quo.add(1);\r\n        require(usrBook[sellerID].sheepNum >= sheepNum && sheepNum <= quo, \"Unmatched available sell sheep number!\");\r\n\r\n        // the accumulated profit can't exceed the max production capacity of ranch\r\n        require(usrBook[sellerID].accumulatedProfits.add(sheepNum.mul(sheepPrice)) <= usrBook[sellerID].maxProfitability.div(1000),\r\n            \"exceed number to sale\");\r\n\r\n        // new sell-order process\r\n        txSystem.addNewSellOrder(sellerID, sheepNum, sheepPrice);\r\n    }\r\n\r\n    // cancel sell order\r\n    function cancelSellOrder() isHuman() playerIsAlive() public {\r\n        uint sellerID = pIDByAddr[msg.sender];\r\n        txSystem.cancelSellOrder(sellerID);\r\n    }\r\n\r\n    // player base ranch data setup\r\n    function initRanchData(uint pID, uint sheepNum) internal{\r\n        usrBook[pID].ranchGrade = ranch.getRanchGrade(sheepNum);\r\n        usrBook[pID].ranchSize = ranch.getRanchSize(usrBook[pID].ranchGrade);\r\n        // grade 0 is invalid for upgrade\r\n        if(usrBook[pID].ranchSize == 0) {\r\n            usrBook[pID].status = PlayerStatus.OVERLOADED;\r\n        } else {\r\n            usrBook[pID].status = PlayerStatus.NORMAL;\r\n        }\r\n        usrBook[pID].weekRound = globalWeekRound;\r\n        usrBook[pID].weekSheepCount = 0;\r\n        usrBook[pID].round = reproductionRound;\r\n        usrBook[pID].joinRound = reproductionRound;\r\n        usrBook[pID].profit = 0;\r\n    }\r\n\r\n    // player price data initialization\r\n    function initSalesData(uint pID, uint totalSheepPrice) private {\r\n        usrBook[pID].accumulatedProfits = 0;\r\n        usrBook[pID].admissionPrice = ranch.getAdmissionPrice(totalSheepPrice);\r\n        usrBook[pID].maxProfitability = ranch.getMaxProfitability(usrBook[pID].ranchGrade, usrBook[pID].admissionPrice);\r\n        usrBook[pID].referralBonus = 0;\r\n        usrBook[pID].rebuy = 0;\r\n    }\r\n\r\n    //renew the week rank data and sort list\r\n    function reorderWeekRank(uint pID, uint sheepNum) private {\r\n        // renew the enrolled number\r\n        usrBook[pID].weekSheepCount = usrBook[pID].weekSheepCount.add(sheepNum);\r\n\r\n        bool tmpJudge = false;\r\n        int index = -1;\r\n        for(uint i = 0; i < 3; i ++) {\r\n            if (usrBook[pID].weekSheepCount > usrBook[weekRank[i]].weekSheepCount) {\r\n                index = int(i); // record the biggest rank-index of less count\r\n                if (tmpJudge) {\r\n                    uint tmpID = weekRank[i];\r\n                    weekRank[i] = pID;\r\n                    weekRank[i-1] = tmpID;\r\n                }\r\n            }\r\n            if (pID == weekRank[i]) tmpJudge = true; // check whether already on list\r\n        }\r\n\r\n        if (tmpJudge == false) {\r\n            for(uint i = 0; int(i) <= index; i++) {\r\n                uint tmpID = weekRank[i];\r\n                weekRank[i] = pID;\r\n                if (i != 0) weekRank[i-1] = tmpID;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Add sheep number of buyer (called from transaction system)\r\n    function addSheepNumber(uint pID, uint sheepNum, uint totalCost, bool isBuy) external onlyForTxSystem(){\r\n        // normalize sheep number,\r\n        normalizeSheepNum(pID);\r\n\r\n        usrBook[pID].sheepNum = usrBook[pID].sheepNum.add(sheepNum);\r\n        usrLastTotalCost[pID] = totalCost;\r\n        emit OnAddSheepNumber(usrBook[pID].addr, sheepNum, totalCost, now);\r\n\r\n        // if it's a cancel order or buy\r\n        if(isBuy && usrBook[pID].isFirstGeneration == false) {\r\n            // distribute commission\r\n            distributeCommission(pID, totalCost);\r\n        }\r\n    }\r\n\r\n    // revenue setting, including 60% profit and 40% operating capital\r\n    function processSellerProfit(uint pID, uint revenue) external onlyForTxSystem(){\r\n        if (pID == 0) {\r\n            ghostProfit = ghostProfit.add(revenue);\r\n            emit OnSellerProcessProfit(address(this), revenue, now);\r\n        } else {\r\n            emit OnSellerProcessProfit(usrBook[pID].addr, revenue, now);\r\n            // preprocess to determine whether overload\r\n            addAccumulatedValue(pID, revenue);\r\n            // sales profit\r\n            uint tmpProfit = revenue.mul(60).div(100);\r\n            usrBook[pID].profit = usrBook[pID].profit.add(tmpProfit);\r\n\r\n            // operating capital\r\n            uint tmpRebuy = revenue.sub(tmpProfit);\r\n            if (usrBook[pID].status == PlayerStatus.NORMAL) {\r\n                usrBook[pID].rebuy = usrBook[pID].rebuy.add(tmpRebuy);\r\n            } else {\r\n                ghostProfit = ghostProfit.add(tmpRebuy);\r\n            }\r\n        }\r\n    }\r\n\r\n    // distribute commission\r\n    uint[9] gradeToCommission = [100,400,400,500,500,600,600,700,700];\r\n    function distributeCommission(uint pID, uint forageFee) private{\r\n        uint ghostCommission = forageFee;\r\n        uint guideFee = forageFee.div(50);// 1% of the total price\r\n        uint joinFee;\r\n        uint ancestorID;\r\n\r\n        uint[] memory ancestorList = commission.getAncestorList(pID);\r\n        address[] memory ancestorAddrList = new address[](ancestorList.length);\r\n\r\n        for (uint i = 0; i < ancestorList.length; i++) {\r\n            ancestorID = ancestorList[i];\r\n            ancestorAddrList[i] = usrBook[ancestorID].addr;\r\n            if (i == 0) {\r\n                // 1st franchisees -> franchises Fee\r\n                joinFee = forageFee.mul(gradeToCommission[usrBook[ancestorID].ranchGrade]).div(1000);\r\n                ghostCommission = ghostCommission.sub(joinFee);\r\n                // add to the consultant's profit\r\n                dealCommissionRevenue(ancestorID, joinFee);\r\n            } else {\r\n                // 2~10th franchisees ->  guidance fee\r\n                ghostCommission = ghostCommission.sub(guideFee);\r\n                // add to the consultant's profit\r\n                dealCommissionRevenue(ancestorID, guideFee);\r\n            }\r\n        }\r\n\r\n        // 1% of the total price to the bonus pool\r\n        uint poolCommission = forageFee.mul(20).div(1000);\r\n        ghostCommission = ghostCommission.sub(poolCommission);\r\n        ghostProfit = ghostProfit.add(ghostCommission);\r\n        // add to the bonus pool\r\n        bonusPot.totalAmount = bonusPot.totalAmount.add(poolCommission);\r\n\r\n        // update bonus pool time\r\n        if( checkWeekBlock()) {\r\n            uint weekBonus = bonusPot.totalAmount.div(10);\r\n            bonusPot.totalAmount = bonusPot.totalAmount.sub(weekBonus);\r\n            bonusPot.weekWinner = usrBook[weekRank[2]].addr;\r\n            bonusPot.weekWinner.transfer(weekBonus);\r\n\r\n            resetWeekData();\r\n\r\n            emit OnWeekBonus(bonusPot.weekWinner, weekBonus, now);\r\n        }\r\n\r\n        if(checkFinalBlock()){\r\n            uint finalBonus = bonusPot.totalAmount;\r\n            bonusPot.totalAmount = 0;\r\n            bonusPot.finalWinner = usrBook[pID].addr;\r\n            bonusPot.finalWinner.transfer(finalBonus);\r\n\r\n            emit OnFinalBonus(usrBook[pID].addr, finalBonus, now);\r\n        }\r\n\r\n        emit OnCommissionDistribute(usrBook[pID].addr, forageFee, ancestorAddrList, bonusPot.totalAmount, now);\r\n    }\r\n\r\n    function normalizeSheepNum(uint pID) internal{ // not export to another contract directly,but inside the exported func processing\r\n        if (reproductionRound != usrBook[pID].round) {\r\n            usrBook[pID].sheepNum = usrBook[pID].sheepNum.mul(2**(reproductionRound.sub(usrBook[pID].round)));\r\n            usrBook[pID].round =  reproductionRound;\r\n        }\r\n    }\r\n\r\n    // add revenue to accumulated profit, determine whether the ranch is overload\r\n    function addAccumulatedValue(uint pID, uint revenue) private{\r\n        //for test\r\n        //emit OnSellerProcessProfit(usrBook[pID].addr, revenue, now);\r\n\r\n        usrBook[pID].accumulatedProfits = usrBook[pID].accumulatedProfits.add(revenue);\r\n        if (usrBook[pID].status != PlayerStatus.OVERLOADED && usrBook[pID].accumulatedProfits >= usrBook[pID].maxProfitability.div(1000)) {\r\n            usrBook[pID].status = PlayerStatus.OVERLOADED;\r\n\r\n            txSystem.burnSheepGlobal(usrBook[pID].sheepNum);\r\n\r\n            ghostProfit = ghostProfit.add(usrBook[pID].rebuy);\r\n            usrBook[pID].rebuy = 0;\r\n        }\r\n    }\r\n\r\n    function dealCommissionRevenue(uint pID, uint revenue) private {\r\n        // normalize sheep number, add to the accumulated profit\r\n        addAccumulatedValue(pID, revenue);\r\n        // 60% sales profit\r\n        uint commissionBonus = revenue.mul(6).div(10);\r\n        // 40% operating capital\r\n        uint rebuy = revenue.sub(commissionBonus);\r\n        usrBook[pID].referralBonus = usrBook[pID].referralBonus.add(commissionBonus);\r\n        if (usrBook[pID].status == PlayerStatus.OVERLOADED) {\r\n            ghostProfit = ghostProfit.add(rebuy);\r\n        } else {\r\n            usrBook[pID].rebuy = usrBook[pID].rebuy.add(rebuy);\r\n        }\r\n    }\r\n\r\n    /* @dev get week bonus condition when there's no user amoung this week */\r\n    function checkFinalBlock () internal returns(bool) {\r\n        uint preFinalBlock = bonusPot.finalBlock;\r\n        bonusPot.finalBlock = block.number;\r\n\r\n        if (bonusPot.finalBlock.sub(preFinalBlock) > BONUS_TIMEOUT_FINAL)\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    /* @dev get week bonus condition */\r\n    function checkWeekBlock () internal returns(bool) {\r\n        uint preWeekBlock = bonusPot.weekBlock;\r\n        uint nowBlock = block.number;\r\n\r\n        if (nowBlock.sub(preWeekBlock) > BONUS_TIMEOUT_WEEK)  {\r\n            bonusPot.weekBlock = nowBlock;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function resetWeekData() internal {\r\n        globalWeekRound = globalWeekRound.add(1);\r\n        delete weekRank;//notice\r\n    }\r\n\r\n    function getReproductionRound() external view returns(uint) {\r\n        return reproductionRound;\r\n    }\r\n\r\n    function addReproductionRound() external {\r\n        reproductionRound = reproductionRound.add(1);\r\n    }\r\n\r\n    function minusSheepNum (uint pID, uint sheepNum) external onlyForTxSystem(){\r\n        usrBook[pID].sheepNum = usrBook[pID].sheepNum.sub(sheepNum);\r\n    }\r\n\r\n    function buyOrderRefund (uint buyerID, uint refundValue) external onlyForTxSystem(){\r\n        uint tmpRefundValue = refundValue;\r\n        if(usrBook[buyerID].isFirstGeneration == false) tmpRefundValue = tmpRefundValue.mul(2);\r\n\r\n        emit OnBuyOrderRefund(usrBook[buyerID].addr, refundValue, now);\r\n\r\n        usrBook[buyerID].addr.transfer(tmpRefundValue);\r\n    }\r\n\r\n    //gets register a new pID.  use this when a player may be new\r\n    function makePlayerID(address payable player) private returns(uint) {\r\n        require(pIDByAddr[player] == 0, 'Player has joined!');\r\n        // set up player account\r\n        pID_ ++;\r\n        pIDByAddr[player] = pID_;\r\n        usrBook[pID_].addr = player;\r\n\r\n        return pID_;\r\n    }\r\n\r\n    function getWeekRankData() public view returns(address[] memory, uint[] memory, uint[] memory){\r\n        address[] memory playerList = new address[](3);\r\n        uint [] memory ranchGradeList = new uint[](3);\r\n        uint [] memory sheepCountList = new uint[](3);\r\n\r\n        for (uint i = 0; i < 3; i++) {\r\n            playerList[i] = usrBook[weekRank[i]].addr;\r\n            ranchGradeList[i] = usrBook[weekRank[i]].ranchGrade;\r\n            sheepCountList[i] = usrBook[weekRank[i]].weekSheepCount;\r\n        }\r\n\r\n        return (\r\n        playerList,\r\n        ranchGradeList,\r\n        sheepCountList\r\n        );\r\n    }\r\n\r\n    function getBonusPotData() public view returns(uint, uint, uint, address, address, uint, uint) {\r\n        return (\r\n        bonusPot.totalAmount,\r\n        bonusPot.weekBlock,\r\n        bonusPot.finalBlock,\r\n        bonusPot.weekWinner,\r\n        bonusPot.finalWinner,\r\n        usrBook[pIDByAddr[bonusPot.weekWinner]].ranchGrade,\r\n        usrBook[pIDByAddr[bonusPot.finalWinner]].ranchGrade\r\n        );\r\n    }\r\n\r\n    function showPlayerInfo()\r\n    public view\r\n    returns(uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n        uint pID = pIDByAddr[msg.sender];\r\n        return (\r\n        pID,\r\n        usrBook[pID].sheepNum.mul(2**(reproductionRound.sub(usrBook[pID].round))),\r\n        usrBook[pID].ranchSize,\r\n        usrBook[pID].ranchGrade,\r\n        usrBook[pID].accumulatedProfits,\r\n        usrBook[pID].maxProfitability,\r\n        usrBook[pID].admissionPrice,\r\n        usrBook[pID].round,\r\n        usrBook[pID].joinRound,\r\n        usrBook[pID].weekRound,\r\n        usrBook[pID].weekSheepCount,\r\n        usrBook[pID].referralBonus,\r\n        usrBook[pID].profit,\r\n        usrBook[pID].rebuy\r\n        );\r\n    }\r\n\r\n    function getPlayerStatus() public view returns(PlayerStatus, bool) {\r\n        uint pID = pIDByAddr[msg.sender];\r\n        return(usrBook[pID].status, usrBook[pID].status == PlayerStatus.OVERLOADED);\r\n    }\r\n\r\n    function getPIDByAddress(address payable addr) external view returns (uint) {\r\n        return pIDByAddr[addr]; // notice-first generation\r\n    }\r\n\r\n    function getAddrByPID(uint pID) external view returns(address) {\r\n        return usrBook[pID].addr;\r\n    }\r\n\r\n    function getUsrCount() external view returns(uint) {\r\n        return pID_;\r\n    }\r\n\r\n    function getAncestorList() external view returns(address[] memory, uint[] memory) {\r\n        uint pID = pIDByAddr[msg.sender];\r\n        require(pID > 0 && usrBook[pID].isFirstGeneration == false, 'You have no ancestor!');\r\n        uint[] memory ancestorList = commission.getAncestorList(pID);\r\n        address[] memory ancestorAddrList = new address[](ancestorList.length);\r\n        uint[] memory ancestorGradeList = new uint[](ancestorList.length);\r\n        for (uint i = 0; i < ancestorList.length; i++) {\r\n            ancestorAddrList[i] = usrBook[ancestorList[i]].addr;\r\n            ancestorGradeList[i] = usrBook[ancestorList[i]].ranchGrade;\r\n        }\r\n        return (ancestorAddrList, ancestorGradeList);\r\n    }\r\n\r\n    function getInviteesList() external view returns(address[] memory, uint[] memory) {\r\n        uint pID = pIDByAddr[msg.sender];\r\n        require(pID > 0, \"You didn't join!\");\r\n        uint[] memory inviteesList = commission.getInviteesList(pID);\r\n        address[] memory inviteesAddrList = new address[](inviteesList.length);\r\n        uint[] memory inviteesGradeList = new uint[](inviteesList.length);\r\n        for (uint i = 0; i < inviteesList.length; i++) {\r\n            inviteesAddrList[i] = usrBook[inviteesList[i]].addr;\r\n            inviteesGradeList[i] = usrBook[inviteesList[i]].ranchGrade;\r\n        }\r\n        return (inviteesAddrList, inviteesGradeList);\r\n    }\r\n\r\n    function getGhostProfit() public view returns(uint){\r\n        return ghostProfit;\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint pID = pIDByAddr[msg.sender];\r\n        require(pID != 0, 'No such player!');\r\n\r\n        uint tmpProfit = usrBook[pID].profit;\r\n        usrBook[pID].profit = 0;\r\n        uint tmpBonus = usrBook[pID].referralBonus;\r\n        usrBook[pID].referralBonus = 0;\r\n\r\n        usrBook[pID].addr.transfer(tmpProfit);\r\n        usrBook[pID].addr.transfer(tmpBonus);\r\n\r\n        emit OnWithdrawProfit(usrBook[pID].addr, tmpProfit, tmpBonus, now);\r\n    }\r\n\r\n    function withdrawOwnerProfit() public onlyOwner{\r\n        uint tmpProfit = ghostProfit;\r\n        ghostProfit = 0;\r\n        uint avgProfit = tmpProfit/5;\r\n        tmpProfit = tmpProfit.sub(avgProfit.mul(4));\r\n\r\n        0xd5783b8ca41Bc9A7FC3C0FF269118fc0a05b7593.transfer(avgProfit);\r\n        0xE416Dd4Cce56eDd3bC0E15a7d7D3D4D16E4b1928.transfer(avgProfit);\r\n        0x5482Ca54eAEd3dbAC4Ba77e8e9079d39DdDCDF0c.transfer(avgProfit);\r\n        0x36A4f27175F372bCFB6AFD00Aa0680276119a115.transfer(avgProfit);\r\n        0x5B8365241CAeDFa0fcED860F8f10D1EB365af3c9.transfer(tmpProfit);\r\n\r\n        emit OnWithdrawOwnerProfit(owner, tmpProfit);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"successBuyNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnAddSheepNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refunder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnBuyOrderRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forageFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"ancestorList\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusPot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnCommissionDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnFinalBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnFirstGenerationJoinGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPlayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnJoinGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnRanchSizeIncrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnReBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnSellerProcessProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnWeekBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"OnWithdrawOwnerProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnWithdrawProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIMEOUT_FINAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIMEOUT_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sheepPrice\",\"type\":\"uint256\"}],\"name\":\"addNewSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addReproductionRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"}],\"name\":\"addSheepNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundValue\",\"type\":\"uint256\"}],\"name\":\"buyOrderRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"}],\"name\":\"firstGenerationJoinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pID\",\"type\":\"uint256\"}],\"name\":\"getAddrByPID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAncestorList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBonusPotData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGhostProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInviteesList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPIDByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerStatus\",\"outputs\":[{\"internalType\":\"enum CryptoRanch.PlayerStatus\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReproductionRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUsrCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeekRankData\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"}],\"name\":\"improveRanchSizeFromWallet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"}],\"name\":\"minusSheepNum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"}],\"name\":\"processSellerProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ranchAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ranchInitSheepNumList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sheepNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"rebuyForSheep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"commissionAddr\",\"type\":\"address\"}],\"name\":\"setCommissionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"ranchAddr\",\"type\":\"address\"}],\"name\":\"setRanchAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"txSysAddr\",\"type\":\"address\"}],\"name\":\"setTransactionSystemAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showPlayerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txSysAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawOwnerProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CryptoRanch","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://75513f0026ba6b7a17badf1bbc675739645c8faccfc34fa7388962a4d93df381"}]}