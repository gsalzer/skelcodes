{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/HodlLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nlibrary HodlLib {\\n    // The packed hodl item makes heavy use of bit packing\\n    // to minimize storage costs.\\n    struct PackedHodlItem {\\n        // Contains the fields of a packed `UnpackedHodlItem`. See the struct definition\\n        // below for more information.\\n        uint256 packedData;\\n        //\\n        // Mostly zero\\n        //\\n        // The creator address is only set if different than the `prpsBeneficiary`.\\n        address creator;\\n        // The dubiBeneficiary is only set if different than the `prpsBeneficiary`.\\n        address dubiBeneficiary;\\n        uint96 pendingLockedPrps;\\n    }\\n\\n    // The unpacked hodl item contains the unpacked data of an hodl item from storage.\\n    // It minimizes storage reads, since only a single read from storage is necessary\\n    // in most cases to access all relevant data.\\n    //\\n    // NOTE: The bit-sizes of the fields are rounded up to the nearest Solidity type.\\n    struct UnpackedHodlItem {\\n        // The id of the hodl item is actually a uint20, but stored in a uint24 for\\n        // technical reasons. Allows for 2^20 = 1_048_576 hodls per address\\n        // Actual size: uint20\\n        uint24 id;\\n        // The hodl duration is stored using 9 bits and measured in days.\\n        // Technically, allowing for 2^9 = 512 days, but we cap it to 365 days.\\n        // In the remaining 3 bytes several 1-bit flags are stored like:\\n        // `hasDependentHodlOp` and `hasPendingLockedPrps`, etc.\\n        // Actual size: uint12\\n        uint16 duration;\\n        UnpackedFlags flags;\\n        // The last withdrawal timestamp in unix seconds (block timestamp). Defaults to\\n        // the creation date of the hodl.\\n        uint32 lastWithdrawal;\\n        // Storing the PRPS amount in a uint96 still allows to lock up to ~ 7 billion PRPS\\n        // which is plenty enough.\\n        uint96 lockedPrps;\\n        uint96 burnedLockedPrps;\\n    }\\n\\n    struct UnpackedFlags {\\n        // True, if creator is not the PRPS beneficiary\\n        bool hasDifferentCreator;\\n        // True, if DUBI beneficiary is not the PRPS beneficiary\\n        bool hasDifferentDubiBeneficiary;\\n        bool hasDependentHodlOp;\\n        bool hasPendingLockedPrps;\\n    }\\n\\n    // Struct that contains all unpacked data and the additional almost-always zero fields from\\n    // the packed hodl item - returned from `getHodl()` to be more user-friendly to consume.\\n    struct PrettyHodlItem {\\n        uint24 id;\\n        uint16 duration;\\n        UnpackedFlags flags;\\n        uint32 lastWithdrawal;\\n        uint96 lockedPrps;\\n        uint96 burnedLockedPrps;\\n        address creator;\\n        address dubiBeneficiary;\\n        uint96 pendingLockedPrps;\\n    }\\n\\n    /**\\n     * @dev Pack an unpacked hodl item and return a uint256\\n     */\\n    function packHodlItem(UnpackedHodlItem memory _unpackedHodlItem)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        //\\n        // Allows for 2^20 = 1_048_576 hodls per address\\n        // uint20 id;\\n        //\\n        // The hodl duration is stored using 9 bits and measured in days.\\n        // Technically, allowing for 2^9 = 512 days, but we only need 365 days anyway.\\n        // uint9 durationAndFlags;\\n        //\\n        // Followed by 4 bits to hold 4 flags:\\n        // - `hasDifferentCreator`\\n        // - `hasDifferentDubiBeneficiarys`\\n        // - `hasDependentHodlOp`\\n        // - `hasPendingLockedPrps`\\n        //\\n        // The last withdrawal timestamp in unix seconds (block timestamp). Defaults to\\n        // the creation date of the hodl and uses 31 bits:\\n        // uint31 lastWithdrawal\\n        //\\n        // The PRPS amounts are stored in a uint96 which can hold up to ~ 7 billion PRPS\\n        // which is plenty enough.\\n        // uint96 lockedPrps;\\n        // uint96 burnedLockedPrps;\\n        //\\n\\n        // Build the packed data according to the spec above.\\n        uint256 packedData;\\n        uint256 offset;\\n\\n        // 1) Set first 20 bits to id\\n        // Since it is stored in a uint24 AND it with a bitmask where the first 20 bits are 1\\n        uint24 id = _unpackedHodlItem.id;\\n        uint24 idMask = (1 << 20) - 1;\\n        packedData |= uint256(id & idMask) << offset;\\n        offset += 20;\\n\\n        // 2) Set next 9 bits to duration.\\n        // Since it is stored in a uint16 AND it with a bitmask where the first 9 bits are 1\\n\\n        uint16 duration = _unpackedHodlItem.duration;\\n        uint16 durationMask = (1 << 9) - 1;\\n        packedData |= uint256(duration & durationMask) << offset;\\n        offset += 9;\\n\\n        // 3) Set next 31 bits to withdrawal time\\n        // Since it is stored in a uint32 AND it with a bitmask where the first 31 bits are 1\\n        uint32 lastWithdrawal = _unpackedHodlItem.lastWithdrawal;\\n        uint32 lastWithdrawalMask = (1 << 31) - 1;\\n        packedData |= uint256(lastWithdrawal & lastWithdrawalMask) << offset;\\n        offset += 31;\\n\\n        // 4) Set the 4 flags in the next 4 bits after lastWithdrawal.\\n        UnpackedFlags memory flags = _unpackedHodlItem.flags;\\n        if (flags.hasDifferentCreator) {\\n            // PRPS beneficiary is not the creator\\n            packedData |= 1 << (offset + 0);\\n        }\\n\\n        if (flags.hasDifferentDubiBeneficiary) {\\n            // PRPS beneficiary is not the DUBI beneficiary\\n            packedData |= 1 << (offset + 1);\\n        }\\n\\n        if (flags.hasDependentHodlOp) {\\n            packedData |= 1 << (offset + 2);\\n        }\\n\\n        if (flags.hasPendingLockedPrps) {\\n            packedData |= 1 << (offset + 3);\\n        }\\n\\n        offset += 4;\\n\\n        // 5) Set next 96 bits to locked PRPS\\n        // We don't need to apply a bitmask here, because it occupies the full 96 bit.\\n        packedData |= uint256(_unpackedHodlItem.lockedPrps) << offset;\\n        offset += 96;\\n\\n        // 6) Set next 96 bits to burned locked PRPS\\n        // We don't need to apply a bitmask here, because it occupies the full 96 bit.\\n        packedData |= uint256(_unpackedHodlItem.burnedLockedPrps) << offset;\\n        offset += 96;\\n\\n        assert(offset == 256);\\n\\n        return packedData;\\n    }\\n\\n    /**\\n     * @dev Unpack a packed hodl item.\\n     */\\n    function unpackHodlItem(uint256 packedData)\\n        internal\\n        pure\\n        returns (UnpackedHodlItem memory)\\n    {\\n        UnpackedHodlItem memory _unpacked;\\n        uint256 offset;\\n\\n        // 1) Read id from the first 20 bits\\n        uint24 id = uint24(packedData >> offset);\\n        uint24 idMask = (1 << 20) - 1;\\n        _unpacked.id = id & idMask;\\n        offset += 20;\\n\\n        // 2) Read duration from the next 9 bits\\n        uint16 duration = uint16(packedData >> offset);\\n        uint16 durationMask = (1 << 9) - 1;\\n        _unpacked.duration = duration & durationMask;\\n        offset += 9;\\n\\n        // 3) Read lastWithdrawal time from the next 31 bits\\n        uint32 lastWithdrawal = uint32(packedData >> offset);\\n        uint32 lastWithdrawalMask = (1 << 31) - 1;\\n        _unpacked.lastWithdrawal = lastWithdrawal & lastWithdrawalMask;\\n        offset += 31;\\n\\n        // 4) Read the 4 flags from the next 4 bits\\n        UnpackedFlags memory flags = _unpacked.flags;\\n\\n        flags.hasDifferentCreator = (packedData >> (offset + 0)) & 1 == 1;\\n        flags.hasDifferentDubiBeneficiary =\\n            (packedData >> (offset + 1)) & 1 == 1;\\n        flags.hasDependentHodlOp = (packedData >> (offset + 2)) & 1 == 1;\\n        flags.hasPendingLockedPrps = (packedData >> (offset + 3)) & 1 == 1;\\n\\n        offset += 4;\\n\\n        // 5) Read locked PRPS from the next 96 bits\\n        // We don't need to apply a bitmask here, because it occupies the full 96 bit.\\n        _unpacked.lockedPrps = uint96(packedData >> offset);\\n        offset += 96;\\n\\n        // 5) Read burned locked PRPS from the next 96 bits\\n        // We don't need to apply a bitmask here, because it occupies the full 96 bit.\\n        _unpacked.burnedLockedPrps = uint96(packedData >> offset);\\n        offset += 96;\\n\\n        assert(offset == 256);\\n\\n        return _unpacked;\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Pending ops\\n    //---------------------------------------------------------------\\n\\n    struct PendingHodl {\\n        // HodlLib.PackedHodlItem;\\n        address creator;\\n        uint96 amountPrps;\\n        address dubiBeneficiary;\\n        uint96 dubiToMint;\\n        address prpsBeneficiary;\\n        uint24 hodlId;\\n        uint16 duration;\\n    }\\n\\n    struct PendingRelease {\\n        uint24 hodlId;\\n        uint96 releasablePrps;\\n        // Required for look-up of hodl item\\n        address creator;\\n        // prpsBeneficiary is implied\\n    }\\n\\n    struct PendingWithdrawal {\\n        address prpsBeneficiary;\\n        uint96 dubiToMint;\\n        // Required for look-up of hodl item\\n        address creator;\\n        uint24 hodlId;\\n    }\\n\\n    function setLockedPrpsToPending(\\n        HodlLib.PackedHodlItem[] storage hodlsSender,\\n        uint96 amount\\n    ) public {\\n        // Sum of the PRPS that got marked pending or removed from pending hodls.\\n        uint96 totalLockedPrpsMarkedPending;\\n        uint256 length = hodlsSender.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            HodlLib.PackedHodlItem storage packed = hodlsSender[i];\\n            HodlLib.UnpackedHodlItem memory unpacked = HodlLib.unpackHodlItem(\\n                packed.packedData\\n            );\\n\\n            // Skip hodls which are occupied by pending releases/withdrawals, but\\n            // allow modifying hodls with already pending locked PRPS.\\n            if (unpacked.flags.hasDependentHodlOp) {\\n                continue;\\n            }\\n\\n            uint96 remainingPendingPrps = amount - totalLockedPrpsMarkedPending;\\n\\n            // Sanity check\\n            assert(remainingPendingPrps <= amount);\\n\\n            // No more PRPS left to mark pending\\n            if (remainingPendingPrps == 0) {\\n                break;\\n            }\\n\\n            // Remaining PRPS on the hodl that can be marked pending\\n            uint96 pendingLockedPrps;\\n            if (unpacked.flags.hasPendingLockedPrps) {\\n                pendingLockedPrps = packed.pendingLockedPrps;\\n            }\\n\\n            uint96 remainingLockedPrps = unpacked.lockedPrps -\\n                unpacked.burnedLockedPrps -\\n                pendingLockedPrps;\\n\\n            // Sanity check\\n            assert(remainingLockedPrps <= unpacked.lockedPrps);\\n\\n            // Skip to next hodl if no PRPS left on hodl\\n            if (remainingLockedPrps == 0) {\\n                continue;\\n            }\\n\\n            // Cap amount if the remaining PRPS on hodl is less than what still needs to be marked pending\\n            if (remainingPendingPrps > remainingLockedPrps) {\\n                remainingPendingPrps = remainingLockedPrps;\\n            }\\n\\n            // Update pending PRPS on hodl\\n            uint96 updatedPendingPrpsOnHodl = pendingLockedPrps +\\n                remainingPendingPrps;\\n\\n            // Total of pending PRPS on hodl may never exceed (locked - burned) PRPS.\\n            assert(\\n                updatedPendingPrpsOnHodl <=\\n                    unpacked.lockedPrps - unpacked.burnedLockedPrps\\n            );\\n\\n            totalLockedPrpsMarkedPending += remainingPendingPrps;\\n\\n            // Write updated hodl item to storage\\n            unpacked.flags.hasPendingLockedPrps = true;\\n            packed.pendingLockedPrps = updatedPendingPrpsOnHodl;\\n            packed.packedData = HodlLib.packHodlItem(unpacked);\\n        }\\n\\n        require(totalLockedPrpsMarkedPending == amount, \\\"H-14\\\");\\n    }\\n\\n    function revertLockedPrpsSetToPending(\\n        HodlLib.PackedHodlItem[] storage hodlsSender,\\n        uint96 amount\\n    ) public {\\n        require(amount > 0, \\\"H-22\\\");\\n\\n        // Remaining pending PRPS to take from hodls\\n        uint96 remainingPendingLockedPrps = amount;\\n        uint256 length = hodlsSender.length;\\n\\n        // Traverse hodls and remove pending locked PRPS until `amount`\\n        // is filled.\\n        for (uint256 i = 0; i < length; i++) {\\n            HodlLib.PackedHodlItem storage packed = hodlsSender[i];\\n            HodlLib.UnpackedHodlItem memory unpacked = HodlLib.unpackHodlItem(\\n                packed.packedData\\n            );\\n\\n            if (\\n                !unpacked.flags.hasPendingLockedPrps ||\\n                unpacked.flags.hasDependentHodlOp\\n            ) {\\n                // Skip hodls without pending locked PRPS or when occupied\\n                // by pending releases and withdrawals\\n                continue;\\n            }\\n\\n            // Hodl has pending locked PRPS\\n\\n            // Ensure we do not remove more than what is needed\\n            uint96 remainingPendingPrpsOnHodl = packed.pendingLockedPrps;\\n            if (remainingPendingPrpsOnHodl > remainingPendingLockedPrps) {\\n                remainingPendingPrpsOnHodl = remainingPendingLockedPrps;\\n            }\\n\\n            // The check above guarantees that this cannot underflow\\n            remainingPendingLockedPrps -= remainingPendingPrpsOnHodl;\\n            packed.pendingLockedPrps -= remainingPendingPrpsOnHodl;\\n\\n            // Update hodl if all pending locked PRPS has been removed\\n            if (remainingPendingPrpsOnHodl == 0) {\\n                unpacked.flags.hasPendingLockedPrps = false;\\n                packed.packedData = HodlLib.packHodlItem(unpacked);\\n            }\\n\\n            // Break loop if the remaining total pending PRPS is zero\\n            if (remainingPendingLockedPrps == 0) {\\n                // Done\\n                break;\\n            }\\n        }\\n\\n        // Sanity check\\n        assert(remainingPendingLockedPrps == 0);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"HodlLib","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}