{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IConversionRate {\r\n\r\n    function getStepFunctionData(address token, uint command, uint param) external view returns(int);\r\n    function getListedTokens() external view returns(address[] memory);\r\n}\r\n\r\n\r\n\r\ncontract KyberHelper {\r\n    \r\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\r\n    struct StepFunction {\r\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n        int[] y; // rate change per quantity step  in bps.\r\n    }\r\n\r\n    struct TokenData {\r\n        address token;\r\n        StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;// in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }\r\n    \r\n    function loadStepFunctionData(address conversionRateContract) external view returns (TokenData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        \r\n        data = new TokenData[](tokens.length);\r\n        \r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            \r\n            data[i].token = tokens[i];\r\n            \r\n            uint[8] memory stepFunctionLenList = [\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 0, 0)),  // buyRateQtyStepFunctionXLen\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 2, 0)),  // buyRateQtyStepFunctionYLen\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 4, 0)),  // sellRateQtyStepFunctionXLen\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 6, 0)),  // sellRateQtyStepFunctionYLen\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 8, 0)),  // buyRateImbalanceStepFunctionXLen\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 10, 0)), // buyRateImbalanceStepFunctionYLen\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 12, 0)), // sellRateImbalanceStepFunctionXLen\r\n                uint(IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 14, 0))  // sellRateImbalanceStepFunctionYLen\r\n            ]; \r\n            \r\n            data[i].buyRateQtyStepFunction = initStepFunction(stepFunctionLenList[0], stepFunctionLenList[1]);\r\n            data[i].sellRateQtyStepFunction = initStepFunction(stepFunctionLenList[2], stepFunctionLenList[3]);\r\n            data[i].buyRateImbalanceStepFunction = initStepFunction(stepFunctionLenList[4], stepFunctionLenList[5]);\r\n            data[i].sellRateImbalanceStepFunction = initStepFunction(stepFunctionLenList[6], stepFunctionLenList[7]);\r\n\r\n            for (uint j = 0; j < getMaxValue(stepFunctionLenList); j++) {\r\n              if (j < stepFunctionLenList[0]) {\r\n                data[i].buyRateQtyStepFunction.x[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 1, uint(j));\r\n              }\r\n              if (j < stepFunctionLenList[1]) {\r\n                data[i].buyRateQtyStepFunction.y[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 3, uint(j));\r\n              }\r\n              if (j < stepFunctionLenList[2]) {\r\n                data[i].sellRateQtyStepFunction.x[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 5, uint(j));\r\n              }\r\n              if (j < stepFunctionLenList[3]) {\r\n                data[i].sellRateQtyStepFunction.y[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 7, uint(j));\r\n              }\r\n              if (j < stepFunctionLenList[4]) {\r\n                data[i].buyRateImbalanceStepFunction.x[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 9, uint(j));\r\n              }\r\n              if (j < stepFunctionLenList[5]) {\r\n                data[i].buyRateImbalanceStepFunction.y[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 11, uint(j));\r\n              }\r\n              if (j < stepFunctionLenList[6]) {\r\n                data[i].sellRateImbalanceStepFunction.x[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 13, uint(j));\r\n              }\r\n              if (j < stepFunctionLenList[7]) {\r\n                data[i].sellRateImbalanceStepFunction.y[j] = IConversionRate(conversionRateContract).getStepFunctionData(tokens[i], 15, uint(j));\r\n              }  \r\n            }\r\n        }\r\n    }\r\n    \r\n    function getMaxValue(uint[8] memory values) private pure returns (uint) {\r\n        uint max; \r\n        for(uint i = 0; i < values.length; i++) {\r\n            if(values[i] > max) {\r\n                max = values[i]; \r\n            } \r\n        }\r\n        return max;\r\n    }\r\n    \r\n    function initStepFunction(uint xLen, uint yLen) private pure returns (StepFunction memory stepFunc) {\r\n        stepFunc.x = new int[](xLen);\r\n        stepFunc.y = new int[](yLen);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"loadStepFunctionData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"buyRateQtyStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"sellRateQtyStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"buyRateImbalanceStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct KyberHelper.StepFunction\",\"name\":\"sellRateImbalanceStepFunction\",\"type\":\"tuple\"}],\"internalType\":\"struct KyberHelper.TokenData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"KyberHelper","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f455e5703a2dd9809c8e9674960834b1c110b0cc1b2d6dbc7cd9b3d3ebe80e28"}]}