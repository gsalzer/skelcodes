{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of src/sushi-farm.sol\r\npragma solidity >0.4.13 >=0.4.23 >=0.5.0 >=0.6.2 <0.7.0 >=0.6.7 <0.7.0;\r\n\r\n////// lib/ds-auth/src/auth.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.4.23; */\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/ds-math/src/math.sol\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >0.4.13; */\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/ds-token/src/token.sol\r\n/// token.sol -- ERC20 implementation with minting and burning\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.4.23; */\r\n\r\n/* import \"ds-math/math.sol\"; */\r\n/* import \"ds-auth/auth.sol\"; */\r\n\r\n\r\ncontract DSToken is DSMath, DSAuth {\r\n    bool                                              public  stopped;\r\n    uint256                                           public  totalSupply;\r\n    mapping (address => uint256)                      public  balanceOf;\r\n    mapping (address => mapping (address => uint256)) public  allowance;\r\n    bytes32                                           public  symbol;\r\n    uint256                                           public  decimals = 18; // standard token precision. override to customize\r\n    bytes32                                           public  name = \"\";     // Optional token name\r\n\r\n    constructor(bytes32 symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n    event Stop();\r\n    event Start();\r\n\r\n    modifier stoppable {\r\n        require(!stopped, \"ds-stop-is-stopped\");\r\n        _;\r\n    }\r\n\r\n    function approve(address guy) external returns (bool) {\r\n        return approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n\r\n        require(balanceOf[src] >= wad, \"ds-token-insufficient-balance\");\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) external {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function pull(address src, uint wad) external {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n\r\n    function mint(uint wad) external {\r\n        mint(msg.sender, wad);\r\n    }\r\n\r\n    function burn(uint wad) external {\r\n        burn(msg.sender, wad);\r\n    }\r\n\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        balanceOf[guy] = add(balanceOf[guy], wad);\r\n        totalSupply = add(totalSupply, wad);\r\n        emit Mint(guy, wad);\r\n    }\r\n\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && allowance[guy][msg.sender] != uint(-1)) {\r\n            require(allowance[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\r\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\r\n        }\r\n\r\n        require(balanceOf[guy] >= wad, \"ds-token-insufficient-balance\");\r\n        balanceOf[guy] = sub(balanceOf[guy], wad);\r\n        totalSupply = sub(totalSupply, wad);\r\n        emit Burn(guy, wad);\r\n    }\r\n\r\n    function stop() public auth {\r\n        stopped = true;\r\n        emit Stop();\r\n    }\r\n\r\n    function start() public auth {\r\n        stopped = false;\r\n        emit Start();\r\n    }\r\n\r\n    function setName(bytes32 name_) external auth {\r\n        name = name_;\r\n    }\r\n}\r\n\r\n////// src/constants.sol\r\n/* pragma solidity ^0.6.7; */\r\n\r\n\r\nlibrary Constants {\r\n    // Tokens\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address constant SUSHI = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\r\n    address constant UNIV2_SUSHI_ETH = 0xCE84867c3c02B05dc570d0135103d3fB9CC19433;\r\n\r\n    // Uniswap\r\n    address constant UNIV2_ROUTER2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    // Sushiswap\r\n    address constant MASTERCHEF = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd;\r\n}\r\n////// src/interfaces/masterchef.sol\r\n// SPDX-License-Identifier: MIT\r\n/* pragma solidity ^0.6.2; */\r\n\r\ninterface Masterchef {\r\n    function deposit(uint256 _pid, uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _pid, uint256 _amount) external;\r\n\r\n    function userInfo(uint256, address)\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 rewardDebt);\r\n}\r\n\r\n////// src/interfaces/uniswap.sol\r\n// SPDX-License-Identifier: MIT\r\n/* pragma solidity ^0.6.2; */\r\n\r\ninterface UniswapRouterV2 {\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface UniswapPair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestamp\r\n        );\r\n}\r\n\r\n////// src/sushi-farm.sol\r\n/* pragma solidity ^0.6.7; */\r\n\r\n/* import \"ds-math/math.sol\"; */\r\n/* import \"ds-token/token.sol\"; */\r\n\r\n/* import \"./interfaces/masterchef.sol\"; */\r\n/* import \"./interfaces/uniswap.sol\"; */\r\n\r\n/* import \"./constants.sol\"; */\r\n\r\n// Sushi Farm in SushiSwap\r\n// Used to farm sushi. i.e. Deposit into this pool if you want to LONG sushi.\r\n\r\n// Based off https://github.com/iearn-finance/vaults/blob/master/contracts/yVault.sol\r\ncontract SushiFarm is DSMath {\r\n    // Tokens\r\n    DSToken public sushi = DSToken(Constants.SUSHI);\r\n    DSToken public univ2SushiEth = DSToken(Constants.UNIV2_SUSHI_ETH);\r\n    DSToken public weth = DSToken(Constants.WETH);\r\n    DSToken public gSushi;\r\n\r\n    // Uniswap Router and Pair\r\n    UniswapRouterV2 public univ2 = UniswapRouterV2(Constants.UNIV2_ROUTER2);\r\n    UniswapPair public univ2Pair = UniswapPair(address(univ2SushiEth));\r\n\r\n    // Masterchef Contract\r\n    Masterchef public masterchef = Masterchef(Constants.MASTERCHEF);\r\n    uint256 public univ2SushiEthPoolId = 12;\r\n\r\n    // 5% reward for anyone who calls HARVEST\r\n    uint256 public callerRewards = 5 ether / 100;\r\n\r\n    // Last harvest\r\n    uint256 public lastHarvest = 0;\r\n\r\n    constructor() public {\r\n        gSushi = new DSToken(\"gSushi\");\r\n        gSushi.setName(\"Grazing Sushi\");\r\n    }\r\n\r\n    // **** Harvest profits ****\r\n\r\n    function harvest() public {\r\n        // Only callable every hour or so\r\n        if (lastHarvest > 0) {\r\n            require(lastHarvest + 1 hours <= block.timestamp, \"!harvest-time\");\r\n        }\r\n        lastHarvest = block.timestamp;\r\n\r\n        // Withdraw sushi\r\n        masterchef.withdraw(univ2SushiEthPoolId, 0);\r\n\r\n        uint256 amount = sushi.balanceOf(address(this));\r\n        uint256 reward = div(mul(amount, callerRewards), 100 ether);\r\n\r\n        // Sends 5% fee to caller\r\n        sushi.transfer(msg.sender, reward);\r\n\r\n        // Remove amount from rewards\r\n        amount = sub(amount, reward);\r\n\r\n        // Add to UniV2 pool\r\n        _sushiToUniV2SushiEth(amount);\r\n\r\n        // Deposit into masterchef contract\r\n        uint256 balance = univ2SushiEth.balanceOf(address(this));\r\n        univ2SushiEth.approve(address(masterchef), balance);\r\n        masterchef.deposit(univ2SushiEthPoolId, balance);\r\n    }\r\n\r\n    // **** Withdraw / Deposit functions ****\r\n\r\n    function withdrawAll() external {\r\n        withdraw(gSushi.balanceOf(msg.sender));\r\n    }\r\n\r\n    function withdraw(uint256 _shares) public {\r\n        uint256 univ2Balance = univ2SushiEthBalance();\r\n\r\n        uint256 amount = div(mul(_shares, univ2Balance), gSushi.totalSupply());\r\n        gSushi.burn(msg.sender, _shares);\r\n\r\n        // Withdraw from Masterchef contract\r\n        masterchef.withdraw(univ2SushiEthPoolId, amount);\r\n\r\n        // Retrive shares from Uniswap pool and converts to SUSHI\r\n        uint256 _before = sushi.balanceOf(address(this));\r\n        _uniV2SushiEthToSushi(amount);\r\n        uint256 _after = sushi.balanceOf(address(this));\r\n\r\n        // Transfer back SUSHI difference\r\n        sushi.transfer(msg.sender, sub(_after, _before));\r\n    }\r\n\r\n    function depositAll() external {\r\n        deposit(sushi.balanceOf(msg.sender));\r\n    }\r\n\r\n    function deposit(uint256 _amount) public {\r\n        sushi.transferFrom(msg.sender, address(this), _amount);\r\n\r\n        uint256 _pool = univ2SushiEthBalance();\r\n        uint256 _before = univ2SushiEth.balanceOf(address(this));\r\n        _sushiToUniV2SushiEth(_amount);\r\n        uint256 _after = univ2SushiEth.balanceOf(address(this));\r\n\r\n        _amount = sub(_after, _before); // Additional check for deflationary tokens\r\n\r\n        uint256 shares = 0;\r\n        if (gSushi.totalSupply() == 0) {\r\n            shares = _amount;\r\n        } else {\r\n            shares = div(mul(_amount, gSushi.totalSupply()), _pool);\r\n        }\r\n\r\n        // Deposit into Masterchef contract to get rewards\r\n        univ2SushiEth.approve(address(masterchef), _amount);\r\n        masterchef.deposit(univ2SushiEthPoolId, _amount);\r\n\r\n        gSushi.mint(msg.sender, shares);\r\n    }\r\n\r\n    // Takes <x> amount of SUSHI\r\n    // Converts half of it into ETH,\r\n    // Supplies them into SUSHI/ETH pool\r\n    function _sushiToUniV2SushiEth(uint256 _amount) internal {\r\n        uint256 half = div(_amount, 2);\r\n\r\n        // Convert half of the sushi to ETH\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(sushi);\r\n        path[1] = address(weth);\r\n        sushi.approve(address(univ2), half);\r\n        univ2.swapExactTokensForTokens(half, 0, path, address(this), now + 60);\r\n\r\n        // Supply liquidity\r\n        uint256 wethBal = weth.balanceOf(address(this));\r\n        uint256 sushiBal = sushi.balanceOf(address(this));\r\n        sushi.approve(address(univ2), sushiBal);\r\n        weth.approve(address(univ2), wethBal);\r\n        univ2.addLiquidity(\r\n            address(sushi),\r\n            address(weth),\r\n            sushiBal,\r\n            wethBal,\r\n            0,\r\n            0,\r\n            address(this),\r\n            now + 60\r\n        );\r\n    }\r\n\r\n    // Takes <x> amount of gSushi\r\n    // And removes liquidity from SUSHI/ETH pool\r\n    // Converts the ETH into Sushi\r\n    function _uniV2SushiEthToSushi(uint256 _amount) internal {\r\n        // Remove liquidity\r\n        require(\r\n            univ2SushiEth.balanceOf(address(this)) >= _amount,\r\n            \"not-enough-liquidity\"\r\n        );\r\n        univ2SushiEth.approve(address(univ2), _amount);\r\n        univ2.removeLiquidity(\r\n            address(sushi),\r\n            address(weth),\r\n            _amount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            now + 60\r\n        );\r\n\r\n        // Convert ETH to SUSHI\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(weth);\r\n        path[1] = address(sushi);\r\n        uint256 wethBal = weth.balanceOf(address(this));\r\n        weth.approve(address(univ2), wethBal);\r\n        univ2.swapExactTokensForTokens(\r\n            wethBal,\r\n            0,\r\n            path,\r\n            address(this),\r\n            now + 60\r\n        );\r\n    }\r\n\r\n    // 1 gSUSHI = <x> SUSHI\r\n    function getGSushiOverSushiRatio() public view returns (uint256) {\r\n        // How much UniV2 do we have\r\n        uint256 uniV2Balance = univ2SushiEthBalance();\r\n\r\n        if (uniV2Balance == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // How many SUSHI and ETH can we get for this?\r\n        (uint112 _poolSushiReserve, uint112 _poolWETHReserve, ) = univ2Pair\r\n            .getReserves(); // SUSHI and WETH in pool\r\n        uint256 uniV2liquidity = univ2SushiEth.totalSupply(); // Univ2 total supply\r\n        uint256 uniV2percentage = div(mul(uniV2Balance, 1e18), uniV2liquidity); // How much we own %-wise\r\n\r\n        uint256 removableSushi = uint256(\r\n            div(mul(_poolSushiReserve, uniV2percentage), 1e18)\r\n        );\r\n        uint256 removableWeth = uint256(\r\n            div(mul(_poolWETHReserve, uniV2percentage), 1e18)\r\n        );\r\n\r\n        // How many SUSHI can we get for the ETH?\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(weth);\r\n        path[1] = address(sushi);\r\n        uint256[] memory outs = univ2.getAmountsOut(removableWeth, path);\r\n\r\n        // Get RATIO\r\n        return div(mul(add(outs[1], removableSushi), 1e18), gSushi.totalSupply());\r\n    }\r\n\r\n    function univ2SushiEthBalance() public view returns (uint256) {\r\n        (uint256 univ2Balance, ) = masterchef.userInfo(\r\n            univ2SushiEthPoolId,\r\n            address(this)\r\n        );\r\n\r\n        return univ2Balance;\r\n    }\r\n\r\n    // **** Internal functions ****\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbol_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"pull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"push\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name_\",\"type\":\"bytes32\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DSToken","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"6753757368690000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5d78c8bfac43325139729d1133484204b57ca93624935908b44ee86129083883"}]}