{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2020 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/BaseMath.sol\r\n\r\n/**\r\n * @title BaseMath\r\n * @author dYdX\r\n *\r\n * @dev Arithmetic for fixed-point numbers with 18 decimals of precision.\r\n */\r\nlibrary BaseMath {\r\n    using SafeMath for uint256;\r\n\r\n    // The number One in the BaseMath system.\r\n    uint256 constant internal BASE = 10 ** 18;\r\n\r\n    /**\r\n     * @dev Getter function since constants can't be read directly from libraries.\r\n     */\r\n    function base()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return BASE;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded down).\r\n     */\r\n    function baseMul(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.mul(baseValue).div(BASE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded down).\r\n     *  Intended as an alternaltive to baseMul to prevent overflow, when `value` is known\r\n     *  to be divisible by `BASE`.\r\n     */\r\n    function baseDivMul(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.div(BASE).mul(baseValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded up).\r\n     */\r\n    function baseMulRoundUp(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (value == 0 || baseValue == 0) {\r\n            return 0;\r\n        }\r\n        return value.mul(baseValue).sub(1).div(BASE).add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a value by a base value (result is rounded down).\r\n     */\r\n    function baseDiv(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.mul(BASE).div(baseValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a base value representing the reciprocal of another base value (result is\r\n     *  rounded down).\r\n     */\r\n    function baseReciprocal(\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return baseDiv(BASE, baseValue);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/intf/I_P1Oracle.sol\r\n\r\n/**\r\n * @title I_P1Oracle\r\n * @author dYdX\r\n *\r\n * @notice Interface that PerpetualV1 Price Oracles must implement.\r\n */\r\ninterface I_P1Oracle {\r\n\r\n    /**\r\n     * @notice Returns the price of the underlying asset relative to the margin token.\r\n     *\r\n     * @return The price as a fixed-point number with 18 decimals.\r\n     */\r\n    function getPrice()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/protocol/v1/oracles/P1OracleInverter.sol\r\n\r\n/**\r\n * @title P1OracleInverter\r\n * @author dYdX\r\n *\r\n * @notice P1Oracle that returns the inverted price (i.e. flips base and quote currencies) of\r\n *  another P1Oracle.\r\n */\r\ncontract P1OracleInverter is\r\n    I_P1Oracle\r\n{\r\n    using BaseMath for uint256;\r\n\r\n    // ============ Storage ============\r\n\r\n    // The underlying P1Oracle to get and invert the price of.\r\n    address public _ORACLE_;\r\n\r\n    // The address with permission to get the oracle price.\r\n    address public _READER_;\r\n\r\n    // A constant factor to adjust the price by, as a fixed-point number with 18 decimal places.\r\n    uint256 public _ADJUSTMENT_;\r\n\r\n    // Compact storage for the above parameters.\r\n    mapping (address => bytes32) public _MAPPING_;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address oracle,\r\n        address reader,\r\n        uint96 adjustment\r\n    )\r\n        public\r\n    {\r\n        _ORACLE_ = oracle;\r\n        _READER_ = reader;\r\n        _ADJUSTMENT_ = adjustment;\r\n\r\n        bytes32 oracleAndAdjustment = bytes32(bytes20(oracle)) | bytes32(uint256(adjustment));\r\n        _MAPPING_[reader] = oracleAndAdjustment;\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * @notice Returns the oracle price, inverted.\r\n     *\r\n     * @return The inverted price as a fixed-point number with 18 decimals.\r\n     */\r\n    function getPrice()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        bytes32 oracleAndAdjustment = _MAPPING_[msg.sender];\r\n        require(\r\n            oracleAndAdjustment != bytes32(0),\r\n            \"P1OracleInverter: Sender not authorized to get price\"\r\n        );\r\n        (address oracle, uint256 adjustment) = splitOracleAndAdjustment(oracleAndAdjustment);\r\n        uint256 rawPrice = I_P1Oracle(oracle).getPrice();\r\n        uint256 invertedPrice = rawPrice.baseReciprocal();\r\n        uint256 result = invertedPrice.baseMul(adjustment);\r\n        return result;\r\n    }\r\n\r\n    function splitOracleAndAdjustment(\r\n        bytes32 oracleAndAdjustment\r\n    )\r\n        private\r\n        pure\r\n        returns (address, uint256)\r\n    {\r\n        address oracle = address(bytes20(oracleAndAdjustment));\r\n        uint256 adjustment = uint256(uint96(uint256(oracleAndAdjustment)));\r\n        return (oracle, adjustment);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reader\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"adjustment\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"_ADJUSTMENT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_MAPPING_\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_ORACLE_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_READER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"P1OracleInverter","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"00000000000000000000000045bb943f763411dedecc6890657f94ed061b73c800000000000000000000000009403fd14510f8196f7879ef514827cd76960b5d00000000000000000000000000000000000000009f2c9cd04674edea40000000","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bd6263ccf166336d42c42065c4bf16cd91dea4aa6f4d17582d7bf254265a010d"}]}