{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AppWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./auth/MultisigABAC.sol\\\";\\nimport \\\"./wallet/TokenManager.sol\\\";\\nimport \\\"./factory/BaseTemplate.sol\\\";\\nimport \\\"./interface/IUserWallet.sol\\\";\\n\\ncontract AppWallet is TokenManager, MultisigABAC, BaseTemplate {\\n\\tevent CallFailed(string reason);\\n\\n\\t// last nonce executed. Allowed to skip.\\n\\tuint256 public lastNonce;\\n\\n\\t/// @notice Initialize the ownership policy.\\n\\t/// @dev Access control: Can only be called with a delegatecall from a contract constructor.\\n\\t/// @param owners address[] Array of owner addresses at initialization.\\n\\t/// @param admins address[] Array of admin addresses at initialization.\\n\\t/// @param ownersRequired uint256 Number of owner signatures required for valid OWNER call.\\n\\t/// @param adminsRequired uint256 Number of admin signatures required for valid ADMIN call.\\n\\tfunction initialize(\\n\\t\\taddress[] memory owners,\\n\\t\\taddress[] memory admins,\\n\\t\\tuint256 ownersRequired,\\n\\t\\tuint256 adminsRequired\\n\\t) public initializeTemplate {\\n\\t\\tMultisigABAC._setOwnerPolicy(owners, admins, ownersRequired, adminsRequired);\\n\\t}\\n\\n\\t/// @notice Execute transaction batch.\\n\\t/// @dev Access control: Must include valid array of ADMIN or OWNER signatures that meet admin policy.\\n\\t/// @param transactions bytes[] Array of user transaction request blobs.\\n\\t/// @param nonce uint256 Unique tx salt. Allowed to skip.\\n\\t/// @param signatures bytes[] Array of admin or owner signatures.\\n\\t/// @return success bool Boolean true if all transactions were successful, false if one or more transaction reverted.\\n\\t/// @return returnData bytes[] Array of return data from user calls.\\n\\tfunction executeTransactions(\\n\\t\\tbytes[] memory transactions,\\n\\t\\tuint256 nonce,\\n\\t\\tbytes[] memory signatures\\n\\t)\\n\\t\\tpublic\\n\\t\\twithSignatures(keccak256(abi.encode(transactions, nonce)), signatures, ADMIN_ATTRIBUTE)\\n\\t\\treturns (bool success, bytes[] memory returnData)\\n\\t{\\n\\t\\t// increment nonce\\n\\t\\trequire(nonce > lastNonce, \\\"invalid nonce\\\");\\n\\t\\tlastNonce = nonce;\\n\\t\\t// execute batch atomically with external call to self in order to catch a revert\\n\\t\\ttry AppWallet(this).executeAtomicTransactions(transactions) returns (bytes[] memory _returnData) {\\n\\t\\t\\treturn (true, _returnData);\\n\\t\\t} catch Error(string memory reason) {\\n\\t\\t\\temit CallFailed(reason);\\n\\t\\t\\treturn (false, returnData);\\n\\t\\t} catch {\\n\\t\\t\\temit CallFailed(\\\"Transaction reverted silently\\\");\\n\\t\\t\\treturn (false, returnData);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Execute atomic transaction batch.\\n\\t/// @dev Access control: Can only be called by self.\\n\\t/// @param transactions bytes[] Array of user transaction request blobs.\\n\\t/// @return returnData bytes[] Array of return data from user calls.\\n\\tfunction executeAtomicTransactions(bytes[] memory transactions) public returns (bytes[] memory returnData) {\\n\\t\\t// restrict to call from self\\n\\t\\trequire(msg.sender == address(this), \\\"caller must be self\\\");\\n\\t\\t// Execute each transaction individually\\n\\t\\tbytes[] memory _returnValues = new bytes[](transactions.length);\\n\\t\\tfor (uint256 i = 0; i < transactions.length; i++) {\\n\\t\\t\\t// Decode transaction request\\n\\t\\t\\t(address payable from, bytes memory transaction, bytes[] memory signatures) = abi.decode(\\n\\t\\t\\t\\ttransactions[i],\\n\\t\\t\\t\\t(address, bytes, bytes[])\\n\\t\\t\\t);\\n\\t\\t\\t// Execute the transaction\\n\\t\\t\\t_returnValues[i] = IUserWallet(from).executeTransaction(transaction, signatures);\\n\\t\\t}\\n\\t\\t// return results\\n\\t\\treturn _returnValues;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/auth/MultisigABAC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/ECDSA.sol\\\";\\nimport \\\"../wallet/MetaTxUtils.sol\\\";\\n\\ncontract MultisigABAC is MetaTxUtils {\\n\\tusing ECDSA for bytes32;\\n\\n\\t// define management attributes\\n\\tstring public constant OWNER_ATTRIBUTE = \\\"OWNER\\\";\\n\\tstring public constant ADMIN_ATTRIBUTE = \\\"ADMIN\\\";\\n\\tuint256 public constant OWNER_ATTRIBUTE_ID = uint256(keccak256(bytes(OWNER_ATTRIBUTE)));\\n\\tuint256 public constant ADMIN_ATTRIBUTE_ID = uint256(keccak256(bytes(ADMIN_ATTRIBUTE)));\\n\\n\\t// store issued attributes\\n\\tmapping(address => mapping(uint256 => bool)) private _issuedAttributes;\\n\\t// store attribute policies\\n\\tmapping(uint256 => uint256) private _attributePolicy;\\n\\n\\t// define events\\n\\tevent PolicySet(string attribute, uint256 attributeID, uint256 required);\\n\\tevent AttributeGranted(string attribute, uint256 attributeID, address account);\\n\\tevent AttributeRevoked(string attribute, uint256 attributeID, address account);\\n\\n\\tfunction _setOwnerPolicy(\\n\\t\\taddress[] memory owners,\\n\\t\\taddress[] memory admins,\\n\\t\\tuint256 ownersRequired,\\n\\t\\tuint256 adminsRequired\\n\\t) internal {\\n\\t\\tfor (uint256 ownerIndex = 0; ownerIndex < owners.length; ownerIndex++) {\\n\\t\\t\\t_grantAttribute(owners[ownerIndex], OWNER_ATTRIBUTE);\\n\\t\\t}\\n\\t\\tfor (uint256 adminIndex = 0; adminIndex < admins.length; adminIndex++) {\\n\\t\\t\\t_grantAttribute(admins[adminIndex], ADMIN_ATTRIBUTE);\\n\\t\\t}\\n\\t\\t_setPolicy(ownersRequired, OWNER_ATTRIBUTE);\\n\\t\\t_setPolicy(adminsRequired, ADMIN_ATTRIBUTE);\\n\\t}\\n\\n\\t// modifier with x/n policy on attribute\\n\\tmodifier withAttribute(string memory attribute) {\\n\\t\\trequire(hasAttribute(msg.sender, attribute), \\\"not authorized\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier withSignatures(\\n\\t\\tbytes32 paramHash,\\n\\t\\tbytes[] memory messageHashSignatures,\\n\\t\\tstring memory attribute\\n\\t) {\\n\\t\\t_withSignatures(paramHash, messageHashSignatures, attribute);\\n\\t\\t_;\\n\\t}\\n\\n\\t// set attribute policy\\n\\tfunction setAttributePolicy(uint256 required, string memory attribute) public {\\n\\t\\t_onlyOwnerOrAdmin(attribute);\\n\\t\\t_setPolicy(required, attribute);\\n\\t}\\n\\n\\tfunction setAttributePolicy(\\n\\t\\tuint256 required,\\n\\t\\tstring memory attribute,\\n\\t\\tbytes[] memory messageHashSignatures\\n\\t) public {\\n\\t\\t_onlyOwnerOrAdmin(keccak256(abi.encode(attribute, required)), attribute, messageHashSignatures);\\n\\t\\t_setPolicy(required, attribute);\\n\\t}\\n\\n\\t// grant attribute\\n\\tfunction grantAttribute(address account, string memory attribute) public {\\n\\t\\t_onlyOwnerOrAdmin(attribute);\\n\\t\\t_grantAttribute(account, attribute);\\n\\t}\\n\\n\\tfunction grantAttribute(\\n\\t\\taddress account,\\n\\t\\tstring memory attribute,\\n\\t\\tbytes[] memory messageHashSignatures\\n\\t) public {\\n\\t\\t_onlyOwnerOrAdmin(keccak256(abi.encode(account, attribute)), attribute, messageHashSignatures);\\n\\t\\t_grantAttribute(account, attribute);\\n\\t}\\n\\n\\t// revoke attribute\\n\\tfunction revokeAttribute(address account, string memory attribute) public {\\n\\t\\t_onlyOwnerOrAdmin(attribute);\\n\\t\\t_revokeAttribute(account, attribute);\\n\\t}\\n\\n\\tfunction revokeAttribute(\\n\\t\\taddress account,\\n\\t\\tstring memory attribute,\\n\\t\\tbytes[] memory messageHashSignatures\\n\\t) public {\\n\\t\\t_onlyOwnerOrAdmin(keccak256(abi.encode(account)), attribute, messageHashSignatures);\\n\\t\\t_revokeAttribute(account, attribute);\\n\\t}\\n\\n\\t// transfer attribute\\n\\tfunction transferAttribute(\\n\\t\\taddress oldAccount,\\n\\t\\taddress newAccount,\\n\\t\\tstring memory attribute\\n\\t) public {\\n\\t\\t_onlyOwnerOrAdmin(attribute);\\n\\t\\t_transferAttribute(oldAccount, newAccount, attribute);\\n\\t}\\n\\n\\tfunction transferAttribute(\\n\\t\\taddress oldAccount,\\n\\t\\taddress newAccount,\\n\\t\\tstring memory attribute,\\n\\t\\tbytes[] memory messageHashSignatures\\n\\t) public {\\n\\t\\t_onlyOwnerOrAdmin(keccak256(abi.encode(oldAccount, newAccount, attribute)), attribute, messageHashSignatures);\\n\\t\\t_transferAttribute(oldAccount, newAccount, attribute);\\n\\t}\\n\\n\\t// internal\\n\\tfunction _setPolicy(uint256 required, string memory attribute) internal {\\n\\t\\tuint256 attributeID = stringToUint(attribute);\\n\\t\\t_attributePolicy[attributeID] = required;\\n\\t\\temit PolicySet(attribute, attributeID, required);\\n\\t}\\n\\n\\tfunction _grantAttribute(address account, string memory attribute) internal {\\n\\t\\tuint256 attributeID = stringToUint(attribute);\\n\\t\\trequire(!_issuedAttributes[account][attributeID], \\\"attribute already held\\\");\\n\\t\\t_issuedAttributes[account][attributeID] = true;\\n\\t\\temit AttributeGranted(attribute, attributeID, account);\\n\\t}\\n\\n\\tfunction _revokeAttribute(address account, string memory attribute) internal {\\n\\t\\tuint256 attributeID = stringToUint(attribute);\\n\\t\\trequire(_issuedAttributes[account][attributeID], \\\"attribute not held\\\");\\n\\t\\tdelete _issuedAttributes[account][attributeID];\\n\\t\\temit AttributeRevoked(attribute, attributeID, account);\\n\\t}\\n\\n\\tfunction _transferAttribute(\\n\\t\\taddress oldAccount,\\n\\t\\taddress newAccount,\\n\\t\\tstring memory attribute\\n\\t) internal {\\n\\t\\t_revokeAttribute(oldAccount, attribute);\\n\\t\\t_grantAttribute(newAccount, attribute);\\n\\t}\\n\\n\\t// getters\\n\\tfunction getPolicy(string memory attribute) public view returns (uint256 required) {\\n\\t\\treturn _attributePolicy[stringToUint(attribute)];\\n\\t}\\n\\n\\tfunction hasAttribute(address account, string memory attribute) public view returns (bool valid) {\\n\\t\\treturn _issuedAttributes[account][stringToUint(attribute)] || _issuedAttributes[account][OWNER_ATTRIBUTE_ID];\\n\\t}\\n\\n\\tfunction hasAttribute(\\n\\t\\tbytes32 messageHash,\\n\\t\\tbytes memory messageHashSignature,\\n\\t\\tstring memory attribute\\n\\t) public view returns (bool valid) {\\n\\t\\treturn hasAttribute(messageHash.recover(messageHashSignature), attribute);\\n\\t}\\n\\n\\tfunction haveAttribute(\\n\\t\\tbytes32 messageHash,\\n\\t\\tbytes[] memory messageHashSignatures,\\n\\t\\tstring memory attribute\\n\\t) public view returns (bool valid) {\\n\\t\\tfor (uint256 index = 0; index < messageHashSignatures.length; index++) {\\n\\t\\t\\tvalid = hasAttribute(messageHash, messageHashSignatures[index], attribute);\\n\\t\\t\\tif (!valid) {\\n\\t\\t\\t\\treturn valid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn valid;\\n\\t}\\n\\n\\tfunction stringToUint(string memory attribute) public pure returns (uint256 attributeID) {\\n\\t\\treturn uint256(keccak256(bytes(attribute)));\\n\\t}\\n\\n\\tfunction _withSignatures(\\n\\t\\tbytes32 paramHash,\\n\\t\\tbytes[] memory messageHashSignatures,\\n\\t\\tstring memory attribute\\n\\t) internal view {\\n\\t\\tbytes32 messageHash = keccak256(abi.encode(address(this), msg.sig, MetaTxUtils.getChainId(), paramHash))\\n\\t\\t\\t.toEthSignedMessageHash();\\n\\t\\trequire(messageHashSignatures.length >= getPolicy(attribute), \\\"insuficient signatures\\\");\\n\\t\\trequire(haveAttribute(messageHash, messageHashSignatures, attribute), \\\"signatures not authorized\\\");\\n\\t}\\n\\n\\t// private\\n\\n\\tfunction _onlyOwnerOrAdmin(\\n\\t\\tbytes32 paramsHash,\\n\\t\\tstring memory attribute,\\n\\t\\tbytes[] memory messageHashSignatures\\n\\t) private view {\\n\\t\\tuint256 attributeID = stringToUint(attribute);\\n\\t\\tif (attributeID == OWNER_ATTRIBUTE_ID || attributeID == ADMIN_ATTRIBUTE_ID) {\\n\\t\\t\\t_withSignatures(paramsHash, messageHashSignatures, OWNER_ATTRIBUTE);\\n\\t\\t} else {\\n\\t\\t\\t_withSignatures(paramsHash, messageHashSignatures, ADMIN_ATTRIBUTE);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _onlyOwnerOrAdmin(string memory attribute) private view {\\n\\t\\tuint256 attributeID = stringToUint(attribute);\\n\\t\\tif (attributeID == OWNER_ATTRIBUTE_ID || attributeID == ADMIN_ATTRIBUTE_ID) {\\n\\t\\t\\trequire(hasAttribute(msg.sender, OWNER_ATTRIBUTE), \\\"not authorized\\\");\\n\\t\\t} else {\\n\\t\\t\\trequire(hasAttribute(msg.sender, ADMIN_ATTRIBUTE), \\\"not authorized\\\");\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n\\t/**\\n\\t * @dev Returns the address that signed a hashed message (`hash`) with\\n\\t * `signature`. This address can then be used for verification purposes.\\n\\t *\\n\\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n\\t * this function rejects them by requiring the `s` value to be in the lower\\n\\t * half order, and the `v` value to be either 27 or 28.\\n\\t *\\n\\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n\\t * verification to be secure: it is possible to craft signatures that\\n\\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n\\t * this is by receiving a hash of the original message (which may otherwise\\n\\t * be too long), and then calling {toEthSignedMessageHash} on it.\\n\\t */\\n\\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n\\t\\t// Check the signature length\\n\\t\\tif (signature.length != 65) {\\n\\t\\t\\trevert(\\\"ECDSA: invalid signature length\\\");\\n\\t\\t}\\n\\n\\t\\t// Divide the signature in r, s and v variables\\n\\t\\tbytes32 r;\\n\\t\\tbytes32 s;\\n\\t\\tuint8 v;\\n\\n\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t// currently is to use assembly.\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\ts := mload(add(signature, 0x40))\\n\\t\\t\\tv := byte(0, mload(add(signature, 0x60)))\\n\\t\\t}\\n\\n\\t\\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n\\t\\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n\\t\\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n\\t\\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n\\t\\t//\\n\\t\\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n\\t\\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n\\t\\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n\\t\\t// these malleable signatures as well.\\n\\t\\tif (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n\\t\\t\\trevert(\\\"ECDSA: invalid signature 's' value\\\");\\n\\t\\t}\\n\\n\\t\\tif (v != 27 && v != 28) {\\n\\t\\t\\trevert(\\\"ECDSA: invalid signature 'v' value\\\");\\n\\t\\t}\\n\\n\\t\\t// If the signature is valid (and not malleable), return the signer address\\n\\t\\taddress signer = ecrecover(hash, v, r, s);\\n\\t\\trequire(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n\\t\\treturn signer;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n\\t * replicates the behavior of the\\n\\t * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n\\t * JSON-RPC method.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n\\t\\t// 32 is the length in bytes of hash,\\n\\t\\t// enforced by the type signature above\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/MetaTxUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"../lib/SafeMath.sol\\\";\\nimport \\\"../lib/BytesLib.sol\\\";\\n\\ncontract MetaTxUtils {\\n\\tusing SafeMath for uint256;\\n\\tusing BytesLib for bytes;\\n\\n\\t/// @dev Get the chain ID constant.\\n\\t/// @return chainId The chain id.\\n\\tfunction getChainId() public pure returns (uint256 chainId) {\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid()\\n\\t\\t}\\n\\t\\treturn chainId;\\n\\t}\\n\\n\\t/// @notice Execute a transaction.\\n\\t/// @param to address Address of the target.\\n\\t/// @param value uint256 Amount of wei to send.\\n\\t/// @param gasLimit uint256 Amount of gas to send.\\n\\t/// @param data bytes Encoded calldata.\\n\\t/// @return returnData bytes Response of the call.\\n\\tfunction _executeTransaction(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tuint256 gasLimit,\\n\\t\\tbytes memory data\\n\\t) internal returns (bytes memory returnData) {\\n\\t\\t// perform external call\\n\\t\\t(bool success, bytes memory res) = to.call{gas: gasLimit, value: value}(data);\\n\\t\\t// Get the revert message of the call and revert with it if the call failed\\n\\t\\tif (!success) {\\n\\t\\t\\tstring memory revertMsg = _getRevertMsg(res);\\n\\t\\t\\trevert(revertMsg);\\n\\t\\t}\\n\\t\\t// return results\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/// @dev Decode transaction data.\\n\\t/// @param transaction Transaction (to, value, gasLimit, data).\\n\\t/// @return to address Address of the target.\\n\\t/// @return value uint256 Amount of wei to send.\\n\\t/// @return gasLimit uint256 Amount of gas to send.\\n\\t/// @return nonce uint256 Unique tx salt.\\n\\t/// @return data bytes Encoded calldata.\\n\\tfunction _decodeTransaction(bytes memory transaction)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (\\n\\t\\t\\taddress to,\\n\\t\\t\\tuint256 value,\\n\\t\\t\\tuint256 gasLimit,\\n\\t\\t\\tuint256 nonce,\\n\\t\\t\\tbytes memory data\\n\\t\\t)\\n\\t{\\n\\t\\treturn abi.decode(transaction, (address, uint256, uint256, uint256, bytes));\\n\\t}\\n\\n\\t/// @notice Get the revert message from a call.\\n\\t/// @param res bytes Response of the call.\\n\\t/// @return revertMessage string Revert message.\\n\\tfunction _getRevertMsg(bytes memory res) internal pure returns (string memory revertMessage) {\\n\\t\\t// If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n\\t\\tif (res.length < 68) return \\\"Transaction reverted silently\\\";\\n\\t\\tbytes memory revertData = res.slice(4, res.length - 4); // Remove the selector which is the first 4 bytes\\n\\t\\treturn abi.decode(revertData, (string)); // All that remains is the revert string\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b <= a, errorMessage);\\n\\t\\tuint256 c = a - b;\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n\\t\\t// benefit is lost if 'b' is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers. Reverts on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn div(a, b, \\\"SafeMath: division by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b > 0, errorMessage);\\n\\t\\tuint256 c = a / b;\\n\\t\\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * Reverts when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * Reverts with custom message when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b != 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\nlibrary BytesLib {\\n\\tfunction concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n\\t\\tbytes memory tempBytes;\\n\\n\\t\\tassembly {\\n\\t\\t\\t// Get a location of some free memory and store it in tempBytes as\\n\\t\\t\\t// Solidity does for memory variables.\\n\\t\\t\\ttempBytes := mload(0x40)\\n\\n\\t\\t\\t// Store the length of the first bytes array at the beginning of\\n\\t\\t\\t// the memory for tempBytes.\\n\\t\\t\\tlet length := mload(_preBytes)\\n\\t\\t\\tmstore(tempBytes, length)\\n\\n\\t\\t\\t// Maintain a memory counter for the current write location in the\\n\\t\\t\\t// temp bytes array by adding the 32 bytes for the array length to\\n\\t\\t\\t// the starting location.\\n\\t\\t\\tlet mc := add(tempBytes, 0x20)\\n\\t\\t\\t// Stop copying when the memory counter reaches the length of the\\n\\t\\t\\t// first bytes array.\\n\\t\\t\\tlet end := add(mc, length)\\n\\n\\t\\t\\tfor {\\n\\t\\t\\t\\t// Initialize a copy counter to the start of the _preBytes data,\\n\\t\\t\\t\\t// 32 bytes into its memory.\\n\\t\\t\\t\\tlet cc := add(_preBytes, 0x20)\\n\\t\\t\\t} lt(mc, end) {\\n\\t\\t\\t\\t// Increase both counters by 32 bytes each iteration.\\n\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\tcc := add(cc, 0x20)\\n\\t\\t\\t} {\\n\\t\\t\\t\\t// Write the _preBytes data into the tempBytes memory 32 bytes\\n\\t\\t\\t\\t// at a time.\\n\\t\\t\\t\\tmstore(mc, mload(cc))\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add the length of _postBytes to the current length of tempBytes\\n\\t\\t\\t// and store it as the new length in the first 32 bytes of the\\n\\t\\t\\t// tempBytes memory.\\n\\t\\t\\tlength := mload(_postBytes)\\n\\t\\t\\tmstore(tempBytes, add(length, mload(tempBytes)))\\n\\n\\t\\t\\t// Move the memory counter back from a multiple of 0x20 to the\\n\\t\\t\\t// actual end of the _preBytes data.\\n\\t\\t\\tmc := end\\n\\t\\t\\t// Stop copying when the memory counter reaches the new combined\\n\\t\\t\\t// length of the arrays.\\n\\t\\t\\tend := add(mc, length)\\n\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tlet cc := add(_postBytes, 0x20)\\n\\t\\t\\t} lt(mc, end) {\\n\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\tcc := add(cc, 0x20)\\n\\t\\t\\t} {\\n\\t\\t\\t\\tmstore(mc, mload(cc))\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update the free-memory pointer by padding our last write location\\n\\t\\t\\t// to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n\\t\\t\\t// next 32 byte block, then round down to the nearest multiple of\\n\\t\\t\\t// 32. If the sum of the length of the two arrays is zero then add\\n\\t\\t\\t// one before rounding down to leave a blank 32 bytes (the length block with 0).\\n\\t\\t\\tmstore(\\n\\t\\t\\t\\t0x40,\\n\\t\\t\\t\\tand(\\n\\t\\t\\t\\t\\tadd(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n\\t\\t\\t\\t\\tnot(31) // Round down to the nearest 32 bytes.\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t}\\n\\n\\t\\treturn tempBytes;\\n\\t}\\n\\n\\tfunction concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n\\t\\tassembly {\\n\\t\\t\\t// Read the first 32 bytes of _preBytes storage, which is the length\\n\\t\\t\\t// of the array. (We don't need to use the offset into the slot\\n\\t\\t\\t// because arrays use the entire slot.)\\n\\t\\t\\tlet fslot := sload(_preBytes_slot)\\n\\t\\t\\t// Arrays of 31 bytes or less have an even value in their slot,\\n\\t\\t\\t// while longer arrays have an odd value. The actual length is\\n\\t\\t\\t// the slot divided by two for odd values, and the lowest order\\n\\t\\t\\t// byte divided by two for even values.\\n\\t\\t\\t// If the slot is even, bitwise and the slot with 255 and divide by\\n\\t\\t\\t// two to get the length. If the slot is odd, bitwise and the slot\\n\\t\\t\\t// with -1 and divide by two.\\n\\t\\t\\tlet slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n\\t\\t\\tlet mlength := mload(_postBytes)\\n\\t\\t\\tlet newlength := add(slength, mlength)\\n\\t\\t\\t// slength can contain both the length and contents of the array\\n\\t\\t\\t// if length < 32 bytes so let's prepare for that\\n\\t\\t\\t// v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n\\t\\t\\tswitch add(lt(slength, 32), lt(newlength, 32))\\n\\t\\t\\t\\tcase 2 {\\n\\t\\t\\t\\t\\t// Since the new array still fits in the slot, we just need to\\n\\t\\t\\t\\t\\t// update the contents of the slot.\\n\\t\\t\\t\\t\\t// uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n\\t\\t\\t\\t\\tsstore(\\n\\t\\t\\t\\t\\t\\t_preBytes_slot,\\n\\t\\t\\t\\t\\t\\t// all the modifications to the slot are inside this\\n\\t\\t\\t\\t\\t\\t// next block\\n\\t\\t\\t\\t\\t\\tadd(\\n\\t\\t\\t\\t\\t\\t\\t// we can just add to the slot contents because the\\n\\t\\t\\t\\t\\t\\t\\t// bytes we want to change are the LSBs\\n\\t\\t\\t\\t\\t\\t\\tfslot,\\n\\t\\t\\t\\t\\t\\t\\tadd(\\n\\t\\t\\t\\t\\t\\t\\t\\tmul(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdiv(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// load the bytes from memory\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmload(add(_postBytes, 0x20)),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// zero all bytes to the right\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\texp(0x100, sub(32, mlength))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// and now shift left the number of bytes to\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// leave space for the length in the slot\\n\\t\\t\\t\\t\\t\\t\\t\\t\\texp(0x100, sub(32, newlength))\\n\\t\\t\\t\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\t\\t\\t\\t// increase length by the double of the memory\\n\\t\\t\\t\\t\\t\\t\\t\\t// bytes length\\n\\t\\t\\t\\t\\t\\t\\t\\tmul(mlength, 2)\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcase 1 {\\n\\t\\t\\t\\t\\t// The stored value fits in the slot, but the combined value\\n\\t\\t\\t\\t\\t// will exceed it.\\n\\t\\t\\t\\t\\t// get the keccak hash to get the contents of the array\\n\\t\\t\\t\\t\\tmstore(0x0, _preBytes_slot)\\n\\t\\t\\t\\t\\tlet sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n\\t\\t\\t\\t\\t// save new length\\n\\t\\t\\t\\t\\tsstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n\\t\\t\\t\\t\\t// The contents of the _postBytes array start 32 bytes into\\n\\t\\t\\t\\t\\t// the structure. Our first read should obtain the `submod`\\n\\t\\t\\t\\t\\t// bytes that can fit into the unused space in the last word\\n\\t\\t\\t\\t\\t// of the stored array. To get this, we read 32 bytes starting\\n\\t\\t\\t\\t\\t// from `submod`, so the data we read overlaps with the array\\n\\t\\t\\t\\t\\t// contents by `submod` bytes. Masking the lowest-order\\n\\t\\t\\t\\t\\t// `submod` bytes allows us to add that value directly to the\\n\\t\\t\\t\\t\\t// stored value.\\n\\n\\t\\t\\t\\t\\tlet submod := sub(32, slength)\\n\\t\\t\\t\\t\\tlet mc := add(_postBytes, submod)\\n\\t\\t\\t\\t\\tlet end := add(_postBytes, mlength)\\n\\t\\t\\t\\t\\tlet mask := sub(exp(0x100, submod), 1)\\n\\n\\t\\t\\t\\t\\tsstore(\\n\\t\\t\\t\\t\\t\\tsc,\\n\\t\\t\\t\\t\\t\\tadd(\\n\\t\\t\\t\\t\\t\\t\\tand(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n\\t\\t\\t\\t\\t\\t\\tand(mload(mc), mask)\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\n\\t\\t\\t\\t\\tfor {\\n\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\t\\t\\tsc := add(sc, 1)\\n\\t\\t\\t\\t\\t} lt(mc, end) {\\n\\t\\t\\t\\t\\t\\tsc := add(sc, 1)\\n\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\t\\t} {\\n\\t\\t\\t\\t\\t\\tsstore(sc, mload(mc))\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmask := exp(0x100, sub(mc, end))\\n\\n\\t\\t\\t\\t\\tsstore(sc, mul(div(mload(mc), mask), mask))\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdefault {\\n\\t\\t\\t\\t\\t// get the keccak hash to get the contents of the array\\n\\t\\t\\t\\t\\tmstore(0x0, _preBytes_slot)\\n\\t\\t\\t\\t\\t// Start copying to the last used word of the stored array.\\n\\t\\t\\t\\t\\tlet sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n\\t\\t\\t\\t\\t// save new length\\n\\t\\t\\t\\t\\tsstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n\\t\\t\\t\\t\\t// Copy over the first `submod` bytes of the new data as in\\n\\t\\t\\t\\t\\t// case 1 above.\\n\\t\\t\\t\\t\\tlet slengthmod := mod(slength, 32)\\n\\t\\t\\t\\t\\tlet mlengthmod := mod(mlength, 32)\\n\\t\\t\\t\\t\\tlet submod := sub(32, slengthmod)\\n\\t\\t\\t\\t\\tlet mc := add(_postBytes, submod)\\n\\t\\t\\t\\t\\tlet end := add(_postBytes, mlength)\\n\\t\\t\\t\\t\\tlet mask := sub(exp(0x100, submod), 1)\\n\\n\\t\\t\\t\\t\\tsstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n\\t\\t\\t\\t\\tfor {\\n\\t\\t\\t\\t\\t\\tsc := add(sc, 1)\\n\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\t\\t} lt(mc, end) {\\n\\t\\t\\t\\t\\t\\tsc := add(sc, 1)\\n\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\t\\t} {\\n\\t\\t\\t\\t\\t\\tsstore(sc, mload(mc))\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmask := exp(0x100, sub(mc, end))\\n\\n\\t\\t\\t\\t\\tsstore(sc, mul(div(mload(mc), mask), mask))\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction slice(\\n\\t\\tbytes memory _bytes,\\n\\t\\tuint256 _start,\\n\\t\\tuint256 _length\\n\\t) internal pure returns (bytes memory) {\\n\\t\\trequire(_bytes.length >= (_start + _length));\\n\\n\\t\\tbytes memory tempBytes;\\n\\n\\t\\tassembly {\\n\\t\\t\\tswitch iszero(_length)\\n\\t\\t\\t\\tcase 0 {\\n\\t\\t\\t\\t\\t// Get a location of some free memory and store it in tempBytes as\\n\\t\\t\\t\\t\\t// Solidity does for memory variables.\\n\\t\\t\\t\\t\\ttempBytes := mload(0x40)\\n\\n\\t\\t\\t\\t\\t// The first word of the slice result is potentially a partial\\n\\t\\t\\t\\t\\t// word read from the original array. To read it, we calculate\\n\\t\\t\\t\\t\\t// the length of that partial word and start copying that many\\n\\t\\t\\t\\t\\t// bytes into the array. The first word we copy will start with\\n\\t\\t\\t\\t\\t// data we don't care about, but the last `lengthmod` bytes will\\n\\t\\t\\t\\t\\t// land at the beginning of the contents of the new array. When\\n\\t\\t\\t\\t\\t// we're done copying, we overwrite the full first word with\\n\\t\\t\\t\\t\\t// the actual length of the slice.\\n\\t\\t\\t\\t\\tlet lengthmod := and(_length, 31)\\n\\n\\t\\t\\t\\t\\t// The multiplication in the next line is necessary\\n\\t\\t\\t\\t\\t// because when slicing multiples of 32 bytes (lengthmod == 0)\\n\\t\\t\\t\\t\\t// the following copy loop was copying the origin's length\\n\\t\\t\\t\\t\\t// and then ending prematurely not copying everything it should.\\n\\t\\t\\t\\t\\tlet mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n\\t\\t\\t\\t\\tlet end := add(mc, _length)\\n\\n\\t\\t\\t\\t\\tfor {\\n\\t\\t\\t\\t\\t\\t// The multiplication in the next line has the same exact purpose\\n\\t\\t\\t\\t\\t\\t// as the one above.\\n\\t\\t\\t\\t\\t\\tlet cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n\\t\\t\\t\\t\\t} lt(mc, end) {\\n\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\t\\t\\tcc := add(cc, 0x20)\\n\\t\\t\\t\\t\\t} {\\n\\t\\t\\t\\t\\t\\tmstore(mc, mload(cc))\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmstore(tempBytes, _length)\\n\\n\\t\\t\\t\\t\\t//update free-memory pointer\\n\\t\\t\\t\\t\\t//allocating the array padded to 32 bytes like the compiler does now\\n\\t\\t\\t\\t\\tmstore(0x40, and(add(mc, 31), not(31)))\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//if we want a zero-length slice let's just return a zero-length array\\n\\t\\t\\t\\tdefault {\\n\\t\\t\\t\\t\\ttempBytes := mload(0x40)\\n\\n\\t\\t\\t\\t\\tmstore(0x40, add(tempBytes, 0x20))\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn tempBytes;\\n\\t}\\n\\n\\tfunction toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n\\t\\trequire(_bytes.length >= (_start + 20));\\n\\t\\taddress tempAddress;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n\\t\\t}\\n\\n\\t\\treturn tempAddress;\\n\\t}\\n\\n\\tfunction toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n\\t\\trequire(_bytes.length >= (_start + 1));\\n\\t\\tuint8 tempUint;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x1), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempUint;\\n\\t}\\n\\n\\tfunction toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n\\t\\trequire(_bytes.length >= (_start + 2));\\n\\t\\tuint16 tempUint;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x2), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempUint;\\n\\t}\\n\\n\\tfunction toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n\\t\\trequire(_bytes.length >= (_start + 4));\\n\\t\\tuint32 tempUint;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x4), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempUint;\\n\\t}\\n\\n\\tfunction toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n\\t\\trequire(_bytes.length >= (_start + 8));\\n\\t\\tuint64 tempUint;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x8), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempUint;\\n\\t}\\n\\n\\tfunction toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n\\t\\trequire(_bytes.length >= (_start + 12));\\n\\t\\tuint96 tempUint;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0xc), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempUint;\\n\\t}\\n\\n\\tfunction toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n\\t\\trequire(_bytes.length >= (_start + 16));\\n\\t\\tuint128 tempUint;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x10), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempUint;\\n\\t}\\n\\n\\tfunction toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n\\t\\trequire(_bytes.length >= (_start + 32));\\n\\t\\tuint256 tempUint;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x20), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempUint;\\n\\t}\\n\\n\\tfunction toBytes4(bytes memory _bytes, uint256 _start) internal pure returns (bytes4) {\\n\\t\\trequire(_bytes.length >= (_start + 4));\\n\\t\\tbytes4 tempBytes4;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempBytes4 := mload(add(add(_bytes, 0x20), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempBytes4;\\n\\t}\\n\\n\\tfunction toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n\\t\\trequire(_bytes.length >= (_start + 32));\\n\\t\\tbytes32 tempBytes32;\\n\\n\\t\\tassembly {\\n\\t\\t\\ttempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n\\t\\t}\\n\\n\\t\\treturn tempBytes32;\\n\\t}\\n\\n\\tfunction equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n\\t\\tbool success = true;\\n\\n\\t\\tassembly {\\n\\t\\t\\tlet length := mload(_preBytes)\\n\\n\\t\\t\\t// if lengths don't match the arrays are not equal\\n\\t\\t\\tswitch eq(length, mload(_postBytes))\\n\\t\\t\\t\\tcase 1 {\\n\\t\\t\\t\\t\\t// cb is a circuit breaker in the for loop since there's\\n\\t\\t\\t\\t\\t//  no said feature for inline assembly loops\\n\\t\\t\\t\\t\\t// cb = 1 - don't breaker\\n\\t\\t\\t\\t\\t// cb = 0 - break\\n\\t\\t\\t\\t\\tlet cb := 1\\n\\n\\t\\t\\t\\t\\tlet mc := add(_preBytes, 0x20)\\n\\t\\t\\t\\t\\tlet end := add(mc, length)\\n\\n\\t\\t\\t\\t\\tfor {\\n\\t\\t\\t\\t\\t\\tlet cc := add(_postBytes, 0x20)\\n\\t\\t\\t\\t\\t\\t// the next line is the loop condition:\\n\\t\\t\\t\\t\\t\\t// while(uint(mc < end) + cb == 2)\\n\\t\\t\\t\\t\\t} eq(add(lt(mc, end), cb), 2) {\\n\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\t\\t\\tcc := add(cc, 0x20)\\n\\t\\t\\t\\t\\t} {\\n\\t\\t\\t\\t\\t\\t// if any of these checks fails then arrays are not equal\\n\\t\\t\\t\\t\\t\\tif iszero(eq(mload(mc), mload(cc))) {\\n\\t\\t\\t\\t\\t\\t\\t// unsuccess:\\n\\t\\t\\t\\t\\t\\t\\tsuccess := 0\\n\\t\\t\\t\\t\\t\\t\\tcb := 0\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdefault {\\n\\t\\t\\t\\t\\t// unsuccess:\\n\\t\\t\\t\\t\\tsuccess := 0\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn success;\\n\\t}\\n\\n\\tfunction equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n\\t\\tbool success = true;\\n\\n\\t\\tassembly {\\n\\t\\t\\t// we know _preBytes_offset is 0\\n\\t\\t\\tlet fslot := sload(_preBytes_slot)\\n\\t\\t\\t// Decode the length of the stored array like in concatStorage().\\n\\t\\t\\tlet slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n\\t\\t\\tlet mlength := mload(_postBytes)\\n\\n\\t\\t\\t// if lengths don't match the arrays are not equal\\n\\t\\t\\tswitch eq(slength, mlength)\\n\\t\\t\\t\\tcase 1 {\\n\\t\\t\\t\\t\\t// slength can contain both the length and contents of the array\\n\\t\\t\\t\\t\\t// if length < 32 bytes so let's prepare for that\\n\\t\\t\\t\\t\\t// v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n\\t\\t\\t\\t\\tif iszero(iszero(slength)) {\\n\\t\\t\\t\\t\\t\\tswitch lt(slength, 32)\\n\\t\\t\\t\\t\\t\\t\\tcase 1 {\\n\\t\\t\\t\\t\\t\\t\\t\\t// blank the last byte which is the length\\n\\t\\t\\t\\t\\t\\t\\t\\tfslot := mul(div(fslot, 0x100), 0x100)\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// unsuccess:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tsuccess := 0\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tdefault {\\n\\t\\t\\t\\t\\t\\t\\t\\t// cb is a circuit breaker in the for loop since there's\\n\\t\\t\\t\\t\\t\\t\\t\\t//  no said feature for inline assembly loops\\n\\t\\t\\t\\t\\t\\t\\t\\t// cb = 1 - don't breaker\\n\\t\\t\\t\\t\\t\\t\\t\\t// cb = 0 - break\\n\\t\\t\\t\\t\\t\\t\\t\\tlet cb := 1\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// get the keccak hash to get the contents of the array\\n\\t\\t\\t\\t\\t\\t\\t\\tmstore(0x0, _preBytes_slot)\\n\\t\\t\\t\\t\\t\\t\\t\\tlet sc := keccak256(0x0, 0x20)\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tlet mc := add(_postBytes, 0x20)\\n\\t\\t\\t\\t\\t\\t\\t\\tlet end := add(mc, mlength)\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// the next line is the loop condition:\\n\\t\\t\\t\\t\\t\\t\\t\\t// while(uint(mc < end) + cb == 2)\\n\\t\\t\\t\\t\\t\\t\\t\\tfor {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} eq(add(lt(mc, end), cb), 2) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tsc := add(sc, 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\n\\t\\t\\t\\t\\t\\t\\t\\t} {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif iszero(eq(sload(sc), mload(mc))) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// unsuccess:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsuccess := 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcb := 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdefault {\\n\\t\\t\\t\\t\\t// unsuccess:\\n\\t\\t\\t\\t\\tsuccess := 0\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn success;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/TokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"../standard/ERC721/ERC721Holder.sol\\\";\\nimport \\\"../standard/ERC1155/ERC1155Receiver.sol\\\";\\nimport \\\"../standard/ERC721/IERC721.sol\\\";\\nimport \\\"../standard/ERC777/IERC777.sol\\\";\\nimport \\\"../standard/ERC1155/IERC1155.sol\\\";\\nimport \\\"../standard/ERC20/IERC20.sol\\\";\\nimport \\\"./ETHRecipient.sol\\\";\\n\\ncontract TokenManager is ETHRecipient, ERC721Holder, ERC1155Receiver {\\n\\tfunction _sendETH(address payable to, uint256 amount) internal {\\n\\t\\tto.transfer(amount);\\n\\t}\\n\\n\\tfunction _sendERC20(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal {\\n\\t\\trequire(IERC20(token).transfer(to, amount), \\\"ERC20 transfer failed\\\");\\n\\t}\\n\\n\\tfunction _sendERC721(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) internal {\\n\\t\\tIERC721(token).safeTransferFrom(address(this), to, tokenId);\\n\\t}\\n\\n\\tfunction _sendERC777(\\n\\t\\taddress token,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount,\\n\\t\\tbytes memory data\\n\\t) internal {\\n\\t\\tIERC777(token).send(recipient, amount, data);\\n\\t}\\n\\n\\tfunction _sendERC1155(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 id,\\n\\t\\tuint256 amount,\\n\\t\\tbytes memory data\\n\\t) internal {\\n\\t\\tIERC1155(token).safeTransferFrom(address(this), to, id, amount, data);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC721/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n\\t/**\\n\\t * @dev See {IERC721Receiver-onERC721Received}.\\n\\t *\\n\\t * Always returns `IERC721Receiver.onERC721Received.selector`.\\n\\t */\\n\\tfunction onERC721Received(\\n\\t\\taddress,\\n\\t\\taddress,\\n\\t\\tuint256,\\n\\t\\tbytes calldata\\n\\t) external virtual override returns (bytes4) {\\n\\t\\treturn this.onERC721Received.selector;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n\\t/**\\n\\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n\\t * by `operator` from `from`, this function is called.\\n\\t *\\n\\t * It must return its Solidity selector to confirm the token transfer.\\n\\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n\\t *\\n\\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n\\t */\\n\\tfunction onERC721Received(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\tuint256 tokenId,\\n\\t\\tbytes calldata data\\n\\t) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC1155/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../ERC165/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Receiver is ERC165, IERC1155Receiver {\\n\\tconstructor() public {\\n\\t\\t_registerInterface(\\n\\t\\t\\tERC1155Receiver(0).onERC1155Received.selector ^ ERC1155Receiver(0).onERC1155BatchReceived.selector\\n\\t\\t);\\n\\t}\\n\\n\\tfunction onERC1155Received(\\n\\t\\taddress,\\n\\t\\taddress,\\n\\t\\tuint256,\\n\\t\\tuint256,\\n\\t\\tbytes calldata\\n\\t) external virtual override returns (bytes4) {\\n\\t\\treturn this.onERC1155Received.selector;\\n\\t}\\n\\n\\tfunction onERC1155BatchReceived(\\n\\t\\taddress,\\n\\t\\taddress,\\n\\t\\tuint256[] calldata,\\n\\t\\tuint256[] calldata,\\n\\t\\tbytes calldata\\n\\t) external virtual override returns (bytes4) {\\n\\t\\treturn this.onERC1155BatchReceived.selector;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"../ERC165/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\t/**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n\\tfunction onERC1155Received(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\tuint256 id,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external returns (bytes4);\\n\\n\\t/**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n\\tfunction onERC1155BatchReceived(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\tuint256[] calldata ids,\\n\\t\\tuint256[] calldata values,\\n\\t\\tbytes calldata data\\n\\t) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC165/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n\\t/**\\n\\t * @dev Returns true if this contract implements the interface defined by\\n\\t * `interfaceId`. See the corresponding\\n\\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n\\t * to learn more about how these ids are created.\\n\\t *\\n\\t * This function call must use less than 30 000 gas.\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC165/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n\\t/*\\n\\t * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n\\t */\\n\\tbytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n\\t/**\\n\\t * @dev Mapping of interface ids to whether or not it's supported.\\n\\t */\\n\\tmapping(bytes4 => bool) private _supportedInterfaces;\\n\\n\\tconstructor() internal {\\n\\t\\t// Derived contracts need only register support for their own interfaces,\\n\\t\\t// we register support for ERC165 itself here\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC165);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC165-supportsInterface}.\\n\\t *\\n\\t * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) public override view returns (bool) {\\n\\t\\treturn _supportedInterfaces[interfaceId];\\n\\t}\\n\\n\\t/**\\n\\t * @dev Registers the contract as an implementer of the interface defined by\\n\\t * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n\\t * registering its interface id is not required.\\n\\t *\\n\\t * See {IERC165-supportsInterface}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n\\t */\\n\\tfunction _registerInterface(bytes4 interfaceId) internal virtual {\\n\\t\\trequire(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n\\t\\t_supportedInterfaces[interfaceId] = true;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"../ERC165/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n\\t/**\\n\\t * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n\\t/**\\n\\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n\\t/**\\n\\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n\\t */\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\t/**\\n\\t * @dev Returns the number of tokens in ``owner``'s account.\\n\\t */\\n\\tfunction balanceOf(address owner) external view returns (uint256 balance);\\n\\n\\t/**\\n\\t * @dev Returns the owner of the `tokenId` token.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must exist.\\n\\t */\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n\\t/**\\n\\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n\\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `from` cannot be the zero address.\\n\\t * - `to` cannot be the zero address.\\n\\t * - `tokenId` token must exist and be owned by `from`.\\n\\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction safeTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Transfers `tokenId` token from `from` to `to`.\\n\\t *\\n\\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `from` cannot be the zero address.\\n\\t * - `to` cannot be the zero address.\\n\\t * - `tokenId` token must be owned by `from`.\\n\\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n\\t * The approval is cleared when the token is transferred.\\n\\t *\\n\\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The caller must own the token or be an approved operator.\\n\\t * - `tokenId` must exist.\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address to, uint256 tokenId) external;\\n\\n\\t/**\\n\\t * @dev Returns the account approved for `tokenId` token.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must exist.\\n\\t */\\n\\tfunction getApproved(uint256 tokenId) external view returns (address operator);\\n\\n\\t/**\\n\\t * @dev Approve or remove `operator` as an operator for the caller.\\n\\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The `operator` cannot be the caller.\\n\\t *\\n\\t * Emits an {ApprovalForAll} event.\\n\\t */\\n\\tfunction setApprovalForAll(address operator, bool _approved) external;\\n\\n\\t/**\\n\\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n\\t *\\n\\t * See {setApprovalForAll}\\n\\t */\\n\\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev Safely transfers `tokenId` token from `from` to `to`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `from` cannot be the zero address.\\n\\t * - `to` cannot be the zero address.\\n\\t * - `tokenId` token must exist and be owned by `from`.\\n\\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction safeTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId,\\n\\t\\tbytes calldata data\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC777/IERC777.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n\\t/**\\n\\t * @dev Returns the name of the token.\\n\\t */\\n\\tfunction name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the symbol of the token, usually a shorter version of the\\n\\t * name.\\n\\t */\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the smallest part of the token that is not divisible. This\\n\\t * means all token operations (creation, movement and destruction) must have\\n\\t * amounts that are a multiple of this number.\\n\\t *\\n\\t * For most token contracts, this value will equal 1.\\n\\t */\\n\\tfunction granularity() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens in existence.\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens owned by an account (`owner`).\\n\\t */\\n\\tfunction balanceOf(address owner) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n\\t *\\n\\t * If send or receive hooks are registered for the caller and `recipient`,\\n\\t * the corresponding functions will be called with `data` and empty\\n\\t * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n\\t *\\n\\t * Emits a {Sent} event.\\n\\t *\\n\\t * Requirements\\n\\t *\\n\\t * - the caller must have at least `amount` tokens.\\n\\t * - `recipient` cannot be the zero address.\\n\\t * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n\\t * interface.\\n\\t */\\n\\tfunction send(\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount,\\n\\t\\tbytes calldata data\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Destroys `amount` tokens from the caller's account, reducing the\\n\\t * total supply.\\n\\t *\\n\\t * If a send hook is registered for the caller, the corresponding function\\n\\t * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n\\t *\\n\\t * Emits a {Burned} event.\\n\\t *\\n\\t * Requirements\\n\\t *\\n\\t * - the caller must have at least `amount` tokens.\\n\\t */\\n\\tfunction burn(uint256 amount, bytes calldata data) external;\\n\\n\\t/**\\n\\t * @dev Returns true if an account is an operator of `tokenHolder`.\\n\\t * Operators can send and burn tokens on behalf of their owners. All\\n\\t * accounts are their own operator.\\n\\t *\\n\\t * See {operatorSend} and {operatorBurn}.\\n\\t */\\n\\tfunction isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev Make an account an operator of the caller.\\n\\t *\\n\\t * See {isOperatorFor}.\\n\\t *\\n\\t * Emits an {AuthorizedOperator} event.\\n\\t *\\n\\t * Requirements\\n\\t *\\n\\t * - `operator` cannot be calling address.\\n\\t */\\n\\tfunction authorizeOperator(address operator) external;\\n\\n\\t/**\\n\\t * @dev Revoke an account's operator status for the caller.\\n\\t *\\n\\t * See {isOperatorFor} and {defaultOperators}.\\n\\t *\\n\\t * Emits a {RevokedOperator} event.\\n\\t *\\n\\t * Requirements\\n\\t *\\n\\t * - `operator` cannot be calling address.\\n\\t */\\n\\tfunction revokeOperator(address operator) external;\\n\\n\\t/**\\n\\t * @dev Returns the list of default operators. These accounts are operators\\n\\t * for all token holders, even if {authorizeOperator} was never called on\\n\\t * them.\\n\\t *\\n\\t * This list is immutable, but individual holders may revoke these via\\n\\t * {revokeOperator}, in which case {isOperatorFor} will return false.\\n\\t */\\n\\tfunction defaultOperators() external view returns (address[] memory);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n\\t * be an operator of `sender`.\\n\\t *\\n\\t * If send or receive hooks are registered for `sender` and `recipient`,\\n\\t * the corresponding functions will be called with `data` and\\n\\t * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n\\t *\\n\\t * Emits a {Sent} event.\\n\\t *\\n\\t * Requirements\\n\\t *\\n\\t * - `sender` cannot be the zero address.\\n\\t * - `sender` must have at least `amount` tokens.\\n\\t * - the caller must be an operator for `sender`.\\n\\t * - `recipient` cannot be the zero address.\\n\\t * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n\\t * interface.\\n\\t */\\n\\tfunction operatorSend(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n\\t * The caller must be an operator of `account`.\\n\\t *\\n\\t * If a send hook is registered for `account`, the corresponding function\\n\\t * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n\\t *\\n\\t * Emits a {Burned} event.\\n\\t *\\n\\t * Requirements\\n\\t *\\n\\t * - `account` cannot be the zero address.\\n\\t * - `account` must have at least `amount` tokens.\\n\\t * - the caller must be an operator for `account`.\\n\\t */\\n\\tfunction operatorBurn(\\n\\t\\taddress account,\\n\\t\\tuint256 amount,\\n\\t\\tbytes calldata data,\\n\\t\\tbytes calldata operatorData\\n\\t) external;\\n\\n\\tevent Sent(\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 amount,\\n\\t\\tbytes data,\\n\\t\\tbytes operatorData\\n\\t);\\n\\n\\tevent Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n\\tevent Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n\\tevent AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n\\tevent RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"../ERC165/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n\\t/**\\n\\t * @dev Emitted when `value` tokens of token type `id` are transfered from `from` to `to` by `operator`.\\n\\t */\\n\\tevent TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n\\t/**\\n\\t * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n\\t * transfers.\\n\\t */\\n\\tevent TransferBatch(\\n\\t\\taddress indexed operator,\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256[] ids,\\n\\t\\tuint256[] values\\n\\t);\\n\\n\\t/**\\n\\t * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n\\t * `approved`.\\n\\t */\\n\\tevent ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n\\t/**\\n\\t * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n\\t *\\n\\t * If an {URI} event was emitted for `id`, the standard\\n\\t * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n\\t * returned by {IERC1155MetadataURI-uri}.\\n\\t */\\n\\tevent URI(string value, uint256 indexed id);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `account` cannot be the zero address.\\n\\t */\\n\\tfunction balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `accounts` and `ids` must have the same length.\\n\\t */\\n\\tfunction balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256[] memory);\\n\\n\\t/**\\n\\t * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n\\t *\\n\\t * Emits an {ApprovalForAll} event.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `operator` cannot be the caller.\\n\\t */\\n\\tfunction setApprovalForAll(address operator, bool approved) external;\\n\\n\\t/**\\n\\t * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n\\t *\\n\\t * See {setApprovalForAll}.\\n\\t */\\n\\tfunction isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n\\t *\\n\\t * Emits a {TransferSingle} event.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `to` cannot be the zero address.\\n\\t * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n\\t * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n\\t * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n\\t * acceptance magic value.\\n\\t */\\n\\tfunction safeTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 id,\\n\\t\\tuint256 amount,\\n\\t\\tbytes calldata data\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n\\t *\\n\\t * Emits a {TransferBatch} event.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `ids` and `amounts` must have the same length.\\n\\t * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n\\t * acceptance magic value.\\n\\t */\\n\\tfunction safeBatchTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256[] calldata ids,\\n\\t\\tuint256[] calldata amounts,\\n\\t\\tbytes calldata data\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n\\t/**\\n\\t * @dev Returns the amount of tokens in existence.\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens owned by `account`.\\n\\t */\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Returns the remaining number of tokens that `spender` will be\\n\\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n\\t * zero by default.\\n\\t *\\n\\t * This value changes when {approve} or {transferFrom} are called.\\n\\t */\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n\\t * that someone may use both the old and the new allowance by unfortunate\\n\\t * transaction ordering. One possible solution to mitigate this race\\n\\t * condition is to first reduce the spender's allowance to 0 and set the\\n\\t * desired value afterwards:\\n\\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n\\t * allowance mechanism. `amount` is then deducted from the caller's\\n\\t * allowance.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n\\t * another (`to`).\\n\\t *\\n\\t * Note that `value` may be zero.\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n\\t * a call to {approve}. `value` is the new allowance.\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/ETHRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\ncontract ETHRecipient {\\n\\tevent ReceivedETH();\\n\\n\\treceive() external payable {\\n\\t\\temit ReceivedETH();\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/factory/BaseTemplate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/// @title BaseTemplate\\n/// @author Stephane Gosselin (@thegostep)\\ncontract BaseTemplate {\\n\\t/// @notice Modifier which only allows to be `DELEGATECALL`ed from within a constructor on initialization of the contract.\\n\\tmodifier initializeTemplate() {\\n\\t\\t// only allow function to be `DELEGATECALL`ed from within a constructor.\\n\\t\\tuint32 codeSize;\\n\\t\\tassembly {\\n\\t\\t\\tcodeSize := extcodesize(address())\\n\\t\\t}\\n\\t\\trequire(codeSize == 0, \\\"must be called within contract constructor\\\");\\n\\t\\t_;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IUserWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IUserWallet {\\n\\tfunction executeTransaction(bytes calldata transaction, bytes[] calldata signatures)\\n\\t\\texternal\\n\\t\\treturns (bytes memory returnData);\\n}\\n\"\r\n    },\r\n    \"contracts/factory/Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./Spawner.sol\\\";\\n\\ncontract Factory is Spawner {\\n\\tevent InstanceCreated(address instance, address template);\\n\\n\\tfunction create(address template, bytes memory args) public returns (address instance) {\\n\\t\\tinstance = Spawner._spawn(msg.sender, template, args);\\n\\t\\temit InstanceCreated(instance, template);\\n\\t}\\n\\n\\tfunction createSalty(\\n\\t\\taddress template,\\n\\t\\tbytes memory args,\\n\\t\\tbytes32 salt\\n\\t) public returns (address instance) {\\n\\t\\tinstance = Spawner._spawnSalty(msg.sender, template, args, salt);\\n\\t\\temit InstanceCreated(instance, template);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/factory/Spawner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/// @title Spawn\\n/// @author 0age and thegostep\\n/// @notice This contract provides creation code that is used by Spawner in order\\n/// to initialize and deploy eip-1167 minimal proxies for a given logic contract.\\ncontract Spawn {\\n\\tconstructor(address logicContract, bytes memory initializationCalldata) public payable {\\n\\t\\t// delegatecall into the logic contract to perform initialization.\\n\\t\\t(bool ok, ) = logicContract.delegatecall(initializationCalldata);\\n\\t\\tif (!ok) {\\n\\t\\t\\t// pass along failure message from delegatecall and revert.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\treturndatacopy(0, 0, returndatasize())\\n\\t\\t\\t\\trevert(0, returndatasize())\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// place eip-1167 runtime code in memory.\\n\\t\\tbytes memory runtimeCode = abi.encodePacked(\\n\\t\\t\\tbytes10(0x363d3d373d3d3d363d73),\\n\\t\\t\\tlogicContract,\\n\\t\\t\\tbytes15(0x5af43d82803e903d91602b57fd5bf3)\\n\\t\\t);\\n\\n\\t\\t// return eip-1167 code to write it to spawned contract runtime.\\n\\t\\tassembly {\\n\\t\\t\\treturn(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\\n\\t\\t}\\n\\t}\\n}\\n\\n/// @title Spawner\\n/// @author 0age and thegostep\\n/// @notice This contract spawns and initializes eip-1167 minimal proxies that\\n/// point to existing logic contracts. The logic contracts need to have an\\n/// initializer function that should only callable when no contract exists at\\n/// their current address (i.e. it is being `DELEGATECALL`ed from a constructor).\\ncontract Spawner {\\n\\t/// @notice Internal function for spawning an eip-1167 minimal proxy using `CREATE2`.\\n\\t/// @param creator address The address of the account creating the proxy.\\n\\t/// @param logicContract address The address of the logic contract.\\n\\t/// @param initializationCalldata bytes The calldata that will be supplied to\\n\\t/// the `DELEGATECALL` from the spawned contract to the logic contract during\\n\\t/// contract creation.\\n\\t/// @return spawnedContract The address of the newly-spawned contract.\\n\\tfunction _spawn(\\n\\t\\taddress creator,\\n\\t\\taddress logicContract,\\n\\t\\tbytes memory initializationCalldata\\n\\t) internal returns (address spawnedContract) {\\n\\t\\t// get instance code and hash\\n\\n\\t\\tbytes memory initCode;\\n\\t\\tbytes32 initCodeHash;\\n\\t\\t(initCode, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\\n\\n\\t\\t// get valid create2 target\\n\\n\\t\\t(address target, bytes32 safeSalt) = _getNextNonceTargetWithInitCodeHash(creator, initCodeHash);\\n\\n\\t\\t// spawn create2 instance and validate\\n\\n\\t\\treturn _executeSpawnCreate2(initCode, safeSalt, target);\\n\\t}\\n\\n\\t/// @notice Internal function for spawning an eip-1167 minimal proxy using `CREATE2`.\\n\\t/// @param creator address The address of the account creating the proxy.\\n\\t/// @param logicContract address The address of the logic contract.\\n\\t/// @param initializationCalldata bytes The calldata that will be supplied to\\n\\t/// the `DELEGATECALL` from the spawned contract to the logic contract during\\n\\t/// contract creation.\\n\\t/// @param salt bytes32 A user defined salt.\\n\\t/// @return spawnedContract The address of the newly-spawned contract.\\n\\tfunction _spawnSalty(\\n\\t\\taddress creator,\\n\\t\\taddress logicContract,\\n\\t\\tbytes memory initializationCalldata,\\n\\t\\tbytes32 salt\\n\\t) internal returns (address spawnedContract) {\\n\\t\\t// get instance code and hash\\n\\n\\t\\tbytes memory initCode;\\n\\t\\tbytes32 initCodeHash;\\n\\t\\t(initCode, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\\n\\n\\t\\t// get valid create2 target\\n\\n\\t\\t(address target, bytes32 safeSalt, bool validity) = _getSaltyTargetWithInitCodeHash(\\n\\t\\t\\tcreator,\\n\\t\\t\\tinitCodeHash,\\n\\t\\t\\tsalt\\n\\t\\t);\\n\\t\\trequire(validity, \\\"contract already deployed with supplied salt\\\");\\n\\n\\t\\t// spawn create2 instance and validate\\n\\n\\t\\treturn _executeSpawnCreate2(initCode, safeSalt, target);\\n\\t}\\n\\n\\t/// @notice Private function for spawning an eip-1167 minimal proxy using `CREATE2`.\\n\\t/// Reverts with appropriate error string if deployment is unsuccessful.\\n\\t/// @param initCode bytes The spawner code and initialization calldata.\\n\\t/// @param safeSalt bytes32 A valid salt hashed with creator address.\\n\\t/// @param target address The expected address of the proxy.\\n\\t/// @return spawnedContract The address of the newly-spawned contract.\\n\\tfunction _executeSpawnCreate2(\\n\\t\\tbytes memory initCode,\\n\\t\\tbytes32 safeSalt,\\n\\t\\taddress target\\n\\t) private returns (address spawnedContract) {\\n\\t\\tassembly {\\n\\t\\t\\tlet encoded_data := add(0x20, initCode) // load initialization code.\\n\\t\\t\\tlet encoded_size := mload(initCode) // load the init code's length.\\n\\t\\t\\tspawnedContract := create2(\\n\\t\\t\\t\\t// call `CREATE2` w/ 4 arguments.\\n\\t\\t\\t\\tcallvalue(), // forward any supplied endowment.\\n\\t\\t\\t\\tencoded_data, // pass in initialization code.\\n\\t\\t\\t\\tencoded_size, // pass in init code's length.\\n\\t\\t\\t\\tsafeSalt // pass in the salt value.\\n\\t\\t\\t)\\n\\n\\t\\t\\t// pass along failure message from failed contract deployment and revert.\\n\\t\\t\\tif iszero(spawnedContract) {\\n\\t\\t\\t\\treturndatacopy(0, 0, returndatasize())\\n\\t\\t\\t\\trevert(0, returndatasize())\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// validate spawned instance matches target\\n\\t\\trequire(spawnedContract == target, \\\"attempted deployment to unexpected address\\\");\\n\\n\\t\\t// explicit return\\n\\t\\treturn spawnedContract;\\n\\t}\\n\\n\\t/// @notice Internal view function for finding the expected address of the standard\\n\\t/// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\\n\\t/// salt, and initialization calldata payload.\\n\\t/// @param creator address The address of the account creating the proxy.\\n\\t/// @param logicContract address The address of the logic contract.\\n\\t/// @param initializationCalldata bytes The calldata that will be supplied to\\n\\t/// the `DELEGATECALL` from the spawned contract to the logic contract during\\n\\t/// contract creation.\\n\\t/// @param salt bytes32 A user defined salt.\\n\\t/// @return target address The address of the newly-spawned contract.\\n\\t/// @return validity bool True if the `target` is available.\\n\\tfunction _getSaltyTarget(\\n\\t\\taddress creator,\\n\\t\\taddress logicContract,\\n\\t\\tbytes memory initializationCalldata,\\n\\t\\tbytes32 salt\\n\\t) internal view returns (address target, bool validity) {\\n\\t\\t// get initialization code\\n\\n\\t\\tbytes32 initCodeHash;\\n\\t\\t(, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\\n\\n\\t\\t// get valid target\\n\\n\\t\\t(target, , validity) = _getSaltyTargetWithInitCodeHash(creator, initCodeHash, salt);\\n\\n\\t\\t// explicit return\\n\\t\\treturn (target, validity);\\n\\t}\\n\\n\\t/// @notice Internal view function for finding the expected address of the standard\\n\\t/// eip-1167 minimal proxy created using `CREATE2` with a given initCodeHash, and salt.\\n\\t/// @param creator address The address of the account creating the proxy.\\n\\t/// @param initCodeHash bytes32 The hash of initCode.\\n\\t/// @param salt bytes32 A user defined salt.\\n\\t/// @return target address The address of the newly-spawned contract.\\n\\t/// @return safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\\n\\t/// @return validity bool True if the `target` is available.\\n\\tfunction _getSaltyTargetWithInitCodeHash(\\n\\t\\taddress creator,\\n\\t\\tbytes32 initCodeHash,\\n\\t\\tbytes32 salt\\n\\t)\\n\\t\\tprivate\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\taddress target,\\n\\t\\t\\tbytes32 safeSalt,\\n\\t\\t\\tbool validity\\n\\t\\t)\\n\\t{\\n\\t\\t// get safeSalt from input\\n\\t\\tsafeSalt = keccak256(abi.encodePacked(creator, salt));\\n\\n\\t\\t// get expected target\\n\\t\\ttarget = _computeTargetWithCodeHash(initCodeHash, safeSalt);\\n\\n\\t\\t// get target validity\\n\\t\\tvalidity = _getTargetValidity(target);\\n\\n\\t\\t// explicit return\\n\\t\\treturn (target, safeSalt, validity);\\n\\t}\\n\\n\\t/// @notice Internal view function for finding the expected address of the standard\\n\\t/// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\\n\\t/// nonce, and initialization calldata payload.\\n\\t/// @param creator address The address of the account creating the proxy.\\n\\t/// @param logicContract address The address of the logic contract.\\n\\t/// @param initializationCalldata bytes The calldata that will be supplied to\\n\\t/// the `DELEGATECALL` from the spawned contract to the logic contract during\\n\\t/// contract creation.\\n\\t/// @return target address The address of the newly-spawned contract.\\n\\tfunction _getNextNonceTarget(\\n\\t\\taddress creator,\\n\\t\\taddress logicContract,\\n\\t\\tbytes memory initializationCalldata\\n\\t) internal view returns (address target) {\\n\\t\\t// get initialization code\\n\\n\\t\\tbytes32 initCodeHash;\\n\\t\\t(, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\\n\\n\\t\\t// get valid target\\n\\n\\t\\t(target, ) = _getNextNonceTargetWithInitCodeHash(creator, initCodeHash);\\n\\n\\t\\t// explicit return\\n\\t\\treturn target;\\n\\t}\\n\\n\\t/// @notice Internal view function for finding the expected address of the standard\\n\\t/// eip-1167 minimal proxy created using `CREATE2` with a given initCodeHash, and nonce.\\n\\t/// @param creator address The address of the account creating the proxy.\\n\\t/// @param initCodeHash bytes32 The hash of initCode.\\n\\t/// @return target address The address of the newly-spawned contract.\\n\\t/// @return safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\\n\\tfunction _getNextNonceTargetWithInitCodeHash(address creator, bytes32 initCodeHash)\\n\\t\\tprivate\\n\\t\\tview\\n\\t\\treturns (address target, bytes32 safeSalt)\\n\\t{\\n\\t\\t// set the initial nonce to be provided when constructing the salt.\\n\\t\\tuint256 nonce = 0;\\n\\n\\t\\twhile (true) {\\n\\t\\t\\t// get safeSalt from nonce\\n\\t\\t\\tsafeSalt = keccak256(abi.encodePacked(creator, nonce));\\n\\n\\t\\t\\t// get expected target\\n\\t\\t\\ttarget = _computeTargetWithCodeHash(initCodeHash, safeSalt);\\n\\n\\t\\t\\t// validate no contract already deployed to the target address.\\n\\t\\t\\t// exit the loop if no contract is deployed to the target address.\\n\\t\\t\\t// otherwise, increment the nonce and derive a new salt.\\n\\t\\t\\tif (_getTargetValidity(target)) break;\\n\\t\\t\\telse nonce++;\\n\\t\\t}\\n\\n\\t\\t// explicit return\\n\\t\\treturn (target, safeSalt);\\n\\t}\\n\\n\\t/// @notice Private pure function for obtaining the initCode and the initCodeHash of `logicContract` and `initializationCalldata`.\\n\\t/// @param logicContract address The address of the logic contract.\\n\\t/// @param initializationCalldata bytes The calldata that will be supplied to\\n\\t/// the `DELEGATECALL` from the spawned contract to the logic contract during\\n\\t/// contract creation.\\n\\t/// @return initCode bytes The spawner code and initialization calldata.\\n\\t/// @return initCodeHash bytes32 The hash of initCode.\\n\\tfunction _getInitCodeAndHash(address logicContract, bytes memory initializationCalldata)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (bytes memory initCode, bytes32 initCodeHash)\\n\\t{\\n\\t\\t// place creation code and constructor args of contract to spawn in memory.\\n\\t\\tinitCode = abi.encodePacked(type(Spawn).creationCode, abi.encode(logicContract, initializationCalldata));\\n\\n\\t\\t// get the keccak256 hash of the init code for address derivation.\\n\\t\\tinitCodeHash = keccak256(initCode);\\n\\n\\t\\t// explicit return\\n\\t\\treturn (initCode, initCodeHash);\\n\\t}\\n\\n\\t/// @notice Private view function for finding the expected address of the standard\\n\\t/// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\\n\\t/// salt, and initialization calldata payload.\\n\\t/// @param initCodeHash bytes32 The hash of initCode.\\n\\t/// @param safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\\n\\t/// @return target The address of the proxy contract with the given parameters.\\n\\tfunction _computeTargetWithCodeHash(bytes32 initCodeHash, bytes32 safeSalt) private view returns (address target) {\\n\\t\\treturn\\n\\t\\t\\taddress( // derive the target deployment address.\\n\\t\\t\\t\\tuint160( // downcast to match the address type.\\n\\t\\t\\t\\t\\tuint256( // cast to uint to truncate upper digits.\\n\\t\\t\\t\\t\\t\\tkeccak256( // compute CREATE2 hash using 4 inputs.\\n\\t\\t\\t\\t\\t\\t\\tabi.encodePacked( // pack all inputs to the hash together.\\n\\t\\t\\t\\t\\t\\t\\t\\tbytes1(0xff), // pass in the control character.\\n\\t\\t\\t\\t\\t\\t\\t\\taddress(this), // pass in the address of this contract.\\n\\t\\t\\t\\t\\t\\t\\t\\tsafeSalt, // pass in the safeSalt from above.\\n\\t\\t\\t\\t\\t\\t\\t\\tinitCodeHash // pass in hash of contract creation code.\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/// @notice Private view function to validate if the `target` address is an available deployment address.\\n\\t/// @param target address The address to validate.\\n\\t/// @return validity bool True if the `target` is available.\\n\\tfunction _getTargetValidity(address target) private view returns (bool validity) {\\n\\t\\t// validate no contract already deployed to the target address.\\n\\t\\tuint256 codeSize;\\n\\t\\tassembly {\\n\\t\\t\\tcodeSize := extcodesize(target)\\n\\t\\t}\\n\\t\\treturn codeSize == 0;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/IdentityWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./auth/MultisigABAC.sol\\\";\\nimport \\\"./wallet/TokenManager.sol\\\";\\nimport \\\"./factory/BaseTemplate.sol\\\";\\n\\ncontract IdentityWallet is TokenManager, MultisigABAC, BaseTemplate {\\n\\tstring public constant WITHDRAW_ATTRIBUTE = \\\"WITHDRAW\\\";\\n\\n\\t/// @notice Initialize the ownership policy.\\n\\t/// @dev Access control: Can only be called with a delegatecall from a contract constructor.\\n\\t/// @param owners address[] Array of owner addresses at initialization.\\n\\t/// @param admins address[] Array of admin addresses at initialization.\\n\\t/// @param ownersRequired uint256 Number of owner signatures required for valid OWNER call.\\n\\t/// @param adminsRequired uint256 Number of admin signatures required for valid ADMIN call.\\n\\tfunction initialize(\\n\\t\\taddress[] memory owners,\\n\\t\\taddress[] memory admins,\\n\\t\\tuint256 ownersRequired,\\n\\t\\tuint256 adminsRequired\\n\\t) public initializeTemplate {\\n\\t\\tMultisigABAC._setOwnerPolicy(owners, admins, ownersRequired, adminsRequired);\\n\\t}\\n\\n\\tfunction withdrawETH(address payable to, uint256 amount) external withAttribute(WITHDRAW_ATTRIBUTE) {\\n\\t\\tTokenManager._sendETH(to, amount);\\n\\t}\\n\\n\\tfunction withdrawERC20(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) external withAttribute(WITHDRAW_ATTRIBUTE) {\\n\\t\\tTokenManager._sendERC20(token, to, amount);\\n\\t}\\n\\n\\tfunction withdrawERC721(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) external withAttribute(WITHDRAW_ATTRIBUTE) {\\n\\t\\tTokenManager._sendERC721(token, to, tokenId);\\n\\t}\\n\\n\\tfunction withdrawERC777(\\n\\t\\taddress token,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount,\\n\\t\\tbytes calldata data\\n\\t) external withAttribute(WITHDRAW_ATTRIBUTE) {\\n\\t\\tTokenManager._sendERC777(token, recipient, amount, data);\\n\\t}\\n\\n\\tfunction withdrawERC1155(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 id,\\n\\t\\tuint256 amount,\\n\\t\\tbytes calldata data\\n\\t) external withAttribute(WITHDRAW_ATTRIBUTE) {\\n\\t\\tTokenManager._sendERC1155(token, to, id, amount, data);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC1271/ERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nabstract contract ERC1271 {\\n\\t// bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n\\tbytes4 internal constant MAGICVALUE = 0x20c13b0b;\\n\\n\\t/**\\n\\t * @dev Should return whether the signature provided is valid for the provided data\\n\\t * @param _data Arbitrary length data signed on the behalf of address(this)\\n\\t * @param _signature Signature byte array associated with _data\\n\\t *\\n\\t * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n\\t * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n\\t * MUST allow external calls\\n\\t */\\n\\n\\tfunction isValidSignature(bytes memory _data, bytes memory _signature)\\n\\t\\tpublic\\n\\t\\tvirtual\\n\\t\\tview\\n\\t\\treturns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC1616/ERC1616.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./IERC1616.sol\\\";\\nimport \\\"../ERC165/ERC165.sol\\\";\\n\\nabstract contract ERC1616 is ERC165, IERC1616 {\\n\\tconstructor() public {\\n\\t\\tERC165._registerInterface(0x5f46473f);\\n\\t}\\n\\n\\tfunction hasAttribute(address account, uint256 attributeTypeID) external virtual override view returns (bool);\\n\\n\\tfunction getAttributeValue(address account, uint256 attributeTypeID)\\n\\t\\texternal\\n\\t\\tvirtual\\n\\t\\toverride\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction countAttributeTypes() external virtual override view returns (uint256);\\n\\n\\tfunction getAttributeTypeID(uint256 index) external virtual override view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC1616/IERC1616.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @title ERC-1616 Attribute Registry interface. ERC-165 ID: 0x5f46473f\\n */\\ninterface IERC1616 {\\n\\t/**\\n\\t * @notice Check if an attribute of the type with ID `attributeTypeID` has\\n\\t * been assigned to the account at `account` and is currently valid.\\n\\t * @param account address The account to check for a valid attribute.\\n\\t * @param attributeTypeID uint256 The ID of the attribute type to check for.\\n\\t * @return True if the attribute is assigned and valid, false otherwise.\\n\\t * @dev This function MUST return either true or false - i.e. calling this\\n\\t * function MUST NOT cause the caller to revert.\\n\\t */\\n\\tfunction hasAttribute(address account, uint256 attributeTypeID) external view returns (bool);\\n\\n\\t/**\\n\\t * @notice Retrieve the value of the attribute of the type with ID\\n\\t * `attributeTypeID` on the account at `account`, assuming it is valid.\\n\\t * @param account address The account to check for the given attribute value.\\n\\t * @param attributeTypeID uint256 The ID of the attribute type to check for.\\n\\t * @return The attribute value if the attribute is valid, reverts otherwise.\\n\\t * @dev This function MUST revert if a directly preceding or subsequent\\n\\t * function call to `hasAttribute` with identical `account` and\\n\\t * `attributeTypeID` parameters would return false.\\n\\t */\\n\\tfunction getAttributeValue(address account, uint256 attributeTypeID) external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice Count the number of attribute types defined by the registry.\\n\\t * @return The number of available attribute types.\\n\\t * @dev This function MUST return a positive integer value  - i.e. calling\\n\\t * this function MUST NOT cause the caller to revert.\\n\\t */\\n\\tfunction countAttributeTypes() external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice Get the ID of the attribute type at index `index`.\\n\\t * @param index uint256 The index of the attribute type in question.\\n\\t * @return The ID of the attribute type.\\n\\t * @dev This function MUST revert if the provided `index` value falls outside\\n\\t * of the range of the value returned from a directly preceding or subsequent\\n\\t * function call to `countAttributeTypes`. It MUST NOT revert if the provided\\n\\t * `index` value falls inside said range.\\n\\t */\\n\\tfunction getAttributeTypeID(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC777/IERC777Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Recipient {\\n\\t/**\\n\\t * @dev Called by an {IERC777} token contract whenever tokens are being\\n\\t * moved or created into a registered account (`to`). The type of operation\\n\\t * is conveyed by `from` being the zero address or not.\\n\\t *\\n\\t * This call occurs _after_ the token contract's state is updated, so\\n\\t * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n\\t *\\n\\t * This function may revert to prevent the operation from being executed.\\n\\t */\\n\\tfunction tokensReceived(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount,\\n\\t\\tbytes calldata userData,\\n\\t\\tbytes calldata operatorData\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"contracts/UserWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./auth/MultisigABAC.sol\\\";\\nimport \\\"./wallet/MetaTxUtils.sol\\\";\\nimport \\\"./wallet/TokenManager.sol\\\";\\nimport \\\"./factory/BaseTemplate.sol\\\";\\n\\ncontract UserWallet is TokenManager, MetaTxUtils, MultisigABAC, BaseTemplate {\\n\\t// last nonce executed. Allowed to skip.\\n\\tuint256 public lastNonce;\\n\\n\\t/// @notice Initialize the ownership policy.\\n\\t/// @dev Access control: Can only be called with a delegatecall from a contract constructor.\\n\\t/// @param owners address[] Array of owner addresses at initialization.\\n\\t/// @param admins address[] Array of admin addresses at initialization.\\n\\t/// @param ownersRequired uint256 Number of owner signatures required for valid OWNER call.\\n\\t/// @param adminsRequired uint256 Number of admin signatures required for valid ADMIN call.\\n\\tfunction initialize(\\n\\t\\taddress[] memory owners,\\n\\t\\taddress[] memory admins,\\n\\t\\tuint256 ownersRequired,\\n\\t\\tuint256 adminsRequired\\n\\t) public initializeTemplate {\\n\\t\\tMultisigABAC._setOwnerPolicy(owners, admins, ownersRequired, adminsRequired);\\n\\t}\\n\\n\\t/// @notice Execute transaction.\\n\\t/// @dev Access control: Must include valid array of ADMIN or OWNER signatures that meet admin policy.\\n\\t/// @param transaction bytes Encoded transaction blob.\\n\\t/// @param signatures bytes[] Array of admin or owner signatures.\\n\\t/// @return returnData bytes Encoded return data from user call.\\n\\tfunction executeTransaction(bytes memory transaction, bytes[] memory signatures)\\n\\t\\tpublic\\n\\t\\twithSignatures(keccak256(transaction), signatures, ADMIN_ATTRIBUTE)\\n\\t\\treturns (bytes memory returnData)\\n\\t{\\n\\t\\t(address to, uint256 value, uint256 gasLimit, uint256 nonce, bytes memory data) = MetaTxUtils\\n\\t\\t\\t._decodeTransaction(transaction);\\n\\t\\t// increment nonce\\n\\t\\trequire(nonce > lastNonce, \\\"invalid nonce\\\");\\n\\t\\tlastNonce = nonce;\\n\\t\\t// execute tx\\n\\t\\treturn MetaTxUtils._executeTransaction(to, value, gasLimit, data);\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"attributeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AttributeGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"attributeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AttributeRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"CallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"attributeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"PolicySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ATTRIBUTE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADMIN_ATTRIBUTE_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ATTRIBUTE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ATTRIBUTE_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"transactions\",\"type\":\"bytes[]\"}],\"name\":\"executeAtomicTransactions\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"transactions\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"executeTransactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"getPolicy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"internalType\":\"bytes[]\",\"name\":\"messageHashSignatures\",\"type\":\"bytes[]\"}],\"name\":\"grantAttribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"grantAttribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"hasAttribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageHashSignature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"hasAttribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"messageHashSignatures\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"haveAttribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"ownersRequired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminsRequired\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"revokeAttribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"internalType\":\"bytes[]\",\"name\":\"messageHashSignatures\",\"type\":\"bytes[]\"}],\"name\":\"revokeAttribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"internalType\":\"bytes[]\",\"name\":\"messageHashSignatures\",\"type\":\"bytes[]\"}],\"name\":\"setAttributePolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"setAttributePolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"stringToUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"attributeID\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAccount\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"},{\"internalType\":\"bytes[]\",\"name\":\"messageHashSignatures\",\"type\":\"bytes[]\"}],\"name\":\"transferAttribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAccount\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"attribute\",\"type\":\"string\"}],\"name\":\"transferAttribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AppWallet","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"9000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}