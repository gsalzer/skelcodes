{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\npragma solidity 0.4.26;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public view returns (address) {this;}\n\n    function transferOwnership(address _newOwner) public;\n    function acceptOwnership() public;\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\npragma solidity 0.4.26;\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public view returns (string) {this;}\n    function symbol() public view returns (string) {this;}\n    function decimals() public view returns (uint8) {this;}\n    function totalSupply() public view returns (uint256) {this;}\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Token Holder interface\n*/\ncontract ITokenHolder is IOwned {\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Converter Anchor interface\n*/\ncontract IConverterAnchor is IOwned, ITokenHolder {\n}\n\n// File: solidity/contracts/token/interfaces/ISmartToken.sol\n\npragma solidity 0.4.26;\n\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is IConverterAnchor, IERC20Token {\n    function disableTransfers(bool _disable) public;\n    function issue(address _to, uint256 _amount) public;\n    function destroy(address _from, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/interfaces/IPoolTokensContainer.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Pool Tokens Container interface\n*/\ncontract IPoolTokensContainer is IConverterAnchor {\n    function poolTokens() public view returns (ISmartToken[]);\n    function createToken() public returns (ISmartToken);\n    function mint(ISmartToken _token, address _to, uint256 _amount) public;\n    function burn(ISmartToken _token, address _from, uint256 _amount) public;\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\npragma solidity 0.4.26;\r\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\npragma solidity 0.4.26;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _spender approved address\n      * @param _value   allowance amount\n    */\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }\n\n    /**\n      * @dev executes a function on the ERC20 token and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _data    data to pass in to the token's contract for execution\n    */\n    function execute(IERC20Token _token, bytes memory _data) private {\n        uint256[1] memory ret = [uint256(1)];\n\n        assembly {\n            let success := call(\n                gas,            // gas remaining\n                _token,         // destination address\n                0,              // no ether\n                add(_data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(_data),   // input length (loaded from the first 32 bytes in the `data` array)\n                ret,            // output buffer\n                32              // output length\n            )\n            if iszero(success) {\n                revert(0, 0)\n            }\n        }\n\n        require(ret[0] != 0, \"ERR_TRANSFER_FAILED\");\n    }\n}\n\n// File: solidity/contracts/utility/TokenHolder.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/SafeMath.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\n\n// File: solidity/contracts/token/ERC20Token.sol\n\npragma solidity 0.4.26;\r\r\r\r\n\r\n/**\r\n  * @dev ERC20 Standard Token implementation\r\n*/\r\ncontract ERC20Token is IERC20Token, Utils {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /**\r\n      * @dev triggered when tokens are transferred between wallets\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n      * @dev triggered when a wallet allows another wallet to transfer tokens from on its behalf\r\n      *\r\n      * @param _owner   wallet that approves the allowance\r\n      * @param _spender wallet that receives the allowance\r\n      * @param _value   allowance amount\r\n    */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n      * @dev initializes a new ERC20Token instance\r\n      *\r\n      * @param _name        token name\r\n      * @param _symbol      token symbol\r\n      * @param _decimals    decimal points, for display purposes\r\n      * @param _totalSupply total supply of token units\r\n    */\r\n    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\r\n        // validate input\r\n        require(bytes(_name).length > 0, \"ERR_INVALID_NAME\");\r\n        require(bytes(_symbol).length > 0, \"ERR_INVALID_SYMBOL\");\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply;\r\n        balanceOf[msg.sender] = _totalSupply;\r\n    }\r\n\r\n    /**\r\n      * @dev transfers tokens to a given address\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev transfers tokens to a given address on behalf of another address\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows another account/contract to transfers tokens on behalf of the caller\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * also, to minimize the risk of the approve/transferFrom attack vector\r\n      * (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\r\n      * in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n      *\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n      *\r\n      * @return true if the approval was successful, false if it wasn't\r\n    */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0, \"ERR_INVALID_AMOUNT\");\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\n\n// File: solidity/contracts/token/SmartToken.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\n\r\n/**\r\n  * @dev Smart Token\r\n  *\r\n  * 'Owned' is specified here for readability reasons\r\n*/\r\ncontract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    uint16 public constant version = 4;\r\n\r\n    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false otherwise\r\n\r\n    /**\r\n      * @dev triggered when the total supply is increased\r\n      *\r\n      * @param _amount  amount that gets added to the supply\r\n    */\r\n    event Issuance(uint256 _amount);\r\n\r\n    /**\r\n      * @dev triggered when the total supply is decreased\r\n      *\r\n      * @param _amount  amount that gets removed from the supply\r\n    */\r\n    event Destruction(uint256 _amount);\r\n\r\n    /**\r\n      * @dev initializes a new SmartToken instance\r\n      *\r\n      * @param _name       token name\r\n      * @param _symbol     token short symbol, minimum 1 character\r\n      * @param _decimals   for display purposes only\r\n    */\r\n    constructor(string _name, string _symbol, uint8 _decimals)\r\n        public\r\n        ERC20Token(_name, _symbol, _decimals, 0)\r\n    {\r\n    }\r\n\r\n    // allows execution only when transfers are enabled\r\n    modifier transfersAllowed {\r\n        _transfersAllowed();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _transfersAllowed() internal view {\r\n        require(transfersEnabled, \"ERR_TRANSFERS_DISABLED\");\r\n    }\r\n\r\n    /**\r\n      * @dev disables/enables transfers\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTransfers(bool _disable) public ownerOnly {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n      * @dev increases the token supply and sends the new tokens to the given account\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to increase the supply by\r\n    */\r\n    function issue(address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balanceOf[_to] = balanceOf[_to].add(_amount);\r\n\r\n        emit Issuance(_amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev removes tokens from the given account and decreases the token supply\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _from    account to remove the amount from\r\n      * @param _amount  amount to decrease the supply by\r\n    */\r\n    function destroy(address _from, uint256 _amount) public ownerOnly {\r\n        balanceOf[_from] = balanceOf[_from].sub(_amount);\r\n        totalSupply = totalSupply.sub(_amount);\r\n\r\n        emit Transfer(_from, address(0), _amount);\r\n        emit Destruction(_amount);\r\n    }\r\n\r\n    // ERC20 standard method overrides with some extra functionality\r\n\r\n    /**\r\n      * @dev send coins\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      * in addition to the standard checks, the function throws if transfers are disabled\r\n      *\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transfer(_to, _value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev an account/contract attempts to get the coins\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      * in addition to the standard checks, the function throws if transfers are disabled\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transferFrom(_from, _to, _value));\r\n        return true;\r\n    }\r\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/PoolTokensContainer.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\n\r\n/**\r\n  * @dev The PoolTokensContainer contract serves as a container for multiple pool tokens.\r\n  * It is used by specific liquidity pool types that require more than a single pool token,\r\n  * while still maintaining the single converter / anchor relationship.\r\n  *\r\n  * It maintains and provides a list of the underlying pool tokens.\r\n */\r\ncontract PoolTokensContainer is IPoolTokensContainer, Owned, TokenHolder {\r\n    uint8 internal constant MAX_POOL_TOKENS = 5;    // maximum pool tokens in the container\r\n\r\n    string public name;                 // pool name\r\n    string public symbol;               // pool symbol\r\n    uint8 public decimals;              // underlying pool tokens decimals\r\n    ISmartToken[] private _poolTokens;  // underlying pool tokens\r\n\r\n    /**\r\n      * @dev initializes a new PoolTokensContainer instance\r\n      *\r\n      * @param  _name       pool name, also used as a prefix for the underlying pool token names\r\n      * @param  _symbol     pool symbol, also used as a prefix for the underlying pool token symbols\r\n      * @param  _decimals   used for the underlying pool token decimals\r\n    */\r\n    constructor(string _name, string _symbol, uint8 _decimals) public {\r\n         // validate input\r\n        require(bytes(_name).length > 0, \"ERR_INVALID_NAME\");\r\n        require(bytes(_symbol).length > 0, \"ERR_INVALID_SYMBOL\");\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of pool tokens\r\n      *\r\n      * @return list of pool tokens\r\n    */\r\n    function poolTokens() public view returns (ISmartToken[] memory) {\r\n        return _poolTokens;\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new pool token and adds it to the list\r\n      *\r\n      * @return new pool token address\r\n    */\r\n    function createToken() public ownerOnly returns (ISmartToken) {\r\n        // verify that the max limit wasn't reached\r\n        require(_poolTokens.length < MAX_POOL_TOKENS, \"ERR_MAX_LIMIT_REACHED\");\r\n\r\n        string memory poolName = concatStrDigit(name, uint8(_poolTokens.length + 1));\r\n        string memory poolSymbol = concatStrDigit(symbol, uint8(_poolTokens.length + 1));\r\n\r\n        SmartToken token = new SmartToken(poolName, poolSymbol, decimals);\r\n        _poolTokens.push(token);\r\n        return token;\r\n    }\r\n\r\n    /**\r\n      * @dev increases the pool token supply and sends the new tokens to the given account\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _token   pool token address\r\n      * @param _to      account to receive the newly minted tokens\r\n      * @param _amount  amount to mint\r\n    */\r\n    function mint(ISmartToken _token, address _to, uint256 _amount) public ownerOnly {\r\n        _token.issue(_to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev removes tokens from the given account and decreases the pool token supply\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _token   pool token address\r\n      * @param _from    account to remove the tokens from\r\n      * @param _amount  amount to burn\r\n    */\r\n    function burn(ISmartToken _token, address _from, uint256 _amount) public ownerOnly {\r\n        _token.destroy(_from, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev concatenates a string and a digit (single only) and returns the result string\r\n      *\r\n      * @param _str     string\r\n      * @param _digit   digit\r\n      * @return concatenated string\r\n    */\r\n    function concatStrDigit(string _str, uint8 _digit) private pure returns (string) {\r\n        return string(abi.encodePacked(_str, uint8(bytes1('0')) + _digit));\r\n    }\r\n}\n\n// File: solidity/contracts/converter/interfaces/ITypedConverterCustomFactory.sol\n\npragma solidity 0.4.26;\n\n/*\n    Typed Converter Custom Factory interface\n*/\ncontract ITypedConverterCustomFactory {\n    function converterType() public pure returns (uint16);\n}\n\n// File: solidity/contracts/utility/interfaces/IChainlinkPriceOracle.sol\n\npragma solidity 0.4.26;\n\n/*\n    Chainlink Price Oracle interface\n*/\ninterface IChainlinkPriceOracle {\n    function latestAnswer() external view returns (int256);\n    function latestTimestamp() external view returns (uint256);\n}\n\n// File: solidity/contracts/utility/interfaces/IPriceOracle.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Price Oracle interface\n*/\ncontract IPriceOracle {\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB) public view returns (uint256, uint256);\n    function lastUpdateTime() public view returns (uint256);\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB) public view returns (uint256, uint256, uint256);\n\n    function tokenAOracle() public view returns (IChainlinkPriceOracle) {this;}\n    function tokenBOracle() public view returns (IChainlinkPriceOracle) {this;}\n}\n\n// File: solidity/contracts/utility/PriceOracle.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\n\r\n/**\r\n  * @dev Provides the off-chain rate between two tokens\r\n  *\r\n  * The price oracle uses chainlink oracles internally to get the rates of the two tokens\r\n  * with respect to a common denominator, and then returns the rate between them, which\r\n  * is equivalent to the rate of TokenA / TokenB\r\n*/\r\ncontract PriceOracle is IPriceOracle, Utils {\r\n    using SafeMath for uint256;\r\n\r\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    uint8 private constant ETH_DECIMALS = 18;\r\n\r\n    IERC20Token public tokenA;                  // token A the oracle supports\r\n    IERC20Token public tokenB;                  // token B the oracle supports\r\n    mapping (address => uint8) public tokenDecimals; // token -> token decimals\r\n\r\n    IChainlinkPriceOracle public tokenAOracle;  // token A chainlink price oracle\r\n    IChainlinkPriceOracle public tokenBOracle;  // token B chainlink price oracle\r\n    mapping (address => IChainlinkPriceOracle) public tokensToOracles;  // token -> price oracle for easier access\r\n\r\n    /**\r\n      * @dev initializes a new PriceOracle instance\r\n      * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n      *\r\n      * @param  _tokenA         first token to support\r\n      * @param  _tokenB         second token to support\r\n      * @param  _tokenAOracle   first token price oracle\r\n      * @param  _tokenBOracle   second token price oracle\r\n    */\r\n    constructor(IERC20Token _tokenA, IERC20Token _tokenB, IChainlinkPriceOracle _tokenAOracle, IChainlinkPriceOracle _tokenBOracle)\r\n        public\r\n        validUniqueAddresses(_tokenA, _tokenB)\r\n        validUniqueAddresses(_tokenAOracle, _tokenBOracle)\r\n    {\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n        tokenDecimals[_tokenA] = decimals(_tokenA);\r\n        tokenDecimals[_tokenB] = decimals(_tokenB);\r\n\r\n        tokenAOracle = _tokenAOracle;\r\n        tokenBOracle = _tokenBOracle;\r\n        tokensToOracles[_tokenA] = _tokenAOracle;\r\n        tokensToOracles[_tokenB] = _tokenBOracle;\r\n    }\r\n\r\n    // ensures that the provided addresses are unique valid\r\n    modifier validUniqueAddresses(address _address1, address _address2) {\r\n        _validUniqueAddresses(_address1, _address2);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validUniqueAddresses(address _address1, address _address2) internal pure {\r\n        _validAddress(_address1);\r\n        _validAddress(_address2);\r\n        require(_address1 != _address2, \"ERR_SAME_ADDRESS\");\r\n    }\r\n\r\n    // ensures that the provides tokens are supported by the oracle\r\n    modifier supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) {\r\n        _supportedTokens(_tokenA, _tokenB);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) internal view {\r\n        _validUniqueAddresses(_tokenA, _tokenB);\r\n        require(tokensToOracles[_tokenA] != address(0) && tokensToOracles[_tokenB] != address(0), \"ERR_UNSUPPORTED_TOKEN\");\r\n    }\r\n\r\n    /**\r\n      * @dev returns the latest known rate between the two given tokens\r\n      * for a given pair of tokens A and B, returns the rate of A / B\r\n      * (the number of B units equivalent to a single A unit)\r\n      * the rate is returned as a fraction (numerator / denominator) for accuracy\r\n      *\r\n      * @param  _tokenA token to get the rate of 1 unit of\r\n      * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n      *\r\n      * @return numerator\r\n      * @return denominator\r\n    */\r\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        supportedTokens(_tokenA, _tokenB)\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 rateTokenA = uint256(tokensToOracles[_tokenA].latestAnswer());\r\n        uint256 rateTokenB = uint256(tokensToOracles[_tokenB].latestAnswer());\r\n        uint8 decimalsTokenA = tokenDecimals[_tokenA];\r\n        uint8 decimalsTokenB = tokenDecimals[_tokenB];\r\n\r\n        // the normalization works as follows:\r\n        //   - token A with decimals of dA and price of rateA per one token (e.g., for 10^dA weiA)\r\n        //   - token B with decimals of dB < dA and price of rateB per one token (e.g., for 10^dB weiB)\r\n        // then the normalized rate, representing the rate between 1 weiA and 1 weiB is rateA / (rateB * 10^(dA - dB)).\r\n        //\r\n        // for example:\r\n        //   - token A with decimals of 5 and price of $10 per one token (e.g., for 100,000 weiA)\r\n        //   - token B with decimals of 2 and price of $2 per one token (e.g., for 100 weiB)\r\n        // then the normalized rate would be: 5 / (2 * 10^3) = 0.0025, which is the correct rate since\r\n        // 1 weiA costs $0.00005, 1 weiB costs $0.02, and weiA / weiB is 0.0025.\r\n\r\n        if (decimalsTokenA > decimalsTokenB) {\r\n            rateTokenB = rateTokenB.mul(uint256(10) ** (decimalsTokenA - decimalsTokenB));\r\n        }\r\n        else if (decimalsTokenA < decimalsTokenB) {\r\n            rateTokenA = rateTokenA.mul(uint256(10) ** (decimalsTokenB - decimalsTokenA));\r\n        }\r\n\r\n        return (rateTokenA, rateTokenB);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the timestamp of the last price update the rates are returned as numerator (token1) and denominator\r\n      * (token2) for accuracy\r\n      *\r\n      * @return timestamp\r\n    */\r\n    function lastUpdateTime()\r\n        public\r\n        view\r\n        returns (uint256) {\r\n        // returns the oldest timestamp between the two\r\n        uint256 timestampA = tokenAOracle.latestTimestamp();\r\n        uint256 timestampB = tokenBOracle.latestTimestamp();\r\n\r\n        return  timestampA < timestampB ? timestampA : timestampB;\r\n    }\r\n\r\n    /**\r\n      * @dev returns both the rate and the timestamp of the last update in a single call (gas optimization)\r\n      *\r\n      * @param  _tokenA token to get the rate of 1 unit of\r\n      * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n      *\r\n      * @return numerator\r\n      * @return denominator\r\n      * @return timestamp of the last update\r\n    */\r\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        (uint256 numerator, uint256 denominator) = latestRate(_tokenA, _tokenB);\r\n\r\n        return (numerator, denominator, lastUpdateTime());\r\n    }\r\n\r\n    /** @dev returns the decimals of a given token */\r\n    function decimals(IERC20Token _token) private view returns (uint8) {\r\n        if (_token == ETH_ADDRESS) {\r\n            return ETH_DECIMALS;\r\n        }\r\n\r\n        return _token.decimals();\r\n    }\r\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2ConverterCustomFactory.sol\n\npragma solidity 0.4.26;\r\r\r\n\r\n/*\r\n    LiquidityPoolV2ConverterCustomFactory Factory\r\n*/\r\ncontract LiquidityPoolV2ConverterCustomFactory is ITypedConverterCustomFactory {\r\n    /**\r\n      * @dev returns the converter type the factory is associated with\r\n      *\r\n      * @return converter type\r\n    */\r\n    function converterType() public pure returns (uint16) {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new price oracle\r\n      * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n      *\r\n      * @param  _primaryReserveToken    primary reserve token address\r\n      * @param  _secondaryReserveToken  secondary reserve token address\r\n      * @param  _primaryReserveOracle   primary reserve oracle address\r\n      * @param  _secondaryReserveOracle secondary reserve oracle address\r\n    */\r\n    function createPriceOracle(\r\n        IERC20Token _primaryReserveToken,\r\n        IERC20Token _secondaryReserveToken,\r\n        IChainlinkPriceOracle _primaryReserveOracle,\r\n        IChainlinkPriceOracle _secondaryReserveOracle)\r\n        public\r\n        returns (IPriceOracle)\r\n    {\r\n        return new PriceOracle(_primaryReserveToken, _secondaryReserveToken, _primaryReserveOracle, _secondaryReserveOracle);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/interfaces/IWhitelist.sol\n\npragma solidity 0.4.26;\n\n/*\n    Whitelist interface\n*/\ncontract IWhitelist {\n    function isWhitelisted(address _address) public view returns (bool);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverter.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/*\n    Converter interface\n*/\ncontract IConverter is IOwned {\n    function converterType() public pure returns (uint16);\n    function anchor() public view returns (IConverterAnchor) {this;}\n    function isActive() public view returns (bool);\n\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256);\n    function convert(IERC20Token _sourceToken,\n                     IERC20Token _targetToken,\n                     uint256 _amount,\n                     address _trader,\n                     address _beneficiary) public payable returns (uint256);\n\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\n    function conversionFee() public view returns (uint32) {this;}\n    function maxConversionFee() public view returns (uint32) {this;}\n    function reserveBalance(IERC20Token _reserveToken) public view returns (uint256);\n    function() external payable;\n\n    function transferAnchorOwnership(address _newOwner) public;\n    function acceptAnchorOwnership() public;\n    function setConversionFee(uint32 _conversionFee) public;\n    function setConversionWhitelist(IWhitelist _whitelist) public;\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n    function withdrawETH(address _to) public;\n    function addReserve(IERC20Token _token, uint32 _ratio) public;\n\n    // deprecated, backward compatibility\n    function token() public view returns (IConverterAnchor);\n    function transferTokenOwnership(address _newOwner) public;\n    function acceptTokenOwnership() public;\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\n    function connectorTokenCount() public view returns (uint16);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterUpgrader.sol\n\npragma solidity 0.4.26;\n\n/*\n    Converter Upgrader interface\n*/\ncontract IConverterUpgrader {\n    function upgrade(bytes32 _version) public;\n    function upgrade(uint16 _version) public;\n}\n\n// File: solidity/contracts/converter/interfaces/IBancorFormula.sol\n\npragma solidity 0.4.26;\n\n/*\n    Bancor Formula interface\n*/\ncontract IBancorFormula {\n    function purchaseTargetAmount(uint256 _supply,\n                                  uint256 _reserveBalance,\n                                  uint32 _reserveWeight,\n                                  uint256 _amount)\n                                  public view returns (uint256);\n\n    function saleTargetAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveWeight,\n                              uint256 _amount)\n                              public view returns (uint256);\n\n    function crossReserveTargetAmount(uint256 _sourceReserveBalance,\n                                      uint32 _sourceReserveWeight,\n                                      uint256 _targetReserveBalance,\n                                      uint32 _targetReserveWeight,\n                                      uint256 _amount)\n                                      public view returns (uint256);\n\n    function fundCost(uint256 _supply,\n                      uint256 _reserveBalance,\n                      uint32 _reserveRatio,\n                      uint256 _amount)\n                      public view returns (uint256);\n\n    function fundSupplyAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveRatio,\n                              uint256 _amount)\n                              public view returns (uint256);\n\n    function liquidateReserveAmount(uint256 _supply,\n                                    uint256 _reserveBalance,\n                                    uint32 _reserveRatio,\n                                    uint256 _amount)\n                                    public view returns (uint256);\n\n    function balancedWeights(uint256 _primaryReserveStakedBalance,\n                             uint256 _primaryReserveBalance,\n                             uint256 _secondaryReserveBalance,\n                             uint256 _reserveRateNumerator,\n                             uint256 _reserveRateDenominator)\n                             public view returns (uint32, uint32);\n}\n\n// File: solidity/contracts/IBancorNetwork.sol\n\npragma solidity 0.4.26;\n\n\n/*\n    Bancor Network interface\n*/\ncontract IBancorNetwork {\n    function convert2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public payable returns (uint256);\n\n    function claimAndConvert2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public returns (uint256);\n\n    function convertFor2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public payable returns (uint256);\n\n    function claimAndConvertFor2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public returns (uint256);\n\n    // deprecated, backward compatibility\n    function convert(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn\n    ) public payable returns (uint256);\n\n    // deprecated, backward compatibility\n    function claimAndConvert(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn\n    ) public returns (uint256);\n\n    // deprecated, backward compatibility\n    function convertFor(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for\n    ) public payable returns (uint256);\n\n    // deprecated, backward compatibility\n    function claimAndConvertFor(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for\n    ) public returns (uint256);\n}\n\n// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\n\npragma solidity 0.4.26;\n\n/*\n    Contract Registry interface\n*/\ncontract IContractRegistry {\n    function addressOf(bytes32 _contractName) public view returns (address);\n\n    // deprecated, backward compatibility\n    function getAddress(bytes32 _contractName) public view returns (address);\n}\n\n// File: solidity/contracts/utility/ContractRegistryClient.sol\n\npragma solidity 0.4.26;\r\r\r\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = \"ChainlinkOracleWhitelist\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/ReentrancyGuard.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev ReentrancyGuard\r\n  *\r\n  * The contract provides protection against re-entrancy - calling a function (directly or\r\n  * indirectly) from within itself.\r\n*/\r\ncontract ReentrancyGuard {\r\n    // true while protected code is being executed, false otherwise\r\n    bool private locked = false;\r\n\r\n    /**\r\n      * @dev ensures instantiation only by sub-contracts\r\n    */\r\n    constructor() internal {}\r\n\r\n    // protects a function against reentrancy attacks\r\n    modifier protected() {\r\n        _protected();\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _protected() internal view {\r\n        require(!locked, \"ERR_REENTRANCY\");\r\n    }\r\n}\n\n// File: solidity/contracts/token/interfaces/IEtherToken.sol\n\npragma solidity 0.4.26;\n\n\n/*\n    Ether Token interface\n*/\ncontract IEtherToken is IERC20Token {\n    function deposit() public payable;\n    function withdraw(uint256 _amount) public;\n    function depositTo(address _to) public payable;\n    function withdrawTo(address _to, uint256 _amount) public;\n}\n\n// File: solidity/contracts/bancorx/interfaces/IBancorX.sol\n\npragma solidity 0.4.26;\n\n\ncontract IBancorX {\n    function token() public view returns (IERC20Token) {this;}\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;\n    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\n}\n\n// File: solidity/contracts/converter/ConverterBase.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\r\r\r\r\r\r\r\r\n\r\n/**\r\n  * @dev ConverterBase\r\n  *\r\n  * The converter contains the main logic for conversions between different ERC20 tokens.\r\n  *\r\n  * It is also the upgradable part of the mechanism (note that upgrades are opt-in).\r\n  *\r\n  * The anchor must be set on construction and cannot be changed afterwards.\r\n  * Wrappers are provided for some of the anchor's functions, for easier access.\r\n  *\r\n  * Once the converter accepts ownership of the anchor, it becomes the anchor's sole controller\r\n  * and can execute any of its functions.\r\n  *\r\n  * To upgrade the converter, anchor ownership must be transferred to a new converter, along with\r\n  * any relevant data.\r\n  *\r\n  * Note that the converter can transfer anchor ownership to a new converter that\r\n  * doesn't allow upgrades anymore, for finalizing the relationship between the converter\r\n  * and the anchor.\r\n  *\r\n  * Converter types (defined as uint16 type) -\r\n  * 0 = liquid token converter\r\n  * 1 = liquidity pool v1 converter\r\n  * 2 = liquidity pool v2 converter\r\n  *\r\n  * Note that converters don't currently support tokens with transfer fees.\r\n*/\r\ncontract ConverterBase is IConverter, TokenHandler, TokenHolder, ContractRegistryClient, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint32 internal constant WEIGHT_RESOLUTION = 1000000;\r\n    uint64 internal constant CONVERSION_FEE_RESOLUTION = 1000000;\r\n    address internal constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    struct Reserve {\r\n        uint256 balance;    // reserve balance\r\n        uint32 weight;      // reserve weight, represented in ppm, 1-1000000\r\n        bool deprecated1;   // deprecated\r\n        bool deprecated2;   // deprecated\r\n        bool isSet;         // true if the reserve is valid, false otherwise\r\n    }\r\n\r\n    /**\r\n      * @dev version number\r\n    */\r\n    uint16 public constant version = 30;\r\n\r\n    IConverterAnchor public anchor;                 // converter anchor contract\r\n    IWhitelist public conversionWhitelist;          // whitelist contract with list of addresses that are allowed to use the converter\r\n    IERC20Token[] public reserveTokens;             // ERC20 standard token addresses (prior version 17, use 'connectorTokens' instead)\r\n    mapping (address => Reserve) public reserves;   // reserve token addresses -> reserve data (prior version 17, use 'connectors' instead)\r\n    uint32 public reserveRatio = 0;                 // ratio between the reserves and the market cap, equal to the total reserve weights\r\n    uint32 public maxConversionFee = 0;             // maximum conversion fee for the lifetime of the contract,\r\n                                                    // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\r\n    uint32 public conversionFee = 0;                // current conversion fee, represented in ppm, 0...maxConversionFee\r\n    bool public constant conversionsEnabled = true; // deprecated, backward compatibility\r\n\r\n    /**\r\n      * @dev triggered when the converter is activated\r\n      *\r\n      * @param _type        converter type\r\n      * @param _anchor      converter anchor\r\n      * @param _activated   true if the converter was activated, false if it was deactivated\r\n    */\r\n    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\r\n\r\n    /**\r\n      * @dev triggered when a conversion between two tokens occurs\r\n      *\r\n      * @param _fromToken       source ERC20 token\r\n      * @param _toToken         target ERC20 token\r\n      * @param _trader          wallet that initiated the trade\r\n      * @param _amount          amount converted, in the source token\r\n      * @param _return          amount returned, minus conversion fee\r\n      * @param _conversionFee   conversion fee\r\n    */\r\n    event Conversion(\r\n        address indexed _fromToken,\r\n        address indexed _toToken,\r\n        address indexed _trader,\r\n        uint256 _amount,\r\n        uint256 _return,\r\n        int256 _conversionFee\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the rate between two tokens in the converter changes\r\n      * note that the event might be dispatched for rate updates between any two tokens in the converter\r\n      * note that prior to version 28, you should use the 'PriceDataUpdate' event instead\r\n      *\r\n      * @param  _token1 address of the first token\r\n      * @param  _token2 address of the second token\r\n      * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\r\n      * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\r\n    */\r\n    event TokenRateUpdate(\r\n        address indexed _token1,\r\n        address indexed _token2,\r\n        uint256 _rateN,\r\n        uint256 _rateD\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the conversion fee is updated\r\n      *\r\n      * @param  _prevFee    previous fee percentage, represented in ppm\r\n      * @param  _newFee     new fee percentage, represented in ppm\r\n    */\r\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\r\n\r\n    /**\r\n      * @dev used by sub-contracts to initialize a new converter\r\n      *\r\n      * @param  _anchor             anchor governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IConverterAnchor _anchor,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        validAddress(_anchor)\r\n        ContractRegistryClient(_registry)\r\n        internal\r\n        validConversionFee(_maxConversionFee)\r\n    {\r\n        anchor = _anchor;\r\n        maxConversionFee = _maxConversionFee;\r\n    }\r\n\r\n    // ensures that the converter is active\r\n    modifier active() {\r\n        _active();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _active() internal view {\r\n        require(isActive(), \"ERR_INACTIVE\");\r\n    }\r\n\r\n    // ensures that the converter is not active\r\n    modifier inactive() {\r\n        _inactive();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _inactive() internal view {\r\n        require(!isActive(), \"ERR_ACTIVE\");\r\n    }\r\n\r\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\r\n    modifier validReserve(IERC20Token _address) {\r\n        _validReserve(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserve(IERC20Token _address) internal view {\r\n        require(reserves[_address].isSet, \"ERR_INVALID_RESERVE\");\r\n    }\r\n\r\n    // validates conversion fee\r\n    modifier validConversionFee(uint32 _conversionFee) {\r\n        _validConversionFee(_conversionFee);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validConversionFee(uint32 _conversionFee) internal pure {\r\n        require(_conversionFee <= CONVERSION_FEE_RESOLUTION, \"ERR_INVALID_CONVERSION_FEE\");\r\n    }\r\n\r\n    // validates reserve weight\r\n    modifier validReserveWeight(uint32 _weight) {\r\n        _validReserveWeight(_weight);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserveWeight(uint32 _weight) internal pure {\r\n        require(_weight > 0 && _weight <= WEIGHT_RESOLUTION, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n    }\r\n\r\n    /**\r\n      * @dev deposits ether\r\n      * can only be called if the converter has an ETH reserve\r\n    */\r\n    function() external payable {\r\n        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\r\n        // a workaround for a problem when running solidity-coverage\r\n        // see https://github.com/sc-forks/solidity-coverage/issues/487\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws ether\r\n      * can only be called by the owner if the converter is inactive or by upgrader contract\r\n      * can only be called after the upgrader contract has accepted the ownership of this contract\r\n      * can only be called if the converter has an ETH reserve\r\n      *\r\n      * @param _to  address to send the ETH to\r\n    */\r\n    function withdrawETH(address _to)\r\n        public\r\n        protected\r\n        ownerOnly\r\n        validReserve(IERC20Token(ETH_RESERVE_ADDRESS))\r\n    {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        _to.transfer(address(this).balance);\r\n\r\n        // sync the ETH reserve balance\r\n        syncReserveBalance(IERC20Token(ETH_RESERVE_ADDRESS));\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter version is 28 or higher\r\n      *\r\n      * @return true, since the converter version is 28 or higher\r\n    */\r\n    function isV28OrHigher() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to update & enable the conversion whitelist contract address\r\n      * when set, only addresses that are whitelisted are actually allowed to use the converter\r\n      * note that the whitelist check is actually done by the BancorNetwork contract\r\n      *\r\n      * @param _whitelist    address of a whitelist contract\r\n    */\r\n    function setConversionWhitelist(IWhitelist _whitelist)\r\n        public\r\n        ownerOnly\r\n        notThis(_whitelist)\r\n    {\r\n        conversionWhitelist = _whitelist;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if the converter is active, false otherwise\r\n      *\r\n      * @return true if the converter is active, false otherwise\r\n    */\r\n    function isActive() public view returns (bool) {\r\n        return anchor.owner() == address(this);\r\n    }\r\n\r\n    /**\r\n      * @dev transfers the anchor ownership\r\n      * the new owner needs to accept the transfer\r\n      * can only be called by the converter upgrder while the upgrader is the owner\r\n      * note that prior to version 28, you should use 'transferAnchorOwnership' instead\r\n      *\r\n      * @param _newOwner    new token owner\r\n    */\r\n    function transferAnchorOwnership(address _newOwner)\r\n        public\r\n        ownerOnly\r\n        only(CONVERTER_UPGRADER)\r\n    {\r\n        anchor.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * most converters are also activated as soon as they accept the anchor ownership\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public ownerOnly {\r\n        // verify the the converter has at least one reserve\r\n        require(reserveTokenCount() > 0, \"ERR_INVALID_RESERVE_COUNT\");\r\n        anchor.acceptOwnership();\r\n        syncReserveBalances();\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the anchor and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawFromAnchor(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        anchor.withdrawTokens(_token, _to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev updates the current conversion fee\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _conversionFee new conversion fee, represented in ppm\r\n    */\r\n    function setConversionFee(uint32 _conversionFee) public ownerOnly {\r\n        require(_conversionFee <= maxConversionFee, \"ERR_INVALID_CONVERSION_FEE\");\r\n        emit ConversionFeeUpdate(conversionFee, _conversionFee);\r\n        conversionFee = _conversionFee;\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the converter and sends them to an account\r\n      * can only be called by the owner\r\n      * note that reserve tokens can only be withdrawn by the owner while the converter is inactive\r\n      * unless the owner is the converter upgrader contract\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public protected ownerOnly {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // if the token is not a reserve token, allow withdrawal\r\n        // otherwise verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!reserves[_token].isSet || !isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        super.withdrawTokens(_token, _to, _amount);\r\n\r\n        // if the token is a reserve token, sync the reserve balance\r\n        if (reserves[_token].isSet)\r\n            syncReserveBalance(_token);\r\n    }\r\n\r\n    /**\r\n      * @dev upgrades the converter to the latest version\r\n      * can only be called by the owner\r\n      * note that the owner needs to call acceptOwnership on the new converter after the upgrade\r\n    */\r\n    function upgrade() public ownerOnly {\r\n        IConverterUpgrader converterUpgrader = IConverterUpgrader(addressOf(CONVERTER_UPGRADER));\r\n\r\n        // trigger de-activation event\r\n        emit Activation(converterType(), anchor, false);\r\n\r\n        transferOwnership(converterUpgrader);\r\n        converterUpgrader.upgrade(version);\r\n        acceptOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of reserve tokens defined\r\n      * note that prior to version 17, you should use 'connectorTokenCount' instead\r\n      *\r\n      * @return number of reserve tokens\r\n    */\r\n    function reserveTokenCount() public view returns (uint16) {\r\n        return uint16(reserveTokens.length);\r\n    }\r\n\r\n    /**\r\n      * @dev defines a new reserve token for the converter\r\n      * can only be called by the owner while the converter is inactive\r\n      *\r\n      * @param _token   address of the reserve token\r\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _weight)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n        validAddress(_token)\r\n        notThis(_token)\r\n        validReserveWeight(_weight)\r\n    {\r\n        // validate input\r\n        require(_token != address(anchor) && !reserves[_token].isSet, \"ERR_INVALID_RESERVE\");\r\n        require(_weight <= WEIGHT_RESOLUTION - reserveRatio, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n        require(reserveTokenCount() < uint16(-1), \"ERR_INVALID_RESERVE_COUNT\");\r\n\r\n        Reserve storage newReserve = reserves[_token];\r\n        newReserve.balance = 0;\r\n        newReserve.weight = _weight;\r\n        newReserve.isSet = true;\r\n        reserveTokens.push(_token);\r\n        reserveRatio += _weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's weight\r\n      * added in version 28\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve weight\r\n    */\r\n    function reserveWeight(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint32)\r\n    {\r\n        return reserves[_reserveToken].weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's balance\r\n      * note that prior to version 17, you should use 'getConnectorBalance' instead\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve balance\r\n    */\r\n    function reserveBalance(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        return reserves[_reserveToken].balance;\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter has an ETH reserve\r\n      *\r\n      * @return true if the converter has an ETH reserve, false otherwise\r\n    */\r\n    function hasETHReserve() public view returns (bool) {\r\n        return reserves[ETH_RESERVE_ADDRESS].isSet;\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function convert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary)\r\n        public\r\n        payable\r\n        protected\r\n        only(BANCOR_NETWORK)\r\n        returns (uint256)\r\n    {\r\n        // validate input\r\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\r\n\r\n        // if a whitelist is set, verify that both and trader and the beneficiary are whitelisted\r\n        require(conversionWhitelist == address(0) ||\r\n                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\r\n                \"ERR_NOT_WHITELISTED\");\r\n\r\n        return doConvert(_sourceToken, _targetToken, _amount, _trader, _beneficiary);\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * called by ConverterBase and allows the inherited contracts to implement custom conversion logic\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary) internal returns (uint256);\r\n\r\n    /**\r\n      * @dev returns the conversion fee for a given target amount\r\n      *\r\n      * @param _targetAmount  target amount\r\n      *\r\n      * @return conversion fee\r\n    */\r\n    function calculateFee(uint256 _targetAmount) internal view returns (uint256) {\r\n        return _targetAmount.mul(conversionFee).div(CONVERSION_FEE_RESOLUTION);\r\n    }\r\n\r\n    /**\r\n      * @dev syncs the stored reserve balance for a given reserve with the real reserve balance\r\n      *\r\n      * @param _reserveToken    address of the reserve token\r\n    */\r\n    function syncReserveBalance(IERC20Token _reserveToken) internal validReserve(_reserveToken) {\r\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\r\n            reserves[_reserveToken].balance = address(this).balance;\r\n        else\r\n            reserves[_reserveToken].balance = _reserveToken.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n      * @dev syncs all stored reserve balances\r\n    */\r\n    function syncReserveBalances() internal {\r\n        uint256 reserveCount = reserveTokens.length;\r\n        for (uint256 i = 0; i < reserveCount; i++)\r\n            syncReserveBalance(reserveTokens[i]);\r\n    }\r\n\r\n    /**\r\n      * @dev helper, dispatches the Conversion event\r\n      *\r\n      * @param _sourceToken     source ERC20 token\r\n      * @param _targetToken     target ERC20 token\r\n      * @param _trader          address of the caller who executed the conversion\r\n      * @param _amount          amount purchased/sold (in the source token)\r\n      * @param _returnAmount    amount returned (in the target token)\r\n    */\r\n    function dispatchConversionEvent(\r\n        IERC20Token _sourceToken,\r\n        IERC20Token _targetToken,\r\n        address _trader,\r\n        uint256 _amount,\r\n        uint256 _returnAmount,\r\n        uint256 _feeAmount)\r\n        internal\r\n    {\r\n        // fee amount is converted to 255 bits -\r\n        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\r\n        // currently the fee is always taken from the target token\r\n        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\r\n        assert(_feeAmount < 2 ** 255);\r\n        emit Conversion(_sourceToken, _targetToken, _trader, _amount, _returnAmount, int256(_feeAmount));\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\r\n    */\r\n    function token() public view returns (IConverterAnchor) {\r\n        return anchor;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\r\n        transferAnchorOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function acceptTokenOwnership() public ownerOnly {\r\n        acceptAnchorOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) {\r\n        Reserve memory reserve = reserves[_address];\r\n        return(reserve.balance, reserve.weight, false, false, reserve.isSet);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token) {\r\n        return ConverterBase.reserveTokens[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokenCount() public view returns (uint16) {\r\n        return reserveTokenCount();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256) {\r\n        return reserveBalance(_connectorToken);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getReturn(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256) {\r\n        return targetAmountAndFee(_sourceToken, _targetToken, _amount);\r\n    }\r\n}\n\n// File: solidity/contracts/converter/LiquidityPoolConverter.sol\n\npragma solidity 0.4.26;\r\r\n\r\n/**\r\n  * @dev Liquidity Pool Converter\r\n  *\r\n  * The liquidity pool converter is the base contract for specific types of converters that\r\n  * manage liquidity pools.\r\n  *\r\n  * Liquidity pools have 2 reserves or more and they allow converting between them.\r\n  *\r\n  * Note that TokenRateUpdate events are dispatched for pool tokens as well.\r\n  * The pool token is the first token in the event in that case.\r\n*/\r\ncontract LiquidityPoolConverter is ConverterBase {\r\n    /**\r\n      * @dev triggered after liquidity is added\r\n      *\r\n      * @param  _provider       liquidity provider\r\n      * @param  _reserveToken   reserve token address\r\n      * @param  _amount         reserve token amount\r\n      * @param  _newBalance     reserve token new balance\r\n      * @param  _newSupply      pool token new supply\r\n    */\r\n    event LiquidityAdded(\r\n        address indexed _provider,\r\n        address indexed _reserveToken,\r\n        uint256 _amount,\r\n        uint256 _newBalance,\r\n        uint256 _newSupply\r\n    );\r\n\r\n    /**\r\n      * @dev triggered after liquidity is removed\r\n      *\r\n      * @param  _provider       liquidity provider\r\n      * @param  _reserveToken   reserve token address\r\n      * @param  _amount         reserve token amount\r\n      * @param  _newBalance     reserve token new balance\r\n      * @param  _newSupply      pool token new supply\r\n    */\r\n    event LiquidityRemoved(\r\n        address indexed _provider,\r\n        address indexed _reserveToken,\r\n        uint256 _amount,\r\n        uint256 _newBalance,\r\n        uint256 _newSupply\r\n    );\r\n\r\n    /**\r\n      * @dev initializes a new LiquidityPoolConverter instance\r\n      *\r\n      * @param  _anchor             anchor governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IConverterAnchor _anchor,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        ConverterBase(_anchor, _registry, _maxConversionFee)\r\n        internal\r\n    {\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * also activates the converter\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public {\r\n        // verify that the converter has at least 2 reserves\r\n        require(reserveTokenCount() > 1, \"ERR_INVALID_RESERVE_COUNT\");\r\n        super.acceptAnchorOwnership();\r\n    }\r\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterFactory.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/*\n    Converter Factory interface\n*/\ncontract IConverterFactory {\n    function createAnchor(uint16 _type, string _name, string _symbol, uint8 _decimals) public returns (IConverterAnchor);\n    function createConverter(uint16 _type, IConverterAnchor _anchor, IContractRegistry _registry, uint32 _maxConversionFee) public returns (IConverter);\n\n    function customFactories(uint16 _type) public view returns (ITypedConverterCustomFactory) { _type; this; }\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2Converter.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\r\n\r\n/**\r\n  * @dev Liquidity Pool v2 Converter\r\n  *\r\n  * The liquidity pool v2 converter is a specialized version of a converter that uses\r\n  * price oracles to rebalance the reserve weights in such a way that the primary token\r\n  * balance always strives to match the staked balance.\r\n  *\r\n  * This type of liquidity pool always has 2 reserves and the reserve weights are dynamic.\r\n*/\r\ncontract LiquidityPoolV2Converter is LiquidityPoolConverter {\r\n    uint8 internal constant AMPLIFICATION_FACTOR = 20;  // factor to use for conversion calculations (reduces slippage)\r\n\r\n    struct Fraction {\r\n        uint256 n;  // numerator\r\n        uint256 d;  // denominator\r\n    }\r\n\r\n    IPriceOracle public priceOracle;                                // external price oracle\r\n    IERC20Token public primaryReserveToken;                         // primary reserve in the pool\r\n    IERC20Token public secondaryReserveToken;                       // secondary reserve in the pool (cache)\r\n    mapping (address => uint256) private stakedBalances;            // tracks the staked liquidity in the pool plus the fees\r\n    mapping (address => ISmartToken) private reservesToPoolTokens;  // maps each reserve to its pool token\r\n    mapping (address => IERC20Token) private poolTokensToReserves;  // maps each pool token to its reserve\r\n\r\n    // the period of time it takes to the last rate to fully take effect\r\n    uint256 private constant RATE_PROPAGATION_PERIOD = 10 minutes;\r\n\r\n    Fraction public referenceRate;              // reference rate from the previous block(s) of 1 primary token in secondary tokens\r\n    uint256 public referenceRateUpdateTime;     // last time when the reference rate was updated (in seconds)\r\n\r\n    Fraction public lastConversionRate;         // last conversion rate of 1 primary token in secondary tokens\r\n\r\n    // used by the temp liquidity limit mechanism during the pilot\r\n    mapping (address => uint256) public maxStakedBalances;\r\n    bool public maxStakedBalanceEnabled = true;\r\n\r\n    /**\r\n      * @dev initializes a new LiquidityPoolV2Converter instance\r\n      *\r\n      * @param  _poolTokensContainer    pool tokens container governed by the converter\r\n      * @param  _registry               address of a contract registry contract\r\n      * @param  _maxConversionFee       maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(IPoolTokensContainer _poolTokensContainer, IContractRegistry _registry, uint32 _maxConversionFee)\r\n        public LiquidityPoolConverter(_poolTokensContainer, _registry, _maxConversionFee)\r\n    {\r\n    }\r\n\r\n    // ensures the address is a pool token\r\n    modifier validPoolToken(ISmartToken _address) {\r\n        _validPoolToken(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validPoolToken(ISmartToken _address) internal view {\r\n        require(poolTokensToReserves[_address] != address(0), \"ERR_INVALID_POOL_TOKEN\");\r\n    }\r\n\r\n    /**\r\n      * @dev returns the converter type\r\n      *\r\n      * @return see the converter types in the the main contract doc\r\n    */\r\n    function converterType() public pure returns (uint16) {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if the converter is active, false otherwise\r\n      *\r\n      * @return true if the converter is active, false otherwise\r\n    */\r\n    function isActive() public view returns (bool) {\r\n        return super.isActive() && priceOracle != address(0);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the liquidity amplification factor in the pool\r\n      *\r\n      * @return liquidity amplification factor\r\n    */\r\n    function amplificationFactor() public pure returns (uint8) {\r\n        return AMPLIFICATION_FACTOR;\r\n    }\r\n\r\n    /**\r\n      * @dev sets the pool's primary reserve token / price oracles and activates the pool\r\n      * each oracle must be able to provide the rate for each reserve token\r\n      * note that the oracle must be whitelisted prior to the call\r\n      * can only be called by the owner while the pool is inactive\r\n      *\r\n      * @param _primaryReserveToken     address of the pool's primary reserve token\r\n      * @param _primaryReserveOracle    address of a chainlink price oracle for the primary reserve token\r\n      * @param _secondaryReserveOracle  address of a chainlink price oracle for the secondary reserve token\r\n    */\r\n    function activate(IERC20Token _primaryReserveToken, IChainlinkPriceOracle _primaryReserveOracle, IChainlinkPriceOracle _secondaryReserveOracle)\r\n        public\r\n        inactive\r\n        ownerOnly\r\n        validReserve(_primaryReserveToken)\r\n        notThis(_primaryReserveOracle)\r\n        notThis(_secondaryReserveOracle)\r\n        validAddress(_primaryReserveOracle)\r\n        validAddress(_secondaryReserveOracle)\r\n    {\r\n        // validate anchor ownership\r\n        require(anchor.owner() == address(this), \"ERR_ANCHOR_NOT_OWNED\");\r\n\r\n        // validate oracles\r\n        IWhitelist oracleWhitelist = IWhitelist(addressOf(CHAINLINK_ORACLE_WHITELIST));\r\n        require(oracleWhitelist.isWhitelisted(_primaryReserveOracle), \"ERR_INVALID_ORACLE\");\r\n        require(oracleWhitelist.isWhitelisted(_secondaryReserveOracle), \"ERR_INVALID_ORACLE\");\r\n\r\n        // create the converter's pool tokens if they don't already exist\r\n        createPoolTokens();\r\n\r\n        // sets the primary & secondary reserve tokens\r\n        primaryReserveToken = _primaryReserveToken;\r\n        if (_primaryReserveToken == reserveTokens[0])\r\n            secondaryReserveToken = reserveTokens[1];\r\n        else\r\n            secondaryReserveToken = reserveTokens[0];\r\n\r\n        // creates and initalizes the price oracle and sets initial rates\r\n        LiquidityPoolV2ConverterCustomFactory customFactory =\r\n            LiquidityPoolV2ConverterCustomFactory(IConverterFactory(addressOf(CONVERTER_FACTORY)).customFactories(converterType()));\r\n        priceOracle = customFactory.createPriceOracle(_primaryReserveToken, secondaryReserveToken, _primaryReserveOracle, _secondaryReserveOracle);\r\n\r\n        (referenceRate.n, referenceRate.d) = priceOracle.latestRate(primaryReserveToken, secondaryReserveToken);\r\n        lastConversionRate = referenceRate;\r\n\r\n        referenceRateUpdateTime = time();\r\n\r\n        // if we are upgrading from an older converter, make sure that reserve balances are in-sync and rebalance\r\n        uint256 primaryReserveStakedBalance = reserveStakedBalance(primaryReserveToken);\r\n        uint256 primaryReserveBalance = reserveBalance(primaryReserveToken);\r\n        uint256 secondaryReserveBalance = reserveBalance(secondaryReserveToken);\r\n\r\n        if (primaryReserveStakedBalance == primaryReserveBalance) {\r\n            if (primaryReserveStakedBalance > 0 || secondaryReserveBalance > 0) {\r\n                rebalance();\r\n            }\r\n        }\r\n        else if (primaryReserveStakedBalance > 0 && primaryReserveBalance > 0 && secondaryReserveBalance > 0) {\r\n            rebalance();\r\n        }\r\n\r\n        emit Activation(converterType(), anchor, true);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the staked balance of a given reserve token\r\n      *\r\n      * @param _reserveToken    reserve token address\r\n      *\r\n      * @return staked balance\r\n    */\r\n    function reserveStakedBalance(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        return stakedBalances[_reserveToken];\r\n    }\r\n\r\n    /**\r\n      * @dev returns the amplified balance of a given reserve token\r\n      *\r\n      * @param _reserveToken   reserve token address\r\n      *\r\n      * @return amplified balance\r\n    */\r\n    function reserveAmplifiedBalance(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        return stakedBalances[_reserveToken].mul(AMPLIFICATION_FACTOR - 1).add(reserveBalance(_reserveToken));\r\n    }\r\n\r\n    /**\r\n      * @dev sets the reserve's staked balance\r\n      * can only be called by the upgrader contract while the upgrader is the owner\r\n      *\r\n      * @param _reserveToken    reserve token address\r\n      * @param _balance         new reserve staked balance\r\n    */\r\n    function setReserveStakedBalance(IERC20Token _reserveToken, uint256 _balance)\r\n        public\r\n        ownerOnly\r\n        only(CONVERTER_UPGRADER)\r\n        validReserve(_reserveToken)\r\n    {\r\n        stakedBalances[_reserveToken] = _balance;\r\n    }\r\n\r\n    /**\r\n      * @dev sets the max staked balance for both reserves\r\n      * available as a temporary mechanism during the pilot\r\n      * can only be called by the owner\r\n      *\r\n      * @param _reserve1MaxStakedBalance    max staked balance for reserve 1\r\n      * @param _reserve2MaxStakedBalance    max staked balance for reserve 2\r\n    */\r\n    function setMaxStakedBalances(uint256 _reserve1MaxStakedBalance, uint256 _reserve2MaxStakedBalance) public ownerOnly {\r\n        maxStakedBalances[reserveTokens[0]] = _reserve1MaxStakedBalance;\r\n        maxStakedBalances[reserveTokens[1]] = _reserve2MaxStakedBalance;\r\n    }\r\n\r\n    /**\r\n      * @dev disables the max staked balance mechanism\r\n      * available as a temporary mechanism during the pilot\r\n      * once disabled, it cannot be re-enabled\r\n      * can only be called by the owner\r\n    */\r\n    function disableMaxStakedBalances() public ownerOnly {\r\n        maxStakedBalanceEnabled = false;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the pool token address by the reserve token address\r\n      *\r\n      * @param _reserveToken    reserve token address\r\n      *\r\n      * @return pool token address\r\n    */\r\n    function poolToken(IERC20Token _reserveToken) public view returns (ISmartToken) {\r\n        return reservesToPoolTokens[_reserveToken];\r\n    }\r\n\r\n    /**\r\n      * @dev returns the maximum number of pool tokens that can currently be liquidated\r\n      *\r\n      * @param _poolToken   address of the pool token\r\n      *\r\n      * @return liquidation limit\r\n    */\r\n    function liquidationLimit(ISmartToken _poolToken) public view returns (uint256) {\r\n        // get the pool token supply\r\n        uint256 poolTokenSupply = _poolToken.totalSupply();\r\n\r\n        // get the reserve token associated with the pool token and its balance / staked balance\r\n        IERC20Token reserveToken = poolTokensToReserves[_poolToken];\r\n        uint256 balance = reserveBalance(reserveToken);\r\n        uint256 stakedBalance = stakedBalances[reserveToken];\r\n\r\n        // calculate the amount that's available for liquidation\r\n        return balance.mul(poolTokenSupply).div(stakedBalance);\r\n    }\r\n\r\n    /**\r\n      * @dev defines a new reserve token for the converter\r\n      * can only be called by the owner while the converter is inactive and\r\n      * 2 reserves aren't defined yet\r\n      *\r\n      * @param _token   address of the reserve token\r\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _weight) public {\r\n        // verify that the converter doesn't have 2 reserves yet\r\n        require(reserveTokenCount() < 2, \"ERR_INVALID_RESERVE_COUNT\");\r\n        super.addReserve(_token, _weight);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the effective rate of 1 primary token in secondary tokens\r\n      *\r\n      * @return rate of 1 primary token in secondary tokens (numerator)\r\n      * @return rate of 1 primary token in secondary tokens (denominator)\r\n    */\r\n    function effectiveTokensRate() public view returns (uint256, uint256) {\r\n        Fraction memory rate = _effectiveTokensRate();\r\n        return (rate.n, rate.d);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the effective reserve tokens weights\r\n      *\r\n      * @return reserve1 weight\r\n      * @return reserve2 weight\r\n    */\r\n    function effectiveReserveWeights() public view returns (uint256, uint256) {\r\n        Fraction memory rate = _effectiveTokensRate();\r\n        (uint32 primaryReserveWeight, uint32 secondaryReserveWeight) = effectiveReserveWeights(rate);\r\n\r\n        if (primaryReserveToken == reserveTokens[0]) {\r\n            return (primaryReserveWeight, secondaryReserveWeight);\r\n        }\r\n\r\n        return (secondaryReserveWeight, primaryReserveWeight);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of converting one reserve to another along with the fee\r\n      *\r\n      * @param _sourceToken contract address of the source reserve token\r\n      * @param _targetToken contract address of the target reserve token\r\n      * @param _amount      amount of tokens received from the user\r\n      *\r\n      * @return expected target amount\r\n      * @return expected fee\r\n    */\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount)\r\n        public\r\n        view\r\n        active\r\n        returns (uint256, uint256)\r\n    {\r\n        // validate input\r\n        // not using the `validReserve` modifier to circumvent `stack too deep` compiler error\r\n        _validReserve(_sourceToken);\r\n        _validReserve(_targetToken);\r\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\r\n\r\n        // check if rebalance is required (some of this code is duplicated for gas optimization)\r\n        uint32 sourceTokenWeight;\r\n        uint32 targetTokenWeight;\r\n\r\n        // if the rate was already checked in this block, use the current weights.\r\n        // otherwise, get the new weights\r\n        Fraction memory rate;\r\n        if (referenceRateUpdateTime == time()) {\r\n            rate = referenceRate;\r\n            sourceTokenWeight = reserves[_sourceToken].weight;\r\n            targetTokenWeight = reserves[_targetToken].weight;\r\n        }\r\n        else {\r\n            // get the new rate / reserve weights\r\n            rate = _effectiveTokensRate();\r\n            (uint32 primaryReserveWeight, uint32 secondaryReserveWeight) = effectiveReserveWeights(rate);\r\n\r\n            if (_sourceToken == primaryReserveToken) {\r\n                sourceTokenWeight = primaryReserveWeight;\r\n                targetTokenWeight = secondaryReserveWeight;\r\n            }\r\n            else {\r\n                sourceTokenWeight = secondaryReserveWeight;\r\n                targetTokenWeight = primaryReserveWeight;\r\n            }\r\n        }\r\n\r\n        // return the target amount and the adjusted fee using the updated reserve weights\r\n        (uint256 targetAmount, , uint256 fee) = targetAmountAndFees(_sourceToken, _targetToken, sourceTokenWeight, targetTokenWeight, rate, _amount);\r\n        return (targetAmount, fee);\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary)\r\n        internal\r\n        active\r\n        validReserve(_sourceToken)\r\n        validReserve(_targetToken)\r\n        returns (uint256)\r\n    {\r\n        // convert the amount and return the resulted amount and fee\r\n        (uint256 amount, uint256 fee) = doConvert(_sourceToken, _targetToken, _amount);\r\n\r\n        // transfer funds to the beneficiary in the to reserve token\r\n        if (_targetToken == ETH_RESERVE_ADDRESS) {\r\n            _beneficiary.transfer(amount);\r\n        }\r\n        else {\r\n            safeTransfer(_targetToken, _beneficiary, amount);\r\n        }\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(_sourceToken, _targetToken, _trader, _amount, amount, fee);\r\n\r\n        // dispatch rate updates for the pool / reserve tokens\r\n        dispatchRateEvents(_sourceToken, _targetToken, reserves[_sourceToken].weight, reserves[_targetToken].weight);\r\n\r\n        // return the conversion result amount\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n      * @return expected fee\r\n    */\r\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) private returns (uint256, uint256) {\r\n        // check if the rate has changed and rebalance the pool if needed (once in a block)\r\n        (bool rateUpdated, Fraction memory rate) = handleRateChange();\r\n\r\n        // get expected target amount and fees\r\n        (uint256 amount, uint256 normalFee, uint256 adjustedFee) = targetAmountAndFees(_sourceToken, _targetToken, 0, 0, rate, _amount);\r\n\r\n        // ensure that the trade gives something in return\r\n        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\r\n\r\n        // ensure that the trade won't deplete the reserve balance\r\n        uint256 targetReserveBalance = reserveBalance(_targetToken);\r\n        require(amount < targetReserveBalance, \"ERR_TARGET_AMOUNT_TOO_HIGH\");\r\n\r\n        // ensure that the input amount was already deposited\r\n        if (_sourceToken == ETH_RESERVE_ADDRESS)\r\n            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n        else\r\n            require(msg.value == 0 && _sourceToken.balanceOf(this).sub(reserveBalance(_sourceToken)) >= _amount, \"ERR_INVALID_AMOUNT\");\r\n\r\n        // sync the reserve balances\r\n        syncReserveBalance(_sourceToken);\r\n        reserves[_targetToken].balance = targetReserveBalance.sub(amount);\r\n\r\n        // update the target staked balance with the fee\r\n        stakedBalances[_targetToken] = stakedBalances[_targetToken].add(normalFee);\r\n\r\n        // update the last conversion rate\r\n        if (rateUpdated) {\r\n            lastConversionRate = tokensRate(primaryReserveToken, secondaryReserveToken, 0, 0);\r\n        }\r\n\r\n        return (amount, adjustedFee);\r\n    }\r\n\r\n    /**\r\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\r\n      *\r\n      * @param _reserveToken    address of the reserve token to add liquidity to\r\n      * @param _amount          amount of liquidity to add\r\n      * @param _minReturn       minimum return-amount of pool tokens\r\n      *\r\n      * @return amount of pool tokens minted\r\n    */\r\n    function addLiquidity(IERC20Token _reserveToken, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        payable\r\n        protected\r\n        active\r\n        validReserve(_reserveToken)\r\n        greaterThanZero(_amount)\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        // verify that msg.value is identical to the provided amount for ETH reserve, or 0 otherwise\r\n        require(_reserveToken == ETH_RESERVE_ADDRESS ? msg.value == _amount : msg.value == 0, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n\r\n        // sync the reserve balances just in case\r\n        syncReserveBalances();\r\n\r\n        // for ETH reserve, deduct the amount that was just synced (since it's already in the converter)\r\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\r\n            reserves[ETH_RESERVE_ADDRESS].balance = reserves[ETH_RESERVE_ADDRESS].balance.sub(msg.value);\r\n\r\n        // get the reserve staked balance before adding the liquidity to it\r\n        uint256 initialStakedBalance = stakedBalances[_reserveToken];\r\n\r\n        // during the pilot, ensure that the new staked balance isn't greater than the max limit\r\n        if (maxStakedBalanceEnabled) {\r\n            require(maxStakedBalances[_reserveToken] == 0 || initialStakedBalance.add(_amount) <= maxStakedBalances[_reserveToken], \"ERR_MAX_STAKED_BALANCE_REACHED\");\r\n        }\r\n\r\n        // get the pool token associated with the reserve and its supply\r\n        ISmartToken reservePoolToken = reservesToPoolTokens[_reserveToken];\r\n        uint256 poolTokenSupply = reservePoolToken.totalSupply();\r\n\r\n        // for non ETH reserve, transfer the funds from the user to the pool\r\n        if (_reserveToken != ETH_RESERVE_ADDRESS)\r\n            safeTransferFrom(_reserveToken, msg.sender, this, _amount);\r\n\r\n        // sync the reserve balance / staked balance\r\n        reserves[_reserveToken].balance = reserves[_reserveToken].balance.add(_amount);\r\n        stakedBalances[_reserveToken] = initialStakedBalance.add(_amount);\r\n\r\n        // calculate how many pool tokens to mint\r\n        // for an empty pool, the price is 1:1, otherwise the price is based on the ratio\r\n        // between the pool token supply and the staked balance\r\n        uint256 poolTokenAmount = 0;\r\n        if (initialStakedBalance == 0 || poolTokenSupply == 0)\r\n            poolTokenAmount = _amount;\r\n        else\r\n            poolTokenAmount = _amount.mul(poolTokenSupply).div(initialStakedBalance);\r\n        require(poolTokenAmount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\r\n\r\n        // mint new pool tokens to the caller\r\n        IPoolTokensContainer(anchor).mint(reservePoolToken, msg.sender, poolTokenAmount);\r\n\r\n        // rebalance the pool's reserve weights\r\n        rebalance();\r\n\r\n        // dispatch the LiquidityAdded event\r\n        emit LiquidityAdded(msg.sender, _reserveToken, _amount, initialStakedBalance.add(_amount), poolTokenSupply.add(poolTokenAmount));\r\n\r\n        // dispatch the `TokenRateUpdate` event for the pool token\r\n        dispatchPoolTokenRateUpdateEvent(reservePoolToken, poolTokenSupply.add(poolTokenAmount), _reserveToken);\r\n\r\n        // dispatch the `TokenRateUpdate` event for the reserve tokens\r\n        dispatchTokenRateUpdateEvent(reserveTokens[0], reserveTokens[1], 0, 0);\r\n\r\n        // return the amount of pool tokens minted\r\n        return poolTokenAmount;\r\n    }\r\n\r\n    /**\r\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\r\n      *\r\n      * @param _poolToken   address of the pool token\r\n      * @param _amount      amount of pool tokens to burn\r\n      * @param _minReturn   minimum return-amount of reserve tokens\r\n      *\r\n      * @return amount of liquidity removed\r\n    */\r\n    function removeLiquidity(ISmartToken _poolToken, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        protected\r\n        active\r\n        validPoolToken(_poolToken)\r\n        greaterThanZero(_amount)\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        // sync the reserve balances just in case\r\n        syncReserveBalances();\r\n\r\n        // get the pool token supply before burning the caller's shares\r\n        uint256 initialPoolSupply = _poolToken.totalSupply();\r\n\r\n        // get the reserve token return before burning the caller's shares\r\n        (uint256 reserveAmount, ) = removeLiquidityReturnAndFee(_poolToken, _amount);\r\n        require(reserveAmount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\r\n\r\n        // get the reserve token associated with the pool token\r\n        IERC20Token reserveToken = poolTokensToReserves[_poolToken];\r\n\r\n        // burn the caller's pool tokens\r\n        IPoolTokensContainer(anchor).burn(_poolToken, msg.sender, _amount);\r\n\r\n        // sync the reserve balance / staked balance\r\n        reserves[reserveToken].balance = reserves[reserveToken].balance.sub(reserveAmount);\r\n        uint256 newStakedBalance = stakedBalances[reserveToken].sub(reserveAmount);\r\n        stakedBalances[reserveToken] = newStakedBalance;\r\n\r\n        // transfer the reserve amount to the caller\r\n        if (reserveToken == ETH_RESERVE_ADDRESS)\r\n            msg.sender.transfer(reserveAmount);\r\n        else\r\n            safeTransfer(reserveToken, msg.sender, reserveAmount);\r\n\r\n        // rebalance the pool's reserve weights\r\n        rebalance();\r\n\r\n        uint256 newPoolTokenSupply = initialPoolSupply.sub(_amount);\r\n\r\n        // dispatch the LiquidityRemoved event\r\n        emit LiquidityRemoved(msg.sender, reserveToken, reserveAmount, newStakedBalance, newPoolTokenSupply);\r\n\r\n        // dispatch the `TokenRateUpdate` event for the pool token\r\n        dispatchPoolTokenRateUpdateEvent(_poolToken, newPoolTokenSupply, reserveToken);\r\n\r\n        // dispatch the `TokenRateUpdate` event for the reserve tokens\r\n        dispatchTokenRateUpdateEvent(reserveTokens[0], reserveTokens[1], 0, 0);\r\n\r\n        // return the amount of liquidity removed\r\n        return reserveAmount;\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the amount of reserve tokens entitled for a given amount of pool tokens\r\n      * note that a fee is applied according to the equilibrium level of the primary reserve token\r\n      *\r\n      * @param _poolToken   address of the pool token\r\n      * @param _amount      amount of pool tokens\r\n      *\r\n      * @return amount after fee and fee, in reserve token units\r\n    */\r\n    function removeLiquidityReturnAndFee(ISmartToken _poolToken, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 totalSupply = _poolToken.totalSupply();\r\n        uint256 stakedBalance = stakedBalances[poolTokensToReserves[_poolToken]];\r\n\r\n        if (_amount < totalSupply) {\r\n            uint256 x = stakedBalances[primaryReserveToken].mul(AMPLIFICATION_FACTOR);\r\n            uint256 y = reserveAmplifiedBalance(primaryReserveToken);\r\n            (uint256 min, uint256 max) = x < y ? (x, y) : (y, x);\r\n            uint256 amountBeforeFee = _amount.mul(stakedBalance).div(totalSupply);\r\n            uint256 amountAfterFee = amountBeforeFee.mul(min).div(max);\r\n            return (amountAfterFee, amountBeforeFee - amountAfterFee);\r\n        }\r\n        return (stakedBalance, 0);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of converting one reserve to another along with the fees\r\n      * this version of the function expects the reserve weights as an input (gas optimization)\r\n      *\r\n      * @param _sourceToken     contract address of the source reserve token\r\n      * @param _targetToken     contract address of the target reserve token\r\n      * @param _sourceWeight    source reserve token weight or 0 to read it from storage\r\n      * @param _targetWeight    target reserve token weight or 0 to read it from storage\r\n      * @param _rate            rate between the reserve tokens\r\n      * @param _amount          amount of tokens received from the user\r\n      *\r\n      * @return expected target amount\r\n      * @return expected fee (normal)\r\n      * @return expected fee (adjusted)\r\n    */\r\n    function targetAmountAndFees(\r\n        IERC20Token _sourceToken,\r\n        IERC20Token _targetToken,\r\n        uint32 _sourceWeight,\r\n        uint32 _targetWeight,\r\n        Fraction memory _rate,\r\n        uint256 _amount)\r\n        private\r\n        view\r\n        returns (uint256 targetAmount, uint256 normalFee, uint256 adjustedFee)\r\n    {\r\n        if (_sourceWeight == 0)\r\n            _sourceWeight = reserves[_sourceToken].weight;\r\n        if (_targetWeight == 0)\r\n            _targetWeight = reserves[_targetToken].weight;\r\n\r\n        // get the tokens amplified balances\r\n        uint256 sourceBalance = reserveAmplifiedBalance(_sourceToken);\r\n        uint256 targetBalance = reserveAmplifiedBalance(_targetToken);\r\n\r\n        // get the target amount\r\n        targetAmount = IBancorFormula(addressOf(BANCOR_FORMULA)).crossReserveTargetAmount(\r\n            sourceBalance,\r\n            _sourceWeight,\r\n            targetBalance,\r\n            _targetWeight,\r\n            _amount\r\n        );\r\n\r\n        // return the target amount minus the conversion fee and the conversion fee\r\n        normalFee = super.calculateFee(targetAmount);\r\n        adjustedFee = calculateFee(_targetToken, _sourceWeight, _targetWeight, _rate, targetAmount);\r\n        targetAmount -= adjustedFee;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the conversion fee for a given target amount\r\n      *\r\n      * @param _targetToken     contract address of the target reserve token\r\n      * @param _sourceWeight    source reserve token weight\r\n      * @param _targetWeight    target reserve token weight\r\n      * @param _rate            rate of 1 primary token in secondary tokens\r\n      * @param _targetAmount    target amount\r\n      *\r\n      * @return conversion fee\r\n    */\r\n    function calculateFee(\r\n        IERC20Token _targetToken,\r\n        uint32 _sourceWeight,\r\n        uint32 _targetWeight,\r\n        Fraction memory _rate,\r\n        uint256 _targetAmount)\r\n        internal view returns (uint256)\r\n    {\r\n        // conversions to the primary reserve apply normal fees\r\n        if (_targetToken == primaryReserveToken) {\r\n            return super.calculateFee(_targetAmount);\r\n        }\r\n\r\n        // get the adjusted fee\r\n        uint256 fee = calculateAdjustedFee(\r\n            stakedBalances[primaryReserveToken],\r\n            stakedBalances[secondaryReserveToken],\r\n            _sourceWeight,\r\n            _targetWeight,\r\n            _rate.n,\r\n            _rate.d,\r\n            conversionFee);\r\n\r\n        // calculate the fee based on the adjusted value\r\n        return _targetAmount.mul(fee).div(CONVERSION_FEE_RESOLUTION);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the fee required for mitigating the secondary reserve distance from equilibrium\r\n      *\r\n      * assumption: _conversionFee * 2 <= CONVERSION_FEE_RESOLUTION\r\n      *\r\n      * @param _primaryReserveStaked    primary reserve staked balance\r\n      * @param _secondaryReserveStaked  secondary reserve staked balance\r\n      * @param _primaryReserveWeight    primary reserve weight\r\n      * @param _secondaryReserveWeight  secondary reserve weight\r\n      * @param _primaryReserveRate      primary reserve rate\r\n      * @param _secondaryReserveRate    secondary reserve rate\r\n      * @param _conversionFee           conversion fee\r\n      *\r\n      * @return adjusted fee\r\n    */\r\n    function calculateAdjustedFee(\r\n        uint256 _primaryReserveStaked,\r\n        uint256 _secondaryReserveStaked,\r\n        uint256 _primaryReserveWeight,\r\n        uint256 _secondaryReserveWeight,\r\n        uint256 _primaryReserveRate,\r\n        uint256 _secondaryReserveRate,\r\n        uint256 _conversionFee)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 x = _primaryReserveStaked.mul(_primaryReserveRate).mul(_secondaryReserveWeight);\r\n        uint256 y = _secondaryReserveStaked.mul(_secondaryReserveRate).mul(_primaryReserveWeight);\r\n\r\n        if (x.mul(AMPLIFICATION_FACTOR) >= y.mul(AMPLIFICATION_FACTOR + 1))\r\n            return _conversionFee / 2;\r\n\r\n        if (x.mul(AMPLIFICATION_FACTOR * 2) <= y.mul(AMPLIFICATION_FACTOR * 2 - 1))\r\n            return _conversionFee * 2;\r\n\r\n        return _conversionFee.mul(y).div(x.mul(AMPLIFICATION_FACTOR).sub(y.mul(AMPLIFICATION_FACTOR - 1)));\r\n    }\r\n\r\n    /**\r\n      * @dev creates the converter's pool tokens\r\n      * note that technically pool tokens can be created on deployment but gas limit\r\n      * might get too high for a block, so creating them on first activation\r\n      *\r\n    */\r\n    function createPoolTokens() internal {\r\n        IPoolTokensContainer container = IPoolTokensContainer(anchor);\r\n        if (container.poolTokens().length != 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 reserveCount = reserveTokens.length;\r\n        for (uint256 i = 0; i < reserveCount; i++) {\r\n            ISmartToken reservePoolToken = container.createToken();\r\n\r\n            // cache the pool token address (gas optimization)\r\n            reservesToPoolTokens[reserveTokens[i]] = reservePoolToken;\r\n            poolTokensToReserves[reservePoolToken] = reserveTokens[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev returns the effective rate between the two reserve tokens\r\n      *\r\n      * @return rate\r\n    */\r\n    function _effectiveTokensRate() private view returns (Fraction memory) {\r\n        // get the external rate between the reserves\r\n        (uint256 externalRateN, uint256 externalRateD, uint256 updateTime) = priceOracle.latestRateAndUpdateTime(primaryReserveToken, secondaryReserveToken);\r\n\r\n        // if the external rate was recently updated - prefer it over the internal rate\r\n        if (updateTime > referenceRateUpdateTime) {\r\n            return Fraction({ n: externalRateN, d: externalRateD });\r\n        }\r\n\r\n        // get the elapsed time between the current and the last conversion\r\n        uint256 timeElapsed = time() - referenceRateUpdateTime;\r\n\r\n        // if both of the conversions are in the same block - use the reference rate\r\n        if (timeElapsed == 0) {\r\n            return referenceRate;\r\n        }\r\n\r\n        // given N as the sampling window, the new internal rate is calculated according to the following formula:\r\n        //   newRate = referenceRate + timeElapsed * [lastConversionRate - referenceRate] / N\r\n\r\n        // if a long period of time, since the last update, has passed - the last rate should fully take effect\r\n        if (timeElapsed >= RATE_PROPAGATION_PERIOD) {\r\n            return lastConversionRate;\r\n        }\r\n\r\n        // calculate the numerator and the denumerator of the new rate\r\n        Fraction memory ref = referenceRate;\r\n        Fraction memory last = lastConversionRate;\r\n\r\n        uint256 x = ref.d.mul(last.n);\r\n        uint256 y = ref.n.mul(last.d);\r\n\r\n        // since we know that timeElapsed < RATE_PROPAGATION_PERIOD, we can avoid using SafeMath:\r\n        uint256 newRateN = y.mul(RATE_PROPAGATION_PERIOD - timeElapsed).add(x.mul(timeElapsed));\r\n        uint256 newRateD = ref.d.mul(last.d).mul(RATE_PROPAGATION_PERIOD);\r\n\r\n        return reduceRate(newRateN, newRateD);\r\n    }\r\n\r\n    /**\r\n      * @dev checks if the rate has changed and if so, rebalances the weights\r\n      * note that rebalancing based on rate change only happens once per block\r\n      *\r\n      * @return whether the rate was updated\r\n      * @return rate between the reserve tokens\r\n    */\r\n    function handleRateChange() private returns (bool, Fraction memory) {\r\n        uint256 currentTime = time();\r\n\r\n        // avoid updating the rate more than once per block\r\n        if (referenceRateUpdateTime == currentTime) {\r\n            return (false, referenceRate);\r\n        }\r\n\r\n        // get and store the effective rate between the reserves\r\n        Fraction memory newRate = _effectiveTokensRate();\r\n\r\n        // if the rate has changed, update it and rebalance the pool\r\n        Fraction memory ref = referenceRate;\r\n        if (newRate.n == ref.n && newRate.d == ref.d) {\r\n            return (false, newRate);\r\n        }\r\n\r\n        referenceRate = newRate;\r\n        referenceRateUpdateTime = currentTime;\r\n\r\n        rebalance();\r\n\r\n        return (true, newRate);\r\n    }\r\n\r\n    /**\r\n      * @dev updates the pool's reserve weights with new values in order to push the current primary\r\n      * reserve token balance to its staked balance\r\n    */\r\n    function rebalance() private {\r\n        // get the new reserve weights\r\n        (uint32 primaryReserveWeight, uint32 secondaryReserveWeight) = effectiveReserveWeights(referenceRate);\r\n\r\n        // update the reserve weights with the new values\r\n        reserves[primaryReserveToken].weight = primaryReserveWeight;\r\n        reserves[secondaryReserveToken].weight = secondaryReserveWeight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the effective reserve weights based on the staked balance, current balance and oracle price\r\n      *\r\n      * @param _rate    rate between the reserve tokens\r\n      *\r\n      * @return new primary reserve weight\r\n      * @return new secondary reserve weight\r\n    */\r\n    function effectiveReserveWeights(Fraction memory _rate) private view returns (uint32, uint32) {\r\n        // get the primary reserve staked balance\r\n        uint256 primaryStakedBalance = stakedBalances[primaryReserveToken];\r\n\r\n        // get the tokens amplified balances\r\n        uint256 primaryBalance = reserveAmplifiedBalance(primaryReserveToken);\r\n        uint256 secondaryBalance = reserveAmplifiedBalance(secondaryReserveToken);\r\n\r\n        // get the new weights\r\n        return IBancorFormula(addressOf(BANCOR_FORMULA)).balancedWeights(\r\n            primaryStakedBalance.mul(AMPLIFICATION_FACTOR),\r\n            primaryBalance,\r\n            secondaryBalance,\r\n            _rate.n,\r\n            _rate.d);\r\n    }\r\n\r\n    /**\r\n      * @dev calculates and returns the rate between two reserve tokens\r\n      *\r\n      * @param _token1          contract address of the token to calculate the rate of one unit of\r\n      * @param _token2          contract address of the token to calculate the rate of one `_token1` unit in\r\n      * @param _token1Weight    reserve weight of token1\r\n      * @param _token2Weight    reserve weight of token2\r\n      *\r\n      * @return rate\r\n    */\r\n    function tokensRate(IERC20Token _token1, IERC20Token _token2, uint32 _token1Weight, uint32 _token2Weight) private view returns (Fraction memory) {\r\n        // apply the amplification factor\r\n        uint256 token1Balance = reserveAmplifiedBalance(_token1);\r\n        uint256 token2Balance = reserveAmplifiedBalance(_token2);\r\n\r\n        // get reserve weights\r\n        if (_token1Weight == 0) {\r\n            _token1Weight = reserves[_token1].weight;\r\n        }\r\n\r\n        if (_token2Weight == 0) {\r\n            _token2Weight = reserves[_token2].weight;\r\n        }\r\n\r\n        return Fraction({ n: token2Balance.mul(_token1Weight), d: token1Balance.mul(_token2Weight) });\r\n    }\r\n\r\n    /**\r\n      * @dev dispatches rate events for both reserve tokens and for the target pool token\r\n      * only used to circumvent the `stack too deep` compiler error\r\n      *\r\n      * @param _sourceToken     contract address of the source reserve token\r\n      * @param _targetToken     contract address of the target reserve token\r\n      * @param _sourceWeight    source reserve token weight\r\n      * @param _targetWeight    target reserve token weight\r\n    */\r\n    function dispatchRateEvents(IERC20Token _sourceToken, IERC20Token _targetToken, uint32 _sourceWeight, uint32 _targetWeight) private {\r\n        dispatchTokenRateUpdateEvent(_sourceToken, _targetToken, _sourceWeight, _targetWeight);\r\n\r\n        // dispatch the `TokenRateUpdate` event for the pool token\r\n        // the target reserve pool token rate is the only one that's affected\r\n        // by conversions since conversion fees are applied to the target reserve\r\n        ISmartToken targetPoolToken = poolToken(_targetToken);\r\n        uint256 targetPoolTokenSupply = targetPoolToken.totalSupply();\r\n        dispatchPoolTokenRateUpdateEvent(targetPoolToken, targetPoolTokenSupply, _targetToken);\r\n    }\r\n\r\n    /**\r\n      * @dev dispatches token rate update event\r\n      * only used to circumvent the `stack too deep` compiler error\r\n      *\r\n      * @param _token1          contract address of the token to calculate the rate of one unit of\r\n      * @param _token2          contract address of the token to calculate the rate of one `_token1` unit in\r\n      * @param _token1Weight    reserve weight of token1\r\n      * @param _token2Weight    reserve weight of token2\r\n    */\r\n    function dispatchTokenRateUpdateEvent(IERC20Token _token1, IERC20Token _token2, uint32 _token1Weight, uint32 _token2Weight) private {\r\n        // dispatch token rate update event\r\n        Fraction memory rate = tokensRate(_token1, _token2, _token1Weight, _token2Weight);\r\n\r\n        emit TokenRateUpdate(_token1, _token2, rate.n, rate.d);\r\n    }\r\n\r\n    /**\r\n      * @dev dispatches the `TokenRateUpdate` for the pool token\r\n      * only used to circumvent the `stack too deep` compiler error\r\n      *\r\n      * @param _poolToken       address of the pool token\r\n      * @param _poolTokenSupply total pool token supply\r\n      * @param _reserveToken    address of the reserve token\r\n    */\r\n    function dispatchPoolTokenRateUpdateEvent(ISmartToken _poolToken, uint256 _poolTokenSupply, IERC20Token _reserveToken) private {\r\n        emit TokenRateUpdate(_poolToken, _reserveToken, stakedBalances[_reserveToken], _poolTokenSupply);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the current time\r\n    */\r\n    function time() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    uint256 private constant MAX_RATE_FACTOR_LOWER_BOUND = 1e30;\r\n    uint256 private constant MAX_RATE_FACTOR_UPPER_BOUND = uint256(-1) / MAX_RATE_FACTOR_LOWER_BOUND;\r\n\r\n    /**\r\n      * @dev reduces the numerator and denominator while maintaining the ratio between them as accurately as possible\r\n    */\r\n    function reduceRate(uint256 _n, uint256 _d) internal pure returns (Fraction memory) {\r\n        if (_n >= _d) {\r\n            return reduceFactors(_n, _d);\r\n        }\r\n\r\n        Fraction memory rate = reduceFactors(_d, _n);\r\n        return Fraction({ n: rate.d, d: rate.n });\r\n    }\r\n\r\n    /**\r\n      * @dev reduces the factors while maintaining the ratio between them as accurately as possible\r\n    */\r\n    function reduceFactors(uint256 _max, uint256 _min) internal pure returns (Fraction memory) {\r\n        if (_min > MAX_RATE_FACTOR_UPPER_BOUND) {\r\n            return Fraction({\r\n                n: MAX_RATE_FACTOR_LOWER_BOUND,\r\n                d: _min / (_max / MAX_RATE_FACTOR_LOWER_BOUND)\r\n            });\r\n        }\r\n\r\n        if (_max > MAX_RATE_FACTOR_LOWER_BOUND) {\r\n            return Fraction({\r\n                n: MAX_RATE_FACTOR_LOWER_BOUND,\r\n                d: _min * MAX_RATE_FACTOR_LOWER_BOUND / _max\r\n            });\r\n        }\r\n\r\n        return Fraction({ n: _max, d: _min });\r\n    }\r\n}\n","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveStakedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_onlyOwnerCanUpdateRegistry\",\"type\":\"bool\"}],\"name\":\"restrictRegistryUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primaryReserveToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxStakedBalanceEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"connectors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primaryReserveToken\",\"type\":\"address\"},{\"name\":\"_primaryReserveOracle\",\"type\":\"address\"},{\"name\":\"_secondaryReserveOracle\",\"type\":\"address\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasETHReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableMaxStakedBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"connectorTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sourceToken\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveAmplifiedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"liquidationLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyOwnerCanUpdateRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromAnchor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"converterType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserve1MaxStakedBalance\",\"type\":\"uint256\"},{\"name\":\"_reserve2MaxStakedBalance\",\"type\":\"uint256\"}],\"name\":\"setMaxStakedBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address\"}],\"name\":\"setConversionWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"poolToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferAnchorOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_poolToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityReturnAndFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_weight\",\"type\":\"uint32\"}],\"name\":\"addReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"connectorTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxConversionFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxStakedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referenceRate\",\"outputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sourceToken\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"targetAmountAndFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restoreRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"},{\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setReserveStakedBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referenceRateUpdateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAnchorOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isV28OrHigher\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anchor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amplificationFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserves\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"weight\",\"type\":\"uint32\"},{\"name\":\"deprecated1\",\"type\":\"bool\"},{\"name\":\"deprecated2\",\"type\":\"bool\"},{\"name\":\"isSet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_connectorToken\",\"type\":\"address\"}],\"name\":\"getConnectorBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"effectiveTokensRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondaryReserveToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sourceToken\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_trader\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"effectiveReserveWeights\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_conversionFee\",\"type\":\"uint32\"}],\"name\":\"setConversionFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastConversionRate\",\"outputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_poolTokensContainer\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_maxConversionFee\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reserveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newSupply\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reserveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newSupply\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_type\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"_anchor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_activated\",\"type\":\"bool\"}],\"name\":\"Activation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_fromToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_return\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_conversionFee\",\"type\":\"int256\"}],\"name\":\"Conversion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token2\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_rateN\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rateD\",\"type\":\"uint256\"}],\"name\":\"TokenRateUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevFee\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_newFee\",\"type\":\"uint32\"}],\"name\":\"ConversionFeeUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"LiquidityPoolV2Converter","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000bfa9a42e1a86bbb9e0bc43e394b88041632563000000000000000000000000052ae12abe5d8bd778bd5397f99ca900624cfadd400000000000000000000000000000000000000000000000000000000000003e8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}