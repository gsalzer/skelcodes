{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.6.6;\n\n\n// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENS.sol\n// with few modifications.\n/**\n * ENS Registry interface.\n */\ninterface ENSRegistry {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n}\n\n/**\n * ENS Resolver interface.\n */\nabstract contract ENSResolver {\n    function addr(bytes32 _node) public view virtual returns (address);\n    function setAddr(bytes32 _node, address _addr) public virtual;\n    function name(bytes32 _node) public view virtual returns (string memory);\n    function setName(bytes32 _node, string memory _name) public virtual;\n}\n\n/**\n * ENS Reverse Registrar interface.\n */\nabstract contract ENSReverseRegistrar {\n    function claim(address _owner) public virtual returns (bytes32 _node);\n    function claimWithResolver(address _owner, address _resolver) public virtual returns (bytes32);\n    function setName(string memory _name) public virtual returns (bytes32);\n    function node(address _addr) public view virtual returns (bytes32);\n}\n\n/**\n * ENS Reverse registrar contract.\n */\ncontract ENSReverseRegistrarImpl is ENSReverseRegistrar {\n    // namehash('addr.reverse')\n    bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    ENSRegistry public ens;\n    ENSResolver public defaultResolver;\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     * @param resolverAddr The address of the default reverse resolver.\n     */\n    constructor(address ensAddr, address resolverAddr) public {\n        ens = ENSRegistry(ensAddr);\n        defaultResolver = ENSResolver(resolverAddr);\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimWithResolver(owner, address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver) public override returns (bytes32) {\n        bytes32 label = sha3HexAddress(msg.sender);\n        bytes32 node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n        address currentOwner = ens.owner(node);\n\n        // Update the resolver if required\n        if(resolver != address(0) && resolver != address(ens.resolver(node))) {\n            // Transfer the name to us first if it's not already\n            if(currentOwner != address(this)) {\n                ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, address(this));\n                currentOwner = address(this);\n            }\n            ens.setResolver(node, resolver);\n        }\n\n        // Update the owner if required\n        if(currentOwner != owner) {\n            ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\n        }\n\n        return node;\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return node The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32 node) {\n        node = claimWithResolver(address(this), address(defaultResolver));\n        defaultResolver.setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return ret The ENS node hash.\n     */\n    function node(address addr) public view override returns (bytes32 ret) {\n        return keccak256(abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr)));\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private view returns (bytes32 ret) {\n        assembly {\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\n            let i := 40\n\n            for { } gt(i, 0) { } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n            ret := keccak256(0, 40)\n        }\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ensAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolverAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"claimWithResolver\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultResolver\",\"outputs\":[{\"internalType\":\"contract ENSResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract ENSRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"node\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ret\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ENSReverseRegistrarImpl","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000621e0209b3f1ef88dd98a82f639ac2bb7f211e35000000000000000000000000f58d55f06bb92f083e78bb5063a2dd3544f9b6a3","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}