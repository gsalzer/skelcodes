{"status":"1","message":"OK","result":[{"SourceCode":"/* Discussion:\r\n * https://dfohub.com/strategy\r\n */\r\n/* Description:\r\n * A sustainable economic model for\r\n * DFO-based Startups to maintain value\r\n * and funds operations\r\n * \r\n * Abstract:\r\n * \r\n * Voting Tokens of Decentralized Flexible Organizations are real programmable equities of a\r\n * protocol because the funds locked into a DFO wallet are actually funds in the hand of token\r\n * holders. DFO funds can be transferred or used only by voting, this opens new and very\r\n * interesting correlations between Private Equity and Tokens.\r\n * The core experiment of this paper is to explore how adding new on-chain valuable assets into a\r\n * DFO wallet can sustain the price of its voting tokens.\r\n * In a traditional company, if new assets are added to the Company funds (without any increase\r\n * of debts) the evaluation of its equities is backed by the value of these assets. This is because\r\n * equities holders have the power to manage these assets.\r\n * This basic rule can be applied to Decentralized Flexible Organizations because if funds are\r\n * added to a DFO wallet, Token Holders are the only ruler of these funds.\r\n * This is a basic design decision of The DFO core protocol, because thanks to its Smart contracts,\r\n * nobody can make actions outside of a public proposal voted by token holders.\r\n * \r\n * The experiment:\r\n * \r\n * Thanks to the Uniswap math design:\r\n * \r\n * x * y = k. **\r\n * \r\n * **Explained by Decrypt.co\r\n * In the equation, x and y represent the quantity of ETH and ERC20 tokens available in a liquidity pool and k is a\r\n * constant value. This equation uses the balance between the ETH and ERC20 tokens–and supply and demand–to\r\n * determine the price of a particular token. Whenever someone buys Poop Token with ETH, the supply of Poop Token\r\n * decreases while the supply of ETH increases–the price of Poop Token goes up. As a result, the price of tokens on\r\n * Uniswap can only change if trades occur. Essentially what Uniswap is doing it balancing out the value of tokens, and\r\n * the swapping of them based on how much people want to buy and sell them.\r\n * \r\n * A Flexible Organization can sustain its operation by a fixed Circulated Supply inflation using the\r\n * uniswap protocol, by adding new values into the DFO Wallet:\r\n * \r\n * Example:\r\n * \r\n * A DFO named “Flexible” with a Voting Token named “FLX”\r\n * ● FLX Total Supply = 1.000.000 FLX\r\n * ● Flexible DFO Wallet = 800.000 FLX (80%)\r\n * ● FLX Circulating Supply = 200.000 FLX (20%)\r\n * With a Smart Contract based proposal, Flexible Token holders decide to step by step inflate the\r\n * circulating supply for a total of 5% during a period of a year and a half by selling a fixed number\r\n * of FLX once a week (~ 50.400 Ethereum Blocks @ 12 sec for a block for 80 times)\r\n * In this case, the Flexible DFO will sell in total 50.000 FLX on the Uniswap protocol at the ratio of\r\n * 625 FLX every 50.400 Blocks, increasing the circulating supply by the 0,0625%\r\n * (In this experiment technically the FLX backed value is already settled by the 800.000 FLX into the Flexible DFO\r\n * Wallet, but because the FLX is at the same time the Voting Token, we don’t count its value in this equation.)\r\n * Every FLX Inflation event will add new ETH to the Flexible DFO wallet, adding new backed\r\n * assets.\r\n * For example, after the first selling event the new status of the Flexible DFO Wallet will be:\r\n * \r\n * 799375 FLX + Z ETH ***\r\n * \r\n * ***(Z is equal to an amount of ETH depending on the ratio of ETH/FLX into the Uniswap Pool)\r\n * \r\n * Now Z ETH is the minimum backed value of the Flexible DFO Wallet and consequently the FLX\r\n * Market cap because FLX Token Holders are the only people who can manage these funds, like\r\n * Equity Holders in a Company.\r\n * Every Selling Event the Uniswap Pool reaches very little inflation but at the same time this\r\n * selling benefits every FLX Holders.\r\n * If the DFO Voting Token Holders will use every week an amount < of the 100% of the Z ETH\r\n * funds reached, the project can pay operations and at the same time accumulate backed value\r\n * to benefit every token holder.\r\n * \r\n * The DFOhub Experiment:\r\n * \r\n * We want to do this experiment for three fundamental reasons:\r\n * \r\n * 1) Empiric data about the correlation from Programmable Equities (DFO based Voting\r\n * Tokens) to Regular Equities that can open an infinite number of questions and business\r\n * opportunities for the dapps of tomorrow (DFO based)\r\n * 2) R&D and introduce these standardized Smart Contracts as optional basic functions for\r\n * every DFO via voting\r\n * 3) Sustain our operations and at the same time to build a minimum backed valorization for\r\n * BUIDL holders.\r\n * The Economics behind BUIDL is based on the Business Model of the General Purpose Protocol\r\n * DFO. Every time someone creates a new Decentralized Flexible Organization, a % of the new\r\n * DFO’s new Voting Tokens is added to the DFOhub Wallet. The DFOhub Wallet is managed only\r\n * by voting from the BUIDL holders, making assets into the DFOhub wallet the backed value of\r\n * BUIDL.\r\n * \r\n * DFOhub Experiment in numbers:\r\n * ● BUIDL Total Supply = 42.000.000 BUIDL\r\n * ● DFOhub DFO Wallet = 11.500.000 BUIDL (27.3%)\r\n * ● DFOhub Team Operations Wallet = 11.500.000 BUIDL (27.3%)\r\n * ● BUIDL Circulating Supply = 2.200.000 BUIDL (5.2%)\r\n * \r\n * With a Smart Contract based proposal, DFOhub will step by step inflate the circulating supply of\r\n * BUIDL for a total of 0.8% during a period of a year and a half by selling a fixed number of BUIDL\r\n * once every two weeks (~ 100.800 Ethereum Blocks @ 12 sec for a block for 40 times)\r\n * At the same time, the DFOhub Team Operations Wallet will step by step inflate the circulating\r\n * supply of BUIDL for a total of 0.8% during a period of a year and a half by selling a fixed number\r\n * of BUIDL once every two weeks (~ 100.800 Ethereum Blocks @ 12 sec for a block for 40 times)\r\n * These two Smart Contracts will inflate the circulation supply of a total of 1.6% (672.000 BUIDL)\r\n * in a year and a half. The funds will be inflated into 3 different Uniswap Pools:\r\n * 25% Uniswap V1 ETH/BUIDL | 0.4% (168.000 BUIDL)\r\n * 25% Uniswap V2 ETH/BUIDL | 0.4% (168.000 BUIDL)\r\n * 50% Uniswap V2 USDC/BUIDL | 0.8% Inflation (336.000 BUIDL)\r\n * During every Selling Event, the Circulating supply of BUIDL will increase by 0.02% (8.400\r\n * BUIDL) and will be split into:\r\n * 25% Uniswap V1 ETH/BUIDL | 0.005% (2.100 BUIDL)\r\n * 25% Uniswap V2 ETH/BUIDL | 0.005% (2.100 BUIDL)\r\n * 50% Uniswap V2 USDC/BUIDL | 0.01% Inflation (4.200 BUIDL)\r\n * Conclusion:\r\n * \r\n * Every Two weeks these funds will create values for BUIDL holders in two different ways:\r\n * 1. From the DFOhub Wallet: Z ETH and Z USDC will be automatically added to the\r\n * DFOhub wallet as a backed value for BUIDL holders.\r\n * 2. From the DFOhub Team Operations Wallet, these funds will be used to accelerate the\r\n * R&D into new DFOhub Functionalities, Marketing, and Community Rewards. These\r\n * Operations will benefit all of the BUIDL holders accelerating the advancement of the\r\n * protocol and its usage, so more DFO's Voting Tokens into the DFOhub Wallet as a\r\n * backed value for BUIDL holders.\r\n * \r\n * All of the functionalities related to this R&D will become available for every DFO as Optional\r\n * Basic Functionalities, to accelerate the exploration of Programmable Equities R&D.\r\n */\r\npragma solidity ^0.6.0;\r\n\r\ncontract FairInflationFunctionality {\r\n\r\n    function onStart(address,address) public {\r\n        IMVDProxy proxy = IMVDProxy(msg.sender);\r\n\r\n        address tokenToSwapAddress = 0xD6F0Bb2A45110f819e908a915237D652Ac7c5AA8;\r\n        address uniswapV1ExchangeAddress = 0xFE3eB37C105800842001F759d295eCFb2158A4Cb;\r\n        address uniswapV2RouterAddress = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;\r\n        address uSDCTokenAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n        uint256 swapBlockLimit = 100800;\r\n        uint256 totalSwapTimes = 40;\r\n        uint256 tokenAmountToSwapForEtherInV1 = 2100000000000000000000;\r\n        uint256 tokenAmountToSwapForEtherInV2 = 2100000000000000000000;\r\n        uint256 tokenAmountToSwapForUSDCInV2 = 4200000000000000000000;\r\n\r\n        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\r\n        stateHolder.setAddress(\"tokenToSwapAddress\", tokenToSwapAddress);\r\n        stateHolder.setAddress(\"uniswapV1ExchangeAddress\", uniswapV1ExchangeAddress);\r\n        stateHolder.setAddress(\"uniswapV2RouterAddress\", uniswapV2RouterAddress);\r\n        stateHolder.setAddress(\"uSDCTokenAddress\", uSDCTokenAddress);\r\n        stateHolder.setUint256(\"swapBlockLimit\", swapBlockLimit);\r\n        stateHolder.setUint256(\"totalSwapTimes\", totalSwapTimes);\r\n        stateHolder.setUint256(\"tokenAmountToSwapForEtherInV1\", tokenAmountToSwapForEtherInV1);\r\n        stateHolder.setUint256(\"tokenAmountToSwapForEtherInV2\", tokenAmountToSwapForEtherInV2);\r\n        stateHolder.setUint256(\"tokenAmountToSwapForUSDCInV2\", tokenAmountToSwapForUSDCInV2);\r\n    }\r\n\r\n    function onStop(address) public {\r\n        IStateHolder stateHolder = IStateHolder(IMVDProxy(msg.sender).getStateHolderAddress());\r\n        stateHolder.clear(\"tokenToSwapAddress\");\r\n        stateHolder.clear(\"uniswapV1ExchangeAddress\");\r\n        stateHolder.clear(\"uniswapV2RouterAddress\");\r\n        stateHolder.clear(\"uSDCTokenAddress\");\r\n        stateHolder.clear(\"swapBlockLimit\");\r\n        stateHolder.clear(\"totalSwapTimes\");\r\n        stateHolder.clear(\"tokenAmountToSwapForEtherInV1\");\r\n        stateHolder.clear(\"tokenAmountToSwapForEtherInV2\");\r\n        stateHolder.clear(\"tokenAmountToSwapForUSDCInV2\");\r\n        stateHolder.clear(\"lastSwapBlock\");\r\n        stateHolder.clear(\"swapTimes\");\r\n    }\r\n\r\n    function fairInflation() public {\r\n        IMVDProxy proxy = IMVDProxy(msg.sender);\r\n        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\r\n\r\n        uint256 swapTimes = stateHolder.getUint256(\"swapTimes\");\r\n        require(swapTimes < stateHolder.getUint256(\"totalSwapTimes\"), \"Total swap times reached\");\r\n        stateHolder.setUint256(\"swapTimes\", swapTimes + 1);\r\n\r\n        require(block.number >= (stateHolder.getUint256(\"lastSwapBlock\") + stateHolder.getUint256(\"swapBlockLimit\")), \"Too early to swap new Tokens!\");\r\n        stateHolder.setUint256(\"lastSwapBlock\", block.number);\r\n\r\n        address dfoWalletAddress = proxy.getMVDWalletAddress();\r\n        IERC20 tokenToSwap = IERC20(stateHolder.getAddress(\"tokenToSwapAddress\"));\r\n\r\n        uint256 tokenAmountToSwapForEtherInV1 = stateHolder.getUint256(\"tokenAmountToSwapForEtherInV1\");\r\n        uint256 tokenAmountToSwapForEtherInV2 = stateHolder.getUint256(\"tokenAmountToSwapForEtherInV2\");\r\n        uint256 tokenAmountToSwapForUSDCInV2 = stateHolder.getUint256(\"tokenAmountToSwapForUSDCInV2\");\r\n\r\n        proxy.transfer(address(this), tokenAmountToSwapForEtherInV1 + tokenAmountToSwapForEtherInV2 + tokenAmountToSwapForUSDCInV2, address(tokenToSwap));\r\n\r\n        uniswapV1(stateHolder,tokenAmountToSwapForEtherInV1, tokenToSwap, dfoWalletAddress);\r\n        uniswapV2(stateHolder, tokenAmountToSwapForEtherInV2, tokenAmountToSwapForUSDCInV2, tokenToSwap, dfoWalletAddress);\r\n    }\r\n\r\n    function uniswapV1(IStateHolder stateHolder, uint256 tokenAmountToSwapForEtherInV1, IERC20 tokenToSwap, address dfoWalletAddress) private {\r\n        if(tokenAmountToSwapForEtherInV1 <= 0) {\r\n            return;\r\n        }\r\n        IUniswapV1Exchange uniswapV1Exchange = IUniswapV1Exchange(stateHolder.getAddress(\"uniswapV1ExchangeAddress\"));\r\n        if(tokenToSwap.allowance(address(this), address(uniswapV1Exchange)) == 0) {\r\n            tokenToSwap.approve(address(uniswapV1Exchange), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        }\r\n        uniswapV1Exchange.tokenToEthTransferInput(tokenAmountToSwapForEtherInV1, uniswapV1Exchange.getTokenToEthInputPrice(tokenAmountToSwapForEtherInV1), block.timestamp + 1000, dfoWalletAddress);\r\n    }\r\n\r\n    function uniswapV2(IStateHolder stateHolder, uint256 tokenAmountToSwapForEtherInV2, uint256 tokenAmountToSwapForUSDCInV2, IERC20 tokenToSwap, address dfoWalletAddress) private {\r\n        if(tokenAmountToSwapForEtherInV2 <= 0 && tokenAmountToSwapForUSDCInV2 <= 0) {\r\n            return;\r\n        }\r\n        IUniswapV2Router uniswapV2Router = IUniswapV2Router(stateHolder.getAddress(\"uniswapV2RouterAddress\"));\r\n        if(tokenToSwap.allowance(address(this), address(uniswapV2Router)) == 0) {\r\n            tokenToSwap.approve(address(uniswapV2Router), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        }\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(tokenToSwap);\r\n        if(tokenAmountToSwapForEtherInV2 > 0) {\r\n            path[1] = uniswapV2Router.WETH();\r\n            uniswapV2Router.swapExactTokensForETH(tokenAmountToSwapForEtherInV2, uniswapV2Router.getAmountsOut(tokenAmountToSwapForEtherInV2, path)[1], path, dfoWalletAddress, block.timestamp + 1000);\r\n        }\r\n\r\n        if(tokenAmountToSwapForUSDCInV2 > 0) {\r\n            path[1] = stateHolder.getAddress(\"uSDCTokenAddress\");\r\n            uniswapV2Router.swapExactTokensForTokens(tokenAmountToSwapForUSDCInV2, uniswapV2Router.getAmountsOut(tokenAmountToSwapForUSDCInV2, path)[1], path, dfoWalletAddress, block.timestamp + 1000);\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV1Exchange {\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IMVDProxy {\r\n    function getToken() external view returns(address);\r\n    function getStateHolderAddress() external view returns(address);\r\n    function getMVDWalletAddress() external view returns(address);\r\n    function transfer(address receiver, uint256 value, address token) external;\r\n}\r\n\r\ninterface IStateHolder {\r\n    function setUint256(string calldata name, uint256 value) external returns(uint256);\r\n    function getUint256(string calldata name) external view returns(uint256);\r\n    function getAddress(string calldata name) external view returns(address);\r\n    function setAddress(string calldata varName, address val) external returns (address);\r\n    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\r\n}\r\n\r\ninterface IERC20 {\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}","ABI":"[{\"inputs\":[],\"name\":\"fairInflation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"onStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"onStop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FairInflationFunctionality","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8e5e428f63164890e4413f8c59fd3bf354020ce3d5af98fcfb48375a8bc90f95"}]}