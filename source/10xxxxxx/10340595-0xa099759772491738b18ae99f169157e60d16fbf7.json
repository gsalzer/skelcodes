{"status":"1","message":"OK","result":[{"SourceCode":"{\"ballot.sol\":{\"content\":\"pragma solidity ^0.4.0;\\r\\ncontract Ballot {\\r\\n\\r\\n    struct Voter {\\r\\n        uint weight;\\r\\n        bool voted;\\r\\n        uint8 vote;\\r\\n        address delegate;\\r\\n    }\\r\\n    struct Proposal {\\r\\n        uint voteCount;\\r\\n    }\\r\\n\\r\\n    address chairperson;\\r\\n    mapping(address =\\u003e Voter) voters;\\r\\n    Proposal[] proposals;\\r\\n\\r\\n    /// Create a new ballot with $(_numProposals) different proposals.\\r\\n    function Ballot(uint8 _numProposals) public {\\r\\n        chairperson = msg.sender;\\r\\n        voters[chairperson].weight = 1;\\r\\n        proposals.length = _numProposals;\\r\\n    }\\r\\n\\r\\n    /// Give $(toVoter) the right to vote on this ballot.\\r\\n    /// May only be called by $(chairperson).\\r\\n    function giveRightToVote(address toVoter) public {\\r\\n        if (msg.sender != chairperson || voters[toVoter].voted) return;\\r\\n        voters[toVoter].weight = 1;\\r\\n    }\\r\\n\\r\\n    /// Delegate your vote to the voter $(to).\\r\\n    function delegate(address to) public {\\r\\n        Voter storage sender = voters[msg.sender]; // assigns reference\\r\\n        if (sender.voted) return;\\r\\n        while (voters[to].delegate != address(0) \\u0026\\u0026 voters[to].delegate != msg.sender)\\r\\n            to = voters[to].delegate;\\r\\n        if (to == msg.sender) return;\\r\\n        sender.voted = true;\\r\\n        sender.delegate = to;\\r\\n        Voter storage delegateTo = voters[to];\\r\\n        if (delegateTo.voted)\\r\\n            proposals[delegateTo.vote].voteCount += sender.weight;\\r\\n        else\\r\\n            delegateTo.weight += sender.weight;\\r\\n    }\\r\\n\\r\\n    /// Give a single vote to proposal $(toProposal).\\r\\n    function vote(uint8 toProposal) public {\\r\\n        Voter storage sender = voters[msg.sender];\\r\\n        if (sender.voted || toProposal \\u003e= proposals.length) return;\\r\\n        sender.voted = true;\\r\\n        sender.vote = toProposal;\\r\\n        proposals[toProposal].voteCount += sender.weight;\\r\\n    }\\r\\n\\r\\n    function winningProposal() public constant returns (uint8 _winningProposal) {\\r\\n        uint256 winningVoteCount = 0;\\r\\n        for (uint8 prop = 0; prop \\u003c proposals.length; prop++)\\r\\n            if (proposals[prop].voteCount \\u003e winningVoteCount) {\\r\\n                winningVoteCount = proposals[prop].voteCount;\\r\\n                _winningProposal = prop;\\r\\n            }\\r\\n    }\\r\\n}\"},\"coins.sol\":{\"content\":\"pragma solidity ^0.4.11;\\r\\nimport \\u0027./iERC20.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\n\\r\\ncontract AME is iERC20{\\r\\n\\r\\n  \\r\\n    uint public _totalSupply = 18600000000000000; //100 M\\r\\n    string public constant symbol = \\\"AME\\\";\\r\\n    string public constant name = \\\"Americoin\\\";\\r\\n    uint8 public constant decimals = 8;\\r\\n    mapping (address =\\u003e uint256) balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\r\\n    \\r\\n    function AME(){\\r\\n        balances[msg.sender] = _totalSupply;\\r\\n    }\\r\\n    function totalSupply() constant returns (uint256 totalSupply){\\r\\n         return _totalSupply;\\r\\n    }\\r\\n    function balanceOf(address _owner) constant returns (uint256 balance) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\r\\n        require(\\r\\n            balances[msg.sender]\\u003e= _value\\r\\n            \\u0026\\u0026 _value \\u003e 0\\r\\n        );\\r\\n        balances[msg.sender] -= _value;\\r\\n        balances[_to] += _value;\\r\\n        Transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\r\\n        require(\\r\\n            allowed[_from][msg.sender]  \\u003e= _value\\r\\n            \\u0026\\u0026 balances[_from] \\u003e= _value\\r\\n            \\u0026\\u0026 _value \\u003e 0\\r\\n        );\\r\\n        balances[_from] -= _value;\\r\\n        balances[_to] += _value;    \\r\\n        allowed[_from][msg.sender] -= _value;\\r\\n        Transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        Approval(msg.sender, _spender, _value);\\r\\n        // require(_value == 0 || allowed[msg.sender][_spender] == 0);\\r\\n        // allowed[msg.sender][_spender] = _value;\\r\\n        // Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n\\r\\n}\"},\"iERC20.sol\":{\"content\":\"pragma solidity ^0.4.11;\\r\\ninterface iERC20{\\r\\n  function totalSupply() constant returns (uint256 totalSupply);\\r\\n  function balanceOf(address _owner) constant returns (uint256 balance);\\r\\n  function transfer(address _to, uint256 _value) returns (bool success);\\r\\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\\r\\n  function approve(address _spender, uint256 _value) returns (bool success);\\r\\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\\r\\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.11;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\\r\\n    uint256 c = a * b;\\r\\n    assert(a == 0 || c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\\r\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    assert(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"AME","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7a785e49b4a9aabb108368edc1d8c2c65c266f4d936e37f31e12a801b35d38d4"}]}