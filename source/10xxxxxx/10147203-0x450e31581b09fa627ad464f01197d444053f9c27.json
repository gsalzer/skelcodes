{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    uint256 public totalSupply;\n\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value)\n        public\n        returns (bool success);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256 remaining);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool success);\n\n    function approve(address _spender, uint256 _value)\n        public\n        returns (bool success);\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner can access\");\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"address cannot be zero\");\n        address previousOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(previousOwner, owner);\n    }\n}\n\n/**\n * @title The MDTExchangeLockup contract\n * @dev Lock up MDT tokens for exchange launching\n * @author MDT Team\n */\ncontract MDTExchangeLockup is Ownable {\n    using SafeMath for uint256;\n\n    ERC20 public token; // MDT contract address\n    address public holderAddress; // wallet address for unlocking tokens\n    uint256 public startTime; // start time of the tokens lockup\n    uint256 public installmentLength; // installment length in seconds\n    uint256 public totalInstallments; // total number of installments\n    uint256 public totalTokensLocked; // total tokens locked in this contract\n    uint256 public totalTokensUnlocked; // total tokens unlocked by the holder\n    uint256 public lastUnlockedTime; // last time of unlocking tokens\n\n    // Events\n    event TokensUnlocked(\n        address indexed _to,\n        uint256 _amount,\n        uint256 _unlockedTime\n    );\n    event HolderAddressChanged(\n        address indexed previousHolder,\n        address indexed newholder\n    );\n\n    /// @dev Reverts if address is 0x0 or token address or this contract address.\n    modifier validRecipient(address _recipient) {\n        require(\n            validAddress(_recipient),\n            \"recipient cannot be zero address, the token address or the contract address\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the token holder.\n     */\n    modifier onlyHolder() {\n        require(msg.sender == holderAddress, \"only holder can access\");\n        _;\n    }\n\n    /**\n     * @dev MDTExchangeLockup contract constructor.\n     * @param _tokenAddress address The MDT contract address.\n     * @param _holderAddress address The wallet address used to unlock tokens.\n     * @param _startTime uint256 the lockup start time.\n     * @param _installmentLength uint256 the length of each installment in seconds.\n     * @param _totalInstallments uint256 total number of installments.\n     * @param _lockupAmount address Amount of tokens to be locked up in the contract.\n     */\n    constructor(\n        address _tokenAddress,\n        address _holderAddress,\n        uint256 _startTime,\n        uint256 _installmentLength,\n        uint256 _totalInstallments,\n        uint256 _lockupAmount\n    ) public {\n        require(_tokenAddress != address(0), \"token address cannot be zero\");\n        require(\n            _holderAddress != address(0) && _holderAddress != _tokenAddress,\n            \"holder address cannot be zero or equal to the token address\"\n        );\n        require(_startTime > now, \"start time must be later than now\");\n        require(\n            _installmentLength > 0,\n            \"installment length must be greater than 0\"\n        );\n        require(\n            _totalInstallments >= 1,\n            \"total number of installments must be greater than or equal to 1\"\n        );\n        require(_lockupAmount > 0, \"lockup amounts must be greater than 0\");\n\n        token = ERC20(_tokenAddress);\n        holderAddress = _holderAddress;\n        startTime = _startTime;\n        installmentLength = _installmentLength;\n        totalInstallments = _totalInstallments;\n        totalTokensLocked = _lockupAmount;\n    }\n\n    /**\n     * @dev Changes token holder to a new holder. (contract owner only)\n     * @param newHolderAddress The address to transfer tokens ownership to.\n     */\n    function changeHolderAddress(address newHolderAddress)\n        public\n        onlyOwner\n        validRecipient(newHolderAddress)\n    {\n        address previousHolder = holderAddress;\n        holderAddress = newHolderAddress;\n        emit HolderAddressChanged(previousHolder, holderAddress);\n    }\n\n    /// @dev Calculate the total amount of unlocked tokens at a given time.\n    /// @param _time uint256 The specific time to calculate against.\n    /// @return uint256 Total amount of tokens available to unlock.\n    function calculateUnlockedTokens(uint256 _time)\n        public\n        view\n        returns (uint256)\n    {\n        // if passed in time is before the lockup start time, return 0.\n        if (_time < startTime) {\n            return 0;\n        }\n\n        // Calculate number of installments pasted until now.\n        uint256 installmentsPast = _time.sub(startTime).div(installmentLength);\n\n        // If number of installments pasted is greater than or equal to the total number of installments, all tokens are unlocked.\n        if (installmentsPast >= totalInstallments) {\n            return totalTokensLocked;\n        }\n\n        // Calculate and return the number of tokens unlocked accordings to the number of installments that has been passed.\n        return installmentsPast.mul(totalTokensLocked).div(totalInstallments);\n    }\n\n    /// @dev Calculate the total amount of unlocked tokens at current time.\n    /// @return uint256 Total amount of tokens available to unlock now.\n    function currentUnlockedTokens() public view returns (uint256) {\n        return calculateUnlockedTokens(now);\n    }\n\n    /**\n     * @dev Unlock tokens. (tokens holder only)\n     * @return amount of tokens unlocked.\n     */\n    function unlockTokens() public onlyHolder returns (uint256) {\n        require(contractTokenBalance() > 0, \"no tokens are locked\");\n\n        // Get the total amount of unlocked tokens.\n        uint256 unlockedAmount = calculateUnlockedTokens(now);\n        if (unlockedAmount == 0) {\n            return 0;\n        }\n\n        // Make sure the holder doesn't transfer more than what he unlocked.\n        uint256 availableAmount = unlockedAmount.sub(totalTokensUnlocked);\n        if (availableAmount == 0) {\n            return 0;\n        }\n\n        // Update total unlocked amounts.\n        totalTokensUnlocked = totalTokensUnlocked.add(availableAmount);\n\n        // Update last unlocked time.\n        lastUnlockedTime = now;\n\n        // Send tokens to the sender.\n        require(\n            token.transfer(msg.sender, availableAmount),\n            \"failed to transfer tokens\"\n        );\n\n        // Emit tokens unlocked event.\n        emit TokensUnlocked(msg.sender, availableAmount, now);\n    }\n\n    /**\n     * @dev Transfer to owner any tokens send by mistake to this contract. (contract owner only)\n     * @param _token ERC20 The address of the token to transfer.\n     * @param amount uint256 The amount to be transferred.\n     */\n    function emergencyERC20Drain(ERC20 _token, uint256 amount)\n        public\n        onlyOwner\n    {\n        _token.transfer(owner, amount);\n    }\n\n    /**\n     * @dev Get token balance of a wallet address.\n     * @param _address address Address to be queried.\n     * @return the token balance of a wallet address.\n     */\n    function tokenBalanceOf(address _address) public view returns (uint256) {\n        return token.balanceOf(_address);\n    }\n\n    /**\n     * @dev Get token balance of this contract.\n     * @return the token balance of this contract.\n     */\n    function contractTokenBalance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Check if address is valid.\n     * @param _address address Wallet address.\n     * @return true if the address is valid.\n     */\n    function validAddress(address _address) private view returns (bool) {\n        return\n            _address != address(0) &&\n            _address != address(this) &&\n            _address != address(token);\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_holderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_installmentLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalInstallments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockupAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousHolder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newholder\",\"type\":\"address\"}],\"name\":\"HolderAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_unlockedTime\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"calculateUnlockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newHolderAddress\",\"type\":\"address\"}],\"name\":\"changeHolderAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentUnlockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyERC20Drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"installmentLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUnlockedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInstallments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensUnlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MDTExchangeLockup","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000814e0908b12a99fecf5bc101bb5d0b8b5cdf7d26000000000000000000000000a14567cbd5090a6b469390e7d33b10cffa70c5b3000000000000000000000000000000000000000000000000000000005ed4450000000000000000000000000000000000000000000000000000000000004f1a00000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000a2209d12d20b20a6700000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}