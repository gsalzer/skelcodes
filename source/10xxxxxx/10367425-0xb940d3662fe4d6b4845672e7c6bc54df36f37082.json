{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Interface.sol\":{\"content\":\"// Abstract contract for the full ERC 20 Token standard\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\npragma solidity ^0.5.0;\\n\\n/**\\n * @author Quant Network\\n * @title ERC20Interface\\n * @dev Allows contracts to easily interface with an ERC20 contract without knowing the whole code\\n */\\ninterface ERC20Interface {\\n \\n    /**\\n     * @return The total supply of tokens\\n     */   \\n    function totalSupply() external view  returns (uint256 supply);\\n\\n    /**\\n     * @param _owner The address from which the balance will be retrieved\\n     * @return The balance\\n     */\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    /** \\n     * send `_value` token(s) to `_to` from `msg.sender`\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token to be transferred\\n     * @return Whether the transfer was successful or not\\n     */\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    /**\\n     * send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n     * @param _from The address of the sender\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token to be transferred\\n     * @return Whether the transfer was successful or not\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n    /**\\n     * `msg.sender` approves `_spender` to spend `_value` tokens\\n     * @param _spender The address of the account able to transfer the tokens\\n     * @param _value The amount of tokens to be approved for transfer\\n     * @return Whether the approval was successful or not\\n     */\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    /**\\n     * @param _owner The address of the account owning tokens\\n     * @param _spender The address of the account able to transfer the tokens\\n     * @return Amount of remaining tokens allowed to spent\\n     */\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n}\"},\"EternalStorageData.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @author Quant Network\\n * @title EternalStorage\\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\\n */\\ncontract EternalStorage {\\n\\n  mapping(bytes32 =\\u003e bool) internal boolStorage;\\n  mapping(bytes32 =\\u003e address) internal addressStorage;\\n  mapping(bytes32 =\\u003e string) internal stringStorage;\\n  mapping(bytes32 =\\u003e bytes) internal bytesStorage;\\n\\n  mapping(bytes32 =\\u003e bytes1) internal bytes1Storage;\\n  mapping(bytes32 =\\u003e bytes2) internal bytes2Storage;\\n  mapping(bytes32 =\\u003e bytes4) internal bytes4Storage;\\n  mapping(bytes32 =\\u003e bytes8) internal bytes8Storage;\\n  mapping(bytes32 =\\u003e bytes16) internal bytes16Storage;\\n  mapping(bytes32 =\\u003e bytes32) internal bytes32Storage;\\n  \\n  mapping(bytes32 =\\u003e int8) internal int8Storage;\\n  mapping(bytes32 =\\u003e int16) internal int16Storage;\\n  mapping(bytes32 =\\u003e int32) internal int32Storage;\\n  mapping(bytes32 =\\u003e int64) internal int64Storage;\\n  mapping(bytes32 =\\u003e int128) internal int128Storage;\\n  mapping(bytes32 =\\u003e int256) internal int256Storage;\\n  \\n  mapping(bytes32 =\\u003e uint8) internal uint8Storage;\\n  mapping(bytes32 =\\u003e uint16) internal uint16Storage;\\n  mapping(bytes32 =\\u003e uint32) internal uint32Storage;\\n  mapping(bytes32 =\\u003e uint64) internal uint64Storage;\\n  mapping(bytes32 =\\u003e uint128) internal uint128Storage;\\n  mapping(bytes32 =\\u003e uint256) internal uint256Storage;\\n\\n\\n}\"},\"TreasuryBase.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title TreasuryAbstract\\n * @dev Sets the main variables of a Treasury contract and allows other contracts to easily interface with a Treasury contract without knowing the whole code. \\n */\\ncontract TreasuryBase is UpgradeableProxy {\\n    \\n        // the connected factory of this treasury\\n        bytes constant private treasurysFactory1 = \\u00271.treasurysFactory\\u0027;\\n        // the connected rulelist of this treasury\\n        bytes constant private treasurysRuleList1 = \\u00271.treasurysRuleList\\u0027;\\n        // the treasury\\u0027s escrowed deposit\\n        bytes constant private treasurysDeposit1 = \\u00271.treasuryDeposit\\u0027;\\n        // the QNT address of this treasury (possible cold wallet)   \\n        bytes constant private QNTAddress1 = \\u00271.QNTAddress\\u0027;\\n        // the operator address of this treasury, which can call other smart contract functions on behalf of the treasury\\n        bytes constant private operatorAddress1 = \\u00271.operatorAddress\\u0027;\\n        // whether this treasury is currently paused (true) or active (false)\\n        bytes constant private circuitBreakerOn1 = \\u00271.circuitBreakerOn\\u0027;\\n        // the fee the MAPP has to pay for any dispute raised per gateway\\n        bytes constant private mappDisputeFeeMultipler1 = \\u00271.mappDisputeFeeMultipler\\u0027;\\n        // the commission divider charged for every mapp to gateway transaction. \\n        // The divider is used with the original fee of the function.\\n        // I.e a commission divider of 2 is equal to 50% commission\\n        bytes constant private commissionDivider1 = \\u00271.commissionDivider\\u0027;\\n        // the penalty multiplier the treasury has to pay if it has been found in breach of \\n        // one of its verification rules. The mulitipication is used with the original fee of the function.\\n        // I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n        bytes constant private  treasuryPenaltyMultipler1 = \\u00271.treasuryPenaltyMultipler\\u0027;\\n        // the penalty multiplier a gateway has to pay if it has be found in breach of\\n        // one of its verification rules. The mulitipication is used with the original fee of the function\\n        // I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n        bytes constant private gatewayPenaltyMultipler1 = \\u00271.gatewayPenaltyMultipler\\u0027;\\n\\n        /**\\n         * set a new factory for this treasury\\n         */        \\n        function treasurysFactory(address newTreasurysFactory) internal {\\n            addressStorage[keccak256(treasurysFactory1)] = newTreasurysFactory;\\n        } \\n        \\n        \\n        /**\\n         * set a new rulelist for this treasury\\n         */        \\n        function treasurysRuleList(address newTreasurysRuleList) internal {\\n            addressStorage[keccak256(treasurysRuleList1)] = newTreasurysRuleList;\\n        } \\n\\n        /**\\n         * set a new treasury deposit \\n         */        \\n        function treasurysDeposit(address newTreasuryDeposit) internal {\\n            addressStorage[keccak256(treasurysDeposit1)] = newTreasuryDeposit;\\n        }\\n        \\n        /**\\n         * set a new QNTAddress for this treasury\\n         */        \\n        function QNTAddress(address newQNTAddress) internal {\\n            addressStorage[keccak256(QNTAddress1)] = newQNTAddress;\\n        }\\n        \\n        /**\\n         * set a new operator for this treasury\\n         */        \\n        function operatorAddress(address newOperator) internal {\\n            addressStorage[keccak256(operatorAddress1)] = newOperator;\\n        }\\n        \\n        /**\\n         * set the circuitbreaker of this treasury\\n         */        \\n        function circuitBreakerOn(bool newCircuitBreakerOn) internal {\\n            boolStorage[keccak256(circuitBreakerOn1)] = newCircuitBreakerOn;\\n        }\\n        \\n        /**\\n         * set the mapp dispute fee multiplier\\n         */        \\n        function mappDisputeFeeMultipler(uint16 newMappDisputeFeeMultipler) internal {\\n            uint16Storage[keccak256(mappDisputeFeeMultipler1)] = newMappDisputeFeeMultipler;\\n        }\\n        \\n \\n        /**\\n         * set the commission divider\\n         */        \\n        function commissionDivider(uint16 neCommissionDivider) internal {\\n            uint16Storage[keccak256(commissionDivider1)] = neCommissionDivider;\\n        }\\n\\n        /**\\n         * set the treasury dispute multiplier\\n         */        \\n        function treasuryPenaltyMultipler(uint16 newTreasuryPenaltyMultipler) internal {\\n            uint16Storage[keccak256(treasuryPenaltyMultipler1)] = newTreasuryPenaltyMultipler;\\n        }\\n\\n        /**\\n         * set the gateway dispute multiplier\\n         */        \\n        function gatewayPenaltyMultipler(uint16 newGatewayPenaltyMultipler) internal {\\n            uint16Storage[keccak256(gatewayPenaltyMultipler1)] = newGatewayPenaltyMultipler;\\n        }\\n\\n      /**\\n       * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n       */\\n      function admin() public view returns (address) {\\n          return addressStorage[keccak256(\\u0027proxy.admin\\u0027)];   \\n      }\\n    \\n        /**\\n        * @return - the number of hours wait time for any critical update\\n        */        \\n        function speedBumpHours() public view returns (uint16){\\n            return uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)];\\n        }\\n     \\n        /**\\n         * @return - the connected factory of this treasury\\n         */        \\n        function treasurysFactory() public view returns (address){\\n            return addressStorage[keccak256(treasurysFactory1)];\\n        } \\n        \\n        /**\\n         * @return - the connected rulelist of this treasury\\n         */        \\n        function treasurysRuleList() public view returns (address){\\n            return addressStorage[keccak256(treasurysRuleList1)];\\n        } \\n\\n\\n        /**\\n         * @return - the treasury\\u0027s escrowed deposit\\n         */        \\n        function treasurysDeposit() public view returns (address){\\n            return addressStorage[keccak256(treasurysDeposit1)];\\n        }\\n        \\n        /**\\n         * @return - the withdrawal address of this treasury\\n         */        \\n        function QNTAddress() public view returns (address){\\n            return addressStorage[keccak256(QNTAddress1)];\\n        }\\n        \\n        /**\\n         * @return - the operator of this treasury\\n         */        \\n        function operatorAddress() public view returns (address){\\n            return addressStorage[keccak256(operatorAddress1)];\\n        }\\n        \\n        /**\\n         * @return - whether this treasury is currently active or not\\n         */        \\n        function circuitBreakerOn() public view returns (bool){\\n            return boolStorage[keccak256(circuitBreakerOn1)];\\n        }\\n        \\n        /**\\n         * @return - the fee the mapp has to pay for any dispute raised per gateway\\n         */        \\n        function mappDisputeFeeMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(mappDisputeFeeMultipler1)];\\n        }\\n        \\n \\n        /**\\n         * @return the commission divider charged for every mapp to gateway transaction.\\n         * The divider is used with the original fee of the function.\\n         * I.e a commission divider of 2 is equal to 50% commission\\n         */        \\n        function commissionDivider() public view returns (uint16){\\n            return uint16Storage[keccak256(commissionDivider1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier for the treasury has to pay if it has been found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function.\\n         * I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n         */        \\n        function treasuryPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(treasuryPenaltyMultipler1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier a gateway has to pay if it has be found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function\\n         * I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n         */        \\n        function gatewayPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(gatewayPenaltyMultipler1)];\\n        }\\n    \\n}\"},\"TreasuryDeposit.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC20Interface.sol\\\";\\nimport \\\"./TreasuryBase.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title Allows the treasury deposit to be held in escrow to be either returned or slashed according to defined rules\\n * The treasury can withdraw from its deposit by firstly adding a request to withdraw, waiting the speed bump time period and then adding another tx  to finalise the withdrawal\\n */\\ncontract EscrowedDeposit  is UpgradeableProxy {\\n\\n    // the treasury contract address;\\n    bytes constant private treasuryAddress1 = \\u00271.treasuryaddress\\u0027;\\n    // how much QNT to withdraw via this circuit breaker\\n    bytes constant private speedBumpQNTToWithdraw1 = \\u00271.speedBump.QNTToWithdraw\\u0027;\\n    // what time this SpeedBump was created at\\n    bytes constant private speedBumpTimeCreated1 = \\u00271.speedBump.timeCreated\\u0027;\\n    // how long after the SpeedBump was created that this can be used\\n    bytes constant private speedBumpWaitingHours1 = \\u00271.speedBump.waitingHours\\u0027;\\n    //mainnet QNT address\\n    ERC20Interface constant private QNTContract = ERC20Interface(0x4a220E6096B25EADb88358cb44068A3248254675); \\n \\n    // The event fired when the deposit contract\\u0027s deposit is deducted:\\n    event depositDeducted(uint256 claimedQNT, address receiver, uint256 remainingQNT, address ruleAddress);\\n    // The event fired when the deposit contract\\u0027s deposit is returned:\\n    event depositReturned(uint256 returnedQNT);\\n    // The event fired when a speed bump has been created:\\n    event updatedSpeedBump(uint256 QNTToWithdraw,uint16 speedBumpHours);\\n\\n    \\n    /**\\n    * Initialises the variables\\n    * @param linkedTreasuryContract - the address of the linked treasury contract\\n    */ \\n    function initialize(address linkedTreasuryContract) external {\\n        require(!initialized(),\\\"contract can only be initialised once\\\");\\n        addressStorage[keccak256(treasuryAddress1)] = linkedTreasuryContract;\\n        initializeNow(); //sets this contract to initialized\\n    }\\n    \\n    /**\\n     * The rule list contract can deduct QNT from this escrow and send it to the receiver (without closing the escrow)\\n     * @param tokenAmount - the amount to deduct\\n     * @param ruleAddress - the contract address detailing the specific rule the treasury has broken\\n     * @param receiver - who will receive the deducted deposit\\n     */\\n    function deductDeposit(uint256 tokenAmount, address ruleAddress, address receiver) external {\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        require(msg.sender == t.treasurysRuleList(), \\\"This function can only be called by the associated rule list contract\\\");\\n        // Transfer the escrowed QNT:\\n        uint256 startingBalance = QNTBalance();\\n        if (tokenAmount \\u003e startingBalance){\\n            //transfer as much as possible:\\n            QNTContract.transfer(receiver, startingBalance);   \\n            // Emit event\\n            emit depositDeducted(startingBalance,receiver,0,ruleAddress);\\n        } else {\\n            //transfer required amount\\n            QNTContract.transfer(receiver, tokenAmount);\\n            // Emit event\\n            emit depositDeducted(tokenAmount,receiver,QNTBalance(),ruleAddress);\\n        }\\n    }\\n\\n    /**\\n     * Withdraws QNT from the deposit, as detailed in the speedBump only after the waiting time of the speed bump has completed\\n     */\\n    function withdrawDeposit() external {\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        uint256 sBTimeCreated = speedBumpTimeCreated();\\n      require(msg.sender == t.operatorAddress(), \\\"Can only be called by the treasury operator\\\");\\n      require(sBTimeCreated \\u003e 0, \\\"Time created must be \\u003e0 (to stop replays of the speed bump)\\\");\\n      require(now \\u003e sBTimeCreated + (speedBumpWaitingHours()*1 hours), \\\"The speed bump time period must have passed\\\");\\n      uint256 QNTToWithdraw = speedBumpQNTToWithdraw();\\n      if (QNTToWithdraw \\u003e 0){\\n          //wipe the speed bump\\n          speedBumpQNTToWithdraw(0);\\n          speedBumpTimeCreated(0);\\n          speedBumpWaitingHours(0);\\n          // Transfer the escrowed QNT:\\n          address receiver = t.QNTAddress();\\n          uint256 startingBalance = QNTBalance();\\n          if (QNTToWithdraw \\u003e startingBalance){ \\n            //this would occur if the treasury has been slashed since the SpeedBump was created\\n            //transfer as much as possible:\\n            QNTContract.transfer(receiver, startingBalance);  \\n            //emits event\\n            emit depositReturned(startingBalance); \\n          } else {\\n            //transfer required amount\\n            QNTContract.transfer(receiver, QNTToWithdraw);     \\n            //emits event\\n            emit depositReturned(QNTToWithdraw); \\n          }\\n      }\\n    }\\n    \\n    /**\\n     * Creates a SpeedBump request to withdraw some (non-slashed) QNT\\n     * @param QNTToWithdraw - the desired QNT to withdraw\\n     */\\n    function updateSpeedBump(uint256 QNTToWithdraw) external {\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        require(msg.sender == t.operatorAddress(), \\\"This function can only be called by the treasury operator\\\");\\n        require(QNTBalance() \\u003e= QNTToWithdraw, \\\"There is not enough QNT in the escrowed deposit\\\");\\n        //set the speed bump variables\\n        speedBumpQNTToWithdraw(QNTToWithdraw);\\n        speedBumpTimeCreated(now);\\n        uint16 sbHours = t.speedBumpHours();\\n        speedBumpWaitingHours(sbHours);\\n        emit updatedSpeedBump(QNTToWithdraw,sbHours);\\n    }\\n    \\n    /**\\n     * sets a QNT to withdraw amount for the speed bump\\n     */        \\n    function speedBumpQNTToWithdraw(uint256 QNTToWithdraw) internal {\\n        uint256Storage[keccak256(speedBumpQNTToWithdraw1)] = QNTToWithdraw;\\n    }\\n    \\n    /**\\n     * sets the time the speed bump was created\\n     */        \\n    function speedBumpTimeCreated(uint256 timeCreated) internal {\\n        uint256Storage[keccak256(speedBumpTimeCreated1)] = timeCreated;\\n    }\\n    \\n    /**\\n     * Sets the number of hours before the speed bump can be used\\n     */       \\n    function speedBumpWaitingHours(uint16 currentSBHours) internal {\\n        uint16Storage[keccak256(speedBumpWaitingHours1)] = currentSBHours;\\n    }\\n\\n    /**\\n    * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n    */\\n    function admin() public view returns (address) {\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        return t.admin();   \\n    }\\n    \\n    /**\\n    * @return - the number of hours wait time for any critical update\\n    */        \\n    function speedBumpHours() public view returns (uint16){\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        return t.speedBumpHours();\\n    }\\n\\n    /**\\n     * Reads the current QNT balance of this contract by checking the linked treasury\\n     * @return - the QNT balance\\n     */\\n    function QNTBalance() public view returns (uint256) {\\n        return QNTContract.balanceOf(address(this));\\n    }\\n    \\n    /**\\n     * Reads the linked ERC20 address\\n     * @return - the ERC20 contract\\n     */       \\n    function ERC20Address() external pure returns (address) {\\n        return address(QNTContract);\\n    }\\n    \\n    /**\\n     * Reads the linked treasury contract address\\n     * @return - the treasury contract\\n     */         \\n    function treasuryAddress() public view returns (address) {\\n        return addressStorage[keccak256(treasuryAddress1)];\\n    }\\n    \\n    /**\\n     * Reads the requested QNT of the SpeedBump\\n     * @return - the QNT\\n     */        \\n    function speedBumpQNTToWithdraw() public view returns (uint256) {\\n        return uint256Storage[keccak256(speedBumpQNTToWithdraw1)];\\n    }\\n    \\n    /**\\n     * Reads the time the speedBump was created at\\n     * @return - the creation time\\n     */        \\n    function speedBumpTimeCreated() public view returns (uint256) {\\n        return uint256Storage[keccak256(speedBumpTimeCreated1)];\\n    }\\n    \\n    /**\\n     * Reads the number of hours until the SpeedBump can be used\\n     * @return - the number of hours\\n     */        \\n    function speedBumpWaitingHours() public view returns (uint16) {\\n        return uint16Storage[keccak256(speedBumpWaitingHours1)];\\n    }\\n\\n\\n}\"},\"UpgradeableProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./EternalStorageData.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title UpgradeableProxy\\n * @dev This contract allows the proxy to be upgradeable and owned\\n */\\ncontract UpgradeableProxy is EternalStorage {\\n    \\n    /**\\n   * Sets the admin of the proxy. Only the admin address can change this\\n   */\\n  function setAdmin() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n        require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      //change storage\\n      addressStorage[keccak256(\\u0027proxy.admin\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)];\\n      //remove speed bump\\n       addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = address(0);\\n  }\\n  \\n    /**\\n   * Sets the implementation of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function setImplementation() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n      require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      addressStorage[keccak256(\\u0027proxy.implementation\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)]; \\n      addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = address(0); \\n  }\\n  \\n    /**\\n   * Adds a speed bump to change the admin or implementation. Only the admin address can change this\\n   */\\n  function changeProxyVariables(address nextAdmin, address nextImplementation) external {\\n      require(msg.sender == admin(), \\u0027only admin can call this function\\u0027);\\n        addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = nextAdmin;\\n        addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = nextImplementation;\\n        //note that admin and implementation functions are separate above to align with more upgradeability patterns\\n        uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)] = now + (speedBumpHours()*1 hours);\\n  }\\n\\n   /**\\n   * sets the contract as initialised\\n   */ \\n  function initializeNow() internal {\\n      boolStorage[keccak256(\\u0027proxy.initialized\\u0027)] = true;    \\n  }\\n  \\n    /**\\n    * set the speed bump time of this contract\\n    */        \\n    function speedBumpHours(uint16 newSpeedBumpHours) internal {\\n        uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)] = newSpeedBumpHours;\\n    }\\n  \\n  /**\\n   * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function admin() public view returns (address);\\n \\n  /**\\n   * @return - the address of the current smart contract logic\\n   */ \\n  function implementation() public view returns (address) {\\n      return addressStorage[keccak256(\\u0027proxy.implementation\\u0027)];    \\n  }\\n  \\n  /**\\n   * @return - whether the smart contract has  been initialized (true) or not (false)\\n   */ \\n  function initialized() public view returns (bool) {\\n      return boolStorage[keccak256(\\u0027proxy.initialized\\u0027)];    \\n  }\\n  \\n    /**\\n    * @return - the number of hours wait time for any critical update\\n    */        \\n    function speedBumpHours() public view returns (uint16);\\n  \\n    \\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedQNT\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingQNT\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ruleAddress\",\"type\":\"address\"}],\"name\":\"depositDeducted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedQNT\",\"type\":\"uint256\"}],\"name\":\"depositReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"QNTToWithdraw\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"speedBumpHours\",\"type\":\"uint16\"}],\"name\":\"updatedSpeedBump\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC20Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QNTBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nextImplementation\",\"type\":\"address\"}],\"name\":\"changeProxyVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ruleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deductDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkedTreasuryContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"speedBumpHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"speedBumpQNTToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"speedBumpTimeCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"speedBumpWaitingHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"QNTToWithdraw\",\"type\":\"uint256\"}],\"name\":\"updateSpeedBump\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EscrowedDeposit","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://dc38dd298690eac2b984c144e5c796ee2b7d8aaf4054ede9659d0bc77c2b659f"}]}