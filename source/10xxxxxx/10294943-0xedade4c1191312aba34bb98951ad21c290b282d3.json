{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.6;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface Erc20Token {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);  // @TOODO: convert bytes32 as needed\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address addr) external view returns (uint);\r\n}\r\n\r\ninterface Erc721Token {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n\r\n    function ownerOf(uint tokenId) external view returns (address);\r\n    function tokenUri(uint tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract AccountState {\r\n\r\n    struct Erc20Info {\r\n        bytes name;\r\n        bytes symbol;\r\n        uint256 decimals;\r\n\r\n        uint balance;\r\n    }\r\n\r\n    struct Erc721Info {\r\n        bytes name;\r\n        bytes symbol;\r\n    }\r\n\r\n    struct Erc721TokenInfo {\r\n        uint owner;\r\n        bytes tokenUri;\r\n    }\r\n\r\n\r\n    // Calls addr with data which returns (uint256)\r\n    function getUint(address addr, bytes memory data) internal view returns (uint result) {\r\n        result = 0;\r\n\r\n        assembly {\r\n            let status := staticcall(16000, addr, add(data, 32), mload(data), 0, 0)\r\n\r\n            // Success!\r\n            if eq(status, 1) {\r\n                if eq(returndatasize(), 32) {\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Calls addr with data which returns (string)\r\n    function getString(address addr, bytes memory data) internal view returns (bytes memory result) {\r\n        assembly {\r\n            result := mload(0x40)\r\n\r\n            // Initialize as length 0 (in case things go wrong)\r\n            mstore(result, 0)\r\n            mstore(0x40, add(result, 32))\r\n\r\n            let status := staticcall(16000, addr, add(data, 32), mload(data), 0, 0)\r\n\r\n            // Success!\r\n            if eq(status, 1) {\r\n\r\n                // If the data returned is 32 bytes, old non-compliant token\r\n                // which returns a bytes32 string\r\n                if eq(returndatasize(), 32) {\r\n                    returndatacopy(0, 0, 32)\r\n\r\n                    mstore(result, 32)\r\n                    mstore(add(result, 32), mload(0))\r\n                    mstore(0x40, add(result, 64))\r\n                }\r\n\r\n                // If the data returned is >= 96 bytes; a string!\r\n                if gt(returndatasize(), 95) {\r\n                    // Dereference the string pointer\r\n                    returndatacopy(0x0, 0, 32)\r\n                    let ptr := mload(0x0)\r\n\r\n                    // This does not handle non-minimal packed strings (should it?)\r\n                    if eq(ptr, 32) {\r\n\r\n                        let returnSize := sub(returndatasize(), ptr)\r\n\r\n                        // Check the return data size fits the encoded string size\r\n                        returndatacopy(0x0, ptr, 32)\r\n                        let payloadSize := add(mload(0x0), 32)\r\n                        if iszero(gt(payloadSize, returnSize)) {         // payloadSize <= returnSize\r\n\r\n                            // Copy the returned string (only up to the correct length;\r\n                            // zeros will be padded below by adjusting memory, which\r\n                            // ensures there is no junk from the callee)\r\n                            returndatacopy(result, ptr, payloadSize)\r\n\r\n                            // Re-adjust the free-memory pointer, rounded up to the neared word\r\n                            mstore(0x40, add(result, and(add(add(payloadSize, 0x20), 0x1f), not(0x1f))))\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getErc20Info(address[] memory erc20s) internal view returns (Erc20Info[] memory) {\r\n        Erc20Info[] memory erc20Infos = new Erc20Info[](erc20s.length);\r\n\r\n        for (uint i = 0; i < erc20s.length; i++) {\r\n            address token = erc20s[i];\r\n\r\n            Erc20Info memory erc20Info = erc20Infos[i];\r\n\r\n            erc20Info.name = getString(token, abi.encodeWithSignature(\"name()\"));\r\n            erc20Info.symbol = getString(token, abi.encodeWithSignature(\"symbol()\"));\r\n            erc20Info.decimals = getUint(token, abi.encodeWithSignature(\"decimals()\"));\r\n\r\n            erc20Info.balance = getUint(token, abi.encodeWithSignature(\"balanceOf(address)\", msg.sender));\r\n        }\r\n\r\n        return erc20Infos;\r\n    }\r\n\r\n    function getErc721Info(address[] memory erc721s, uint[] memory counts, uint[] memory erc721TokenIds) internal view returns (Erc721Info[] memory, Erc721TokenInfo[] memory) {\r\n        Erc721Info[] memory erc721Infos = new Erc721Info[](erc721s.length);\r\n        Erc721TokenInfo[] memory erc721TokenInfos = new Erc721TokenInfo[](erc721TokenIds.length);\r\n\r\n        uint k = 0;\r\n        for (uint i = 0; i < erc721s.length; i++) {\r\n            address token = erc721s[i];\r\n            Erc721Info memory erc721Info = erc721Infos[i];\r\n\r\n            erc721Info.name = getString(token, abi.encodeWithSignature(\"name()\"));\r\n            erc721Info.symbol = getString(token, abi.encodeWithSignature(\"symbol()\"));\r\n\r\n            uint count = counts[i];\r\n            for (uint j = 0; j < count; j++) {\r\n                Erc721TokenInfo memory erc721TokenInfo = erc721TokenInfos[k];\r\n\r\n                erc721TokenInfo.owner = getUint(token, abi.encodeWithSignature(\"ownerOf(uint256)\", erc721TokenIds[k]));\r\n                erc721TokenInfo.tokenUri = getString(token, abi.encodeWithSignature(\"tokenURI(uint256)\", erc721TokenIds[k]));\r\n\r\n                k++;\r\n            }\r\n        }\r\n\r\n        return (erc721Infos, erc721TokenInfos);\r\n    }\r\n\r\n    function getInfo(\r\n        address[] calldata erc20s,\r\n        address[] calldata erc721s,\r\n        uint[] calldata erc721Counts,\r\n        uint[] calldata erc721TokenIds\r\n    ) external view returns(\r\n        uint256,\r\n        uint256,\r\n        Erc20Info[] memory,\r\n        Erc721Info[] memory,\r\n        Erc721TokenInfo[] memory\r\n    ) {\r\n        Erc20Info[] memory erc20Infos = getErc20Info(erc20s);\r\n\r\n        (Erc721Info[] memory erc721Infos, Erc721TokenInfo[] memory erc721TokenInfos) = getErc721Info(erc721s, erc721Counts, erc721TokenIds);\r\n\r\n        return (\r\n            msg.sender.balance,\r\n            block.number,\r\n            erc20Infos,\r\n            erc721Infos,\r\n            erc721TokenInfos\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"erc20s\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"erc721s\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"erc721Counts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"erc721TokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"symbol\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct AccountState.Erc20Info[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"symbol\",\"type\":\"bytes\"}],\"internalType\":\"struct AccountState.Erc721Info[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"owner\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tokenUri\",\"type\":\"bytes\"}],\"internalType\":\"struct AccountState.Erc721TokenInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AccountState","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://500abd28d6c6dbb92419f48ca674a1f95a587bdc03de1e7c054403f7bfdd3d05"}]}