{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/BaseWithStorage/ERC20Group.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20SubToken.sol\\\";\\nimport \\\"../contracts_common/src/Libraries/SafeMath.sol\\\";\\nimport \\\"../contracts_common/src/Libraries/AddressUtils.sol\\\";\\nimport \\\"../contracts_common/src/Libraries/ObjectLib32.sol\\\";\\nimport \\\"../contracts_common/src/Libraries/BytesUtil.sol\\\";\\n\\nimport \\\"../contracts_common/src/BaseWithStorage/SuperOperators.sol\\\";\\nimport \\\"../contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol\\\";\\n\\n\\ncontract ERC20Group is SuperOperators, MetaTransactionReceiver {\\n    uint256 internal constant MAX_UINT256 = ~uint256(0);\\n\\n    /// @notice emitted when a new Token is added to the group.\\n    /// @param subToken the token added, its id will be its index in the array.\\n    event SubToken(ERC20SubToken subToken);\\n\\n    /// @notice emitted when `owner` is allowing or disallowing `operator` to transfer tokens on its behalf.\\n    /// @param owner the address approving.\\n    /// @param operator the address being granted (or revoked) permission to transfer.\\n    /// @param approved whether the operator is granted transfer right or not.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event Minter(address minter, bool enabled);\\n\\n    /// @notice Enable or disable the ability of `minter` to mint tokens\\n    /// @param minter address that will be given/removed minter right.\\n    /// @param enabled set whether the minter is enabled or disabled.\\n    function setMinter(address minter, bool enabled) external {\\n        require(msg.sender == _admin, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _setMinter(minter, enabled);\\n    }\\n\\n    /// @notice check whether address `who` is given minter rights.\\n    /// @param who The address to query.\\n    /// @return whether the address has minter rights.\\n    function isMinter(address who) public view returns (bool) {\\n        return _minters[who];\\n    }\\n\\n    /// @dev mint more tokens of a specific subToken .\\n    /// @param to address receiving the tokens.\\n    /// @param id subToken id (also the index at which it was added).\\n    /// @param amount of token minted.\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(_minters[msg.sender], \\\"NOT_AUTHORIZED_MINTER\\\");\\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\\n        toPack[bin] = toPack[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\\n        _packedSupplies[bin] = _packedSupplies[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\\n        _erc20s[id].emitTransferEvent(address(0), to, amount);\\n    }\\n\\n    /// @dev mint more tokens of a several subToken .\\n    /// @param to address receiving the tokens.\\n    /// @param ids subToken ids (also the index at which it was added).\\n    /// @param amounts for each token minted.\\n    function batchMint(\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(_minters[msg.sender], \\\"NOT_AUTHORIZED_MINTER\\\");\\n        require(ids.length == amounts.length, \\\"INVALID_INCONSISTENT_LENGTH\\\");\\n        _batchMint(to, ids, amounts);\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 lastBin = MAX_UINT256;\\n        uint256 bal = 0;\\n        uint256 supply = 0;\\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            if (amounts[i] != 0) {\\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\\n                if (lastBin == MAX_UINT256) {\\n                    lastBin = bin;\\n                    bal = toPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\\n                } else {\\n                    if (bin != lastBin) {\\n                        toPack[lastBin] = bal;\\n                        bal = toPack[bin];\\n                        _packedSupplies[lastBin] = supply;\\n                        supply = _packedSupplies[bin];\\n                        lastBin = bin;\\n                    }\\n                    bal = bal.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\\n                }\\n                _erc20s[ids[i]].emitTransferEvent(address(0), to, amounts[i]);\\n            }\\n        }\\n        if (lastBin != MAX_UINT256) {\\n            toPack[lastBin] = bal;\\n            _packedSupplies[lastBin] = supply;\\n        }\\n    }\\n\\n    /// @notice return the current total supply of a specific subToken.\\n    /// @param id subToken id.\\n    /// @return supply current total number of tokens.\\n    function supplyOf(uint256 id) external view returns (uint256 supply) {\\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\\n        return _packedSupplies[bin].getValueInBin(index);\\n    }\\n\\n    /// @notice return the balance of a particular owner for a particular subToken.\\n    /// @param owner whose balance it is of.\\n    /// @param id subToken id.\\n    /// @return balance of the owner\\n    function balanceOf(address owner, uint256 id) public view returns (uint256 balance) {\\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\\n        return _packedTokenBalance[owner][bin].getValueInBin(index);\\n    }\\n\\n    /// @notice return the balances of a list of owners / subTokens.\\n    /// @param owners list of addresses to which we want to know the balance.\\n    /// @param ids list of subTokens's addresses.\\n    /// @return balances list of balances for each request.\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory balances) {\\n        require(owners.length == ids.length, \\\"INVALID_INCONSISTENT_LENGTH\\\");\\n        balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n    }\\n\\n    /// @notice transfer a number of subToken from one address to another.\\n    /// @param from owner to transfer from.\\n    /// @param to destination address that will receive the tokens.\\n    /// @param id subToken id.\\n    /// @param value amount of tokens to transfer.\\n    function singleTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value\\n    ) external {\\n        require(to != address(0), \\\"INVALID_TO_ZERO_ADDRESS\\\");\\n        ERC20SubToken erc20 = _erc20s[id];\\n        require(\\n            from == msg.sender ||\\n                msg.sender == address(erc20) ||\\n                _metaTransactionContracts[msg.sender] ||\\n                _superOperators[msg.sender] ||\\n                _operatorsForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\\n        fromPack[bin] = fromPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.SUB);\\n        toPack[bin] = toPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.ADD);\\n        erc20.emitTransferEvent(from, to, value);\\n    }\\n\\n    /// @notice transfer a number of different subTokens from one address to another.\\n    /// @param from owner to transfer from.\\n    /// @param to destination address that will receive the tokens.\\n    /// @param ids list of subToken ids to transfer.\\n    /// @param values list of amount for eacg subTokens to transfer.\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values\\n    ) external {\\n        require(ids.length == values.length, \\\"INVALID_INCONSISTENT_LENGTH\\\");\\n        require(to != address(0), \\\"INVALID_TO_ZERO_ADDRESS\\\");\\n        require(\\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n        _batchTransferFrom(from, to, ids, values);\\n    }\\n\\n    function _batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values\\n    ) internal {\\n        uint256 lastBin = MAX_UINT256;\\n        uint256 balFrom;\\n        uint256 balTo;\\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            if (values[i] != 0) {\\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\\n                if (lastBin == MAX_UINT256) {\\n                    lastBin = bin;\\n                    balFrom = ObjectLib32.updateTokenBalance(fromPack[bin], index, values[i], ObjectLib32.Operations.SUB);\\n                    balTo = ObjectLib32.updateTokenBalance(toPack[bin], index, values[i], ObjectLib32.Operations.ADD);\\n                } else {\\n                    if (bin != lastBin) {\\n                        fromPack[lastBin] = balFrom;\\n                        toPack[lastBin] = balTo;\\n                        balFrom = fromPack[bin];\\n                        balTo = toPack[bin];\\n                        lastBin = bin;\\n                    }\\n                    balFrom = balFrom.updateTokenBalance(index, values[i], ObjectLib32.Operations.SUB);\\n                    balTo = balTo.updateTokenBalance(index, values[i], ObjectLib32.Operations.ADD);\\n                }\\n                ERC20SubToken erc20 = _erc20s[ids[i]];\\n                erc20.emitTransferEvent(from, to, values[i]);\\n            }\\n        }\\n        if (lastBin != MAX_UINT256) {\\n            fromPack[lastBin] = balFrom;\\n            toPack[lastBin] = balTo;\\n        }\\n    }\\n\\n    /// @notice grant or revoke the ability for an address to transfer token on behalf of another address.\\n    /// @param sender address granting/revoking the approval.\\n    /// @param operator address being granted/revoked ability to transfer.\\n    /// @param approved whether the operator is revoked or approved.\\n    function setApprovalForAllFor(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) external {\\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \\\"NOT_AUTHORIZED\\\");\\n        _setApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @notice grant or revoke the ability for an address to transfer token on your behalf.\\n    /// @param operator address being granted/revoked ability to transfer.\\n    /// @param approved whether the operator is revoked or approved.\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _setApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @notice return whether an oeprator has the ability to transfer on behalf of another address.\\n    /// @param owner address who would have granted the rights.\\n    /// @param operator address being given the ability to transfer.\\n    /// @return isOperator whether the operator has approval rigths or not.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool isOperator) {\\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\\n    }\\n\\n    function isAuthorizedToTransfer(address owner, address sender) external view returns (bool) {\\n        return _metaTransactionContracts[sender] || _superOperators[sender] || _operatorsForAll[owner][sender];\\n    }\\n\\n    function isAuthorizedToApprove(address sender) external view returns (bool) {\\n        return _metaTransactionContracts[sender] || _superOperators[sender];\\n    }\\n\\n    function batchBurnFrom(\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(from != address(0), \\\"INVALID_FROM_ZERO_ADDRESS\\\");\\n        require(\\n            from == msg.sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        _batchBurnFrom(from, ids, amounts);\\n    }\\n\\n    /// @notice burn token for a specific owner and subToken.\\n    /// @param from fron which address the token are burned from.\\n    /// @param id subToken id.\\n    /// @param value amount of tokens to burn.\\n    function burnFrom(\\n        address from,\\n        uint256 id,\\n        uint256 value\\n    ) external {\\n        require(\\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n        _burn(from, id, value);\\n    }\\n\\n    /// @notice burn token for a specific subToken.\\n    /// @param id subToken id.\\n    /// @param value amount of tokens to burn.\\n    function burn(uint256 id, uint256 value) external {\\n        _burn(msg.sender, id, value);\\n    }\\n\\n    // ///////////////// INTERNAL //////////////////////////\\n\\n    function _batchBurnFrom(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 balFrom = 0;\\n        uint256 supply = 0;\\n        uint256 lastBin = MAX_UINT256;\\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            if (amounts[i] != 0) {\\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\\n                if (lastBin == MAX_UINT256) {\\n                    lastBin = bin;\\n                    balFrom = fromPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\\n                } else {\\n                    if (bin != lastBin) {\\n                        fromPack[lastBin] = balFrom;\\n                        balFrom = fromPack[bin];\\n                        _packedSupplies[lastBin] = supply;\\n                        supply = _packedSupplies[bin];\\n                        lastBin = bin;\\n                    }\\n\\n                    balFrom = balFrom.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\\n                }\\n                _erc20s[ids[i]].emitTransferEvent(from, address(0), amounts[i]);\\n            }\\n        }\\n        if (lastBin != MAX_UINT256) {\\n            fromPack[lastBin] = balFrom;\\n            _packedSupplies[lastBin] = supply;\\n        }\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 value\\n    ) internal {\\n        ERC20SubToken erc20 = _erc20s[id];\\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\\n        fromPack[bin] = ObjectLib32.updateTokenBalance(fromPack[bin], index, value, ObjectLib32.Operations.SUB);\\n        _packedSupplies[bin] = ObjectLib32.updateTokenBalance(_packedSupplies[bin], index, value, ObjectLib32.Operations.SUB);\\n        erc20.emitTransferEvent(from, address(0), value);\\n    }\\n\\n    function _addSubToken(ERC20SubToken subToken) internal returns (uint256 id) {\\n        id = _erc20s.length;\\n        require(subToken.groupAddress() == address(this), \\\"INVALID_GROUP\\\");\\n        require(subToken.groupTokenId() == id, \\\"INVALID_ID\\\");\\n        _erc20s.push(subToken);\\n        emit SubToken(subToken);\\n    }\\n\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal {\\n        require(!_superOperators[operator], \\\"INVALID_SUPER_OPERATOR\\\");\\n        _operatorsForAll[sender][operator] = approved;\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    function _setMinter(address minter, bool enabled) internal {\\n        _minters[minter] = enabled;\\n        emit Minter(minter, enabled);\\n    }\\n\\n    // ///////////////// UTILITIES /////////////////////////\\n    using AddressUtils for address;\\n    using ObjectLib32 for ObjectLib32.Operations;\\n    using ObjectLib32 for uint256;\\n    using SafeMath for uint256;\\n\\n    // ////////////////// DATA ///////////////////////////////\\n    mapping(uint256 => uint256) internal _packedSupplies;\\n    mapping(address => mapping(uint256 => uint256)) internal _packedTokenBalance;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    ERC20SubToken[] internal _erc20s;\\n    mapping(address => bool) internal _minters;\\n\\n    // ////////////// CONSTRUCTOR ////////////////////////////\\n\\n    struct SubTokenData {\\n        string name;\\n        string symbol;\\n    }\\n\\n    constructor(\\n        address metaTransactionContract,\\n        address admin,\\n        address initialMinter\\n    ) internal {\\n        _admin = admin;\\n        _setMetaTransactionProcessor(metaTransactionContract, true);\\n        _setMinter(initialMinter, true);\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x1831eed9ae2700d27f8792499902baf6ba0605f3eb66f17bd87d14b7986a2209\"\r\n    },\r\n    \"src/BaseWithStorage/ERC20SubToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\n\\nimport \\\"../contracts_common/src/Libraries/SafeMathWithRequire.sol\\\";\\nimport \\\"../contracts_common/src/BaseWithStorage/SuperOperators.sol\\\";\\nimport \\\"../contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol\\\";\\n\\nimport \\\"./ERC20Group.sol\\\";\\n\\n\\ncontract ERC20SubToken {\\n    // TODO add natspec, currently blocked by solidity compiler issue\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    // TODO add natspec, currently blocked by solidity compiler issue\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice A descriptive name for the tokens\\n    /// @return name of the tokens\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @notice An abbreviated name for the tokens\\n    /// @return symbol of the tokens\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /// @notice the tokenId in ERC20Group\\n    /// @return the tokenId in ERC20Group\\n    function groupTokenId() external view returns (uint256) {\\n        return _index;\\n    }\\n\\n    /// @notice the ERC20Group address\\n    /// @return the address of the group\\n    function groupAddress() external view returns (address) {\\n        return address(_group);\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _group.supplyOf(_index);\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        return _group.balanceOf(who, _index);\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return uint8(0);\\n    }\\n\\n    function transfer(address to, uint256 amount) external returns (bool success) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        if (msg.sender != from && !_group.isAuthorizedToTransfer(from, msg.sender)) {\\n            uint256 allowance = _mAllowed[from][msg.sender];\\n            if (allowance != ~uint256(0)) {\\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\\n                require(allowance >= amount, \\\"NOT_AUTHOIZED_ALLOWANCE\\\");\\n                _mAllowed[from][msg.sender] = allowance - amount;\\n            }\\n        }\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount) external returns (bool success) {\\n        _approveFor(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveFor(\\n        address from,\\n        address spender,\\n        uint256 amount\\n    ) external returns (bool success) {\\n        require(msg.sender == from || _group.isAuthorizedToApprove(msg.sender), \\\"NOT_AUTHORIZED\\\");\\n        _approveFor(from, spender, amount);\\n        return true;\\n    }\\n\\n    function emitTransferEvent(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        require(msg.sender == address(_group), \\\"NOT_AUTHORIZED_GROUP_ONLY\\\");\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    // /////////////////// INTERNAL ////////////////////////\\n\\n    function _approveFor(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0) && spender != address(0), \\\"INVALID_FROM_OR_SPENDER\\\");\\n        _mAllowed[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function allowance(address owner, address spender) external view returns (uint256 remaining) {\\n        return _mAllowed[owner][spender];\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        _group.singleTransferFrom(from, to, _index, amount);\\n    }\\n\\n    // ///////////////////// UTILITIES ///////////////////////\\n    using SafeMathWithRequire for uint256;\\n\\n    // //////////////////// CONSTRUCTOR /////////////////////\\n    constructor(\\n        ERC20Group group,\\n        uint256 index,\\n        string memory tokenName,\\n        string memory tokenSymbol\\n    ) public {\\n        _group = group;\\n        _index = index;\\n        _name = tokenName;\\n        _symbol = tokenSymbol;\\n    }\\n\\n    // ////////////////////// DATA ///////////////////////////\\n    ERC20Group internal immutable _group;\\n    uint256 internal immutable _index;\\n    mapping(address => mapping(address => uint256)) internal _mAllowed;\\n    string internal _name;\\n    string internal _symbol;\\n}\\n\",\r\n      \"keccak256\": \"0x13930d853cfc2bb74e062fb0ebf17ebcc04105676fe63acee092f04e0f63b713\"\r\n    },\r\n    \"src/Catalyst/CatalystToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface CatalystToken {\\n    function getMintData(uint256 catalystId)\\n        external\\n        view\\n        returns (\\n            uint16 maxGems,\\n            uint16 minQuantity,\\n            uint16 maxQuantity,\\n            uint256 sandMintingFee,\\n            uint256 sandUpdateFee\\n        );\\n\\n    function batchBurnFrom(\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    function burnFrom(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) external;\\n}\\n\",\r\n      \"keccak256\": \"0xca09d3d65037c817100fd04d4e4bb4fe5008d8687532755d38cb36f5789ed7e0\"\r\n    },\r\n    \"src/Catalyst/CatalystValue.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface CatalystValue {\\n    struct GemEvent {\\n        uint256[] gemIds;\\n        bytes32 blockHash;\\n    }\\n\\n    function getValues(\\n        uint256 catalystId,\\n        uint256 seed,\\n        GemEvent[] calldata events,\\n        uint32 totalNumberOfGemTypes\\n    ) external view returns (uint32[] memory values);\\n}\\n\",\r\n      \"keccak256\": \"0x3983ba567af891e8d4c6a983bd0857d930754fd36d72b330925a3df33289ae0f\"\r\n    },\r\n    \"src/Catalyst/GemToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\n\\n\\ninterface GemToken {\\n    function batchBurnFrom(\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external;\\n}\\n\",\r\n      \"keccak256\": \"0x33924e2f4962abb02de5ff13280c0df4a2cef60040504980873a2859b92876dc\"\r\n    },\r\n    \"src/CatalystMinter.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Interfaces/AssetToken.sol\\\";\\nimport \\\"./contracts_common/src/Interfaces/ERC20.sol\\\";\\nimport \\\"./Interfaces/ERC20Extended.sol\\\";\\nimport \\\"./contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol\\\";\\nimport \\\"./contracts_common/src/Libraries/SafeMathWithRequire.sol\\\";\\nimport \\\"./Catalyst/GemToken.sol\\\";\\nimport \\\"./Catalyst/CatalystToken.sol\\\";\\nimport \\\"./CatalystRegistry.sol\\\";\\nimport \\\"./BaseWithStorage/ERC20Group.sol\\\";\\n\\n\\n/// @notice Gateway to mint Asset with Catalyst, Gems and Sand\\ncontract CatalystMinter is MetaTransactionReceiver {\\n    /// @dev emitted when fee collector (that receive the sand fee) get changed\\n    /// @param newCollector address of the new collector, address(0) means the fee will be burned\\n    event FeeCollector(address newCollector);\\n\\n    function setFeeCollector(address newCollector) external {\\n        require(msg.sender == _admin, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _setFeeCollector(newCollector);\\n    }\\n\\n    event GemAdditionFee(uint256 newFee);\\n\\n    function setGemAdditionFee(uint256 newFee) external {\\n        require(msg.sender == _admin, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _setGemAdditionFee(newFee);\\n    }\\n\\n    /// @notice mint one Asset token.\\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\\n    /// @param packId unused packId that will let you predict the resulting tokenId.\\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\\n    /// @param catalystId address of the Catalyst ERC20 token to burn.\\n    /// @param gemIds list of gem ids to burn in the catalyst.\\n    /// @param quantity asset supply to mint\\n    /// @param to destination address receiving the minted tokens.\\n    /// @param data extra data.\\n    function mint(\\n        address from,\\n        uint40 packId,\\n        bytes32 metadataHash,\\n        uint256 catalystId,\\n        uint256[] calldata gemIds,\\n        uint256 quantity,\\n        address to,\\n        bytes calldata data\\n    ) external returns (uint256) {\\n        _checkAuthorization(from, to);\\n        _burnCatalyst(from, catalystId);\\n        uint16 maxGems = _checkQuantityAndBurnSandAndGems(from, catalystId, gemIds, quantity);\\n        uint256 id = _asset.mint(from, packId, metadataHash, quantity, 0, to, data);\\n        _catalystRegistry.setCatalyst(id, catalystId, maxGems, gemIds);\\n        return id;\\n    }\\n\\n    /// @notice associate a catalyst to a fungible Asset token by extracting it as ERC721 first.\\n    /// @param from address from which the Asset token belongs to.\\n    /// @param assetId tokenId of the Asset being extracted.\\n    /// @param catalystId address of the catalyst token to use and burn.\\n    /// @param gemIds list of gems to socket into the catalyst (burned).\\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\\n    function extractAndChangeCatalyst(\\n        address from,\\n        uint256 assetId,\\n        uint256 catalystId,\\n        uint256[] calldata gemIds,\\n        address to\\n    ) external returns (uint256 tokenId) {\\n        _checkAuthorization(from, to);\\n        tokenId = _asset.extractERC721From(from, assetId, from);\\n        _changeCatalyst(from, tokenId, catalystId, gemIds, to);\\n    }\\n\\n    /// @notice associate a new catalyst to a non-fungible Asset token.\\n    /// @param from address from which the Asset token belongs to.\\n    /// @param assetId tokenId of the Asset being updated.\\n    /// @param catalystId address of the catalyst token to use and burn.\\n    /// @param gemIds list of gems to socket into the catalyst (burned).\\n    /// @param to destination address receiving the Asset token.\\n    function changeCatalyst(\\n        address from,\\n        uint256 assetId,\\n        uint256 catalystId,\\n        uint256[] calldata gemIds,\\n        address to\\n    ) external returns (uint256 tokenId) {\\n        _checkAuthorization(from, to);\\n        _changeCatalyst(from, assetId, catalystId, gemIds, to);\\n        return assetId;\\n    }\\n\\n    /// @notice add gems to a fungible Asset token by extracting it as ERC721 first.\\n    /// @param from address from which the Asset token belongs to.\\n    /// @param assetId tokenId of the Asset being extracted.\\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\\n    function extractAndAddGems(\\n        address from,\\n        uint256 assetId,\\n        uint256[] calldata gemIds,\\n        address to\\n    ) external returns (uint256 tokenId) {\\n        _checkAuthorization(from, to);\\n        tokenId = _asset.extractERC721From(from, assetId, from);\\n        _addGems(from, tokenId, gemIds, to);\\n    }\\n\\n    /// @notice add gems to a non-fungible Asset token.\\n    /// @param from address from which the Asset token belongs to.\\n    /// @param assetId tokenId of the Asset to which the gems will be added to.\\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\\n    function addGems(\\n        address from,\\n        uint256 assetId,\\n        uint256[] calldata gemIds,\\n        address to\\n    ) external {\\n        _checkAuthorization(from, to);\\n        _addGems(from, assetId, gemIds, to);\\n    }\\n\\n    struct AssetData {\\n        uint256[] gemIds;\\n        uint256 quantity;\\n        uint256 catalystId;\\n    }\\n\\n    /// @notice mint multiple Asset tokens.\\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\\n    /// @param packId unused packId that will let you predict the resulting tokenId.\\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\\n    /// @param gemsQuantities quantities of gems to be used for each id in order\\n    /// @param catalystsQuantities quantities of catalyst to be used for each id in order\\n    /// @param assets contains the data to associate catalyst and gems to the assets.\\n    /// @param to destination address receiving the minted tokens.\\n    /// @param data extra data.\\n    function mintMultiple(\\n        address from,\\n        uint40 packId,\\n        bytes32 metadataHash,\\n        uint256[] memory gemsQuantities,\\n        uint256[] memory catalystsQuantities,\\n        AssetData[] memory assets,\\n        address to,\\n        bytes memory data\\n    ) public returns (uint256[] memory ids) {\\n        require(assets.length != 0, \\\"INVALID_0_ASSETS\\\");\\n        _checkAuthorization(from, to);\\n        return _mintMultiple(from, packId, metadataHash, gemsQuantities, catalystsQuantities, assets, to, data);\\n    }\\n\\n    // //////////////////// INTERNALS ////////////////////\\n\\n    function _checkQuantityAndBurnSandAndGems(\\n        address from,\\n        uint256 catalystId,\\n        uint256[] memory gemIds,\\n        uint256 quantity\\n    ) internal returns (uint16) {\\n        (uint16 maxGems, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, ) = _getMintData(catalystId);\\n        require(minQuantity <= quantity && quantity <= maxQuantity, \\\"INVALID_QUANTITY\\\");\\n        require(gemIds.length <= maxGems, \\\"INVALID_GEMS_TOO_MANY\\\");\\n        _burnSingleGems(from, gemIds);\\n        _chargeSand(from, quantity.mul(sandMintingFee));\\n        return maxGems;\\n    }\\n\\n    function _mintMultiple(\\n        address from,\\n        uint40 packId,\\n        bytes32 metadataHash,\\n        uint256[] memory gemsQuantities,\\n        uint256[] memory catalystsQuantities,\\n        AssetData[] memory assets,\\n        address to,\\n        bytes memory data\\n    ) internal returns (uint256[] memory) {\\n        (uint256 totalSandFee, uint256[] memory supplies, uint16[] memory maxGemsList) = _handleMultipleCatalysts(\\n            from,\\n            gemsQuantities,\\n            catalystsQuantities,\\n            assets\\n        );\\n\\n        _chargeSand(from, totalSandFee);\\n\\n        return _mintAssets(from, packId, metadataHash, assets, supplies, maxGemsList, to, data);\\n    }\\n\\n    function _chargeSand(address from, uint256 sandFee) internal {\\n        address feeCollector = _feeCollector;\\n        if (feeCollector != address(0) && sandFee != 0) {\\n            if (feeCollector == address(BURN_ADDRESS)) {\\n                // special address for burn\\n                _sand.burnFor(from, sandFee);\\n            } else {\\n                _sand.transferFrom(from, _feeCollector, sandFee);\\n            }\\n        }\\n    }\\n\\n    function _extractMintData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 maxGems,\\n            uint16 minQuantity,\\n            uint16 maxQuantity,\\n            uint256 sandMintingFee,\\n            uint256 sandUpdateFee\\n        )\\n    {\\n        maxGems = uint16(data >> 240);\\n        minQuantity = uint16((data >> 224) % 2**16);\\n        maxQuantity = uint16((data >> 208) % 2**16);\\n        sandMintingFee = uint256((data >> 120) % 2**88);\\n        sandUpdateFee = uint256(data % 2**88);\\n    }\\n\\n    function _getMintData(uint256 catalystId)\\n        internal\\n        view\\n        returns (\\n            uint16,\\n            uint16,\\n            uint16,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        if (catalystId == 0) {\\n            return _extractMintData(_common_mint_data);\\n        } else if (catalystId == 1) {\\n            return _extractMintData(_rare_mint_data);\\n        } else if (catalystId == 2) {\\n            return _extractMintData(_epic_mint_data);\\n        } else if (catalystId == 3) {\\n            return _extractMintData(_legendary_mint_data);\\n        }\\n        return _catalysts.getMintData(catalystId);\\n    }\\n\\n    function _handleMultipleCatalysts(\\n        address from,\\n        uint256[] memory gemsQuantities,\\n        uint256[] memory catalystsQuantities,\\n        AssetData[] memory assets\\n    )\\n        internal\\n        returns (\\n            uint256 totalSandFee,\\n            uint256[] memory supplies,\\n            uint16[] memory maxGemsList\\n        )\\n    {\\n        _burnCatalysts(from, catalystsQuantities);\\n        _burnGems(from, gemsQuantities);\\n\\n        supplies = new uint256[](assets.length);\\n        maxGemsList = new uint16[](assets.length);\\n\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            require(catalystsQuantities[assets[i].catalystId] != 0, \\\"INVALID_CATALYST_NOT_ENOUGH\\\");\\n            catalystsQuantities[assets[i].catalystId]--;\\n            gemsQuantities = _checkGemsQuantities(gemsQuantities, assets[i].gemIds);\\n            (uint16 maxGems, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, ) = _getMintData(assets[i].catalystId);\\n            require(minQuantity <= assets[i].quantity && assets[i].quantity <= maxQuantity, \\\"INVALID_QUANTITY\\\");\\n            require(assets[i].gemIds.length <= maxGems, \\\"INVALID_GEMS_TOO_MANY\\\");\\n            maxGemsList[i] = maxGems;\\n            supplies[i] = assets[i].quantity;\\n            totalSandFee = totalSandFee.add(sandMintingFee.mul(assets[i].quantity));\\n        }\\n    }\\n\\n    function _checkGemsQuantities(uint256[] memory gemsQuantities, uint256[] memory gemIds) internal pure returns (uint256[] memory) {\\n        for (uint256 i = 0; i < gemIds.length; i++) {\\n            require(gemsQuantities[gemIds[i]] != 0, \\\"INVALID_GEMS_NOT_ENOUGH\\\");\\n            gemsQuantities[gemIds[i]]--;\\n        }\\n        return gemsQuantities;\\n    }\\n\\n    function _burnCatalysts(address from, uint256[] memory catalystsQuantities) internal {\\n        uint256[] memory ids = new uint256[](catalystsQuantities.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            ids[i] = i;\\n        }\\n        _catalysts.batchBurnFrom(from, ids, catalystsQuantities);\\n    }\\n\\n    function _burnGems(address from, uint256[] memory gemsQuantities) internal {\\n        uint256[] memory ids = new uint256[](gemsQuantities.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            ids[i] = i;\\n        }\\n        _gems.batchBurnFrom(from, ids, gemsQuantities);\\n    }\\n\\n    function _mintAssets(\\n        address from,\\n        uint40 packId,\\n        bytes32 metadataHash,\\n        AssetData[] memory assets,\\n        uint256[] memory supplies,\\n        uint16[] memory maxGemsList,\\n        address to,\\n        bytes memory data\\n    ) internal returns (uint256[] memory tokenIds) {\\n        tokenIds = _asset.mintMultiple(from, packId, metadataHash, supplies, \\\"\\\", to, data);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            _catalystRegistry.setCatalyst(tokenIds[i], assets[i].catalystId, maxGemsList[i], assets[i].gemIds);\\n        }\\n    }\\n\\n    function _changeCatalyst(\\n        address from,\\n        uint256 assetId,\\n        uint256 catalystId,\\n        uint256[] memory gemIds,\\n        address to\\n    ) internal {\\n        require(assetId & IS_NFT != 0, \\\"INVALID_NOT_NFT\\\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\\n        _burnCatalyst(from, catalystId);\\n        (uint16 maxGems, , , , uint256 sandUpdateFee) = _getMintData(catalystId);\\n        require(gemIds.length <= maxGems, \\\"INVALID_GEMS_TOO_MANY\\\");\\n        _burnGems(from, gemIds);\\n        _chargeSand(from, sandUpdateFee);\\n\\n        _catalystRegistry.setCatalyst(assetId, catalystId, maxGems, gemIds);\\n\\n        _transfer(from, to, assetId);\\n    }\\n\\n    function _addGems(\\n        address from,\\n        uint256 assetId,\\n        uint256[] memory gemIds,\\n        address to\\n    ) internal {\\n        require(assetId & IS_NFT != 0, \\\"INVALID_NOT_NFT\\\"); // Asset (ERC1155ERC721.sol) ensure NFT will return true here and non-NFT will return false\\n        _catalystRegistry.addGems(assetId, gemIds);\\n        _chargeSand(from, gemIds.length.mul(_gemAdditionFee));\\n        _transfer(from, to, assetId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 assetId\\n    ) internal {\\n        if (from != to) {\\n            _asset.safeTransferFrom(from, to, assetId);\\n        }\\n    }\\n\\n    function _checkAuthorization(address from, address to) internal view {\\n        require(to != address(0), \\\"INVALID_TO_ZERO_ADDRESS\\\");\\n        require(from == msg.sender || _metaTransactionContracts[msg.sender], \\\"NOT_SENDER\\\");\\n    }\\n\\n    function _burnSingleGems(address from, uint256[] memory gemIds) internal {\\n        uint256[] memory amounts = new uint256[](gemIds.length);\\n        for (uint256 i = 0; i < gemIds.length; i++) {\\n            amounts[i] = 1;\\n        }\\n        _gems.batchBurnFrom(from, gemIds, amounts);\\n    }\\n\\n    function _burnCatalyst(address from, uint256 catalystId) internal {\\n        _catalysts.burnFrom(from, catalystId, 1);\\n    }\\n\\n    function _setFeeCollector(address newCollector) internal {\\n        _feeCollector = newCollector;\\n        emit FeeCollector(newCollector);\\n    }\\n\\n    function _setGemAdditionFee(uint256 newFee) internal {\\n        _gemAdditionFee = newFee;\\n        emit GemAdditionFee(newFee);\\n    }\\n\\n    // /////////////////// UTILITIES /////////////////////\\n    using SafeMathWithRequire for uint256;\\n\\n    // //////////////////////// DATA /////////////////////\\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\\n    address private constant BURN_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\\n\\n    ERC20Extended internal immutable _sand;\\n    AssetToken internal immutable _asset;\\n    GemToken internal immutable _gems;\\n    CatalystToken internal immutable _catalysts;\\n    CatalystRegistry internal immutable _catalystRegistry;\\n    address internal _feeCollector;\\n\\n    uint256 internal immutable _common_mint_data;\\n    uint256 internal immutable _rare_mint_data;\\n    uint256 internal immutable _epic_mint_data;\\n    uint256 internal immutable _legendary_mint_data;\\n\\n    uint256 internal _gemAdditionFee;\\n\\n    // /////////////////// CONSTRUCTOR ////////////////////\\n    constructor(\\n        CatalystRegistry catalystRegistry,\\n        ERC20Extended sand,\\n        AssetToken asset,\\n        GemToken gems,\\n        address metaTx,\\n        address admin,\\n        address feeCollector,\\n        uint256 gemAdditionFee,\\n        CatalystToken catalysts,\\n        uint256[4] memory bakedInMintdata\\n    ) public {\\n        _catalystRegistry = catalystRegistry;\\n        _sand = sand;\\n        _asset = asset;\\n        _gems = gems;\\n        _catalysts = catalysts;\\n        _admin = admin;\\n        _setGemAdditionFee(gemAdditionFee);\\n        _setFeeCollector(feeCollector);\\n        _setMetaTransactionProcessor(metaTx, true);\\n        _common_mint_data = bakedInMintdata[0];\\n        _rare_mint_data = bakedInMintdata[1];\\n        _epic_mint_data = bakedInMintdata[2];\\n        _legendary_mint_data = bakedInMintdata[3];\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xe8560d592c92f47783a5adb79e6ad76722061dbea3cabae7abd62874390444fc\"\r\n    },\r\n    \"src/CatalystRegistry.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Interfaces/AssetToken.sol\\\";\\nimport \\\"./contracts_common/src/BaseWithStorage/Admin.sol\\\";\\nimport \\\"./Catalyst/CatalystValue.sol\\\";\\n\\n\\ncontract CatalystRegistry is Admin, CatalystValue {\\n    event Minter(address indexed newMinter);\\n    event CatalystApplied(uint256 indexed assetId, uint256 indexed catalystId, uint256 seed, uint256[] gemIds, uint64 blockNumber);\\n    event GemsAdded(uint256 indexed assetId, uint256 seed, uint256[] gemIds, uint64 blockNumber);\\n\\n    function getCatalyst(uint256 assetId) external view returns (bool exists, uint256 catalystId) {\\n        CatalystStored memory catalyst = _catalysts[assetId];\\n        if (catalyst.set != 0) {\\n            return (true, catalyst.catalystId);\\n        }\\n        if (assetId & IS_NFT != 0) {\\n            catalyst = _catalysts[_getCollectionId(assetId)];\\n            return (catalyst.set != 0, catalyst.catalystId);\\n        }\\n        return (false, 0);\\n    }\\n\\n    function setCatalyst(\\n        uint256 assetId,\\n        uint256 catalystId,\\n        uint256 maxGems,\\n        uint256[] calldata gemIds\\n    ) external {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINTER\\\");\\n        require(gemIds.length <= maxGems, \\\"INVALID_GEMS_TOO_MANY\\\");\\n        uint256 emptySockets = maxGems - gemIds.length;\\n        _catalysts[assetId] = CatalystStored(uint64(emptySockets), uint64(catalystId), 1);\\n        uint64 blockNumber = _getBlockNumber();\\n        emit CatalystApplied(assetId, catalystId, assetId, gemIds, blockNumber);\\n    }\\n\\n    function addGems(uint256 assetId, uint256[] calldata gemIds) external {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINTER\\\");\\n        require(assetId & IS_NFT != 0, \\\"INVALID_NOT_NFT\\\");\\n        require(gemIds.length != 0, \\\"INVALID_GEMS_0\\\");\\n        (uint256 emptySockets, uint256 seed) = _getSocketData(assetId);\\n        require(emptySockets >= gemIds.length, \\\"INVALID_GEMS_TOO_MANY\\\");\\n        emptySockets -= gemIds.length;\\n        _catalysts[assetId].emptySockets = uint64(emptySockets);\\n        uint64 blockNumber = _getBlockNumber();\\n        emit GemsAdded(assetId, seed, gemIds, blockNumber);\\n    }\\n\\n    /// @dev Set the Minter that will be the only address able to create Estate\\n    /// @param minter address of the minter\\n    function setMinter(address minter) external {\\n        require(msg.sender == _admin, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        require(minter != _minter, \\\"INVALID_MINTER_SAME_ALREADY_SET\\\");\\n        _minter = minter;\\n        emit Minter(minter);\\n    }\\n\\n    /// @dev return the current minter\\n    function getMinter() external view returns (address) {\\n        return _minter;\\n    }\\n\\n    function getValues(\\n        uint256 catalystId,\\n        uint256 seed,\\n        GemEvent[] calldata events,\\n        uint32 totalNumberOfGemTypes\\n    ) external override view returns (uint32[] memory values) {\\n        return _catalystValue.getValues(catalystId, seed, events, totalNumberOfGemTypes);\\n    }\\n\\n    // ///////// INTERNAL ////////////\\n\\n    uint256 private constant IS_NFT = 0x0000000000000000000000000000000000000000800000000000000000000000;\\n    uint256 private constant NOT_IS_NFT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 private constant NOT_NFT_INDEX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF800000007FFFFFFFFFFFFFFF;\\n\\n    function _getSocketData(uint256 assetId) internal view returns (uint256 emptySockets, uint256 seed) {\\n        seed = assetId;\\n        CatalystStored memory catalyst = _catalysts[assetId];\\n        if (catalyst.set != 0) {\\n            // the gems are added to an asset who already get a specific catalyst.\\n            // the seed is its id\\n            return (catalyst.emptySockets, seed);\\n        }\\n        // else the asset is only adding gems while keeping the same seed (that of the original assetId)\\n        seed = _getCollectionId(assetId);\\n        catalyst = _catalysts[seed];\\n        return (catalyst.emptySockets, seed);\\n    }\\n\\n    function _getBlockNumber() internal view returns (uint64 blockNumber) {\\n        blockNumber = uint64(block.number + 1);\\n    }\\n\\n    function _getCollectionId(uint256 assetId) internal pure returns (uint256) {\\n        return assetId & NOT_NFT_INDEX & NOT_IS_NFT; // compute the same as Asset to get collectionId\\n    }\\n\\n    // CONSTRUCTOR ////\\n    constructor(CatalystValue catalystValue, address admin) public {\\n        _admin = admin;\\n        _catalystValue = catalystValue;\\n    }\\n\\n    /// DATA ////////\\n\\n    struct CatalystStored {\\n        uint64 emptySockets;\\n        uint64 catalystId;\\n        uint64 set;\\n    }\\n    address internal _minter;\\n    CatalystValue internal immutable _catalystValue;\\n    mapping(uint256 => CatalystStored) internal _catalysts;\\n}\\n\",\r\n      \"keccak256\": \"0xea6bf49ca881efa6a81a24f02f5754e03fc4f1e2821866d05bd27b0fa7b6749f\"\r\n    },\r\n    \"src/Interfaces/AssetToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\n\\n\\ninterface AssetToken {\\n    function mint(\\n        address creator,\\n        uint40 packId,\\n        bytes32 hash,\\n        uint256 supply,\\n        uint8 rarity,\\n        address owner,\\n        bytes calldata data\\n    ) external returns (uint256 id);\\n\\n    function mintMultiple(\\n        address creator,\\n        uint40 packId,\\n        bytes32 hash,\\n        uint256[] calldata supplies,\\n        bytes calldata rarityPack,\\n        address owner,\\n        bytes calldata data\\n    ) external returns (uint256[] memory ids);\\n\\n    // fails on non-NFT or nft who do not have collection (was a mistake)\\n    function collectionOf(uint256 id) external view returns (uint256);\\n\\n    // return true for Non-NFT ERC1155 tokens which exists\\n    function isCollection(uint256 id) external view returns (bool);\\n\\n    function collectionIndexOf(uint256 id) external view returns (uint256);\\n\\n    function extractERC721From(\\n        address sender,\\n        uint256 id,\\n        address to\\n    ) external returns (uint256 newId);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external;\\n}\\n\",\r\n      \"keccak256\": \"0x23a2eb8029ccf2a04ac6702e78bed1857e373cdeab30972efa0fe54a7b327fc7\"\r\n    },\r\n    \"src/Interfaces/ERC20Extended.sol\": {\r\n      \"content\": \"pragma solidity 0.6.5;\\n\\nimport \\\"../contracts_common/src/Interfaces/ERC20.sol\\\";\\n\\n\\ninterface ERC20Extended is ERC20 {\\n    function burnFor(address from, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n}\\n\",\r\n      \"keccak256\": \"0x60d1b8cb3676a35031ab3e3508e13590afdb371eb16e3628168148a565ecb3db\"\r\n    },\r\n    \"src/contracts_common/src/BaseWithStorage/Admin.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ncontract Admin {\\n    address internal _admin;\\n\\n    /// @dev emitted when the contract administrator is changed.\\n    /// @param oldAdmin address of the previous administrator.\\n    /// @param newAdmin address of the new administrator.\\n    event AdminChanged(address oldAdmin, address newAdmin);\\n\\n    /// @dev gives the current administrator of this contract.\\n    /// @return the current administrator of this contract.\\n    function getAdmin() external view returns (address) {\\n        return _admin;\\n    }\\n\\n    /// @dev change the administrator to be `newAdmin`.\\n    /// @param newAdmin address of the new administrator.\\n    function changeAdmin(address newAdmin) external {\\n        require(msg.sender == _admin, \\\"only admin can change admin\\\");\\n        emit AdminChanged(_admin, newAdmin);\\n        _admin = newAdmin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _admin, \\\"only admin allowed\\\");\\n        _;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xe5606264fdcdb48191f172743be4fac889f183ce97e907dba4cc5b3fe41b7f9a\"\r\n    },\r\n    \"src/contracts_common/src/BaseWithStorage/MetaTransactionReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./Admin.sol\\\";\\n\\n\\ncontract MetaTransactionReceiver is Admin {\\n    mapping(address => bool) internal _metaTransactionContracts;\\n\\n    /// @dev emiited when a meta transaction processor is enabled/disabled\\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\\n\\n    /// @dev Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\\n        require(msg.sender == _admin, \\\"only admin can setup metaTransactionProcessors\\\");\\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\\n    }\\n\\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\\n    }\\n\\n    /// @dev check whether address `who` is given meta-transaction execution rights.\\n    /// @param who The address to query.\\n    /// @return whether the address has meta-transaction execution rights.\\n    function isMetaTransactionProcessor(address who) external view returns (bool) {\\n        return _metaTransactionContracts[who];\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x3103cbc4f6bf91e2866014622a693c9562f8341b22f1bd2891210b4d4cec468f\"\r\n    },\r\n    \"src/contracts_common/src/BaseWithStorage/SuperOperators.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./Admin.sol\\\";\\n\\n\\ncontract SuperOperators is Admin {\\n    mapping(address => bool) internal _superOperators;\\n\\n    event SuperOperator(address superOperator, bool enabled);\\n\\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\\n    /// @param superOperator address that will be given/removed superOperator right.\\n    /// @param enabled set whether the superOperator is enabled or disabled.\\n    function setSuperOperator(address superOperator, bool enabled) external {\\n        require(msg.sender == _admin, \\\"only admin is allowed to add super operators\\\");\\n        _superOperators[superOperator] = enabled;\\n        emit SuperOperator(superOperator, enabled);\\n    }\\n\\n    /// @notice check whether address `who` is given superOperator rights.\\n    /// @param who The address to query.\\n    /// @return whether the address has superOperator rights.\\n    function isSuperOperator(address who) public view returns (bool) {\\n        return _superOperators[who];\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x226c0f78303ffa5d40f3517fbaff34775519e499ab1365bfc4997a86707ff2af\"\r\n    },\r\n    \"src/contracts_common/src/Interfaces/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\n/// @dev see https://eips.ethereum.org/EIPS/eip-20\\ninterface ERC20 {\\n    /// @notice emitted when tokens are transfered from one address to another.\\n    /// @param from address from which the token are transfered from (zero means tokens are minted).\\n    /// @param to destination address which the token are transfered to (zero means tokens are burnt).\\n    /// @param value amount of tokens transferred.\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice emitted when owner grant transfer rights to another address\\n    /// @param owner address allowing its token to be transferred.\\n    /// @param spender address allowed to spend on behalf of `owner`\\n    /// @param value amount of tokens allowed.\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice return the current total amount of tokens owned by all holders.\\n    /// @return supply total number of tokens held.\\n    function totalSupply() external view returns (uint256 supply);\\n\\n    /// @notice return the number of tokens held by a particular address.\\n    /// @param who address being queried.\\n    /// @return balance number of token held by that address.\\n    function balanceOf(address who) external view returns (uint256 balance);\\n\\n    /// @notice transfer tokens to a specific address.\\n    /// @param to destination address receiving the tokens.\\n    /// @param value number of tokens to transfer.\\n    /// @return success whether the transfer succeeded.\\n    function transfer(address to, uint256 value) external returns (bool success);\\n\\n    /// @notice transfer tokens from one address to another.\\n    /// @param from address tokens will be sent from.\\n    /// @param to destination address receiving the tokens.\\n    /// @param value number of tokens to transfer.\\n    /// @return success whether the transfer succeeded.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool success);\\n\\n    /// @notice approve an address to spend on your behalf.\\n    /// @param spender address entitled to transfer on your behalf.\\n    /// @param value amount allowed to be transfered.\\n    /// @param success whether the approval succeeded.\\n    function approve(address spender, uint256 value) external returns (bool success);\\n\\n    /// @notice return the current allowance for a particular owner/spender pair.\\n    /// @param owner address allowing spender.\\n    /// @param spender address allowed to spend.\\n    /// @return amount number of tokens `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) external view returns (uint256 amount);\\n}\\n\",\r\n      \"keccak256\": \"0x263a2705ead1d04cec64624ff8a8aa7cc108fb97e3a48516de33dbe290a7122e\"\r\n    },\r\n    \"src/contracts_common/src/Libraries/AddressUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nlibrary AddressUtils {\\n    function toPayable(address _address) internal pure returns (address payable _payable) {\\n        return address(uint160(_address));\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        // for accounts without code, i.e. `keccak256('')`:\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n        bytes32 codehash;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(addr)\\n        }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x52ed5ebe95a057d4f41b5f44711588816059c18c7f7e48aa0b6f4078812e80de\"\r\n    },\r\n    \"src/contracts_common/src/Libraries/BytesUtil.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nlibrary BytesUtil {\\n    function memcpy(\\n        uint256 dest,\\n        uint256 src,\\n        uint256 len\\n    ) internal pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    function pointerToBytes(uint256 src, uint256 len) internal pure returns (bytes memory) {\\n        bytes memory ret = new bytes(len);\\n        uint256 retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n\\n        memcpy(retptr, src, len);\\n        return ret;\\n    }\\n\\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\\n            mstore(0x40, add(m, 52))\\n            b := m\\n        }\\n    }\\n\\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 32), a)\\n            mstore(0x40, add(m, 64))\\n            b := m\\n        }\\n    }\\n\\n    function doFirstParamEqualsAddress(bytes memory data, address _address) internal pure returns (bool) {\\n        if (data.length < (36 + 32)) {\\n            return false;\\n        }\\n        uint256 value;\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value == uint256(_address);\\n    }\\n\\n    function doParamEqualsUInt256(\\n        bytes memory data,\\n        uint256 i,\\n        uint256 value\\n    ) internal pure returns (bool) {\\n        if (data.length < (36 + (i + 1) * 32)) {\\n            return false;\\n        }\\n        uint256 offset = 36 + i * 32;\\n        uint256 valuePresent;\\n        assembly {\\n            valuePresent := mload(add(data, offset))\\n        }\\n        return valuePresent == value;\\n    }\\n\\n    function overrideFirst32BytesWithAddress(bytes memory data, address _address) internal pure returns (bytes memory) {\\n        uint256 dest;\\n        assembly {\\n            dest := add(data, 48)\\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\\n\\n        bytes memory addressBytes = addressToBytes(_address);\\n        uint256 src;\\n        assembly {\\n            src := add(addressBytes, 32)\\n        }\\n\\n        memcpy(dest, src, 20);\\n        return data;\\n    }\\n\\n    function overrideFirstTwo32BytesWithAddressAndInt(\\n        bytes memory data,\\n        address _address,\\n        uint256 _value\\n    ) internal pure returns (bytes memory) {\\n        uint256 dest;\\n        uint256 src;\\n\\n        assembly {\\n            dest := add(data, 48)\\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\\n        bytes memory bbytes = addressToBytes(_address);\\n        assembly {\\n            src := add(bbytes, 32)\\n        }\\n        memcpy(dest, src, 20);\\n\\n        assembly {\\n            dest := add(data, 68)\\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\\n        bbytes = uint256ToBytes(_value);\\n        assembly {\\n            src := add(bbytes, 32)\\n        }\\n        memcpy(dest, src, 32);\\n\\n        return data;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xe6deec26a5bb00520a8025fb2b7b0155e3cad78349934bbd24e8d524c54114db\"\r\n    },\r\n    \"src/contracts_common/src/Libraries/ObjectLib32.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./SafeMathWithRequire.sol\\\";\\n\\n\\nlibrary ObjectLib32 {\\n    using SafeMathWithRequire for uint256;\\n    enum Operations {ADD, SUB, REPLACE}\\n    // Constants regarding bin or chunk sizes for balance packing\\n    uint256 constant TYPES_BITS_SIZE = 32; // Max size of each object\\n    uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\\n\\n    //\\n    // Objects and Tokens Functions\\n    //\\n\\n    /**\\n     * @dev Return the bin number and index within that bin where ID is\\n     * @param tokenId Object type\\n     * @return bin Bin number\\n     * @return index ID's index within that bin\\n     */\\n    function getTokenBinIndex(uint256 tokenId) internal pure returns (uint256 bin, uint256 index) {\\n        bin = (tokenId * TYPES_BITS_SIZE) / 256;\\n        index = tokenId % TYPES_PER_UINT256;\\n        return (bin, index);\\n    }\\n\\n    /**\\n     * @dev update the balance of a type provided in binBalances\\n     * @param binBalances Uint256 containing the balances of objects\\n     * @param index Index of the object in the provided bin\\n     * @param amount Value to update the type balance\\n     * @param operation Which operation to conduct :\\n     *     Operations.REPLACE : Replace type balance with amount\\n     *     Operations.ADD     : ADD amount to type balance\\n     *     Operations.SUB     : Substract amount from type balance\\n     */\\n    function updateTokenBalance(\\n        uint256 binBalances,\\n        uint256 index,\\n        uint256 amount,\\n        Operations operation\\n    ) internal pure returns (uint256 newBinBalance) {\\n        uint256 objectBalance = 0;\\n        if (operation == Operations.ADD) {\\n            objectBalance = getValueInBin(binBalances, index);\\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.add(amount));\\n        } else if (operation == Operations.SUB) {\\n            objectBalance = getValueInBin(binBalances, index);\\n            require(objectBalance >= amount, \\\"can't substract more than there is\\\");\\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.sub(amount));\\n        } else if (operation == Operations.REPLACE) {\\n            newBinBalance = writeValueInBin(binBalances, index, amount);\\n        } else {\\n            revert(\\\"Invalid operation\\\"); // Bad operation\\n        }\\n\\n        return newBinBalance;\\n    }\\n\\n    /*\\n     * @dev return value in binValue at position index\\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\\n     * @param index index at which to retrieve value\\n     * @return Value at given index in bin\\n     */\\n    function getValueInBin(uint256 binValue, uint256 index) internal pure returns (uint256) {\\n        // Mask to retrieve data for a given binData\\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\\n\\n        // Shift amount\\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (index + 1);\\n        return (binValue >> rightShift) & mask;\\n    }\\n\\n    /**\\n     * @dev return the updated binValue after writing amount at index\\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\\n     * @param index Index at which to retrieve value\\n     * @param amount Value to store at index in bin\\n     * @return Value at given index in bin\\n     */\\n    function writeValueInBin(\\n        uint256 binValue,\\n        uint256 index,\\n        uint256 amount\\n    ) internal pure returns (uint256) {\\n        require(amount < 2**TYPES_BITS_SIZE, \\\"Amount to write in bin is too large\\\");\\n\\n        // Mask to retrieve data for a given binData\\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\\n\\n        // Shift amount\\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (index + 1);\\n        return (binValue & ~(mask << leftShift)) | (amount << leftShift);\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xc2b73b8a4e836615ee9cb570406c532233a293024dad944ddb87f8957fce8b25\"\r\n    },\r\n    \"src/contracts_common/src/Libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two numbers, throws on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two numbers, truncating the quotient.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Adds two numbers, throws on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xdd13b563f215fd558bab94e03eb5a96e0cb30e7e156198bf448514876d1fa1bd\"\r\n    },\r\n    \"src/contracts_common/src/Libraries/SafeMathWithRequire.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert\\n */\\nlibrary SafeMathWithRequire {\\n    /**\\n     * @dev Multiplies two numbers, throws on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        c = a * b;\\n        require(c / a == b, \\\"overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two numbers, truncating the quotient.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"divbyzero\\\");\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"undeflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Adds two numbers, throws on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        require(c >= a, \\\"overflow\\\");\\n        return c;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x3ed5e25131dfcd07b3b11cb45b33dc24d0721acc0a034c85c2f17914fcea2dcd\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract CatalystRegistry\",\"name\":\"catalystRegistry\",\"type\":\"address\"},{\"internalType\":\"contract ERC20Extended\",\"name\":\"sand\",\"type\":\"address\"},{\"internalType\":\"contract AssetToken\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"contract GemToken\",\"name\":\"gems\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"metaTx\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gemAdditionFee\",\"type\":\"uint256\"},{\"internalType\":\"contract CatalystToken\",\"name\":\"catalysts\",\"type\":\"address\"},{\"internalType\":\"uint256[4]\",\"name\":\"bakedInMintdata\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCollector\",\"type\":\"address\"}],\"name\":\"FeeCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"GemAdditionFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"metaTransactionProcessor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"MetaTransactionProcessor\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"addGems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"catalystId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"changeCatalyst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"extractAndAddGems\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"catalystId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"extractAndChangeCatalyst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isMetaTransactionProcessor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"packId\",\"type\":\"uint40\"},{\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"catalystId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"packId\",\"type\":\"uint40\"},{\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"gemsQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"catalystsQuantities\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"gemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"catalystId\",\"type\":\"uint256\"}],\"internalType\":\"struct CatalystMinter.AssetData[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintMultiple\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setGemAdditionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metaTransactionProcessor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setMetaTransactionProcessor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CatalystMinter","CompilerVersion":"v0.6.5+commit.f956cc89","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000efa52f2f24a82fa27faae3c1ec3cca52806d1aa70000000000000000000000003845badade8e6dff049820680d1f14bd3903a5d0000000000000000000000000067a1eb5e383ed24b66d72aaf80d8d7db3d299a80000000000000000000000008ff2611da386de427fc96a8073963619c5851ba50000000000000000000000003845badade8e6dff049820680d1f14bd3903a5d0000000000000000000000000eaa0993e1d21c2103e4f172a20d29371fbaf6d0600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000002fc246149b4b8d7bcef6188a10af1791380227f100010fa04e200000000de0b6b3a7640000000000000000000de0b6b3a7640000000205dc0fa00000003782dace9d900000000000000000003782dace9d900000000300c805dc0000008ac7230489e80000000000000000008ac7230489e800000004000100c800000ad78ebc5ac62000000000000000000ad78ebc5ac6200000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}