{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n██╗     ███████╗██╗  ██╗                         \r\n██║     ██╔════╝╚██╗██╔╝                         \r\n██║     █████╗   ╚███╔╝                          \r\n██║     ██╔══╝   ██╔██╗                          \r\n███████╗███████╗██╔╝ ██╗                         \r\n╚══════╝╚══════╝╚═╝  ╚═╝                         \r\n██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗ \r\n██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗\r\n██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝\r\n██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗\r\n███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║\r\n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\r\nDEAR MSG.SENDER(S):\r\n\r\n/ LXL is a project in beta.\r\n// Please audit and use at your own risk.\r\n/// Entry into LXL shall not create an attorney/client relationship.\r\n//// Likewise, LXL should not be construed as legal advice or replacement for professional counsel.\r\n///// STEAL THIS C0D3SL4W \r\n\r\n~presented by Open, ESQ || LexDAO LLC\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract Context { // describes current contract execution context / openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath { // wrappers over solidity arithmetic operations with added overflow checks\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Address { // helper function for address type / openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\ninterface IERC20 { // brief interface for erc20 token txs\r\n    function balanceOf(address who) external view returns (uint256);\r\n    \r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\nlibrary SafeERC20 { // wrappers around erc20 token txs that throw on failure (when the token contract returns false) / openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n   function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWETH { // brief interface for ether wrapping contract \r\n    function deposit() payable external;\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n}\r\n\r\ncontract LexLocker is Context { // digital deal deposits w/ embedded arbitration via lexDAO (lexdao.org)\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    /** ADR Wrapper **/\r\n    address public judgeAccessToken;\r\n    address public judgmentRewardToken;\r\n    address payable public lexDAO;\r\n    address public wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // wrapping contract for raw payable ether\r\n    uint256 public judgeAccessBalance;\r\n    uint256 public judgmentReward;\r\n\r\n    /** <$> LXL <$> **/\r\n    address private locker = address(this);\r\n    uint256 public lxl; // index for registered lexlocker\r\n    mapping(uint256 => Deposit) public deposit; \r\n\r\n    struct Deposit {  \r\n        address client; \r\n        address provider;\r\n        address token;\r\n        uint8 locked;\r\n        uint256 amount;\r\n        uint256 cap;\r\n        uint256 index;\r\n        uint256 released;\r\n        uint256 termination;\r\n        bytes32 details; \r\n    }\r\n    \t\r\n    event DepositToken(address indexed client, address indexed provider, uint256 indexed index);  \r\n    event Release(uint256 indexed index, uint256 indexed milestone); \r\n    event Withdraw(uint256 indexed index, uint256 indexed remainder);\r\n    event Lock(address indexed sender, uint256 indexed index, bytes32 indexed details);\r\n    event Resolve(address indexed resolver, uint256 indexed clientAward, uint256 indexed providerAward, uint256 index, bytes32 details); \r\n    event PayLexDAO(address indexed sender, uint256 indexed payment, bytes32 indexed details);\r\n    \r\n    constructor(\r\n        address _judgeAccessToken, \r\n        address _judgmentRewardToken, \r\n        address payable _lexDAO, \r\n        uint256 _judgeAccessBalance, \r\n        uint256 _judgmentReward) public { \r\n        judgeAccessToken = _judgeAccessToken;\r\n        judgmentRewardToken = _judgmentRewardToken;\r\n        lexDAO = _lexDAO;\r\n        judgeAccessBalance = _judgeAccessBalance;\r\n        judgmentReward = _judgmentReward;\r\n    } \r\n    \r\n    /***************\r\n    LOCKER FUNCTIONS\r\n    ***************/\r\n    function depositToken( // register lexlocker and deposit token \r\n        address provider,\r\n        address token,\r\n        uint256 amount, \r\n        uint256 cap,\r\n        uint256 termination,\r\n        bytes32 details) payable external {\r\n        require(amount <= cap, \"amount exeeds cap\"); \r\n        \r\n        if (token == wETH && msg.value > 0) {\r\n            require(msg.value == cap, \"insufficient ETH\");\r\n            IWETH(wETH).deposit();\r\n            (bool success, ) = wETH.call.value(msg.value)(\"\");\r\n            require(success, \"transfer failed\");\r\n            IWETH(wETH).transfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), cap);\r\n        }\r\n\r\n        uint256 index = lxl+1; // add to registered index\r\n\t    lxl += lxl;\r\n                \r\n            deposit[index] = Deposit( \r\n                _msgSender(), \r\n                provider,\r\n                token,\r\n                0,\r\n                amount,\r\n                cap,\r\n                index,\r\n                0,\r\n                termination,\r\n                details);\r\n \r\n        emit DepositToken(_msgSender(), provider, index); \r\n    }\r\n\r\n    function release(uint256 index) external { // client transfers deposit amount to provider\r\n    \tDeposit storage depos = deposit[index];\r\n\t    \r\n\t    require(depos.locked == 0, \"deposit locked\"); \r\n    \trequire(_msgSender() == depos.client, \"not client\"); \r\n    \trequire(depos.cap >= depos.amount.add(depos.released), \"cap exceeded\");\r\n        \r\n        uint256 milestone = depos.amount;  \r\n        \r\n        IERC20(depos.token).safeTransfer(depos.provider, milestone);\r\n        \r\n        depos.released = depos.released.add(milestone);\r\n        \r\n\t    emit Release(index, milestone); \r\n    }\r\n    \r\n    function withdraw(uint256 index) external { // withdraw deposit remainder to client if termination time passes\r\n    \tDeposit storage depos = deposit[index];\r\n        \r\n        require(depos.locked == 0, \"deposit locked\"); \r\n        require(depos.cap > depos.released, \"deposit released\");\r\n        require(now >= depos.termination, \"termination time pending\");\r\n        \r\n        uint256 remainder = depos.cap.sub(depos.released); \r\n        \r\n        IERC20(depos.token).safeTransfer(depos.client, remainder);\r\n        \r\n        depos.released = depos.released.add(remainder); \r\n        \r\n\t    emit Withdraw(index, remainder); \r\n    }\r\n    \r\n    /************\r\n    ADR FUNCTIONS\r\n    ************/\r\n    function lock(uint256 index, bytes32 details) external { // client or provider can lock deposit for lexDAO resolution during locker period\r\n        Deposit storage depos = deposit[index]; \r\n        \r\n        require(depos.cap > depos.released, \"deposit released\");\r\n        require(now <= depos.termination, \"termination time passed\"); \r\n        require(_msgSender() == depos.client || _msgSender() == depos.provider, \"not deposit party\"); \r\n        \r\n\t    depos.locked = 1; \r\n\t    \r\n\t    emit Lock(_msgSender(), index, details);\r\n    }\r\n    \r\n    function resolve(uint256 index, uint256 clientAward, uint256 providerAward, bytes32 details) external { // lexDAO judge resolves locked deposit remainder\r\n        Deposit storage depos = deposit[index];\r\n        \r\n        uint256 remainder = depos.cap.sub(depos.released); \r\n\t    uint256 resolutionFee = remainder.div(20); // calculates 5% lexDAO dispute resolution fee\r\n\t    \r\n\t    require(depos.locked == 1, \"deposit not locked\"); \r\n\t    require(depos.cap > depos.released, \"deposit released\");\r\n\t    require(_msgSender() != depos.client, \"cannot be deposit party\");\r\n\t    require(_msgSender() != depos.provider, \"cannot be deposit party\");\r\n\t    require(clientAward.add(providerAward) == remainder.sub(resolutionFee), \"resolution must match deposit\"); \r\n\t    require(IERC20(judgeAccessToken).balanceOf(_msgSender()) >= judgeAccessBalance, \"judgeAccessToken insufficient\");\r\n        \r\n        IERC20(depos.token).safeTransfer(depos.client, clientAward);\r\n        IERC20(depos.token).safeTransfer(depos.provider, providerAward);\r\n        IERC20(depos.token).safeTransfer(lexDAO, resolutionFee);\r\n\t    IERC20(judgmentRewardToken).safeTransfer(_msgSender(), judgmentReward);\r\n\t    \r\n\t    depos.released = depos.released.add(remainder); \r\n\t    \r\n\t    emit Resolve(_msgSender(), clientAward, providerAward, index, details);\r\n    }\r\n    \r\n    /*************\r\n    MGMT FUNCTIONS\r\n    *************/\r\n    modifier onlyLexDAO() {\r\n        require(_msgSender() == lexDAO, \"caller not lexDAO\");\r\n        _;\r\n    }\r\n    \r\n    function payLexDAO(bytes32 details) payable external { // attach ether (Ξ) with details to lexDAO\r\n        (bool success, ) = lexDAO.call.value(msg.value)(\"\");\r\n        require(success, \"transfer failed\");\r\n        emit PayLexDAO(_msgSender(), msg.value, details);\r\n    }\r\n\r\n    function updateJudgeAccessToken(address _judgeAccessToken) external onlyLexDAO { \r\n        judgeAccessToken = _judgeAccessToken; \r\n    }\r\n    \r\n    function updateJudgeAccessBalance(uint256 _judgeAccessBalance) external onlyLexDAO {\r\n        judgeAccessBalance = _judgeAccessBalance;\r\n    }\r\n    \r\n    function updateJudgmentRewardToken(address _judgmentRewardToken) external onlyLexDAO { \r\n        judgmentRewardToken = _judgmentRewardToken;\r\n    }\r\n    \r\n    function updateJudgmentReward(uint256 _judgmentReward) external onlyLexDAO {\r\n        judgmentReward = _judgmentReward;\r\n    }\r\n\r\n    function updateLexDAO(address payable _lexDAO) external onlyLexDAO {\r\n        lexDAO = _lexDAO;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_judgeAccessToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_judgmentRewardToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_lexDAO\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_judgeAccessBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_judgmentReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DepositToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"PayLexDAO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"milestone\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"providerAward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"Resolve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"remainder\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"locked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgeAccessBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgeAccessToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgmentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgmentRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lexDAO\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lxl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"payLexDAO\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providerAward\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"resolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_judgeAccessBalance\",\"type\":\"uint256\"}],\"name\":\"updateJudgeAccessBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_judgeAccessToken\",\"type\":\"address\"}],\"name\":\"updateJudgeAccessToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_judgmentReward\",\"type\":\"uint256\"}],\"name\":\"updateJudgmentReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_judgmentRewardToken\",\"type\":\"address\"}],\"name\":\"updateJudgmentRewardToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_lexDAO\",\"type\":\"address\"}],\"name\":\"updateLexDAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LexLocker","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b4659d8907cdd36e36d0037f62ef8be696e4ce16000000000000000000000000b4659d8907cdd36e36d0037f62ef8be696e4ce160000000000000000000000001c0aa8ccd568d90d61659f060d1bfb1e6f855a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3693008eec6c06e88e30f9f5053d7f4fe72e8748d295773d1a92ee6b645bbf11"}]}