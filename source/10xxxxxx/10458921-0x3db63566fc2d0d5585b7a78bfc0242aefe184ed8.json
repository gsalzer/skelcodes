{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.14;\r\n\r\n\r\ncontract ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function decimals() public view returns(uint);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n}\r\n\r\ncontract CERC20 is ERC20 {\r\n    function mint(uint256) external returns (uint256);\r\n    function exchangeRateStored() public view returns (uint256);\r\n    function supplyRatePerBlock() external returns (uint256);\r\n    function redeem(uint) external returns (uint);\r\n    function redeemUnderlying(uint) external returns (uint);\r\n    function underlying() external view returns (address);\r\n    function isCToken() public view returns (bool);\r\n}\r\n\r\n\r\ncontract Kyber {\r\n    function getExpectedRate(address src, address dest, uint srcQty)\r\n        public view returns (uint expectedRate, uint slippageRate);\r\n\r\n    function trade(address src, uint srcAmount, address dst, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId)\r\n        public payable returns(uint);\r\n}\r\n\r\n\r\ncontract AdminRole {\r\n\r\n    mapping (address => bool) adminGroup;\r\n    address payable owner;\r\n\r\n    constructor () public {\r\n        adminGroup[msg.sender] = true;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyAdmin() {\r\n        require(\r\n            isAdmin(msg.sender),\r\n            \"The caller is not Admin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(\r\n            owner == msg.sender,\r\n            \"The caller is not Owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function addAdmin(address addr) external onlyAdmin {\r\n        adminGroup[addr] = true;\r\n    }\r\n    function delAdmin(address addr) external onlyAdmin {\r\n        adminGroup[addr] = false;\r\n    }\r\n\r\n    function isAdmin(address addr) public view returns(bool) {\r\n        return adminGroup[addr];\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\ncontract Withdrawable is AdminRole {\r\n    /*\r\n     * External Function to withdraw founds -> Gas or Tokens\r\n     */\r\n    function withdrawTo (address payable dst, uint founds, address token) external onlyAdmin {\r\n        if (token == address(0))\r\n            require (address(this).balance >= founds);\r\n        else {\r\n            ERC20 erc20 = ERC20(token);\r\n            require (erc20.balanceOf(address(this)) >= founds);\r\n        }\r\n        sendFounds(dst,founds, token);\r\n    }\r\n\r\n    /*\r\n     * Function to send founds -> Gas or Tokens\r\n     */\r\n    function sendFounds(address payable dst, uint amount, address token) internal returns(bool) {\r\n        ERC20 erc20;\r\n        if (token == address(0))\r\n            require(address(dst).send(amount), \"Impossible send founds\");\r\n        else {\r\n            erc20 = ERC20(token);\r\n            require(erc20.transfer(dst, amount), \"Impossible send founds\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract KyberProxy {\r\n    Kyber proxy;\r\n\r\n    constructor () public {\r\n        proxy = Kyber(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\r\n    }\r\n\r\n    function getSwapQuantity_internal(address src, address dst, uint256 srcQty) internal view returns(uint256) {\r\n        uint256 rate = getSwapRate_internal(src,dst,srcQty);\r\n        ERC20 srcToken = ERC20(src);\r\n        uint256 ret;\r\n\r\n        ret = (srcQty * (10**(18-srcToken.decimals())) * rate) / (10 ** 18);\r\n        return ret;\r\n    }\r\n\r\n    function getSwapRate_internal(address src, address dst, uint256 srcQty) internal view returns(uint256) {\r\n        uint256 rate;\r\n\r\n        (rate,) = proxy.getExpectedRate(src,dst,srcQty);\r\n        return rate;\r\n    }\r\n\r\n    function executeSwap_internal(address srcToken, uint256 srcQty, address dstToken, address dstAddress) internal returns(bool) {\r\n        uint256 rate;\r\n        uint256 bought;\r\n        ERC20 token = ERC20(srcToken);\r\n\r\n        rate = getSwapRate_internal(srcToken,dstToken,srcQty);\r\n\r\n        require(token.transferFrom(msg.sender, address(this), srcQty), \"Unable to transferFrom()\");\r\n\r\n        // Set the spender's token allowance to tokenQty\r\n        require(token.approve(address(proxy), srcQty), \"Unable to appove()\");\r\n\r\n        bought = proxy.trade(\r\n            srcToken,\r\n            srcQty,\r\n            dstToken,\r\n            dstAddress,\r\n            0x8000000000000000000000000000000000000000000000000000000000000000,\r\n            rate,\r\n            address(0)\r\n        );\r\n\r\n        require(bought != 0, \"Unable to exchange tokens\");\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract CompoundProxy is AdminRole {\r\n    mapping(address => bool) cTokens;\r\n\r\n\r\n    constructor() public {\r\n        cTokens[0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E] = true;\r\n        cTokens[0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643] = true;\r\n        cTokens[0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5] = true;\r\n        cTokens[0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1] = true;\r\n        cTokens[0xF5DCe57282A584D2746FaF1593d3121Fcac444dC] = true;\r\n        cTokens[0x39AA39c021dfbaE8faC545936693aC917d5E7563] = true;\r\n        cTokens[0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9] = true;\r\n        cTokens[0xC11b1268C1A384e55C48c2391d8d480264A3A7F4] = true;\r\n        cTokens[0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407] = true;\r\n    }\r\n\r\n    function addcToken(address _cToken) external onlyAdmin {\r\n        cTokens[_cToken] = true;\r\n    }\r\n\r\n    function delcToken(address _cToken) external onlyAdmin {\r\n        cTokens[_cToken] = false; \r\n    }\r\n\r\n    function isCToken(address _token) internal view returns(bool) {\r\n        return cTokens[_token];\r\n    }\r\n\r\n    function getUnderlying(address cToken) internal view returns(bool, address) {\r\n        CERC20 token = CERC20(cToken);\r\n\r\n        if (token.isCToken()) {\r\n            return (true, token.underlying());\r\n        }\r\n        return (false, address(0));\r\n    }\r\n\r\n    function supplyToCompound(address _erc20Contract, address _cErc20Contract, uint256 _numTokensToSupply) internal returns (uint) {\r\n        // Create a reference to the underlying asset contract, like DAI.\r\n        ERC20 underlying = ERC20(_erc20Contract);\r\n\r\n        // Create a reference to the corresponding cToken contract, like cDAI\r\n        CERC20 cToken = CERC20(_cErc20Contract);\r\n\r\n        // Approve transfer on the ERC20 contract\r\n        underlying.approve(_cErc20Contract, _numTokensToSupply);\r\n\r\n        // Mint cTokens\r\n        uint mintResult = cToken.mint(_numTokensToSupply);\r\n        return mintResult;\r\n    }\r\n\r\n    function redeemFromCompound(uint256 amount, bool redeemType, address _cErc20Contract ) internal returns (bool) {\r\n        // Create a reference to the corresponding cToken contract, like cDAI\r\n        CERC20 cToken = CERC20(_cErc20Contract);\r\n\r\n        // `amount` is scaled up by 1e18 to avoid decimals\r\n        uint256 redeemResult;\r\n\r\n        if (redeemType == true) {\r\n            // Retrieve your asset based on a cToken amount\r\n            redeemResult = cToken.redeem(amount);\r\n        } else {\r\n            // Retrieve your asset based on an amount of the asset\r\n            redeemResult = cToken.redeemUnderlying(amount);\r\n        }\r\n\r\n        require(redeemResult == 0, \"redeemResult error\");\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract cTokenKyberBridge is KyberProxy, CompoundProxy, Withdrawable {\r\n    string public name = \"cTokenKyberBridge\";\r\n\r\n\r\n    function getTokens(address srcToken, uint256 qty) internal returns (bool){\r\n        ERC20 token = ERC20(srcToken);\r\n\r\n        return token.transferFrom(msg.sender, address(this), qty);\r\n    }\r\n\r\n    function tokenBalance(address src) internal view returns(uint256) {\r\n        ERC20 token = ERC20(src);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function executeSwap(address src, address dst, uint256 srcQty) external {\r\n        ERC20 token;\r\n        bool ok;\r\n        address srcToken;\r\n        address dstToken;\r\n        uint256 srcQuantity;\r\n\r\n\r\n        require(getTokens(src,srcQty), \"Unable to transferFrom()\");\r\n\r\n        /**\r\n         * En este punto se verifica si el src es un cToken, en caso de que lo sea\r\n         * se solicita a compound un reedem de los cToken por el token correspondiente\r\n         */\r\n        if (isCToken(src)) {\r\n            (ok, srcToken) = getUnderlying(src);\r\n            require(ok == true, \"Maybe the src token is not cToken\");\r\n            require(redeemFromCompound(srcQty, true, src), \"Unable to reedem from compound\");\r\n            srcQuantity = tokenBalance(srcToken);\r\n        } else {\r\n            srcToken = src;\r\n            srcQuantity = srcQty;\r\n        }\r\n\r\n        /** \r\n         * Se aprueba al contrato exchenge a tomar los tokens\r\n         */\r\n        token = ERC20(srcToken);\r\n        require(token.approve(address(proxy), srcQuantity), \"Unable to appove()\");\r\n\r\n\r\n        /** \r\n         * Se verifica si el destino es un compound, en caso de que lo sea, se pide el underlying\r\n         */\r\n        if (isCToken(dst)) {\r\n            (ok, dstToken) = getUnderlying(dst);\r\n            require(ok == true, \"Maybe the dst token is not cToken\");\r\n        } else {\r\n            dstToken = dst;\r\n        }\r\n\r\n        /**\r\n         * Ejecuta el swap\r\n         */\r\n        ok = executeSwap_internal(srcToken, srcQuantity, dstToken, address(this));\r\n        require(ok == true, \"Unable to execute swap\");\r\n\r\n        /**\r\n         * Si el swap funciona y el destino era un token de compound lo intercambia\r\n         */\r\n        if (isCToken(dst)) {\r\n            require(supplyToCompound(dstToken, dst, tokenBalance(dstToken)) == 0, \"Unable to supply to Compound\");\r\n        }\r\n\r\n        token = ERC20(dst);\r\n        require(token.transfer(msg.sender,tokenBalance(dst)), \"Unable to transfer dst token\");\r\n    }\r\n\r\n\r\n    function getSwapQuantity(address src, address dst, uint256 srcQty) external view returns(uint256) {\r\n        address srcToken;\r\n        address dstToken;\r\n        uint256 srcQuantity;\r\n        uint256 dstQuantity;\r\n\r\n        if (isCToken(src)) {\r\n            // En este punto el souce es un cToken, hay que traer la direccion de su underlying\r\n            // y ademas calcular de acuerdo a su rate la cantidad a pasarle al proxy\r\n            srcToken = CERC20(src).underlying();\r\n            srcQuantity = (srcQty * CERC20(src).exchangeRateStored()) / 10**18; \r\n        } else {\r\n            srcToken = src;\r\n            srcQuantity = srcQty;\r\n        }\r\n\r\n        if (isCToken(dst)) {\r\n            // En este punto el destino es un cToken, hay que traer la direccion de su underlying\r\n            dstToken = CERC20(dst).underlying();\r\n        } else {\r\n            dstToken = dst;\r\n        }\r\n\r\n        if (srcToken == dstToken) {\r\n            // Un token es el underlying del otro \r\n            if (isCToken(dst)) {\r\n                return (srcQuantity * 10**(36-ERC20(dst).decimals())) / CERC20(dst).exchangeRateStored();\r\n            } else {\r\n                return (srcQuantity * 10**(18-ERC20(dst).decimals()));\r\n            }\r\n        }\r\n\r\n        dstQuantity = getSwapQuantity_internal(srcToken, dstToken, srcQuantity);\r\n\r\n        if (isCToken(dst)) {\r\n            dstQuantity = dstQuantity * 10**(18 + ERC20(dstToken).decimals() - ERC20(dst).decimals()) / CERC20(dst).exchangeRateStored();\r\n        }\r\n        return dstQuantity;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"addcToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"delAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"}],\"name\":\"delcToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"executeSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getSwapQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"founds\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"cTokenKyberBridge","CompilerVersion":"v0.5.14+commit.01f1aaa4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://cdd7be5aed6a89344660508dd3430f29b040fb9a596b99843e7ae41b4dd77fe0"}]}