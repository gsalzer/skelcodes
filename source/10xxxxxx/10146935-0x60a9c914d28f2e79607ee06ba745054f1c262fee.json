{"status":"1","message":"OK","result":[{"SourceCode":"{\"db.no.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\r\\nimport \\\"./safeMath.sol\\\";\\r\\ncontract Db {\\r\\n    using SafeMath for uint256;\\r\\n    address own = msg.sender;\\r\\n    address coreAddress;\\r\\n    address toolAddress;\\r\\n    address tokenAddress;\\r\\n    Tool tool;\\r\\n    uint day = 86400;\\r\\n    modifier isCore(){\\r\\n        require(msg.sender == coreAddress);\\r\\n        _;\\r\\n    }\\r\\n    modifier isOwn(){\\r\\n        require(msg.sender == own);\\r\\n        _;\\r\\n    }\\r\\n    modifier isToken(){\\r\\n        require(msg.sender == tokenAddress);\\r\\n        _;\\r\\n    }\\r\\n    function init(address _coreAddress,address _toolAddress) isOwn public{\\r\\n        coreAddress = _coreAddress;\\r\\n        toolAddress = _toolAddress;\\r\\n        tool = Tool(_toolAddress);\\r\\n    }\\r\\n    function getNow() public view returns(uint){\\r\\n        return now;\\r\\n    }\\r\\n    function setLuckPool(uint _luckNum,uint _luckType,uint _luckArea,uint _balance) isCore public{\\r\\n        luckPool[_luckNum][_luckType][_luckArea] = _balance;\\r\\n    }\\r\\n    function setLuckPool(uint _luckNum) isCore public{\\r\\n        luckNum = _luckNum;\\r\\n    }\\r\\n    function setLastTime(uint _time) isCore public{\\r\\n        lastTime = _time;\\r\\n    }\\r\\n    function setSystemPlayerNum(uint _num) public isCore {\\r\\n        systemPlayerNum = _num;\\r\\n    }\\r\\n    function setPlayerLev(address _own,uint _lev) public isCore{\\r\\n        if(_lev \\u003e 0 \\u0026\\u0026 true == playerList[_own].isExist){\\r\\n            playerList[_own].lev = _lev;\\r\\n        }\\r\\n    }\\r\\n    function getPlayerInfo(address _own) public view returns(address _parent,bool _isExist,bool _isParent){\\r\\n        return (playerList[_own].parentAddress,playerList[_own].isExist,playerList[_own].isParent);\\r\\n    }\\r\\n    function _getProgenitorAddress(address _own) internal view returns (address[30] memory){\\r\\n        address[30] memory _progenitor;\\r\\n        Player memory _tempPlayer = playerList[_own];\\r\\n        for (uint i = 0; i \\u003c 30; i++) {\\r\\n            if (playerList[_tempPlayer.parentAddress].isExist == true) {\\r\\n                _progenitor[i] = _tempPlayer.parentAddress;\\r\\n                _tempPlayer = playerList[_tempPlayer.parentAddress];\\r\\n            }\\r\\n        }\\r\\n        return _progenitor;\\r\\n    }\\r\\n    function setMyTeam(address _own) internal{\\r\\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\\r\\n        for(uint i = 0;i\\u003c30;i++){\\r\\n            if(false == playerList[_progenitor[i]].isExist){\\r\\n                break;\\r\\n            }\\r\\n            if(i == 0){\\r\\n                playerList[_progenitor[i]].sonAddress.push(_own);\\r\\n            }\\r\\n            playerList[_progenitor[i]].teamAddress.push(_own);\\r\\n        }\\r\\n    }\\r\\n    function setPlayerParentAddress(address _own,address _parent) public isCore{\\r\\n        if(playerList[_own].isParent == false){\\r\\n            playerList[_own].isParent = true;\\r\\n            playerList[_own].isExist = true;\\r\\n            playerList[_own].parentAddress = _parent;\\r\\n            systemPlayerNum = systemPlayerNum.add(1);\\r\\n            setMyTeam(_own);\\r\\n        }\\r\\n    }\\r\\n    function getFreeWithdrawBalance(address _own) public view returns (uint){\\r\\n        require(playerList[_own].isExist == true);\\r\\n        uint _balance = playerList[_own].allIncome.sub(playerList[_own].withdrawAmount); \\r\\n        return _balance;\\r\\n    }\\r\\n    function setPlayerWithdraw(address _own) public isCore{\\r\\n        require(playerList[_own].isExist == true);\\r\\n        uint _balance = getFreeWithdrawBalance(_own);\\r\\n        if(_balance \\u003c= 0){\\r\\n            return;\\r\\n        }\\r\\n        playerList[_own].withdrawAmount = playerList[_own].withdrawAmount.add(_balance);\\r\\n        playerList[_own].lastWithdrawTime = getNow();\\r\\n    }\\r\\n    function _setMyTeamIncome(address _own,uint _balance) internal{\\r\\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\\r\\n        for(uint i = 0;i\\u003c30;i++){\\r\\n            if(false == playerList[_progenitor[i]].isExist){\\r\\n                break;\\r\\n            }\\r\\n            playerList[_progenitor[i]].teamRechargeAmount = playerList[_progenitor[i]].teamRechargeAmount.add(_balance);\\r\\n        }\\r\\n    }\\r\\n    function _setPlayerInvest(address _own,uint _balance) internal isCore{\\r\\n        require(playerList[_own].isExist == true);\\r\\n        playerList[_own].rechargeAmount = playerList[_own].rechargeAmount.add(_balance);\\r\\n        playerList[_own].teamRechargeAmount = playerList[_own].teamRechargeAmount.add(_balance);\\r\\n        _setMyTeamIncome(_own,_balance);\\r\\n        if(lastPool \\u003e= 9990000e6){\\r\\n            _setLastPoolOverflowReward(_balance);\\r\\n        }else{\\r\\n            lastPool = lastPool.add(_balance.mul(8).div(100));\\r\\n        }\\r\\n    }\\r\\n    function addInvestBurnNum(uint _num) public isCore{\\r\\n        investTokenUsdtNum[luckCodeNum] = investTokenUsdtNum[luckCodeNum].add(_num);\\r\\n    }\\r\\n    function getAreaPerformance(address _own) public view returns (uint _maxPerformance, uint _minPerformance){\\r\\n        uint _ownBalance = playerList[_own].rechargeAmount;\\r\\n        address[] memory _sonList = playerList[_own].sonAddress;\\r\\n        _maxPerformance = 0;\\r\\n        for (uint i = 0; i \\u003c _sonList.length; i++) {\\r\\n            if (playerList[_sonList[i]].teamRechargeAmount \\u003e _maxPerformance) {\\r\\n                _maxPerformance = playerList[_sonList[i]].teamRechargeAmount;\\r\\n            }\\r\\n        }\\r\\n        _minPerformance = playerList[_own].teamRechargeAmount.sub(_maxPerformance.add(_ownBalance));\\r\\n        return (_maxPerformance, _minPerformance);\\r\\n    }\\r\\n    function getAddressSomeInfo(address _own) public view returns(uint _teamCount,uint _sonCount,uint _investBalance,uint _lev,uint _incomeBalance,uint _withdrawBalance){\\r\\n        return (\\r\\n            playerList[_own].teamAddress.length,\\r\\n            playerList[_own].sonAddress.length,\\r\\n            playerList[_own].rechargeAmount,\\r\\n            playerList[_own].lev,\\r\\n            playerList[_own].allIncome,\\r\\n            playerList[_own].withdrawAmount\\r\\n            );\\r\\n    }\\r\\n    function addIncome(address _own,uint _type, uint _time ,uint _balance,address _fromAddress) public isCore{\\r\\n        if(_balance == 0){\\r\\n            return;\\r\\n        }\\r\\n        playerList[_own].allIncome = playerList[_own].allIncome.add(_balance);\\r\\n        incomeList[_own].push(Income({\\r\\n            incomeType : _type,\\r\\n            createTime : _time,\\r\\n            balance : _balance,\\r\\n            fromAddress : _fromAddress\\r\\n        }));\\r\\n    }\\r\\n    function addInvest(address _own,uint _balance) public isCore{\\r\\n        _setPlayerInvest(_own,_balance);\\r\\n        uint _ratio = tool._getRatio(_balance);\\r\\n        Invest memory _invest = Invest({\\r\\n            own : _own,\\r\\n            createTime : getNow(),\\r\\n            withdrawTime : getNow(),\\r\\n            balance : _balance,\\r\\n            ratio : _ratio,\\r\\n            profit : 0,\\r\\n            isFull : false\\r\\n        });\\r\\n        investList[_own].push(_invest);\\r\\n        systemInvest.push(_invest);\\r\\n    }\\r\\n    function addCodeToPlayer(address _own,uint _count) public isCore{\\r\\n        luckCodeBurnTokenNum[luckCodeNum] = luckCodeBurnTokenNum[luckCodeNum].add(_count);//增加消耗门票记录\\r\\n        for(uint i = 0; i \\u003c _count;i++){\\r\\n            luckCodeList[luckCodeNum].push(_own);\\r\\n        }\\r\\n    }\\r\\n    function _checkOpenLuckCodeLev() internal view returns (bool , bool){\\r\\n        uint _investBurnToken = investTokenUsdtNum[luckCodeNum];\\r\\n        uint _nowCodeNum = (luckCodeList[luckCodeNum].length).mul(1e6);\\r\\n        if(_investBurnToken \\u003e= _nowCodeNum.mul(2)){\\r\\n            return (true,true);\\r\\n        }else if(_investBurnToken \\u003e= _nowCodeNum){\\r\\n            return (false,true);\\r\\n        }else{\\r\\n            return (false,false);\\r\\n        }\\r\\n    }\\r\\n    function _giveUserLuckCodeReward(uint[25] memory _code,uint _length) internal{\\r\\n        for(uint i = 0;i \\u003c _length;i++){\\r\\n            address _tempAddress = luckCodeList[luckCodeNum][_code[i]];\\r\\n            luckCodeResList[luckCodeNum].push(_code[i]);\\r\\n            uint _tempBalance;\\r\\n            if(i \\u003e= 24){\\r\\n                _tempBalance = luckPool[luckCodeNum][1][1];\\r\\n                \\r\\n            }else if(i \\u003e= 18){\\r\\n                _tempBalance = luckPool[luckCodeNum][1][2].div(6);\\r\\n            }else{\\r\\n                _tempBalance = luckPool[luckCodeNum][1][3].div(18);\\r\\n            }\\r\\n            addIncome(_tempAddress,8,getNow(),_tempBalance,address(0x01));\\r\\n        }\\r\\n    }\\r\\n    function openLuckCodeReward() internal{\\r\\n        address[] memory _address = luckCodeList[luckCodeNum];\\r\\n        uint[25] memory _codeList = tool._crateLuckCodeList(_address.length);\\r\\n        uint[4] memory _poolBalance = luckPool[luckCodeNum][1];\\r\\n        uint _length;\\r\\n        (bool isLev1,bool isLev2) = _checkOpenLuckCodeLev();\\r\\n        if(true == isLev1){\\r\\n            _length = 25;\\r\\n        }else if(true == isLev2){\\r\\n            _length = 24;\\r\\n        }else{\\r\\n            _length = 18;\\r\\n        }\\r\\n        _giveUserLuckCodeReward(_codeList,_length);\\r\\n        luckCodeNum = luckCodeNum.add(1);\\r\\n        luckCodeList[luckCodeNum].push(address(0x00));\\r\\n        uint _frozenTempBalance;\\r\\n        if(true == isLev1){\\r\\n            return;\\r\\n        }else if(true == isLev2){\\r\\n            _frozenTempBalance = _poolBalance[1];\\r\\n        }else{\\r\\n            _frozenTempBalance = _poolBalance[1].add(_poolBalance[2]);\\r\\n        }\\r\\n        luckPool[luckCodeNum][1][0] = luckPool[luckCodeNum][1][1].add(_frozenTempBalance);\\r\\n        luckPool[luckCodeNum][1][1] = luckPool[luckCodeNum][1][1].add(_frozenTempBalance);\\r\\n    }\\r\\n    function openLuckInvestReward() internal{\\r\\n        Invest[21] memory _invest = _getLuckInvestList(true);\\r\\n        if(_invest[0].own == address(0x00) || _invest[0].balance == 0){\\r\\n            return;\\r\\n        }\\r\\n        uint _balance1 = luckPool[luckInvestNum][0][1];\\r\\n        uint _balance2 = luckPool[luckInvestNum][0][2].div(5);\\r\\n        uint _balance3 =luckPool[luckInvestNum][0][3].div(15);\\r\\n        for(uint i = 0; i \\u003c 21;i++){\\r\\n            if(_invest[i].balance == 0){\\r\\n                continue;\\r\\n            }\\r\\n            if(i == 0){\\r\\n                addIncome(_invest[i].own,8,getNow(),_balance1,address(0x00));\\r\\n            }else if(i \\u003c= 5){\\r\\n                addIncome(_invest[i].own,8,getNow(),_balance2,address(0x00));\\r\\n            }else{\\r\\n                addIncome(_invest[i].own,8,getNow(),_balance3,address(0x00));\\r\\n            }\\r\\n        }\\r\\n        lastLuckOpenTime = getNow();\\r\\n        luckInvestNum = luckInvestNum.add(1);\\r\\n    }\\r\\n    function setAssignment(uint _balance) public isCore{\\r\\n        uint _tempBalance = _balance.mul(5).div(100);\\r\\n        luckPool[luckCodeNum][0][0] = luckPool[luckCodeNum][0][0].add(_tempBalance); \\r\\n        luckPool[luckCodeNum][0][1] = luckPool[luckCodeNum][0][1].add(_tempBalance.mul(20).div(100)); \\r\\n        luckPool[luckCodeNum][0][2] = luckPool[luckCodeNum][0][2].add(_tempBalance.mul(30).div(100)); \\r\\n        luckPool[luckCodeNum][0][3] = luckPool[luckCodeNum][0][3].add(_tempBalance.mul(50).div(100)); \\r\\n        luckPool[luckCodeNum][1][0] = luckPool[luckCodeNum][1][0].add(_tempBalance); \\r\\n        luckPool[luckCodeNum][1][1] = luckPool[luckCodeNum][1][1].add(_tempBalance.mul(30).div(100)); \\r\\n        luckPool[luckCodeNum][1][2] = luckPool[luckCodeNum][1][2].add(_tempBalance.mul(30).div(100)); \\r\\n        luckPool[luckCodeNum][1][3] = luckPool[luckCodeNum][1][3].add(_tempBalance.mul(40).div(100)); \\r\\n    }\\r\\n    function getSurplusBalance(address _own) public view returns (uint, uint){\\r\\n        Invest[] memory _orderList = investList[_own];\\r\\n        uint _investCount = _orderList.length;\\r\\n        uint _surplusBanalce = 0;\\r\\n        uint _index = 0;\\r\\n        for (uint i = 0; i \\u003c _investCount; i++) {\\r\\n            if (_orderList[i].isFull == false) {\\r\\n                _surplusBanalce = ((_orderList[i].balance).mul(_orderList[i].ratio)).sub(_orderList[i].profit);\\r\\n                _index = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return (_index, _surplusBanalce);\\r\\n    }\\r\\n    function setIncomeBurn(address _own,uint _balance) internal returns (uint) {\\r\\n        uint _tempBalance = _balance;\\r\\n        (uint _index, uint _surplusAmount) = getSurplusBalance(_own);\\r\\n        if (_surplusAmount \\u003c= 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        if (_surplusAmount \\u003c _tempBalance) {\\r\\n            _tempBalance = _surplusAmount;\\r\\n            investList[_own][_index].isFull = true;\\r\\n            investList[_own][_index].profit = (investList[_own][_index].balance).mul(investList[_own][_index].ratio);\\r\\n        } else {\\r\\n            investList[_own][_index].profit = (investList[_own][_index].profit).add(_tempBalance);\\r\\n        }\\r\\n        return _tempBalance;\\r\\n    }\\r\\n    function _setParentReward(address _own,uint _balance) internal{\\r\\n        if(false == playerList[_own].isExist || false == playerList[_own].isParent || false == playerList[playerList[_own].parentAddress].isExist){\\r\\n            return;\\r\\n        }\\r\\n        uint _tempBalance = _balance.mul(10).div(100);\\r\\n        address _parent = playerList[_own].parentAddress;\\r\\n        _tempBalance = setIncomeBurn(_parent,_tempBalance);\\r\\n        addIncome(_parent,6,getNow(),_tempBalance,_own);\\r\\n    }\\r\\n    function _setSonsReward(address _own,uint _balance) internal{\\r\\n        if(false == playerList[_own].isExist){\\r\\n            return;\\r\\n        }\\r\\n        address[] memory _mySons = playerList[_own].sonAddress;\\r\\n        uint _sonNum = _mySons.length;\\r\\n        if(_sonNum \\u003c= 0){\\r\\n            return;\\r\\n        }\\r\\n        uint _giveBalance = _balance.mul(10).div(100).div(_sonNum);\\r\\n        for(uint i = 0;i \\u003c _mySons.length;i++){\\r\\n            uint _tempBalance = _giveBalance;\\r\\n            address _son = _mySons[i];\\r\\n            _tempBalance = setIncomeBurn(_son,_tempBalance);\\r\\n            addIncome(_son,7,getNow(),_tempBalance,_own);\\r\\n        }\\r\\n    }\\r\\n    function _setParentAndSonReward(address _own,uint _balance) internal{\\r\\n        _setParentReward(_own,_balance);\\r\\n        _setSonsReward(_own,_balance);\\r\\n    }\\r\\n    function giveShare(address _own, uint _balance) public isCore{\\r\\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\\r\\n        address[3] memory _parents;\\r\\n        _parents[0] = _progenitor[0];\\r\\n        _parents[1] = _progenitor[1];\\r\\n        _parents[2] = _progenitor[2];\\r\\n        uint[3] memory _ratio = [uint(9), 6, 3];\\r\\n        for (uint i = 0; i \\u003c 3; i++) {\\r\\n            if (playerList[_parents[i]].isExist) {\\r\\n                uint _tempBalance = _balance.mul(_ratio[i]).div(100);\\r\\n                _tempBalance = setIncomeBurn(_parents[i],_tempBalance);\\r\\n                addIncome(_parents[i],1,getNow(),_tempBalance,_own);\\r\\n                _setParentAndSonReward(_parents[i],_tempBalance);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _getSon(address _own) internal view returns (address[] memory){\\r\\n        address[] memory _sonList = playerList[_own].sonAddress;\\r\\n        return _sonList;\\r\\n    }\\r\\n    function _getTeam(address _own) internal view returns (address[] memory){\\r\\n        address[] memory _teamList = playerList[_own].teamAddress;\\r\\n        return _teamList;\\r\\n    }\\r\\n    function _getTeamLevNum(address _own, uint _lev) internal view returns (uint, uint) {\\r\\n        address[] memory _teamAddress = _getTeam(_own);\\r\\n        uint _count = 0;\\r\\n        uint _nowLevCount = 0;\\r\\n        for (uint i = 0; i \\u003c _teamAddress.length; i++) {\\r\\n            if (playerList[_teamAddress[i]].lev \\u003e= _lev) {\\r\\n                _count = _count.add(1);\\r\\n                if (playerList[_teamAddress[i]].lev == _lev) {\\r\\n                    _nowLevCount = _nowLevCount.add(1);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (playerList[_own].lev \\u003e= _lev) {\\r\\n            _count = _count.add(1);\\r\\n            if (playerList[_own].lev == _lev) {\\r\\n                _nowLevCount = _nowLevCount.add(1);\\r\\n            }\\r\\n        }\\r\\n        return (_count, _nowLevCount);\\r\\n    }\\r\\n    function getSystemTopLevUser() public view isCore returns (address[] memory) {\\r\\n        address[] memory _addressList = topLevUser;\\r\\n        return _addressList;\\r\\n    }\\r\\n    function _addAddressToSystem(address _own) internal {\\r\\n        address[] memory _addressList = getSystemTopLevUser();\\r\\n        bool _isExist = false;\\r\\n        for (uint i = 0; i \\u003c _addressList.length; i++) {\\r\\n            if (_addressList[i] == _own) {\\r\\n                _isExist = true;\\r\\n            }\\r\\n        }\\r\\n        if (false == _isExist) {\\r\\n            topLevUser.push(_own);\\r\\n        }\\r\\n    }\\r\\n    function _setLev1(address _own) internal {\\r\\n        uint _ownBalance = playerList[_own].rechargeAmount;\\r\\n        (uint _maxPerformance,uint _minPerformance) = getAreaPerformance(_own);\\r\\n        uint _nowLev = playerList[_own].lev;\\r\\n        if (_ownBalance \\u003e= 0 \\u0026\\u0026 _maxPerformance \\u003e= 30000e6 \\u0026\\u0026 _minPerformance \\u003e= 30000e6 \\u0026\\u0026 _nowLev \\u003c 1) {\\r\\n            playerList[_own].lev = 1;\\r\\n        }\\r\\n    }\\r\\n    function _setLev2(address _own, uint _setLevNum) internal {\\r\\n        require(_setLevNum \\u003e= 2, \\\"_setLevNum \\u003c 2\\\");\\r\\n        require(_setLevNum \\u003c= 4, \\\"_setLevNum \\u003e 4\\\");\\r\\n        uint _ownBalance = playerList[_own].rechargeAmount;\\r\\n        address[] memory _son = _getSon(_own);\\r\\n        uint _teamCount = 0;\\r\\n        for (uint i = 0; i \\u003c _son.length; i++) {\\r\\n            (uint _tempCountGtLev,uint _tempCountNowLev) = _getTeamLevNum(_son[i], _setLevNum.sub(1));\\r\\n            delete _tempCountNowLev;\\r\\n            if (_tempCountGtLev \\u003e 0) {\\r\\n                _teamCount = _teamCount.add(1);\\r\\n            }\\r\\n        }\\r\\n        uint _minBalance = 0;\\r\\n        if (_ownBalance \\u003e= _minBalance \\u0026\\u0026 _teamCount \\u003e= 2 \\u0026\\u0026 playerList[_own].lev \\u003c _setLevNum) {\\r\\n            playerList[_own].lev = _setLevNum;\\r\\n            if (_setLevNum == 4) {\\r\\n                _addAddressToSystem(_own);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _addLevNumToSystem(uint _lev) internal {\\r\\n        require(_lev \\u003c 5);\\r\\n        systemLevNum[_lev] = systemLevNum[_lev].add(1);\\r\\n        if(_lev == 1){\\r\\n            return;\\r\\n        }\\r\\n        if(systemLevNum[_lev.sub(1)] == 0){\\r\\n            return;\\r\\n        }\\r\\n        systemLevNum[_lev.sub(1)] = systemLevNum[_lev.sub(1)].sub(1);\\r\\n    }\\r\\n    function _setLev(address _own) internal {\\r\\n        _setLev1(_own);\\r\\n        _setLev2(_own, 2);\\r\\n        _setLev2(_own, 3);\\r\\n        _setLev2(_own, 4);\\r\\n    }\\r\\n    function setParentLev(address _own) public isCore {\\r\\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\\r\\n        _setLev(_own);\\r\\n        for (uint i = 0; i \\u003c 30; i++) {\\r\\n            if (true == playerList[_progenitor[i]].isExist) {\\r\\n                _setLev(_progenitor[i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function setTeamLevReward(address _own, uint _balance) public isCore{\\r\\n        uint[5] memory _teamLevRewardRatio = [0, uint(3), 6, 9, 12];\\r\\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\\r\\n        uint _nowLev = playerList[_own].lev;\\r\\n        teamLevReward[4] memory _teamLevRewardList;\\r\\n        uint _index = 0;\\r\\n        for (uint i = 0; i \\u003c 30; i++) {\\r\\n            if (true == playerList[_progenitor[i]].isExist) {\\r\\n                uint _tempPlayerLev = playerList[_progenitor[i]].lev;\\r\\n                if (_tempPlayerLev \\u003e _nowLev) {\\r\\n                    uint _ratio = _teamLevRewardRatio[_tempPlayerLev].sub(_teamLevRewardRatio[_nowLev]);\\r\\n                    _teamLevRewardList[_index].playerAddress = _progenitor[i];\\r\\n                    _teamLevRewardList[_index].ratio = _ratio;\\r\\n                    _teamLevRewardList[_index].balance = _balance;\\r\\n                    _teamLevRewardList[_index].fromAddress = _own;\\r\\n                    _teamLevRewardList[_index].isExist = true;\\r\\n                    _nowLev = _tempPlayerLev;\\r\\n                    _index = _index.add(1);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        for (uint j = 0; j \\u003c 4; j++) {\\r\\n            if (true == _teamLevRewardList[j].isExist) {\\r\\n                _setTeamLevRewardAct(_teamLevRewardList[j].playerAddress, _teamLevRewardList[j].balance, _teamLevRewardList[j].ratio, _teamLevRewardList[j].fromAddress);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _setTeamLevRewardAct(address _own, uint _balance, uint _ratio, address _formAddress) internal {\\r\\n        uint _tempBalance = (_balance.mul(_ratio)).div(100);\\r\\n        (,uint _surplusAmount) = getSurplusBalance(_own);\\r\\n        if (_surplusAmount \\u003c= 0) {\\r\\n            return;\\r\\n        }\\r\\n        _tempBalance = setIncomeBurn(_own,_tempBalance);\\r\\n        addIncome(_own,2,getNow(),_tempBalance,_formAddress);\\r\\n        _setParentAndSonReward(_own,_tempBalance);\\r\\n    }\\r\\n    function _setLastPoolOverflowReward(uint _balance) internal {\\r\\n        uint _giveBalance = _balance.mul(20).div(100);\\r\\n        _setTopLevReward(_giveBalance);\\r\\n    }\\r\\n    function setTopLevReward(uint _balance) public isCore{\\r\\n        _setTopLevReward(_balance);\\r\\n    }\\r\\n    function _setTopLevReward(uint _balance) internal {\\r\\n        address[] memory topLevList = topLevUser;\\r\\n        uint _topLevNum = topLevList.length;\\r\\n        if (_topLevNum \\u003c= 0) {\\r\\n            return;\\r\\n        }\\r\\n        uint _tempBalance = _balance.div(_topLevNum);\\r\\n        for (uint i = 0; i \\u003c _topLevNum; i++) {\\r\\n            addIncome(topLevList[i],4,getNow(),_tempBalance,tx.origin);\\r\\n        }\\r\\n    }\\r\\n    function getEstimateReward(address _own) public isCore view returns(uint,uint){\\r\\n        Invest[] memory _invest = investList[_own];\\r\\n        uint _min;\\r\\n        uint _max;\\r\\n        for(uint i = 0;i \\u003c _invest.length;i++){\\r\\n            if(true == _invest[i].isFull){\\r\\n                continue;\\r\\n            }\\r\\n            Invest memory _tempInvest = _invest[i]; \\r\\n            (uint _num,uint _endTime,uint _beginTime) = _getCompInvestNum(_tempInvest.withdrawTime);\\r\\n            _endTime.add(_beginTime);\\r\\n            _min = _min.add((_invest[i].balance).mul(_num).mul(30).div(10000));\\r\\n            _max = _max.add((_invest[i].balance).mul(_num).mul(180).div(10000));\\r\\n        }\\r\\n        return (_min,_max);\\r\\n    }\\r\\n    function _setStaticRewardToInvest(address _own, uint _index,uint _random,uint _actionTime) internal {\\r\\n        Invest memory _invest = investList[_own][_index];\\r\\n        if (_invest.isFull == true) {\\r\\n            return;\\r\\n        }\\r\\n        uint _ratio = tool._createRandomNum(30, 150, _index.add(_random));\\r\\n        uint _tempBalance = _invest.balance.mul(_ratio).div(10000);\\r\\n        _tempBalance = setIncomeBurn(_own,_tempBalance);\\r\\n        addIncome(_own,5,_actionTime,_tempBalance,address(0x00));\\r\\n    }\\r\\n    function _getCompInvestNum(uint _lastTime) public view returns(uint _num,uint _withdrawTime,uint _beginTime){\\r\\n        uint _day = day;\\r\\n        uint _nowTime = getNow();\\r\\n        _nowTime = _nowTime.sub(_nowTime.mod(day));\\r\\n        uint _extTime = _lastTime.mod(_day);\\r\\n        if(_extTime != 0){\\r\\n            _lastTime.sub(_extTime);\\r\\n        }\\r\\n        uint _dayNum;\\r\\n        if(_nowTime \\u003c _lastTime){\\r\\n            _dayNum = 0;\\r\\n        }else{\\r\\n            _dayNum = _nowTime.sub(_lastTime).div(_day);\\r\\n        }\\r\\n        return (_dayNum,_nowTime,_lastTime);\\r\\n    }\\r\\n    function _setInvestAllDayReward(address _own,uint _index) internal {\\r\\n        uint _day = day;\\r\\n        Invest memory _invest = investList[_own][_index];\\r\\n        (uint _num,uint _endTime,uint _beginTime) = _getCompInvestNum(_invest.withdrawTime);\\r\\n        for(uint i=0;i\\u003c_num;i++){\\r\\n            _beginTime = _beginTime.add(_day);\\r\\n            _setStaticRewardToInvest(_own,_index,i,_beginTime);\\r\\n        }\\r\\n        investList[_own][_index].withdrawTime = _endTime;\\r\\n    }\\r\\n    function setAllStaticReward(address _own) public isCore {\\r\\n        Invest[] memory _ownInvest = investList[_own];\\r\\n        for (uint i = 0; i \\u003c _ownInvest.length; i++) {\\r\\n            _setInvestAllDayReward(_own, i);\\r\\n        }\\r\\n    }\\r\\n    function getLastOpenLuckCodeList() public view returns(uint[] memory){\\r\\n        require(luckCodeNum \\u003e= 0);\\r\\n        uint[] memory _code;\\r\\n        _code = luckCodeResList[luckCodeNum.sub(1)];\\r\\n        return  _code;\\r\\n    }\\r\\n    function _getRewardList(address _own) internal view  returns (uint[9] memory){\\r\\n        uint[9] memory _reward;\\r\\n        Income[] memory _incomeList = incomeList[_own];\\r\\n        for(uint i=0;i \\u003c _incomeList.length;i++){\\r\\n            if(_incomeList[i].balance \\u003e 0){\\r\\n                _reward[_incomeList[i].incomeType] = _reward[_incomeList[i].incomeType].add(_incomeList[i].balance);\\r\\n            }\\r\\n        }\\r\\n        return _reward;\\r\\n    }\\r\\n    function getIncomeList(address _own) public view returns (uint[50] memory , uint[50] memory , uint[50] memory, address[50] memory ) {\\r\\n        Income[] memory _incomeList = incomeList[_own];\\r\\n        uint j = 0;\\r\\n        uint[50] memory _type;\\r\\n        uint[50] memory _createTime;\\r\\n        uint[50] memory _balance;\\r\\n        address[50] memory _address;\\r\\n        for(uint i = _incomeList.length;i \\u003e 0;i--){\\r\\n            if(j \\u003e= 50){\\r\\n                break;\\r\\n            }\\r\\n            _type[j] = _incomeList[i.sub(1)].incomeType;\\r\\n            _createTime[j] = _incomeList[i.sub(1)].createTime;\\r\\n            _balance[j] = _incomeList[i.sub(1)].balance;\\r\\n            _address[j] = _incomeList[i.sub(1)].fromAddress;\\r\\n            j++;\\r\\n        }\\r\\n        return (_type,_createTime,_balance,_address);\\r\\n    }\\r\\n    function getMyReward(address _own) public view  returns (uint[9] memory){\\r\\n        return _getRewardList(_own);\\r\\n    }\\r\\n    function _getDayMinInvest(Invest[21] memory _invest) internal pure returns (uint _value,uint _keyIndex){\\r\\n        uint _minValue = 0;\\r\\n        uint _index = 0;\\r\\n        for(uint i = 0; i \\u003c 21;i++){\\r\\n            if(_invest[i].balance  == 0){\\r\\n                return (0,i);\\r\\n            }\\r\\n            if(_minValue == 0){\\r\\n                _minValue = _invest[i].balance;\\r\\n                _index = i;\\r\\n            }\\r\\n            if(_minValue \\u003e _invest[i].balance){\\r\\n                _minValue = _invest[i].balance;\\r\\n                _index = i;\\r\\n            }\\r\\n        }\\r\\n        return (_minValue,_index);\\r\\n    }\\r\\n    function _setSortInvest(Invest[21] memory _invest) internal pure returns (Invest[21] memory){\\r\\n        for(uint i = 0;i \\u003c 21;i++){\\r\\n            for(uint j = i+1;j \\u003c 21;j++){\\r\\n                if(_invest[i].balance \\u003c _invest[j].balance){\\r\\n                    (_invest[i], _invest[j]) = (_invest[j], _invest[i]);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return _invest;\\r\\n    }\\r\\n    function _getLuckInvestList(bool _flag) internal view  returns (Invest[21] memory){\\r\\n        uint _lastTime;\\r\\n        uint _endTime;\\r\\n        if(true == _flag){\\r\\n            _lastTime = lastLuckOpenTime;\\r\\n            _endTime = getNow();\\r\\n        }else{\\r\\n            _lastTime = 0;\\r\\n            _endTime = getNow();\\r\\n        }\\r\\n        Invest[] memory _allInvest = systemInvest;\\r\\n        uint _allInvestNum = _allInvest.length;\\r\\n        require (_allInvestNum \\u003e 0);\\r\\n        _allInvestNum = _allInvestNum;\\r\\n        uint _endIndex;\\r\\n        bool _endFlag = false;\\r\\n        uint _startIndex;\\r\\n\\r\\n        for(;_allInvestNum \\u003e 0;_allInvestNum--){\\r\\n            if(_allInvest[_allInvestNum.sub(1)].createTime \\u003c _lastTime){\\r\\n                break;\\r\\n            }\\r\\n            if(_allInvest[_allInvestNum.sub(1)].createTime \\u003c= _endTime){\\r\\n                if(false == _endFlag){\\r\\n                    _endIndex = _allInvestNum.sub(1);\\r\\n                    _endFlag = true;\\r\\n                }\\r\\n                _startIndex = _allInvestNum.sub(1);\\r\\n            }\\r\\n        }\\r\\n        Invest[21] memory _dayMaxInvest;\\r\\n        for(uint i = _startIndex;i \\u003c= _endIndex;i++){\\r\\n            (uint _minValue,uint _minIndex) = _getDayMinInvest(_dayMaxInvest);\\r\\n            if(_minValue \\u003c _allInvest[i].balance){\\r\\n                _dayMaxInvest[_minIndex] = _allInvest[i];\\r\\n            }\\r\\n        }\\r\\n        _dayMaxInvest = _setSortInvest(_dayMaxInvest);\\r\\n        return _dayMaxInvest;\\r\\n    }\\r\\n    function getInvestList(bool _flag) public view isCore returns (address[21] memory) {\\r\\n        Invest[21] memory investList = _getLuckInvestList(_flag);\\r\\n        address[21] memory _address;\\r\\n        for(uint i = 0; i \\u003c 21;i++){\\r\\n            _address[i] = investList[i].own;\\r\\n        }\\r\\n        return _address;\\r\\n    }\\r\\n    function getSystemInvestLength() public view isCore returns (uint){\\r\\n        return systemInvest.length;\\r\\n    }\\r\\n    function getSystemInvestInfo(uint _index) public view isCore returns (address,uint){\\r\\n        return (systemInvest[_index].own,systemInvest[_index].createTime);\\r\\n    }\\r\\n    function getLuckCode(address _own) public view returns(uint[100] memory){\\r\\n        address[] memory _luckCodeList = luckCodeList[luckCodeNum];\\r\\n        uint[100] memory _code;\\r\\n        uint j = 0;\\r\\n        for(uint i = 0; i\\u003c _luckCodeList.length;i++){\\r\\n            if(j \\u003e= 100){\\r\\n                continue;\\r\\n            }\\r\\n            if(_luckCodeList[i] == _own){\\r\\n                _code[j] = i;\\r\\n                j++;\\r\\n            }\\r\\n        }\\r\\n        return _code;\\r\\n    }\\r\\n    function openReward() public isCore{\\r\\n        uint _nowTime = getNow();\\r\\n        uint _day = day;\\r\\n        if(_nowTime.sub(luckCodeLastTime) \\u003c= _day){\\r\\n            return;\\r\\n        }\\r\\n        openLuckInvestReward();\\r\\n        openLuckCodeReward();\\r\\n        luckCodeLastTime = getNow();\\r\\n    }\\r\\n    function openLastPoolReward() public isCore{\\r\\n        Invest[] memory _investList = systemInvest;\\r\\n        uint _length = systemInvest.length;\\r\\n        uint _index = _length.sub(1);\\r\\n        address[568] memory _player;\\r\\n        for(uint i=0;i\\u003c568;i++){\\r\\n            _player[i] = _investList[_index].own;\\r\\n            if(_index == 0){\\r\\n                break;\\r\\n            }\\r\\n            _index = _index.sub(1);\\r\\n        }\\r\\n        uint _num1 = lastPool.mul(10).div(100).div(8);\\r\\n        uint _num2 = lastPool.mul(20).div(100).div(60);\\r\\n        uint _num3 = lastPool.mul(70).div(100).div(500);\\r\\n        lastPool = 0;\\r\\n        for(uint j = 0;j\\u003c568;j++){\\r\\n            if(_player[j] == address(0x00)){\\r\\n                break;\\r\\n            }\\r\\n            if(j \\u003c 8){\\r\\n                addIncome(_player[j],3,getNow(),_num1,address(0x00));\\r\\n            }else if(j \\u003c 68){\\r\\n                addIncome(_player[j],3,getNow(),_num2,address(0x00));\\r\\n            }else{\\r\\n                addIncome(_player[j],3,getNow(),_num3,address(0x00));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    mapping(uint=\\u003euint[4][2]) public luckPool;\\r\\n    uint luckNum = 1;\\r\\n    uint luckInvestNum = 1;\\r\\n    uint public systemPlayerNum;\\r\\n    mapping(address =\\u003e Player) public playerList;\\r\\n    address[] public topLevUser;\\r\\n    Invest[] public systemInvest;\\r\\n    mapping(address =\\u003e Income[]) public incomeList;\\r\\n    mapping(address =\\u003e Invest[]) public investList;\\r\\n    mapping(uint =\\u003eaddress[]) public luckCodeList;\\r\\n    mapping(uint =\\u003euint[]) public luckCodeResList;\\r\\n    mapping(uint =\\u003euint) public luckCodeBurnTokenNum;\\r\\n    mapping(uint =\\u003euint) public investTokenUsdtNum;\\r\\n    uint public luckCodeNum = 1;\\r\\n    uint public luckCodeLastTime = now;\\r\\n    uint public lastLuckOpenTime = now;\\r\\n    uint luckInvestCycle = day;\\r\\n    uint public lastPool;\\r\\n    uint public lastTime;\\r\\n    uint[5] public systemLevNum; \\r\\n    struct Player {\\r\\n        uint lev;\\r\\n        uint withdrawAmount;\\r\\n        uint allIncome;\\r\\n        uint rechargeAmount;\\r\\n        uint teamRechargeAmount;\\r\\n        uint lastWithdrawTime;\\r\\n        bool isExist;\\r\\n        bool isParent;\\r\\n        address parentAddress;\\r\\n        address[] sonAddress;\\r\\n        address [] teamAddress;\\r\\n    }\\r\\n    struct Income {\\r\\n        uint incomeType;\\r\\n        uint createTime;\\r\\n        uint balance;\\r\\n        address fromAddress;\\r\\n    }\\r\\n    struct Invest{\\r\\n        address own;\\r\\n        uint createTime;\\r\\n        uint withdrawTime;\\r\\n        uint balance;\\r\\n        uint ratio;\\r\\n        uint profit;\\r\\n        bool isFull;\\r\\n    }\\r\\n    struct luckIncome{\\r\\n        uint balance;\\r\\n        address own;\\r\\n    }\\r\\n    struct luckIncomeHistory{\\r\\n        uint num;\\r\\n        luckIncome[] list;\\r\\n        bool isExist;\\r\\n    }\\r\\n    struct teamLevReward{\\r\\n        address playerAddress;\\r\\n        address fromAddress;\\r\\n        uint ratio;\\r\\n        uint balance;\\r\\n        bool isExist;\\r\\n    }\\r\\n}\\r\\nabstract contract Tool {\\r\\n    function _getNeedTicketNum(uint _balance) view public virtual returns (uint);\\r\\n    function _getRatio(uint _balance) pure public virtual returns (uint);\\r\\n    function _createRandomNum(uint _min, uint _max, uint _randNonce) public virtual view returns (uint);\\r\\n    function _crateLuckCodeList(uint _max) public view virtual returns (uint[25] memory);\\r\\n}\"},\"safeMath.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.7.0;\\r\\n\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastTime\",\"type\":\"uint256\"}],\"name\":\"_getCompInvestNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_beginTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"addCodeToPlayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fromAddress\",\"type\":\"address\"}],\"name\":\"addIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"addInvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"addInvestBurnNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getAddressSomeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_teamCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sonCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_investBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_incomeBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getAreaPerformance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPerformance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPerformance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getEstimateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getFreeWithdrawBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getIncomeList\",\"outputs\":[{\"internalType\":\"uint256[50]\",\"name\":\"\",\"type\":\"uint256[50]\"},{\"internalType\":\"uint256[50]\",\"name\":\"\",\"type\":\"uint256[50]\"},{\"internalType\":\"uint256[50]\",\"name\":\"\",\"type\":\"uint256[50]\"},{\"internalType\":\"address[50]\",\"name\":\"\",\"type\":\"address[50]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"getInvestList\",\"outputs\":[{\"internalType\":\"address[21]\",\"name\":\"\",\"type\":\"address[21]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastOpenLuckCodeList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getLuckCode\",\"outputs\":[{\"internalType\":\"uint256[100]\",\"name\":\"\",\"type\":\"uint256[100]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getMyReward\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isParent\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"getSurplusBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSystemInvestInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemInvestLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemTopLevUser\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"giveShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"incomeList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"incomeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coreAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toolAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFull\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investTokenUsdtNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLuckOpenTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckCodeBurnTokenNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckCodeLastTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckCodeList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckCodeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckCodeResList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openLastPoolReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rechargeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamRechargeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isParent\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"setAllStaticReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setAssignment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setLastTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_luckNum\",\"type\":\"uint256\"}],\"name\":\"setLuckPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_luckNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_luckType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_luckArea\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setLuckPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"setParentLev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lev\",\"type\":\"uint256\"}],\"name\":\"setPlayerLev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"}],\"name\":\"setPlayerParentAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"}],\"name\":\"setPlayerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"setSystemPlayerNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setTeamLevReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setTopLevReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"systemInvest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"own\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFull\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"systemLevNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemPlayerNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topLevUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Db","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5ef3675b694f8446c6cf0c5e447fc189b413253a64895553094c318976be259f"}]}