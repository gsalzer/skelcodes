{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\nlibrary SafeMath { // wrappers over solidity arithmetic operations with overflow checks\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard { // contract module that helps prevent reentrant calls to a function\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n        \r\n        _;\r\n        \r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC20 { // brief interface for erc20 token txs\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWETH { // brief interface for canonical ether token wrapper contract \r\n    function deposit() payable external;\r\n    \r\n    function transfer(address dst, uint wad) external returns (bool);\r\n}\r\n\r\ncontract MysticMoloch is ReentrancyGuard { \r\n    using SafeMath for uint256;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n    address public depositToken; // deposit token contract reference - default = wETH\r\n    address public stakeToken; // stake token contract reference for guild voting shares \r\n    address public wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // canonical ether token wrapper contract reference for proposals\r\n    \r\n    uint256 public proposalDeposit; // default = 10 deposit token \r\n    uint256 public processingReward; // default = 0.1 - amount of deposit token to give to whoever processes a proposal\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public summoningTime; // needed to determine the current period\r\n    \r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n    uint256 constant MAX_GUILD_BOUND = 10**36; // maximum bound for guild shares & loot (reflects guild token 18 decimal default)\r\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 400; // maximum number of whitelisted tokens\r\n    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\r\n\r\n    // BANK TOKEN DETAILS\r\n    string private _name = \"Moloch DAO v2x Bank\";\r\n    string private _symbol = \"MOL-V2X\";\r\n    uint8 private _decimals = 18;\r\n\r\n    // **************\r\n    // EVENT TRACKING\r\n    // **************\r\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, uint8[7] flags, bytes data, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\r\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\r\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\r\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessActionProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event Transfer(address indexed from, address indexed to, uint256 amount); // guild token mint, burn & (loot) transfer tracking\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\r\n    event TokensCollected(address indexed token, uint256 amountToCollect);\r\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\r\n    \r\n    // *******************\r\n    // INTERNAL ACCOUNTING\r\n    // *******************\r\n    address public constant GUILD = address(0xdead);\r\n    address public constant ESCROW = address(0xdeaf);\r\n    address public constant TOTAL = address(0xdeed);\r\n    \r\n    uint256 public proposalCount; // total proposals submitted\r\n    uint256 public totalShares; // total shares across all members\r\n    uint256 public totalLoot; // total loot across all members\r\n    uint256 public totalGuildBankTokens; // total tokens with non-zero balance in guild bank\r\n\r\n    mapping(uint256 => bytes) public actions; // proposalId => action data\r\n    mapping(address => uint256) private balances; // guild token balances\r\n    mapping(address => mapping(address => uint256)) private userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n    \r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals & voting - defaults to member address unless updated\r\n        uint8 exists; // always true (1) once a member has been created\r\n        uint256 shares; // the # of voting shares assigned to this member\r\n        uint256 loot; // the loot amount available to this member (combined with shares on ragekick) - transferable by guild token\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on & sponsoring proposals\r\n    }\r\n    \r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as target for alt. proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        address tributeToken; // tribute token contract reference\r\n        address paymentToken; // payment token contract reference\r\n        uint8[7] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        bytes32 details; // proposal details to add context for members \r\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n\r\n    mapping(address => bool) public tokenWhitelist;\r\n    address[] public approvedTokens;\r\n\r\n    mapping(address => bool) public proposedToWhitelist;\r\n    mapping(address => bool) public proposedToKick;\r\n    \r\n    mapping(address => Member) public members;\r\n    mapping(address => address) public memberAddressByDelegateKey;\r\n    \r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    uint256[] public proposalQueue;\r\n\r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"!delegate\");\r\n        _;\r\n    }\r\n    \r\n    constructor(\r\n        address _depositToken,\r\n        address _stakeToken,\r\n        address[] memory _summoner,\r\n        uint256[] memory _summonerShares,\r\n        uint256 _summonerDeposit,\r\n        uint256 _proposalDeposit,\r\n        uint256 _processingReward,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _dilutionBound\r\n    ) public {\r\n        require(_depositToken != _stakeToken, \"depositToken==stakeToken\");\r\n        require(_summoner.length == _summonerShares.length, \"summoner!=summonerShares\");\r\n        \r\n        for (uint256 i = 0; i < _summoner.length; i++) {\r\n            registerMember(_summoner[i], _summonerShares[i]);\r\n            mintGuildToken(_summoner[i], _summonerShares[i]);\r\n            totalShares += _summonerShares[i];\r\n        }\r\n        \r\n        require(totalShares <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        \r\n        tokenWhitelist[_depositToken] = true;\r\n        approvedTokens.push(_depositToken);\r\n        \r\n        if (_summonerDeposit > 0) {\r\n            totalGuildBankTokens += 1;\r\n            unsafeAddToBalance(GUILD, _depositToken, _summonerDeposit);\r\n        }\r\n        \r\n        depositToken = _depositToken;\r\n        stakeToken = _stakeToken;\r\n        proposalDeposit = _proposalDeposit;\r\n        processingReward = _processingReward;\r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        dilutionBound = _dilutionBound;\r\n        summoningTime = now;\r\n    }\r\n    \r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details\r\n    ) payable external nonReentrant returns (uint256 proposalId) {\r\n        require(sharesRequested.add(lootRequested) <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        require(tokenWhitelist[tributeToken], \"tributeToken!=whitelist\");\r\n        require(tokenWhitelist[paymentToken], \"paymentToken!=whitelist\");\r\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant unreservable\");\r\n        require(members[applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n        \r\n        // collect tribute from proposer & store it in the Moloch until the proposal is processed - if ether, wrap into wETH\r\n        if (tributeToken == wETH && msg.value > 0) {\r\n            require(msg.value == tributeOffered, \"!ETH\");\r\n            IWETH(wETH).deposit();\r\n            (bool success, ) = wETH.call.value(msg.value)(\"\");\r\n            require(success, \"!transfer\");\r\n            IWETH(wETH).transfer(address(this), msg.value);\r\n        } else {\r\n            require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"!transfer\");\r\n        }\r\n        \r\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\r\n\r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n\r\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, \"\");\r\n        \r\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\r\n    }\r\n    \r\n    function submitActionProposal( // stages arbitrary function calls for member vote - based on Raid Guild 'Minion'\r\n        address actionTo,\r\n        address actionToken,\r\n        uint256 actionTokenAmount,\r\n        uint256 actionValue,\r\n        bytes calldata data,\r\n        bytes32 details\r\n    ) external returns (uint256 proposalId) {\r\n        \r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        flags[6] = 1; // guild action\r\n        \r\n        _submitProposal(actionTo, 0, 0, actionValue, address(0), actionTokenAmount, actionToken, details, flags, data);\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n    \r\n    function submitWhitelistProposal(address tokenToWhitelist, bytes32 details) external returns (uint256 proposalId) {\r\n        require(tokenToWhitelist != address(0), \"!token\");\r\n        require(tokenToWhitelist != stakeToken, \"whitelist==stakeToken\");\r\n        require(!tokenWhitelist[tokenToWhitelist], \"whitelisted\");\r\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n\r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        flags[4] = 1; // whitelist\r\n\r\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags, \"\");\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n    \r\n    function submitGuildKickProposal(address memberToKick, bytes32 details) external returns (uint256 proposalId) {\r\n        Member memory member = members[memberToKick];\r\n\r\n        require(member.shares > 0 || member.loot > 0, \"!share||loot\");\r\n        require(members[memberToKick].jailed == 0, \"jailed\");\r\n\r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        flags[5] = 1; // guild kick\r\n\r\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags, \"\");\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n    \r\n    function _submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details,\r\n        uint8[7] memory flags,\r\n        bytes memory data\r\n    ) internal {\r\n        Proposal memory proposal = Proposal({\r\n            applicant : applicant,\r\n            proposer : msg.sender,\r\n            sponsor : address(0),\r\n            tributeToken : tributeToken,\r\n            paymentToken : paymentToken,\r\n            flags : flags,\r\n            sharesRequested : sharesRequested,\r\n            lootRequested : lootRequested,\r\n            paymentRequested : paymentRequested,\r\n            tributeOffered : tributeOffered,\r\n            startingPeriod : 0,\r\n            yesVotes : 0,\r\n            noVotes : 0,\r\n            maxTotalSharesAndLootAtYesVote : 0,\r\n            details : details\r\n        });\r\n        \r\n        if (proposal.flags[6] == 1) {\r\n            actions[proposalCount] = data;\r\n        }\r\n        \r\n        proposals[proposalCount] = proposal;\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        // NOTE: argument order matters, avoid stack too deep\r\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, data, proposalCount, msg.sender, memberAddress);\r\n        \r\n        proposalCount += 1;\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposalId) external nonReentrant onlyDelegate {\r\n        // collect proposal deposit from sponsor & store it in the Moloch until the proposal is processed\r\n        require(IERC20(depositToken).transferFrom(msg.sender, address(this), proposalDeposit), \"!transfer\");\r\n        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.proposer != address(0), \"!proposed\");\r\n        require(proposal.flags[0] == 0, \"sponsored\");\r\n        require(proposal.flags[3] == 0, \"cancelled\");\r\n        require(members[proposal.applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n\r\n        // whitelist proposal\r\n        if (proposal.flags[4] == 1) {\r\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"whitelisted\");\r\n            require(!proposedToWhitelist[address(proposal.tributeToken)], \"proposed\");\r\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\r\n\r\n        // guild kick proposal\r\n        } else if (proposal.flags[5] == 1) {\r\n            require(!proposedToKick[proposal.applicant], \"kick proposed\");\r\n            proposedToKick[proposal.applicant] = true;\r\n        }\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length - 1]].startingPeriod\r\n        ) + 1;\r\n\r\n        proposal.startingPeriod = startingPeriod;\r\n\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        proposal.sponsor = memberAddress;\r\n\r\n        proposal.flags[0] = 1; // sponsored\r\n\r\n        // append proposal to the queue\r\n        proposalQueue.push(proposalId);\r\n        \r\n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length - 1, startingPeriod);\r\n    }\r\n\r\n    // NOTE: In MolochV2 proposalIndex != proposalId\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) external onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"!proposed\");\r\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(uintVote < 3, \"!<3\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"pending\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"voted\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"!Yes||No\");\r\n\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes += member.shares;\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalSupply() > proposal.maxTotalSharesAndLootAtYesVote) {\r\n                proposal.maxTotalSharesAndLootAtYesVote = totalSupply();\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes += member.shares;\r\n        }\r\n     \r\n        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set until it's been sponsored but proposal is created on submission\r\n        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) external {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4] == 0 && proposal.flags[5] == 0 && proposal.flags[6] == 0, \"!standard\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        // Make the proposal fail if the new total number of shares & loot exceeds the limit\r\n        if (totalSupply().add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_GUILD_BOUND) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\r\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass == true) {\r\n            proposal.flags[2] = 1; // didPass\r\n\r\n            // if the applicant is already a member, add to their existing shares & loot\r\n            if (members[proposal.applicant].exists == 1) {\r\n                members[proposal.applicant].shares += proposal.sharesRequested;\r\n                members[proposal.applicant].loot += proposal.lootRequested;\r\n\r\n            // if the applicant is a new member, create a new record for them\r\n            } else {\r\n                registerMember(proposal.applicant, proposal.sharesRequested);\r\n            }\r\n\r\n            // mint new guild token, shares & loot \r\n            mintGuildToken(proposal.applicant, proposal.sharesRequested + proposal.lootRequested);\r\n            totalShares += proposal.sharesRequested;\r\n            totalLoot += proposal.lootRequested;\r\n\r\n            // if the proposal tribute is the first token of its kind to make it into the guild bank, increment total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\r\n                totalGuildBankTokens += 1;\r\n            }\r\n\r\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\r\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\r\n\r\n            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\r\n                totalGuildBankTokens -= 1;\r\n            }\r\n\r\n        // PROPOSAL FAILED\r\n        } else {\r\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\r\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        }\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n    \r\n    function processActionProposal(uint256 proposalIndex) external returns (bool, bytes memory) {\r\n        _validateProposalForProcessing(proposalIndex);\r\n        \r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        bytes memory action = actions[proposalId];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        require(proposal.flags[6] == 1, \"!action\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n        \r\n        // Make the proposal fail if it is requesting more ether than the available local balance\r\n        if (proposal.paymentToken == address(0) && proposal.tributeOffered > address(this).balance) {\r\n            didPass = false;\r\n        }\r\n        \r\n        // Make the proposal fail if it is requesting more stake token than the available local balance\r\n        if (proposal.paymentToken == stakeToken && proposal.paymentRequested > IERC20(stakeToken).balanceOf(address(this))) {\r\n            didPass = false;\r\n        }\r\n        \r\n        // Make the proposal fail if it is requesting more tokens than the available guild bank balance\r\n        if (proposal.paymentToken != address(0) && proposal.paymentToken != stakeToken && proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass == true) {\r\n            proposal.flags[2] = 1; // didPass\r\n            (bool success, bytes memory retData) = proposal.applicant.call.value(proposal.tributeOffered)(action);\r\n            if (proposal.paymentToken != address(0) && proposal.paymentToken != stakeToken) {\r\n                unsafeSubtractFromBalance(GUILD, proposal.paymentToken, proposal.paymentRequested);\r\n                // if the action proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n                if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {totalGuildBankTokens -= 1;}\r\n            }\r\n            return (success, retData);\r\n        }\r\n        \r\n        emit ProcessActionProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processWhitelistProposal(uint256 proposalIndex) external {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4] == 1, \"!whitelist\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass == true) {\r\n            proposal.flags[2] = 1; // didPass\r\n\r\n            tokenWhitelist[address(proposal.tributeToken)] = true;\r\n            approvedTokens.push(proposal.tributeToken);\r\n        }\r\n\r\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processGuildKickProposal(uint256 proposalIndex) external {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[5] == 1, \"!kick\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (didPass == true) {\r\n            proposal.flags[2] = 1; // didPass\r\n            Member storage member = members[proposal.applicant];\r\n            member.jailed = proposalIndex;\r\n\r\n            // transfer shares to loot\r\n            member.shares = 0; // revoke all shares\r\n            member.loot += member.shares;\r\n            totalShares -= member.shares;\r\n            totalLoot += member.shares;\r\n        }\r\n\r\n        proposedToKick[proposal.applicant] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function _didPass(uint256 proposalIndex) internal view returns (bool didPass) {\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n        \r\n        if (proposal.yesVotes > proposal.noVotes) {\r\n            didPass = true;\r\n        }\r\n        \r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if ((totalSupply().mul(dilutionBound)) < proposal.maxTotalSharesAndLootAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if the applicant is jailed\r\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\r\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\r\n        if (members[proposal.applicant].jailed != 0) {\r\n            didPass = false;\r\n        }\r\n\r\n        return didPass;\r\n    }\r\n\r\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\r\n        require(proposalIndex < proposalQueue.length, \"!proposal\");\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod + votingPeriodLength + gracePeriodLength, \"!ready\");\r\n        require(proposal.flags[1] == 0, \"processed\");\r\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex - 1]].flags[1] == 1, \"prior !processed\");\r\n    }\r\n\r\n    function _returnDeposit(address sponsor) internal {\r\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\r\n        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit - processingReward);\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) external {\r\n        require(members[msg.sender].exists == 1, \"!member\");\r\n        \r\n        _ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) internal {\r\n        uint256 initialTotalSharesAndLoot = totalSupply();\r\n\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(member.shares >= sharesToBurn, \"!shares\");\r\n        require(member.loot >= lootToBurn, \"!loot\");\r\n\r\n        require(canRagequit(member.highestIndexYesVote), \"!ragequit until highest index proposal member voted YES processes\");\r\n\r\n        uint256 sharesAndLootToBurn = sharesToBurn + lootToBurn;\r\n\r\n        // burn guild token, shares & loot\r\n        burnGuildToken(memberAddress, sharesAndLootToBurn);\r\n        member.shares -= sharesToBurn;\r\n        member.loot -= lootToBurn;\r\n        totalShares -= sharesToBurn;\r\n        totalLoot -= lootToBurn;\r\n\r\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\r\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\r\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\r\n                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\r\n                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\r\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\r\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\r\n            }\r\n        }\r\n\r\n        emit Ragequit(memberAddress, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function ragekick(address memberToKick) external {\r\n        Member storage member = members[memberToKick];\r\n\r\n        require(member.jailed != 0, \"!jailed\");\r\n        require(member.loot > 0, \"!loot\"); // note - should be impossible for jailed member to have shares\r\n        require(canRagequit(member.highestIndexYesVote), \"!ragequit until highest index proposal member voted YES processes\");\r\n\r\n        _ragequit(memberToKick, 0, member.loot);\r\n    }\r\n    \r\n    function withdrawBalance(address token, uint256 amount) external nonReentrant {\r\n        _withdrawBalance(token, amount);\r\n    }\r\n\r\n    function withdrawBalances(address[] calldata tokens, uint256[] calldata amounts, bool max) external nonReentrant {\r\n        require(tokens.length == amounts.length, \"tokens!=amounts\");\r\n\r\n        for (uint256 i=0; i < tokens.length; i++) {\r\n            uint256 withdrawAmount = amounts[i];\r\n            if (max) { // withdraw the maximum balance\r\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\r\n            }\r\n\r\n            _withdrawBalance(tokens[i], withdrawAmount);\r\n        }\r\n    }\r\n    \r\n    function _withdrawBalance(address token, uint256 amount) internal {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"!balance\");\r\n        \r\n        require(IERC20(token).transfer(msg.sender, amount), \"!transfer\");\r\n        unsafeSubtractFromBalance(msg.sender, token, amount);\r\n        \r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n\r\n    function collectTokens(address token) external {\r\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)) - userTokenBalances[TOTAL][token];\r\n        // only collect if 1) there are tokens to collect & 2) token is whitelisted\r\n        require(amountToCollect > 0, \"!amount\");\r\n        require(tokenWhitelist[token], \"!whitelisted\");\r\n        \r\n        if (userTokenBalances[GUILD][token] == 0 && totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT) {totalGuildBankTokens += 1;}\r\n        unsafeAddToBalance(GUILD, token, amountToCollect);\r\n\r\n        emit TokensCollected(token, amountToCollect);\r\n    }\r\n\r\n    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender == proposal.proposer\r\n    function cancelProposal(uint256 proposalId) external {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.flags[0] == 0, \"sponsored\");\r\n        require(proposal.flags[3] == 0, \"cancelled\");\r\n        require(msg.sender == proposal.proposer, \"!proposer\");\r\n\r\n        proposal.flags[3] = 1; // cancelled\r\n        \r\n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        \r\n        emit CancelProposal(proposalId, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) external {\r\n        require(members[msg.sender].shares > 0, \"caller !shareholder\");\r\n        require(newDelegateKey != address(0), \"newDelegateKey==0\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(members[newDelegateKey].exists == 0, \"!overwrite members\");\r\n            require(members[memberAddressByDelegateKey[newDelegateKey]].exists == 0, \"!overwrite keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n    \r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"!proposal\");\r\n        \r\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod + votingPeriodLength;\r\n    }\r\n    \r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n    \r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n    \r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\r\n        require(members[memberAddress].exists == 1, \"!member\");\r\n        require(proposalIndex < proposalQueue.length, \"!proposed\");\r\n        \r\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\r\n    }\r\n\r\n    function getProposalFlags(uint256 proposalId) public view returns (uint8[7] memory) {\r\n        return proposals[proposalId].flags;\r\n    }\r\n    \r\n    function getProposalQueueLength() public view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n    \r\n    function getTokenCount() public view returns (uint256) {\r\n        return approvedTokens.length;\r\n    }\r\n\r\n    function getUserTokenBalance(address user, address token) public view returns (uint256) {\r\n        return userTokenBalances[user][token];\r\n    }\r\n    \r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    function() external payable {}\r\n    \r\n    function fairShare(uint256 balance, uint256 shares, uint256 totalSharesAndLoot) internal pure returns (uint256) {\r\n        require(totalSharesAndLoot != 0);\r\n\r\n        if (balance == 0) { return 0; }\r\n\r\n        uint256 prod = balance * shares;\r\n\r\n        if (prod / balance == shares) { // no overflow in multiplication above?\r\n            return prod / totalSharesAndLoot;\r\n        }\r\n\r\n        return (balance / totalSharesAndLoot) * shares;\r\n    }\r\n    \r\n    function registerMember(address newMember, uint256 shares) internal {\r\n        // if new member is already taken by a member's delegateKey, reset it to their member address\r\n        if (members[memberAddressByDelegateKey[newMember]].exists == 1) {\r\n            address memberToOverride = memberAddressByDelegateKey[newMember];\r\n            memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n            members[memberToOverride].delegateKey = memberToOverride;\r\n        }\r\n        \r\n        members[newMember] = Member({\r\n            delegateKey : newMember,\r\n            exists : 1, // 'true'\r\n            shares : shares,\r\n            loot : 0,\r\n            highestIndexYesVote : 0,\r\n            jailed : 0\r\n        });\r\n\r\n        memberAddressByDelegateKey[newMember] = newMember;\r\n    }\r\n    \r\n    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] += amount;\r\n        userTokenBalances[TOTAL][token] += amount;\r\n    }\r\n    \r\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\r\n        unsafeSubtractFromBalance(from, token, amount);\r\n        unsafeAddToBalance(to, token, amount);\r\n    }\r\n\r\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] -= amount;\r\n        userTokenBalances[TOTAL][token] -= amount;\r\n    }\r\n    \r\n    /********************\r\n    GUILD TOKEN FUNCTIONS\r\n    ********************/\r\n    // GETTER FUNCTIONS\r\n    function balanceOf(address account) external view returns (uint256) { \r\n        return balances[account];\r\n    }\r\n    \r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256) { \r\n        return totalShares + totalLoot;\r\n    }\r\n    \r\n    // BALANCE MGMT FUNCTIONS\r\n    function burnGuildToken(address memberAddress, uint256 amount) internal {\r\n        balances[memberAddress] -= amount;\r\n        \r\n        emit Transfer(memberAddress, address(0), amount);\r\n    }\r\n    \r\n    function claimShares(uint256 amount) external nonReentrant {\r\n        require(IERC20(stakeToken).transferFrom(msg.sender, address(this), amount), \"!transfer\"); // deposit stake token & claim shares (1:1)\r\n        \r\n        // if the sender is already a member, add to their existing shares \r\n        if (members[msg.sender].exists == 1) {\r\n            members[msg.sender].shares = members[msg.sender].shares.add(amount);\r\n\r\n        // if the sender is a new member, create a new record for them\r\n        } else {\r\n            registerMember(msg.sender, amount);\r\n        }\r\n\r\n        // mint new guild token & shares \r\n        mintGuildToken(msg.sender, amount);\r\n        totalShares += amount;\r\n            \r\n        require(totalShares <= MAX_GUILD_BOUND, \"guild maxed\");\r\n    }\r\n    \r\n    function convertSharesToLoot(uint256 sharesToLoot) external {\r\n        require(members[msg.sender].shares >= sharesToLoot, \"!shares\");\r\n        \r\n        members[msg.sender].shares -= sharesToLoot;\r\n        members[msg.sender].loot += sharesToLoot;\r\n        totalShares -= sharesToLoot;\r\n        totalLoot += sharesToLoot;\r\n    }\r\n    \r\n    function mintGuildToken(address memberAddress, uint256 amount) internal {\r\n        balances[memberAddress] += amount;\r\n        \r\n        emit Transfer(address(0), memberAddress, amount);\r\n    }\r\n\r\n    // LOOT TRANSFER FUNCTION\r\n    function transfer(address receiver, uint256 lootToTransfer) external returns (bool) {\r\n        require(members[msg.sender].loot >= lootToTransfer, \"!loot\");\r\n        \r\n        members[msg.sender].loot -= lootToTransfer;\r\n        members[receiver].loot += lootToTransfer;\r\n        \r\n        balances[msg.sender] -= lootToTransfer;\r\n        balances[receiver] += lootToTransfer;\r\n        \r\n        emit Transfer(msg.sender, receiver, lootToTransfer);\r\n        \r\n        return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_summoner\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_summonerShares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_summonerDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_processingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingPeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gracePeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dilutionBound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"applicantAddress\",\"type\":\"address\"}],\"name\":\"CancelProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessActionProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessGuildKickProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessWhitelistProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"Ragequit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"SponsorProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8[7]\",\"name\":\"flags\",\"type\":\"uint8[7]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"SubmitProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"SubmitVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToCollect\",\"type\":\"uint256\"}],\"name\":\"TokensCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"UpdateDelegateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"ESCROW\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GUILD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"actions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"}],\"name\":\"canRagequit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancelProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"collectTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesToLoot\",\"type\":\"uint256\"}],\"name\":\"convertSharesToLoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dilutionBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"getMemberProposalVote\",\"outputs\":[{\"internalType\":\"enum MysticMoloch.Vote\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalFlags\",\"outputs\":[{\"internalType\":\"uint8[7]\",\"name\":\"\",\"type\":\"uint8[7]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposalQueueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gracePeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"hasVotingPeriodExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberAddressByDelegateKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"exists\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jailed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processActionProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processGuildKickProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processWhitelistProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"processingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yesVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalSharesAndLootAtYesVote\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToKick\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"}],\"name\":\"ragekick\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"ragequit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"sponsorProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"actionTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actionTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actionValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitActionProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitGuildKickProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"submitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenToWhitelist\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitWhitelistProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"summoningTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGuildBankTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lootToTransfer\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"updateDelegateKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingPeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"max\",\"type\":\"bool\"}],\"name\":\"withdrawBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MysticMoloch","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001e1c9929bc7865ad39ebfcb0cc8c92cfabddbc48000000000000000000000000cd62b1c403fa761baadfc74c525ce2b51780b184000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000004563918244f400000000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000438000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000001c0aa8ccd568d90d61659f060d1bfb1e6f855a2000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f454a0b80e81163e42dbfdd31fc803eaf3fa48fd232d0eb0231c5a8697f4249a"}]}