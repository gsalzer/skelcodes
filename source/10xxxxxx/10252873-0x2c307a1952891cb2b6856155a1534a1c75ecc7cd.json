{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Subtraction cannot overflow.\r\n\t *\r\n\t * _Available since v2.4.0._\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (uint256)\r\n\t{\r\n\t\trequire(b <= a, errorMessage);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn div(a, b, \"SafeMath: division by zero\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t *\r\n\t * _Available since v2.4.0._\r\n\t */\r\n\tfunction div(uint256 a, uint256 b, string memory errorMessage)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (uint256)\r\n\t{\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\trequire(b > 0, errorMessage);\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * Reverts when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * Reverts with custom message when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t *\r\n\t * _Available since v2.4.0._\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (uint256)\r\n\t{\r\n\t\trequire(b != 0, errorMessage);\r\n\t\treturn a % b;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n\t/**\r\n\t * @dev Returns the amount of tokens in existence.\r\n\t */\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the amount of tokens owned by `account`.\r\n\t */\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transfer(address recipient, uint256 amount)\r\n\t\texternal\r\n\t\treturns (bool);\r\n\r\n\t/**\r\n\t * @dev Returns the remaining number of tokens that `spender` will be\r\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n\t * zero by default.\r\n\t *\r\n\t * This value changes when {approve} or {transferFrom} are called.\r\n\t */\r\n\tfunction allowance(address owner, address spender)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n\t * that someone may use both the old and the new allowance by unfortunate\r\n\t * transaction ordering. One possible solution to mitigate this race\r\n\t * condition is to first reduce the spender's allowance to 0 and set the\r\n\t * desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n\t * allowance mechanism. `amount` is then deducted from the caller's\r\n\t * allowance.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount)\r\n\t\texternal\r\n\t\treturns (bool);\r\n\r\n\t/**\r\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n\t * another (`to`).\r\n\t *\r\n\t * Note that `value` may be zero.\r\n\t */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n\t * a call to {approve}. `value` is the new allowance.\r\n\t */\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n\tusing SafeMath for uint256;\r\n\r\n\tfunction safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n\t\tcallOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(token.transfer.selector, to, value)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(\r\n\t\tIERC20 token,\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\tcallOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction safeApprove(IERC20 token, address spender, uint256 value)\r\n\t\tinternal\r\n\t{\r\n\t\t// safeApprove should only be called when setting an initial allowance,\r\n\t\t// or when resetting it to zero. To increase and decrease it, use\r\n\t\t// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n\t\t// solhint-disable-next-line max-line-length\r\n\t\trequire(\r\n\t\t\t(value == 0) || (token.allowance(address(this), spender) == 0),\r\n\t\t\t\"SafeERC20: approve from non-zero to non-zero allowance\"\r\n\t\t);\r\n\t\tcallOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(token.approve.selector, spender, value)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction safeIncreaseAllowance(IERC20 token, address spender, uint256 value)\r\n\t\tinternal\r\n\t{\r\n\t\tuint256 newAllowance = token.allowance(address(this), spender).add(\r\n\t\t\tvalue\r\n\t\t);\r\n\t\tcallOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\ttoken.approve.selector,\r\n\t\t\t\tspender,\r\n\t\t\t\tnewAllowance\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction safeDecreaseAllowance(IERC20 token, address spender, uint256 value)\r\n\t\tinternal\r\n\t{\r\n\t\tuint256 newAllowance = token.allowance(address(this), spender).sub(\r\n\t\t\tvalue\r\n\t\t);\r\n\t\tcallOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\ttoken.approve.selector,\r\n\t\t\t\tspender,\r\n\t\t\t\tnewAllowance\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n\t * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n\t * @param token The token targeted by the call.\r\n\t * @param data The call data (encoded using abi.encode or one of its variants).\r\n\t */\r\n\tfunction callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n\t\t// we're implementing it ourselves.\r\n\r\n\t\t// A Solidity high level call has three parts:\r\n\t\t//  1. The target address is checked to verify it contains contract code\r\n\t\t//  2. The call itself is made, and success asserted\r\n\t\t//  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\t\t// solhint-disable-next-line max-line-length\r\n\t\t// TODO: implement later\r\n\t\t// require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n\t\t// solhint-disable-next-line avoid-low-level-calls\r\n\t\t(bool success, bytes memory returndata) = address(token).call(data);\r\n\t\trequire(success, \"SafeERC20: low-level call failed\");\r\n\r\n\t\tif (returndata.length > 0) {\r\n\t\t\t// Return data is optional\r\n\t\t\t// solhint-disable-next-line max-line-length\r\n\t\t\trequire(\r\n\t\t\t\tabi.decode(returndata, (bool)),\r\n\t\t\t\t\"SafeERC20: ERC20 operation did not succeed\"\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n\tstruct Role {\r\n\t\tmapping(address => bool) bearer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Give an account access to this role.\r\n\t */\r\n\tfunction add(Role storage _role, address _account) internal {\r\n\t\trequire(!has(_role, _account), \"Roles: account already has role\");\r\n\t\t_role.bearer[_account] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove an account's access to this role.\r\n\t */\r\n\tfunction remove(Role storage _role, address _account) internal {\r\n\t\trequire(has(_role, _account), \"Roles: account does not have role\");\r\n\t\t_role.bearer[_account] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if an account has this role.\r\n\t * @return bool\r\n\t */\r\n\tfunction has(Role storage _role, address _account)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bool)\r\n\t{\r\n\t\trequire(_account != address(0), \"Roles: account is the zero address\");\r\n\t\treturn _role.bearer[_account];\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() internal {\r\n\t\t_owner = msg.sender;\r\n\t\temit OwnershipTransferred(address(0), _owner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the caller is the current owner.\r\n\t */\r\n\tfunction isOwner() public view returns (bool) {\r\n\t\treturn msg.sender == _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t */\r\n\tfunction _transferOwnership(address newOwner) internal {\r\n\t\trequire(\r\n\t\t\tnewOwner != address(0),\r\n\t\t\t\"Ownable: new owner is the zero address\"\r\n\t\t);\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\n\r\ncontract Operator is Ownable {\r\n\tusing Roles for Roles.Role;\r\n\r\n\tRoles.Role private _operators;\r\n\r\n\taddress[] private _operatorsListed;\r\n\r\n\tmapping(address => uint256) _operatorIndexs;\r\n\r\n\tevent OperatorAdded(address indexed account);\r\n\tevent OperatorRemoved(address indexed account);\r\n\r\n\tmodifier onlyOperator() {\r\n\t\trequire(\r\n\t\t\tisOperator(msg.sender),\r\n\t\t\t\"caller does not have the Operator role\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor() public {\r\n\t\t_addOperator(msg.sender);\r\n\t}\r\n\r\n\tfunction getAllOperators() public view returns(address[] memory operators) {\r\n\t\toperators = new address[](_operatorsListed.length);\r\n\t\tuint256 counter = 0;\r\n\t\tfor (uint256 i = 0; i < _operatorsListed.length; i++) {\r\n\t\t\tif (isOperator(_operatorsListed[i])) {\r\n\t\t\t\toperators[counter] = _operatorsListed[i];\r\n\t\t\t\tcounter++;\r\n\t\t\t}\r\n\t\t}\r\n\t  return operators;\r\n\t}\r\n\r\n\tfunction isOperator(address _account) public view returns (bool) {\r\n\t\treturn _operators.has(_account);\r\n\t}\r\n\r\n\tfunction addOperator(address _account) public onlyOwner {\r\n\t\t_addOperator(_account);\r\n\t}\r\n\r\n\tfunction batchAddOperators(address[] memory _accounts) public onlyOwner {\r\n\t\tuint256 arrayLength = _accounts.length;\r\n\t\tfor (uint256 i = 0; i < arrayLength; i++) {\r\n\t\t\t_addOperator(_accounts[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removeOperator(address _account) public onlyOwner {\r\n\t\t_removeOperator(_account);\r\n\t}\r\n\r\n\tfunction batchRemoveOperators(address[] memory _accounts)\r\n\t\tpublic\r\n\t\tonlyOwner\r\n\t{\r\n\t\tuint256 arrayLength = _accounts.length;\r\n\t\tfor (uint256 i = 0; i < arrayLength; i++) {\r\n\t\t\t_removeOperator(_accounts[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction renounceOperator() public {\r\n\t\t_removeOperator(msg.sender);\r\n\t}\r\n\r\n\tfunction _addOperator(address _account) internal {\r\n\t\t_operators.add(_account);\r\n\t\tif (_operatorIndexs[_account] == 0) {\r\n\t\t  _operatorsListed.push(_account);\r\n\t\t  _operatorIndexs[_account] = _operatorsListed.length;\r\n\t\t}\r\n\t\temit OperatorAdded(_account);\r\n\t}\r\n\r\n\tfunction _removeOperator(address _account) internal {\r\n\t\t_operators.remove(_account);\r\n\t\temit OperatorRemoved(_account);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Ownable {\r\n\t/**\r\n\t * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n\t */\r\n\tevent Paused(address account);\r\n\r\n\t/**\r\n\t * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n\t */\r\n\tevent Unpaused(address account);\r\n\r\n\tbool private _paused;\r\n\r\n\t/**\r\n\t * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n\t * to the deployer.\r\n\t */\r\n\tconstructor() internal {\r\n\t\t_paused = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the contract is paused, and false otherwise.\r\n\t */\r\n\tfunction paused() public view returns (bool) {\r\n\t\treturn _paused;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is not paused.\r\n\t */\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!_paused, \"Pausable: paused\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is paused.\r\n\t */\r\n\tmodifier whenPaused() {\r\n\t\trequire(_paused, \"Pausable: not paused\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Called by a pauser to pause, triggers stopped state.\r\n\t */\r\n\tfunction pause() public onlyOwner whenNotPaused {\r\n\t\t_paused = true;\r\n\t\temit Paused(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Called by a pauser to unpause, returns to normal state.\r\n\t */\r\n\tfunction unpause() public onlyOwner whenPaused {\r\n\t\t_paused = false;\r\n\t\temit Unpaused(msg.sender);\r\n\t}\r\n}\r\n\r\n\r\ninterface IAdvanceCrowdsale {\r\n  function updatePurchasingState(address beneficiary, uint256 tokenAmount) external returns(bool);\r\n}\r\n\r\n\r\n\r\ncontract TimeLockFactory is Operator, Pausable {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\t// ERC20 basic token contract being held\r\n\tIERC20 private _token;\r\n\r\n\t// time when the token was deployed to the network\r\n\tuint256 private _globalReleaseTime;\r\n\r\n\t// storage list of the beneficiary addresses\r\n\taddress[] private _lockupBeneficiaries;\r\n\r\n\t// storage list of bundle identifies\r\n\tuint256[] private _bundleIdentifies;\r\n\r\n\t// storage list of lockup phases\r\n\tLockupPhase[] private _lockupPhases;\r\n\r\n\t// finalized state\r\n\tbool private _finalized;\r\n\r\n\t// smart contract version\r\n\tstring public constant version = \"1.0\";\r\n\r\n\tuint256 public constant TOTAL_PERCENTAGE = 1000; // mean 10x percent 1000 = 100%\r\n\r\n\t// storage lockup phase detail\r\n\tstruct LockupPhase {\r\n\t\tuint256 id;\r\n\t\tuint256 percentage;\r\n\t\tuint256 extraTime;\r\n\t\tuint256 unlockedCount;\r\n\t\tbool hasWithdrawal;\r\n\t}\r\n\r\n\t// storage lockup bundle detail\r\n\tstruct LockupBundle {\r\n\t\tuint256 id;\r\n\t\taddress beneficiary;\r\n\t\tuint256 amount;\r\n\t\tmapping(uint256 => bool) isPhaseWithdrawns;\r\n\t}\r\n\r\n\t// storage bundle id of beneficiary address\r\n\tmapping(address => uint256[]) private _lockupIdsOfBeneficiary;\r\n\r\n\t// storage lockup bundle by bundle id\r\n\tmapping(uint256 => LockupBundle) private _lockupBundles;\r\n\r\n\t// storage phase index\r\n\tmapping(uint256 => uint256) private _phaseIndexs;\r\n\r\n\t// storage process state of transaction id\r\n\tmapping(string => uint256) private _processedTxids;\r\n\r\n\tevent TokenLocked(address _beneficiary, uint256 _amount);\r\n\r\n\tevent TimeLockFactoryFinalized();\r\n\r\n\tmodifier whenNotFinalized() {\r\n\t\trequire(!_finalized, \"TimeLockFactory: finalized\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor(IERC20 token) public {\r\n\t\t_token = token;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the token being held.\r\n\t */\r\n\tfunction token() public view returns (IERC20) {\r\n\t\treturn _token;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the global release time.\r\n\t */\r\n\tfunction globalReleaseTime() public view returns (uint256) {\r\n\t\treturn _globalReleaseTime;\r\n\t}\r\n\r\n\t/**\r\n\t * @return true if the crowdsale is finalized, false otherwise.\r\n\t */\r\n\tfunction finalized() public view returns (bool) {\r\n\t\treturn _finalized;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the total of the beneficiary addresses\r\n\t */\r\n\tfunction getTotalBeneficiaries() public view returns (uint256) {\r\n\t\treturn _lockupBeneficiaries.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the total of the bundle identifies\r\n\t */\r\n\tfunction getTotalBundleIdentifies() public view returns (uint256) {\r\n\t\treturn _bundleIdentifies.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @param _beneficiary beneficiary address\r\n\t * @return the total of the bundle identifies if beneficiary address\r\n\t */\r\n\tfunction getTotalBundleIdentifiesOf(address _beneficiary) public view returns (uint256) {\r\n\t\treturn _lockupIdsOfBeneficiary[_beneficiary].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @param _startIndex start index\r\n\t * @param _endIndex end index\r\n\t * @param _revert sort array asc or desc\r\n\t * @return the list of the beneficiary addresses\r\n\t */\r\n\tfunction paginationBeneficiaries(uint256 _startIndex, uint256 _endIndex, bool _revert) public view returns (address[] memory) {\r\n\t\tuint256 startIndex = _startIndex;\r\n\t\tuint256 endIndex = _endIndex;\r\n\t\tif (startIndex >= _lockupBeneficiaries.length) {\r\n\t\t\treturn new address[](0);\r\n\t\t}\r\n\t\tif (endIndex > _lockupBeneficiaries.length) {\r\n\t\t\tendIndex = _lockupBeneficiaries.length;\r\n\t\t}\r\n\t\t// make memory array\r\n\t\taddress[] memory beneficiaries = new address[](endIndex.sub(startIndex));\r\n\t\tif (_revert) {\r\n\t\t\tfor (uint256 i = endIndex; i > startIndex; i--) {\r\n\t\t\t\tbeneficiaries[endIndex.sub(i)] = _lockupBeneficiaries[i.sub(1)];\r\n\t\t\t}\r\n\t\t\treturn beneficiaries;\r\n\t\t}\r\n\t\tfor (uint256 i = startIndex; i < endIndex; i++) {\r\n\t\t\tbeneficiaries[i.sub(startIndex)] = _lockupBeneficiaries[i];\r\n\t\t}\r\n\t\treturn beneficiaries;\r\n\t}\r\n\r\n\t/**\r\n\t * @param _startIndex start index\r\n\t * @param _endIndex end index\r\n\t * @param _revert sort array asc or desc\r\n\t * @return the list of the bundle identifies\r\n\t */\r\n\tfunction paginationBundleIdentifies(uint256 _startIndex, uint256 _endIndex, bool _revert) public view returns (uint256[] memory) {\r\n\t\tuint256 startIndex = _startIndex;\r\n\t\tuint256 endIndex = _endIndex;\r\n\t\tif (startIndex >= _bundleIdentifies.length) {\r\n\t\t\treturn new uint256[](0);\r\n\t\t}\r\n\t\tif (endIndex > _bundleIdentifies.length) {\r\n\t\t\tendIndex = _bundleIdentifies.length;\r\n\t\t}\r\n\r\n\t\t// make memory array\r\n\t\tuint256[] memory identifies = new uint256[](endIndex.sub(startIndex));\r\n\t\tif (_revert) {\r\n\t\t\tfor (uint256 i = endIndex; i > startIndex; i--) {\r\n\t\t\t\tidentifies[endIndex.sub(i)] = _bundleIdentifies[i.sub(1)];\r\n\t\t\t}\r\n\t\t\treturn identifies;\r\n\t\t}\r\n\t\tfor (uint256 i = startIndex; i < endIndex; i++) {\r\n\t\t\tidentifies[i.sub(startIndex)] = _bundleIdentifies[i];\r\n\t\t}\r\n\t\treturn identifies;\r\n\t}\r\n\r\n\t/**\r\n\t * @param _beneficiary beneficiary address\r\n\t * @param _startIndex start index\r\n\t * @param _endIndex end index\r\n\t * @param _revert sort array asc or desc\r\n\t * @return the list of the bundle identifies of beneficiary address\r\n\t */\r\n\tfunction paginationBundleIdentifiesOf(address _beneficiary, uint256 _startIndex, uint256 _endIndex, bool _revert) public view returns (uint256[] memory) {\r\n\t\tuint256 startIndex = _startIndex;\r\n\t\tuint256 endIndex = _endIndex;\r\n\t\tif (startIndex >= _lockupIdsOfBeneficiary[_beneficiary].length) {\r\n\t\t\treturn new uint256[](0);\r\n\t\t}\r\n\t\tif (endIndex >= _lockupIdsOfBeneficiary[_beneficiary].length) {\r\n\t\t\tendIndex = _lockupIdsOfBeneficiary[_beneficiary].length;\r\n\t\t}\r\n\t\t// make memory array\r\n\t\tuint256[] memory identifies = new uint256[](endIndex.sub(startIndex));\r\n\t\tif (_revert) {\r\n\t\t\tfor (uint256 i = endIndex; i > startIndex; i--) {\r\n\t\t\t\tidentifies[endIndex.sub(i)] = _lockupIdsOfBeneficiary[_beneficiary][i.sub(1)];\r\n\t\t\t}\r\n\t\t\treturn identifies;\r\n\t\t}\r\n\t\tfor (uint256 i = startIndex; i < endIndex; i++) {\r\n\t\t\tidentifies[i.sub(startIndex)] = _lockupIdsOfBeneficiary[_beneficiary][i];\r\n\t\t}\r\n\t\treturn identifies;\r\n\t}\r\n\r\n\t/**\r\n\t * @param _id bundle id\r\n\t * @return the bundle detail\r\n\t */\r\n\tfunction getBundleDetailById(uint256 _id) public view returns (uint256 id, address beneficiary, uint256 amount, uint256[] memory phaseIdentifies, bool[] memory isPhaseWithdrawns) {\r\n\t\tLockupBundle storage bundle = _lockupBundles[_id];\r\n\t\tid = bundle.id;\r\n\t\tbeneficiary = bundle.beneficiary;\r\n\t\tamount = bundle.amount;\r\n\t\tphaseIdentifies = new uint256[](_lockupPhases.length);\r\n\t\tisPhaseWithdrawns = new bool[](_lockupPhases.length);\r\n\t\tfor (uint256 i = 0; i < _lockupPhases.length; i++) {\r\n\t\t\tphaseIdentifies[i] = _lockupPhases[i].id;\r\n\t\t\tisPhaseWithdrawns[i] = bundle.isPhaseWithdrawns[_lockupPhases[i].id];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return the all phases detail\r\n\t */\r\n\tfunction getLockupPhases() public view returns (uint256[] memory ids, uint256[] memory percentages, uint256[] memory extraTimes, bool[] memory hasWithdrawals, bool[] memory canWithdrawals) {\r\n\t\tids = new uint256[](_lockupPhases.length);\r\n\t\tpercentages = new uint256[](_lockupPhases.length);\r\n\t\textraTimes = new uint256[](_lockupPhases.length);\r\n\t\thasWithdrawals = new bool[](_lockupPhases.length);\r\n\t\tcanWithdrawals = new bool[](_lockupPhases.length);\r\n\r\n\t\tfor (uint256 i = 0; i < _lockupPhases.length; i++) {\r\n\t\t\tLockupPhase memory phase = _lockupPhases[i];\r\n\t\t\tids[i] = phase.id;\r\n\t\t\tpercentages[i] = phase.percentage;\r\n\t\t\textraTimes[i] = phase.extraTime;\r\n\t\t\thasWithdrawals[i] = phase.hasWithdrawal;\r\n\t\t\tcanWithdrawals[i] = checkPhaseCanWithdrawal(phase.id);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param _id phase id\r\n\t * @return the phase detail\r\n\t */\r\n\tfunction getLockupPhaseDetail(uint256 _id) public view returns (uint256 id, uint256 percentage, uint256 extraTime, bool hasWithdrawal, bool canWithdrawal) {\r\n\t\tif (_phaseIndexs[_id] > 0) {\r\n\t\t\tLockupPhase memory phase = _lockupPhases[_phaseIndexs[_id].sub(1)];\r\n\t\t\tid = phase.id;\r\n\t\t\tpercentage = phase.percentage;\r\n\t\t\textraTime = phase.extraTime;\r\n\t\t\thasWithdrawal = phase.hasWithdrawal;\r\n\t\t\tcanWithdrawal = checkPhaseCanWithdrawal(_id);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param _id phase id\r\n\t * @return the withdrawal state of phase\r\n\t */\r\n\tfunction checkPhaseCanWithdrawal(uint256 _id) public view returns (bool) {\r\n\t\tif (_phaseIndexs[_id] == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tLockupPhase memory phase = _lockupPhases[_phaseIndexs[_id].sub(1)];\r\n\t\treturn !phase.hasWithdrawal && _globalReleaseTime.add(phase.extraTime) <= block.timestamp;\r\n\t}\r\n\r\n\t/**\r\n\t * @param _id phase id\r\n\t * @return the withdrawal state of phase\r\n\t */\r\n\tfunction checkPhaseHasWithdrawal(uint256 _id) internal view returns (bool) {\r\n\t\tif (_phaseIndexs[_id] == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tLockupPhase memory phase = _lockupPhases[_phaseIndexs[_id].sub(1)];\r\n\t\treturn phase.hasWithdrawal;\r\n\t}\r\n\r\n\t/**\r\n\t * @param _txid transaction hash\r\n\t * @return the process state of transaction id\r\n\t */\r\n\tfunction hasProcessedTxid(string memory _txid) public view returns (bool) {\r\n\t\treturn _processedTxids[_txid] != 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Lockup Phases Start\r\n\t * ===============================================================================\r\n\t */\r\n\r\n\tfunction setLockupPhases(uint256[] memory _ids, uint256[] memory _percentages, uint256[] memory _extraTimes) public whenNotPaused whenNotFinalized {\r\n\t\trequire(isOwner() || isOperator(msg.sender), \"TimeLockFactory: caller is not the owner or operator\");\r\n\t\trequire(_ids.length == _percentages.length && _ids.length == _extraTimes.length, \"TimeLockFactory:: Cannot match inputs\");\r\n\t\t_preValidateLockupPhases(_percentages);\r\n\t\tfor (uint256 i = 0; i < _ids.length; i++) {\r\n\t\t\tif (!checkPhaseHasWithdrawal(_ids[i])) {\r\n\t\t\t\t_setLockupPhase(_ids[i], _percentages[i], _extraTimes[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _setLockupPhase(uint256 _id, uint256 _percentage, uint256 _extraTime) internal {\r\n\t\trequire(_id > 0, \"TimeLockFactory: Phase ID is zero\");\r\n\t\trequire(_percentage > 0, \"TimeLockFactory: Percentage is zero\");\r\n\t\trequire(_extraTime > 0, \"TimeLockFactory: ExtraTime is zero\");\r\n\t\t// require(_globalReleaseTime.add(_extraTime) > block.timestamp, \"TimeLockFactory: Unlock time is before current\");\r\n\r\n\t\tLockupPhase memory phase = LockupPhase(_id, _percentage, _extraTime, 0, false);\r\n\t\t_lockupPhases.push(phase);\r\n\t\t_phaseIndexs[_id] = _lockupPhases.length;\r\n\t}\r\n\r\n\tfunction _preValidateLockupPhases(uint256[] memory _percentages) internal {\r\n\t\tuint256 totalPercentage = 0;\r\n\t\tfor (uint256 i = 0; i < _percentages.length; i++) {\r\n\t\t\ttotalPercentage = totalPercentage.add(_percentages[i]);\r\n\t\t}\r\n\t\trequire(totalPercentage == TOTAL_PERCENTAGE, \"TimeLockFactory: Total percentage is not valid\");\r\n\t\t// init tmp phase\r\n\t\tLockupPhase[] memory _tempPhases = new LockupPhase[](_lockupPhases.length);\r\n\t\tfor (uint256 i = 0; i < _lockupPhases.length; i++) {\r\n\t\t\t_tempPhases[i] = _lockupPhases[i];\r\n\t\t}\r\n\t\t// delete all current phases has not withdrawal\r\n\t\t_lockupPhases.length = 0;\r\n\t\t// add phase has withdrawal\r\n\t\tfor (uint256 i = 0; i < _tempPhases.length; i++) {\r\n\t\t\tif (_tempPhases[i].hasWithdrawal) {\r\n\t\t\t\t_lockupPhases.push(_tempPhases[i]);\r\n\t\t\t\t_phaseIndexs[_tempPhases[i].id] = _lockupPhases.length;\r\n\t\t\t} else {\r\n\t\t\t\t_phaseIndexs[_tempPhases[i].id] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Lockup Phases End\r\n\t * ===============================================================================\r\n\t */\r\n\r\n\t/**\r\n\t * Lockup Bundles Start\r\n\t * ===============================================================================\r\n\t */\r\n\r\n\tfunction lock(uint256 _id, address _beneficiary, uint256 _amount, address _saleAddress) public whenNotPaused whenNotFinalized {\r\n\t\trequire(isOwner() || isOperator(msg.sender), \"TimeLockFactory: caller is not the owner or operator\");\r\n\t\t_lock(_id, _beneficiary, _amount, _saleAddress);\r\n\t}\r\n\r\n\tfunction lock(uint256 _id, address _beneficiary, uint256 _amount, address _saleAddress, string memory _txid) public whenNotPaused whenNotFinalized {\r\n\t\trequire(isOwner() || isOperator(msg.sender), \"TimeLockFactory: caller is not the owner or operator\");\r\n\t\trequire(_processedTxids[_txid] == 0, \"TimeLockFactory: Txid is processed or empty\");\r\n\t\t_lock(_id, _beneficiary, _amount, _saleAddress);\r\n\t\t_processedTxids[_txid] = _id;\r\n\t}\r\n\r\n\tfunction _lock(uint256 _id, address _beneficiary, uint256 _amount, address _saleAddress) internal {\r\n\t\t_preValidateLockup(_id, _beneficiary, _amount);\r\n\r\n\t\t_processLockup(_id, _beneficiary, _amount);\r\n\r\n\t\temit TokenLocked(_beneficiary, _amount);\r\n\r\n\t\t_postUnlockIfAvailable(_id, _beneficiary, _amount, _saleAddress);\r\n\t}\r\n\r\n\tfunction hasEnoughTokenBeforeLockup(uint256 _amount) public view returns (bool hasEnough, uint256 requiredAmount) {\r\n\t\tuint256 unlockedPercentage = 0;\r\n\t\tfor (uint256 i = 0; i < _lockupPhases.length; i++) {\r\n\t\t\tLockupPhase memory phase = _lockupPhases[i];\r\n\t\t\tif (phase.hasWithdrawal) {\r\n\t\t\t\tunlockedPercentage = unlockedPercentage.add(phase.percentage);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 unlockedAmount = _amount.mul(unlockedPercentage).div(TOTAL_PERCENTAGE);\r\n\t\tif (_token.balanceOf(address(this)) >= unlockedAmount) {\r\n\t\t\treturn (true, 0);\r\n\t\t}\r\n\t\treturn (false, unlockedAmount);\r\n\t}\r\n\r\n\tfunction _preValidateLockup(uint256 _id, address _beneficiary, uint256 _amount) internal view {\r\n\t\trequire(_id > 0, \"TimeLockFactory: Bundle ID is zero\");\r\n\t\trequire(_beneficiary != address(0), \"TimeLockFactory: Beneficiary is zero address\");\r\n\t\trequire(_amount > 0, \"TimeLockFactory: Amount is zero\");\r\n\r\n\t\tLockupBundle memory _existedBundle = _lockupBundles[_id];\r\n\t\trequire(_existedBundle.id == 0, \"TimeLockFactory: Bundle ID has already existed\");\r\n\t\t(bool hasEnough, ) = hasEnoughTokenBeforeLockup(_amount);\r\n\t\trequire(hasEnough, \"TimeLockFactory: Balance not enough\");\r\n\t}\r\n\r\n\tfunction _processLockup(uint256 _id, address _beneficiary, uint256 _amount) internal {\r\n\t\tLockupBundle memory bundle = LockupBundle(_id, _beneficiary, _amount);\r\n\t\t_lockupBundles[_id] = bundle;\r\n\t\tif (_lockupIdsOfBeneficiary[_beneficiary].length == 0) {\r\n\t\t\t_lockupBeneficiaries.push(_beneficiary);\r\n\t\t}\r\n\t\t_bundleIdentifies.push(_id);\r\n\t\t_lockupIdsOfBeneficiary[_beneficiary].push(_id);\r\n\t}\r\n\r\n\tfunction _postUnlockIfAvailable(uint256 _id, address _beneficiary, uint256 _amount, address _saleAddress) internal {\r\n\t\tIAdvanceCrowdsale(_saleAddress).updatePurchasingState(_beneficiary, _amount);\r\n\r\n\t\tuint256 unlockedPercentage = 0;\r\n\t\tfor (uint256 i = 0; i < _lockupPhases.length; i++) {\r\n\t\t\tLockupPhase memory phase = _lockupPhases[i];\r\n\t\t\tif (phase.hasWithdrawal) {\r\n\t\t\t\tunlockedPercentage = unlockedPercentage.add(phase.percentage);\r\n\t\t\t\t_lockupBundles[_id].isPhaseWithdrawns[phase.id] = true;\r\n\t\t\t} else {\r\n\t\t\t\t_lockupBundles[_id].isPhaseWithdrawns[phase.id] = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 unlockedAmount = _amount.mul(unlockedPercentage).div(TOTAL_PERCENTAGE);\r\n\t\tif (unlockedAmount > 0) {\r\n\t\t\t_token.safeTransfer(_beneficiary, unlockedAmount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unlocks(uint256 _phaseId, uint256 _limit) public whenNotPaused whenNotFinalized {\r\n\t\trequire(isOwner() || isOperator(msg.sender), \"TimeLockFactory: caller is not the owner or operator\");\r\n\t\trequire(_phaseId > 0, \"TimeLockFactory: Phase ID is zero\");\r\n\t\trequire(_limit > 0, \"TimeLockFactory: Must set maximum bundles per unlock\");\r\n\t\trequire(_phaseIndexs[_phaseId] > 0, \"TimeLockFactory: Phase ID not existed\");\r\n\r\n\t\t_preUnlockPhase(_phaseId, _limit);\r\n\r\n\t\t_processUnlocks(_phaseId, _limit);\r\n\t}\r\n\r\n\tfunction hasEnoughTokenBeforeUnlock(uint256 _phaseId, uint256 _limit) public view returns (bool hasEnough, uint256 requiredAmount) {\r\n\t\tif (_phaseIndexs[_phaseId] == 0) {\r\n\t\t\treturn (false, 0);\r\n\t\t}\r\n\r\n\t\tuint256 totalUnlockAmount = 0;\r\n\t\tuint256 _limitCounter = 0;\r\n\t\tLockupPhase storage phase = _lockupPhases[_phaseIndexs[_phaseId].sub(1)];\r\n\t\tfor (uint256 i = phase.unlockedCount; i < _bundleIdentifies.length; i++) {\r\n\t\t\tLockupBundle storage bundle = _lockupBundles[_bundleIdentifies[i]];\r\n\t\t\t// skip if bundle has withdrawal\r\n\t\t\tif (bundle.isPhaseWithdrawns[_phaseId]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// calculate amount\r\n\t\t\tuint256 unlockAmount = bundle.amount.mul(phase.percentage).div(TOTAL_PERCENTAGE);\r\n\t\t\ttotalUnlockAmount = totalUnlockAmount.add(unlockAmount);\r\n\t\t\t// increase counter\r\n\t\t\t_limitCounter = _limitCounter.add(1);\r\n\t\t\tif (_limitCounter == _limit) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (_token.balanceOf(address(this)) >= totalUnlockAmount) {\r\n\t\t\treturn (true, 0);\r\n\t\t}\r\n\t\treturn (false, totalUnlockAmount);\r\n\t}\r\n\r\n\tfunction _preUnlockPhase(uint256 _phaseId, uint256 _limit) internal view {\r\n\t\tLockupPhase storage phase = _lockupPhases[_phaseIndexs[_phaseId].sub(1)];\r\n\t\trequire(phase.id > 0, \"TimeLockFactory: Phase does not exist\");\r\n\t\trequire(!phase.hasWithdrawal, \"TimeLockFactory: Phase was unlocked\");\r\n\t\trequire(_globalReleaseTime.add(phase.extraTime) <= block.timestamp, \"TimeLockFactory: Phase is locking\");\r\n\t\t(bool hasEnough, ) = hasEnoughTokenBeforeUnlock(_phaseId, _limit);\r\n\t\trequire(hasEnough, \"TimeLockFactory: Balance not enough\");\r\n\t}\r\n\r\n\tfunction _processUnlocks(uint256 _phaseId, uint256 _limit) internal {\r\n\t\tuint256 _limitCounter = 0;\r\n\t\tLockupPhase storage phase = _lockupPhases[_phaseIndexs[_phaseId].sub(1)];\r\n\t\tfor (uint256 i = phase.unlockedCount; i < _bundleIdentifies.length; i++) {\r\n\t\t\tLockupBundle storage bundle = _lockupBundles[_bundleIdentifies[i]];\r\n\t\t\t// skip if bundle has withdrawal\r\n\t\t\tif (bundle.isPhaseWithdrawns[_phaseId]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// transfer token\r\n\t\t\tuint256 unlockAmount = bundle.amount.mul(phase.percentage).div(TOTAL_PERCENTAGE);\r\n\t\t\t_token.safeTransfer(bundle.beneficiary, unlockAmount);\r\n\t\t\tbundle.isPhaseWithdrawns[_phaseId] = true;\r\n\t\t\t// increase counter\r\n\t\t\tphase.unlockedCount = phase.unlockedCount.add(1);\r\n\t\t\t_limitCounter = _limitCounter.add(1);\r\n\t\t\t// break if counter equal limit\r\n\t\t\tif (_limitCounter == _limit) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (phase.unlockedCount >= _bundleIdentifies.length) {\r\n\t\t\tphase.hasWithdrawal = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Lockup Bundle End\r\n\t * ===============================================================================\r\n\t */\r\n\r\n\t/**\r\n\t * @dev Set global release time of the token\r\n\t * @param _globalTime the global timee to release token\r\n\t */\r\n\tfunction setGlobalReleaseTime(uint256 _globalTime) public onlyOwner whenNotFinalized {\r\n\t\t_globalReleaseTime = _globalTime;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Use to withdrawal token to owner\r\n\t * @param _amount the withdrawal amount\r\n\t */\r\n\tfunction withdrawal(uint256 _amount) public onlyOwner whenNotFinalized {\r\n\t\trequire(_amount > 0, \"TimeLockFactory: Amount is 0\");\r\n\t\trequire(_token.balanceOf(address(this)) >= _amount, \"TimeLockFactory: Balance not enough\");\r\n\t\t_token.safeTransfer(msg.sender, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Must be called after current phase ends, to do some extra finalization\r\n\t * work. Calls the contract's finalization function.\r\n\t */\r\n\tfunction finalize() public onlyOwner whenNotFinalized {\r\n\t\t_finalized = true;\r\n\t\t_finalization();\r\n\t\temit TimeLockFactoryFinalized();\r\n\t}\r\n\r\n\tfunction _finalization() internal {\r\n\t\tuint256 amount = _token.balanceOf(address(this));\r\n\t\tif (amount != 0) {\r\n\t\t\t_token.safeTransfer(msg.sender, amount);\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TimeLockFactoryFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"batchAddOperators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"batchRemoveOperators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"checkPhaseCanWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getBundleDetailById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"phaseIdentifies\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isPhaseWithdrawns\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getLockupPhaseDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasWithdrawal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canWithdrawal\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLockupPhases\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"percentages\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"extraTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"hasWithdrawals\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"canWithdrawals\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalBeneficiaries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalBundleIdentifies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getTotalBundleIdentifiesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalReleaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"hasEnoughTokenBeforeLockup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasEnough\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"requiredAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"hasEnoughTokenBeforeUnlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasEnough\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"requiredAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_txid\",\"type\":\"string\"}],\"name\":\"hasProcessedTxid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_saleAddress\",\"type\":\"address\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_saleAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_txid\",\"type\":\"string\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_revert\",\"type\":\"bool\"}],\"name\":\"paginationBeneficiaries\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_revert\",\"type\":\"bool\"}],\"name\":\"paginationBundleIdentifies\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_revert\",\"type\":\"bool\"}],\"name\":\"paginationBundleIdentifiesOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_globalTime\",\"type\":\"uint256\"}],\"name\":\"setGlobalReleaseTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percentages\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_extraTimes\",\"type\":\"uint256[]\"}],\"name\":\"setLockupPhases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"unlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TimeLockFactory","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000019c8ac33cb42c67ce69bcf4e52466a955d46f866","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c56e85b11fc229e3973486d2230583a33c7d877f74d312e77a45073fed4921d3"}]}