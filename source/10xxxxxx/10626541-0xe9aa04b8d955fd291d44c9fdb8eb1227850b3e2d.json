{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/Interfaces/PriceCalculatorInterface.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\ninterface PriceCalculatorInterface {\r\n    function calculatePrice(\r\n        uint256 buyAmount,\r\n        uint256 buyAmountLimit,\r\n        uint256 sellAmount,\r\n        uint256 sellAmountLimit,\r\n        uint256 baseTokenPool,\r\n        uint256 settlementTokenPool\r\n    ) external view returns (uint256[5] memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Libraries/RateMath.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\nlibrary RateMath {\r\n    using SafeMath for uint256;\r\n    uint256 public constant RATE_POINT_MULTIPLIER = 1000000000000000000; // 10^18\r\n\r\n    function getRate(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a.mul(RATE_POINT_MULTIPLIER).div(b);\r\n    }\r\n\r\n    function divByRate(uint256 self, uint256 rate)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return self.mul(RATE_POINT_MULTIPLIER).div(rate);\r\n    }\r\n\r\n    function mulByRate(uint256 self, uint256 rate)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return self.mul(rate).div(RATE_POINT_MULTIPLIER);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/PriceCalculator.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n\r\n\r\n\r\n\r\ncontract PriceCalculator is PriceCalculatorInterface {\r\n    using RateMath for uint256;\r\n    using SafeMath for uint256;\r\n    using SafeCast for uint256;\r\n    uint256 public constant TOLERANCE_RATE = 1001000000000000000; //= 100.1%\r\n    uint256 public constant SECURE_RATE = 1050000000000000000; //105% max slippage for all orders\r\n    uint256 public constant DECIMAL = 1000000000000000000;\r\n\r\n    /**\r\n     * @notice calculates and return price, and refund rates\r\n     * @param AmountFLEX0_1 Amount of flex order of token0 to token1\r\n     * @param AmountSTRICT0_1 Amount of strict order of token0 to token1\r\n     * @param AmountFLEX1_0  Amount of flex order of token1 to token0\r\n     * @param AmountSTRICT1_0 Amount of strict order of token1 to token0\r\n     * @param reserve0 Amount of reserve0\r\n     * @param reserve1 Amount of reserve1\r\n     * @return [price, refundStatus, partiallyRefundRate, executed amount of token0 to token1, executed amount of token1 to token0]\r\n     * @dev Refund for careful users if change of price is bigger than TORELANCE_RATE\r\n     * @dev Refund for all traders if change of price is bigger than SECURE_RATE\r\n     **/\r\n    function calculatePrice(\r\n        uint256 AmountFLEX0_1,\r\n        uint256 AmountSTRICT0_1,\r\n        uint256 AmountFLEX1_0,\r\n        uint256 AmountSTRICT1_0,\r\n        uint256 reserve0,\r\n        uint256 reserve1\r\n    ) external override view returns (uint256[5] memory) {\r\n        require(\r\n            reserve0 != 0 && reserve1 != 0,\r\n            \"There are no reserves. Please add liquidity or redeploy exchange\"\r\n        );\r\n        // initial price = reserve1 / reserve0\r\n        // price = (reserve1 + sell order amount) / (reserve0 + sell order amount)\r\n        uint256 price = (reserve1.add(AmountFLEX1_0).add(AmountSTRICT1_0))\r\n            .divByRate(reserve0.add(AmountFLEX0_1).add(AmountSTRICT0_1));\r\n        // initial low Price is price of Limit order(initial price / 1.001)\r\n        uint256 lowPrice = (reserve1.divByRate(reserve0)).divByRate(\r\n            TOLERANCE_RATE\r\n        );\r\n        // initial high Price is price of Limit order(initial price * 1.001)\r\n        uint256 highPrice = (reserve1.divByRate(reserve0)).mulByRate(\r\n            TOLERANCE_RATE\r\n        );\r\n        // if initial price is within the TORELANCE_RATE, return initial price and execute all orders\r\n        if (price > lowPrice && price < highPrice) {\r\n            return [\r\n                price,\r\n                0,\r\n                0,\r\n                AmountFLEX0_1.add(AmountSTRICT0_1),\r\n                AmountFLEX1_0.add(AmountSTRICT1_0)\r\n            ];\r\n        } else if (price <= lowPrice) {\r\n            return\r\n                _calculatePriceAnd0_1RefundRate(\r\n                    price,\r\n                    lowPrice,\r\n                    AmountFLEX0_1,\r\n                    AmountSTRICT0_1,\r\n                    AmountFLEX1_0.add(AmountSTRICT1_0),\r\n                    reserve0,\r\n                    reserve1\r\n                );\r\n        } else {\r\n            return\r\n                _calculatePriceAnd1_0RefundRate(\r\n                    price,\r\n                    highPrice,\r\n                    AmountFLEX0_1.add(AmountSTRICT0_1),\r\n                    AmountFLEX1_0,\r\n                    AmountSTRICT1_0,\r\n                    reserve0,\r\n                    reserve1\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice calculates price and refund rates if price is lower than `lowPrice`\r\n     * @param price price which is calculated in _calculatePrice()\r\n     * @param lowPrice reserve1 / reserve0 * 0.999\r\n     * @param AmountFLEX0_1 Amount of no-limit token0 to token1\r\n     * @param AmountSTRICT0_1 Amount of limit token0 to token1\r\n     * @param all1_0Amount Amount of all token1 to token0 order. In this function, all token1 to token0 order will be executed\r\n     * @return [price, refundStatus, partiallyRefundRate, executed amount of token0 to token1 order, executed amount of token1 to token0 order]\r\n     **/\r\n    function _calculatePriceAnd0_1RefundRate(\r\n        uint256 price,\r\n        uint256 lowPrice,\r\n        uint256 AmountFLEX0_1,\r\n        uint256 AmountSTRICT0_1,\r\n        uint256 all1_0Amount,\r\n        uint256 reserve0,\r\n        uint256 reserve1\r\n    ) private pure returns (uint256[5] memory) {\r\n        // executeAmount is amount of buy orders in lowPrice(initial price * 0.999)\r\n        uint256 executeAmount = _calculateExecuteAmount0_1(\r\n            reserve0,\r\n            reserve1,\r\n            all1_0Amount,\r\n            lowPrice\r\n        );\r\n\r\n        // if executeAmount > AmountFLEX0_1, (AmountFLEX0_1 - executeAmount) in limit order will be executed\r\n        if (executeAmount > AmountFLEX0_1) {\r\n            uint256 refundRate = (\r\n                AmountFLEX0_1.add(AmountSTRICT0_1).sub(executeAmount)\r\n            )\r\n                .divByRate(AmountSTRICT0_1);\r\n            return [lowPrice, 1, refundRate, executeAmount, all1_0Amount];\r\n        } else {\r\n            // refund all limit buy orders\r\n            // update lowPrice to SECURE_RATE\r\n            uint256 nextLowPrice = (reserve1.divByRate(reserve0)).divByRate(\r\n                SECURE_RATE\r\n            );\r\n            // update price\r\n            price = (reserve1.add(all1_0Amount)).divByRate(\r\n                reserve0.add(AmountFLEX0_1)\r\n            );\r\n            if (nextLowPrice > price) {\r\n                // executeAmount is amount of buy orders when the price is lower than lowPrice (initial price * 0.95)\r\n                executeAmount = _calculateExecuteAmount0_1(\r\n                    reserve0,\r\n                    reserve1,\r\n                    all1_0Amount,\r\n                    nextLowPrice\r\n                );\r\n\r\n                // if executeAmount < AmountFLEX0_1, refund all of limit buy orders and refund some parts of no-limit buy orders\r\n                if (executeAmount < AmountFLEX0_1) {\r\n                    uint256 refundRate = (AmountFLEX0_1.sub(executeAmount))\r\n                        .divByRate(AmountFLEX0_1);\r\n                    return [\r\n                        nextLowPrice,\r\n                        2,\r\n                        refundRate,\r\n                        executeAmount,\r\n                        all1_0Amount\r\n                    ];\r\n                }\r\n            }\r\n            // execute all no-limit buy orders and refund all limit buy orders\r\n            return [price, 1, DECIMAL, AmountFLEX0_1, all1_0Amount];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice calculates price and refund rates if price is higher than highPrice\r\n     * @param price price which is calculated in _calculatePrice()\r\n     * @param highPrice reserve1 / reserve0 * 1.001\r\n     * @param all0_1Amount Amount of all token0 to token1 order. In this function, all token0 to token1 order will be executed\r\n     * @param AmountFLEX1_0  Amount of limit token0 to token1 order.\r\n     * @param AmountSTRICT1_0 Amount of no-limit token1 to token0 order\r\n     * @return [price, refundStatus, partiallyRefundRate, executed amount of token0 to token1 order, executed amount of token1 to token0 order]\r\n     **/\r\n    function _calculatePriceAnd1_0RefundRate(\r\n        uint256 price,\r\n        uint256 highPrice,\r\n        uint256 all0_1Amount,\r\n        uint256 AmountFLEX1_0,\r\n        uint256 AmountSTRICT1_0,\r\n        uint256 reserve0,\r\n        uint256 reserve1\r\n    ) private pure returns (uint256[5] memory) {\r\n        // executeAmount is amount of sell orders when the price is higher than highPrice(initial price * 1.001)\r\n        uint256 executeAmount = _calculateExecuteAmount1_0(\r\n            reserve1,\r\n            reserve0,\r\n            all0_1Amount,\r\n            highPrice\r\n        );\r\n\r\n        if (executeAmount > AmountFLEX1_0) {\r\n            //if executeAmount > AmountFLEX1_0 , (AmountFLEX1_0  - executeAmount) in limit order will be executed\r\n            uint256 refundRate = (\r\n                AmountFLEX1_0.add(AmountSTRICT1_0).sub(executeAmount)\r\n            )\r\n                .divByRate(AmountSTRICT1_0);\r\n            return [highPrice, 3, refundRate, all0_1Amount, executeAmount];\r\n        } else {\r\n            // refund all limit sell orders\r\n            // update highPrice to SECURE_RATE\r\n            uint256 nextHighPrice = (reserve1.divByRate(reserve0)).mulByRate(\r\n                SECURE_RATE\r\n            );\r\n            // update price\r\n            price = (reserve1.add(AmountFLEX1_0)).divByRate(\r\n                reserve0.add(all0_1Amount)\r\n            );\r\n            if (nextHighPrice < price) {\r\n                // executeAmount is amount of sell orders when the price is higher than highPrice(initial price * 1.05)\r\n                executeAmount = _calculateExecuteAmount1_0(\r\n                    reserve1,\r\n                    reserve0,\r\n                    all0_1Amount,\r\n                    nextHighPrice\r\n                );\r\n                // if executeAmount < AmountFLEX1_0 , refund all of limit sell orders and refund some parts of no-limit sell orders\r\n                if (executeAmount < AmountFLEX1_0) {\r\n                    uint256 refundRate = (AmountFLEX1_0.sub(executeAmount))\r\n                        .divByRate(AmountFLEX1_0);\r\n                    return [\r\n                        nextHighPrice,\r\n                        4,\r\n                        refundRate,\r\n                        all0_1Amount,\r\n                        executeAmount\r\n                    ];\r\n                }\r\n            }\r\n            // execute all no-limit sell orders and refund all limit sell orders\r\n            return [price, 3, DECIMAL, all0_1Amount, AmountFLEX1_0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates TOKEN0 amount to execute in price `price`\r\n     **/\r\n    function _calculateExecuteAmount0_1(\r\n        uint256 reserve,\r\n        uint256 opponentReserve,\r\n        uint256 opppnentAmount,\r\n        uint256 price\r\n    ) private pure returns (uint256) {\r\n        uint256 possibleReserve = (opponentReserve.add(opppnentAmount))\r\n            .divByRate(price);\r\n\r\n        if (possibleReserve > reserve) {\r\n            return possibleReserve.sub(reserve);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates TOKEN1 amount to execute in price `price`\r\n     **/\r\n    function _calculateExecuteAmount1_0(\r\n        uint256 reserve,\r\n        uint256 opponentReserve,\r\n        uint256 opppnentAmount,\r\n        uint256 price\r\n    ) private pure returns (uint256) {\r\n        uint256 possibleReserve = (opponentReserve.add(opppnentAmount))\r\n            .mulByRate(price);\r\n\r\n        if (possibleReserve > reserve) {\r\n            return possibleReserve.sub(reserve);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"DECIMAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECURE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOLERANCE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"AmountFLEX0_1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AmountSTRICT0_1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AmountFLEX1_0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AmountSTRICT1_0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"}],\"name\":\"calculatePrice\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PriceCalculator","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://955d21ca411553100f44ae9e41e27089c5541d476143852e83cba004182b82f8"}]}