{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/util/DeployerRole.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract DeployerRole {\r\n    address internal immutable _deployer;\r\n\r\n    modifier onlyDeployer() {\r\n        require(\r\n            _isDeployer(msg.sender),\r\n            \"only deployer is allowed to call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _deployer = msg.sender;\r\n    }\r\n\r\n    function _isDeployer(address account) internal view returns (bool) {\r\n        return account == _deployer;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/math/UseSafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\r\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\r\n */\r\n\r\nlibrary SafeMathDivRoundUp {\r\n    using SafeMath for uint256;\r\n\r\n    function divRoundUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(b > 0, errorMessage);\r\n        return ((a - 1) / b) + 1;\r\n    }\r\n\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title UseSafeMath\r\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\r\n * and also can use SafeCast for uint256.\r\n * For example:\r\n *   uint64 a = 1;\r\n *   uint64 b = 2;\r\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\r\n * In additionally, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\r\n * In the case of the operation to the uint64 value, one need to cast the value into int256 in\r\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\r\n * For example:\r\n *   int256 a = 1;\r\n *   uint64 b = 2;\r\n *   int256 c = 3;\r\n *   a = a.add(int256(b).sub(c)); // `a` become 0 as int256\r\n *   b = a.toUint256().toUint64(); // `b` become 0 as uint64\r\n */\r\nabstract contract UseSafeMath {\r\n    using SafeMath for uint256;\r\n    using SafeMathDivRoundUp for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMathDivRoundUp for uint64;\r\n    using SafeMath for uint16;\r\n    using SignedSafeMath for int256;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n}\r\n\r\n// File: contracts/AuctionBoardInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface AuctionBoardInterface {\r\n    event LogBidMemo(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes memo\r\n    );\r\n\r\n    event LogInsertBoard(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint64 bidPrice,\r\n        uint64 boardIndex,\r\n        uint64 targetSBTAmount\r\n    );\r\n\r\n    event LogAuctionInfoDiff(\r\n        bytes32 indexed auctionID,\r\n        uint64 settledAmount,\r\n        uint64 paidIDOL,\r\n        uint64 rewardedSBT\r\n    );\r\n\r\n    function auctionRevealInfo(\r\n        bytes32 auctionID\r\n    ) external view returns (\r\n        uint64 totalSBTAmountBid,\r\n        uint64 totalIDOLSecret,\r\n        uint64 totalIDOLRevealed,\r\n        uint16 auctionPriceCount\r\n    );\r\n\r\n    function auctionParticipantInfo(\r\n        bytes32 auctionID,\r\n        address participant\r\n    ) external view returns (\r\n        uint64 auctionLockedIDOLAmountE8,\r\n        uint16 bidCount\r\n    );\r\n\r\n    function auctionDisposalInfo(\r\n        bytes32 auctionID\r\n    ) external view returns (\r\n        uint64 solidStrikePriceIDOLForUnrevealedE8,\r\n        uint64 solidStrikePriceIDOLForRestWinnersE8,\r\n        bool isEndInfoCreated,\r\n        bool isForceToFinalizeWinnerAmountTriggered,\r\n        bool isPriceSorted\r\n    );\r\n\r\n    function auctionInfo(\r\n        bytes32 auctionID\r\n    ) external view returns (\r\n        uint64 auctionSettledTotalE8,\r\n        uint64 auctionRewardedTotalE8,\r\n        uint64 auctionPaidTotalE8\r\n    );\r\n\r\n    function bidWithMemo(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 totalSBTAmountBid,\r\n        bytes calldata memo\r\n    ) external;\r\n\r\n    function revealBids(\r\n        bytes32 auctionID,\r\n        uint64[] calldata bids,\r\n        uint64 random\r\n    ) external;\r\n\r\n    function sortBidPrice(bytes32 auctionID, uint64[] calldata sortedPrice)\r\n        external;\r\n\r\n    function makeEndInfo(bytes32 auctionID) external;\r\n\r\n    function removeSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 subtractAmount\r\n    ) external;\r\n\r\n    function deleteParticipantInfo(bytes32 auctionID, address participant) external;\r\n\r\n    function updateAuctionInfo(\r\n        bytes32 auctionID,\r\n        uint64 settledAmountE8,\r\n        uint64 paidIDOLE8,\r\n        uint64 rewardedSBTE8\r\n    ) external;\r\n\r\n    function calcBill(\r\n        bytes32 auctionID,\r\n        uint64 winnerAmount,\r\n        uint64 myLowestPrice\r\n    ) external view returns (uint64 paymentAmount);\r\n\r\n    function auctionSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret\r\n    ) external view returns (\r\n        address sender,\r\n        uint64 amount,\r\n        uint64 IDOLamount\r\n    );\r\n\r\n    function getUnsortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory bidPriceList);\r\n\r\n    function getSortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory bidPriceList);\r\n\r\n    function auctionBoard(\r\n        bytes32 auctionID,\r\n        uint64 bidPrice,\r\n        uint256 boardIndex\r\n    ) external view returns (uint64 amount, address bidder);\r\n\r\n    function getEndInfo(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 price,\r\n            uint64 boardIndex,\r\n            uint64 loseSBTAmount,\r\n            uint64 auctionEndPriceWinnerSBTAmount\r\n        );\r\n\r\n    function getBidderStatus(bytes32 auctionID, address bidder)\r\n        external\r\n        view\r\n        returns (uint64 toBack, bool isIDOLReturned);\r\n\r\n    function getBoard(\r\n        bytes32 auctionID,\r\n        uint64 price,\r\n        uint64 boardIndex\r\n    ) external view returns (address bidder, uint64 amount);\r\n\r\n    function getBoardStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory boardStatus);\r\n\r\n    function generateMultiSecret(\r\n        bytes32 auctionID,\r\n        uint64[] calldata bids,\r\n        uint64 random\r\n    ) external pure returns (bytes32 secret);\r\n\r\n    function discretizeBidPrice(uint64 price)\r\n        external\r\n        pure\r\n        returns (uint64 discretizedPrice);\r\n}\r\n\r\n// File: contracts/AuctionTimeControlInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface AuctionTimeControlInterface {\r\n    enum TimeControlFlag {\r\n        BEFORE_AUCTION_FLAG,\r\n        ACCEPTING_BIDS_PERIOD_FLAG,\r\n        REVEALING_BIDS_PERIOD_FLAG,\r\n        RECEIVING_SBT_PERIOD_FLAG,\r\n        AFTER_AUCTION_FLAG\r\n    }\r\n\r\n    function listAuction(uint256 timestamp)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n\r\n    function getTimeControlFlag(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (TimeControlFlag);\r\n\r\n    function isInPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function isAfterPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface AuctionInterface is AuctionTimeControlInterface {\r\n    event LogStartAuction(bytes32 indexed auctionID, bytes32 bondID);\r\n\r\n    event LogCancelBid(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes32 secret,\r\n        uint256 returnedIDOLAmount\r\n    );\r\n\r\n    event LogAuctionResult(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint256 SBTAmountOfReward,\r\n        uint256 IDOLAmountOfPayment,\r\n        uint256 IDOLAmountOfChange\r\n    );\r\n\r\n    event LogCloseAuction(\r\n        bytes32 indexed auctionID,\r\n        bool isLast,\r\n        bytes32 nextAuctionID\r\n    );\r\n\r\n    function ongoingAuctionSBTTotal(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64 ongoingSBTAmountE8);\r\n\r\n    function startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) external returns (bytes32 auctonID);\r\n\r\n    function cancelBid(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (uint64 returnedIDOLAmount);\r\n\r\n    function makeAuctionResult(\r\n        bytes32 auctionID,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata winnerBids,\r\n        uint64[] calldata loserBids\r\n    )\r\n        external\r\n        returns (\r\n            uint64 winnerAmount,\r\n            uint64 toPay,\r\n            uint64 IDOLAmountOfChange\r\n        );\r\n\r\n    function closeAuction(bytes32 auctionID)\r\n        external\r\n        returns (bool isLast, bytes32 nextAuctionID);\r\n\r\n    function receiveUnrevealedBidDistribution(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (bool success);\r\n\r\n    function getCurrentAuctionID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 auctionID);\r\n\r\n    function generateAuctionID(bytes32 bondID, uint256 auctionCount)\r\n        external\r\n        pure\r\n        returns (bytes32 auctionID);\r\n\r\n    function listBondIDFromAuctionID(bytes32[] calldata auctionIDs)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs);\r\n\r\n    function getAuctionStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 closingTime,\r\n            uint64 auctionAmount,\r\n            uint64 rewardedAmount,\r\n            uint64 totalSBTAmountBid,\r\n            bool isEmergency,\r\n            bool doneFinalizeWinnerAmount,\r\n            bool doneSortPrice,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n            uint64 totalSBTAmountPaidForUnrevealed\r\n        );\r\n\r\n    function getWeeklyAuctionStatus(uint256 weekNumber)\r\n        external\r\n        view\r\n        returns (uint256[] memory weeklyAuctionStatus);\r\n\r\n    function calcWinnerAmount(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64[] calldata winnerBids\r\n    ) external view returns (uint64 winnerAmount);\r\n\r\n    function calcBillAndCheckLoserBids(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64 winnerAmountInput,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata myLoseBids\r\n    ) external view returns (uint64 paymentAmount);\r\n\r\n    function getAuctionCount(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (uint256 auctionCount);\r\n}\r\n\r\n// File: contracts/util/Time.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract Time {\r\n    function _getBlockTimestampSec()\r\n        internal\r\n        view\r\n        returns (uint256 unixtimesec)\r\n    {\r\n        unixtimesec = now; // solium-disable-line security/no-block-members\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionTimeControl.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ncontract AuctionTimeControl is Time, AuctionTimeControlInterface {\r\n    uint256 internal immutable MIN_NORMAL_AUCTION_PERIOD;\r\n    uint256 internal immutable MIN_EMERGENCY_AUCTION_PERIOD;\r\n    uint256 internal immutable NORMAL_AUCTION_REVEAL_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_REVEAL_SPAN;\r\n    uint256 internal immutable AUCTION_WITHDRAW_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_WITHDRAW_SPAN;\r\n\r\n    TimeControlFlag internal constant BEFORE_AUCTION_FLAG = TimeControlFlag\r\n        .BEFORE_AUCTION_FLAG;\r\n    TimeControlFlag internal constant ACCEPTING_BIDS_PERIOD_FLAG = TimeControlFlag\r\n        .ACCEPTING_BIDS_PERIOD_FLAG;\r\n    TimeControlFlag internal constant REVEALING_BIDS_PERIOD_FLAG = TimeControlFlag\r\n        .REVEALING_BIDS_PERIOD_FLAG;\r\n    TimeControlFlag internal constant RECEIVING_SBT_PERIOD_FLAG = TimeControlFlag\r\n        .RECEIVING_SBT_PERIOD_FLAG;\r\n    TimeControlFlag internal constant AFTER_AUCTION_FLAG = TimeControlFlag\r\n        .AFTER_AUCTION_FLAG;\r\n\r\n    /**\r\n     * @dev Get whether the auction is in emergency or not.\r\n     */\r\n    mapping(bytes32 => bool) public isAuctionEmergency;\r\n\r\n    /**\r\n     * @dev The end time that the auction accepts bids.\r\n     * The zero value indicates the auction is not held.\r\n     */\r\n    mapping(bytes32 => uint256) public auctionClosingTime;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by listAuction function.\r\n     */\r\n    mapping(uint256 => bytes32[]) internal _weeklyAuctionList;\r\n\r\n    constructor(\r\n        uint256 minNormalAuctionPeriod,\r\n        uint256 minEmergencyAuctionPeriod,\r\n        uint256 normalAuctionRevealSpan,\r\n        uint256 emergencyAuctionRevealSpan,\r\n        uint256 auctionWithdrawSpan,\r\n        uint256 emergencyAuctionWithdrawSpan\r\n    ) public {\r\n        MIN_NORMAL_AUCTION_PERIOD = minNormalAuctionPeriod;\r\n        MIN_EMERGENCY_AUCTION_PERIOD = minEmergencyAuctionPeriod;\r\n        NORMAL_AUCTION_REVEAL_SPAN = normalAuctionRevealSpan;\r\n        EMERGENCY_AUCTION_REVEAL_SPAN = emergencyAuctionRevealSpan;\r\n        AUCTION_WITHDRAW_SPAN = auctionWithdrawSpan;\r\n        EMERGENCY_AUCTION_WITHDRAW_SPAN = emergencyAuctionWithdrawSpan;\r\n    }\r\n\r\n    /**\r\n     * @dev Get auctions which will close within the week.\r\n     */\r\n    function listAuction(uint256 weekNumber)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return _weeklyAuctionList[weekNumber];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the period the auction is currently in.\r\n     * This function returns 0-4 corresponding to its period.\r\n     */\r\n    function getTimeControlFlag(bytes32 auctionID)\r\n        public\r\n        override\r\n        view\r\n        returns (TimeControlFlag)\r\n    {\r\n        uint256 closingTime = auctionClosingTime[auctionID];\r\n\r\n        // Note that the auction span differs based on whether the auction is in emergency or not.\r\n        bool isEmergency = isAuctionEmergency[auctionID];\r\n        uint256 revealSpan = NORMAL_AUCTION_REVEAL_SPAN;\r\n        uint256 withdrawSpan = AUCTION_WITHDRAW_SPAN;\r\n        if (isEmergency) {\r\n            revealSpan = EMERGENCY_AUCTION_REVEAL_SPAN;\r\n            withdrawSpan = EMERGENCY_AUCTION_WITHDRAW_SPAN;\r\n        }\r\n\r\n        uint256 nowTime = _getBlockTimestampSec();\r\n        if (closingTime == 0) {\r\n            return BEFORE_AUCTION_FLAG;\r\n        } else if (nowTime <= closingTime) {\r\n            return ACCEPTING_BIDS_PERIOD_FLAG;\r\n        } else if (nowTime < closingTime + revealSpan) {\r\n            return REVEALING_BIDS_PERIOD_FLAG;\r\n        } else if (nowTime < closingTime + revealSpan + withdrawSpan) {\r\n            return RECEIVING_SBT_PERIOD_FLAG;\r\n        } else {\r\n            return AFTER_AUCTION_FLAG;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns whether or not the auction is in the period indicated\r\n     * by the flag.\r\n     */\r\n    function isInPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        public\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getTimeControlFlag(auctionID) == flag;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether or not the auction is in or after the period indicated\r\n     * by the flag.\r\n     */\r\n    function isAfterPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        public\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getTimeControlFlag(auctionID) >= flag;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates and registers the end time of the period in which the auction accepts bids\r\n     * (= closingTime). The period in which bids are revealed follows after this time.\r\n     */\r\n    function _setAuctionClosingTime(bytes32 auctionID, bool isEmergency)\r\n        internal\r\n    {\r\n        uint256 closingTime;\r\n\r\n        if (isEmergency) {\r\n            closingTime =\r\n                ((_getBlockTimestampSec() +\r\n                    MIN_EMERGENCY_AUCTION_PERIOD +\r\n                    5 minutes -\r\n                    1) / 5 minutes) *\r\n                (5 minutes);\r\n        } else {\r\n            closingTime =\r\n                ((_getBlockTimestampSec() +\r\n                    MIN_NORMAL_AUCTION_PERIOD +\r\n                    1 hours -\r\n                    1) / 1 hours) *\r\n                (1 hours);\r\n        }\r\n        _setAuctionClosingTime(auctionID, isEmergency, closingTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the end time of the period in which the auction accepts bids (= closingTime).\r\n     * The period in which bids are revealed follows after this time.\r\n     */\r\n    function _setAuctionClosingTime(\r\n        bytes32 auctionID,\r\n        bool isEmergency,\r\n        uint256 closingTime\r\n    ) internal {\r\n        isAuctionEmergency[auctionID] = isEmergency;\r\n        auctionClosingTime[auctionID] = closingTime;\r\n        uint256 weekNumber = closingTime / (1 weeks);\r\n        _weeklyAuctionList[weekNumber].push(auctionID);\r\n    }\r\n}\r\n\r\n// File: contracts/BondMakerInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface BondMakerInterface {\r\n    event LogNewBond(\r\n        bytes32 indexed bondID,\r\n        address bondTokenAddress,\r\n        uint64 stableStrikePrice,\r\n        bytes32 fnMapID\r\n    );\r\n\r\n    event LogNewBondGroup(uint256 indexed bondGroupID);\r\n\r\n    event LogIssueNewBonds(\r\n        uint256 indexed bondGroupID,\r\n        address indexed issuer,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogReverseBondToETH(\r\n        uint256 indexed bondGroupID,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogExchangeEquivalentBonds(\r\n        address indexed owner,\r\n        uint256 indexed inputBondGroupID,\r\n        uint256 indexed outputBondGroupID,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    function registerNewBond(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        returns (\r\n            bytes32 bondID,\r\n            address bondTokenAddress,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function registerNewBondGroup(\r\n        bytes32[] calldata bondIDList,\r\n        uint256 maturity\r\n    ) external returns (uint256 bondGroupID);\r\n\r\n    function issueNewBonds(uint256 bondGroupID)\r\n        external\r\n        payable\r\n        returns (uint256 amount);\r\n\r\n    function reverseBondToETH(uint256 bondGroupID, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function exchangeEquivalentBonds(\r\n        uint256 inputBondGroupID,\r\n        uint256 outputBondGroupID,\r\n        uint256 amount,\r\n        bytes32[] calldata exceptionBonds\r\n    ) external returns (bool);\r\n\r\n    function liquidateBond(uint256 bondGroupID, uint256 oracleHintID) external;\r\n\r\n    function getBond(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (\r\n            address bondAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function getFnMap(bytes32 fnMapID)\r\n        external\r\n        view\r\n        returns (bytes memory fnMap);\r\n\r\n    function getBondGroup(uint256 bondGroupID)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs, uint256 maturity);\r\n\r\n    function generateBondID(uint256 maturity, bytes calldata functionHash)\r\n        external\r\n        pure\r\n        returns (bytes32 bondID);\r\n}\r\n\r\n// File: contracts/UseBondMaker.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\nabstract contract UseBondMaker {\r\n    BondMakerInterface internal immutable _bondMakerContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _bondMakerContract = BondMakerInterface(payable(contractAddress));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/StableCoinInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface StableCoinInterface is IERC20 {\r\n    event LogIsAcceptableSBT(bytes32 indexed bondID, bool isAcceptable);\r\n\r\n    event LogMintIDOL(\r\n        bytes32 indexed bondID,\r\n        address indexed owner,\r\n        bytes32 poolID,\r\n        uint256 obtainIDOLAmount,\r\n        uint256 poolIDOLAmount\r\n    );\r\n\r\n    event LogBurnIDOL(\r\n        bytes32 indexed bondID, // poolID?\r\n        address indexed owner,\r\n        uint256 burnIDOLAmount,\r\n        uint256 unlockSBTAmount\r\n    );\r\n\r\n    event LogReturnLockedPool(\r\n        bytes32 indexed poolID,\r\n        address indexed owner,\r\n        uint64 backIDOLAmount\r\n    );\r\n\r\n    event LogLambda(\r\n        bytes32 indexed poolID,\r\n        uint64 settledAverageAuctionPrice,\r\n        uint256 totalSupply,\r\n        uint256 lockedSBTValue\r\n    );\r\n\r\n    function getPoolInfo(bytes32 poolID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 lockedSBTTotal,\r\n            uint64 unlockedSBTTotal,\r\n            uint64 lockedPoolIDOLTotal,\r\n            uint64 burnedIDOLTotal,\r\n            uint64 soldSBTTotalInAuction,\r\n            uint64 paidIDOLTotalInAuction,\r\n            uint64 settledAverageAuctionPrice,\r\n            bool isAllAmountSoldInAuction\r\n        );\r\n\r\n    function solidValueTotal() external view returns (uint256 solidValue);\r\n\r\n    function isAcceptableSBT(bytes32 bondID) external returns (bool ok);\r\n\r\n    function mint(\r\n        bytes32 bondID,\r\n        address recipient,\r\n        uint64 lockAmount\r\n    )\r\n        external\r\n        returns (\r\n            bytes32 poolID,\r\n            uint64 obtainIDOLAmount,\r\n            uint64 poolIDOLAmount\r\n        );\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n    function unlockSBT(bytes32 bondID, uint64 burnAmount)\r\n        external\r\n        returns (uint64 rewardSBT);\r\n\r\n    function startAuctionOnMaturity(bytes32 bondID) external;\r\n\r\n    function startAuctionByMarket(bytes32 bondID) external;\r\n\r\n    function setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 totalPaidIDOL,\r\n        uint64 SBTAmount,\r\n        bool isLast\r\n    ) external;\r\n\r\n    function calcSBT2IDOL(uint256 solidBondAmount)\r\n        external\r\n        view\r\n        returns (uint256 IDOLAmount);\r\n\r\n    function returnLockedPool(bytes32[] calldata poolIDs)\r\n        external\r\n        returns (uint64 IDOLAmount);\r\n\r\n    function generatePoolID(bytes32 bondID, uint64 count)\r\n        external\r\n        pure\r\n        returns (bytes32 poolID);\r\n\r\n    function getCurrentPoolID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 poolID);\r\n\r\n    function getLockedPool(address user, bytes32 poolID)\r\n        external\r\n        view\r\n        returns (uint64, uint64);\r\n}\r\n\r\n// File: contracts/UseStableCoin.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\nabstract contract UseStableCoin {\r\n    StableCoinInterface internal immutable _IDOLContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _IDOLContract = StableCoinInterface(contractAddress);\r\n    }\r\n\r\n    function _transferIDOLFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        _IDOLContract.transferFrom(from, to, amount);\r\n    }\r\n\r\n    function _transferIDOL(address to, uint256 amount) internal {\r\n        _IDOLContract.transfer(to, amount);\r\n    }\r\n\r\n    function _transferIDOL(\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMessage\r\n    ) internal {\r\n        require(_IDOLContract.balanceOf(address(this)) >= amount, errorMessage);\r\n        _IDOLContract.transfer(to, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/UseAuctionBoard.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\nabstract contract UseAuctionBoard {\r\n    AuctionBoardInterface internal immutable _auctionBoardContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _auctionBoardContract = AuctionBoardInterface(contractAddress);\r\n    }\r\n}\r\n\r\n// File: contracts/oracle/OracleInterface.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n// Oracle referenced by OracleProxy must implement this interface.\r\ninterface OracleInterface {\r\n    // Returns if oracle is running.\r\n    function alive() external view returns (bool);\r\n\r\n    // Returns latest id.\r\n    // The first id is 1 and 0 value is invalid as id.\r\n    // Each price values and theirs timestamps are identified by id.\r\n    // Ids are assigned incrementally to values.\r\n    function latestId() external returns (uint256);\r\n\r\n    // Returns latest price value.\r\n    // decimal 8\r\n    function latestPrice() external returns (uint256);\r\n\r\n    // Returns timestamp of latest price.\r\n    function latestTimestamp() external returns (uint256);\r\n\r\n    // Returns price of id.\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    // Returns timestamp of id.\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n\r\n    function getVolatility() external returns (uint256);\r\n}\r\n\r\n// File: contracts/oracle/UseOracle.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\nabstract contract UseOracle {\r\n    OracleInterface internal _oracleContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _oracleContract = OracleInterface(contractAddress);\r\n    }\r\n\r\n    /// @notice Get the latest USD/ETH price and historical volatility using oracle.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    /// @return volatilityE8 (10^-8)\r\n    function _getOracleData()\r\n        internal\r\n        returns (uint256 rateETH2USDE8, uint256 volatilityE8)\r\n    {\r\n        rateETH2USDE8 = _oracleContract.latestPrice();\r\n        volatilityE8 = _oracleContract.getVolatility();\r\n\r\n        return (rateETH2USDE8, volatilityE8);\r\n    }\r\n\r\n    /// @notice Get the price of the oracle data with a minimum timestamp that does more than input value\r\n    /// when you know the ID you are looking for.\r\n    /// @param timestamp is the timestamp that you want to get price.\r\n    /// @param hintID is the ID of the oracle data you are looking for.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    function _getPriceOn(uint256 timestamp, uint256 hintID)\r\n        internal\r\n        returns (uint256 rateETH2USDE8)\r\n    {\r\n        uint256 latestID = _oracleContract.latestId();\r\n        require(\r\n            latestID != 0,\r\n            \"system error: the ID of oracle data should not be zero\"\r\n        );\r\n\r\n        require(hintID != 0, \"the hint ID must not be zero\");\r\n        uint256 id = hintID;\r\n        if (hintID > latestID) {\r\n            id = latestID;\r\n        }\r\n\r\n        require(\r\n            _oracleContract.getTimestamp(id) > timestamp,\r\n            \"there is no price data after maturity\"\r\n        );\r\n\r\n        id--;\r\n        while (id != 0) {\r\n            if (_oracleContract.getTimestamp(id) <= timestamp) {\r\n                break;\r\n            }\r\n            id--;\r\n        }\r\n\r\n        return _oracleContract.getPrice(id + 1);\r\n    }\r\n}\r\n\r\n// File: contracts/util/TransferETHInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface TransferETHInterface {\r\n    receive() external payable;\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/bondToken/BondTokenInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ninterface BondTokenInterface is TransferETHInterface, IERC20 {\r\n    event LogExpire(\r\n        uint128 rateNumerator,\r\n        uint128 rateDenominator,\r\n        bool firstTime\r\n    );\r\n\r\n    function mint(address account, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function expire(uint128 rateNumerator, uint128 rateDenominator)\r\n        external\r\n        returns (bool firstTime);\r\n\r\n    function burn(uint256 amount) external returns (bool success);\r\n\r\n    function burnAll() external returns (uint256 amount);\r\n\r\n    function isMinter(address account) external view returns (bool minter);\r\n\r\n    function getRate()\r\n        external\r\n        view\r\n        returns (uint128 rateNumerator, uint128 rateDenominator);\r\n}\r\n\r\n// File: contracts/Auction.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Auction is\r\n    UseSafeMath,\r\n    AuctionInterface,\r\n    AuctionTimeControl,\r\n    UseStableCoin,\r\n    UseBondMaker,\r\n    UseAuctionBoard\r\n{\r\n    using Math for uint256;\r\n\r\n    uint64 internal constant NO_SKIP_BID = uint64(-1);\r\n    uint64 internal constant SKIP_RECEIVING_WIN_BIDS = uint64(-2);\r\n    uint256 internal constant POOL_AUCTION_COUNT_PADDING = 10**8;\r\n\r\n    /**\r\n     * @notice The times of auctions held for the auction ID.\r\n     * @dev The contents in this internal storage variable can be seen by getAuctionCount function.\r\n     */\r\n    mapping(bytes32 => uint256) internal _bondIDAuctionCount;\r\n\r\n    /**\r\n     * @notice Get the bond ID from the auction ID.\r\n     */\r\n    mapping(bytes32 => bytes32) public auctionID2BondID;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by getAuctionStatus function.\r\n     * @param ongoingAuctionSBTTotalE8 is the SBT amount put up in the auction.\r\n     * @param lowestBidPriceDeadLineE8 is the minimum bid price in the auction.\r\n     * @param highestBidPriceDeadLineE8 is the maximum bid price in the auction.\r\n     * @param totalSBTAmountPaidForUnrevealedE8 is the SBT Amount allocated for those who had not revealed their own bid.\r\n     */\r\n    struct AuctionConfig {\r\n        uint64 ongoingAuctionSBTTotalE8;\r\n        uint64 lowestBidPriceDeadLineE8;\r\n        uint64 highestBidPriceDeadLineE8;\r\n        uint64 totalSBTAmountPaidForUnrevealedE8;\r\n    }\r\n    mapping(bytes32 => AuctionConfig) internal _auctionConfigList;\r\n\r\n    constructor(\r\n        address bondMakerAddress,\r\n        address IDOLAddress,\r\n        address auctionBoardAddress,\r\n        uint256 minNormalAuctionPeriod,\r\n        uint256 minEmergencyAuctionPeriod,\r\n        uint256 normalAuctionRevealSpan,\r\n        uint256 emergencyAuctionRevealSpan,\r\n        uint256 auctionWithdrawSpan,\r\n        uint256 emergencyAuctionWithdrawSpan\r\n    )\r\n        public\r\n        AuctionTimeControl(\r\n            minNormalAuctionPeriod,\r\n            minEmergencyAuctionPeriod,\r\n            normalAuctionRevealSpan,\r\n            emergencyAuctionRevealSpan,\r\n            auctionWithdrawSpan,\r\n            emergencyAuctionWithdrawSpan\r\n        )\r\n        UseBondMaker(bondMakerAddress)\r\n        UseStableCoin(IDOLAddress)\r\n        UseAuctionBoard(auctionBoardAddress)\r\n    {}\r\n\r\n    /**\r\n     * @dev This function starts the auction for the auctionID. Can be called only by the IDOL contract.\r\n     */\r\n    function startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) external override returns (bytes32) {\r\n        require(\r\n            msg.sender == address(_IDOLContract),\r\n            \"caller must be IDOL contract\"\r\n        );\r\n        return _startAuction(bondID, auctionAmount, isEmergency);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called when the auction (re)starts.\r\n     * @param bondID is SBT ID whose auction will be held.\r\n     * @param auctionAmount is SBT amount put up in the auction.\r\n     * @param isEmergency is the flag that indicates the auction schedule is for emergency mode.\r\n     */\r\n    function _startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) internal returns (bytes32) {\r\n        (, , uint256 solidStrikePriceE4, ) = _bondMakerContract.getBond(bondID);\r\n        uint256 strikePriceIDOL = _IDOLContract.calcSBT2IDOL(\r\n            solidStrikePriceE4.mul(10**8)\r\n        );\r\n\r\n        uint256 auctionCount = _bondIDAuctionCount[bondID].add(1);\r\n        _bondIDAuctionCount[bondID] = auctionCount;\r\n        bytes32 auctionID = getCurrentAuctionID(bondID);\r\n        require(\r\n            isInPeriod(auctionID, BEFORE_AUCTION_FLAG),\r\n            \"the auction has been held\"\r\n        );\r\n\r\n        uint256 betaCount = auctionCount.mod(POOL_AUCTION_COUNT_PADDING).min(9);\r\n\r\n        auctionID2BondID[auctionID] = bondID;\r\n\r\n        _setAuctionClosingTime(auctionID, isEmergency);\r\n\r\n        {\r\n            AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n            auctionConfig.ongoingAuctionSBTTotalE8 = auctionAmount;\r\n            auctionConfig.lowestBidPriceDeadLineE8 = strikePriceIDOL\r\n                .mul(10 - betaCount)\r\n                .div(10)\r\n                .toUint64();\r\n            auctionConfig.highestBidPriceDeadLineE8 = strikePriceIDOL\r\n                .mul(10 + betaCount)\r\n                .div(10)\r\n                .toUint64();\r\n            _auctionConfigList[auctionID] = auctionConfig;\r\n        }\r\n\r\n        emit LogStartAuction(auctionID, bondID);\r\n\r\n        return auctionID;\r\n    }\r\n\r\n    /**\r\n     * @notice submit only your own winning bids and get SBT amount which you'll aquire.\r\n     */\r\n    function calcWinnerAmount(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64[] memory winnerBids\r\n    ) public override view returns (uint64) {\r\n        uint256 totalBidAmount;\r\n\r\n        (\r\n            uint64 endPrice,\r\n            uint64 endBoardIndex,\r\n            uint64 loseSBTAmount,\r\n\r\n        ) = _auctionBoardContract.getEndInfo(auctionID);\r\n\r\n        uint64 bidPrice;\r\n        uint64 boardIndex;\r\n        // can calculate winner amount after making the end info.\r\n        {\r\n            (, , bool isEndInfoCreated, , ) = _auctionBoardContract\r\n                .auctionDisposalInfo(auctionID);\r\n            require(isEndInfoCreated, \"the end info has not been made yet\");\r\n        }\r\n\r\n        for (uint256 i = 0; i < winnerBids.length; i += 2) {\r\n            if (i != 0) {\r\n                require(\r\n                    bidPrice > winnerBids[i] ||\r\n                        (bidPrice == winnerBids[i] &&\r\n                            boardIndex < winnerBids[i + 1]),\r\n                    \"loser Bids are not sorted.\"\r\n                );\r\n            }\r\n            bidPrice = winnerBids[i];\r\n            boardIndex = winnerBids[i + 1];\r\n            (uint64 bidAmount, address bidder) = _auctionBoardContract\r\n                .auctionBoard(auctionID, bidPrice, boardIndex);\r\n            require(bidder == sender, \"this bid is not yours\");\r\n\r\n            totalBidAmount = totalBidAmount.add(bidAmount);\r\n            if (endPrice == bidPrice) {\r\n                if (boardIndex == endBoardIndex) {\r\n                    totalBidAmount = totalBidAmount.sub(loseSBTAmount);\r\n                } else {\r\n                    require(\r\n                        boardIndex < endBoardIndex,\r\n                        \"this bid does not win\"\r\n                    );\r\n                }\r\n            } else {\r\n                require(endPrice < bidPrice, \"this bid does not win\");\r\n            }\r\n        }\r\n\r\n        return totalBidAmount.toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice all loser bids must be reported to this function. These are checked and counted for calculations of bill.\r\n     * @param auctionID aunctionID\r\n     * @param sender owner of the bids\r\n     * @param winnerAmountInput SBT amount to aquire. this is needed because this effect the price of SBT in Vickly Auction's protocol.\r\n     * @param myLowestPrice myLowestPrice is the lowest price of skip bids.\r\n     * @param myLoseBids is the all bids which is after the endInfo\r\n     */\r\n    function calcBillAndCheckLoserBids(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64 winnerAmountInput,\r\n        uint64 myLowestPrice,\r\n        uint64[] memory myLoseBids\r\n    ) public override view returns (uint64) {\r\n        uint256 winnerAmount = winnerAmountInput;\r\n        uint256 toPaySkip = 0;\r\n\r\n        if (\r\n            myLowestPrice != NO_SKIP_BID &&\r\n            myLowestPrice != SKIP_RECEIVING_WIN_BIDS\r\n        ) {\r\n            bool myLowestVerify = false;\r\n            for (uint256 i = 0; i < myLoseBids.length; i += 2) {\r\n                uint64 price = myLoseBids[i];\r\n                if (price == myLowestPrice) {\r\n                    myLowestVerify = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            require(\r\n                myLowestVerify,\r\n                \"myLowestPrice must be included in myLoseBids\"\r\n            );\r\n        }\r\n\r\n        // The amount of sender's lose bids will be skipped. In order to optimize the calculation,\r\n        // components in myLoseBids with a higher price than myLowestPrice are added to winnerAmount and\r\n        // to be subtracted at the end of this function.\r\n        for (uint256 i = 0; i < myLoseBids.length; i += 2) {\r\n            uint64 price = myLoseBids[i];\r\n            uint64 boardIndex = myLoseBids[i + 1];\r\n\r\n            if (i != 0) {\r\n                require(\r\n                    price < myLoseBids[i - 2] ||\r\n                        (price == myLoseBids[i - 2] &&\r\n                            boardIndex > myLoseBids[i - 1]),\r\n                    \"myLoseBids is not sorted\"\r\n                );\r\n            }\r\n            {\r\n                (\r\n                    uint64 endPrice,\r\n                    uint64 endBoardIndex,\r\n                    uint64 loseSBTAmount,\r\n\r\n                ) = _auctionBoardContract.getEndInfo(auctionID);\r\n\r\n                if (price == endPrice) {\r\n                    if (boardIndex == endBoardIndex) {\r\n                        require(\r\n                            loseSBTAmount != 0,\r\n                            \"myLoseBids includes the bid which is same as endInfo with no lose SBT amount\"\r\n                        );\r\n\r\n                        // This function does not guarantee to return the correct result if an invalid input is given,\r\n                        // because this function can be used just for getting information.\r\n                        // This function is used in the procecss of makeAuctionResult(), and in such a case,\r\n                        // all the verification for bidder==sender and some necessary conditions are processed\r\n                        // in different functions.\r\n\r\n                        if (myLowestPrice <= price) {\r\n                            winnerAmount = winnerAmount.add(loseSBTAmount);\r\n                            toPaySkip = toPaySkip.add(\r\n                                price.mul(loseSBTAmount).div(10**8)\r\n                            );\r\n                            continue;\r\n                        }\r\n                    } else {\r\n                        require(\r\n                            boardIndex > endBoardIndex,\r\n                            \"myLoseBids includes the bid whose bid index is less than that of endInfo\"\r\n                        );\r\n                    }\r\n                } else {\r\n                    require(\r\n                        price < endPrice,\r\n                        \"myLoseBids includes the bid whose price is more than that of endInfo\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            (uint64 bidAmount, address bidder) = _auctionBoardContract\r\n                .auctionBoard(auctionID, price, boardIndex);\r\n            require(\r\n                bidder == sender,\r\n                \"myLoseBids includes the bid whose owner is not the sender\"\r\n            );\r\n\r\n            if (myLowestPrice <= price) {\r\n                winnerAmount = winnerAmount.add(bidAmount);\r\n                toPaySkip = toPaySkip.add(price.mul(bidAmount).div(10**8));\r\n            }\r\n        }\r\n\r\n        if (myLowestPrice == SKIP_RECEIVING_WIN_BIDS) {\r\n            // Reduce calculation costs instead by receiving obtained SBT at the highest losing price.\r\n            (uint64 endPrice, , , ) = _auctionBoardContract.getEndInfo(\r\n                auctionID\r\n            );\r\n            //while toPaySkip is expected to be zero in the loop above,\r\n            //only the exception is when the the price acctually hit uint64(-1) at an extremely unexpected case.\r\n            return\r\n                endPrice\r\n                    .mul(winnerAmount)\r\n                    .divRoundUp(10**8)\r\n                    .sub(toPaySkip)\r\n                    .toUint64();\r\n        }\r\n\r\n        return\r\n            _auctionBoardContract\r\n                .calcBill(auctionID, winnerAmount.toUint64(), myLowestPrice)\r\n                .sub(toPaySkip)\r\n                .toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice Submit all my win and lose bids, verify them, and transfer the auction reward.\r\n     * @param winnerBids is an array of alternating price and board index.\r\n     * For example, if the end info is { price: 96, boardIndex: 0, loseSBTAmount: 100000000 } and you have 3 bids:\r\n     * { price: 99, boardIndex: 0 }, { price: 97, boardIndex: 2 }, and { price: 96, boardIndex: 1 },\r\n     * you should submit [9900000000, 0, 9700000000, 2] as winnerBids and [9600000000, 1] as loserBids.\r\n     * If the end info is { price: 96, boardIndex: 0, loseSBTAmount: 100000000 } and you have 1 bid:\r\n     * { price: 96, boardIndex: 0 }, you should submit [9600000000, 0] as winnerBids and [9600000000, 0]\r\n     * as loserBids.\r\n     */\r\n    function makeAuctionResult(\r\n        bytes32 auctionID,\r\n        uint64 myLowestPrice,\r\n        uint64[] memory winnerBids,\r\n        uint64[] memory loserBids\r\n    )\r\n        public\r\n        override\r\n        returns (\r\n            uint64,\r\n            uint64,\r\n            uint64\r\n        )\r\n    {\r\n        (\r\n            uint64 auctionLockedIDOLAmountE8,\r\n            uint16 bidCount\r\n        ) = _auctionBoardContract.auctionParticipantInfo(auctionID, msg.sender);\r\n\r\n        require(auctionLockedIDOLAmountE8 != 0, \"This process is already done\");\r\n\r\n        {\r\n            (\r\n                uint64 endPrice,\r\n                uint64 endBoardIndex,\r\n                uint64 loseSBTAmount,\r\n                uint64 auctionEndPriceWinnerSBTAmount\r\n            ) = _auctionBoardContract.getEndInfo(auctionID);\r\n            (address endBidder, ) = _auctionBoardContract.getBoard(\r\n                auctionID,\r\n                endPrice,\r\n                endBoardIndex\r\n            );\r\n            // If dupicated bid count is included (loseSBTAmount != 0), bidCount is increased by 1.\r\n            // When both auctionEndPriceWinnerSBTAmount and loseSBTAmount are no-zero value,\r\n            // the end info bid has two components(a winner bid side & a loser bid side).\r\n            // If endInfo bid is frauded in calcBillAndCheckLoserBids L269, revert here. So there needs not check sender==bidder.\r\n            require(\r\n                winnerBids.length.div(2) + loserBids.length.div(2) ==\r\n                    bidCount +\r\n                        (\r\n                            (msg.sender == endBidder &&\r\n                                loseSBTAmount != 0 &&\r\n                                auctionEndPriceWinnerSBTAmount != 0)\r\n                                ? 1\r\n                                : 0\r\n                        ),\r\n                \"must submit all of your bids\"\r\n            );\r\n        }\r\n\r\n        uint64 winnerAmount = calcWinnerAmount(\r\n            auctionID,\r\n            msg.sender,\r\n            winnerBids\r\n        );\r\n\r\n        uint64 toPay;\r\n        TimeControlFlag timeFlag = getTimeControlFlag(auctionID);\r\n\r\n        if (timeFlag == RECEIVING_SBT_PERIOD_FLAG) {\r\n            toPay = calcBillAndCheckLoserBids(\r\n                auctionID,\r\n                msg.sender,\r\n                winnerAmount,\r\n                myLowestPrice,\r\n                loserBids\r\n            );\r\n        } else {\r\n            require(\r\n                timeFlag > RECEIVING_SBT_PERIOD_FLAG,\r\n                \"has not been the receiving period yet\"\r\n            );\r\n            toPay = calcBillAndCheckLoserBids(\r\n                auctionID,\r\n                msg.sender,\r\n                winnerAmount,\r\n                SKIP_RECEIVING_WIN_BIDS,\r\n                loserBids\r\n            );\r\n        }\r\n\r\n        uint64 IDOLAmountOfChange = auctionLockedIDOLAmountE8\r\n            .sub(toPay)\r\n            .toUint64();\r\n        _auctionBoardContract.deleteParticipantInfo(auctionID, msg.sender);\r\n        _transferIDOL(msg.sender, IDOLAmountOfChange);\r\n\r\n        _auctionBoardContract.updateAuctionInfo(\r\n            auctionID,\r\n            0,\r\n            toPay,\r\n            winnerAmount\r\n        );\r\n        _distributeToWinners(auctionID, winnerAmount);\r\n\r\n        emit LogAuctionResult(\r\n            auctionID,\r\n            msg.sender,\r\n            winnerAmount,\r\n            toPay,\r\n            IDOLAmountOfChange\r\n        );\r\n\r\n        return (winnerAmount, toPay, IDOLAmountOfChange);\r\n    }\r\n\r\n    /**\r\n     * @notice Close the auction when it is done. If some part of SBTs remain unsold, the auction is held again.\r\n     */\r\n    function closeAuction(bytes32 auctionID)\r\n        public\r\n        override\r\n        returns (bool, bytes32)\r\n    {\r\n        (uint64 auctionSettledTotalE8, , ) = _auctionBoardContract.auctionInfo(\r\n            auctionID\r\n        );\r\n        require(\r\n            isInPeriod(auctionID, AFTER_AUCTION_FLAG),\r\n            \"This function is not allowed to execute in this period\"\r\n        );\r\n\r\n        uint64 ongoingAuctionSBTTotal = _auctionConfigList[auctionID]\r\n            .ongoingAuctionSBTTotalE8;\r\n        require(ongoingAuctionSBTTotal != 0, \"already closed\");\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n\r\n        {\r\n            (, , bool isEndInfoCreated, , ) = _auctionBoardContract\r\n                .auctionDisposalInfo(auctionID);\r\n            require(isEndInfoCreated, \"has not set end info\");\r\n        }\r\n\r\n        _forceToFinalizeWinnerAmount(auctionID);\r\n\r\n        uint256 nextAuctionAmount = ongoingAuctionSBTTotal.sub(\r\n            auctionSettledTotalE8,\r\n            \"allocated SBT amount for auction never becomes lower than reward total\"\r\n        );\r\n\r\n        bool isLast = nextAuctionAmount == 0;\r\n        _publishSettledAverageAuctionPrice(auctionID, isLast);\r\n\r\n        bytes32 nextAuctionID = bytes32(0);\r\n        if (isLast) {\r\n            // closeAuction adds 10**8 to _bondIDAuctionCount[bondID] and resets beta count\r\n            // when all SBT of the auction is sold out.\r\n            _bondIDAuctionCount[bondID] = _bondIDAuctionCount[bondID]\r\n                .div(POOL_AUCTION_COUNT_PADDING)\r\n                .add(1)\r\n                .mul(POOL_AUCTION_COUNT_PADDING);\r\n        } else {\r\n            // When the SBT is not sold out in the auction, restart a new one until all the SBT is successfully sold.\r\n            nextAuctionID = _startAuction(\r\n                bondID,\r\n                nextAuctionAmount.toUint64(),\r\n                true\r\n            );\r\n        }\r\n        delete _auctionConfigList[auctionID].ongoingAuctionSBTTotalE8;\r\n\r\n        emit LogCloseAuction(auctionID, isLast, nextAuctionID);\r\n\r\n        return (isLast, nextAuctionID);\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns SBT amount and iDOL amount (as its change) settled for those who didn't reveal bids.\r\n     */\r\n    function _calcUnrevealedBidDistribution(\r\n        uint64 ongoingAmount,\r\n        uint64 totalIDOLAmountUnrevealed,\r\n        uint64 totalSBTAmountPaidForUnrevealed,\r\n        uint64 solidStrikePriceIDOL,\r\n        uint64 IDOLAmountDeposited\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint64 receivingSBTAmount, uint64 returnedIDOLAmount)\r\n    {\r\n        // (total target) - (total revealed) = (total unrevealed)\r\n        uint64 totalSBTAmountUnrevealed = totalIDOLAmountUnrevealed\r\n            .mul(10**8)\r\n            .div(solidStrikePriceIDOL, \"system error: Oracle has a problem\")\r\n            .toUint64();\r\n\r\n        // min((total unrevealed), ongoing) - (total paid already) = (total deposit for punishment)\r\n        uint64 totalLeftSBTAmountForUnrevealed = uint256(\r\n            totalSBTAmountUnrevealed\r\n        )\r\n            .min(ongoingAmount)\r\n            .sub(totalSBTAmountPaidForUnrevealed)\r\n            .toUint64();\r\n\r\n        // (receiving SBT amount) = min((bid amount), (total deposited))\r\n        uint256 expectedReceivingSBTAmount = IDOLAmountDeposited.mul(10**8).div(\r\n            solidStrikePriceIDOL,\r\n            \"system error: Oracle has a problem\"\r\n        );\r\n\r\n        // (returned iDOL amount) = (deposit amount) - (iDOL value of receiving SBT amount)\r\n        if (expectedReceivingSBTAmount <= totalLeftSBTAmountForUnrevealed) {\r\n            receivingSBTAmount = expectedReceivingSBTAmount.toUint64();\r\n            returnedIDOLAmount = 0;\r\n        } else if (totalLeftSBTAmountForUnrevealed == 0) {\r\n            receivingSBTAmount = 0;\r\n            returnedIDOLAmount = IDOLAmountDeposited;\r\n        } else {\r\n            receivingSBTAmount = totalLeftSBTAmountForUnrevealed;\r\n            returnedIDOLAmount = IDOLAmountDeposited\r\n                .sub(\r\n                totalLeftSBTAmountForUnrevealed\r\n                    .mul(solidStrikePriceIDOL)\r\n                    .divRoundUp(10**8)\r\n            )\r\n                .toUint64();\r\n        }\r\n\r\n        return (receivingSBTAmount, returnedIDOLAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer SBT for those who forget to reveal.\r\n     */\r\n    function receiveUnrevealedBidDistribution(bytes32 auctionID, bytes32 secret)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        (\r\n            uint64 solidStrikePriceIDOL,\r\n            ,\r\n            bool isEndInfoCreated,\r\n            ,\r\n\r\n        ) = _auctionBoardContract.auctionDisposalInfo(auctionID);\r\n        require(\r\n            isEndInfoCreated,\r\n            \"EndInfo hasn't been made. This Function has not been allowed yet.\"\r\n        );\r\n\r\n        (address secOwner, , uint64 IDOLAmountDeposited) = _auctionBoardContract\r\n            .auctionSecret(auctionID, secret);\r\n        require(secOwner == msg.sender, \"ownership of the bid is required\");\r\n\r\n        (\r\n            ,\r\n            uint64 totalIDOLSecret,\r\n            uint64 totalIDOLAmountRevealed,\r\n\r\n        ) = _auctionBoardContract.auctionRevealInfo(auctionID);\r\n        uint64 totalIDOLAmountUnrevealed = totalIDOLSecret\r\n            .sub(totalIDOLAmountRevealed)\r\n            .toUint64();\r\n\r\n        uint64 receivingSBTAmount;\r\n        uint64 returnedIDOLAmount;\r\n        uint64 totalSBTAmountPaidForUnrevealed;\r\n        {\r\n            AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n            totalSBTAmountPaidForUnrevealed = auctionConfig\r\n                .totalSBTAmountPaidForUnrevealedE8;\r\n\r\n            (\r\n                receivingSBTAmount,\r\n                returnedIDOLAmount\r\n            ) = _calcUnrevealedBidDistribution(\r\n                auctionConfig.ongoingAuctionSBTTotalE8,\r\n                totalIDOLAmountUnrevealed,\r\n                totalSBTAmountPaidForUnrevealed,\r\n                solidStrikePriceIDOL,\r\n                IDOLAmountDeposited\r\n            );\r\n        }\r\n\r\n        _auctionConfigList[auctionID]\r\n            .totalSBTAmountPaidForUnrevealedE8 = totalSBTAmountPaidForUnrevealed\r\n            .add(receivingSBTAmount)\r\n            .toUint64();\r\n        _auctionBoardContract.removeSecret(auctionID, secret, 0);\r\n\r\n        // Transfer the winning SBT and (if necessary) return the rest of deposited iDOL.\r\n        (address solidBondAddress, , , ) = _getBondFromAuctionID(auctionID);\r\n        BondTokenInterface solidBondContract = BondTokenInterface(\r\n            payable(solidBondAddress)\r\n        );\r\n        solidBondContract.transfer(secOwner, receivingSBTAmount);\r\n        _IDOLContract.transfer(secOwner, returnedIDOLAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel the bid of your own within the bid acceptance period.\r\n     */\r\n    function cancelBid(bytes32 auctionID, bytes32 secret)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        require(\r\n            isInPeriod(auctionID, ACCEPTING_BIDS_PERIOD_FLAG),\r\n            \"it is not the time to accept bids\"\r\n        );\r\n        (address owner, , uint64 IDOLamount) = _auctionBoardContract\r\n            .auctionSecret(auctionID, secret);\r\n        require(owner == msg.sender, \"you are not the bidder for the secret\");\r\n        _auctionBoardContract.removeSecret(auctionID, secret, IDOLamount);\r\n        _transferIDOL(\r\n            owner,\r\n            IDOLamount,\r\n            \"system error: try to cancel bid, but cannot return iDOL\"\r\n        );\r\n\r\n        emit LogCancelBid(auctionID, owner, secret, IDOLamount);\r\n\r\n        return IDOLamount;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current auction ID.\r\n     */\r\n    function getCurrentAuctionID(bytes32 bondID)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint256 count = _bondIDAuctionCount[bondID];\r\n        return generateAuctionID(bondID, count);\r\n    }\r\n\r\n    /**\r\n     * @notice Generates auction ID from bond ID and the count of auctions for the bond.\r\n     */\r\n    function generateAuctionID(bytes32 bondID, uint256 count)\r\n        public\r\n        override\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(bondID, count));\r\n    }\r\n\r\n    /**\r\n     * @dev The bidder succeeds in winning the SBT for the auctionID with receivingBondAmount, and pays IDOL with billingIDOLAmount.\r\n     */\r\n    function _distributeToWinners(bytes32 auctionID, uint64 receivingBondAmount)\r\n        internal\r\n        returns (uint64)\r\n    {\r\n        // Get the address of SBT contract.\r\n        (address solidBondAddress, , , ) = _getBondFromAuctionID(auctionID);\r\n\r\n        // Transfer the winning SBT.\r\n        BondTokenInterface solidBondContract = BondTokenInterface(\r\n            payable(solidBondAddress)\r\n        );\r\n        solidBondContract.transfer(msg.sender, receivingBondAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev When isLast is true, the SBTs put up in the auction are sold entirely.\r\n     * The average auction price is used for deciding the amount of IDOL to return from the lock pool.\r\n     */\r\n    function _publishSettledAverageAuctionPrice(bytes32 auctionID, bool isLast)\r\n        internal\r\n    {\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n        (\r\n            ,\r\n            uint64 auctionRewardedTotalE8,\r\n            uint64 auctionPaidTotalE8\r\n        ) = _auctionBoardContract.auctionInfo(auctionID);\r\n\r\n        // The auction contract actually do not burn iDOL. Paid iDOL will be transferred and burned in the stable coin contract.\r\n        _transferIDOL(\r\n            address(_IDOLContract),\r\n            auctionPaidTotalE8,\r\n            \"system error: cannot transfer iDOL from auction contract to iDOL contract\"\r\n        );\r\n\r\n        _IDOLContract.setSettledAverageAuctionPrice(\r\n            bondID,\r\n            auctionPaidTotalE8,\r\n            auctionRewardedTotalE8,\r\n            isLast\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev How much IDOL to burn is decided by the settlement price.\r\n     * Hence, this contract needs to decide the price within some specified period.\r\n     */\r\n    function _forceToFinalizeWinnerAmount(bytes32 auctionID) internal {\r\n        (\r\n            uint64 auctionSettledTotalE8,\r\n            uint64 auctionRewardedTotalE8,\r\n\r\n        ) = _auctionBoardContract.auctionInfo(auctionID);\r\n\r\n        if (_auctionBoardContract.getSortedBidPrice(auctionID).length == 0) {\r\n            return;\r\n        }\r\n\r\n        (uint256 burnIDOLRate, , , ) = _auctionBoardContract.getEndInfo(\r\n            auctionID\r\n        );\r\n\r\n        uint256 _totalSBTForRestWinners = auctionSettledTotalE8.sub(\r\n            auctionRewardedTotalE8,\r\n            \"system error: allocated SBT amount for auction never becomes lower than reward total at any point\"\r\n        );\r\n\r\n        uint256 burnIDOL = _totalSBTForRestWinners.mul(burnIDOLRate).div(10**8);\r\n\r\n        _auctionBoardContract.updateAuctionInfo(\r\n            auctionID,\r\n            _totalSBTForRestWinners.toUint64(),\r\n            burnIDOL.toUint64(),\r\n            _totalSBTForRestWinners.toUint64()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the bond information corresponding to the auction ID.\r\n     */\r\n    function _getBondFromAuctionID(bytes32 auctionID)\r\n        internal\r\n        view\r\n        returns (\r\n            address erc20Address,\r\n            uint256 maturity,\r\n            uint64 stableStrikePrice,\r\n            bytes32 fnMapID\r\n        )\r\n    {\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n        return _bondMakerContract.getBond(bondID);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the bond IDs corresponding to the auction IDs respectively.\r\n     */\r\n    function listBondIDFromAuctionID(bytes32[] memory auctionIDs)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32[] memory bondIDs)\r\n    {\r\n        bondIDs = new bytes32[](auctionIDs.length);\r\n        for (uint256 i = 0; i < auctionIDs.length; i++) {\r\n            bondIDs[i] = auctionID2BondID[auctionIDs[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the auction status.\r\n     * @param auctionID is a auction ID.\r\n     * @return closingTime is .\r\n     * @return auctionAmount is the SBT amount put up in the auction.\r\n     * @return rewardedAmount is .\r\n     * @return totalSBTAmountBid is .\r\n     * @return isEmergency is .\r\n     * @return doneFinalizeWinnerAmount is .\r\n     * @return doneSortPrice is .\r\n     * @return lowestBidPriceDeadLine is the minimum bid price in the auction.\r\n     * @return highestBidPriceDeadLine is the maximum bid price in the auction.\r\n     * @return totalSBTAmountPaidForUnrevealed is the SBT Amount allocated for those who had not revealed their own bid.\r\n     */\r\n    function getAuctionStatus(bytes32 auctionID)\r\n        public\r\n        override\r\n        view\r\n        returns (\r\n            uint256 closingTime,\r\n            uint64 auctionAmount,\r\n            uint64 rewardedAmount,\r\n            uint64 totalSBTAmountBid,\r\n            bool isEmergency,\r\n            bool doneFinalizeWinnerAmount,\r\n            bool doneSortPrice,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n            uint64 totalSBTAmountPaidForUnrevealed\r\n        )\r\n    {\r\n        closingTime = auctionClosingTime[auctionID].toUint64();\r\n        AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n        auctionAmount = auctionConfig.ongoingAuctionSBTTotalE8;\r\n        lowestBidPriceDeadLine = auctionConfig.lowestBidPriceDeadLineE8;\r\n        highestBidPriceDeadLine = auctionConfig.highestBidPriceDeadLineE8;\r\n        totalSBTAmountPaidForUnrevealed = auctionConfig\r\n            .totalSBTAmountPaidForUnrevealedE8;\r\n        (, rewardedAmount, ) = _auctionBoardContract.auctionInfo(auctionID);\r\n        (totalSBTAmountBid, , , ) = _auctionBoardContract.auctionRevealInfo(\r\n            auctionID\r\n        );\r\n        isEmergency = isAuctionEmergency[auctionID];\r\n        (, , , doneFinalizeWinnerAmount, doneSortPrice) = _auctionBoardContract\r\n            .auctionDisposalInfo(auctionID);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the status of auctions which is held in the week.\r\n     * @param weekNumber is the quotient obtained by dividing the timestamp by 7 * 24 * 60 * 60 (= 7 days).\r\n     */\r\n    function getWeeklyAuctionStatus(uint256 weekNumber)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256[] memory weeklyAuctionStatus)\r\n    {\r\n        bytes32[] memory auctions = listAuction(weekNumber);\r\n        weeklyAuctionStatus = new uint256[](auctions.length.mul(6));\r\n        for (uint256 i = 0; i < auctions.length; i++) {\r\n            (\r\n                uint256 closingTime,\r\n                uint64 auctionAmount,\r\n                uint64 rewardedAmount,\r\n                uint64 totalSBTAmountBid,\r\n                bool isEmergency,\r\n                bool doneFinalizeWinnerAmount,\r\n                bool doneSortPrice,\r\n                ,\r\n                ,\r\n\r\n            ) = getAuctionStatus(auctions[i]);\r\n            uint8 auctionStatusCode = (isEmergency ? 1 : 0) << 2;\r\n            auctionStatusCode += (doneFinalizeWinnerAmount ? 1 : 0) << 1;\r\n            auctionStatusCode += doneSortPrice ? 1 : 0;\r\n            weeklyAuctionStatus[i * 6] = closingTime;\r\n            weeklyAuctionStatus[i * 6 + 1] = auctionAmount;\r\n            weeklyAuctionStatus[i * 6 + 2] = rewardedAmount;\r\n            weeklyAuctionStatus[i * 6 + 3] = totalSBTAmountBid;\r\n            weeklyAuctionStatus[i * 6 + 4] = auctionStatusCode;\r\n            weeklyAuctionStatus[i * 6 + 5] = uint256(auctions[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total SBT amount put up in the auction.\r\n     */\r\n    function ongoingAuctionSBTTotal(bytes32 auctionID)\r\n        external\r\n        override\r\n        view\r\n        returns (uint64 ongoingSBTAmountE8)\r\n    {\r\n        AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n        return auctionConfig.ongoingAuctionSBTTotalE8;\r\n    }\r\n\r\n    function getAuctionCount(bytes32 bondID)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256 auctionCount)\r\n    {\r\n        return _bondIDAuctionCount[bondID];\r\n    }\r\n}\r\n\r\n// File: contracts/auction/AuctionSecret.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\nabstract contract AuctionSecret {\r\n    /**\r\n     * @param sender is the account who set this secret bid.\r\n     * @param amount is target SBT amount.\r\n     * @param IDOLamount is deposited iDOL amount attached to this secret bid.\r\n     */\r\n    struct Secret {\r\n        address sender;\r\n        uint64 amount;\r\n        uint64 IDOLamount;\r\n    }\r\n    mapping(bytes32 => mapping(bytes32 => Secret)) public auctionSecret;\r\n\r\n    function _setSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        address sender,\r\n        uint64 amount,\r\n        uint64 IDOLamount\r\n    ) internal returns (bool) {\r\n        require(\r\n            auctionSecret[auctionID][secret].sender == address(0),\r\n            \"Secret already exists\"\r\n        );\r\n        require(sender != address(0), \"the zero address cannot set secret\");\r\n        auctionSecret[auctionID][secret] = Secret({\r\n            sender: sender,\r\n            amount: amount,\r\n            IDOLamount: IDOLamount\r\n        });\r\n        return true;\r\n    }\r\n\r\n    function _removeSecret(bytes32 auctionID, bytes32 secret)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        delete auctionSecret[auctionID][secret];\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/UseAuctionLater.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\nabstract contract UseAuctionLater is DeployerRole {\r\n    Auction internal _auctionContract;\r\n\r\n    modifier isNotEmptyAuctionInstance() {\r\n        require(\r\n            address(_auctionContract) != address(0),\r\n            \"the auction contract is not set\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev This function is called only once when the code is initially deployed.\r\n     */\r\n    function setAuctionContract(address contractAddress) public onlyDeployer {\r\n        require(\r\n            address(_auctionContract) == address(0),\r\n            \"the auction contract is already registered\"\r\n        );\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _setAuctionContract(contractAddress);\r\n    }\r\n\r\n    function _setAuctionContract(address contractAddress) internal {\r\n        _auctionContract = Auction(payable(contractAddress));\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionBoard.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AuctionBoard is\r\n    UseSafeMath,\r\n    AuctionSecret,\r\n    UseStableCoin,\r\n    UseBondMaker,\r\n    UseAuctionLater\r\n{\r\n    AuctionTimeControlInterface.TimeControlFlag internal constant BEFORE_AUCTION_FLAG = AuctionTimeControlInterface\r\n        .TimeControlFlag\r\n        .BEFORE_AUCTION_FLAG;\r\n    AuctionTimeControlInterface.TimeControlFlag internal constant ACCEPTING_BIDS_PERIOD_FLAG = AuctionTimeControlInterface\r\n        .TimeControlFlag\r\n        .ACCEPTING_BIDS_PERIOD_FLAG;\r\n    AuctionTimeControlInterface.TimeControlFlag internal constant REVEALING_BIDS_PERIOD_FLAG = AuctionTimeControlInterface\r\n        .TimeControlFlag\r\n        .REVEALING_BIDS_PERIOD_FLAG;\r\n    AuctionTimeControlInterface.TimeControlFlag internal constant RECEIVING_SBT_PERIOD_FLAG = AuctionTimeControlInterface\r\n        .TimeControlFlag\r\n        .RECEIVING_SBT_PERIOD_FLAG;\r\n    AuctionTimeControlInterface.TimeControlFlag internal constant AFTER_AUCTION_FLAG = AuctionTimeControlInterface\r\n        .TimeControlFlag\r\n        .AFTER_AUCTION_FLAG;\r\n\r\n    uint64 internal constant NO_SKIP_BID = uint64(-1);\r\n    uint64 internal constant SKIP_RECEIVING_WIN_BIDS = uint64(-2);\r\n    uint256 internal immutable MAX_PRICE_INDEX;\r\n    uint256 internal immutable MAX_BOARD_INDEX;\r\n    uint256 internal immutable MAX_BOARD_INDEX_AT_END_PRICE;\r\n    uint256 internal immutable MAX_BIDCOUNT_PER_ADDRESS;\r\n\r\n    /**\r\n     * @notice The stats of the bids in the auction.\r\n     * totalIDOLSecret is the total IDOL amount of unrevealed bids.\r\n     * totalIDOLRevealed is the total IDOL amount of revealed bids.\r\n     * auctionPriceCount is the number of the unique bid price in the auction.\r\n     */\r\n    struct RevealingInfo {\r\n        uint64 totalSBTAmountBid;\r\n        uint64 totalIDOLSecret;\r\n        uint64 totalIDOLRevealed;\r\n        uint16 auctionPriceCount;\r\n    }\r\n    mapping(bytes32 => RevealingInfo) public auctionRevealInfo;\r\n\r\n    /**\r\n     * @notice The revealed bids grouped by its price. Each BidInfo has its amount and person who bid.\r\n     * @dev The contents in this internal storage variable can be seen by LogInsertBoard event.\r\n     */\r\n    struct BidInfo {\r\n        uint64 amount;\r\n        address bidder;\r\n    }\r\n    mapping(bytes32 => mapping(uint64 => BidInfo[])) internal _auctionBoard;\r\n\r\n    /**\r\n     * @notice The total SBT bid amount at the price in the auction.\r\n     * @dev The contents in this internal storage variable can be seen by getBoardStatus function.\r\n     */\r\n    mapping(bytes32 => mapping(uint64 => uint64)) internal _auctionPrice2TotalSBTAmount;\r\n\r\n    /**\r\n     * @notice The information of the person who bid in the auction.\r\n     * auctionLockedIDOLAmountE8 is the total IDOL amount locked for the bid.\r\n     * bidCount is the number of their bids.\r\n     */\r\n    struct ParticipantAmount {\r\n        uint64 auctionLockedIDOLAmountE8;\r\n        uint16 bidCount;\r\n    }\r\n    mapping(bytes32 => mapping(address => ParticipantAmount)) public auctionParticipantInfo;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by getUnsortedBidPrice function.\r\n     */\r\n    mapping(bytes32 => uint64[]) internal _auctionSortedPrice;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by getSortedBidPrice function.\r\n     */\r\n    mapping(bytes32 => uint64[]) internal _auctionUnsortedPrice;\r\n\r\n    /**\r\n     * @notice solidStrikePriceIDOLForUnrevealedE8 is the rate of SBT/IDOL for Unrevealed Bids.\r\n     * isEndInfoCreated is the flag that indicates executions of disposeOfUnrevealedBid()\r\n     * in makeEndInfo and giveUpMakeEndInfo.\r\n     * isPriceSorted is the flag that indicates the prices are successfully sorted.\r\n     */\r\n    struct DisposalInfo {\r\n        uint64 solidStrikePriceIDOLForUnrevealedE8;\r\n        uint64 solidStrikePriceIDOLForRestWinnersE8;\r\n        bool isEndInfoCreated;\r\n        bool isForceToFinalizeWinnerAmountTriggered;\r\n        bool isPriceSorted;\r\n    }\r\n    mapping(bytes32 => DisposalInfo) public auctionDisposalInfo;\r\n\r\n    /**\r\n     * @notice The indicator for the person who has the lowest winning price (priceIndex, boardIndex),\r\n     * and his losing amount (loseSBTAmount).\r\n     * @dev The contents in this internal storage variable can be seen by getEndInfo function.\r\n     * @param price is the lowest winner price.\r\n     * @param boardIndex is the maximum board index among the winner bids at the lowest price.\r\n     * @param loseSBTAmount is the unsettled amount of the bid at the lowest price and the maximum\r\n     * board index among the winner bids at the price.\r\n     * @param auctionEndPriceWinnerSBTAmount is the total amount of SBTs that have been settled\r\n     * at the lowest winner price.\r\n     */\r\n    struct AuctionWinnerDetInfo {\r\n        uint64 priceIndex;\r\n        uint64 boardIndex;\r\n        uint64 loseSBTAmount;\r\n        uint64 auctionEndPriceWinnerSBTAmount;\r\n    }\r\n    mapping(bytes32 => AuctionWinnerDetInfo) internal _auctionEndInfo;\r\n\r\n    struct AuctionInfo {\r\n        uint64 auctionSettledTotalE8;\r\n        uint64 auctionRewardedTotalE8;\r\n        uint64 auctionPaidTotalE8;\r\n    }\r\n    mapping(bytes32 => AuctionInfo) public auctionInfo;\r\n\r\n    event LogBidMemo(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes memo\r\n    );\r\n\r\n    event LogInsertBoard(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint64 bidPrice,\r\n        uint64 boardIndex,\r\n        uint64 targetSBTAmount\r\n    );\r\n\r\n    event LogAuctionInfoDiff(\r\n        bytes32 indexed auctionID,\r\n        uint64 settledAmount,\r\n        uint64 paidIDOL,\r\n        uint64 rewardedSBT\r\n    );\r\n\r\n    constructor(\r\n        address bondMakerAddress,\r\n        address IDOLAddress,\r\n        uint256 maxPriceIndex,\r\n        uint256 maxBoardIndex,\r\n        uint256 maxBoardIndexAtEndPrice,\r\n        uint256 maxBidCountPerAddress\r\n    ) public UseBondMaker(bondMakerAddress) UseStableCoin(IDOLAddress) {\r\n        require(\r\n            maxPriceIndex <= uint16(-1),\r\n            \"MAX_PRICE_INDEX must not exceed 2^16 - 1\"\r\n        );\r\n        require(\r\n            maxBoardIndex <= uint64(-1),\r\n            \"MAX_BOARD_INDEX must not exceed 2^64 - 1\"\r\n        );\r\n        require(\r\n            maxBoardIndexAtEndPrice <= uint64(-1),\r\n            \"MAX_BOARD_INDEX_AT_END_PRICE must not exceed 2^64 - 1\"\r\n        );\r\n        MAX_PRICE_INDEX = maxPriceIndex;\r\n        MAX_BOARD_INDEX = maxBoardIndex;\r\n        MAX_BOARD_INDEX_AT_END_PRICE = maxBoardIndexAtEndPrice;\r\n        MAX_BIDCOUNT_PER_ADDRESS = maxBidCountPerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Secret submission for the auction participation by hash commit.\r\n     * @dev Need to execute ERC20's approve() with IDOL amount\r\n     * (= lambda * SBTstrikePrice * SBTAmount) before this execution.\r\n     * The lambda value equals to the value used in unlockSBT.\r\n     * Hence, even in the same auction, the strike price * lambda may change.\r\n     * In such a case, they may wish to cancel their bid and resend a new one.\r\n     */\r\n    function bidWithMemo(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 targetSBTAmount,\r\n        bytes memory memo\r\n    ) public virtual {\r\n        require(\r\n            _auctionContract.isInPeriod(auctionID, ACCEPTING_BIDS_PERIOD_FLAG),\r\n            \"it is not the time to accept bids\"\r\n        );\r\n\r\n        (, , uint256 solidStrikePriceE4, ) = _getBondFromAuctionID(auctionID);\r\n        uint256 strikePriceIDOLAmount = _IDOLContract.calcSBT2IDOL(\r\n            solidStrikePriceE4.mul(targetSBTAmount)\r\n        );\r\n        require(\r\n            strikePriceIDOLAmount >= 10**10,\r\n            \"at least 100 iDOL is required for the bid Amount\"\r\n        );\r\n\r\n        _bidWithMemo(\r\n            auctionID,\r\n            secret,\r\n            targetSBTAmount,\r\n            strikePriceIDOLAmount,\r\n            memo\r\n        );\r\n    }\r\n\r\n    function _bidWithMemo(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 targetSBTAmount,\r\n        uint256 strikePriceIDOLAmount,\r\n        bytes memory memo\r\n    ) internal {\r\n        _transferIDOLFrom(\r\n            msg.sender,\r\n            address(_auctionContract),\r\n            strikePriceIDOLAmount\r\n        );\r\n\r\n        // write secret\r\n        _setSecret(\r\n            auctionID,\r\n            secret,\r\n            msg.sender,\r\n            targetSBTAmount,\r\n            strikePriceIDOLAmount.toUint64()\r\n        );\r\n        RevealingInfo memory revealInfo = auctionRevealInfo[auctionID];\r\n        revealInfo.totalSBTAmountBid = revealInfo\r\n            .totalSBTAmountBid\r\n            .add(targetSBTAmount)\r\n            .toUint64();\r\n        revealInfo.totalIDOLSecret = revealInfo\r\n            .totalIDOLSecret\r\n            .add(strikePriceIDOLAmount)\r\n            .toUint64();\r\n        auctionRevealInfo[auctionID] = revealInfo;\r\n\r\n        emit LogBidMemo(auctionID, msg.sender, memo);\r\n    }\r\n\r\n    function _revealTimeControl(bytes32 auctionID)\r\n        internal\r\n        view\r\n        returns (uint64)\r\n    {\r\n        AuctionTimeControlInterface.TimeControlFlag timeFlag = _auctionContract\r\n            .getTimeControlFlag(auctionID);\r\n        uint64 strikePrice;\r\n        if (timeFlag == ACCEPTING_BIDS_PERIOD_FLAG) {\r\n            (, , uint256 solidStrikePriceE4, ) = _getBondFromAuctionID(\r\n                auctionID\r\n            );\r\n            strikePrice = _IDOLContract\r\n                .calcSBT2IDOL(solidStrikePriceE4.mul(10**8))\r\n                .toUint64();\r\n        } else {\r\n            require(\r\n                timeFlag == REVEALING_BIDS_PERIOD_FLAG,\r\n                \"it is not the time to reveal the value of bids\"\r\n            );\r\n        }\r\n        return strikePrice;\r\n    }\r\n\r\n    function _registerNewBidPrice(bytes32 auctionID, uint256 price)\r\n        internal\r\n        view\r\n        returns (uint64)\r\n    {\r\n        uint64 bidPrice = price.toUint64();\r\n        (\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n\r\n        ) = _auctionContract.getAuctionStatus(auctionID);\r\n        if (price > highestBidPriceDeadLine) {\r\n            bidPrice = highestBidPriceDeadLine;\r\n        } else if (price < lowestBidPriceDeadLine) {\r\n            bidPrice = lowestBidPriceDeadLine;\r\n        }\r\n\r\n        bidPrice = discretizeBidPrice(bidPrice);\r\n\r\n        return bidPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Reveal the bid price publicly.\r\n     * When the bidder publishes their bids earlier than expected by the rule,\r\n     * all people can see the preimage of the bid which can potentially change behaviors of the others,\r\n     * which shuld be prevented.\r\n     * If one submits a valid proof for detecting earlier reveal,\r\n     * the bid price is overwritten by the strike price (slightly unfavored price).\r\n     * Also, if the disclosure is not processed until the deadline, the bid price is considered as\r\n     * a bid with the strike price as well (the process is done in _disposeOfUnrevealedBid()).\r\n     */\r\n    function revealBids(\r\n        bytes32 auctionID,\r\n        uint64[] memory bids,\r\n        uint64 random\r\n    ) public {\r\n        uint64 bidPrice = _revealTimeControl(auctionID);\r\n        bytes32 secret = generateMultiSecret(auctionID, bids, random);\r\n        Secret memory sec = auctionSecret[auctionID][secret];\r\n        require(sec.sender != address(0), \"secret is invalid\");\r\n        _removeSecret(auctionID, secret);\r\n\r\n        /**\r\n         * @dev bidPrice>0 means the revealing bid is too early and this deserves penalty\r\n         * that forces to bid at strikePrice.\r\n         */\r\n        uint256 targetSBTAmount;\r\n\r\n        if (bidPrice != 0) {\r\n            uint64[] memory punishBid = new uint64[](2);\r\n            punishBid[0] = bidPrice;\r\n            punishBid[1] = sec.amount;\r\n            targetSBTAmount = _revealBids(\r\n                auctionID,\r\n                sec.sender,\r\n                punishBid,\r\n                sec.IDOLamount\r\n            );\r\n        } else {\r\n            targetSBTAmount = _revealBids(\r\n                auctionID,\r\n                sec.sender,\r\n                bids,\r\n                sec.IDOLamount\r\n            );\r\n        }\r\n\r\n        require(\r\n            targetSBTAmount == sec.amount,\r\n            \"the total SBT amount info needs to be the same with that of secret.\"\r\n        );\r\n    }\r\n\r\n    function _revealBids(\r\n        bytes32 auctionID,\r\n        address bidder,\r\n        uint64[] memory bids,\r\n        uint64 strikePriceIDOLAmount\r\n    ) internal returns (uint64 targetSBTAmount) {\r\n        {\r\n\r\n                ParticipantAmount memory participantInfo\r\n             = auctionParticipantInfo[auctionID][bidder];\r\n            participantInfo.auctionLockedIDOLAmountE8 = participantInfo\r\n                .auctionLockedIDOLAmountE8\r\n                .add(strikePriceIDOLAmount)\r\n                .toUint64();\r\n            participantInfo.bidCount = participantInfo\r\n                .bidCount\r\n                .add(bids.length.div(2))\r\n                .toUint16();\r\n            auctionParticipantInfo[auctionID][bidder] = participantInfo;\r\n            require(\r\n                participantInfo.bidCount <= MAX_BIDCOUNT_PER_ADDRESS,\r\n                \"the max bid count per addres exceeded 100\"\r\n            );\r\n        }\r\n\r\n        RevealingInfo memory revealInfo = auctionRevealInfo[auctionID];\r\n        for (uint256 i = 0; i < bids.length; i += 2) {\r\n            uint64 bidPrice = _registerNewBidPrice(auctionID, bids[i]);\r\n\r\n            {\r\n                // If the auctionBoard does not have the same price, increment the count of price.\r\n                uint256 nextBoardIndex = _auctionBoard[auctionID][bidPrice]\r\n                    .length;\r\n                require(nextBoardIndex <= MAX_BOARD_INDEX, \"too many bids\");\r\n                if (nextBoardIndex == 0) {\r\n                    uint256 nextPriceIndex = _auctionUnsortedPrice[auctionID]\r\n                        .length;\r\n                    require(\r\n                        nextPriceIndex <= MAX_PRICE_INDEX,\r\n                        \"price range exceeded\"\r\n                    );\r\n                    _auctionUnsortedPrice[auctionID].push(bidPrice);\r\n                    revealInfo.auctionPriceCount = revealInfo\r\n                        .auctionPriceCount\r\n                        .add(1)\r\n                        .toUint16();\r\n                }\r\n            }\r\n\r\n            uint64 SBTAmount = bids[i + 1];\r\n\r\n            emit LogInsertBoard(\r\n                auctionID,\r\n                bidder,\r\n                bidPrice,\r\n                _auctionBoard[auctionID][bidPrice].length.toUint64(),\r\n                SBTAmount\r\n            );\r\n\r\n            _auctionBoard[auctionID][bidPrice].push(BidInfo(SBTAmount, bidder));\r\n            _auctionPrice2TotalSBTAmount[auctionID][bidPrice] = _auctionPrice2TotalSBTAmount[auctionID][bidPrice]\r\n                .add(SBTAmount)\r\n                .toUint64();\r\n\r\n            targetSBTAmount = targetSBTAmount.add(SBTAmount).toUint64();\r\n        }\r\n\r\n        revealInfo.totalIDOLRevealed = revealInfo\r\n            .totalIDOLRevealed\r\n            .add(strikePriceIDOLAmount)\r\n            .toUint64();\r\n        auctionRevealInfo[auctionID] = revealInfo;\r\n    }\r\n\r\n    /**\r\n     * @notice Create the sorted bid price data outside the contract, and check if it is correctly\r\n     * sorted from highest to lowest.\r\n     * @dev This is because creating a hash table for bids by sort will significantly increase the\r\n     * cost of gas.\r\n     */\r\n    function sortBidPrice(bytes32 auctionID, uint64[] memory sortedPrice)\r\n        public\r\n    {\r\n        uint16 bidsCount = sortedPrice.length.toUint16();\r\n\r\n        require(\r\n            _auctionContract.isAfterPeriod(\r\n                auctionID,\r\n                RECEIVING_SBT_PERIOD_FLAG\r\n            ),\r\n            \"it is not the time to insert the price data\"\r\n        );\r\n        require(\r\n            bidsCount == auctionRevealInfo[auctionID].auctionPriceCount,\r\n            \"the number of unique prices is invalid\"\r\n        );\r\n\r\n        if (bidsCount == 1) {\r\n            require(\r\n                _auctionBoard[auctionID][sortedPrice[0]].length != 0,\r\n                \"no order exists at the price\"\r\n            );\r\n            _auctionSortedPrice[auctionID] = sortedPrice;\r\n        } else if (bidsCount != 0) {\r\n            // Large/small check for each price (large-> small)\r\n            for (uint16 i = 0; i < bidsCount - 1; i++) {\r\n                uint64 current = sortedPrice[i];\r\n                uint64 next = sortedPrice[i + 1];\r\n                require(current > next, \"sortedPrice is not sorted correctly\");\r\n                require(\r\n                    _auctionBoard[auctionID][current].length != 0,\r\n                    \"no order exists at the price\"\r\n                );\r\n            }\r\n\r\n            require(\r\n                _auctionBoard[auctionID][sortedPrice[bidsCount - 1]].length !=\r\n                    0,\r\n                \"no order exists at the price\"\r\n            );\r\n\r\n            // Completion of sorted bid price data\r\n            _auctionSortedPrice[auctionID] = sortedPrice;\r\n        }\r\n\r\n        // Initialize bidIndex to 0. Used in the following endAuction process.\r\n        auctionDisposalInfo[auctionID].isPriceSorted = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Unrevealed secret is punished.\r\n     * The total locked IDOL is exchanged for the SBT (the penalty fee is very small in general).\r\n     */\r\n    function _disposeOfUnrevealedBid(bytes32 auctionID) internal {\r\n        DisposalInfo memory disposalInfo = auctionDisposalInfo[auctionID];\r\n\r\n        RevealingInfo memory revealInfo = auctionRevealInfo[auctionID];\r\n\r\n        require(\r\n            !disposalInfo.isEndInfoCreated,\r\n            \"This Function should be triggered only once\"\r\n        );\r\n        require(\r\n            disposalInfo.isPriceSorted,\r\n            \"Prices need to be sorted before the execution of _disposeOfUnrevealedBid\"\r\n        );\r\n        (, , uint256 solidStrikePriceE4, ) = _getBondFromAuctionID(auctionID); // strikePrice in IDOL unit\r\n        // calcSBT2IDOL executes the multiplication of lambda to the strike price\r\n        uint256 solidStrikePriceIDOL = _IDOLContract.calcSBT2IDOL(\r\n            solidStrikePriceE4.mul(10**8)\r\n        );\r\n\r\n        // (total target) - (total revealed) = (total unrevealed)\r\n        uint256 IDOLAmountUnrevealedBid = revealInfo.totalIDOLSecret.sub(\r\n            revealInfo.totalIDOLRevealed\r\n        );\r\n        uint256 totalSBTAmountE8 = IDOLAmountUnrevealedBid.mul(10**8).div(\r\n            solidStrikePriceIDOL,\r\n            \"system error: SBT strike price should not be zero value\"\r\n        );\r\n\r\n        {\r\n            uint64 ongoingAmount = _auctionContract.ongoingAuctionSBTTotal(\r\n                auctionID\r\n            );\r\n            if (totalSBTAmountE8 > ongoingAmount) {\r\n                totalSBTAmountE8 = ongoingAmount;\r\n                IDOLAmountUnrevealedBid = totalSBTAmountE8\r\n                    .mul(solidStrikePriceIDOL)\r\n                    .div(10**8);\r\n            }\r\n        }\r\n\r\n        disposalInfo.solidStrikePriceIDOLForUnrevealedE8 = solidStrikePriceIDOL\r\n            .toUint64();\r\n\r\n        // It is necessary to atomically burn IDOL and to return SBT in order to keep the lambda value consistent.\r\n        _updateAuctionInfo(\r\n            auctionID,\r\n            totalSBTAmountE8.toUint64(),\r\n            IDOLAmountUnrevealedBid.toUint64(),\r\n            totalSBTAmountE8.toUint64()\r\n        );\r\n        disposalInfo.isEndInfoCreated = true;\r\n        auctionDisposalInfo[auctionID] = disposalInfo;\r\n    }\r\n\r\n    function makeEndInfo(bytes32 auctionID) public {\r\n        _disposeOfUnrevealedBid(auctionID);\r\n\r\n        AuctionTimeControlInterface.TimeControlFlag timeFlag = _auctionContract\r\n            .getTimeControlFlag(auctionID);\r\n        if (timeFlag == RECEIVING_SBT_PERIOD_FLAG) {\r\n            _makeAuctionEndInfo(auctionID);\r\n            return;\r\n        }\r\n\r\n        require(\r\n            timeFlag > RECEIVING_SBT_PERIOD_FLAG,\r\n            \"it is not the time to receive winning SBT\"\r\n        );\r\n        _giveUpMakeAuctionEndInfo(auctionID);\r\n    }\r\n\r\n    /**\r\n     * @notice only decides the lowest winning price, and let each winner calculate their own winning amount in a different function.\r\n     * This function still works even when the network is too crowded.\r\n     * This is different from endAuction, which decides both all the winning amounts per winner and the lowest winning price,\r\n     * but endAuction cannot work when the network is too crowded.\r\n     */\r\n    function _makeAuctionEndInfo(bytes32 auctionID) internal {\r\n        if (_auctionSortedPrice[auctionID].length == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 winnerAmountCount = 0;\r\n\r\n        uint64 ongoingAmount = _auctionContract.ongoingAuctionSBTTotal(\r\n            auctionID\r\n        );\r\n        uint256 SBTAuctionTotal = ongoingAmount.sub(\r\n            auctionInfo[auctionID].auctionSettledTotalE8,\r\n            \"system error: settled amount exceeds auction amount\"\r\n        );\r\n\r\n        uint256 SBTAmountAtLowestWinnerPrice;\r\n        uint256 lowestWinnerPriceIndex;\r\n        uint256 price;\r\n        bool endFlag = false;\r\n        for (uint256 i = 0; i < _auctionSortedPrice[auctionID].length; i++) {\r\n            price = _auctionSortedPrice[auctionID][i];\r\n            uint256 SBTAmount = _auctionPrice2TotalSBTAmount[auctionID][price\r\n                .toUint64()];\r\n            uint256 diffAmount = SBTAuctionTotal.sub(winnerAmountCount);\r\n            lowestWinnerPriceIndex = i;\r\n            if (SBTAmount > diffAmount) {\r\n                SBTAmountAtLowestWinnerPrice = diffAmount;\r\n                endFlag = true;\r\n                break;\r\n            }\r\n\r\n            winnerAmountCount = winnerAmountCount.add(SBTAmount);\r\n\r\n            if (SBTAmount == diffAmount) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @dev For the case that the total bid amount is less than the total SBT amount put up in the auction,\r\n         * all the bids result in buying SBT.\r\n         */\r\n        if (!endFlag) {\r\n            AuctionWinnerDetInfo memory endInfo = AuctionWinnerDetInfo(\r\n                lowestWinnerPriceIndex.toUint64(),\r\n                (_auctionBoard[auctionID][price.toUint64()].length - 1)\r\n                    .toUint64(),\r\n                0,\r\n                _auctionPrice2TotalSBTAmount[auctionID][price.toUint64()]\r\n            );\r\n            _auctionEndInfo[auctionID] = endInfo;\r\n            auctionInfo[auctionID]\r\n                .auctionSettledTotalE8 = auctionInfo[auctionID]\r\n                .auctionSettledTotalE8\r\n                .add(winnerAmountCount)\r\n                .toUint64();\r\n            return;\r\n        }\r\n\r\n        SBTAuctionTotal = winnerAmountCount; // [WARNING] here we are using SBTAuctionTotal for another purpose to avoid Stack too deep\r\n        winnerAmountCount = 0;\r\n\r\n        for (uint256 j = 0; j <= MAX_BOARD_INDEX_AT_END_PRICE; j++) {\r\n\r\n                uint256 bidPrice\r\n             = _auctionSortedPrice[auctionID][lowestWinnerPriceIndex];\r\n\r\n            // j is guaranteed to be less than _auctionBoard[auctionID][bidPrice.toUint64()].length\r\n            // because of the check of total SBT amount at the end of the loop above.\r\n            BidInfo memory bidInfo = _auctionBoard[auctionID][bidPrice\r\n                .toUint64()][j];\r\n            uint256 diffAmount = SBTAmountAtLowestWinnerPrice.sub(\r\n                winnerAmountCount\r\n            );\r\n            winnerAmountCount = winnerAmountCount.add(bidInfo.amount);\r\n\r\n            if (bidInfo.amount >= diffAmount) {\r\n                uint256 loseSBTAmount = bidInfo.amount.sub(diffAmount);\r\n                _auctionEndInfo[auctionID] = AuctionWinnerDetInfo(\r\n                    lowestWinnerPriceIndex.toUint64(),\r\n                    j.toUint64(),\r\n                    loseSBTAmount.toUint64(),\r\n                    SBTAmountAtLowestWinnerPrice.toUint64()\r\n                );\r\n                winnerAmountCount = winnerAmountCount.sub(loseSBTAmount);\r\n                break;\r\n            } else if (j == MAX_BOARD_INDEX_AT_END_PRICE) {\r\n                /**\r\n                 * @dev For spam protection, we stop summing up the winning bid at the lowest winning price.\r\n                 * In this case, the second aucion will be held.\r\n                 */\r\n                _auctionEndInfo[auctionID] = AuctionWinnerDetInfo(\r\n                    lowestWinnerPriceIndex.toUint64(),\r\n                    j.toUint64(),\r\n                    0,\r\n                    winnerAmountCount.toUint64()\r\n                );\r\n            }\r\n        }\r\n        auctionInfo[auctionID].auctionSettledTotalE8 = auctionInfo[auctionID]\r\n            .auctionSettledTotalE8\r\n            .add(SBTAuctionTotal.add(winnerAmountCount))\r\n            .toUint64();\r\n    }\r\n\r\n    function _giveUpMakeAuctionEndInfo(bytes32 auctionID) internal {\r\n        if (_auctionSortedPrice[auctionID].length != 0) {\r\n            uint64 highestBidPrice = _auctionSortedPrice[auctionID][0];\r\n\r\n            if (_auctionBoard[auctionID][highestBidPrice].length != 0) {\r\n                _auctionEndInfo[auctionID]\r\n                    .loseSBTAmount = _auctionBoard[auctionID][highestBidPrice][0]\r\n                    .amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function calcBill(\r\n        bytes32 auctionID,\r\n        uint64 winnerAmount,\r\n        uint64 myLowestPrice\r\n    ) public view returns (uint64) {\r\n        AuctionWinnerDetInfo memory endInfo = _auctionEndInfo[auctionID];\r\n\r\n        uint256 toPayPlusSkip = 0;\r\n        bool myLowestVerify = false;\r\n        uint256 restWinnerAmount = winnerAmount;\r\n\r\n        // Here we start the counting of the payment by using winnerAmount and Loser Bid Prices.\r\n        // At this moment, winnerAmount includes losing amount for optimizing calculation.\r\n        // Verifying the loser bids (function input) is also required after this loop.\r\n        for (\r\n            uint256 i = endInfo.priceIndex;\r\n            i < _auctionSortedPrice[auctionID].length;\r\n            i++\r\n        ) {\r\n            uint64 price = _auctionSortedPrice[auctionID][i];\r\n            uint64 SBTAmount = _auctionPrice2TotalSBTAmount[auctionID][price];\r\n            if (price <= myLowestPrice) {\r\n                myLowestVerify = true;\r\n            }\r\n\r\n            if (i == endInfo.priceIndex) {\r\n                // losing SBT amount at the lowest winning price (the highest losing price)\r\n                SBTAmount = SBTAmount\r\n                    .sub(endInfo.auctionEndPriceWinnerSBTAmount)\r\n                    .toUint64();\r\n            }\r\n\r\n            if (restWinnerAmount > SBTAmount) {\r\n                toPayPlusSkip = toPayPlusSkip.add(\r\n                    SBTAmount.mul(price).divRoundUp(10**8)\r\n                );\r\n                restWinnerAmount = restWinnerAmount.sub(SBTAmount);\r\n            } else {\r\n                toPayPlusSkip = toPayPlusSkip.add(\r\n                    restWinnerAmount.mul(price).divRoundUp(10**8)\r\n                );\r\n                restWinnerAmount = 0;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (myLowestPrice != NO_SKIP_BID) {\r\n            require(\r\n                myLowestVerify,\r\n                \"myLowestVerify is false: incorrect input :[myLowestPrice]3\"\r\n            );\r\n        }\r\n\r\n        (, , , , , , , uint256 lowestBidPriceDeadLine, , ) = _auctionContract\r\n            .getAuctionStatus(auctionID);\r\n        toPayPlusSkip = toPayPlusSkip.add(\r\n            restWinnerAmount.mul(lowestBidPriceDeadLine).divRoundUp(10**8)\r\n        );\r\n\r\n        return toPayPlusSkip.toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice In this auction process, all the bids are secretly submitted, and are revealed later on.\r\n     * This function provides the form of hash commit.\r\n     */\r\n    function generateMultiSecret(\r\n        bytes32 auctionID,\r\n        uint64[] memory bids,\r\n        uint64 random\r\n    ) public pure returns (bytes32 secret) {\r\n        secret = keccak256(abi.encodePacked(auctionID, bids, random));\r\n    }\r\n\r\n    function deleteParticipantInfo(bytes32 auctionID, address participant)\r\n        public\r\n    {\r\n        require(\r\n            msg.sender == address(_auctionContract),\r\n            \"only auction contract allow to invoke deleteParticipantInfo\"\r\n        );\r\n        delete auctionParticipantInfo[auctionID][participant];\r\n    }\r\n\r\n    /**\r\n     * @dev This function returns the price rounded off to the top 4 digits.\r\n     */\r\n    function discretizeBidPrice(uint64 priceE8)\r\n        public\r\n        pure\r\n        returns (uint64)\r\n    {\r\n        if (priceE8 < 5 * 10**8) {\r\n            return priceE8.div(10**4).mul(10**4).toUint64();\r\n        } else if (priceE8 < 5 * 10**9) {\r\n            return priceE8.div(10**5).mul(10**5).toUint64();\r\n        } else if (priceE8 < 5 * 10**10) {\r\n            return priceE8.div(10**6).mul(10**6).toUint64();\r\n        } else if (priceE8 < 5 * 10**11) {\r\n            return priceE8.div(10**7).mul(10**7).toUint64();\r\n        } else if (priceE8 < 5 * 10**12) {\r\n            return priceE8.div(10**8).mul(10**8).toUint64();\r\n        } else if (priceE8 < 5 * 10**13) {\r\n            return priceE8.div(10**9).mul(10**9).toUint64();\r\n        } else if (priceE8 < 5 * 10**14) {\r\n            return priceE8.div(10**10).mul(10**10).toUint64();\r\n        } else {\r\n            return priceE8.div(10**11).mul(10**11).toUint64();\r\n        }\r\n    }\r\n\r\n    function updateAuctionInfo(\r\n        bytes32 auctionID,\r\n        uint64 settledAmountE8,\r\n        uint64 paidIDOLE8,\r\n        uint64 rewardedSBTE8\r\n    ) external {\r\n        require(\r\n            msg.sender == address(_auctionContract),\r\n            \"only auction contract is allowed to invoke updateAuctionInfo\"\r\n        );\r\n        _updateAuctionInfo(\r\n            auctionID,\r\n            settledAmountE8,\r\n            paidIDOLE8,\r\n            rewardedSBTE8\r\n        );\r\n    }\r\n\r\n    /**\r\n     *@notice updates AuctionInfo structure simultineously to make gas cheaper.\r\n     */\r\n    function _updateAuctionInfo(\r\n        bytes32 auctionID,\r\n        uint64 settledAmountE8,\r\n        uint64 paidIDOLE8,\r\n        uint64 rewardedSBTE8\r\n    ) internal {\r\n        AuctionInfo memory _auctionInfo = auctionInfo[auctionID];\r\n        _auctionInfo.auctionSettledTotalE8 = _auctionInfo\r\n            .auctionSettledTotalE8\r\n            .add(settledAmountE8)\r\n            .toUint64();\r\n        // Calculate the cumulative amount of IDOL that is already paid and not to be returned.\r\n        _auctionInfo.auctionPaidTotalE8 = _auctionInfo\r\n            .auctionPaidTotalE8\r\n            .add(paidIDOLE8)\r\n            .toUint64();\r\n        // Calculate the cumulative amount of SBT that is already decided to be distributed.\r\n        _auctionInfo.auctionRewardedTotalE8 = _auctionInfo\r\n            .auctionRewardedTotalE8\r\n            .add(rewardedSBTE8)\r\n            .toUint64();\r\n        auctionInfo[auctionID] = _auctionInfo;\r\n        emit LogAuctionInfoDiff(\r\n            auctionID,\r\n            settledAmountE8,\r\n            paidIDOLE8,\r\n            rewardedSBTE8\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev get the bond information from the auctionID\r\n     */\r\n    function _getBondFromAuctionID(bytes32 auctionID)\r\n        internal\r\n        view\r\n        returns (\r\n            address erc20Address,\r\n            uint256 maturity,\r\n            uint64 stableStrikePrice,\r\n            bytes32 fnMapID\r\n        )\r\n    {\r\n        bytes32 bondID = _auctionContract.auctionID2BondID(auctionID);\r\n        return _bondMakerContract.getBond(bondID);\r\n    }\r\n\r\n    /**\r\n     * @notice this function is a view fuction for client side. The return value of this will be used and verified in makeAuctionResult.\r\n     */\r\n    function calcMyLowestPrice(\r\n        bytes32 auctionID,\r\n        uint64 winnerAmount,\r\n        uint64[] calldata myLoseBids\r\n    ) external view returns (uint64 myLowestPrice) {\r\n        AuctionWinnerDetInfo memory endInfo = _auctionEndInfo[auctionID];\r\n        myLowestPrice = uint64(-1);\r\n        if (winnerAmount == 0) {\r\n            return myLowestPrice;\r\n        }\r\n\r\n        uint256 restWinnerAmount = winnerAmount;\r\n        uint256 myLoseBidsIndex = 0;\r\n        for (\r\n            uint256 priceIndex = endInfo.priceIndex;\r\n            priceIndex < _auctionSortedPrice[auctionID].length;\r\n            priceIndex++\r\n        ) {\r\n            uint64 price = _auctionSortedPrice[auctionID][priceIndex];\r\n\r\n\r\n                uint64 totalSBTAmount\r\n             = _auctionPrice2TotalSBTAmount[auctionID][price];\r\n\r\n            if (priceIndex == endInfo.priceIndex) {\r\n                // losing SBT amount at the lowest winning price (the highest losing price)\r\n                if (totalSBTAmount == endInfo.auctionEndPriceWinnerSBTAmount) {\r\n                    continue;\r\n                }\r\n                totalSBTAmount = totalSBTAmount\r\n                    .sub(endInfo.auctionEndPriceWinnerSBTAmount)\r\n                    .toUint64();\r\n            }\r\n\r\n            while (\r\n                myLoseBidsIndex + 1 < myLoseBids.length &&\r\n                myLoseBids[myLoseBidsIndex] == price\r\n            ) {\r\n                if (\r\n                    priceIndex == endInfo.priceIndex &&\r\n                    myLoseBids[myLoseBidsIndex + 1] == endInfo.boardIndex\r\n                ) {\r\n                    if (endInfo.loseSBTAmount != 0) {\r\n                        restWinnerAmount = restWinnerAmount.add(\r\n                            endInfo.loseSBTAmount\r\n                        );\r\n                        myLowestPrice = price;\r\n                    }\r\n                } else {\r\n\r\n                        BidInfo memory bidInfo\r\n                     = _auctionBoard[auctionID][price][myLoseBids[myLoseBidsIndex +\r\n                        1]];\r\n                    restWinnerAmount = restWinnerAmount.add(bidInfo.amount);\r\n                    myLowestPrice = price;\r\n                }\r\n                myLoseBidsIndex += 2;\r\n            }\r\n\r\n            if (restWinnerAmount > totalSBTAmount) {\r\n                restWinnerAmount = restWinnerAmount.sub(totalSBTAmount);\r\n            } else {\r\n                restWinnerAmount = 0;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice removeSecret is only allowed by Auction Contract cancelBid function.\r\n     */\r\n    function removeSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 subtractAmount\r\n    ) external {\r\n        require(\r\n            msg.sender == address(_auctionContract),\r\n            \"only auction contract is allowed to invoke removeSecret\"\r\n        );\r\n        _removeSecret(auctionID, secret);\r\n        if (subtractAmount != 0) {\r\n            RevealingInfo storage revealInfo = auctionRevealInfo[auctionID];\r\n            revealInfo.totalIDOLSecret = revealInfo\r\n                .totalIDOLSecret\r\n                .sub(subtractAmount)\r\n                .toUint64();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Functions bellow are view functions.\r\n     */\r\n\r\n    function auctionBoard(\r\n        bytes32 auctionID,\r\n        uint64 bidPrice,\r\n        uint256 boardIndex\r\n    ) public view returns (uint64 amount, address bidder) {\r\n        require(\r\n            boardIndex < _auctionBoard[auctionID][bidPrice].length,\r\n            \"out of index\"\r\n        );\r\n\r\n\r\n            BidInfo storage bidInfo\r\n         = _auctionBoard[auctionID][bidPrice][boardIndex];\r\n        return (bidInfo.amount, bidInfo.bidder);\r\n    }\r\n\r\n    function getUnsortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory)\r\n    {\r\n        return _auctionUnsortedPrice[auctionID];\r\n    }\r\n\r\n    function getSortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory)\r\n    {\r\n        return _auctionSortedPrice[auctionID];\r\n    }\r\n\r\n    /**\r\n     * @param auctionID is an auction ID.\r\n     * @return price is the lowest winner price.\r\n     * @return boardIndex is the maximum board index among the winner bids at the lowest price.\r\n     * @return loseSBTAmount is the unsettled amount of the bid at the lowest price and the maximum\r\n     * board index among the winner bids at the price.\r\n     * @return auctionEndPriceWinnerSBTAmount is the total amount of SBTs that have been settled\r\n     * at the lowest winner price.\r\n     */\r\n    function getEndInfo(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 price,\r\n            uint64 boardIndex,\r\n            uint64 loseSBTAmount,\r\n            uint64 auctionEndPriceWinnerSBTAmount\r\n        )\r\n    {\r\n        AuctionWinnerDetInfo memory endInfo = _auctionEndInfo[auctionID];\r\n        if (!auctionDisposalInfo[auctionID].isEndInfoCreated) {\r\n            // before executing makeEndInfo\r\n            return (0, 0, 0, 0);\r\n        }\r\n        if (_auctionSortedPrice[auctionID].length == 0) {\r\n            // no revealed bid\r\n            return (0, 0, 0, 0);\r\n        }\r\n\r\n        // This function does not return the initial value of AuctionWinnerDetInfo except for the two cases above.\r\n\r\n        price = _auctionSortedPrice[auctionID][endInfo.priceIndex];\r\n        boardIndex = endInfo.boardIndex;\r\n        loseSBTAmount = endInfo.loseSBTAmount;\r\n        auctionEndPriceWinnerSBTAmount = endInfo.auctionEndPriceWinnerSBTAmount;\r\n        require(\r\n            !(price == 0 &&\r\n                boardIndex == 0 &&\r\n                loseSBTAmount == 0 &&\r\n                auctionEndPriceWinnerSBTAmount == 0),\r\n            \"system error: the end info should not be initial value\"\r\n        );\r\n    }\r\n\r\n    function getBidderStatus(bytes32 auctionID, address bidder)\r\n        external\r\n        view\r\n        returns (uint64 toBack, bool isIDOLReturned)\r\n    {\r\n        toBack = auctionParticipantInfo[auctionID][bidder]\r\n            .auctionLockedIDOLAmountE8;\r\n        isIDOLReturned = (toBack != 0);\r\n    }\r\n\r\n    function getBoard(\r\n        bytes32 auctionID,\r\n        uint64 price,\r\n        uint64 boardIndex\r\n    ) external view returns (address bidder, uint64 amount) {\r\n        BidInfo memory bidInfo = _auctionBoard[auctionID][price][boardIndex];\r\n        return (bidInfo.bidder, bidInfo.amount);\r\n    }\r\n\r\n    function getBoardStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory boardStatus)\r\n    {\r\n        uint256 priceCount = _auctionSortedPrice[auctionID].length;\r\n        boardStatus = new uint64[](priceCount);\r\n        for (uint256 i = 0; i < priceCount; i++) {\r\n            uint64 price = _auctionSortedPrice[auctionID][i];\r\n            boardStatus[i] = _auctionPrice2TotalSBTAmount[auctionID][price];\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bondMakerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"IDOLAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auctionBoardAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minNormalAuctionPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEmergencyAuctionPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normalAuctionRevealSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyAuctionRevealSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionWithdrawSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyAuctionWithdrawSpan\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"SBTAmountOfReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"IDOLAmountOfPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"IDOLAmountOfChange\",\"type\":\"uint256\"}],\"name\":\"LogAuctionResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedIDOLAmount\",\"type\":\"uint256\"}],\"name\":\"LogCancelBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLast\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nextAuctionID\",\"type\":\"bytes32\"}],\"name\":\"LogCloseAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"LogStartAuction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionClosingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionID2BondID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"winnerAmountInput\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"myLowestPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64[]\",\"name\":\"myLoseBids\",\"type\":\"uint64[]\"}],\"name\":\"calcBillAndCheckLoserBids\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64[]\",\"name\":\"winnerBids\",\"type\":\"uint64[]\"}],\"name\":\"calcWinnerAmount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"cancelBid\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"closeAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"generateAuctionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"getAuctionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"getAuctionStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"auctionAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rewardedAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalSBTAmountBid\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isEmergency\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"doneFinalizeWinnerAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"doneSortPrice\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"lowestBidPriceDeadLine\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"highestBidPriceDeadLine\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalSBTAmountPaidForUnrevealed\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"getCurrentAuctionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"getTimeControlFlag\",\"outputs\":[{\"internalType\":\"enum AuctionTimeControlInterface.TimeControlFlag\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekNumber\",\"type\":\"uint256\"}],\"name\":\"getWeeklyAuctionStatus\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"weeklyAuctionStatus\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"enum AuctionTimeControlInterface.TimeControlFlag\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"isAfterPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isAuctionEmergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"enum AuctionTimeControlInterface.TimeControlFlag\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"isInPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekNumber\",\"type\":\"uint256\"}],\"name\":\"listAuction\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"auctionIDs\",\"type\":\"bytes32[]\"}],\"name\":\"listBondIDFromAuctionID\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"bondIDs\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"myLowestPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64[]\",\"name\":\"winnerBids\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"loserBids\",\"type\":\"uint64[]\"}],\"name\":\"makeAuctionResult\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"ongoingAuctionSBTTotal\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"ongoingSBTAmountE8\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"receiveUnrevealedBidDistribution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"auctionAmount\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isEmergency\",\"type\":\"bool\"}],\"name\":\"startAuction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Auction","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"00000000000000000000000001784ee895107564096279f4da016e2fab636edb0000000000000000000000007c73cc13b6054de69489a8a1d15ad254a7641c070000000000000000000000004e70aaa4f3072a426fdc573059ff1a856b37f9f900000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000e10","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6604265203a9f9aa65d1a5f1204da2aec9bd05ff74f3298e42943cb0dc22f94b"}]}