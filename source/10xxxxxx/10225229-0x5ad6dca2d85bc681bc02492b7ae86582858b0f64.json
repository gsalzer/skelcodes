{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n/*\r\nThis token is designed specifically for the Generation Guild International Consumer Cooperative.\r\nDeveloper Alex Burn.\r\ngithub https://github.com/alexburndev/gcg/blob/master/cit_with_reward.sol\r\n*/\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal view returns (uint256) {\r\n        uint256 c = a + b;\r\n //       require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal view returns (uint256) {\r\n//        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal view returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal view returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n    \r\n        uint256 c = a / b;\r\n       // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal view returns (uint256) {\r\n \r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract owned {\r\n    address public owner;\r\n \r\n\r\n    function owned() payable {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    address public addressSupportProject = 0x009AE8DDCBF8aba5b04d49d034146A6b8E3a8B0a; //AB\r\n    \r\n       function setaddressSupportProject(address _addr ) public onlyOwner {\r\n       require(_addr != 0);\r\n       addressSupportProject = _addr;\r\n    }\r\n    \r\n    \r\n}\r\n\r\n\r\n\r\ncontract Crowdsale is owned {\r\n    \r\n   using Address for address;\r\n   using SafeMath for uint256;\r\n    \r\n   uint256 tokensPerOneEther = 16000;\r\n    struct HolderData {\r\n        uint256 funds;\r\n        uint256 lastDatetime;\r\n        uint256 TokenOnAcc;\r\n        uint256 reward;\r\n        \r\n   \r\n        uint256 holdersID;\r\n        \r\n        address blackList;\r\n    \r\n       \r\n    }\r\n    \r\n    struct ReferalData {\r\n        address ref;\r\n        uint8 refUserCount;\r\n     \r\n    }\r\n    \r\n    \r\n    uint256 public totalSupply;\r\n    \r\n    uint256 internal LastID;\r\n    \r\n    uint256 public totalToken;\r\n    \r\n    uint256 public totalHolders;\r\n    \r\n    uint256 internal reward_to;\r\n    \r\n    uint256 internal reward_sender;\r\n    \r\n    uint256 internal P = 10;\r\n    \r\n    \r\n    \r\n    \r\n   \r\n    mapping (address => uint256) public balanceOf;\r\n   \r\n    mapping (address => HolderData) public holders;\r\n    \r\n    mapping(address => address) public refList;\r\n    \r\n    mapping(address => ReferalData) public referals;\r\n    \r\n   \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n  \r\n    function bytesToAddress(bytes memory bys) private returns (address addr) {\r\n        assembly {\r\n          addr := mload(add(bys,20))\r\n        } \r\n    }\r\n    \r\n    \r\n   \r\n    function Crowdsale() payable owned() {\r\n   \r\n      HolderData storage data = holders[owner];\r\n      ReferalData storage data_ref = referals[owner];\r\n      \r\n        totalSupply =     1000000;\r\n        balanceOf[this] =  800000;\r\n        balanceOf[owner] = totalSupply - balanceOf[this];\r\n        balanceOf[addressSupportProject]=100000;\r\n        totalToken += balanceOf[owner];\r\n        totalHolders ++;\r\n        \r\n        data_ref.refUserCount ++;\r\n        data_ref.ref = owner;\r\n        \r\n        data.holdersID = totalHolders;\r\n        data.lastDatetime = now;\r\n        \r\n        Transfer(this, owner, balanceOf[owner]);\r\n        Transfer(this, addressSupportProject, balanceOf[addressSupportProject]);\r\n    }\r\n    \r\n   \r\n\r\n\r\n    function () payable external{\r\n        \r\n        assert(msg.sender == tx.origin); // prevent bots to interact with contract\r\n        require(balanceOf[this] > 0);\r\n        require(msg.value > 0);\r\n        \r\n        HolderData storage data = holders[msg.sender];\r\n        HolderData storage data2 = holders[msg.sender];\r\n        ReferalData storage data_ref = referals[msg.sender];\r\n        \r\n        if (data.blackList == msg.sender) return ;\r\n        \r\n        uint256 tokens = tokensPerOneEther * msg.value / 1000000000000000000;\r\n        if (tokens > balanceOf[this]) {\r\n            tokens = balanceOf[this];\r\n            uint valueWei = tokens * 1000000000000000000 / tokensPerOneEther;\r\n            msg.sender.transfer(msg.value - valueWei);\r\n        }\r\n        data.funds += msg.value / 10**18;\r\n        \r\n        // Reward\r\n        \r\n        require(tokens > 0);\r\n        \r\n        if (balanceOf[msg.sender] == 0){\r\n         totalHolders ++;\r\n         data.holdersID = totalHolders ;\r\n         data.lastDatetime = now;\r\n         data.reward = 0;\r\n        \r\n            if (msg.data.length == 0)\r\n             {\r\n               data_ref.ref = address(owner);\r\n               refList[msg.sender] = address(owner);\r\n         \r\n             } \r\n             else {\r\n                    require(msg.data.length == 20);\r\n                    data_ref.ref = bytesToAddress(msg.data);\r\n                    refList[msg.sender] = bytesToAddress(msg.data);\r\n                    assert(data_ref.ref != msg.sender);\r\n                    }\r\n         \r\n         data_ref.refUserCount++;\r\n         data.holdersID = totalHolders;\r\n         \r\n         }\r\n         \r\n         else {\r\n           \r\n           reward_sender = reward_info (msg.sender);\r\n               if (reward_sender > 0) { \r\n                  balanceOf[msg.sender] += reward_sender;\r\n                  balanceOf[this] -= reward_to;\r\n                  data2.lastDatetime = now;\r\n                  data.reward = 0;\r\n                  Transfer(this, msg.sender, reward_sender);\r\n                }\r\n           \r\n            \r\n             \r\n          }\r\n        \r\n        \r\n        balanceOf[msg.sender] += tokens;\r\n        balanceOf[this] -= tokens;\r\n        totalToken += tokens;\r\n       \r\n        \r\n      \r\n     \r\n        Transfer(this, msg.sender, tokens);\r\n        \r\n        \r\n      // Transfer 15% for Support\r\n        \r\n        uint256 eth_amount = msg.value * 15/100;\r\n     \r\n        addressSupportProject.transfer(eth_amount);\r\n        \r\n    }\r\n    \r\n    function ChangeProcentReward (uint256 NewProcent) public onlyOwner {\r\n       P = NewProcent;\r\n    }\r\n    \r\n    function reward_info(address addressHolder) public view returns (uint256 Reward) {\r\n        require(balanceOf[addressHolder] > 0);\r\n        HolderData storage data = holders[addressHolder];\r\n  \r\n        \r\n        Reward = balanceOf[addressHolder].mul(P).div(100).mul(block.timestamp - data.lastDatetime).div(30 days);\r\n        \r\n   \r\n    }\r\n    \r\n    \r\n    \r\n    function changeTokensPerOneEther(uint256 newPrice) public onlyOwner {\r\n        tokensPerOneEther = newPrice;\r\n    }\r\n    \r\n    \r\n    \r\n     \r\n        \r\n}\r\n\r\ncontract CIT_Token is Crowdsale {\r\n    \r\n    string  public standard    = 'Сooperative Internal Token';\r\n    string  public name        = 'Сooperative Internal Token';\r\n    string  public symbol      = \"CIT\";\r\n    uint8   public decimals    = 0;\r\n\r\n    function CIT_Token() payable Crowdsale() {}\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        require (_value > 0);\r\n        require(balanceOf[msg.sender] >= _value);\r\n        \r\n        HolderData storage data = holders[_to];\r\n        HolderData storage data2 = holders[msg.sender];\r\n        ReferalData storage data_ref = referals[_to];\r\n        \r\n        if (holders[_to].blackList == _to) return ;\r\n        \r\n        \r\n  \r\n        \r\n        if (balanceOf[_to] == 0){\r\n         totalHolders ++;\r\n         data.holdersID = totalHolders ;\r\n         address ref = msg.sender;\r\n         data_ref.ref = ref;\r\n         refList[msg.sender] = ref;\r\n         data_ref.refUserCount++;\r\n         data.holdersID = totalHolders;\r\n        }\r\n        \r\n        address general = this;\r\n    \r\n        if ( _to == general) { \r\n            \r\n            holders[msg.sender].TokenOnAcc += _value;\r\n            \r\n        }\r\n        \r\n  //     Reward accrual\r\n        \r\n        if (_to != address(this) && balanceOf[_to] !=0) {\r\n                reward_to = reward_info (_to);\r\n             if (reward_to > 0 ) { \r\n                 balanceOf[_to] += reward_to ;\r\n                 balanceOf[this] -= reward_to;\r\n                 data.lastDatetime = now;\r\n                 data.reward = 0;\r\n                 \r\n                 Transfer(this, _to, reward_to);\r\n             }\r\n        }\r\n        \r\n        if (balanceOf[_to] == 0 ) data.lastDatetime = now;\r\n             \r\n        if (msg.sender != address(this) ) {\r\n               reward_sender = reward_info (msg.sender);\r\n            if (reward_sender > 0) { \r\n                balanceOf[msg.sender] += reward_sender;\r\n                balanceOf[this] -= reward_to;\r\n                data2.lastDatetime = now;\r\n                data.reward = 0;\r\n                Transfer(this, msg.sender, reward_sender);\r\n            }\r\n        }\r\n            \r\n    \r\n    \r\n         balanceOf[msg.sender] -= _value;\r\n         balanceOf[_to] += _value;\r\n         Transfer(msg.sender, _to, _value);\r\n \r\n        \r\n     }\r\n\r\n \r\n     function transferFromContract(address _to, uint256 _value) public onlyOwner {\r\n        \r\n        transfer(_to, _value);\r\n        \r\n \r\n    }  \r\n      \r\n      \r\n     function contract_balance() view public returns (uint256 ethBalance, uint256 tokenBalance,uint256 tokenPrice) {\r\n        ethBalance = address(this).balance;\r\n        tokenBalance = balanceOf[this];\r\n        tokenPrice = tokensPerOneEther;\r\n      }\r\n    \r\n    function getHolderInfo(address addressHolder) view public returns (uint256 ethBalanceOnContract, \r\n    uint256 tokenBalanceOnMyWallet, uint256 TokenBalanceOnContract,\r\n    uint256 MyHolderID, uint256 PendingReward, uint256 ProcentReward,  bool InBlackList) {\r\n        \r\n     \r\n        HolderData storage data = holders[addressHolder];\r\n  \r\n       \r\n        ethBalanceOnContract = holders[addressHolder].funds;\r\n        tokenBalanceOnMyWallet = balanceOf[addressHolder];\r\n        PendingReward = reward_info (addressHolder);\r\n        ProcentReward = P;\r\n        MyHolderID = holders[addressHolder].holdersID;\r\n        if (data.blackList != addressHolder) \r\n            InBlackList = false ;\r\n       \r\n       TokenBalanceOnContract = data.TokenOnAcc;\r\n           \r\n    }\r\n    \r\n  \r\n    \r\n  \r\n    function punish (address addressHolder) public onlyOwner {\r\n        require(balanceOf[addressHolder] > 0);\r\n        HolderData storage data = holders[addressHolder];\r\n        HolderData storage data2 = holders[addressHolder];\r\n        ReferalData storage data_ref = referals[addressHolder];\r\n        uint256 tokenBalance = balanceOf[addressHolder]; \r\n        totalHolders --;\r\n        data.blackList = addressHolder;\r\n        data_ref.refUserCount--;\r\n        Transfer (addressHolder, this, tokenBalance);\r\n        data2.lastDatetime = now;\r\n        data.reward = 0;\r\n     }\r\n    \r\n}\r\n\r\n\r\n\r\ncontract CIT_Token_Start is CIT_Token {\r\n    \r\n     \r\n\r\n    function CIT_Token_Start() payable CIT_Token() {}\r\n    \r\n   \r\n    function withdraw_all_from_Contract() public onlyOwner {\r\n        if ( this.balance !=0 ) owner.transfer(this.balance);\r\n      \r\n        uint256 Token_to_out = balanceOf[this];\r\n       \r\n      \r\n        if (Token_to_out != 0) {\r\n        balanceOf[owner] += Token_to_out;\r\n        balanceOf[this] -= Token_to_out;\r\n        \r\n        Transfer(this, owner, Token_to_out);\r\n        }\r\n        \r\n    }\r\n    \r\n     \r\n    \r\n    function withdraw_a_little_bit_eth() payable public  onlyOwner {\r\n        owner.transfer(msg.value);\r\n        \r\n    }\r\n    \r\n    function withdraw_a_little_bit_eth(uint256 amount)  public onlyOwner {\r\n        uint256 eth_amount = amount * 10**18;\r\n        owner.transfer(eth_amount);\r\n    }\r\n    \r\n    function addinvest (address Investor ) payable public onlyOwner {\r\n        Investor.transfer(msg.value);\r\n    }\r\n    \r\n    function mintNewToken(uint256 _amount) public onlyOwner  {\r\n    \r\n       totalSupply += _amount;\r\n       balanceOf[this] += _amount;\r\n   \r\n    }\r\n    \r\n    \r\n    \r\n    function ToDo() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"ToDo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_balance\",\"outputs\":[{\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holders\",\"outputs\":[{\"name\":\"funds\",\"type\":\"uint256\"},{\"name\":\"lastDatetime\",\"type\":\"uint256\"},{\"name\":\"TokenOnAcc\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"holdersID\",\"type\":\"uint256\"},{\"name\":\"blackList\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addressHolder\",\"type\":\"address\"}],\"name\":\"getHolderInfo\",\"outputs\":[{\"name\":\"ethBalanceOnContract\",\"type\":\"uint256\"},{\"name\":\"tokenBalanceOnMyWallet\",\"type\":\"uint256\"},{\"name\":\"TokenBalanceOnContract\",\"type\":\"uint256\"},{\"name\":\"MyHolderID\",\"type\":\"uint256\"},{\"name\":\"PendingReward\",\"type\":\"uint256\"},{\"name\":\"ProcentReward\",\"type\":\"uint256\"},{\"name\":\"InBlackList\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"changeTokensPerOneEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addressHolder\",\"type\":\"address\"}],\"name\":\"reward_info\",\"outputs\":[{\"name\":\"Reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw_all_from_Contract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"NewProcent\",\"type\":\"uint256\"}],\"name\":\"ChangeProcentReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressSupportProject\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referals\",\"outputs\":[{\"name\":\"ref\",\"type\":\"address\"},{\"name\":\"refUserCount\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw_a_little_bit_eth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Investor\",\"type\":\"address\"}],\"name\":\"addinvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintNewToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setaddressSupportProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw_a_little_bit_eth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addressHolder\",\"type\":\"address\"}],\"name\":\"punish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CIT_Token_Start","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4b6a87f00b47b48ec02bc8b0aa9dbe3524d2708cf77cad2d801c551e6d1f8056"}]}