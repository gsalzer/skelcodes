{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\nabstract contract ERC20Interface {\r\n    function totalSupply() public virtual view returns (uint);\r\n    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public virtual view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public virtual returns (bool success);\r\n    function approve(address spender, uint256 tokens) public virtual returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public virtual returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\r\n*/\r\n \r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n  function ceil(uint a, uint m) internal pure returns (uint r) {\r\n    return (a + m - 1) / m * m;\r\n  }\r\n}\r\n\r\ninterface ISYFP{\r\n   function transferFrom(address from, address to, uint256 tokens) external returns (bool success); \r\n   function transfer(address to, uint256 tokens) external returns (bool success);\r\n   function mint(address to, uint256 _mint_amount) external;\r\n}\r\n\r\ncontract SYFP_STAKE_FARM is Owned{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    uint256 public yieldCollectionFee = 0.05 ether;\r\n    uint256 public stakingPeriod = 2 weeks;\r\n    uint256 public stakeClaimFee = 0.01 ether;\r\n    uint256 public totalYield;\r\n    uint256 public totalRewards;\r\n    \r\n    address public SYFP = 0xC11396e14990ebE98a09F8639a082C03Eb9dB55a;\r\n    \r\n    struct Tokens{\r\n        bool exists;\r\n        uint256 rate;\r\n        uint256 stakedTokens;\r\n    }\r\n    \r\n    mapping(address => Tokens) public tokens;\r\n    address[] TokensAddresses;\r\n    \r\n    struct DepositedToken{\r\n        uint256 activeDeposit;\r\n        uint256 totalDeposits;\r\n        uint256 startTime;\r\n        uint256 pendingGains;\r\n        uint256 lastClaimedDate;\r\n        uint256 totalGained;\r\n        uint    rate;\r\n        uint    period;\r\n    }\r\n    \r\n    mapping(address => mapping(address => DepositedToken)) users;\r\n    \r\n    event TokenAdded(address indexed tokenAddress, uint256 indexed APY);\r\n    event TokenRemoved(address indexed tokenAddress, uint256 indexed APY);\r\n    event FarmingRateChanged(address indexed tokenAddress, uint256 indexed newAPY);\r\n    event YieldCollectionFeeChanged(uint256 indexed yieldCollectionFee);\r\n    event FarmingStarted(address indexed _tokenAddress, uint256 indexed _amount);\r\n    event YieldCollected(address indexed _tokenAddress, uint256 indexed _yield);\r\n    event AddedToExistingFarm(address indexed _tokenAddress, uint256 indexed tokens);\r\n    \r\n    event Staked(address indexed staker, uint256 indexed tokens);\r\n    event AddedToExistingStake(address indexed staker, uint256 indexed tokens);\r\n    event StakingRateChanged(uint256 indexed newAPY);\r\n    event TokensClaimed(address indexed claimer, uint256 indexed stakedTokens);\r\n    event RewardClaimed(address indexed claimer, uint256 indexed reward);\r\n    \r\n    constructor() public {\r\n        owner = 0xf64df26Fb32Ce9142393C31f01BB1689Ff7b29f5;\r\n        // add syfp token to ecosystem\r\n        _addToken(0xC11396e14990ebE98a09F8639a082C03Eb9dB55a, 4000000); //SYFP\r\n        _addToken(0xdAC17F958D2ee523a2206206994597C13D831ec7, 14200); // USDT\r\n        _addToken(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 14200); // USDC\r\n        _addToken(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 5200000); // WETH\r\n        _addToken(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e, 297300000); // YFI\r\n        _addToken(0x45f24BaEef268BB6d63AEe5129015d69702BCDfa, 230000); // YFV\r\n        _addToken(0x96d62cdCD1cc49cb6eE99c867CB8812bea86B9FA, 300000); // yfp\r\n        \r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //####################################################FARMING EXTERNAL FUNCTIONS###########################################################################//\r\n    //#########################################################################################################################################################// \r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Add assets to farm\r\n    // @param _tokenAddress address of the token asset\r\n    // @param _amount amount of tokens to deposit\r\n    // ------------------------------------------------------------------------\r\n    function Farm(address _tokenAddress, uint256 _amount) external{\r\n        require(_tokenAddress != SYFP, \"Use staking instead\"); \r\n        \r\n        // add to farm\r\n        _newDeposit(_tokenAddress, _amount);\r\n        \r\n        // transfer tokens from user to the contract balance\r\n        require(ISYFP(_tokenAddress).transferFrom(msg.sender, address(this), _amount));\r\n        \r\n        emit FarmingStarted(_tokenAddress, _amount);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Add more deposits to already running farm\r\n    // @param _tokenAddress address of the token asset\r\n    // @param _amount amount of tokens to deposit\r\n    // ------------------------------------------------------------------------\r\n    function AddToFarm(address _tokenAddress, uint256 _amount) external{\r\n        require(_tokenAddress != SYFP, \"use staking instead\");\r\n        _addToExisting(_tokenAddress, _amount);\r\n        \r\n        // move the tokens from the caller to the contract address\r\n        require(ISYFP(_tokenAddress).transferFrom(msg.sender,address(this), _amount));\r\n        \r\n        emit AddedToExistingFarm(_tokenAddress, _amount);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Withdraw accumulated yield\r\n    // @param _tokenAddress address of the token asset\r\n    // @required must pay yield claim fee\r\n    // ------------------------------------------------------------------------\r\n    function Yield(address _tokenAddress) public payable {\r\n        require(msg.value >= yieldCollectionFee, \"should pay exact claim fee\");\r\n        require(PendingYield(_tokenAddress, msg.sender) > 0, \"No pending yield\");\r\n        require(tokens[_tokenAddress].exists, \"Token doesn't exist\");\r\n        require(_tokenAddress != SYFP, \"use staking instead\");\r\n    \r\n        uint256 _pendingYield = PendingYield(_tokenAddress, msg.sender);\r\n        \r\n        // Global stats update\r\n        totalYield = totalYield.add(_pendingYield);\r\n        \r\n        // update the record\r\n        users[msg.sender][_tokenAddress].totalGained = users[msg.sender][_tokenAddress].totalGained.add(_pendingYield);\r\n        users[msg.sender][_tokenAddress].lastClaimedDate = now;\r\n        users[msg.sender][_tokenAddress].pendingGains = 0;\r\n        \r\n        // transfer fee to the owner\r\n        owner.transfer(msg.value);\r\n        \r\n        // mint more tokens inside token contract equivalent to _pendingYield\r\n        ISYFP(SYFP).mint(msg.sender, _pendingYield);\r\n        \r\n        emit YieldCollected(_tokenAddress, _pendingYield);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Withdraw any amount of tokens, the contract will update the farming \r\n    // @param _tokenAddress address of the token asset\r\n    // @param _amount amount of tokens to deposit\r\n    // ------------------------------------------------------------------------\r\n    function WithdrawFarmedTokens(address _tokenAddress, uint256 _amount) public {\r\n        require(users[msg.sender][_tokenAddress].activeDeposit >= _amount, \"insufficient amount in farming\");\r\n        require(_tokenAddress != SYFP, \"use withdraw of staking instead\");\r\n        \r\n        // update farming stats\r\n            // check if we have any pending yield, add it to previousYield var\r\n            users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);\r\n            \r\n            tokens[_tokenAddress].stakedTokens = tokens[_tokenAddress].stakedTokens.sub(_amount);\r\n            \r\n            // update amount \r\n            users[msg.sender][_tokenAddress].activeDeposit = users[msg.sender][_tokenAddress].activeDeposit.sub(_amount);\r\n            // update farming start time -- new farming will begin from this time onwards\r\n            users[msg.sender][_tokenAddress].startTime = now;\r\n            // reset last claimed figure as well -- new farming will begin from this time onwards\r\n            users[msg.sender][_tokenAddress].lastClaimedDate = now;\r\n        \r\n        // withdraw the tokens and move from contract to the caller\r\n        require(ISYFP(_tokenAddress).transfer(msg.sender, _amount));\r\n        \r\n        emit TokensClaimed(msg.sender, _amount);\r\n    }\r\n    \r\n    function yieldWithdraw(address _tokenAddress) external {\r\n        Yield(_tokenAddress);\r\n        WithdrawFarmedTokens(_tokenAddress, users[msg.sender][_tokenAddress].activeDeposit);\r\n        \r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //####################################################STAKING EXTERNAL FUNCTIONS###########################################################################//\r\n    //#########################################################################################################################################################//    \r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Start staking\r\n    // @param _tokenAddress address of the token asset\r\n    // @param _amount amount of tokens to deposit\r\n    // ------------------------------------------------------------------------\r\n    function Stake(uint256 _amount) external {\r\n        // add new stake\r\n        _newDeposit(SYFP, _amount);\r\n        \r\n        // transfer tokens from user to the contract balance\r\n        require(ISYFP(SYFP).transferFrom(msg.sender, address(this), _amount));\r\n        \r\n        emit Staked(msg.sender, _amount);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Add more deposits to already running farm\r\n    // @param _tokenAddress address of the token asset\r\n    // @param _amount amount of tokens to deposit\r\n    // ------------------------------------------------------------------------\r\n    function AddToStake(uint256 _amount) external {\r\n        require(now - users[msg.sender][SYFP].startTime < users[msg.sender][SYFP].period, \"current staking expired\");\r\n        _addToExisting(SYFP, _amount);\r\n\r\n        // move the tokens from the caller to the contract address\r\n        require(ISYFP(SYFP).transferFrom(msg.sender,address(this), _amount));\r\n        \r\n        emit AddedToExistingStake(msg.sender, _amount);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Claim reward and staked tokens\r\n    // @required user must be a staker\r\n    // @required must be claimable\r\n    // ------------------------------------------------------------------------\r\n    function ClaimStakedTokens() public {\r\n        require(users[msg.sender][SYFP].activeDeposit > 0, \"no running stake\");\r\n        require(users[msg.sender][SYFP].startTime.add(users[msg.sender][SYFP].period) < now, \"not claimable before staking period\");\r\n        \r\n        uint256 _currentDeposit = users[msg.sender][SYFP].activeDeposit;\r\n        \r\n        // check if we have any pending reward, add it to pendingGains var\r\n        users[msg.sender][SYFP].pendingGains = PendingReward(msg.sender);\r\n        \r\n        tokens[SYFP].stakedTokens = tokens[SYFP].stakedTokens.sub(users[msg.sender][SYFP].activeDeposit);\r\n        \r\n        // update amount \r\n        users[msg.sender][SYFP].activeDeposit = 0;\r\n        \r\n        // transfer staked tokens\r\n        require(ISYFP(SYFP).transfer(msg.sender, _currentDeposit));\r\n        emit TokensClaimed(msg.sender, _currentDeposit);\r\n        \r\n        \r\n    }\r\n    \r\n    function ClaimUnStake() external {\r\n        ClaimReward();\r\n        ClaimStakedTokens();\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Claim reward and staked tokens\r\n    // @required user must be a staker\r\n    // @required must be claimable\r\n    // ------------------------------------------------------------------------\r\n    function ClaimReward() public payable {\r\n        require(msg.value >= stakeClaimFee, \"should pay exact claim fee\");\r\n        require(PendingReward(msg.sender) > 0, \"nothing pending to claim\");\r\n    \r\n        uint256 _pendingReward = PendingReward(msg.sender);\r\n        \r\n        // add claimed reward to global stats\r\n        totalRewards = totalRewards.add(_pendingReward);\r\n        // add the reward to total claimed rewards\r\n        users[msg.sender][SYFP].totalGained = users[msg.sender][SYFP].totalGained.add(_pendingReward);\r\n        // update lastClaim amount\r\n        users[msg.sender][SYFP].lastClaimedDate = now;\r\n        // reset previous rewards\r\n        users[msg.sender][SYFP].pendingGains = 0;\r\n        \r\n        // transfer the claim fee to the owner\r\n        owner.transfer(msg.value);\r\n        \r\n        // mint more tokens inside token contract\r\n        ISYFP(SYFP).mint(msg.sender, _pendingReward);\r\n         \r\n        emit RewardClaimed(msg.sender, _pendingReward);\r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //##########################################################FARMING QUERIES################################################################################//\r\n    //#########################################################################################################################################################//\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the pending yield\r\n    // @param _tokenAddress address of the token asset\r\n    // ------------------------------------------------------------------------\r\n    function PendingYield(address _tokenAddress, address _caller) public view returns(uint256 _pendingRewardWeis){\r\n        uint256 _totalFarmingTime = now.sub(users[_caller][_tokenAddress].lastClaimedDate);\r\n        \r\n        uint256 _reward_token_second = ((tokens[_tokenAddress].rate).mul(10 ** 21)).div(365 days); // added extra 10^21\r\n        \r\n        uint256 yield = ((users[_caller][_tokenAddress].activeDeposit).mul(_totalFarmingTime.mul(_reward_token_second))).div(10 ** 27); // remove extra 10^21 // 10^2 are for 100 (%)\r\n        \r\n        return yield.add(users[_caller][_tokenAddress].pendingGains);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the active farm of the user\r\n    // @param farming asset/ token address\r\n    // ------------------------------------------------------------------------\r\n    function ActiveFarmDeposit(address _tokenAddress, address _user) external view returns(uint256 _activeDeposit){\r\n        return users[_user][_tokenAddress].activeDeposit;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the total farming of the user\r\n    // @param farming asset/ token address\r\n    // ------------------------------------------------------------------------\r\n    function YourTotalFarmingTillToday(address _tokenAddress, address _user) external view returns(uint256 _totalFarming){\r\n        return users[_user][_tokenAddress].totalDeposits;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the time of last farming of user\r\n    // ------------------------------------------------------------------------\r\n    function LastFarmedOn(address _tokenAddress, address _user) external view returns(uint256 _unixLastFarmedTime){\r\n        return users[_user][_tokenAddress].startTime;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get total earned rewards from particular farming\r\n    // @param farming asset/ token address\r\n    // ------------------------------------------------------------------------\r\n    function TotalFarmingRewards(address _tokenAddress, address _user) external view returns(uint256 _totalEarned){\r\n        return users[_user][_tokenAddress].totalGained;\r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //####################################################FARMING ONLY OWNER FUNCTIONS#########################################################################//\r\n    //#########################################################################################################################################################//\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Add supported tokens\r\n    // @param _tokenAddress address of the token asset\r\n    // @param _farmingRate rate applied for farming yield to produce\r\n    // @required only owner or governance contract\r\n    // ------------------------------------------------------------------------    \r\n    function AddToken(address _tokenAddress, uint256 _rate) public onlyOwner {\r\n        _addToken(_tokenAddress, _rate);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Remove tokens if no longer supported\r\n    // @param _tokenAddress address of the token asset\r\n    // @required only owner or governance contract\r\n    // ------------------------------------------------------------------------  \r\n    function RemoveToken(address _tokenAddress) public onlyOwner {\r\n        \r\n        require(tokens[_tokenAddress].exists, \"token doesn't exist\");\r\n        \r\n        tokens[_tokenAddress].exists = false;\r\n        \r\n        emit TokenRemoved(_tokenAddress, tokens[_tokenAddress].rate);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Change farming rate of the supported token\r\n    // @param _tokenAddress address of the token asset\r\n    // @param _newFarmingRate new rate applied for farming yield to produce\r\n    // @required only owner or governance contract\r\n    // ------------------------------------------------------------------------  \r\n    function ChangeFarmingRate(address _tokenAddress, uint256 _newFarmingRate) public onlyOwner{\r\n        \r\n        require(tokens[_tokenAddress].exists, \"token doesn't exist\");\r\n        \r\n        tokens[_tokenAddress].rate = _newFarmingRate;\r\n        \r\n        emit FarmingRateChanged(_tokenAddress, _newFarmingRate);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Change Yield collection fee\r\n    // @param _fee fee to claim the yield\r\n    // @required only owner or governance contract\r\n    // ------------------------------------------------------------------------     \r\n    function SetYieldCollectionFee(uint256 _fee) public onlyOwner{\r\n        yieldCollectionFee = _fee;\r\n        emit YieldCollectionFeeChanged(_fee);\r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //####################################################STAKING QUERIES######################################################################################//\r\n    //#########################################################################################################################################################//\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the pending reward\r\n    // ------------------------------------------------------------------------\r\n    function PendingReward(address _caller) public view returns(uint256 _pendingReward){\r\n        uint256 _totalStakedTime = 0;\r\n        uint256 expiryDate = (users[_caller][SYFP].period).add(users[_caller][SYFP].startTime);\r\n        \r\n        if(now < expiryDate)\r\n            _totalStakedTime = now.sub(users[_caller][SYFP].lastClaimedDate);\r\n        else{\r\n            if(users[_caller][SYFP].lastClaimedDate >= expiryDate) // if claimed after expirydate already\r\n                _totalStakedTime = 0;\r\n            else\r\n                _totalStakedTime = expiryDate.sub(users[_caller][SYFP].lastClaimedDate);\r\n        }\r\n            \r\n        uint256 _reward_token_second = ((users[_caller][SYFP].rate).mul(10 ** 21)); // added extra 10^21\r\n        uint256 reward =  ((users[_caller][SYFP].activeDeposit).mul(_totalStakedTime.mul(_reward_token_second))).div(10 ** 27); // remove extra 10^21 // the two extra 10^2 is for 100 (%) // another two extra 10^4 is for decimals to be allowed\r\n        reward = reward.div(365 days);\r\n        return (reward.add(users[_caller][SYFP].pendingGains));\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the active stake of the user\r\n    // ------------------------------------------------------------------------\r\n    function YourActiveStake(address _user) external view returns(uint256 _activeStake){\r\n        return users[_user][SYFP].activeDeposit;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the total stakes of the user\r\n    // ------------------------------------------------------------------------\r\n    function YourTotalStakesTillToday(address _user) external view returns(uint256 _totalStakes){\r\n        return users[_user][SYFP].totalDeposits;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the time of last stake of user\r\n    // ------------------------------------------------------------------------\r\n    function LastStakedOn(address _user) public view returns(uint256 _unixLastStakedTime){\r\n        return users[_user][SYFP].startTime;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get total earned rewards from stake\r\n    // ------------------------------------------------------------------------\r\n    function TotalStakeRewardsClaimedTillToday(address _user) external view returns(uint256 _totalEarned){\r\n        return users[_user][SYFP].totalGained;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the staking rate\r\n    // ------------------------------------------------------------------------\r\n    function LatestStakingRate() external view returns(uint256 APY){\r\n        return tokens[SYFP].rate;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the staking rate you staked at\r\n    // ------------------------------------------------------------------------\r\n    function YourStakingRate(address _user) external view returns(uint256 _stakingRate){\r\n        return users[_user][SYFP].rate;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the staking period you staked at\r\n    // ------------------------------------------------------------------------\r\n    function YourStakingPeriod(address _user) external view returns(uint256 _stakingPeriod){\r\n        return users[_user][SYFP].period;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the staking time left\r\n    // ------------------------------------------------------------------------\r\n    function StakingTimeLeft(address _user) external view returns(uint256 _secsLeft){\r\n        uint256 left = 0; \r\n        uint256 expiryDate = (users[_user][SYFP].period).add(LastStakedOn(_user));\r\n        \r\n        if(now < expiryDate)\r\n            left = expiryDate.sub(now);\r\n            \r\n        return left;\r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //####################################################STAKING ONLY OWNER FUNCTION##########################################################################//\r\n    //#########################################################################################################################################################//\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Change staking rate\r\n    // @param _newStakingRate new rate applied for staking\r\n    // @required only owner or governance contract\r\n    // ------------------------------------------------------------------------  \r\n    function ChangeStakingRate(uint256 _newStakingRate) public onlyOwner{\r\n        \r\n        tokens[SYFP].rate = _newStakingRate;\r\n        \r\n        emit StakingRateChanged(_newStakingRate);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Change the staking period\r\n    // @param _seconds number of seconds to stake (n days = n*24*60*60)\r\n    // @required only callable by owner or governance contract\r\n    // ------------------------------------------------------------------------\r\n    function SetStakingPeriod(uint256 _seconds) public onlyOwner{\r\n       stakingPeriod = _seconds;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Change the staking claim fee\r\n    // @param _fee claim fee in weis\r\n    // @required only callable by owner or governance contract\r\n    // ------------------------------------------------------------------------\r\n    function SetClaimFee(uint256 _fee) public onlyOwner{\r\n       stakeClaimFee = _fee;\r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //################################################################COMMON UTILITIES#########################################################################//\r\n    //#########################################################################################################################################################//    \r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Internal function to add new deposit\r\n    // ------------------------------------------------------------------------        \r\n    function _newDeposit(address _tokenAddress, uint256 _amount) internal{\r\n        require(users[msg.sender][_tokenAddress].activeDeposit ==  0, \"Already running\");\r\n        require(tokens[_tokenAddress].exists, \"Token doesn't exist\");\r\n        \r\n        // add that token into the contract balance\r\n        // check if we have any pending reward/yield, add it to pendingGains variable\r\n        if(_tokenAddress == SYFP){\r\n            users[msg.sender][_tokenAddress].pendingGains = PendingReward(msg.sender);\r\n            users[msg.sender][_tokenAddress].period = stakingPeriod;\r\n            users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate; // rate for stakers will be fixed at time of staking\r\n        }\r\n        else\r\n            users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);\r\n            \r\n        users[msg.sender][_tokenAddress].activeDeposit = _amount;\r\n        users[msg.sender][_tokenAddress].totalDeposits = users[msg.sender][_tokenAddress].totalDeposits.add(_amount);\r\n        users[msg.sender][_tokenAddress].startTime = now;\r\n        users[msg.sender][_tokenAddress].lastClaimedDate = now;\r\n        tokens[_tokenAddress].stakedTokens = tokens[_tokenAddress].stakedTokens.add(_amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Internal function to add to existing deposit\r\n    // ------------------------------------------------------------------------        \r\n    function _addToExisting(address _tokenAddress, uint256 _amount) internal{\r\n        require(tokens[_tokenAddress].exists, \"Token doesn't exist\");\r\n        // require(users[msg.sender][_tokenAddress].running, \"no running farming/stake\");\r\n        require(users[msg.sender][_tokenAddress].activeDeposit > 0, \"no running farming/stake\");\r\n        // update farming stats\r\n            // check if we have any pending reward/yield, add it to pendingGains variable\r\n            if(_tokenAddress == SYFP){\r\n                users[msg.sender][_tokenAddress].pendingGains = PendingReward(msg.sender);\r\n                users[msg.sender][_tokenAddress].period = stakingPeriod;\r\n                users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate; // rate of only staking will be updated when more is added to stake\r\n            }\r\n            else\r\n                users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);\r\n            // update current deposited amount \r\n            users[msg.sender][_tokenAddress].activeDeposit = users[msg.sender][_tokenAddress].activeDeposit.add(_amount);\r\n            // update total deposits till today\r\n            users[msg.sender][_tokenAddress].totalDeposits = users[msg.sender][_tokenAddress].totalDeposits.add(_amount);\r\n            // update new deposit start time -- new stake/farming will begin from this time onwards\r\n            users[msg.sender][_tokenAddress].startTime = now;\r\n            // reset last claimed figure as well -- new stake/farming will begin from this time onwards\r\n            users[msg.sender][_tokenAddress].lastClaimedDate = now;\r\n            tokens[_tokenAddress].stakedTokens = tokens[_tokenAddress].stakedTokens.add(_amount);\r\n            \r\n            \r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Internal function to add token\r\n    // ------------------------------------------------------------------------     \r\n    function _addToken(address _tokenAddress, uint256 _rate) internal{\r\n        require(!tokens[_tokenAddress].exists, \"token already exists\");\r\n        \r\n        tokens[_tokenAddress] = Tokens({\r\n            exists: true,\r\n            rate: _rate,\r\n            stakedTokens: 0\r\n        });\r\n        \r\n        TokensAddresses.push(_tokenAddress);\r\n        emit TokenAdded(_tokenAddress, _rate);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"AddedToExistingFarm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"AddedToExistingStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAPY\",\"type\":\"uint256\"}],\"name\":\"FarmingRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FarmingStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAPY\",\"type\":\"uint256\"}],\"name\":\"StakingRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_yield\",\"type\":\"uint256\"}],\"name\":\"YieldCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"yieldCollectionFee\",\"type\":\"uint256\"}],\"name\":\"YieldCollectionFeeChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"ActiveFarmDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_activeDeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AddToFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AddToStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"AddToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newFarmingRate\",\"type\":\"uint256\"}],\"name\":\"ChangeFarmingRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newStakingRate\",\"type\":\"uint256\"}],\"name\":\"ChangeStakingRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimReward\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimStakedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimUnStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Farm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"LastFarmedOn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_unixLastFarmedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"LastStakedOn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_unixLastStakedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LatestStakingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"PendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"PendingYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingRewardWeis\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"RemoveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYFP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"SetClaimFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"SetStakingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"SetYieldCollectionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"StakingTimeLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_secsLeft\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"TotalFarmingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"TotalStakeRewardsClaimedTillToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFarmedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"Yield\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"YourActiveStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_activeStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"YourStakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingPeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"YourStakingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"YourTotalFarmingTillToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalFarming\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"YourTotalStakesTillToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStakes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeClaimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldCollectionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"yieldWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SYFP_STAKE_FARM","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4ad45095d35554327d2e694b519670ea6823b1494dc0bf77537498de943843d1"}]}