{"status":"1","message":"OK","result":[{"SourceCode":"// GG-GOV-TITLE: Initial Launch of Giving Governance\r\n/* BEGIN-GG-GOV-DESC  \r\nProposal:\r\n1. Launch Giving Governance Contract\r\n2. Launch First Pool GiveWell\r\n\r\n\r\nDescription:\r\nGiving Governance aims to redirect some of the excess exuberance in the DeFi sphere into effective giving.\r\nBuilding off Andre's amazing yyCRV auto-earning ecosystem, and leveraging Uniswap, the contract channels all returns as ETH to GiveWell's donation address. \r\nThe contract considers the initial yCRV you deposit which is wrapped in yyCRV, and returns you the same number of yCRV in yyCRV. \r\nThe contract has a function whereby anyone can call swapDonatedYYCRVForETH, donating gas, and sends the ETH to the designated address.\r\nWithdrawals get hit with a 0.5% fee, all going to charity - this is purely to stop people from gaming the system.\r\nThe Giving Goverance token GG has no value, and is used purely for voting new charity addresses in, and acting as a focal point for building a altruistic community to share our GaInZ.\r\nGoverannce discussions will occur on forum.giving.finance, and it is envisioned that every new charity added will have its own pool so that users can choose where to donate their earnings.\r\n\r\nGiven the initial quorum of 25%, governance will only start from week 1 onwards. Governance can be queued after getting 50% of quorum, then executed after 1 day.\r\nAll Governance Proposals are contracts, and should follow this template.\r\nGovernance requires 1% of tokens to be proposed. Be careful, once submitted, all your tokens are locked. \r\nIf you vote, all your tokens are locked too. Tokens are released once new governance is executed.\r\n\r\n\r\nexecuteGovernanceActions():\r\nNone\r\n\r\n\r\nEND-GG-GOV-DESC */ \r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract Governance {\r\n    using SafeMath for uint;\r\n\r\n    // Governance Parameters\r\n    \r\n    uint public governanceExpiry      = 7 days;    // Duration for which governance votes can be collected\r\n    uint public governanceSwitchDelay = 1 days;    // Duration before next governance module can be loaded\r\n    uint public voteQuorum            = 25;        // Quorum to approve new governance\r\n    uint public votePass              = 50;        // Percentage required to approve new governance\r\n    uint public minGovToken           = 1;         // Percentage tokens required to create new proposal \r\n    uint public voteDecimal           = 100;       // Divisor for voteQuorum and votePass\r\n    \r\n    // Address Management\r\n    address public previousGovernance;    // Address of previous governance - a linked list leading back to the genesis\r\n    address public GovernanceTokenAddress = 0x3DA1095F0b571f00B4D9A4B2A78AD8D13416886b;    // GovernanceTokenAddress\r\n    \r\n    function executeGovernanceActions() public {                // Function executed by the predecessor Governance Contract when handing over\r\n        require(msg.sender == previousGovernance, \"!PrevGov\");  // Governance actions can be executed here, such as mint GG, revoke GG, etc\r\n    }\r\n\r\n    // Standard Governance Functions and Parameters\r\n\r\n    address public nextGovernance;            // Next governance module\r\n    uint    public nextGovernanceExecution;   // Timestamp before governance module is executed\r\n    address [] public proposedGovernanceList; // List of proposed governance modules\r\n    bool    public GovernanceSwitchExecuted;  // Governance Changed. \r\n    \r\n    // Voting Storage\r\n    mapping (address => mapping (address => uint)) public voteYes;  // Yes votes collected \r\n    mapping (address => mapping (address => uint)) public voteNo;   // No votes collected\r\n\r\n    mapping (address => uint) public voteYesTotal;     // Total Yes votes collected \r\n    mapping (address => uint) public voteNoTotal;      // Total No votes collected\r\n    mapping (address => uint) public dateIntroduced;   // Timestamp when contract is proposed\r\n    mapping (address => bool) public tokenLocked;      // Tokens locked\r\n\r\n    function proposeNewGovernance(address newGovernanceContract) external {\r\n        require(tokenLocked[msg.sender] == false, \"Locked\");\r\n        require(GovernanceToken(GovernanceTokenAddress).balanceOf(msg.sender).mul(voteDecimal).div( GovernanceToken(GovernanceTokenAddress).totalSupply() ) > minGovToken, \"<InsufGovTok\" );\r\n        require(Governance(newGovernanceContract).previousGovernance() == address(this), \"WrongGovAddr\");\r\n        require(dateIntroduced[newGovernanceContract] == 0, \"AlreadyProposed\");\r\n        tokenLocked[msg.sender] = true;\r\n        proposedGovernanceList.push(newGovernanceContract);\r\n        dateIntroduced[newGovernanceContract] = now;\r\n    }\r\n    \r\n    function clearExistingVotesForProposal(address newGovernanceContract) internal {\r\n        voteYesTotal[newGovernanceContract] = voteYesTotal[newGovernanceContract].sub( voteYes[newGovernanceContract][msg.sender] );\r\n        voteNoTotal [newGovernanceContract] = voteNoTotal [newGovernanceContract].sub( voteNo [newGovernanceContract][msg.sender] );\r\n        voteYes[newGovernanceContract][msg.sender] = 0;\r\n        voteNo [newGovernanceContract][msg.sender] = 0;\r\n    }\r\n    \r\n    function voteYesForProposal(address newGovernanceContract) external {\r\n        require(dateIntroduced[newGovernanceContract].add(governanceExpiry) > now , \"ProposalExpired\");\r\n        require( nextGovernance == address(0), \"AlreadyQueued\");\r\n        tokenLocked[msg.sender] = true;\r\n        clearExistingVotesForProposal(newGovernanceContract);\r\n        voteYes[newGovernanceContract][msg.sender] = GovernanceToken(GovernanceTokenAddress).balanceOf(msg.sender);\r\n        voteYesTotal[newGovernanceContract] = voteYesTotal[newGovernanceContract].add( GovernanceToken(GovernanceTokenAddress).balanceOf(msg.sender) );\r\n    }\r\n    \r\n    function voteNoForProposal(address newGovernanceContract) external {\r\n        require(dateIntroduced[newGovernanceContract].add(governanceExpiry) > now , \"ProposalExpired\");\r\n        require( nextGovernance == address(0), \"AlreadyQueued\");\r\n        tokenLocked[msg.sender] = true;\r\n        clearExistingVotesForProposal(newGovernanceContract);\r\n        voteNo[newGovernanceContract][msg.sender] = GovernanceToken(GovernanceTokenAddress).balanceOf(msg.sender);\r\n        voteNoTotal[newGovernanceContract] = voteNoTotal[newGovernanceContract].add( GovernanceToken(GovernanceTokenAddress).balanceOf(msg.sender) );\r\n    }\r\n    \r\n    function queueGovernance(address newGovernanceContract) external {\r\n        require( voteYesTotal[newGovernanceContract].add(voteNoTotal[newGovernanceContract]).mul(voteDecimal).div( GovernanceToken(GovernanceTokenAddress).totalSupply() ) > voteQuorum, \"<Quorum\" );\r\n        require( voteYesTotal[newGovernanceContract].mul(voteDecimal).div( voteYesTotal[newGovernanceContract].add(voteNoTotal[newGovernanceContract]) ) > votePass, \"<Pass\" );\r\n        require( nextGovernance == address(0), \"AlreadyQueued\");\r\n        nextGovernance = newGovernanceContract;\r\n        nextGovernanceExecution = now.add(governanceSwitchDelay);\r\n    }  \r\n    \r\n    function executeGovernance() external {\r\n        require( nextGovernance != address(0) , \"!Queued\");\r\n        require( now > nextGovernanceExecution, \"!NotYet\");\r\n        require( GovernanceSwitchExecuted == false, \"AlrExec\");\r\n        GovernanceToken(GovernanceTokenAddress).setGovernance(nextGovernance);\r\n        Governance(nextGovernance).executeGovernanceActions();\r\n        GovernanceSwitchExecuted = true;\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n      require(b > 0, \"SafeMath: division by zero\");\r\n      return a / b;\r\n  }\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) return 0;\r\n    uint c = a * b;\r\n    require (c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a, \"SafeMath: subtraction underflow\");\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface GovernanceToken {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function mint(address tgtAdd, uint amount) external;\r\n    function revoke(address tgtAdd, uint amount) external;\r\n    function setGovernance(address newGovernanceAddress) external;\r\n}\r\n\r\n// SPDX-License-Identifier: None","ABI":"[{\"inputs\":[],\"name\":\"GovernanceSwitchExecuted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GovernanceTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dateIntroduced\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeGovernanceActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceSwitchDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minGovToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextGovernanceExecution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernanceContract\",\"type\":\"address\"}],\"name\":\"proposeNewGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposedGovernanceList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernanceContract\",\"type\":\"address\"}],\"name\":\"queueGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernanceContract\",\"type\":\"address\"}],\"name\":\"voteNoForProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteNoTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votePass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteYes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernanceContract\",\"type\":\"address\"}],\"name\":\"voteYesForProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteYesTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://20aad625372d2a0016d5a38379290dec1d0f08426c2e7b747a7d23d52d421068"}]}