{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.7;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint a, uint m) internal pure returns (uint) {\r\n    uint c = add(a,m);\r\n    uint d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n\r\n  \r\nabstract contract Uniswap2PairContract {\r\n  \r\n  function getReserves() external virtual returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n \r\n \r\n      \r\n  }\r\n  \r\n    \r\n  \r\n\r\n\r\nabstract contract ERC20Token {\r\n  function totalSupply()  public virtual returns (uint);\r\n  function approve(address spender, uint value)  public virtual returns (bool);\r\n  function balanceOf(address owner) public virtual returns (uint);\r\n  function transferFrom (address from, address to, uint value) public virtual returns (bool);\r\n}\r\n\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event TransferOwnership(address _from, address _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit TransferOwnership(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) external onlyOwner {\r\n        emit TransferOwnership(owner, _owner);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n\r\ncontract CHESSLiquidReward is Ownable{\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    uint ONE_MONTH = 60*60;// 60*60*24*30;\r\n    uint MAX_MONTHS = 24;\r\n    \r\n    \r\n    address public LIQUIDITY_TOKEN  = 0x781ba450EaDf9e493DDfDe81D7d6B6f33528Bc8d;\r\n    address public REWARD_TOKEN  = 0x5f75112bBB4E1aF516fBE3e21528C63DA2B6a1A5;\r\n\r\n    uint[3] public rewardLevels = [3000000000000000000000000,6000000000000000000000000,9000000000000000000000000];\r\n    uint[3] public poolLevels = [100000000000000000000,1000000000000000000000,10000000000000000000000];\r\n    uint[3] public monthLevels = [3,6,12];\r\n    \r\n    uint[4]  public baseRateLookup = [1000,500,250,125];\r\n    \r\n    //poolLevelsIndex   //monthLevelsIndex    //s0(small)[m0,m1,m2..]  //s2 m2   m3    /3=\r\n    uint[4][4]  public multiplierLookup = [[uint(100),uint(120),uint(150),uint(300)],\r\n                                           [uint(100),uint(115),uint(140),uint(280)],\r\n                                           [uint(100),uint(110),uint(130),uint(260)],\r\n                                           [uint(100),uint(105),uint(120),uint(240)]];\r\n   \r\n    \r\n      mapping(address => mapping(uint => LiquidityRewardData)) public liquidityRewardData; //address to timestamp to data\r\n    \r\n    uint public allocatedRewards;\r\n    uint public totalUniswapLiquidity;\r\n    uint public unallocatedRewards;\r\n \r\n    struct LiquidityRewardData {\r\n        uint quantity;\r\n        uint timestamp;\r\n        uint stakeMonths;\r\n        uint reward;\r\n        bool rewardClaimed;\r\n        bool liquidityClaimed;\r\n    }\r\n    \r\n     \r\n    \r\n    fallback()  external payable {\r\n        revert();\r\n    }\r\n    \r\n    \r\n    function setRewardLevels(uint[3] memory input ) public onlyOwner{\r\n       rewardLevels = input;\r\n    }\r\n    function setpoolLevels(uint[3] memory input ) public onlyOwner{\r\n       poolLevels = input;\r\n    }\r\n    function setMonthLevels(uint[3] memory input ) public onlyOwner{\r\n       monthLevels = input;\r\n    }\r\n    function setBaseRateLookup(uint[4] memory input ) public onlyOwner{\r\n       baseRateLookup = input;\r\n    }\r\n    function setMultiplierLookup(uint[4][4] memory input ) public onlyOwner{\r\n       multiplierLookup = input;\r\n    }\r\n    function setMonth(uint input ) public onlyOwner{\r\n       ONE_MONTH = input;\r\n    }\r\n    function setMaxMonths(uint input ) public onlyOwner{\r\n       MAX_MONTHS = input;\r\n    }\r\n     function getMaxMonths() view public returns(uint){\r\n       return MAX_MONTHS;\r\n    }\r\n    \r\n    \r\n    \r\n    function getAllocatedRewards() view public returns(uint){\r\n        return allocatedRewards;\r\n    }\r\n    \r\n    function getUnallocatedRewards() view public returns(uint){\r\n        return unallocatedRewards;\r\n    }\r\n    \r\n    \r\n   \r\n   \r\n        //(this)must be whitelisted on ubomb\r\n     function topupReward (uint amount)  external {\r\n       require(ERC20Token(REWARD_TOKEN).transferFrom(address(msg.sender), address(this), amount),\"tokenXferFail\");\r\n       //calc actual deposit amount due to BOMB burn\r\n       uint tokensToBurn = amount.div(1000);\r\n       uint actual = amount.sub(tokensToBurn);\r\n       \r\n       unallocatedRewards += actual;\r\n     } \r\n     \r\n     function removeReward ()  external onlyOwner {\r\n       require(ERC20Token(REWARD_TOKEN).transferFrom(address(this), address(msg.sender), unallocatedRewards),\"tokenXferFail\");\r\n       unallocatedRewards = 0;\r\n     } \r\n    \r\n    \r\n  \r\n    \r\n    function calcReward(uint stakeMonths, uint stakeTokens)  public returns (uint){\r\n        \r\n        (uint tokens, uint eth, uint time) = Uniswap2PairContract(LIQUIDITY_TOKEN).getReserves();\r\n        \r\n        uint liquidity = stakeTokens;\r\n\r\n        uint liquidityTotalSupply = ERC20Token(LIQUIDITY_TOKEN).totalSupply();\r\n        \r\n        //uint amountEth = liquidity.mul(eth) / liquidityTotalSupply; // using balances ensures pro-rata distribution\r\n        uint amountTokens = (liquidity.mul(tokens)).div(liquidityTotalSupply); // using balances ensures pro-rata distribution\r\n       \r\n        uint months = stakeMonths;\r\n        uint baseRate = baseRateLookup[getRewardIndex()];\r\n        uint multiplier =  multiplierLookup[getpoolLevelsIndex(eth)][getMonthsIndex(months)];\r\n        \r\n        uint reward = (amountTokens.mul(months).mul(baseRate).mul(multiplier)).div(1000000);\r\n        \r\n        return(reward);\r\n    }\r\n    \r\n   \r\n    \r\n    function getRewardIndex() public view returns (uint) {\r\n        if(unallocatedRewards < rewardLevels[0]){return 3;}\r\n        else if(unallocatedRewards < rewardLevels[1]){return 2;}\r\n        else if(unallocatedRewards < rewardLevels[2]){return 1;}\r\n        else {return 0;}\r\n    }\r\n    \r\n    //baserate\r\n    function getpoolLevelsIndex(uint eth) public view returns (uint) {\r\n     \r\n        if(eth < poolLevels[0] ){return 0;}\r\n        else if(eth <poolLevels[1]){return 1;}\r\n        else if(eth <poolLevels[2]){return 2;}\r\n        else {return 3;}\r\n    }\r\n    \r\n     function getMonthsIndex(uint month) public view returns (uint) {\r\n        \r\n        if(month < monthLevels[0]){return 0;}\r\n        else if(month < monthLevels[1]){return 1;}\r\n        else if(month < monthLevels[2]){return 2;}\r\n        else {return 3;}\r\n        \r\n    }\r\n    \r\n    \r\n    function lockLiquidity(uint idx, uint stakeMonths, uint stakeTokens) external {\r\n    \r\n        //temp hold tokens and ether from sender\r\n        require(stakeMonths <= MAX_MONTHS,\"tooManyMonths\");\r\n        require(ERC20Token(LIQUIDITY_TOKEN).transferFrom(address(msg.sender), address(this), stakeTokens),\"tokenXferFail\");\r\n        \r\n        require( (liquidityRewardData[msg.sender][idx].quantity == 0),\"previousLiquidityInSlot\");\r\n       \r\n        uint reward = calcReward(stakeMonths,stakeTokens);\r\n        \r\n        require( unallocatedRewards >= reward, \"notEnoughRewardRemaining\");\r\n        \r\n        allocatedRewards += reward;\r\n        unallocatedRewards -= reward;\r\n        totalUniswapLiquidity += stakeTokens;\r\n        \r\n        liquidityRewardData[msg.sender][idx] = LiquidityRewardData(stakeTokens, block.timestamp, stakeMonths, reward,false,false);\r\n     \r\n    }\r\n    \r\n    \r\n    \r\n    function rewardTask(uint idx, uint renewMonths) public {\r\n        \r\n        require(liquidityRewardData[msg.sender][idx].rewardClaimed == false,\"RewardClaimedAlready\");\r\n        liquidityRewardData[msg.sender][idx].rewardClaimed = true;\r\n        \r\n        uint reward = liquidityRewardData[msg.sender][idx].reward;\r\n        allocatedRewards -= reward;\r\n            \r\n        if( liquidityRewardData[msg.sender][idx].timestamp.add( liquidityRewardData[msg.sender][idx].stakeMonths.mul(ONE_MONTH)) <= block.timestamp){\r\n            \r\n            if(renewMonths > 0 && liquidityRewardData[msg.sender][idx].liquidityClaimed==false){ //claim and renew\r\n                \r\n                uint newReward = calcReward(renewMonths,liquidityRewardData[msg.sender][idx].quantity);\r\n                require(newReward < unallocatedRewards,\"NotEnoughRewardsRemaining\");\r\n                allocatedRewards += newReward;\r\n                unallocatedRewards -= newReward;\r\n                liquidityRewardData[msg.sender][idx].timestamp = block.timestamp;\r\n                liquidityRewardData[msg.sender][idx].stakeMonths = renewMonths;\r\n                liquidityRewardData[msg.sender][idx].reward = newReward;\r\n                liquidityRewardData[msg.sender][idx].rewardClaimed = false;\r\n            \r\n            }\r\n            ERC20Token(REWARD_TOKEN).approve(address(this),reward);\r\n            ERC20Token(REWARD_TOKEN).transferFrom(address(this), address(msg.sender), reward);\r\n        }\r\n        else{\r\n            unallocatedRewards += reward;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    function unlockLiquidity(uint idx) external { //get liquidity tokens\r\n    \r\n        require(liquidityRewardData[msg.sender][idx].liquidityClaimed == false,\"LiquidityAlreadyClaimed\");\r\n        \r\n        if(liquidityRewardData[msg.sender][idx].rewardClaimed == false){\r\n            rewardTask(idx,0);\r\n        }\r\n        totalUniswapLiquidity -= liquidityRewardData[msg.sender][idx].quantity;\r\n        ERC20Token(LIQUIDITY_TOKEN).approve(address(this),liquidityRewardData[msg.sender][idx].quantity);\r\n        ERC20Token(LIQUIDITY_TOKEN).transferFrom(address(this),address(msg.sender),liquidityRewardData[msg.sender][idx].quantity);\r\n        liquidityRewardData[msg.sender][idx].quantity = 0;\r\n        liquidityRewardData[msg.sender][idx].liquidityClaimed = true;\r\n        \r\n    }\r\n  \r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"LIQUIDITY_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"baseRateLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeMonths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTokens\",\"type\":\"uint256\"}],\"name\":\"calcReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllocatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxMonths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"}],\"name\":\"getMonthsIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnallocatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"getpoolLevelsIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityRewardData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeMonths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"rewardClaimed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"liquidityClaimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeMonths\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTokens\",\"type\":\"uint256\"}],\"name\":\"lockLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"monthLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"multiplierLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renewMonths\",\"type\":\"uint256\"}],\"name\":\"rewardTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"input\",\"type\":\"uint256[4]\"}],\"name\":\"setBaseRateLookup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"setMaxMonths\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"setMonth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"input\",\"type\":\"uint256[3]\"}],\"name\":\"setMonthLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4][4]\",\"name\":\"input\",\"type\":\"uint256[4][4]\"}],\"name\":\"setMultiplierLookup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"input\",\"type\":\"uint256[3]\"}],\"name\":\"setRewardLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"input\",\"type\":\"uint256[3]\"}],\"name\":\"setpoolLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"topupReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUniswapLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unallocatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"unlockLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CHESSLiquidReward","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://47581d3f48c6d1c6b5436715aa08479f4b537e71e1af49cbfb486bde3a404182"}]}