{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n/*\n * @title  Pool\n * @notice Abstract pool to facilitate tracking of shares in a pool\n */\ncontract Pool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 private _totalShares;\n    mapping(address => uint256) private _shares;\n\n    /**\n     * @dev Pool constructor\n     */\n    constructor() internal {\n    }\n\n    /*** VIEW ***/\n\n    /**\n     * @dev Get the total number of shares in pool\n     * @return uint256 total shares\n     */\n    function totalShares()\n        public\n        view\n        returns (uint256)\n    {\n        return _totalShares;\n    }\n\n    /**\n     * @dev Get the share of a given account\n     * @param _account User for which to retrieve balance\n     * @return uint256 shares\n     */\n    function sharesOf(address _account)\n        public\n        view\n        returns (uint256)\n    {\n        return _shares[_account];\n    }\n\n    /*** INTERNAL ***/\n\n    /**\n     * @dev Add a given amount of shares to a given account\n     * @param _account Account to increase shares for\n     * @param _amount Units of shares\n     */\n    function _increaseShares(address _account, uint256 _amount)\n        internal\n    {\n        _totalShares = _totalShares.add(_amount);\n        _shares[_account] = _shares[_account].add(_amount);\n    }\n\n    /**\n     * @dev Remove a given amount of shares from a given account\n     * @param _account Account to decrease shares for\n     * @param _amount Units of shares\n     */\n    function _decreaseShares(address _account, uint256 _amount)\n        internal\n    {\n        _totalShares = _totalShares.sub(_amount);\n        _shares[_account] = _shares[_account].sub(_amount);\n    }\n}\n\ncontract Context {\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract RewardDistributionRecipient is Ownable {\n    address public rewardDistributor;\n\n    constructor (address _rewardDistributor) internal {\n        rewardDistributor = _rewardDistributor;\n    }\n\n    function notifyRewardAmount(uint256 _reward) external;\n\n    modifier onlyRewardDistributor() {\n        require(_msgSender() == rewardDistributor, \"Caller is not reward distributor\");\n        _;\n    }\n\n    function setRewardDistributor(address _rewardDistributor)\n        external\n        onlyOwner\n    {\n        rewardDistributor = _rewardDistributor;\n    }\n}\n\n/**\n * @title  RewardPool\n * @author Originally: Synthetix (forked from /Synthetixio/synthetix/contracts/StakingRewards.sol)\n *         Audit: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf\n * @notice Rewards share holders with RewardToken, on a pro-rata basis\n */\ncontract RewardPool is Pool, RewardDistributionRecipient {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public rewardToken;\n\n    uint256 public DURATION;\n    uint256 public periodFinish = 0;\n    uint256 public rewardPerSecond = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerShareStored;\n    mapping(address => uint256) public userRewardPerSharePaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 amount);\n    event RewardPaid(address indexed user, uint256 amount);\n\n    /**\n     * @dev RewardPool constructor\n     * @param _DURATION The duration of each reward period\n     * @param _rewardToken The rewardToken\n     */\n    constructor (\n        uint256 _DURATION,\n        address _rewardToken\n    )\n        RewardDistributionRecipient(msg.sender)\n        internal\n    {\n        DURATION = _DURATION;\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /** @dev Updates the reward for a given address, before executing function */\n    modifier updateReward(address _account) {\n        // Setting of global vars\n        uint256 newRewardPerShare = rewardPerShare();\n        // If statement protects against loss in initialisation case\n        if(newRewardPerShare > 0) {\n            rewardPerShareStored = newRewardPerShare;\n            lastUpdateTime = lastTimeRewardApplicable();\n            // Setting of personal vars based on new globals\n            if (_account != address(0)) {\n                rewards[_account] = earned(_account);\n                userRewardPerSharePaid[_account] = newRewardPerShare;\n            }\n        }\n        _;\n    }\n\n    /*** PUBLIC FUNCTIONS ***/\n\n    /**\n     * @dev Claim outstanding rewards for sender\n     * @return uint256 amount claimed\n     */\n    function claim()\n        public\n        updateReward(msg.sender)\n    {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.transfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /*** VIEW ***/\n\n    /**\n     * @dev Get current block timestamp. For easy mocking in test\n     */\n    function getCurrentTimestamp()\n        public\n        view\n        returns (uint256)\n    {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Gets the last applicable timestamp for this reward period\n     */\n    function lastTimeRewardApplicable()\n        public\n        view\n        returns (uint256)\n    {\n        return Math.min(getCurrentTimestamp(), periodFinish);\n    }\n\n    /**\n     * @dev Calculate rewardsPerShare\n     * @return uint256 rewardsPerShare\n     */\n    function rewardPerShare()\n        public\n        view\n        returns (uint256)\n    {\n        if (totalShares() == 0) {\n            return rewardPerShareStored;\n        }\n        return rewardPerShareStored.add(\n          lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardPerSecond)\n          .mul(1e18)\n          .div(totalShares())\n          );\n    }\n\n    /**\n     * @dev Calculates the amount of rewards earned for a given account\n     * @param _account User for which calculate earned rewards for\n     * @return uint256 Earned rewards\n     */\n    function earned(address _account)\n        public\n        view\n        returns (uint256)\n    {\n        return sharesOf(_account)\n               .mul(rewardPerShare().sub(userRewardPerSharePaid[_account]))\n               .div(1e18)\n               .add(rewards[_account]);\n    }\n\n    /*** ADMIN ***/\n\n    /**\n     * @dev Notifies the contract that new rewards have been added.\n     * Calculates an updated rewardPerSecond based on the rewards in period.\n     * @param _reward Units of RewardToken that have been added to the pool\n     */\n    function notifyRewardAmount(uint256 _reward)\n        external\n        onlyRewardDistributor\n        updateReward(address(0))\n    {\n        uint256 currentTime = getCurrentTimestamp();\n        // If previous period over, reset rewardPerSecond\n        if (currentTime >= periodFinish) {\n            rewardPerSecond = _reward.div(DURATION);\n        }\n        // If additional reward to existing period, calc sum\n        else {\n            uint256 remaining = periodFinish.sub(currentTime);\n            uint256 leftover = remaining.mul(rewardPerSecond);\n            rewardPerSecond = _reward.add(leftover).div(DURATION);\n        }\n\n        lastUpdateTime = currentTime;\n        periodFinish = currentTime.add(DURATION);\n\n        emit RewardAdded(_reward);\n    }\n\n    /*** INTERNAL ***/\n\n    /**\n     * @dev Add a given amount of shares to a given account\n     * @param _account Account to increase shares for\n     * @param _amount Units of shares\n     */\n    function _mintShares(address _account, uint256 _amount)\n        internal\n        updateReward(_account)\n    {\n        require(_amount > 0, \"REWARD_POOL: cannot mint 0 shares\");\n        _increaseShares(_account, _amount);\n    }\n\n    /**\n     * @dev Remove a given amount of shares from a given account\n     * @param _account Account to decrease shares for\n     * @param _amount Units of shares\n     */\n    function _burnShares(address _account, uint256 _amount)\n        internal\n        updateReward(_account)\n    {\n        require(_amount > 0, \"REWARD_POOL: cannot burn 0 shares\");\n        _decreaseShares(_account, _amount);\n    }\n}\n\n/*\n * @title  ManagedRewardPool\n * @notice RewardPool with shares controlled by manager\n */\ncontract ManagedRewardPool is RewardPool {\n\n    mapping(address => bool) public managers;\n\n    event Promoted(address indexed manager);\n    event Demoted(address indexed manager);\n\n    constructor(\n        uint256 _DURATION,\n        address _rewardToken\n    )\n        RewardPool (\n            _DURATION,\n            _rewardToken\n        )\n        public\n    {\n    }\n\n    modifier onlyManager() {\n        require(isManager(msg.sender), \"MANAGED_REWARD_POOL: caller is not a manager\");\n        _;\n    }\n\n    /*** PUBLIC ***/\n\n    function mintShares(address _account, uint256 _amount)\n        external\n        onlyManager\n    {\n        _mintShares(_account, _amount);\n    }\n\n    function burnShares(address _account, uint256 _amount)\n        external\n        onlyManager\n    {\n        _burnShares(_account, _amount);\n    }\n\n    function isManager(address _account)\n        public\n        view\n        returns (bool)\n    {\n        return managers[_account];\n    }\n\n    /*** ADMIN ***/\n\n    function promote(address _address)\n        external\n        onlyOwner\n    {\n        managers[_address] = true;\n\n        emit Promoted(_address);\n    }\n\n    function demote(address _address)\n        external\n        onlyOwner\n    {\n        managers[_address] = false;\n\n        emit Demoted(_address);\n    }\n}\n\n/**\n * @title nUSDMintRewardPool\n * @dev Reward pool to issue BRET for minting nUSD\n */\ncontract nUSDMintRewardPool is ManagedRewardPool {\n    constructor (address _bretToken)\n        ManagedRewardPool (\n            604800, // 7 days\n            _bretToken\n        )\n        public\n    {\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bretToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"Demoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"Promoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"demote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"promote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerShareStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardDistributor\",\"type\":\"address\"}],\"name\":\"setRewardDistributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerSharePaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"nUSDMintRewardPool","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"50000","ConstructorArguments":"000000000000000000000000096dc18e816f3a39c84c42fe092658ebe57066d5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}