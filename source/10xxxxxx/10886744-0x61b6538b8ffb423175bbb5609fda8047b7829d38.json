{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12; // optimization runs: 200, evm version: istanbul\r\n\r\n\r\ninterface IDharmaUNIDelegator {\r\n    function getDefaultDelegationPayload() external pure returns (bytes32);\r\n    function validateDefaultPayload(address delegator, bytes calldata signature) external view returns (bool valid);\r\n    function delegateToDharmaViaDefault(bytes calldata signature) external returns (bool ok);\r\n    \r\n    function getCustomDelegationPayload(address delegator, uint256 expiry) external view returns (bytes32);\r\n    function validateCustomPayload(address delegator, uint256 expiry, bytes calldata signature) external view returns (bool valid);\r\n    function delegateToDharmaViaCustom(address delegator, uint256 expiry, bytes calldata signature) external returns (bool ok);\r\n}\r\n\r\n\r\ninterface IUNI {\r\n    function nonces(address account) external view returns (uint256);\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n\r\n/// @title DharmaUNIDelegator\r\n/// @author 0age\r\n/// @notice This contract facilitates UNI delegation to Dharma via meta-transaction,\r\n/// using the `delegateBySig` pattern first established by Compound on their COMP\r\n/// token. Two methods are available — a \"default\" method, which assumes that the\r\n/// delegator is making their first meta-transaction on UNI and does not desire the\r\n/// deletation meta-transaction to expire, and a \"custom\" method that utilizes the\r\n/// current nonce for the delegator in question and allows for specification of any\r\n/// expiration. First, call `getDefaultDelegationPayload` to retrieve the payload\r\n/// that needs to be signed. Next, the delegator signs the payload via `eth_sign`.\r\n/// Finally, validate the signature via `validateDefaultPayload` and relay the\r\n/// delegation via `delegateToDharmaViaDefault`. (The same sequence applies for\r\n/// custom delegation, using the corresponding custom methods.) Finally, note that\r\n/// delegation can be modified at any point, but that any proposals that are made\r\n/// will \"lock in\" delegation as of the proposal time in the context of the vote\r\n/// in question.\r\ncontract DharmaUNIDelegator is IDharmaUNIDelegator {\r\n    /// @notice The EIP-712 typehash for UNI's domain\r\n    bytes32 internal constant DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    /// @notice UNI's EIP-712 domain separator, computed from parameters in typehash\r\n    bytes32 internal constant DOMAIN_SEPARATOR = bytes32(\r\n        0x28e9a6a663fbec82798f959fbf7b0805000a2aa21154d62a24be5f2a8716bf81\r\n    );\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by UNI\r\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\r\n        \"Delegation(address delegatee,uint256 nonce,uint256 expiry)\"\r\n    );\r\n\r\n    /// @notice The EIP-712 typehash for the initial delegation struct to Dharma\r\n    bytes32 internal constant STRUCT_HASH_FOR_ZERO_NONCE_AND_DISTANT_EXPIRY = bytes32(\r\n        0x8e3dad336fbf63723cdd6a970ccff74331f69d237e030433c4fb2d299d44fdd6\r\n    );\r\n    \r\n    /// @notice The EIP-712 payload to sign for delegation to Dharma with default parameters\r\n    bytes32 internal constant DEFAULT_DELEGATION_PAYLOAD = bytes32(\r\n        0x96b14b7fefb98540ed60068884902ad2b61901691cd14a23fdd0e24bc7515f24\r\n    );\r\n\r\n    /// @notice The address and relevant interface of UNI\r\n    IUNI public constant UNI = IUNI(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);\r\n    \r\n    /// @notice The Dharma Delegatee address\r\n    address public constant DHARMA_DELEGATEE = address(\r\n        0x7e4A8391C728fEd9069B2962699AB416628B19Fa\r\n    );\r\n    \r\n    /// @notice The default nonce (zero)\r\n    uint256 internal constant ZERO_NONCE = uint256(0);\r\n    \r\n    /// @notice The default expiration (a long, long time from now)\r\n    uint256 internal constant DISTANT_EXPIRY = uint256(999999999999999999);\r\n    \r\n    /// @notice Validate the computation of defined constants during deployment\r\n    constructor() public {\r\n        require(\r\n            DOMAIN_SEPARATOR == keccak256(\r\n                abi.encode(\r\n                    DOMAIN_TYPEHASH, keccak256(bytes(\"Uniswap\")), uint256(1), address(UNI)\r\n                )\r\n            ),\r\n            \"Domain Separator does not match computed domain separator.\"\r\n        );\r\n        \r\n        require(\r\n            STRUCT_HASH_FOR_ZERO_NONCE_AND_DISTANT_EXPIRY == keccak256(\r\n                abi.encode(\r\n                    DELEGATION_TYPEHASH, DHARMA_DELEGATEE, ZERO_NONCE, DISTANT_EXPIRY\r\n                )\r\n            ),\r\n            \"Default struct hash does not match computed default struct hash.\"\r\n        );\r\n        \r\n        require(\r\n            DEFAULT_DELEGATION_PAYLOAD == keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\", DOMAIN_SEPARATOR, STRUCT_HASH_FOR_ZERO_NONCE_AND_DISTANT_EXPIRY\r\n                )\r\n            ),\r\n            \"Default initial delegation payload does not match computed default payload.\"\r\n        );\r\n    }\r\n    \r\n    /// @notice Get default payload to sign for delegating to Dharma — note that it must be the\r\n    /// first UNI meta-transaction from the delegator.\r\n    function getDefaultDelegationPayload() external pure override returns (bytes32) {\r\n        return DEFAULT_DELEGATION_PAYLOAD;\r\n    }\r\n\r\n    /// @notice Confirm that a given signature for default delegation resolves to a specific delegator\r\n    /// and is currently valid.\r\n    function validateDefaultPayload(\r\n        address delegator, bytes calldata signature\r\n    ) external view override returns (bool valid) {\r\n        uint256 delegatorNonce = UNI.nonces(delegator);\r\n        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\r\n        valid = (delegatorNonce == 0 && ecrecover(DEFAULT_DELEGATION_PAYLOAD, v, r, s) == delegator);\r\n    }\r\n\r\n    /// @notice Provide a valid signature to delegate to Dharma — delegation can be reassigned to\r\n    /// another account at any time, but any votes that have already occurred will persist.\r\n    function delegateToDharmaViaDefault(bytes calldata signature) external override returns (bool ok) {\r\n        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\r\n        UNI.delegateBySig(DHARMA_DELEGATEE, ZERO_NONCE, DISTANT_EXPIRY, v, r, s);\r\n        ok = true;\r\n    }\r\n    \r\n    /// @notice Get a custom payload to sign for delegating to Dharma — this supports non-zero nonces,\r\n    /// and any expiration can be specified.\r\n    function getCustomDelegationPayload(\r\n        address delegator, uint256 expiry\r\n    ) public view override returns (bytes32) {\r\n        uint256 nonce = UNI.nonces(delegator);\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                DELEGATION_TYPEHASH, DHARMA_DELEGATEE, nonce, expiry\r\n            )\r\n        );\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash));\r\n    }\r\n\r\n    /// @notice Confirm that a given signature for custom delegation resolves to a specific delegator\r\n    /// and is currently valid.\r\n    function validateCustomPayload(\r\n        address delegator, uint256 expiry, bytes calldata signature\r\n    ) external view override returns (bool valid) {\r\n        bytes32 customPayload = getCustomDelegationPayload(delegator, expiry);\r\n        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\r\n        valid = (block.timestamp <= expiry && ecrecover(customPayload, v, r, s) == delegator);\r\n    }\r\n\r\n    /// @notice Provide a valid signature and custom arguments to delegate to Dharma — delegation\r\n    /// can be reassigned to another account at any time, but any votes that have already occurred\r\n    /// will persist.\r\n    function delegateToDharmaViaCustom(\r\n        address delegator, uint256 expiry, bytes calldata signature\r\n    ) external override returns (bool ok) {\r\n        uint256 delegatorNonce = UNI.nonces(delegator);\r\n        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\r\n        UNI.delegateBySig(DHARMA_DELEGATEE, delegatorNonce, expiry, v, r, s);\r\n        ok = true;\r\n    }\r\n    \r\n    /// @notice Internal function to deconstruct an aggregated signature into r, s, and v values.\r\n    function _unpackSignature(\r\n        bytes memory signature\r\n    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\r\n        require(signature.length == 65, \"Signature length is incorrect.\");\r\n\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DHARMA_DELEGATEE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNI\",\"outputs\":[{\"internalType\":\"contract IUNI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"delegateToDharmaViaCustom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"delegateToDharmaViaDefault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"getCustomDelegationPayload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultDelegationPayload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"validateCustomPayload\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"validateDefaultPayload\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DharmaUNIDelegator","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://79ac5f0a28f16c7175b23a244ddf8f4f0649baea9106988ad2194db9f42a897f"}]}