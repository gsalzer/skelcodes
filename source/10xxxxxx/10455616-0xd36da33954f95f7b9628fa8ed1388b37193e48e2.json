{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath8 {\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n    uint8 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n    }\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a / b;\r\n        return c;\r\n    }\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        uint8 c = a- b;\r\n        return c;\r\n    }\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract gameContract {\r\n    function game(uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) public pure returns(uint winAmount, uint256[10] result);\r\n    function getMaxWin(uint betMask, uint8 modulo, uint betAmount) public pure returns(uint maxWin);\r\n}\r\n\r\ncontract Baccarat is gameContract {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath8 for uint8;\r\n\r\n    function getMaxWin(uint betMask, uint8 modulo, uint betAmount) public pure returns(uint maxWin) {\r\n        if(betMask == 1) {\r\n            maxWin = betAmount.add(2);\r\n        } else if(betMask == 2) {\r\n            maxWin = betAmount.div(100).mul(195);\r\n        } else if(betMask == 4) {\r\n            maxWin = betAmount.mul(8);\r\n        }\r\n    }\r\n\r\n    function game(uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) public pure returns (uint winAmount, uint256[10] result) {\r\n        uint8 outcome;\r\n        uint8[3] memory player_hand;\r\n        uint8[3] memory banker_hand;\r\n        uint8 player_point;\r\n        uint8 banker_point;\r\n        uint8[52] memory resultdeck;\r\n        resultdeck = shuffleDeck(initDeck(), uint(entropy));\r\n        (outcome, player_hand, banker_hand, player_point, banker_point) = baccarat(resultdeck);\r\n\r\n        if(outcome == 1 && betMask == 1) {\r\n            winAmount = betAmount.mul(2);\r\n        } else if(outcome == 2 && betMask == 2) {\r\n            winAmount = betAmount.div(100).mul(195);\r\n\r\n        } else if(outcome == 4) {\r\n            if (betMask == 4){\r\n                winAmount = betAmount.mul(8);\r\n            } else {\r\n                winAmount = betAmount;\r\n            }\r\n\r\n        }\r\n\r\n        result[0] = outcome;\r\n        result[1] = player_hand[0];\r\n        result[2] = banker_hand[0];\r\n        result[3] = player_hand[1];\r\n        result[4] = banker_hand[1];\r\n        result[5] = player_hand[2];\r\n        result[6] = banker_hand[2];\r\n        result[7] = player_point;\r\n        result[8] = banker_point;\r\n    }\r\n\r\n    function baccarat(uint8[52] memory deck) public pure returns (uint8 outcome, uint8[3] player_hand, uint8[3] banker_hand, uint8 player_point, uint8 banker_point){\r\n        uint8[14][10] memory hit_stand_array;\r\n        hit_stand_array = [\r\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1],\r\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1],\r\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1],\r\n            [1,1,1,1,1,1,1,1,0,1,1,1,1,1],\r\n            [1,0,1,1,1,1,1,1,0,0,0,0,0,0],\r\n            [1,0,0,0,1,1,1,1,0,0,0,0,0,0],\r\n            [0,0,0,0,0,0,1,1,0,0,0,0,0,0],\r\n            [0,0,0,0,0,0,0,0,0,0,0,0,0,0],\r\n            [0,0,0,0,0,0,0,0,0,0,0,0,0,0],\r\n            [0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\r\n        ;\r\n\r\n        uint8 _player_point = 0;\r\n        uint8 _banker_point = 0;\r\n\r\n        player_hand[0] = deck[0];\r\n        banker_hand[0] = deck[1];\r\n        player_hand[1] = deck[2];\r\n        banker_hand[1] = deck[3];\r\n        uint8 next_index = 4;   //next draw\r\n\r\n        _player_point = getPoint(player_hand[0]).add(getPoint(player_hand[1])).mod(10);\r\n        _banker_point = getPoint(banker_hand[0]).add(getPoint(banker_hand[1])).mod(10);\r\n\r\n        outcome = 0;//0 processing, 1 player win, 2 banker win, 4 tie\r\n\r\n        if(_player_point > 7 || _banker_point > 7 || (_player_point > 5 && _banker_point > 5)) {\r\n            outcome = getOutcome(_player_point, _banker_point);\r\n        }\r\n\r\n        if(outcome == 0) {\r\n            if (_player_point < 6) {\r\n                player_hand[2] = deck[next_index];\r\n                _player_point = _player_point.add(getPoint(player_hand[2])).mod(10);\r\n                next_index ++ ;\r\n            }\r\n\r\n            uint8 player_third_rank = player_hand[2].mod(13);\r\n            if(hit_stand_array[_banker_point][player_third_rank] == 1) {\r\n                banker_hand[2] = deck[next_index];\r\n                _banker_point = _banker_point.add(getPoint(banker_hand[2])).mod(10);\r\n            }\r\n\r\n            outcome = getOutcome(_player_point, _banker_point);\r\n        }\r\n\r\n        return (outcome, player_hand, banker_hand, _player_point, _banker_point);\r\n    }\r\n\r\n    function getOutcome(uint8 player_point, uint8 banker_point) public pure returns (uint8 outcome){\r\n        if(player_point > banker_point) {\r\n            outcome = 1;\r\n        } else if (player_point < banker_point) {\r\n            outcome = 2;\r\n        } else {\r\n            outcome = 4;\r\n        }\r\n    }\r\n\r\n    function getPoint(uint8 hand) public pure returns (uint8 point) {\r\n        if (hand == 0) {\r\n            return 0;//No hand\r\n        }\r\n        uint8 rank = hand.sub(1).mod(13);  //get card rank(0-12 as 1-10,J,Q,K)\r\n        if (rank  > 8 ) {\r\n            point = 0;  //10,J,Q,K are 0 point\r\n        } else {\r\n            point = rank.add(1);//1-9 has point of its rank\r\n        }\r\n        return point;\r\n    }\r\n\r\n    function initDeck() public pure returns(uint8[52] memory deck) {\r\n        for (uint8 i = 0 ; i < 52 ; i ++) {\r\n            deck[i] = i.add(1);\r\n        }\r\n    }\r\n\r\n    function shuffleDeck(uint8[52] memory deck, uint256 _seed) public pure returns (uint8[52] shuffled){\r\n        uint8 CARD_NUM = 52;\r\n        for (uint8 i = 0; i < 6; i++ ) {\r\n            _seed = uint256(keccak256(abi.encodePacked(_seed)));\r\n            uint8 modulo = CARD_NUM.sub(i) ;\r\n            uint256 rnd = _seed.mod(modulo); //This is not uniform random number.\r\n            uint8 tmp = deck[i];\r\n            deck[i] = deck[rnd];\r\n            deck[rnd] = tmp;\r\n        }\r\n        //return Deck(deck.body, 0);\r\n        shuffled = deck;\r\n    }\r\n\r\n\r\n    event GameEnd(string result);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"hand\",\"type\":\"uint8\"}],\"name\":\"getPoint\",\"outputs\":[{\"name\":\"point\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxWin\",\"outputs\":[{\"name\":\"maxWin\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initDeck\",\"outputs\":[{\"name\":\"deck\",\"type\":\"uint8[52]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"entropy\",\"type\":\"bytes32\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"game\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"deck\",\"type\":\"uint8[52]\"}],\"name\":\"baccarat\",\"outputs\":[{\"name\":\"outcome\",\"type\":\"uint8\"},{\"name\":\"player_hand\",\"type\":\"uint8[3]\"},{\"name\":\"banker_hand\",\"type\":\"uint8[3]\"},{\"name\":\"player_point\",\"type\":\"uint8\"},{\"name\":\"banker_point\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"deck\",\"type\":\"uint8[52]\"},{\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"shuffleDeck\",\"outputs\":[{\"name\":\"shuffled\",\"type\":\"uint8[52]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player_point\",\"type\":\"uint8\"},{\"name\":\"banker_point\",\"type\":\"uint8\"}],\"name\":\"getOutcome\",\"outputs\":[{\"name\":\"outcome\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"string\"}],\"name\":\"GameEnd\",\"type\":\"event\"}]","ContractName":"Baccarat","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d9193d186fd4d6b9c121cd9f68c1e332cba110601f28317ddd5bba6eb369cc2d"}]}