{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.6;\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\n\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/math/UseSafeMath.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\r\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\r\n */\r\n\r\nlibrary SafeMathDivRoundUp {\r\n    using SafeMath for uint256;\r\n\r\n    function divRoundUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(b > 0, errorMessage);\r\n        return ((a - 1) / b) + 1;\r\n    }\r\n\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title UseSafeMath\r\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\r\n * and also can use SafeCast for uint256.\r\n * For example:\r\n *   uint64 a = 1;\r\n *   uint64 b = 2;\r\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\r\n * In additionally, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\r\n * In the case of the operation to the uint64 value, one need to cast the value into int256 in\r\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\r\n * For example:\r\n *   int256 a = 1;\r\n *   uint64 b = 2;\r\n *   int256 c = 3;\r\n *   a = a.add(int256(b).sub(c)); // `a` become 0 as int256\r\n *   b = a.toUint256().toUint64(); // `b` become 0 as uint64\r\n */\r\nabstract contract UseSafeMath {\r\n    using SafeMath for uint256;\r\n    using SafeMathDivRoundUp for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMathDivRoundUp for uint64;\r\n    using SafeMath for uint16;\r\n    using SignedSafeMath for int256;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/StableCoinInterface.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface StableCoinInterface is IERC20 {\r\n    event LogIsAcceptableSBT(bytes32 indexed bondID, bool isAcceptable);\r\n\r\n    event LogMintIDOL(\r\n        bytes32 indexed bondID,\r\n        address indexed owner,\r\n        bytes32 poolID,\r\n        uint256 obtainIDOLAmount,\r\n        uint256 poolIDOLAmount\r\n    );\r\n\r\n    event LogBurnIDOL(\r\n        bytes32 indexed bondID, // poolID?\r\n        address indexed owner,\r\n        uint256 burnIDOLAmount,\r\n        uint256 unlockSBTAmount\r\n    );\r\n\r\n    event LogReturnLockedPool(\r\n        bytes32 indexed poolID,\r\n        address indexed owner,\r\n        uint64 backIDOLAmount\r\n    );\r\n\r\n    event LogLambda(\r\n        bytes32 indexed poolID,\r\n        uint64 settledAverageAuctionPrice,\r\n        uint256 totalSupply,\r\n        uint256 lockedSBTValue\r\n    );\r\n\r\n    function getPoolInfo(bytes32 poolID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 lockedSBTTotal,\r\n            uint64 unlockedSBTTotal,\r\n            uint64 lockedPoolIDOLTotal,\r\n            uint64 burnedIDOLTotal,\r\n            uint64 soldSBTTotalInAuction,\r\n            uint64 paidIDOLTotalInAuction,\r\n            uint64 settledAverageAuctionPrice,\r\n            bool isAllAmountSoldInAuction\r\n        );\r\n\r\n    function solidValueTotal() external view returns (uint256 solidValue);\r\n\r\n    function isAcceptableSBT(bytes32 bondID) external returns (bool ok);\r\n\r\n    function mint(\r\n        bytes32 bondID,\r\n        address recipient,\r\n        uint64 lockAmount\r\n    )\r\n        external\r\n        returns (\r\n            bytes32 poolID,\r\n            uint64 obtainIDOLAmount,\r\n            uint64 poolIDOLAmount\r\n        );\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n    function unlockSBT(bytes32 bondID, uint64 burnAmount)\r\n        external\r\n        returns (uint64 rewardSBT);\r\n\r\n    function startAuctionOnMaturity(bytes32 bondID) external;\r\n\r\n    function startAuctionByMarket(bytes32 bondID) external;\r\n\r\n    function setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 totalPaidIDOL,\r\n        uint64 SBTAmount,\r\n        bool isLast\r\n    ) external;\r\n\r\n    function calcSBT2IDOL(uint256 solidBondAmount)\r\n        external\r\n        view\r\n        returns (uint256 IDOLAmount);\r\n\r\n    function returnLockedPool(bytes32[] calldata poolIDs)\r\n        external\r\n        returns (uint64 IDOLAmount);\r\n\r\n    function returnLockedPoolTo(bytes32[] calldata poolIDs, address account)\r\n        external\r\n        returns (uint64 IDOLAmount);\r\n\r\n    function generatePoolID(bytes32 bondID, uint64 count)\r\n        external\r\n        pure\r\n        returns (bytes32 poolID);\r\n\r\n    function getCurrentPoolID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 poolID);\r\n\r\n    function getLockedPool(address user, bytes32 poolID)\r\n        external\r\n        view\r\n        returns (uint64, uint64);\r\n}\r\n\r\n// File: contracts/util/Time.sol\r\n\r\n\r\n\r\n\r\nabstract contract Time {\r\n    function _getBlockTimestampSec()\r\n        internal\r\n        view\r\n        returns (uint256 unixtimesec)\r\n    {\r\n        unixtimesec = now; // solium-disable-line security/no-block-members\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20MinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/solidBondSafety/SolidBondSafety.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n// This contract is used for calculating minimum threshold acceptable strike price (relative to the current oracle price)\r\n// for the SBT with the time to maturity and the volatility from oracle.\r\n// It is derived from the risk appetite of this protocol.\r\n// For volatile SBT due to the long time to maturity or the underlying ETH volatility,\r\n// the minimum threshold acceptable strike price needs to increase in order to mitigate the risk of emergency auction.\r\n// The policy in this protocol is to equalize the risk of acceptable SBT over the different time to maturity or the underlying ETH volatility.\r\n// The threshold is thus derived from solving the black-scholes formula with a linear approximation technique.\r\n// Even in the approximation of the formula, there remains square root of time, which is tricky to handle in solidity.\r\n// Hence, we deal with the value in the squared form of the value.\r\n// In the following notations, for example, vvtE16 represents v^2 * t * 10^16.\r\nabstract contract SolidBondSafety is UseSafeMath, Time {\r\n    /// @notice The return values of getEmergencyBorderInfo are intermediate values\r\n    /// used for checking if the SBT is acceptable to the IDOL contract.\r\n    /// Let f(x) = a*x + b be the function defined below:\r\n    /// f(x) =            1.1    for 0      <= x <= 0.3576\r\n    /// f(x) =  1.52 x +  0.5564 for 0.3576 < x <= 0.7751\r\n    /// f(x) =  6.4  x -  3.226  for 0.7751 < x <= 1.1562\r\n    /// f(x) = 14.27 x - 12.3256 for 1.1562 < x <= 1.416\r\n    /// f(x) = 29.13 x - 33.3676 for 1.416  < x <= 1.6257\r\n    /// f(x) = 53.15 x - 72.4165 for 1.6257 < x <= 1.8\r\n    /// Then, we define getEmergencyBorderInfo(x^2 * 10^8) = (a^2 * 10^4, b * 10^4).\r\n    /// @param  xxE8 is multiply 10^8 with the square of x\r\n    /// @return aaE4 is multiply 10000 with the square of a\r\n    /// @return bE4  is multiply 10000 with b\r\n    function getEmergencyBorderInfo(uint256 xxE8)\r\n        public\r\n        pure\r\n        returns (int256 aaE4, int256 bE4)\r\n    {\r\n        if (xxE8 <= 3576 * 3576) {\r\n            return (0, 11000);\r\n        } else if (xxE8 <= 7751 * 7751) {\r\n            return (152 * 152, 5564);\r\n        } else if (xxE8 <= 11562 * 11562) {\r\n            return (640 * 640, -32260);\r\n        } else if (xxE8 <= 14160 * 14160) {\r\n            return (1427 * 1427, -123256);\r\n        } else if (xxE8 <= 16257 * 16257) {\r\n            return (2913 * 2913, -333676);\r\n        } else if (xxE8 <= 18000 * 18000) {\r\n            return (5315 * 5315, -724165);\r\n        } else {\r\n            revert(\"not acceptable\");\r\n        }\r\n    }\r\n\r\n    /// @param rateETH2USD S * 10^8 (USD/ETH)\r\n    /// @param solidBondStrikePrice K * 10^4 (USD/SBT)\r\n    /// @param volatility v * 10^8\r\n    /// @param untilMaturity t (= T * 365 * 86400)\r\n    // isInEmergency checks if the SBT should be put into emergency auction.\r\n    // The condition is verified by utilizing approximate form of black-scholes formula.\r\n    function isInEmergency(\r\n        uint256 rateETH2USD,\r\n        uint256 solidBondStrikePrice,\r\n        uint256 volatility,\r\n        uint256 untilMaturity\r\n    ) public pure returns (bool) {\r\n        uint256 vE8 = volatility;\r\n        if (vE8 > 2 * 10**8) {\r\n            vE8 = 2 * 10**8; // The volatility is too high.\r\n        }\r\n        if (untilMaturity >= 12 weeks) {\r\n            return true; // The period until maturity is too long.\r\n        }\r\n        uint256 vvtE16 = vE8.mul(vE8).mul(untilMaturity);\r\n\r\n        uint256 xxE8 = vvtE16 / (64 * 10**6 * 86400 * 365); // 1.25^2 / 10^8 = 1 / (64 * 10^6)\r\n        (int256 aaE4, int256 bE4) = getEmergencyBorderInfo(xxE8);\r\n        int256 sE8 = rateETH2USD.toInt256();\r\n        int256 kE4 = solidBondStrikePrice.toInt256();\r\n        int256 cE8 = sE8.sub(bE4.mul(kE4));\r\n        // int256 lE28 = cE8.mul(cE8).mul(20183040 * 10**12);\r\n        int256 rE28 = int256(vvtE16).mul(aaE4).mul(kE4).mul(kE4);\r\n        bool isDanger = cE8 <= 0 || cE8.mul(cE8).mul(20183040 * 10**12) <= rE28;\r\n        return isDanger;\r\n    }\r\n\r\n    /// @param rateETH2USD S * 10^8 (USD/ETH)\r\n    /// @param solidBondStrikePrice K * 10^4  (USD/SBT)\r\n    /// @param volatility v * 10^8\r\n    /// @param untilMaturity t (= T * 365 * 86400)\r\n    // isDangerSolidBond checks if the SBT is acceptable to be a part of IDOL.\r\n    // The condition is verified by utilizing approximate form of black-scholes formula.\r\n    // This condition is more strict than the condition for triggering emergency auction described in isInEmergency function above.\r\n    function isDangerSolidBond(\r\n        uint256 rateETH2USD,\r\n        uint256 solidBondStrikePrice,\r\n        uint256 volatility,\r\n        uint256 untilMaturity\r\n    ) public pure returns (bool) {\r\n        if (\r\n            solidBondStrikePrice * 5 * 10**4 < rateETH2USD * 2 &&\r\n            untilMaturity < 2 weeks\r\n        ) {\r\n            return false;\r\n        } else if (volatility > 2 * 10**8) {\r\n            return true; // The volatility is too high.\r\n        }\r\n        if (untilMaturity >= 12 weeks) {\r\n            return true; // The period until maturity is too long.\r\n        }\r\n        uint256 vvtE16 = volatility.mul(volatility).mul(untilMaturity);\r\n\r\n        uint256 xxE8 = vvtE16 / (64 * 10**6 * 86400 * 365); // 1.25^2 / 10^8 = 1 / (64 * 10^6)\r\n        (int256 aaE4, int256 bE4) = getEmergencyBorderInfo(xxE8);\r\n        //                                            S/K <= 1.5f(1.25*v*sqrt(T))\r\n        // <=>                                        S/K <= 1.5(1.25a*v*sqrt(T) + b)\r\n        // <=>                                 (2S - 3bK) <= (3.75aKv) * sqrt(T)\r\n        // if 2S > 3bK,\r\n        //                                   (2S - 3bK)^2 <= (3.75aKv)^2 * t / 365 / 86400\r\n        // <=>                       20183040(2S - 3bK)^2 <= 9t(aKv)^2\r\n        // <=> 20183040 * 10^12(10^8 * 2S - 10^8 * 3bK)^2 <= 9 * 10000a^2 * (10000K)^2 * t(10^8 * v)^2\r\n        int256 sE8 = rateETH2USD.toInt256();\r\n        int256 kE4 = solidBondStrikePrice.toInt256();\r\n        int256 cE8 = sE8.mul(2).sub(bE4.mul(kE4).mul(3));\r\n        // int256 lE28 = cE8.mul(cE8).mul(20183040 * 10**12);\r\n        int256 rE28 = int256(vvtE16).mul(aaE4).mul(kE4).mul(kE4).mul(9);\r\n        bool isDanger = cE8 <= 0 || cE8.mul(cE8).mul(20183040 * 10**12) <= rE28;\r\n        return isDanger;\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionTimeControlInterface.sol\r\n\r\n\r\n\r\n\r\ninterface AuctionTimeControlInterface {\r\n    enum TimeControlFlag {\r\n        BEFORE_AUCTION_FLAG,\r\n        ACCEPTING_BIDS_PERIOD_FLAG,\r\n        REVEALING_BIDS_PERIOD_FLAG,\r\n        RECEIVING_SBT_PERIOD_FLAG,\r\n        AFTER_AUCTION_FLAG\r\n    }\r\n\r\n    function listAuction(uint256 timestamp)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n\r\n    function getTimeControlFlag(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (TimeControlFlag);\r\n\r\n    function isInPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function isAfterPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/AuctionInterface.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface AuctionInterface is AuctionTimeControlInterface {\r\n    event LogStartAuction(\r\n        bytes32 indexed auctionID,\r\n        bytes32 bondID,\r\n        uint256 auctionedAmount\r\n    );\r\n\r\n    event LogCancelBid(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes32 secret,\r\n        uint256 returnedIDOLAmount\r\n    );\r\n\r\n    event LogAuctionResult(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint256 SBTAmountOfReward,\r\n        uint256 IDOLAmountOfPayment,\r\n        uint256 IDOLAmountOfChange\r\n    );\r\n\r\n    event LogCloseAuction(\r\n        bytes32 indexed auctionID,\r\n        bool isLast,\r\n        bytes32 nextAuctionID\r\n    );\r\n\r\n    function ongoingAuctionSBTTotal(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64 ongoingSBTAmountE8);\r\n\r\n    function startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) external returns (bytes32 auctonID);\r\n\r\n    function cancelBid(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (uint64 returnedIDOLAmount);\r\n\r\n    function makeAuctionResult(\r\n        bytes32 auctionID,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata winnerBids,\r\n        uint64[] calldata loserBids\r\n    )\r\n        external\r\n        returns (\r\n            uint64 winnerAmount,\r\n            uint64 toPay,\r\n            uint64 IDOLAmountOfChange\r\n        );\r\n\r\n    function closeAuction(bytes32 auctionID)\r\n        external\r\n        returns (bool isLast, bytes32 nextAuctionID);\r\n\r\n    function receiveUnrevealedBidDistribution(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (bool success);\r\n\r\n    function getCurrentAuctionID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 auctionID);\r\n\r\n    function generateAuctionID(bytes32 bondID, uint256 auctionCount)\r\n        external\r\n        pure\r\n        returns (bytes32 auctionID);\r\n\r\n    function listBondIDFromAuctionID(bytes32[] calldata auctionIDs)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs);\r\n\r\n    function getAuctionStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 closingTime,\r\n            uint64 auctionAmount,\r\n            uint64 rewardedAmount,\r\n            uint64 totalSBTAmountBid,\r\n            bool isEmergency,\r\n            bool doneFinalizeWinnerAmount,\r\n            bool doneSortPrice,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n            uint64 totalSBTAmountPaidForUnrevealed\r\n        );\r\n\r\n    function getWeeklyAuctionStatus(uint256 weekNumber)\r\n        external\r\n        view\r\n        returns (uint256[] memory weeklyAuctionStatus);\r\n\r\n    function calcWinnerAmount(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64[] calldata winnerBids\r\n    ) external view returns (uint64 winnerAmount);\r\n\r\n    function calcBillAndCheckLoserBids(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64 winnerAmountInput,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata myLoseBids\r\n    ) external view returns (uint64 paymentAmount);\r\n\r\n    function getAuctionCount(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (uint256 auctionCount);\r\n}\r\n\r\n// File: contracts/AuctionTimeControl.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AuctionTimeControl is Time, AuctionTimeControlInterface {\r\n    uint256 internal immutable MIN_NORMAL_AUCTION_PERIOD;\r\n    uint256 internal immutable MIN_EMERGENCY_AUCTION_PERIOD;\r\n    uint256 internal immutable NORMAL_AUCTION_REVEAL_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_REVEAL_SPAN;\r\n    uint256 internal immutable AUCTION_WITHDRAW_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_WITHDRAW_SPAN;\r\n\r\n    TimeControlFlag internal constant BEFORE_AUCTION_FLAG = TimeControlFlag\r\n        .BEFORE_AUCTION_FLAG;\r\n    TimeControlFlag internal constant ACCEPTING_BIDS_PERIOD_FLAG = TimeControlFlag\r\n        .ACCEPTING_BIDS_PERIOD_FLAG;\r\n    TimeControlFlag internal constant REVEALING_BIDS_PERIOD_FLAG = TimeControlFlag\r\n        .REVEALING_BIDS_PERIOD_FLAG;\r\n    TimeControlFlag internal constant RECEIVING_SBT_PERIOD_FLAG = TimeControlFlag\r\n        .RECEIVING_SBT_PERIOD_FLAG;\r\n    TimeControlFlag internal constant AFTER_AUCTION_FLAG = TimeControlFlag\r\n        .AFTER_AUCTION_FLAG;\r\n\r\n    /**\r\n     * @dev Get whether the auction is in emergency or not.\r\n     */\r\n    mapping(bytes32 => bool) public isAuctionEmergency;\r\n\r\n    /**\r\n     * @dev The end time that the auction accepts bids.\r\n     * The zero value indicates the auction is not held.\r\n     */\r\n    mapping(bytes32 => uint256) public auctionClosingTime;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by listAuction function.\r\n     */\r\n    mapping(uint256 => bytes32[]) internal _weeklyAuctionList;\r\n\r\n    constructor(\r\n        uint256 minNormalAuctionPeriod,\r\n        uint256 minEmergencyAuctionPeriod,\r\n        uint256 normalAuctionRevealSpan,\r\n        uint256 emergencyAuctionRevealSpan,\r\n        uint256 auctionWithdrawSpan,\r\n        uint256 emergencyAuctionWithdrawSpan\r\n    ) public {\r\n        MIN_NORMAL_AUCTION_PERIOD = minNormalAuctionPeriod;\r\n        MIN_EMERGENCY_AUCTION_PERIOD = minEmergencyAuctionPeriod;\r\n        NORMAL_AUCTION_REVEAL_SPAN = normalAuctionRevealSpan;\r\n        EMERGENCY_AUCTION_REVEAL_SPAN = emergencyAuctionRevealSpan;\r\n        AUCTION_WITHDRAW_SPAN = auctionWithdrawSpan;\r\n        EMERGENCY_AUCTION_WITHDRAW_SPAN = emergencyAuctionWithdrawSpan;\r\n    }\r\n\r\n    /**\r\n     * @dev Get auctions which will close within the week.\r\n     */\r\n    function listAuction(uint256 weekNumber)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return _weeklyAuctionList[weekNumber];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the period the auction is currently in.\r\n     * This function returns 0-4 corresponding to its period.\r\n     */\r\n    function getTimeControlFlag(bytes32 auctionID)\r\n        public\r\n        override\r\n        view\r\n        returns (TimeControlFlag)\r\n    {\r\n        uint256 closingTime = auctionClosingTime[auctionID];\r\n\r\n        // Note that the auction span differs based on whether the auction is in emergency or not.\r\n        bool isEmergency = isAuctionEmergency[auctionID];\r\n        uint256 revealSpan = NORMAL_AUCTION_REVEAL_SPAN;\r\n        uint256 withdrawSpan = AUCTION_WITHDRAW_SPAN;\r\n        if (isEmergency) {\r\n            revealSpan = EMERGENCY_AUCTION_REVEAL_SPAN;\r\n            withdrawSpan = EMERGENCY_AUCTION_WITHDRAW_SPAN;\r\n        }\r\n\r\n        uint256 nowTime = _getBlockTimestampSec();\r\n        if (closingTime == 0) {\r\n            return BEFORE_AUCTION_FLAG;\r\n        } else if (nowTime <= closingTime) {\r\n            return ACCEPTING_BIDS_PERIOD_FLAG;\r\n        } else if (nowTime < closingTime + revealSpan) {\r\n            return REVEALING_BIDS_PERIOD_FLAG;\r\n        } else if (nowTime < closingTime + revealSpan + withdrawSpan) {\r\n            return RECEIVING_SBT_PERIOD_FLAG;\r\n        } else {\r\n            return AFTER_AUCTION_FLAG;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns whether or not the auction is in the period indicated\r\n     * by the flag.\r\n     */\r\n    function isInPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        public\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getTimeControlFlag(auctionID) == flag;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether or not the auction is in or after the period indicated\r\n     * by the flag.\r\n     */\r\n    function isAfterPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        public\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getTimeControlFlag(auctionID) >= flag;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates and registers the end time of the period in which the auction accepts bids\r\n     * (= closingTime). The period in which bids are revealed follows after this time.\r\n     */\r\n    function _setAuctionClosingTime(bytes32 auctionID, bool isEmergency)\r\n        internal\r\n    {\r\n        uint256 closingTime;\r\n\r\n        if (isEmergency) {\r\n            closingTime =\r\n                ((_getBlockTimestampSec() +\r\n                    MIN_EMERGENCY_AUCTION_PERIOD +\r\n                    5 minutes -\r\n                    1) / 5 minutes) *\r\n                (5 minutes);\r\n        } else {\r\n            closingTime =\r\n                ((_getBlockTimestampSec() +\r\n                    MIN_NORMAL_AUCTION_PERIOD +\r\n                    1 hours -\r\n                    1) / 1 hours) *\r\n                (1 hours);\r\n        }\r\n        _setAuctionClosingTime(auctionID, isEmergency, closingTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the end time of the period in which the auction accepts bids (= closingTime).\r\n     * The period in which bids are revealed follows after this time.\r\n     */\r\n    function _setAuctionClosingTime(\r\n        bytes32 auctionID,\r\n        bool isEmergency,\r\n        uint256 closingTime\r\n    ) internal {\r\n        isAuctionEmergency[auctionID] = isEmergency;\r\n        auctionClosingTime[auctionID] = closingTime;\r\n        uint256 weekNumber = closingTime / (1 weeks);\r\n        _weeklyAuctionList[weekNumber].push(auctionID);\r\n    }\r\n}\r\n\r\n// File: contracts/BondMakerInterface.sol\r\n\r\n\r\n\r\n\r\ninterface BondMakerInterface {\r\n    event LogNewBond(\r\n        bytes32 indexed bondID,\r\n        address bondTokenAddress,\r\n        uint64 stableStrikePrice,\r\n        bytes32 fnMapID\r\n    );\r\n\r\n    event LogNewBondGroup(uint256 indexed bondGroupID);\r\n\r\n    event LogIssueNewBonds(\r\n        uint256 indexed bondGroupID,\r\n        address indexed issuer,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogReverseBondToETH(\r\n        uint256 indexed bondGroupID,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogExchangeEquivalentBonds(\r\n        address indexed owner,\r\n        uint256 indexed inputBondGroupID,\r\n        uint256 indexed outputBondGroupID,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    function registerNewBond(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        returns (\r\n            bytes32 bondID,\r\n            address bondTokenAddress,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function registerNewBondGroup(\r\n        bytes32[] calldata bondIDList,\r\n        uint256 maturity\r\n    ) external returns (uint256 bondGroupID);\r\n\r\n    function issueNewBonds(uint256 bondGroupID)\r\n        external\r\n        payable\r\n        returns (uint256 amount);\r\n\r\n    function reverseBondToETH(uint256 bondGroupID, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function exchangeEquivalentBonds(\r\n        uint256 inputBondGroupID,\r\n        uint256 outputBondGroupID,\r\n        uint256 amount,\r\n        bytes32[] calldata exceptionBonds\r\n    ) external returns (bool);\r\n\r\n    function liquidateBond(uint256 bondGroupID, uint256 oracleHintID) external;\r\n\r\n    function getBond(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (\r\n            address bondAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function getFnMap(bytes32 fnMapID)\r\n        external\r\n        view\r\n        returns (bytes memory fnMap);\r\n\r\n    function getBondGroup(uint256 bondGroupID)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs, uint256 maturity);\r\n\r\n    function generateBondID(uint256 maturity, bytes calldata functionHash)\r\n        external\r\n        pure\r\n        returns (bytes32 bondID);\r\n}\r\n\r\n// File: contracts/UseBondMaker.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseBondMaker {\r\n    BondMakerInterface internal immutable _bondMakerContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _bondMakerContract = BondMakerInterface(payable(contractAddress));\r\n    }\r\n}\r\n\r\n// File: contracts/UseStableCoin.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseStableCoin {\r\n    StableCoinInterface internal immutable _IDOLContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _IDOLContract = StableCoinInterface(contractAddress);\r\n    }\r\n\r\n    function _transferIDOLFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        _IDOLContract.transferFrom(from, to, amount);\r\n    }\r\n\r\n    function _transferIDOL(address to, uint256 amount) internal {\r\n        _IDOLContract.transfer(to, amount);\r\n    }\r\n\r\n    function _transferIDOL(\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMessage\r\n    ) internal {\r\n        require(_IDOLContract.balanceOf(address(this)) >= amount, errorMessage);\r\n        _IDOLContract.transfer(to, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/auction/AuctionSecret.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface AuctionSecretInterface {\r\n        function auctionSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret\r\n    ) external view returns (\r\n        address sender,\r\n        uint64 amount,\r\n        uint64 IDOLamount\r\n    );\r\n}\r\n\r\nabstract contract AuctionSecret is AuctionSecretInterface {\r\n    /**\r\n     * @param sender is the account who set this secret bid.\r\n     * @param amount is target SBT amount.\r\n     * @param IDOLamount is deposited iDOL amount attached to this secret bid.\r\n     */\r\n    struct Secret {\r\n        address sender;\r\n        uint64 amount;\r\n        uint64 IDOLamount;\r\n    }\r\n    mapping(bytes32 => mapping(bytes32 => Secret)) public override auctionSecret;\r\n\r\n    function _setSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        address sender,\r\n        uint64 amount,\r\n        uint64 IDOLamount\r\n    ) internal returns (bool) {\r\n        require(\r\n            auctionSecret[auctionID][secret].sender == address(0),\r\n            \"Secret already exists\"\r\n        );\r\n        require(sender != address(0), \"the zero address cannot set secret\");\r\n        auctionSecret[auctionID][secret] = Secret({\r\n            sender: sender,\r\n            amount: amount,\r\n            IDOLamount: IDOLamount\r\n        });\r\n        return true;\r\n    }\r\n\r\n    function _removeSecret(bytes32 auctionID, bytes32 secret)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        delete auctionSecret[auctionID][secret];\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionBoardInterface.sol\r\n\r\n\r\n\r\n\r\ninterface AuctionBoardInterface is AuctionSecretInterface {\r\n    event LogBidMemo(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes memo\r\n    );\r\n\r\n    event LogInsertBoard(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint64 bidPrice,\r\n        uint64 boardIndex,\r\n        uint64 targetSBTAmount\r\n    );\r\n\r\n    event LogAuctionInfoDiff(\r\n        bytes32 indexed auctionID,\r\n        uint64 settledAmount,\r\n        uint64 paidIDOL,\r\n        uint64 rewardedSBT\r\n    );\r\n\r\n    function bidWithMemo(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 totalSBTAmountBid,\r\n        bytes calldata memo\r\n    ) external returns (uint256 depositedIDOLAmount);\r\n\r\n    function revealBids(\r\n        bytes32 auctionID,\r\n        uint64[] calldata bids,\r\n        uint64 random\r\n    ) external;\r\n\r\n    function sortBidPrice(bytes32 auctionID, uint64[] calldata sortedPrice)\r\n        external;\r\n\r\n    function makeEndInfo(bytes32 auctionID) external;\r\n\r\n    function calcBill(\r\n        bytes32 auctionID,\r\n        uint64 winnerAmount,\r\n        uint64 myLowestPrice\r\n    ) external view returns (uint64 paymentAmount);\r\n\r\n    function getUnsortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory bidPriceList);\r\n\r\n    function getSortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory bidPriceList);\r\n\r\n    function getEndInfo(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 price,\r\n            uint64 boardIndex,\r\n            uint64 loseSBTAmount,\r\n            uint64 auctionEndPriceWinnerSBTAmount\r\n        );\r\n\r\n    function getBidderStatus(bytes32 auctionID, address bidder)\r\n        external\r\n        view\r\n        returns (uint64 toBack, bool isIDOLReturned);\r\n\r\n    function getBoard(\r\n        bytes32 auctionID,\r\n        uint64 price,\r\n        uint64 boardIndex\r\n    ) external view returns (address bidder, uint64 amount);\r\n\r\n    function getBoardStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory boardStatus);\r\n\r\n    function generateMultiSecret(\r\n        bytes32 auctionID,\r\n        uint64[] calldata bids,\r\n        uint64 random\r\n    ) external pure returns (bytes32 secret);\r\n\r\n    function discretizeBidPrice(uint64 price)\r\n        external\r\n        pure\r\n        returns (uint64 discretizedPrice);\r\n\r\n    function auctionDisposalInfo(bytes32 auctionID) external view returns (\r\n        uint64 solidStrikePriceIDOLForUnrevealedE8,\r\n        uint64 solidStrikePriceIDOLForRestWinnersE8,\r\n        bool isEndInfoCreated,\r\n        bool isForceToFinalizeWinnerAmountTriggered,\r\n        bool isPriceSorted\r\n    );\r\n\r\n    function removeSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 subtractAmount\r\n    ) external;\r\n\r\n    function auctionRevealInfo(bytes32 auctionID) external view returns (\r\n        uint64 totalSBTAmountBid,\r\n        uint64 totalIDOLSecret,\r\n        uint64 totalIDOLRevealed,\r\n        uint16 auctionPriceCount\r\n    );\r\n\r\n    function auctionBoard(\r\n        bytes32 auctionID,\r\n        uint64 bidPrice,\r\n        uint256 boardIndex\r\n    ) external view returns (\r\n        uint64 bidAmount,\r\n        address bidder\r\n    );\r\n\r\n    function auctionParticipantInfo(\r\n        bytes32 auctionID,\r\n        address participant\r\n    ) external view returns (\r\n        uint64 auctionLockedIDOLAmountE8,\r\n        uint16 bidCount\r\n    );\r\n\r\n    function auctionInfo(\r\n        bytes32 auctionID\r\n    ) external view returns (\r\n        uint64 auctionSettledTotalE8,\r\n        uint64 auctionRewardedTotalE8,\r\n        uint64 auctionPaidTotalE8\r\n    );\r\n\r\n    function updateAuctionInfo(\r\n        bytes32 auctionID,\r\n        uint64 settledAmountE8,\r\n        uint64 paidIDOLE8,\r\n        uint64 rewardedSBTE8\r\n    ) external;\r\n\r\n    function deleteParticipantInfo(\r\n        bytes32 auctionID,\r\n        address participant\r\n    ) external;\r\n}\r\n\r\n// File: contracts/UseAuctionBoard.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseAuctionBoard {\r\n    AuctionBoardInterface internal immutable _auctionBoardContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _auctionBoardContract = AuctionBoardInterface(contractAddress);\r\n    }\r\n}\r\n\r\n// File: contracts/oracle/OracleInterface.sol\r\n\r\n\r\n\r\n\r\n// Oracle referenced by OracleProxy must implement this interface.\r\ninterface OracleInterface {\r\n    // Returns if oracle is running.\r\n    function alive() external view returns (bool);\r\n\r\n    // Returns latest id.\r\n    // The first id is 1 and 0 value is invalid as id.\r\n    // Each price values and theirs timestamps are identified by id.\r\n    // Ids are assigned incrementally to values.\r\n    function latestId() external returns (uint256);\r\n\r\n    // Returns latest price value.\r\n    // decimal 8\r\n    function latestPrice() external returns (uint256);\r\n\r\n    // Returns timestamp of latest price.\r\n    function latestTimestamp() external returns (uint256);\r\n\r\n    // Returns price of id.\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    // Returns timestamp of id.\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n\r\n    function getVolatility() external returns (uint256);\r\n}\r\n\r\n// File: contracts/oracle/UseOracle.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseOracle {\r\n    OracleInterface internal _oracleContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _oracleContract = OracleInterface(contractAddress);\r\n    }\r\n\r\n    /// @notice Get the latest USD/ETH price and historical volatility using oracle.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    /// @return volatilityE8 (10^-8)\r\n    function _getOracleData()\r\n        internal\r\n        returns (uint256 rateETH2USDE8, uint256 volatilityE8)\r\n    {\r\n        rateETH2USDE8 = _oracleContract.latestPrice();\r\n        volatilityE8 = _oracleContract.getVolatility();\r\n\r\n        return (rateETH2USDE8, volatilityE8);\r\n    }\r\n\r\n    /// @notice Get the price of the oracle data with a minimum timestamp that does more than input value\r\n    /// when you know the ID you are looking for.\r\n    /// @param timestamp is the timestamp that you want to get price.\r\n    /// @param hintID is the ID of the oracle data you are looking for.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    function _getPriceOn(uint256 timestamp, uint256 hintID)\r\n        internal\r\n        returns (uint256 rateETH2USDE8)\r\n    {\r\n        uint256 latestID = _oracleContract.latestId();\r\n        require(\r\n            latestID != 0,\r\n            \"system error: the ID of oracle data should not be zero\"\r\n        );\r\n\r\n        require(hintID != 0, \"the hint ID must not be zero\");\r\n        uint256 id = hintID;\r\n        if (hintID > latestID) {\r\n            id = latestID;\r\n        }\r\n\r\n        require(\r\n            _oracleContract.getTimestamp(id) > timestamp,\r\n            \"there is no price data after maturity\"\r\n        );\r\n\r\n        id--;\r\n        while (id != 0) {\r\n            if (_oracleContract.getTimestamp(id) <= timestamp) {\r\n                break;\r\n            }\r\n            id--;\r\n        }\r\n\r\n        return _oracleContract.getPrice(id + 1);\r\n    }\r\n}\r\n\r\n// File: contracts/util/TransferETHInterface.sol\r\n\r\n\r\n\r\n\r\ninterface TransferETHInterface {\r\n    receive() external payable;\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/bondToken/BondTokenInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface BondTokenInterface is TransferETHInterface, IERC20 {\r\n    event LogExpire(\r\n        uint128 rateNumerator,\r\n        uint128 rateDenominator,\r\n        bool firstTime\r\n    );\r\n\r\n    function mint(address account, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function expire(uint128 rateNumerator, uint128 rateDenominator)\r\n        external\r\n        returns (bool firstTime);\r\n\r\n    function burn(uint256 amount) external returns (bool success);\r\n\r\n    function burnAll() external returns (uint256 amount);\r\n\r\n    function isMinter(address account) external view returns (bool minter);\r\n\r\n    function getRate()\r\n        external\r\n        view\r\n        returns (uint128 rateNumerator, uint128 rateDenominator);\r\n}\r\n\r\n// File: contracts/Auction.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Auction is\r\n    UseSafeMath,\r\n    AuctionInterface,\r\n    AuctionTimeControl,\r\n    UseStableCoin,\r\n    UseBondMaker,\r\n    UseAuctionBoard\r\n{\r\n    using Math for uint256;\r\n\r\n    uint64 internal constant NO_SKIP_BID = uint64(-1);\r\n    uint64 internal constant SKIP_RECEIVING_WIN_BIDS = uint64(-2);\r\n    uint256 internal constant POOL_AUCTION_COUNT_PADDING = 10**8;\r\n\r\n    /**\r\n     * @notice The times of auctions held for the auction ID.\r\n     * @dev The contents in this internal storage variable can be seen by getAuctionCount function.\r\n     */\r\n    mapping(bytes32 => uint256) internal _bondIDAuctionCount;\r\n\r\n    /**\r\n     * @notice Get the bond ID from the auction ID.\r\n     */\r\n    mapping(bytes32 => bytes32) public auctionID2BondID;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by getAuctionStatus function.\r\n     * @param ongoingAuctionSBTTotalE8 is the SBT amount put up in the auction.\r\n     * @param lowestBidPriceDeadLineE8 is the minimum bid price in the auction.\r\n     * @param highestBidPriceDeadLineE8 is the maximum bid price in the auction.\r\n     * @param totalSBTAmountPaidForUnrevealedE8 is the SBT Amount allocated for those who had not revealed their own bid.\r\n     */\r\n    struct AuctionConfig {\r\n        uint64 ongoingAuctionSBTTotalE8;\r\n        uint64 lowestBidPriceDeadLineE8;\r\n        uint64 highestBidPriceDeadLineE8;\r\n        uint64 totalSBTAmountPaidForUnrevealedE8;\r\n    }\r\n    mapping(bytes32 => AuctionConfig) internal _auctionConfigList;\r\n\r\n    constructor(\r\n        address bondMakerAddress,\r\n        address IDOLAddress,\r\n        address auctionBoardAddress,\r\n        uint256 minNormalAuctionPeriod,\r\n        uint256 minEmergencyAuctionPeriod,\r\n        uint256 normalAuctionRevealSpan,\r\n        uint256 emergencyAuctionRevealSpan,\r\n        uint256 auctionWithdrawSpan,\r\n        uint256 emergencyAuctionWithdrawSpan\r\n    )\r\n        public\r\n        AuctionTimeControl(\r\n            minNormalAuctionPeriod,\r\n            minEmergencyAuctionPeriod,\r\n            normalAuctionRevealSpan,\r\n            emergencyAuctionRevealSpan,\r\n            auctionWithdrawSpan,\r\n            emergencyAuctionWithdrawSpan\r\n        )\r\n        UseBondMaker(bondMakerAddress)\r\n        UseStableCoin(IDOLAddress)\r\n        UseAuctionBoard(auctionBoardAddress)\r\n    {}\r\n\r\n    /**\r\n     * @dev This function starts the auction for the auctionID. Can be called only by the IDOL contract.\r\n     */\r\n    function startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) external override returns (bytes32) {\r\n        require(\r\n            msg.sender == address(_IDOLContract),\r\n            \"caller must be IDOL contract\"\r\n        );\r\n        return _startAuction(bondID, auctionAmount, isEmergency);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called when the auction (re)starts.\r\n     * @param bondID is SBT ID whose auction will be held.\r\n     * @param auctionAmount is SBT amount put up in the auction.\r\n     * @param isEmergency is the flag that indicates the auction schedule is for emergency mode.\r\n     */\r\n    function _startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) internal returns (bytes32) {\r\n        (, , uint256 solidStrikePriceE4, ) = _bondMakerContract.getBond(bondID);\r\n        uint256 strikePriceIDOL = _IDOLContract.calcSBT2IDOL(\r\n            solidStrikePriceE4.mul(10**8)\r\n        );\r\n\r\n        uint256 auctionCount = _bondIDAuctionCount[bondID].add(1);\r\n        _bondIDAuctionCount[bondID] = auctionCount;\r\n        bytes32 auctionID = getCurrentAuctionID(bondID);\r\n        require(\r\n            isInPeriod(auctionID, BEFORE_AUCTION_FLAG),\r\n            \"the auction has been held\"\r\n        );\r\n\r\n        uint256 betaCount = auctionCount.mod(POOL_AUCTION_COUNT_PADDING).min(9);\r\n\r\n        auctionID2BondID[auctionID] = bondID;\r\n\r\n        _setAuctionClosingTime(auctionID, isEmergency);\r\n\r\n        {\r\n            AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n            auctionConfig.ongoingAuctionSBTTotalE8 = auctionAmount;\r\n            auctionConfig.lowestBidPriceDeadLineE8 = _auctionBoardContract\r\n                .discretizeBidPrice(\r\n                strikePriceIDOL\r\n                    .mul(10 - betaCount)\r\n                    .divRoundUp(10**(1 + 8))\r\n                    .mul(10**8)\r\n                    .toUint64()\r\n            );\r\n            auctionConfig.highestBidPriceDeadLineE8 = _auctionBoardContract\r\n                .discretizeBidPrice(\r\n                strikePriceIDOL.divRoundUp(10**8).mul(10**8).toUint64()\r\n            );\r\n            _auctionConfigList[auctionID] = auctionConfig;\r\n        }\r\n\r\n        emit LogStartAuction(auctionID, bondID, auctionAmount);\r\n\r\n        return auctionID;\r\n    }\r\n\r\n    /**\r\n     * @notice submit only your own winning bids and get SBT amount which you'll aquire.\r\n     */\r\n    function calcWinnerAmount(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64[] memory winnerBids\r\n    ) public override view returns (uint64) {\r\n        uint256 totalBidAmount;\r\n\r\n        (\r\n            uint64 endPrice,\r\n            uint64 endBoardIndex,\r\n            uint64 loseSBTAmount,\r\n\r\n        ) = _auctionBoardContract.getEndInfo(auctionID);\r\n\r\n        uint64 bidPrice;\r\n        uint64 boardIndex;\r\n        // can calculate winner amount after making the end info.\r\n        {\r\n            (, , bool isEndInfoCreated, , ) = _auctionBoardContract\r\n                .auctionDisposalInfo(auctionID);\r\n            require(isEndInfoCreated, \"the end info has not been made yet\");\r\n        }\r\n\r\n        for (uint256 i = 0; i < winnerBids.length; i += 2) {\r\n            if (i != 0) {\r\n                require(\r\n                    bidPrice > winnerBids[i] ||\r\n                        (bidPrice == winnerBids[i] &&\r\n                            boardIndex < winnerBids[i + 1]),\r\n                    \"winner bids are not sorted\"\r\n                );\r\n            }\r\n            bidPrice = winnerBids[i];\r\n            boardIndex = winnerBids[i + 1];\r\n            (uint64 bidAmount, address bidder) = _auctionBoardContract\r\n                .auctionBoard(auctionID, bidPrice, boardIndex);\r\n            require(bidder == sender, \"this bid is not yours\");\r\n\r\n            totalBidAmount = totalBidAmount.add(bidAmount);\r\n            if (endPrice == bidPrice) {\r\n                if (boardIndex == endBoardIndex) {\r\n                    // Guarantee loseSBTAmount <= bidAmount in this case.\r\n                    totalBidAmount = totalBidAmount.sub(loseSBTAmount);\r\n                } else {\r\n                    require(\r\n                        boardIndex < endBoardIndex,\r\n                        \"this bid does not win\"\r\n                    );\r\n                }\r\n            } else {\r\n                require(endPrice < bidPrice, \"this bid does not win\");\r\n            }\r\n        }\r\n\r\n        return totalBidAmount.toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice all loser bids must be reported to this function. These are checked and counted for calculations of bill.\r\n     * @param auctionID aunctionID\r\n     * @param sender owner of the bids\r\n     * @param winnerAmountInput SBT amount to aquire. this is needed because this effect the price of SBT in Vickly Auction's protocol.\r\n     * @param myLowestPrice myLowestPrice is the lowest price of skip bids.\r\n     * @param myLoseBids is the all bids which is after the endInfo\r\n     */\r\n    function calcBillAndCheckLoserBids(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64 winnerAmountInput,\r\n        uint64 myLowestPrice,\r\n        uint64[] memory myLoseBids\r\n    ) public override view returns (uint64) {\r\n        uint256 winnerAmount = winnerAmountInput;\r\n        uint256 toPaySkip = 0;\r\n\r\n        if (\r\n            myLowestPrice != NO_SKIP_BID &&\r\n            myLowestPrice != SKIP_RECEIVING_WIN_BIDS\r\n        ) {\r\n            bool myLowestVerify = false;\r\n            for (uint256 i = 0; i < myLoseBids.length; i += 2) {\r\n                uint64 price = myLoseBids[i];\r\n                if (price == myLowestPrice) {\r\n                    myLowestVerify = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            require(\r\n                myLowestVerify,\r\n                \"myLowestPrice must be included in myLoseBids\"\r\n            );\r\n        }\r\n\r\n        // The amount of sender's lose bids will be skipped. In order to optimize the calculation,\r\n        // components in myLoseBids with a higher price than myLowestPrice are added to winnerAmount and\r\n        // to be subtracted at the end of this function.\r\n        for (uint256 i = 0; i < myLoseBids.length; i += 2) {\r\n            uint64 price = myLoseBids[i];\r\n            uint64 boardIndex = myLoseBids[i + 1];\r\n\r\n            if (i != 0) {\r\n                require(\r\n                    price < myLoseBids[i - 2] ||\r\n                        (price == myLoseBids[i - 2] &&\r\n                            boardIndex > myLoseBids[i - 1]),\r\n                    \"myLoseBids is not sorted\"\r\n                );\r\n            }\r\n            {\r\n                (\r\n                    uint64 endPrice,\r\n                    uint64 endBoardIndex,\r\n                    uint64 loseSBTAmount,\r\n\r\n                ) = _auctionBoardContract.getEndInfo(auctionID);\r\n\r\n                if (price == endPrice) {\r\n                    if (boardIndex == endBoardIndex) {\r\n                        require(\r\n                            loseSBTAmount != 0,\r\n                            \"myLoseBids includes the bid which is same as endInfo with no lose SBT amount\"\r\n                        );\r\n\r\n                        // This function does not guarantee to return the correct result if an invalid input is given,\r\n                        // because this function can be used just for getting information.\r\n                        // This function is used in the procecss of makeAuctionResult(), and in such a case,\r\n                        // all the verification for bidder==sender and some necessary conditions are processed\r\n                        // in different functions.\r\n\r\n                        if (myLowestPrice <= price) {\r\n                            winnerAmount = winnerAmount.add(loseSBTAmount);\r\n                            toPaySkip = toPaySkip.add(\r\n                                price.mul(loseSBTAmount).div(10**8)\r\n                            );\r\n                            continue;\r\n                        }\r\n                    } else {\r\n                        require(\r\n                            boardIndex > endBoardIndex,\r\n                            \"myLoseBids includes the bid whose bid index is less than that of endInfo\"\r\n                        );\r\n                    }\r\n                } else {\r\n                    require(\r\n                        price < endPrice,\r\n                        \"myLoseBids includes the bid whose price is more than that of endInfo\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            (uint64 bidAmount, address bidder) = _auctionBoardContract\r\n                .auctionBoard(auctionID, price, boardIndex);\r\n            require(\r\n                bidder == sender,\r\n                \"myLoseBids includes the bid whose owner is not the sender\"\r\n            );\r\n\r\n            if (myLowestPrice <= price) {\r\n                winnerAmount = winnerAmount.add(bidAmount);\r\n                toPaySkip = toPaySkip.add(price.mul(bidAmount).div(10**8));\r\n            }\r\n        }\r\n\r\n        if (myLowestPrice == SKIP_RECEIVING_WIN_BIDS) {\r\n            // Reduce calculation costs instead by receiving obtained SBT at the highest losing price.\r\n            (uint64 endPrice, , , ) = _auctionBoardContract.getEndInfo(\r\n                auctionID\r\n            );\r\n            //while toPaySkip is expected to be zero in the loop above,\r\n            //only the exception is when the the price acctually hit uint64(-1) at an extremely unexpected case.\r\n            return\r\n                endPrice\r\n                    .mul(winnerAmount)\r\n                    .divRoundUp(10**8)\r\n                    .sub(toPaySkip)\r\n                    .toUint64();\r\n        }\r\n\r\n        return\r\n            _auctionBoardContract\r\n                .calcBill(auctionID, winnerAmount.toUint64(), myLowestPrice)\r\n                .sub(toPaySkip)\r\n                .toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice Submit all my win and lose bids, verify them, and transfer the auction reward.\r\n     * @param winnerBids is an array of alternating price and board index.\r\n     * For example, if the end info is { price: 96, boardIndex: 0, loseSBTAmount: 100000000 } and you have 3 bids:\r\n     * { price: 99, boardIndex: 0 }, { price: 97, boardIndex: 2 }, and { price: 96, boardIndex: 1 },\r\n     * you should submit [9900000000, 0, 9700000000, 2] as winnerBids and [9600000000, 1] as loserBids.\r\n     * If the end info is { price: 96, boardIndex: 0, loseSBTAmount: 100000000 } and you have 1 bid:\r\n     * { price: 96, boardIndex: 0 }, you should submit [9600000000, 0] as winnerBids and [9600000000, 0]\r\n     * as loserBids.\r\n     */\r\n    function makeAuctionResult(\r\n        bytes32 auctionID,\r\n        uint64 myLowestPrice,\r\n        uint64[] memory winnerBids,\r\n        uint64[] memory loserBids\r\n    )\r\n        public\r\n        override\r\n        returns (\r\n            uint64,\r\n            uint64,\r\n            uint64\r\n        )\r\n    {\r\n        (\r\n            uint64 auctionLockedIDOLAmountE8,\r\n            uint16 bidCount\r\n        ) = _auctionBoardContract.auctionParticipantInfo(auctionID, msg.sender);\r\n\r\n        require(auctionLockedIDOLAmountE8 != 0, \"This process is already done\");\r\n\r\n        {\r\n            (\r\n                uint64 endPrice,\r\n                uint64 endBoardIndex,\r\n                uint64 loseSBTAmount,\r\n                uint64 auctionEndPriceWinnerSBTAmount\r\n            ) = _auctionBoardContract.getEndInfo(auctionID);\r\n            (address endBidder, ) = _auctionBoardContract.getBoard(\r\n                auctionID,\r\n                endPrice,\r\n                endBoardIndex\r\n            );\r\n            // If dupicated bid count is included (loseSBTAmount != 0), bidCount is increased by 1.\r\n            // When both auctionEndPriceWinnerSBTAmount and loseSBTAmount are no-zero value,\r\n            // the end info bid has two components(a winner bid side & a loser bid side).\r\n            // If endInfo bid is frauded in calcBillAndCheckLoserBids L269, revert here. So there needs not check sender==bidder.\r\n            require(\r\n                winnerBids.length.div(2) + loserBids.length.div(2) ==\r\n                    bidCount +\r\n                        (\r\n                            (msg.sender == endBidder &&\r\n                                loseSBTAmount != 0 &&\r\n                                auctionEndPriceWinnerSBTAmount != 0)\r\n                                ? 1\r\n                                : 0\r\n                        ),\r\n                \"must submit all of your bids\"\r\n            );\r\n        }\r\n\r\n        uint64 winnerAmount = calcWinnerAmount(\r\n            auctionID,\r\n            msg.sender,\r\n            winnerBids\r\n        );\r\n\r\n        uint64 toPay;\r\n        TimeControlFlag timeFlag = getTimeControlFlag(auctionID);\r\n\r\n        if (timeFlag == RECEIVING_SBT_PERIOD_FLAG) {\r\n            toPay = calcBillAndCheckLoserBids(\r\n                auctionID,\r\n                msg.sender,\r\n                winnerAmount,\r\n                myLowestPrice,\r\n                loserBids\r\n            );\r\n        } else {\r\n            require(\r\n                timeFlag > RECEIVING_SBT_PERIOD_FLAG,\r\n                \"has not been the receiving period yet\"\r\n            );\r\n            toPay = calcBillAndCheckLoserBids(\r\n                auctionID,\r\n                msg.sender,\r\n                winnerAmount,\r\n                SKIP_RECEIVING_WIN_BIDS,\r\n                loserBids\r\n            );\r\n        }\r\n\r\n        // IDOLAmountOfChange = max(auctionLockedIDOLAmountE8 - toPay, 0)\r\n        if (toPay > auctionLockedIDOLAmountE8) {\r\n            // assertion to prevent from the worst case that accumulate to certain amount by rounding up of toPay.\r\n            require(\r\n                toPay.sub(auctionLockedIDOLAmountE8) < 10**8,\r\n                \"system error: does not ignore too big error for spam protection\"\r\n            );\r\n            toPay = auctionLockedIDOLAmountE8;\r\n        }\r\n        uint64 IDOLAmountOfChange = auctionLockedIDOLAmountE8 - toPay;\r\n\r\n        _auctionBoardContract.deleteParticipantInfo(auctionID, msg.sender);\r\n        _transferIDOL(msg.sender, IDOLAmountOfChange);\r\n\r\n        _auctionBoardContract.updateAuctionInfo(\r\n            auctionID,\r\n            0,\r\n            toPay,\r\n            winnerAmount\r\n        );\r\n        _distributeToWinners(auctionID, winnerAmount);\r\n\r\n        emit LogAuctionResult(\r\n            auctionID,\r\n            msg.sender,\r\n            winnerAmount,\r\n            toPay,\r\n            IDOLAmountOfChange\r\n        );\r\n\r\n        return (winnerAmount, toPay, IDOLAmountOfChange);\r\n    }\r\n\r\n    /**\r\n     * @notice Close the auction when it is done. If some part of SBTs remain unsold, the auction is held again.\r\n     */\r\n    function closeAuction(bytes32 auctionID)\r\n        public\r\n        override\r\n        returns (bool, bytes32)\r\n    {\r\n        (uint64 auctionSettledTotalE8, , ) = _auctionBoardContract.auctionInfo(\r\n            auctionID\r\n        );\r\n        require(\r\n            isInPeriod(auctionID, AFTER_AUCTION_FLAG),\r\n            \"This function is not allowed to execute in this period\"\r\n        );\r\n\r\n        uint64 ongoingAuctionSBTTotal = _auctionConfigList[auctionID]\r\n            .ongoingAuctionSBTTotalE8;\r\n        require(ongoingAuctionSBTTotal != 0, \"already closed\");\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n\r\n        {\r\n            (, , bool isEndInfoCreated, , ) = _auctionBoardContract\r\n                .auctionDisposalInfo(auctionID);\r\n            require(isEndInfoCreated, \"has not set end info\");\r\n        }\r\n\r\n        _forceToFinalizeWinnerAmount(auctionID);\r\n\r\n        uint256 nextAuctionAmount = ongoingAuctionSBTTotal.sub(\r\n            auctionSettledTotalE8,\r\n            \"allocated SBT amount for auction never becomes lower than reward total\"\r\n        );\r\n\r\n        bool isLast = nextAuctionAmount == 0;\r\n        _publishSettledAverageAuctionPrice(auctionID, isLast);\r\n\r\n        bytes32 nextAuctionID = bytes32(0);\r\n        if (isLast) {\r\n            // closeAuction adds 10**8 to _bondIDAuctionCount[bondID] and resets beta count\r\n            // when all SBT of the auction is sold out.\r\n            _bondIDAuctionCount[bondID] = _bondIDAuctionCount[bondID]\r\n                .div(POOL_AUCTION_COUNT_PADDING)\r\n                .add(1)\r\n                .mul(POOL_AUCTION_COUNT_PADDING);\r\n        } else {\r\n            // When the SBT is not sold out in the auction, restart a new one until all the SBT is successfully sold.\r\n            nextAuctionID = _startAuction(\r\n                bondID,\r\n                nextAuctionAmount.toUint64(),\r\n                true\r\n            );\r\n        }\r\n        delete _auctionConfigList[auctionID].ongoingAuctionSBTTotalE8;\r\n\r\n        emit LogCloseAuction(auctionID, isLast, nextAuctionID);\r\n\r\n        return (isLast, nextAuctionID);\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns SBT amount and iDOL amount (as its change) settled for those who didn't reveal bids.\r\n     */\r\n    function _calcUnrevealedBidDistribution(\r\n        uint64 ongoingAmount,\r\n        uint64 totalIDOLAmountUnrevealed,\r\n        uint64 totalSBTAmountPaidForUnrevealed,\r\n        uint64 solidStrikePriceIDOL,\r\n        uint64 IDOLAmountDeposited\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint64 receivingSBTAmount, uint64 returnedIDOLAmount)\r\n    {\r\n        // (total target) - (total revealed) = (total unrevealed)\r\n        uint64 totalSBTAmountUnrevealed = totalIDOLAmountUnrevealed\r\n            .mul(10**8)\r\n            .div(solidStrikePriceIDOL, \"system error: Oracle has a problem\")\r\n            .toUint64();\r\n\r\n        // min((total unrevealed), ongoing) - (total paid already) = (total deposit for punishment)\r\n        uint64 totalLeftSBTAmountForUnrevealed = uint256(\r\n            totalSBTAmountUnrevealed\r\n        )\r\n            .min(ongoingAmount)\r\n            .sub(totalSBTAmountPaidForUnrevealed)\r\n            .toUint64();\r\n\r\n        // (receiving SBT amount) = min((bid amount), (total deposited))\r\n        uint256 expectedReceivingSBTAmount = IDOLAmountDeposited.mul(10**8).div(\r\n            solidStrikePriceIDOL,\r\n            \"system error: Oracle has a problem\"\r\n        );\r\n\r\n        // (returned iDOL amount) = (deposit amount) - (iDOL value of receiving SBT amount)\r\n        if (expectedReceivingSBTAmount <= totalLeftSBTAmountForUnrevealed) {\r\n            receivingSBTAmount = expectedReceivingSBTAmount.toUint64();\r\n            returnedIDOLAmount = 0;\r\n        } else if (totalLeftSBTAmountForUnrevealed == 0) {\r\n            receivingSBTAmount = 0;\r\n            returnedIDOLAmount = IDOLAmountDeposited;\r\n        } else {\r\n            receivingSBTAmount = totalLeftSBTAmountForUnrevealed;\r\n            returnedIDOLAmount = IDOLAmountDeposited\r\n                .sub(\r\n                totalLeftSBTAmountForUnrevealed\r\n                    .mul(solidStrikePriceIDOL)\r\n                    .divRoundUp(10**8)\r\n            )\r\n                .toUint64();\r\n        }\r\n\r\n        return (receivingSBTAmount, returnedIDOLAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer SBT for those who forget to reveal.\r\n     */\r\n    function receiveUnrevealedBidDistribution(bytes32 auctionID, bytes32 secret)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        (\r\n            uint64 solidStrikePriceIDOL,\r\n            ,\r\n            bool isEndInfoCreated,\r\n            ,\r\n\r\n        ) = _auctionBoardContract.auctionDisposalInfo(auctionID);\r\n        require(\r\n            isEndInfoCreated,\r\n            \"EndInfo hasn't been made. This Function has not been allowed yet.\"\r\n        );\r\n\r\n        (address secOwner, , uint64 IDOLAmountDeposited) = _auctionBoardContract\r\n            .auctionSecret(auctionID, secret);\r\n        require(secOwner == msg.sender, \"ownership of the bid is required\");\r\n\r\n        (\r\n            ,\r\n            uint64 totalIDOLSecret,\r\n            uint64 totalIDOLAmountRevealed,\r\n\r\n        ) = _auctionBoardContract.auctionRevealInfo(auctionID);\r\n        uint64 totalIDOLAmountUnrevealed = totalIDOLSecret\r\n            .sub(totalIDOLAmountRevealed)\r\n            .toUint64();\r\n\r\n        uint64 receivingSBTAmount;\r\n        uint64 returnedIDOLAmount;\r\n        uint64 totalSBTAmountPaidForUnrevealed;\r\n        {\r\n            AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n            totalSBTAmountPaidForUnrevealed = auctionConfig\r\n                .totalSBTAmountPaidForUnrevealedE8;\r\n\r\n            (\r\n                receivingSBTAmount,\r\n                returnedIDOLAmount\r\n            ) = _calcUnrevealedBidDistribution(\r\n                auctionConfig.ongoingAuctionSBTTotalE8,\r\n                totalIDOLAmountUnrevealed,\r\n                totalSBTAmountPaidForUnrevealed,\r\n                solidStrikePriceIDOL,\r\n                IDOLAmountDeposited\r\n            );\r\n        }\r\n\r\n        _auctionConfigList[auctionID]\r\n            .totalSBTAmountPaidForUnrevealedE8 = totalSBTAmountPaidForUnrevealed\r\n            .add(receivingSBTAmount)\r\n            .toUint64();\r\n        _auctionBoardContract.removeSecret(auctionID, secret, 0);\r\n\r\n        // Transfer the winning SBT and (if necessary) return the rest of deposited iDOL.\r\n        _distributeToWinners(auctionID, receivingSBTAmount);\r\n        _IDOLContract.transfer(secOwner, returnedIDOLAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel the bid of your own within the bid acceptance period.\r\n     */\r\n    function cancelBid(bytes32 auctionID, bytes32 secret)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        require(\r\n            isInPeriod(auctionID, ACCEPTING_BIDS_PERIOD_FLAG),\r\n            \"it is not the time to accept bids\"\r\n        );\r\n        (address owner, , uint64 IDOLamount) = _auctionBoardContract\r\n            .auctionSecret(auctionID, secret);\r\n        require(owner == msg.sender, \"you are not the bidder for the secret\");\r\n        _auctionBoardContract.removeSecret(auctionID, secret, IDOLamount);\r\n        _transferIDOL(\r\n            owner,\r\n            IDOLamount,\r\n            \"system error: try to cancel bid, but cannot return iDOL\"\r\n        );\r\n\r\n        emit LogCancelBid(auctionID, owner, secret, IDOLamount);\r\n\r\n        return IDOLamount;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current auction ID.\r\n     */\r\n    function getCurrentAuctionID(bytes32 bondID)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint256 count = _bondIDAuctionCount[bondID];\r\n        return generateAuctionID(bondID, count);\r\n    }\r\n\r\n    /**\r\n     * @notice Generates auction ID from bond ID and the count of auctions for the bond.\r\n     */\r\n    function generateAuctionID(bytes32 bondID, uint256 count)\r\n        public\r\n        override\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(bondID, count));\r\n    }\r\n\r\n    /**\r\n     * @dev The bidder succeeds in winning the SBT for the auctionID with receivingBondAmount, and pays IDOL with billingIDOLAmount.\r\n     */\r\n    function _distributeToWinners(bytes32 auctionID, uint64 receivingBondAmount)\r\n        internal\r\n        returns (uint64)\r\n    {\r\n        // Get the address of SBT contract.\r\n        (address solidBondAddress, , , ) = _getBondFromAuctionID(auctionID);\r\n        require(solidBondAddress != address(0), \"the bond is not registered\");\r\n\r\n        // Transfer the winning SBT.\r\n        BondTokenInterface solidBondContract = BondTokenInterface(\r\n            payable(solidBondAddress)\r\n        );\r\n        solidBondContract.transfer(msg.sender, receivingBondAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev When isLast is true, the SBTs put up in the auction are sold entirely.\r\n     * The average auction price is used for deciding the amount of IDOL to return from the lock pool.\r\n     */\r\n    function _publishSettledAverageAuctionPrice(bytes32 auctionID, bool isLast)\r\n        internal\r\n    {\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n        (\r\n            ,\r\n            uint64 auctionRewardedTotalE8,\r\n            uint64 auctionPaidTotalE8\r\n        ) = _auctionBoardContract.auctionInfo(auctionID);\r\n\r\n        // The auction contract actually do not burn iDOL. Paid iDOL will be transferred and burned in the stable coin contract.\r\n        _transferIDOL(\r\n            address(_IDOLContract),\r\n            auctionPaidTotalE8,\r\n            \"system error: cannot transfer iDOL from auction contract to iDOL contract\"\r\n        );\r\n\r\n        _IDOLContract.setSettledAverageAuctionPrice(\r\n            bondID,\r\n            auctionPaidTotalE8,\r\n            auctionRewardedTotalE8,\r\n            isLast\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev How much IDOL to burn is decided by the settlement price.\r\n     * Hence, this contract needs to decide the price within some specified period.\r\n     */\r\n    function _forceToFinalizeWinnerAmount(bytes32 auctionID) internal {\r\n        (\r\n            uint64 auctionSettledTotalE8,\r\n            uint64 auctionRewardedTotalE8,\r\n\r\n        ) = _auctionBoardContract.auctionInfo(auctionID);\r\n\r\n        if (_auctionBoardContract.getSortedBidPrice(auctionID).length == 0) {\r\n            return;\r\n        }\r\n\r\n        (uint256 burnIDOLRate, , , ) = _auctionBoardContract.getEndInfo(\r\n            auctionID\r\n        );\r\n\r\n        uint256 _totalSBTForRestWinners = auctionSettledTotalE8.sub(\r\n            auctionRewardedTotalE8,\r\n            \"system error: allocated SBT amount for auction never becomes lower than reward total at any point\"\r\n        );\r\n\r\n        uint256 burnIDOL = _totalSBTForRestWinners.mul(burnIDOLRate).div(10**8);\r\n\r\n        _auctionBoardContract.updateAuctionInfo(\r\n            auctionID,\r\n            _totalSBTForRestWinners.toUint64(),\r\n            burnIDOL.toUint64(),\r\n            _totalSBTForRestWinners.toUint64()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the bond information corresponding to the auction ID.\r\n     */\r\n    function _getBondFromAuctionID(bytes32 auctionID)\r\n        internal\r\n        view\r\n        returns (\r\n            address erc20Address,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        )\r\n    {\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n        return _bondMakerContract.getBond(bondID);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the bond IDs corresponding to the auction IDs respectively.\r\n     */\r\n    function listBondIDFromAuctionID(bytes32[] memory auctionIDs)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32[] memory bondIDs)\r\n    {\r\n        bondIDs = new bytes32[](auctionIDs.length);\r\n        for (uint256 i = 0; i < auctionIDs.length; i++) {\r\n            bondIDs[i] = auctionID2BondID[auctionIDs[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the auction status.\r\n     * @param auctionID is a auction ID.\r\n     * @return closingTime is .\r\n     * @return auctionAmount is the SBT amount put up in the auction.\r\n     * @return rewardedAmount is .\r\n     * @return totalSBTAmountBid is .\r\n     * @return isEmergency is .\r\n     * @return doneFinalizeWinnerAmount is .\r\n     * @return doneSortPrice is .\r\n     * @return lowestBidPriceDeadLine is the minimum bid price in the auction.\r\n     * @return highestBidPriceDeadLine is the maximum bid price in the auction.\r\n     * @return totalSBTAmountPaidForUnrevealed is the SBT Amount allocated for those who had not revealed their own bid.\r\n     */\r\n    function getAuctionStatus(bytes32 auctionID)\r\n        public\r\n        override\r\n        view\r\n        returns (\r\n            uint256 closingTime,\r\n            uint64 auctionAmount,\r\n            uint64 rewardedAmount,\r\n            uint64 totalSBTAmountBid,\r\n            bool isEmergency,\r\n            bool doneFinalizeWinnerAmount,\r\n            bool doneSortPrice,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n            uint64 totalSBTAmountPaidForUnrevealed\r\n        )\r\n    {\r\n        closingTime = auctionClosingTime[auctionID].toUint64();\r\n        AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n        auctionAmount = auctionConfig.ongoingAuctionSBTTotalE8;\r\n        lowestBidPriceDeadLine = auctionConfig.lowestBidPriceDeadLineE8;\r\n        highestBidPriceDeadLine = auctionConfig.highestBidPriceDeadLineE8;\r\n        totalSBTAmountPaidForUnrevealed = auctionConfig\r\n            .totalSBTAmountPaidForUnrevealedE8;\r\n        (, rewardedAmount, ) = _auctionBoardContract.auctionInfo(auctionID);\r\n        (totalSBTAmountBid, , , ) = _auctionBoardContract.auctionRevealInfo(\r\n            auctionID\r\n        );\r\n        isEmergency = isAuctionEmergency[auctionID];\r\n        (, , , doneFinalizeWinnerAmount, doneSortPrice) = _auctionBoardContract\r\n            .auctionDisposalInfo(auctionID);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the status of auctions which is held in the week.\r\n     * @param weekNumber is the quotient obtained by dividing the timestamp by 7 * 24 * 60 * 60 (= 7 days).\r\n     */\r\n    function getWeeklyAuctionStatus(uint256 weekNumber)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256[] memory weeklyAuctionStatus)\r\n    {\r\n        bytes32[] memory auctions = listAuction(weekNumber);\r\n        weeklyAuctionStatus = new uint256[](auctions.length.mul(6));\r\n        for (uint256 i = 0; i < auctions.length; i++) {\r\n            (\r\n                uint256 closingTime,\r\n                uint64 auctionAmount,\r\n                uint64 rewardedAmount,\r\n                uint64 totalSBTAmountBid,\r\n                bool isEmergency,\r\n                bool doneFinalizeWinnerAmount,\r\n                bool doneSortPrice,\r\n                ,\r\n                ,\r\n\r\n            ) = getAuctionStatus(auctions[i]);\r\n            uint8 auctionStatusCode = (isEmergency ? 1 : 0) << 2;\r\n            auctionStatusCode += (doneFinalizeWinnerAmount ? 1 : 0) << 1;\r\n            auctionStatusCode += doneSortPrice ? 1 : 0;\r\n            weeklyAuctionStatus[i * 6] = closingTime;\r\n            weeklyAuctionStatus[i * 6 + 1] = auctionAmount;\r\n            weeklyAuctionStatus[i * 6 + 2] = rewardedAmount;\r\n            weeklyAuctionStatus[i * 6 + 3] = totalSBTAmountBid;\r\n            weeklyAuctionStatus[i * 6 + 4] = auctionStatusCode;\r\n            weeklyAuctionStatus[i * 6 + 5] = uint256(auctions[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total SBT amount put up in the auction.\r\n     */\r\n    function ongoingAuctionSBTTotal(bytes32 auctionID)\r\n        external\r\n        override\r\n        view\r\n        returns (uint64 ongoingSBTAmountE8)\r\n    {\r\n        AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n        return auctionConfig.ongoingAuctionSBTTotalE8;\r\n    }\r\n\r\n    function getAuctionCount(bytes32 bondID)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256 auctionCount)\r\n    {\r\n        return _bondIDAuctionCount[bondID];\r\n    }\r\n}\r\n\r\n// File: contracts/util/DeployerRole.sol\r\n\r\n\r\n\r\n\r\nabstract contract DeployerRole {\r\n    address internal immutable _deployer;\r\n\r\n    modifier onlyDeployer() {\r\n        require(\r\n            _isDeployer(msg.sender),\r\n            \"only deployer is allowed to call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _deployer = msg.sender;\r\n    }\r\n\r\n    function _isDeployer(address account) internal view returns (bool) {\r\n        return account == _deployer;\r\n    }\r\n}\r\n\r\n// File: contracts/UseAuctionLater.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseAuctionLater is DeployerRole {\r\n    Auction internal _auctionContract;\r\n\r\n    modifier isNotEmptyAuctionInstance() {\r\n        require(\r\n            address(_auctionContract) != address(0),\r\n            \"the auction contract is not set\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev This function is called only once when the code is initially deployed.\r\n     */\r\n    function setAuctionContract(address contractAddress) public onlyDeployer {\r\n        require(\r\n            address(_auctionContract) == address(0),\r\n            \"the auction contract is already registered\"\r\n        );\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _setAuctionContract(contractAddress);\r\n    }\r\n\r\n    function _setAuctionContract(address contractAddress) internal {\r\n        _auctionContract = Auction(payable(contractAddress));\r\n    }\r\n}\r\n\r\n// File: contracts/StableCoin.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract StableCoin is\r\n    UseSafeMath,\r\n    StableCoinInterface,\r\n    Time,\r\n    ERC20(\"iDOL\", \"iDOL\"),\r\n    SolidBondSafety,\r\n    UseOracle,\r\n    UseBondMaker,\r\n    UseAuctionLater\r\n{\r\n    using Math for uint256;\r\n\r\n    /**\r\n     * @dev pool:mint = 1:9\r\n     */\r\n    uint256 internal constant LOCK_POOL_BORDER = 1;\r\n    uint256 internal constant MINT_IDOL_BORDER = 10 - LOCK_POOL_BORDER;\r\n    uint256 internal immutable AUCTION_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_SPAN;\r\n    uint256 internal immutable MINT_IDOL_AMOUNT_BORDER;\r\n\r\n    /**\r\n     * @dev The contents of this internal storage variable can be seen by solidValueTotal function.\r\n     */\r\n    uint256 internal _solidValueTotalE12;\r\n\r\n    mapping(bytes32 => uint64) public auctionTriggerCount;\r\n\r\n    /**\r\n     * @dev Record the pooled IDOL for each person(= beta * minted amount).\r\n     * The pooled IDOL is going to be refunded partially to the person when the deposited SBT is\r\n     * sold in the auction.\r\n     */\r\n    struct LockedPool {\r\n        uint64 IDOLAmount;\r\n        uint64 baseSBTAmount;\r\n    }\r\n    mapping(address => mapping(bytes32 => LockedPool)) public lockedPoolE8;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by getPoolInfo function.\r\n     * @param lockedSolidBondTotalE8 is the current locked SBT amount.\r\n     * @param unlockedSolidBondTotalE8 is the SBT amount unlocked by unlockSBT().\r\n     * @param lockedPoolIDOLTotalE8 is the iDOL amount locked to the pool for the SBT.\r\n     * @param SBT2BurnedIDOLTotalE8 is the iDOL amount burned by unlockSBT() or setSettledAverageAuctionPrice().\r\n     */\r\n    struct AccountingTotalInfo {\r\n        uint64 lockedSolidBondTotalE8;\r\n        uint64 unlockedSolidBondTotalE8;\r\n        uint64 lockedPoolIDOLTotalE8;\r\n        uint64 SBT2BurnedIDOLTotalE8;\r\n    }\r\n    mapping(bytes32 => AccountingTotalInfo) internal _accountingTotalInfo;\r\n\r\n    /**\r\n     * @notice Record the average settlement price for each SBT bondID.\r\n     * @dev The average settlement price is used for calculating the amount to return partially from\r\n     * the pooled IDOL.\r\n     * The contents in this internal storage variable can be seen by getPoolInfo function.\r\n     * @param auctionSoldSolidBondTotal is the SBT total amount already sold in the auction.\r\n     * @param auctionPaidIDOLTotalE8 is the iDOL amount already paid for the SBT in the auction.\r\n     * @param settledAverageAuctionPrice is the average price for the SBT in the auction and unlockSBT().\r\n     * @param isAllAmountSoldInAuction indicates whether auctionSoldSolidBondTotal equals to the auction amount or not.\r\n     */\r\n    struct AuctionAmountInfo {\r\n        uint64 auctionSoldSolidBondTotal;\r\n        uint64 auctionPaidIDOLTotalE8;\r\n        uint64 settledAverageAuctionPrice;\r\n        bool isAllAmountSoldInAuction;\r\n    }\r\n    mapping(bytes32 => AuctionAmountInfo) internal _auctionAmountInfo;\r\n\r\n    constructor(\r\n        address oracleAddress,\r\n        address bondMakerAddress,\r\n        uint256 auctionSpan,\r\n        uint256 emergencyAuctionSpan,\r\n        uint256 mintIDOLAmountBorder\r\n    ) public UseOracle(oracleAddress) UseBondMaker(bondMakerAddress) {\r\n        _setupDecimals(8);\r\n        AUCTION_SPAN = auctionSpan;\r\n        EMERGENCY_AUCTION_SPAN = emergencyAuctionSpan;\r\n        MINT_IDOL_AMOUNT_BORDER = mintIDOLAmountBorder;\r\n    }\r\n\r\n    function _reduceSBTValue(uint256 SBTValueE12) internal {\r\n        _solidValueTotalE12 = _solidValueTotalE12.sub(SBTValueE12);\r\n    }\r\n\r\n    /**\r\n     * @notice In order to calculate the amount to burn from the pooled IDOL, need to aggregate\r\n     * IDOLs both in the auction and in the unlockSBT function. Calculate settled-average-auction-\r\n     * price (every time an auction ends, the auction contract trigger this)\r\n     * @param bondID ID for auctioned SBT\r\n     * @param auctionPaidIDOL IDOL amount burned in this auction\r\n     * @param auctionSoldAmount SBT amount sold in this auction\r\n     * @param isLastTime True when the auction successfully sold all the SBT\r\n     */\r\n    function _setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 auctionPaidIDOL,\r\n        uint64 auctionSoldAmount,\r\n        bool isLastTime\r\n    ) internal {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        AuctionAmountInfo memory auctionInfo = _auctionAmountInfo[poolID];\r\n\r\n        auctionInfo.auctionSoldSolidBondTotal = auctionInfo\r\n            .auctionSoldSolidBondTotal\r\n            .add(auctionSoldAmount)\r\n            .toUint64();\r\n        auctionInfo.auctionPaidIDOLTotalE8 = auctionInfo\r\n            .auctionPaidIDOLTotalE8\r\n            .add(auctionPaidIDOL)\r\n            .toUint64();\r\n\r\n        if (isLastTime) {\r\n            // Calculate the amount of IDOL to burn\r\n\r\n                AccountingTotalInfo memory accountingInfo\r\n             = _accountingTotalInfo[poolID];\r\n            uint256 burnIDOLAmount = 0;\r\n\r\n            /**\r\n             * @dev In the case of beta=0.1, total distributed IDOL for the bondID\r\n             * can be calculated by the pooled IDOL amount for the bondID multiplied by 9\r\n             * (= MINT_IDOL_BORDER).\r\n             * In the case that someone has withdrawn SBT by unlockSBT(), the pooled IDOL is also\r\n             * circulated.\r\n             * When 3 SBT (strike = $100) are withdrawn by unlockSBT() and 8 SBT are sold in the\r\n             * auction, circulated = (3+8)*100*0.9 and everminted = (3+8)*100.\r\n             * Those 3 and 8 can be captured by looking at the amount of IDOL in the pool.\r\n             */\r\n            {\r\n                // (circulated amount) = (locked pool iDOL total) * MINT_IDOL_BORDER / LOCK_POOL_BORDER\r\n                //                     = (locked pool iDOL total) * MINT_IDOL_BORDER\r\n                uint256 circulated = accountingInfo.lockedPoolIDOLTotalE8.mul(\r\n                    MINT_IDOL_BORDER\r\n                );\r\n                uint256 everMinted = accountingInfo.lockedPoolIDOLTotalE8.add(\r\n                    circulated\r\n                );\r\n                uint256 allBurn = accountingInfo.SBT2BurnedIDOLTotalE8.add(\r\n                    auctionInfo.auctionPaidIDOLTotalE8\r\n                );\r\n                if (allBurn > circulated) {\r\n                    if (everMinted >= allBurn) {\r\n                        // burn all the IDOL issued for the SBT put up in the auction\r\n                        //SAME MEANING of: burnIDOLAmount = everMinted.sub(allBurn).add(auctionPaidIDOLTotalE8[bondID]);\r\n                        burnIDOLAmount = everMinted.sub(\r\n                            accountingInfo.SBT2BurnedIDOLTotalE8\r\n                        );\r\n                    } else {\r\n                        // burn all the IDOL issued for the SBT put up in the auction, and excess amount.\r\n                        //SAME MEANING of: burnIDOLAmount = allBurn.sub(allBurn).add(auctionPaidIDOLTotalE8[bondID]);\r\n                        burnIDOLAmount = allBurn.sub(\r\n                            accountingInfo.SBT2BurnedIDOLTotalE8\r\n                        );\r\n                    }\r\n                } else {\r\n                    // burn as much as we can.\r\n                    //In this case, burn rate(price) is lower than 1-beta\r\n                    burnIDOLAmount = accountingInfo.lockedPoolIDOLTotalE8.add(\r\n                        auctionInfo.auctionPaidIDOLTotalE8\r\n                    );\r\n                }\r\n            }\r\n\r\n            (, , uint64 solidBondStrikePriceUSD, ) = _bondMakerContract.getBond(\r\n                bondID\r\n            );\r\n\r\n            _burn(address(this), burnIDOLAmount);\r\n            accountingInfo.SBT2BurnedIDOLTotalE8 = accountingInfo\r\n                .SBT2BurnedIDOLTotalE8\r\n                .add(auctionInfo.auctionPaidIDOLTotalE8)\r\n                .toUint64();\r\n\r\n            _reduceSBTValue(\r\n                auctionInfo.auctionSoldSolidBondTotal.mul(\r\n                    solidBondStrikePriceUSD\r\n                )\r\n            );\r\n            accountingInfo.unlockedSolidBondTotalE8 = accountingInfo\r\n                .unlockedSolidBondTotalE8\r\n                .add(auctionInfo.auctionSoldSolidBondTotal)\r\n                .toUint64();\r\n\r\n            auctionInfo.settledAverageAuctionPrice = accountingInfo\r\n                .SBT2BurnedIDOLTotalE8\r\n                .mul(10**8)\r\n                .div(\r\n                accountingInfo\r\n                    .unlockedSolidBondTotalE8,\r\n                \"system: the total unlock amount should be non-zero value\"\r\n            )\r\n                .toUint64();\r\n\r\n            auctionInfo.isAllAmountSoldInAuction = true;\r\n            auctionTriggerCount[bondID] = auctionTriggerCount[bondID]\r\n                .add(1)\r\n                .toUint64();\r\n\r\n            _accountingTotalInfo[poolID] = accountingInfo;\r\n\r\n            uint256 totalIDOLSupply = totalSupply();\r\n            emit LogLambda(\r\n                poolID,\r\n                auctionInfo.settledAverageAuctionPrice,\r\n                totalIDOLSupply,\r\n                _solidValueTotalE12\r\n            );\r\n        }\r\n        _auctionAmountInfo[poolID] = auctionInfo;\r\n    }\r\n\r\n    /**\r\n     * @param poolID is a pool ID.\r\n     * @return lockedSBTTotal is the current locked SBT amount. (e8)\r\n     * @return unlockedSBTTotal is the SBT amount unlocked with unlockSBT(). (e8)\r\n     * @return lockedPoolIDOLTotal is the iDOL amount locked to the pool when this was minted. (e8)\r\n     * @return burnedIDOLTotal is the iDOL amount burned with unlockSBT() and setSettledAverageAuctionPrice(). (e8)\r\n     * @return soldSBTTotalInAuction is the SBT total amount already sold in the auction. (e8)\r\n     * @return paidIDOLTotalInAuction is the iDOL amount already paid for SBT in the auction. (e8)\r\n     * @return settledAverageAuctionPrice is the average price with iDOL of the SBT in the auction and unlockSBT(). (e8)\r\n     * @return isAllAmountSoldInAuction is whether auctionSoldSolidBondTotal is equal to the auction amount or not.\r\n     */\r\n    function getPoolInfo(bytes32 poolID)\r\n        external\r\n        override\r\n        view\r\n        returns (\r\n            uint64 lockedSBTTotal,\r\n            uint64 unlockedSBTTotal,\r\n            uint64 lockedPoolIDOLTotal,\r\n            uint64 burnedIDOLTotal,\r\n            uint64 soldSBTTotalInAuction,\r\n            uint64 paidIDOLTotalInAuction,\r\n            uint64 settledAverageAuctionPrice,\r\n            bool isAllAmountSoldInAuction\r\n        )\r\n    {\r\n\r\n            AccountingTotalInfo memory accountingInfo\r\n         = _accountingTotalInfo[poolID];\r\n        lockedSBTTotal = accountingInfo.lockedSolidBondTotalE8;\r\n        unlockedSBTTotal = accountingInfo.unlockedSolidBondTotalE8;\r\n        lockedPoolIDOLTotal = accountingInfo.lockedPoolIDOLTotalE8;\r\n        burnedIDOLTotal = accountingInfo.SBT2BurnedIDOLTotalE8;\r\n\r\n\r\n            AuctionAmountInfo memory auctionSettlementInfo\r\n         = _auctionAmountInfo[poolID];\r\n        soldSBTTotalInAuction = auctionSettlementInfo.auctionSoldSolidBondTotal;\r\n        paidIDOLTotalInAuction = auctionSettlementInfo.auctionPaidIDOLTotalE8;\r\n        settledAverageAuctionPrice = auctionSettlementInfo\r\n            .settledAverageAuctionPrice;\r\n        isAllAmountSoldInAuction = auctionSettlementInfo\r\n            .isAllAmountSoldInAuction;\r\n    }\r\n\r\n    function solidValueTotal() external override view returns (uint256) {\r\n        return _solidValueTotalE12;\r\n    }\r\n\r\n    function generatePoolID(bytes32 bondID, uint64 count)\r\n        public\r\n        override\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(bondID, count, \"lien\"));\r\n    }\r\n\r\n    function getCurrentPoolID(bytes32 bondID)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint64 currentTriggeredCount = auctionTriggerCount[bondID];\r\n        return generatePoolID(bondID, currentTriggeredCount);\r\n    }\r\n\r\n    function getLockedPool(address user, bytes32 poolID)\r\n        public\r\n        override\r\n        view\r\n        returns (uint64, uint64)\r\n    {\r\n        return (\r\n            lockedPoolE8[user][poolID].IDOLAmount,\r\n            lockedPoolE8[user][poolID].baseSBTAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev poolID is counted up and used when the SBT once released from IDOL in the emergency\r\n     * auction becomes qualified again before its maturity.\r\n     */\r\n\r\n    /**\r\n     * @dev Check if the SBT is qualified in terms of the length of the time until maturity,\r\n     * the volatility, and the distance between the current price and the strike price.\r\n     */\r\n    function isAcceptableSBT(bytes32 bondID)\r\n        public\r\n        virtual\r\n        override\r\n        isNotEmptyAuctionInstance\r\n        returns (bool)\r\n    {\r\n        (\r\n            address bondTokenAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePriceE4,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(bondTokenAddress != address(0), \"the bond is not registered\");\r\n        require(\r\n            solidStrikePriceE4 != 0,\r\n            \"the bond does not match to the form of SBT\"\r\n        );\r\n        require(\r\n            maturity > _getBlockTimestampSec() + AUCTION_SPAN,\r\n            \"a request to hold an auction of the bond has already expired\"\r\n        );\r\n        require(\r\n            solidStrikePriceE4 % (10**5) == 0,\r\n            \"the strike price need to be $ 10*X\"\r\n        );\r\n\r\n        bytes32 auctionID = _auctionContract.getCurrentAuctionID(bondID);\r\n        require(\r\n            _auctionContract.ongoingAuctionSBTTotal(auctionID) == 0,\r\n            \"this SBT is on a auciton\"\r\n        );\r\n\r\n        (uint256 rateETH2USDE8, uint256 volatilityE8) = _getOracleData();\r\n        bool isDanger = isDangerSolidBond(\r\n            rateETH2USDE8,\r\n            solidStrikePriceE4,\r\n            volatilityE8,\r\n            maturity - _getBlockTimestampSec()\r\n        );\r\n\r\n        emit LogIsAcceptableSBT(bondID, !isDanger);\r\n\r\n        return !isDanger;\r\n    }\r\n\r\n    /**\r\n     * @notice Lock SBT and mint IDOL\r\n     * @param bondID the ID for the SBT locked for minting IDOL\r\n     * @param lockAmountE8 the amount of locked SBT\r\n     */\r\n    function mint(\r\n        bytes32 bondID,\r\n        address recipient,\r\n        uint64 lockAmountE8\r\n    )\r\n        public\r\n        override\r\n        returns (\r\n            bytes32 poolID,\r\n            uint64 obtainIDOLAmountE8,\r\n            uint64 poolIDOLAmountE8\r\n        )\r\n    {\r\n        poolID = getCurrentPoolID(bondID);\r\n\r\n        // Check if the maturity is sufficiently distant from the current time.\r\n        (\r\n            address bondTokenAddress,\r\n            ,\r\n            uint256 solidStrikePriceE4,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(\r\n            isAcceptableSBT(bondID),\r\n            \"SBT with the bondID is not currently acceptable\"\r\n        );\r\n\r\n\r\n            AccountingTotalInfo memory accountingInfo\r\n         = _accountingTotalInfo[poolID];\r\n\r\n        // Calculate the mint amount based on the dilution ratio.\r\n        uint256 solidBondValueE12 = lockAmountE8.mul(solidStrikePriceE4);\r\n        uint256 mintAmountE8 = calcSBT2IDOL(solidBondValueE12);\r\n        require(\r\n            accountingInfo.lockedPoolIDOLTotalE8 != 0 ||\r\n                mintAmountE8 >= MINT_IDOL_AMOUNT_BORDER,\r\n            \"mint amount need to be greater than 500 idol for this bond\"\r\n        );\r\n\r\n        ERC20 bondTokenContract = ERC20(bondTokenAddress);\r\n        bondTokenContract.transferFrom(msg.sender, address(this), lockAmountE8);\r\n\r\n        // (pooling amount) = mintAmountE8 * LOCK_POOL_BORDER / 10 = mintAmountE8 / 10\r\n        uint256 poolAmount = mintAmountE8.div(10);\r\n        LockedPool storage lockedPoolInfo = lockedPoolE8[recipient][poolID];\r\n        lockedPoolInfo.IDOLAmount = lockedPoolInfo\r\n            .IDOLAmount\r\n            .add(poolAmount)\r\n            .toUint64();\r\n        lockedPoolInfo.baseSBTAmount = lockedPoolInfo\r\n            .baseSBTAmount\r\n            .add(lockAmountE8)\r\n            .toUint64();\r\n\r\n        _mint(recipient, mintAmountE8.sub(poolAmount));\r\n        _mint(address(this), poolAmount);\r\n        _solidValueTotalE12 = _solidValueTotalE12.add(solidBondValueE12);\r\n        accountingInfo.lockedSolidBondTotalE8 = accountingInfo\r\n            .lockedSolidBondTotalE8\r\n            .add(lockAmountE8)\r\n            .toUint64();\r\n        accountingInfo.lockedPoolIDOLTotalE8 = accountingInfo\r\n            .lockedPoolIDOLTotalE8\r\n            .add(poolAmount)\r\n            .toUint64();\r\n        _accountingTotalInfo[poolID] = accountingInfo;\r\n\r\n        uint256 obtainAmount = mintAmountE8.sub(poolAmount);\r\n        emit LogMintIDOL(bondID, recipient, poolID, obtainAmount, poolAmount);\r\n        return (poolID, obtainAmount.toUint64(), poolAmount.toUint64());\r\n    }\r\n\r\n    /**\r\n     * @dev Only the auction contract address can burn some specified amount of the IDOL held by\r\n     * an account.\r\n     */\r\n    function burnFrom(address account, uint256 amount)\r\n        public\r\n        override\r\n        isNotEmptyAuctionInstance\r\n    {\r\n        require(\r\n            msg.sender == address(_auctionContract),\r\n            \"msg.sender must be auction contract\"\r\n        );\r\n        _burn(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice This function provides the opportunity to redeem any type of SBT with a correct\r\n     * amount by burning iDOL. iDOL is pegged to totalLockedValue/totalSupply dollar\r\n     * (initially 1 dollar), so we can always allow anyone to redeem at most 1 dollar worth SBT\r\n     * by burning 1 dollar worth iDOL.\r\n     * This is based on the mathematical fact that the theoretical value of 1 unit SBT with\r\n     * strike price 100 dollar is always strictly less than 100 dollar (e.g. 99.99 dollar).\r\n     * @dev IDOL contract needs to know the value of iDOL per unit by calculating\r\n     * totalLockedValue/totalSupply the value of iDOL per unit may change when the auction\r\n     * settlement price is not within the certain price range.\r\n     * rewardSBT = burnAmountE8/solidStrikePriceE4 * totalSupply/totalLockedValue\r\n     * @param bondID is the bond to unlock\r\n     * @param burnAmountE8 is the iDOL amount to burn\r\n     */\r\n    function unlockSBT(bytes32 bondID, uint64 burnAmountE8)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        (\r\n            address bondTokenAddress,\r\n            ,\r\n            uint256 solidStrikePriceE4,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(bondTokenAddress != address(0), \"the bond is not registered\");\r\n        require(solidStrikePriceE4 != 0, \"the bond is not the form of SBT\");\r\n\r\n            AccountingTotalInfo memory accountingInfo\r\n         = _accountingTotalInfo[poolID];\r\n\r\n        uint64 rewardSBTE8 = burnAmountE8\r\n            .mul(_solidValueTotalE12)\r\n            .div(totalSupply(), \"system error: totalSupply never becomes zero\")\r\n            .div(\r\n            solidStrikePriceE4,\r\n            \"system error: solidStrikePrice never becomes zero [unlockSBT]\"\r\n        )\r\n            .toUint64();\r\n\r\n        // Burn iDOL.\r\n        accountingInfo.SBT2BurnedIDOLTotalE8 = accountingInfo\r\n            .SBT2BurnedIDOLTotalE8\r\n            .add(burnAmountE8)\r\n            .toUint64();\r\n\r\n        _burn(msg.sender, burnAmountE8);\r\n\r\n        // Return SBT.\r\n        BondTokenInterface bondTokenContract = BondTokenInterface(\r\n            payable(bondTokenAddress)\r\n        );\r\n        bondTokenContract.transfer(msg.sender, rewardSBTE8);\r\n\r\n        emit LogBurnIDOL(bondID, msg.sender, burnAmountE8, rewardSBTE8);\r\n\r\n        // Update solidValueTotal, lockedSolidBondTotalE18 and unlockedSolidBondTotal.\r\n        _solidValueTotalE12 = _solidValueTotalE12.sub(\r\n            rewardSBTE8.mul(solidStrikePriceE4)\r\n        );\r\n        accountingInfo.lockedSolidBondTotalE8 = accountingInfo\r\n            .lockedSolidBondTotalE8\r\n            .sub(rewardSBTE8)\r\n            .toUint64();\r\n        accountingInfo.unlockedSolidBondTotalE8 = accountingInfo\r\n            .unlockedSolidBondTotalE8\r\n            .add(rewardSBTE8)\r\n            .toUint64();\r\n\r\n        _accountingTotalInfo[poolID] = accountingInfo;\r\n\r\n        return rewardSBTE8;\r\n    }\r\n\r\n    /**\r\n     * @notice Starts regular auction for SBT with short maturity.\r\n     */\r\n    function startAuctionOnMaturity(bytes32 bondID)\r\n        public\r\n        override\r\n        isNotEmptyAuctionInstance\r\n    {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        (\r\n            address bondTokenAddress,\r\n            uint256 maturity,\r\n            uint64 solidBondStrikePriceUSD,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(bondTokenAddress != address(0), \"the bond is not registered\");\r\n        require(\r\n            solidBondStrikePriceUSD != 0,\r\n            \"the bond is not the form of SBT\"\r\n        );\r\n        require(\r\n            maturity <= _getBlockTimestampSec() + AUCTION_SPAN,\r\n            \"maturity is later than the regular auctionSpan\"\r\n        );\r\n\r\n        uint64 lockedSolidBondTotalE8;\r\n        {\r\n\r\n                AccountingTotalInfo memory accountingInfo\r\n             = _accountingTotalInfo[poolID];\r\n            lockedSolidBondTotalE8 = accountingInfo.lockedSolidBondTotalE8;\r\n            if (lockedSolidBondTotalE8 == 0) {\r\n                if (accountingInfo.lockedPoolIDOLTotalE8 != 0) {\r\n                    _setSettledAverageAuctionPrice(bondID, 0, 0, true);\r\n                }\r\n                return;\r\n            }\r\n            delete _accountingTotalInfo[poolID].lockedSolidBondTotalE8;\r\n        }\r\n\r\n        if (maturity <= _getBlockTimestampSec() + EMERGENCY_AUCTION_SPAN) {\r\n            _auctionContract.startAuction(bondID, lockedSolidBondTotalE8, true);\r\n        } else {\r\n            _auctionContract.startAuction(\r\n                bondID,\r\n                lockedSolidBondTotalE8,\r\n                false\r\n            );\r\n        }\r\n\r\n        // Send SBT to the auction contract.\r\n        BondTokenInterface bondTokenContract = BondTokenInterface(\r\n            payable(bondTokenAddress)\r\n        );\r\n        bondTokenContract.transfer(\r\n            address(_auctionContract),\r\n            lockedSolidBondTotalE8\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Starts emergency auction\r\n     * @dev Check if the SBT needs to trigger the emergency auction based on the length of the\r\n     * time until maturity, the volatility, and the distance between the current price and the\r\n     * strike price.\r\n     */\r\n    function startAuctionByMarket(bytes32 bondID)\r\n        public\r\n        override\r\n        isNotEmptyAuctionInstance\r\n    {\r\n        bytes32 poolID = getCurrentPoolID(bondID);\r\n        (\r\n            address bondTokenAddress,\r\n            uint256 maturity,\r\n            uint64 solidBondStrikePriceUSD,\r\n\r\n        ) = _bondMakerContract.getBond(bondID);\r\n        require(bondTokenAddress != address(0), \"the bond is not registered\");\r\n        require(\r\n            solidBondStrikePriceUSD != 0,\r\n            \"the bond is not the form of SBT\"\r\n        );\r\n\r\n        (uint256 rateETH2USD, uint256 volatility) = _getOracleData();\r\n        bool isDanger = isInEmergency(\r\n            rateETH2USD,\r\n            solidBondStrikePriceUSD,\r\n            volatility,\r\n            maturity - _getBlockTimestampSec()\r\n        );\r\n        require(isDanger, \"the SBT is not in emergency\");\r\n\r\n        uint64 lockedSolidBondTotalE8;\r\n        {\r\n\r\n                AccountingTotalInfo memory accountingInfo\r\n             = _accountingTotalInfo[poolID];\r\n            lockedSolidBondTotalE8 = accountingInfo.lockedSolidBondTotalE8;\r\n            if (lockedSolidBondTotalE8 == 0) {\r\n                if (accountingInfo.lockedPoolIDOLTotalE8 != 0) {\r\n                    _setSettledAverageAuctionPrice(bondID, 0, 0, true);\r\n                }\r\n                return;\r\n            }\r\n            delete _accountingTotalInfo[poolID].lockedSolidBondTotalE8;\r\n        }\r\n\r\n        _auctionContract.startAuction(bondID, lockedSolidBondTotalE8, true);\r\n\r\n        // Send SBT to the auction contract.\r\n        BondTokenInterface bondTokenContract = BondTokenInterface(\r\n            payable(bondTokenAddress)\r\n        );\r\n        bondTokenContract.transfer(\r\n            address(_auctionContract),\r\n            lockedSolidBondTotalE8\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sets SettledAverageAuctionPrice and burns a portion of pooled IDOL.\r\n     * @dev Only callable from the auction contract.\r\n     */\r\n    function setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 totalPaidIDOL,\r\n        uint64 SBTAmount,\r\n        bool isLast\r\n    ) public override isNotEmptyAuctionInstance {\r\n        require(\r\n            msg.sender == address(_auctionContract),\r\n            \"msg.sender must be auction contract\"\r\n        );\r\n\r\n        (, , uint256 solidStrikePrice, ) = _bondMakerContract.getBond(bondID);\r\n        require(solidStrikePrice != 0, \"the bond is not the form of SBT\");\r\n        _setSettledAverageAuctionPrice(\r\n            bondID,\r\n            totalPaidIDOL,\r\n            SBTAmount,\r\n            isLast\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the IDOL amount equivalent to the strike price value of SBT.\r\n     * @param solidBondValueE12 solidBondValueE12(USD) = SBT(SBT) * strikePrice(USD/SBT)\r\n     */\r\n    function calcSBT2IDOL(uint256 solidBondValueE12)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256 IDOLAmountE8)\r\n    {\r\n        if (_solidValueTotalE12 == 0) {\r\n            return solidBondValueE12.div(10**4);\r\n        }\r\n\r\n        return solidBondValueE12.mul(totalSupply()).div(_solidValueTotalE12);\r\n    }\r\n\r\n    function _calcUnlockablePoolAmount(bytes32 poolID, address account)\r\n        internal\r\n        returns (uint64)\r\n    {\r\n        AuctionAmountInfo memory auctionInfo = _auctionAmountInfo[poolID];\r\n        if (!auctionInfo.isAllAmountSoldInAuction) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 pool = lockedPoolE8[account][poolID].IDOLAmount;\r\n        uint256 amountE8 = lockedPoolE8[account][poolID].baseSBTAmount;\r\n        delete lockedPoolE8[account][poolID];\r\n\r\n        uint256 auctionIDOLPriceE8 = auctionInfo.settledAverageAuctionPrice;\r\n        uint256 toBack = 0;\r\n\r\n        // The return value can be calculated by\r\n        // (average sold price) * (total sold amount) - (total distributed amount) for the bondID.\r\n        // Here, (total distributed amount) = pool * MINT_IDOL_BORDER / LOCK_POOL_BORDER = pool * MINT_IDOL_BORDER\r\n        if (\r\n            auctionIDOLPriceE8.mul(amountE8).div(10**8) >\r\n            pool.mul(MINT_IDOL_BORDER)\r\n        ) {\r\n            toBack =\r\n                auctionIDOLPriceE8.mul(amountE8).div(10**8) -\r\n                pool.mul(MINT_IDOL_BORDER);\r\n        }\r\n\r\n        return toBack.min(pool).toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice Receives all the redeemable IDOL in one action.\r\n     * @dev Receive corresponding pooled IDOL based on the SettledAverageAuctionPrice.\r\n     */\r\n    function returnLockedPoolTo(bytes32[] memory poolIDs, address account)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        uint256 totalBackIDOLAmount = 0;\r\n        for (uint256 i = 0; i < poolIDs.length; i++) {\r\n            // For each bondID, the return amount should not exceed the pooled amount.\r\n            uint64 backIDOLAmount = _calcUnlockablePoolAmount(\r\n                poolIDs[i],\r\n                account\r\n            );\r\n            totalBackIDOLAmount = totalBackIDOLAmount.add(backIDOLAmount);\r\n            if (backIDOLAmount != 0) {\r\n                emit LogReturnLockedPool(poolIDs[i], account, backIDOLAmount);\r\n            }\r\n        }\r\n\r\n        this.transfer(account, totalBackIDOLAmount);\r\n\r\n        return totalBackIDOLAmount.toUint64();\r\n    }\r\n\r\n    function returnLockedPool(bytes32[] memory poolIDs)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        return returnLockedPoolTo(poolIDs, msg.sender);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bondMakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyAuctionSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintIDOLAmountBorder\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnIDOLAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockSBTAmount\",\"type\":\"uint256\"}],\"name\":\"LogBurnIDOL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAcceptable\",\"type\":\"bool\"}],\"name\":\"LogIsAcceptableSBT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"settledAverageAuctionPrice\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedSBTValue\",\"type\":\"uint256\"}],\"name\":\"LogLambda\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"obtainIDOLAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolIDOLAmount\",\"type\":\"uint256\"}],\"name\":\"LogMintIDOL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"backIDOLAmount\",\"type\":\"uint64\"}],\"name\":\"LogReturnLockedPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionTriggerCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"solidBondValueE12\",\"type\":\"uint256\"}],\"name\":\"calcSBT2IDOL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"IDOLAmountE8\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"}],\"name\":\"generatePoolID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"getCurrentPoolID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xxE8\",\"type\":\"uint256\"}],\"name\":\"getEmergencyBorderInfo\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"aaE4\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"bE4\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"}],\"name\":\"getLockedPool\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"lockedSBTTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"unlockedSBTTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockedPoolIDOLTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"burnedIDOLTotal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"soldSBTTotalInAuction\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"paidIDOLTotalInAuction\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"settledAverageAuctionPrice\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isAllAmountSoldInAuction\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"isAcceptableSBT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rateETH2USD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"solidBondStrikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"untilMaturity\",\"type\":\"uint256\"}],\"name\":\"isDangerSolidBond\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rateETH2USD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"solidBondStrikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"untilMaturity\",\"type\":\"uint256\"}],\"name\":\"isInEmergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lockedPoolE8\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"IDOLAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"baseSBTAmount\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"lockAmountE8\",\"type\":\"uint64\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"obtainIDOLAmountE8\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"poolIDOLAmountE8\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"poolIDs\",\"type\":\"bytes32[]\"}],\"name\":\"returnLockedPool\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"poolIDs\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"returnLockedPoolTo\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setAuctionContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"totalPaidIDOL\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"SBTAmount\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isLast\",\"type\":\"bool\"}],\"name\":\"setSettledAverageAuctionPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solidValueTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"startAuctionByMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"startAuctionOnMaturity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"burnAmountE8\",\"type\":\"uint64\"}],\"name\":\"unlockSBT\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StableCoin","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000120a078fdc516a1a98bbecb9e961f8741ac7ac820000000000000000000000008b24f5c764ab741bc8a2426505bda458c30df010000000000000000000000000000000000000000000000000000000000003f4800000000000000000000000000000000000000000000000000000000000015f900000000000000000000000000000000000000000000000000000000ba43b7400","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d085672f8467497f59973194f9b1d4d97c7592939b63afb78bc9add4e0e727e6"}]}