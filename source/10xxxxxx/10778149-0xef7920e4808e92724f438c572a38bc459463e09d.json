{"status":"1","message":"OK","result":[{"SourceCode":"// https://nhentai.net/g/177978/\r\n//⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄\r\n//⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄\r\n//⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄\r\n//⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄\r\n//⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰\r\n//⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤\r\n//⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗\r\n//⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄\r\n//⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄\r\n//⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄\r\n//⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄\r\n//⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄\r\n//⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄\r\n//⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴\r\n//⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿\r\n\r\n// File: @openzeppelin/contracts/cryptography/MerkleProof.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n// File: contracts/redeem/IERC20.sol\r\n\r\npragma solidity 0.6.0;\r\n\r\ninterface IERC20 {\r\n  event Approval(address indexed src, address indexed dst, uint amt);\r\n  event Transfer(address indexed src, address indexed dst, uint amt);\r\n\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address whom) external view returns (uint);\r\n  function allowance(address src, address dst) external view returns (uint);\r\n\r\n  function approve(address dst, uint amt) external returns (bool);\r\n  function transfer(address dst, uint amt) external returns (bool);\r\n  function transferFrom(\r\n    address src, address dst, uint amt\r\n  ) external returns (bool);\r\n}\r\n\r\n// File: contracts/redeem/ISwapXToken.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ISwapXToken {\r\n    function initialize(string calldata name, string calldata sym, uint maxSupply) external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    function verify(bool verified) external;\r\n\r\n    function verified() external returns (bool);\r\n\r\n    function addIssuer(address _addr) external returns (bool);\r\n\r\n    function removeIssuer(address _addr) external returns (bool);\r\n\r\n    function issue(address account, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: contracts/redeem/MerkleRedeem.sol\r\n\r\npragma solidity 0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\ncontract MerkleRedeem {\r\n    address public tokenAddress;\r\n    address public owner;\r\n\r\n    event Claimed(address _claimant, address _token, uint256 _balance);\r\n    event VerifiedToken(address _token);\r\n\r\n    // Recorded epochs\r\n    uint256 latestEpoch;\r\n    mapping(uint256 => bytes32) public epochMerkleRoots;\r\n    mapping(uint256 => uint256) public epochTimestamps;\r\n    mapping(uint256 => bytes32) public epochBlockHashes;\r\n    mapping(uint256 => mapping(address => mapping(address => bool)))\r\n        public claimed;\r\n\r\n    address[] public _verifiedTokens;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Must be the contract owner\");\r\n        _;\r\n    }\r\n\r\n    modifier requireEpochInPast(uint256 epoch) {\r\n        require(epoch <= latestEpoch, \"Epoch cannot be in the future\");\r\n        _;\r\n    }\r\n\r\n    modifier requireEpochRecorded(uint256 _epoch) {\r\n        require(epochTimestamps[_epoch] != 0);\r\n        require(epochBlockHashes[_epoch] != 0);\r\n        _;\r\n    }\r\n\r\n    modifier requireMerkleRootUnset(uint256 _epoch) {\r\n        require(epochMerkleRoots[_epoch] == bytes32(0));\r\n        _;\r\n    }\r\n\r\n    modifier requireUnverified(address _token) {\r\n        require(verified(_token) == false);\r\n        _;\r\n    }\r\n\r\n    function verify(address _token)\r\n        external\r\n        onlyOwner\r\n        requireUnverified(_token)\r\n    {\r\n        ISwapXToken(_token).verify(true);\r\n        _verifiedTokens.push(_token);\r\n        emit VerifiedToken(_token);\r\n    }\r\n\r\n    function verified(address _token) public view returns (bool) {\r\n        for (uint256 i = 0; i < _verifiedTokens.length; i++) {\r\n            if (_token == _verifiedTokens[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function verifiedTokens() public view returns (address[] memory) {\r\n        address[] memory result = new address[](1);\r\n        if (0 == _verifiedTokens.length) {\r\n            delete result;\r\n            return result;\r\n        }\r\n        uint256 len = _verifiedTokens.length;\r\n        address[] memory results = new address[](len);\r\n        for (uint256 i = 0; i < _verifiedTokens.length; i++) {\r\n            results[i] = _verifiedTokens[i];\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    function issue(address _token, uint256 amount) external onlyOwner {\r\n        if (amount > 0) {\r\n            ISwapXToken(_token).issue(address(this), amount);\r\n        } else {\r\n            revert(\"No amount would be minted - not gonna waste your gas\");\r\n        }\r\n    }\r\n\r\n    function disburse(\r\n        address _liquidityProvider,\r\n        address _token,\r\n        uint256 _balance\r\n    ) private {\r\n        if (_balance > 0) {\r\n            IERC20(_token).transfer(_liquidityProvider, _balance);\r\n            emit Claimed(_liquidityProvider, _token, _balance);\r\n        } else {\r\n            revert(\"No balance would be transfered - not gonna waste your gas\");\r\n        }\r\n    }\r\n\r\n    function offsetRequirementMet(address user, uint256 _epoch)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes32 blockHash = epochBlockHashes[_epoch];\r\n        uint256 timestamp = epochTimestamps[_epoch];\r\n        uint256 offsetSeconds = userEpochOffset(user, blockHash);\r\n\r\n        uint256 earliestClaimableTimestamp = timestamp + offsetSeconds;\r\n        return earliestClaimableTimestamp < block.timestamp;\r\n    }\r\n\r\n    function claimEpoch(\r\n        address _liquidityProvider,\r\n        uint256 _epoch,\r\n        address _token,\r\n        uint256 _claimedBalance,\r\n        bytes32[] memory _merkleProof\r\n    ) public requireEpochInPast(_epoch) requireEpochRecorded(_epoch) {\r\n        // if trying to claim for the current epoch\r\n        if (_epoch == latestEpoch) {\r\n            require(\r\n                offsetRequirementMet(_liquidityProvider, latestEpoch),\r\n                \"It is too early to claim for the current epoch\"\r\n            );\r\n        }\r\n\r\n        require(!claimed[_epoch][_liquidityProvider][_token]);\r\n        require(\r\n            verifyClaim(\r\n                _liquidityProvider,\r\n                _epoch,\r\n                _token,\r\n                _claimedBalance,\r\n                _merkleProof\r\n            ),\r\n            \"Incorrect merkle proof\"\r\n        );\r\n\r\n        claimed[_epoch][_liquidityProvider][_token] = true;\r\n        disburse(_liquidityProvider, _token, _claimedBalance);\r\n    }\r\n\r\n    struct Claim {\r\n        uint256 epoch;\r\n        address token;\r\n        uint256 balance;\r\n        bytes32[] merkleProof;\r\n    }\r\n\r\n    mapping(address => uint256) tokenTotalBalances; //temp mapping\r\n\r\n    function claimEpochs(address _liquidityProvider, Claim[] memory claims)\r\n        public\r\n    {\r\n        Claim memory claim;\r\n        address[] memory _tokens;\r\n        for (uint256 i = 0; i < claims.length; i++) {\r\n            claim = claims[i];\r\n            require(\r\n                claim.epoch <= latestEpoch,\r\n                \"Epoch cannot be in the future\"\r\n            );\r\n            require(epochTimestamps[claim.epoch] != 0);\r\n            require(epochBlockHashes[claim.epoch] != 0);\r\n\r\n            // if trying to claim for the current epoch\r\n            if (claim.epoch == latestEpoch) {\r\n                require(\r\n                    offsetRequirementMet(_liquidityProvider, latestEpoch),\r\n                    \"It is too early to claim for the current epoch\"\r\n                );\r\n            }\r\n\r\n            require(!claimed[claim.epoch][_liquidityProvider][claim.token]);\r\n            require(\r\n                verifyClaim(\r\n                    _liquidityProvider,\r\n                    claim.epoch,\r\n                    claim.token,\r\n                    claim.balance,\r\n                    claim.merkleProof\r\n                ),\r\n                \"Incorrect merkle proof\"\r\n            );\r\n\r\n            if (tokenTotalBalances[claim.token] == uint256(0)) {\r\n                _tokens[_tokens.length] = claim.token;\r\n            }\r\n\r\n            tokenTotalBalances[claim.token] += claim.balance;\r\n\r\n            claimed[claim.epoch][_liquidityProvider][claim.token] = true;\r\n        }\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            disburse(\r\n                _liquidityProvider,\r\n                _tokens[i],\r\n                tokenTotalBalances[_tokens[i]]\r\n            );\r\n\r\n            delete tokenTotalBalances[_tokens[i]];\r\n        }\r\n        delete _tokens;\r\n    }\r\n\r\n    function claimStatus(\r\n        address _liquidityProvider,\r\n        address _token,\r\n        uint256 _begin,\r\n        uint256 _end\r\n    ) public view returns (bool[] memory) {\r\n        uint256 size = 1 + _end - _begin;\r\n        bool[] memory arr = new bool[](size);\r\n        for (uint256 i = 0; i < size; i++) {\r\n            arr[i] = claimed[_begin + i][_liquidityProvider][_token];\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function merkleRoots(uint256 _begin, uint256 _end)\r\n        public\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        uint256 size = 1 + _end - _begin;\r\n        bytes32[] memory arr = new bytes32[](size);\r\n        for (uint256 i = 0; i < size; i++) {\r\n            arr[i] = epochMerkleRoots[_begin + i];\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function verifyClaim(\r\n        address _liquidityProvider,\r\n        uint256 _epoch,\r\n        address _token,\r\n        uint256 _claimedBalance,\r\n        bytes32[] memory _merkleProof\r\n    ) public view returns (bool valid) {\r\n        bytes32 leaf = keccak256(\r\n            abi.encodePacked(_liquidityProvider, _token, _claimedBalance)\r\n        );\r\n        return MerkleProof.verify(_merkleProof, epochMerkleRoots[_epoch], leaf);\r\n    }\r\n\r\n    function userEpochOffset(\r\n        address _liquidityProvider,\r\n        bytes32 _epochBlockHash\r\n    ) public pure returns (uint256 offset) {\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(_liquidityProvider, _epochBlockHash)\r\n        );\r\n        assembly {\r\n            offset := mod(\r\n                hash,\r\n                86400 // seconds in a epoch\r\n            )\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    function finishEpoch(\r\n        uint256 _epoch,\r\n        uint256 _timestamp,\r\n        bytes32 _blockHash\r\n    ) public onlyOwner {\r\n        epochTimestamps[_epoch] = _timestamp;\r\n        epochBlockHashes[_epoch] = _blockHash;\r\n        if (_epoch > latestEpoch) {\r\n            // just in case we get these out of order\r\n            latestEpoch = _epoch;\r\n        }\r\n    }\r\n\r\n    function seedAllocations(uint256 _epoch, bytes32 _merkleRoot)\r\n        external\r\n        requireEpochRecorded(_epoch)\r\n        requireMerkleRootUnset(_epoch)\r\n        onlyOwner\r\n    {\r\n        require(\r\n            epochMerkleRoots[_epoch] == bytes32(0),\r\n            \"cannot rewrite merkle root\"\r\n        );\r\n        epochMerkleRoots[_epoch] = _merkleRoot;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"VerifiedToken\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_verifiedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_claimedBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct MerkleRedeem.Claim[]\",\"name\":\"claims\",\"type\":\"tuple[]\"}],\"name\":\"claimEpochs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_begin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"claimStatus\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochBlockHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochMerkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"}],\"name\":\"finishEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_begin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"offsetRequirementMet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"seedAllocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_epochBlockHash\",\"type\":\"bytes32\"}],\"name\":\"userEpochOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"verified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifiedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_claimedBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MerkleRedeem","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a92f5c9fe092ecb550e404f3b1fbfc660bba756d89ca653a0d0863a06175b0ac"}]}