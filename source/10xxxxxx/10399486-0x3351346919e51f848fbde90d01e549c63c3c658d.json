{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n    \r\n    \r\n     ██████╗ ██████╗     ██████╗  █████╗ ██╗     \r\n    ██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██║     \r\n    ██║   ██║██████╔╝    ██████╔╝███████║██║     \r\n    ██║▄▄ ██║██╔══██╗    ██╔═══╝ ██╔══██║██║     \r\n    ╚██████╔╝██║  ██║    ██║     ██║  ██║███████╗\r\n     ╚══▀▀═╝ ╚═╝  ╚═╝    ╚═╝     ╚═╝  ╚═╝╚══════╝\r\n                                                 \r\n\r\n\r\n-------------------------------------------------------------------\r\n Copyright (c) 2020 onwards QR PAL Inc. ( https://qrpal.money )\r\n-------------------------------------------------------------------\r\n\r\n*/\r\n\r\npragma solidity 0.5.16; \r\n\r\n\r\n// Owner Handler\r\ncontract ownerShip    // Auction Contract Owner and OwherShip change\r\n{\r\n    //Global storage declaration\r\n    address public ownerWallet;\r\n    address public newOwner;\r\n    //Event defined for ownership transfered\r\n    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);\r\n\r\n    //Sets owner only on first run\r\n    constructor() public \r\n    {\r\n        //Set contract owner\r\n        ownerWallet = msg.sender;\r\n        emit OwnershipTransferredEv(address(0), msg.sender);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner \r\n    {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function acceptOwnership() external \r\n    {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferredEv(ownerWallet, newOwner);\r\n        ownerWallet = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    //This will restrict function only for owner where attached\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == ownerWallet);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ninterface usdtInterface\r\n{\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);    \r\n}\r\n\r\ninterface multiadminInterface\r\n{\r\n    function payamount(uint256 _amount) external;\r\n}\r\n\r\n\r\n\r\ncontract QRPal is ownerShip {\r\n\r\n    //public variables\r\n    uint public maxDownLimit = 2;\r\n    uint public levelLifeTime = 8640000;  // = 100 days;\r\n    uint public lastIDCount = 0;\r\n    address public usdtTokenAddress;\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint referrerID;\r\n        address[] referral;\r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n\r\n    mapping(uint => uint) public priceOfLevel;\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address) public userAddressByID;\r\n    \r\n    address public multiadminaddress;\r\n\r\n\r\n    //events\r\n    event regLevelEv(uint indexed _userID, address indexed _userWallet, uint indexed _referrerID, address _refererWallet, uint _originalReferrer, uint _time);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    event lostForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    \r\n    /**\r\n     * constructor makes all the levels upgraded of ID 1 - owner\r\n     */\r\n    constructor(address _usdtTokenAddress, address _multiadminAddress) public {\r\n        require(_usdtTokenAddress!=address(0));\r\n        require(_multiadminAddress!=address(0));\r\n        \r\n        usdtTokenAddress = _usdtTokenAddress;\r\n        multiadminaddress=_multiadminAddress;\r\n        \r\n        \r\n        priceOfLevel[1] = 20*(10**6);//usdt\r\n        priceOfLevel[2] = 30*(10**6);//usdt\r\n        priceOfLevel[3] = 60*(10**6);//usdt\r\n        priceOfLevel[4] = 180*(10**6);//usdt\r\n        priceOfLevel[5] = 880*(10**6);//usdt\r\n        priceOfLevel[6] = 6160*(10**6);//usdt\r\n        priceOfLevel[7] = 8320*(10**6);//usdt\r\n        priceOfLevel[8] = 13280*(10**6);//usdt\r\n        priceOfLevel[9] = 16240*(10**6);//usdt\r\n        priceOfLevel[10] = 29640*(10**6);//usdt\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: 0,\r\n            referral: new address[](0)\r\n        });\r\n        userInfos[multiadminaddress] = UserInfo;\r\n        userAddressByID[lastIDCount] = multiadminaddress;\r\n\r\n        for(uint i = 1; i <= 10; i++) {\r\n            userInfos[multiadminaddress].levelExpired[i] = 99999999999;\r\n            emit paidForLevelEv(multiadminaddress, address(0), i, priceOfLevel[i], now);\r\n        }\r\n        \r\n        emit regLevelEv(lastIDCount, multiadminaddress, 0, address(0), 0, now);\r\n\r\n    }\r\n    \r\n    \r\n    /**\r\n     * no incoming ether, as all process happening in USDT\r\n     */\r\n    function () external payable {\r\n        revert();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * This function register the user in the system. He has to provide referrer ID.\r\n     * User should have USDT balance as well approval of this smart contract in order for this function to work.\r\n     */\r\n    function regUser(uint _referrerID) external {\r\n        uint originalReferrerID = _referrerID;\r\n        require(!userInfos[msg.sender].joined, 'User exist');\r\n        require(_referrerID > 0 && _referrerID <= lastIDCount, 'Incorrect referrer Id');\r\n        //require(msg.value == priceOfLevel[1], 'Incorrect Value');\r\n\r\n        if(userInfos[userAddressByID[_referrerID]].referral.length >= maxDownLimit) _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: _referrerID,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[msg.sender] = UserInfo;\r\n        userAddressByID[lastIDCount] = msg.sender;\r\n\r\n        userInfos[msg.sender].levelExpired[1] = now + levelLifeTime;\r\n\r\n        userInfos[userAddressByID[_referrerID]].referral.push(msg.sender);\r\n\r\n        payForLevel(1, msg.sender);\r\n\r\n        emit regLevelEv(lastIDCount, msg.sender, _referrerID, userAddressByID[_referrerID], originalReferrerID, now);\r\n        emit levelBuyEv(msg.sender, 1, priceOfLevel[1], now);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * This function to buy any level. User has to specify level number to buy it.\r\n     * User should have USDT balance as well approval of this smart contract in order for this function to work.\r\n     */\r\n    function buyLevel(uint _level) external returns(bool) {\r\n        require(userInfos[msg.sender].joined, 'User not exist'); \r\n        require(_level > 0 && _level <= 10, 'Incorrect level');\r\n        \r\n        //owner can buy levels without paying anything\r\n        if(msg.sender!=ownerWallet){\r\n            //require(amount == priceOfLevel[_level], 'Incorrect Value');\r\n            //require(usdtInterface(usdtTokenAddress).transferFrom(msg.sender,address(this), priceOfLevel[_level]),\"usdt transfer fail\");\r\n        }\r\n        \r\n        if(_level == 1) {\r\n            userInfos[msg.sender].levelExpired[1] += levelLifeTime;\r\n        }\r\n        else {\r\n            \r\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[msg.sender].levelExpired[l] >= now, 'Buy the previous level');\r\n\r\n            if(userInfos[msg.sender].levelExpired[_level] == 0) userInfos[msg.sender].levelExpired[_level] = now + levelLifeTime;\r\n            else userInfos[msg.sender].levelExpired[_level] += levelLifeTime;\r\n        }\r\n\r\n        payForLevel(_level, msg.sender);\r\n\r\n        emit levelBuyEv(msg.sender, _level, priceOfLevel[_level], now);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Internal function to which distributes fund.\r\n     */\r\n    function payForLevel(uint _level, address _user) internal {\r\n        address referer;\r\n        address referer1;\r\n        address referer2;\r\n        address referer3;\r\n        address referer4;\r\n\r\n        if(_level == 1 || _level == 6) {\r\n            referer = userAddressByID[userInfos[_user].referrerID];\r\n        }\r\n        else if(_level == 2 || _level == 7) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer = userAddressByID[userInfos[referer1].referrerID];\r\n        }\r\n        else if(_level == 3 || _level == 8) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer = userAddressByID[userInfos[referer2].referrerID];\r\n        }\r\n        else if(_level == 4 || _level == 9) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer = userAddressByID[userInfos[referer3].referrerID];\r\n        }\r\n        else if(_level == 5 || _level == 10) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer4 = userAddressByID[userInfos[referer3].referrerID];\r\n            referer = userAddressByID[userInfos[referer4].referrerID];\r\n        }\r\n\r\n        if(!userInfos[referer].joined) referer = userAddressByID[1];\r\n\r\n        bool sent = false;\r\n        if(userInfos[referer].levelExpired[_level] >= now) {\r\n            //sent = address(uint160(referer)).transfer(priceOfLevel[_level]);\r\n            \r\n            if(referer==multiadminaddress)\r\n            {\r\n                referer=ownerWallet;\r\n            }\r\n            \r\n            sent = usdtInterface(usdtTokenAddress).transferFrom(msg.sender,referer, priceOfLevel[_level]);\r\n\r\n            if (sent) {\r\n                emit paidForLevelEv(referer, msg.sender, _level, priceOfLevel[_level], now);\r\n            }\r\n        }\r\n        if(!sent) {\r\n            emit lostForLevelEv(referer, msg.sender, _level, priceOfLevel[_level], now);\r\n            \r\n            if(userAddressByID[userInfos[referer].referrerID]==multiadminaddress)\r\n            {\r\n                multiadminInterface(multiadminaddress).payamount(priceOfLevel[_level]);\r\n                usdtInterface(usdtTokenAddress).transferFrom(msg.sender,multiadminaddress, priceOfLevel[_level]);\r\n                \r\n                emit paidForLevelEv(multiadminaddress, msg.sender, _level, priceOfLevel[_level], now);\r\n                \r\n            }\r\n            else\r\n            {\r\n                payForLevel(_level, referer);\r\n            }\r\n            \r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Find available free referrer in the matrix. It search maximum 126 positions.\r\n     * For any chances where matrix goes beyond 126 position, then UI should supply correct referrer ID, to avoid hitting this limit.\r\n     */\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        if(userInfos[_user].referral.length < maxDownLimit) return _user;\r\n\r\n        address[] memory referrals = new address[](126);\r\n        referrals[0] = userInfos[_user].referral[0];\r\n        referrals[1] = userInfos[_user].referral[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\r\n                if(i < 62) {\r\n                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\r\n                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Owner can set/change USDT contract address.\r\n     * Owner can set 0x0 address to pause this network. Owner can set correct USDT address and it should start working again.\r\n     * This contract does not hold any fund, so no scam is every possible.\r\n     */\r\n    function changeUSDTaddress(address _add) external onlyOwner{\r\n        usdtTokenAddress=_add;\r\n    }\r\n\r\n\r\n    /**\r\n     * View function to see referrals of user.\r\n     */\r\n    function viewUserReferral(address _user) external view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n\r\n    /**\r\n     * See user's level expire.\r\n     */\r\n    function viewUserLevelExpired(address _user, uint _level) external view returns(uint) {\r\n        return userInfos[_user].levelExpired[_level];\r\n    }\r\n\r\n    \r\n    /**\r\n     * assembly function which converts buytes to address.\r\n     */\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * output the array of timestamp of user last joined. This is used to see the expiration of all the levels.\r\n     */\r\n    function viewTimestampSinceJoined(address usr) external view returns(uint256[10] memory timeSinceJoined )\r\n    {\r\n        if(userInfos[usr].joined)\r\n        {\r\n            for(uint256 i=0;i<10;i++)\r\n            {\r\n                uint256 t = userInfos[usr].levelExpired[i+1];\r\n                if(t>now)\r\n                {\r\n                    timeSinceJoined[i] = (t-now);\r\n                }\r\n            }\r\n        }\r\n        return timeSinceJoined;\r\n    }\r\n    \r\n    function changeMultiadminAddress(address _add) public onlyOwner{\r\n        require(_add!=address(0));\r\n        \r\n        multiadminaddress=_add;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_multiadminAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferredEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lostForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paidForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_originalReferrer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"regLevelEv\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"changeMultiadminAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"changeUSDTaddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levelLifeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiadminaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdtTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"viewTimestampSinceJoined\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"timeSinceJoined\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"QRPal","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000f927b49629dad227bb3cc594359be17372328eda","EVMVersion":"Default","Library":"","LicenseType":"OSL-3.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1946e0bbd77629404c2eb4439cffc0457716f78ebd0d9b0bf191dc5fb0df0c75"}]}