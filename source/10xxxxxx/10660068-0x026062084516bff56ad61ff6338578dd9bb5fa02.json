{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n    /**\r\n     * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n     * checks.\r\n     *\r\n     * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n     * in bugs, because programmers usually assume that an overflow raises an\r\n     * error, which is the standard behavior in high level programming languages.\r\n     * `SafeMath` restores this intuition by reverting the transaction when an\r\n     * operation overflows.\r\n     *\r\n     * Using this library instead of the unchecked operations eliminates an entire\r\n     * class of bugs, so it's recommended to use it always.\r\n     */\r\n    library SafeMath {\r\n        /**\r\n         * @dev Returns the addition of two unsigned integers, reverting on\r\n         * overflow.\r\n         *\r\n         * Counterpart to Solidity's `+` operator.\r\n         *\r\n         * Requirements:\r\n         * - Addition cannot overflow.\r\n         */\r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            uint256 c = a + b;\r\n            require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the subtraction of two unsigned integers, reverting on\r\n         * overflow (when the result is negative).\r\n         *\r\n         * Counterpart to Solidity's `-` operator.\r\n         *\r\n         * Requirements:\r\n         * - Subtraction cannot overflow.\r\n         */\r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            return sub(a, b, \"SafeMath: subtraction overflow\");\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n         * overflow (when the result is negative).\r\n         *\r\n         * Counterpart to Solidity's `-` operator.\r\n         *\r\n         * Requirements:\r\n         * - Subtraction cannot overflow.\r\n         */\r\n        function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n            require(b <= a, errorMessage);\r\n            uint256 c = a - b;\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the multiplication of two unsigned integers, reverting on\r\n         * overflow.\r\n         *\r\n         * Counterpart to Solidity's `*` operator.\r\n         *\r\n         * Requirements:\r\n         * - Multiplication cannot overflow.\r\n         */\r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) {\r\n                return 0;\r\n            }\r\n\r\n            uint256 c = a * b;\r\n            require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the integer division of two unsigned integers. Reverts on\r\n         * division by zero. The result is rounded towards zero.\r\n         *\r\n         * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n         * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n         * uses an invalid opcode to revert (consuming all remaining gas).\r\n         *\r\n         * Requirements:\r\n         * - The divisor cannot be zero.\r\n         */\r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            return div(a, b, \"SafeMath: division by zero\");\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n         * division by zero. The result is rounded towards zero.\r\n         *\r\n         * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n         * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n         * uses an invalid opcode to revert (consuming all remaining gas).\r\n         *\r\n         * Requirements:\r\n         * - The divisor cannot be zero.\r\n         */\r\n        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n            // Solidity only automatically asserts when dividing by 0\r\n            require(b > 0, errorMessage);\r\n            uint256 c = a / b;\r\n            // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n            return c;\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n         * Reverts when dividing by zero.\r\n         *\r\n         * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n         * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n         * invalid opcode to revert (consuming all remaining gas).\r\n         *\r\n         * Requirements:\r\n         * - The divisor cannot be zero.\r\n         */\r\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            return mod(a, b, \"SafeMath: modulo by zero\");\r\n        }\r\n\r\n        /**\r\n         * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n         * Reverts with custom message when dividing by zero.\r\n         *\r\n         * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n         * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n         * invalid opcode to revert (consuming all remaining gas).\r\n         *\r\n         * Requirements:\r\n         * - The divisor cannot be zero.\r\n         */\r\n        function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n            require(b != 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n\r\n    interface ERC20 {\r\n        function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n        function approve(address spender, uint256 value) external returns (bool);\r\n        function transfer(address to, uint256 value) external returns(bool);\r\n        function allowance(address owner, address spender) external view returns (uint256);\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    }\r\n\r\n    contract Ethrim is ERC20 {\r\n        using SafeMath for uint256;\r\n        address public owner;\r\n        //1 token = 0.01 eth\r\n        uint256 public tokenCost = 0.01 ether;\r\n\r\n        string public name;\r\n        string public symbol;\r\n        uint8 public decimals;\r\n        uint256 public totalSupply = 1e9* 10**18;\r\n\r\n        mapping (address => uint256) public balances;\r\n        mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n        constructor () public {\r\n            symbol = \"ETRM\";\r\n            name = \"Ethrim\";\r\n            decimals = 18;\r\n            owner = msg.sender;\r\n            balances[owner] = totalSupply;\r\n        }\r\n        \r\n        modifier onlyOwner() {\r\n            require(msg.sender == owner, \"Only owner\");\r\n            _;\r\n        }\r\n        \r\n        /**\r\n         * @dev To change burnt Address\r\n         * @param _newOwner New owner address\r\n         */ \r\n        function changeOwner(address _newOwner) public onlyOwner returns(bool) {\r\n            require(_newOwner != address(0), \"Invalid Address\");\r\n            owner = _newOwner;\r\n            uint256 _value = balances[msg.sender];\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_newOwner] = balances[_newOwner].add(_value);\r\n            //minting total supply tokens\r\n            return true;\r\n        }\r\n\r\n        function getAmountOfToken(uint256 amount) public view returns (uint256) {\r\n            uint256 tokenValue = (amount.mul(10 ** 18)).div(tokenCost);\r\n            return tokenValue;\r\n        }\r\n\r\n        /**\r\n         * @dev Check balance of the holder\r\n         * @param _owner Token holder address\r\n         */ \r\n        function balanceOf(address _owner) public view returns (uint256) {\r\n            return balances[_owner];\r\n        }\r\n\r\n        /**\r\n         * @dev Transfer token to specified address\r\n         * @param _to Receiver address\r\n         * @param _value Amount of the tokens\r\n         */\r\n        function transfer(address _to, uint256 _value) public override returns (bool) {\r\n            require(_value <= balances[msg.sender]);\r\n            require(_to != address(0));\r\n\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * @dev Transfer tokens from one address to another\r\n         * @param _from  The holder address\r\n         * @param _to  The Receiver address\r\n         * @param _value  the amount of tokens to be transferred\r\n         */\r\n        function transferFrom(address _from, address _to, uint256 _value) public override returns (bool){\r\n            require(_value <= balances[_from]);\r\n            require(_value <= allowed[_from][msg.sender]);\r\n            require(_to != address(0));\r\n\r\n            balances[_from] = balances[_from].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        \r\n        /**\r\n         * @dev Approve respective tokens for spender\r\n         * @param _spender Spender address\r\n         * @param _value Amount of tokens to be allowed\r\n         */\r\n        function approve(address _spender, uint256 _value) public override returns (bool) {\r\n            allowed[msg.sender][_spender] = _value;\r\n            emit Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * @dev To view approved balance\r\n         * @param _owner Holder address\r\n         * @param _spender Spender address\r\n         */ \r\n        function allowance(address _owner, address _spender) public override view returns (uint256) {\r\n            return allowed[_owner][_spender];\r\n        }\r\n\r\n        function mint(uint256 _tokens) public returns (bool) {\r\n            balances[owner] = balances[owner].add(_tokens);\r\n            totalSupply = totalSupply.add(_tokens);\r\n            return true;\r\n        }\r\n\r\n    }\r\n\r\n    contract Referral {\r\n        using SafeMath for uint256;\r\n\r\n        //user structure\r\n        struct UserStruct {\r\n            bool isExist;\r\n            //unique id\r\n            uint256 id;\r\n            //person who referred unique id\r\n            uint256 referrerID;\r\n            //user current level\r\n            uint256 currentLevel;\r\n            //total eraning for user\r\n            uint256 totalEarningEth;\r\n            //persons referred\r\n            address[] referral;\r\n            //time for every level\r\n            uint256 levelExpiresAt;\r\n        }\r\n        \r\n        //address to tarnsfer eth/2\r\n        address payable public ownerAddress1;\r\n        //address to tarnsfer eth/2\r\n        address payable public ownerAddress2;\r\n        //unique id for every user\r\n        uint256 public last_uid = 0;\r\n        //token variable\r\n        Ethrim public ETRM;\r\n\r\n        //map user by their unique trust wallet address\r\n        mapping(address => UserStruct) public users;\r\n        //users trust wallet address corresponding to unique id\r\n        mapping(uint256 => address) public userAddresses;\r\n\r\n        /**\r\n         * @dev View referrals\r\n         */\r\n\r\n        function viewUserReferral(address _userAddress) external view returns (address[] memory) {\r\n            return users[_userAddress].referral;\r\n        }\r\n    }\r\n\r\n    contract ProjectEthrim {\r\n        using SafeMath for uint256;\r\n\r\n        //user structure\r\n        struct UserStruct {\r\n            bool isExist;\r\n            //unique id\r\n            uint256 id;\r\n            //person who referred unique id\r\n            uint256 referrerID;\r\n            //user current level\r\n            uint256 currentLevel;\r\n            //total eraning for user\r\n            uint256 totalEarningEth;\r\n            //persons referred\r\n            address[] referral;\r\n            //time for every level\r\n            uint256 levelExpiresAt;\r\n        }\r\n        \r\n        //levelInecntives\r\n        struct incentiveStruct {\r\n            uint256 directNumerator;\r\n            uint256 inDirectNumerator;\r\n        }\r\n        \r\n        //owner who deploys contracts\r\n        address public owner;\r\n        //address to tarnsfer eth/2\r\n        address payable public ownerAddress1;\r\n        //address to tarnsfer eth/2\r\n        address payable public ownerAddress2;\r\n        //unique id for every user\r\n        uint256 public last_uid;\r\n        //time limit for each level\r\n        uint256 public PERIOD_LENGTH = 60 days;\r\n        //no of users in each level\r\n        uint256 REFERRALS_LIMIT = 5;\r\n        //maximum level from 0 to 7\r\n        uint256 MAX_LEVEL = 7;\r\n        //precenateg denominator- 100= 10000\r\n        uint256 public percentageDenominator = 10000;\r\n        //token per level i.e,  for L1-> 1*25, L2-> 2*25\r\n        uint256 tokenPerLevel = 25;\r\n\r\n        //token variable\r\n        Ethrim public ETRM;\r\n        \r\n        //Referral contract address\r\n        Referral public OldEthrimObj;\r\n\r\n        //map user by their unique trust wallet address\r\n        mapping(address => UserStruct) public users;\r\n        //users trust wallet address corresponding to unique id\r\n        mapping(uint256 => address) public userAddresses;\r\n        //maps level incentive by level\r\n        mapping(uint256 => incentiveStruct) public LEVEL_INCENTIVE;\r\n\r\n        //check if user not registered previously\r\n        modifier userRegistered() {\r\n            require(users[msg.sender].isExist == true, \"User is not registered\");\r\n            _;\r\n        }\r\n        //check if referrer id is invalid or not\r\n        modifier validReferrerID(uint256 _referrerID) {\r\n            require( _referrerID > 0 && _referrerID <= last_uid, \"Invalid referrer ID\");\r\n            _;\r\n        }\r\n        //check if user is already registerd\r\n        modifier userNotRegistered() {\r\n            require(users[msg.sender].isExist == false, \"User is already registered\");\r\n            _;\r\n        }\r\n        //check if selected level is valid or not\r\n        modifier validLevel(uint256 _level) {\r\n            require(_level > 0 && _level <= MAX_LEVEL, \"Invalid level entered\");\r\n            _;\r\n        }\r\n        \r\n        \r\n      event RegisterUserEvent(address indexed user, address indexed referrer, uint256 time);\r\n      event BuyLevelEvent(address indexed user, uint256 indexed level, uint256 time);\r\n\r\n        constructor(address payable _ownerAddress1, address payable _ownerAddress2, address _tokenAddr, address payable _oldEthrimAddr) public {\r\n            require(_ownerAddress1 != address(0), \"Invalid owner address 1\");\r\n            require(_ownerAddress2 != address(0), \"Invalid owner address 2\");\r\n            require(_tokenAddr != address(0), \"Invalid token address\");\r\n            owner = msg.sender;\r\n            ownerAddress1 = _ownerAddress1;\r\n            ownerAddress2 = _ownerAddress2;\r\n            ETRM = Ethrim(_tokenAddr);\r\n            OldEthrimObj = Referral(_oldEthrimAddr);\r\n            OldEthrimObj = Referral(_oldEthrimAddr);\r\n            last_uid = OldEthrimObj.last_uid();\r\n            //20% = 2000\r\n            LEVEL_INCENTIVE[1].directNumerator = 2000;\r\n            //10% =1000\r\n            LEVEL_INCENTIVE[1].inDirectNumerator = 1000;\r\n            //10% = 1000\r\n            LEVEL_INCENTIVE[2].directNumerator = 1000;\r\n            //5% = 500\r\n            LEVEL_INCENTIVE[2].inDirectNumerator = 500;\r\n            //6.67% = 667\r\n            LEVEL_INCENTIVE[3].directNumerator = 667;\r\n            //3.34% = 334\r\n            LEVEL_INCENTIVE[3].inDirectNumerator = 334;\r\n            //5% = 500\r\n            LEVEL_INCENTIVE[4].directNumerator = 500;\r\n            //2.5% = 1000\r\n            LEVEL_INCENTIVE[4].inDirectNumerator = 250;\r\n            //4% = 400\r\n            LEVEL_INCENTIVE[5].directNumerator = 400;\r\n            //2% = 200\r\n            LEVEL_INCENTIVE[5].inDirectNumerator = 200;\r\n            //3.34% = 334\r\n            LEVEL_INCENTIVE[6].directNumerator = 334;\r\n            //1.7% = 170\r\n            LEVEL_INCENTIVE[6].inDirectNumerator = 170;\r\n            //2.86% = 286\r\n            LEVEL_INCENTIVE[7].directNumerator = 286;\r\n            //1.43% = 143\r\n            LEVEL_INCENTIVE[7].inDirectNumerator = 143;\r\n        }\r\n\r\n        /**\r\n         * @dev User registration\r\n         */\r\n        function registerUser(uint256 _referrerUniqueID) public payable userNotRegistered() validReferrerID(_referrerUniqueID) {\r\n            require(msg.value > 0, \"ether value is 0\");\r\n            uint256 referrerUniqueID = _referrerUniqueID;\r\n            if (users[userAddresses[referrerUniqueID]].referral.length >= REFERRALS_LIMIT) {\r\n                referrerUniqueID = users[findFreeReferrer(userAddresses[referrerUniqueID])].id;\r\n            }\r\n            last_uid = last_uid + 1;\r\n            users[msg.sender] = UserStruct({\r\n                isExist: true,\r\n                id: last_uid,\r\n                referrerID: referrerUniqueID,\r\n                currentLevel: 1,\r\n                totalEarningEth: 0,\r\n                referral: new address[](0),\r\n                levelExpiresAt: now.add(PERIOD_LENGTH)\r\n            });\r\n            userAddresses[last_uid] = msg.sender;\r\n            users[userAddresses[referrerUniqueID]].referral.push(msg.sender);\r\n\r\n            uint256 tokenAmount = getTokenAmountByLevel(1);\r\n            require(ETRM.transferFrom(owner, msg.sender, tokenAmount), \"token transfer failed\");\r\n\r\n            //get upline level\r\n            address userUpline = userAddresses[referrerUniqueID];\r\n            //transfer payment to all upline from current upline\r\n            transferLevelPayment(userUpline, 1);\r\n            emit RegisterUserEvent(msg.sender, userAddresses[referrerUniqueID], now);\r\n        }\r\n\r\n        /**\r\n         * @dev View free Referrer Address\r\n         */\r\n\r\n        function findFreeReferrer(address _userAddress) public view returns (address) {\r\n            if (users[_userAddress].referral.length < REFERRALS_LIMIT){\r\n                return _userAddress;\r\n            }\r\n\r\n            address[] memory referrals = new address[](254);\r\n            referrals[0] = users[_userAddress].referral[0];\r\n            referrals[1] = users[_userAddress].referral[1];\r\n            referrals[2] = users[_userAddress].referral[2];\r\n            referrals[3] = users[_userAddress].referral[3];\r\n            referrals[4] = users[_userAddress].referral[4];\r\n\r\n            address referrer;\r\n\r\n            for (uint256 i = 0; i < 1048576; i++) {\r\n                if (users[referrals[i]].referral.length < REFERRALS_LIMIT) {\r\n                    referrer = referrals[i];\r\n                    break;\r\n                }\r\n\r\n                 if (i >= 8191) {\r\n                    continue;\r\n                }\r\n\r\n                //adding pyramid trees\r\n                referrals[((i.add(1).mul(5))).add(i.add(0))] = users[referrals[i]].referral[0];\r\n                referrals[((i.add(1).mul(5))).add(i.add(1))] = users[referrals[i]].referral[1];\r\n                referrals[((i.add(1).mul(5))).add(i.add(2))] = users[referrals[i]].referral[2];\r\n                referrals[((i.add(1).mul(5))).add(i.add(3))] = users[referrals[i]].referral[3];\r\n                referrals[((i.add(1).mul(5))).add(i.add(4))] = users[referrals[i]].referral[4];\r\n            }\r\n\r\n            require(referrer != address(0), 'Referrer not found');\r\n            return referrer;\r\n        }\r\n\r\n        function transferLevelPayment(address _userUpline, uint256 _levelForIncentive) internal {\r\n            //ether value\r\n            uint256 etherValue = msg.value;\r\n            address uplineAddress = _userUpline;\r\n            //current upline to be sent money\r\n            uint256 uplineLevel = users[uplineAddress].currentLevel;\r\n            //upline user level expiry time\r\n            uint256 uplineUserLevelExpiry = users[uplineAddress].levelExpiresAt;\r\n            //uid\r\n            uint256 uplineUID = users[uplineAddress].id;\r\n            //incentive amount total\r\n            uint256 amountSentAsIncetives = 0;\r\n\r\n            uint256 count = 1;\r\n\r\n            while(uplineUID > 0 && count <= 7) {\r\n                address payable receiver = payable(uplineAddress);\r\n                if(count == 1) {\r\n                    uint256 uplineIncentive = (etherValue.mul(LEVEL_INCENTIVE[_levelForIncentive].directNumerator)).div(percentageDenominator);\r\n                    if(now <= uplineUserLevelExpiry && users[uplineAddress].isExist) {\r\n                        receiver.transfer(uplineIncentive);\r\n                        users[uplineAddress].totalEarningEth = users[uplineAddress].totalEarningEth.add(uplineIncentive);\r\n                    } else {\r\n                        users[uplineAddress].isExist = false;\r\n                        (ownerAddress1).transfer(uplineIncentive.div(2));\r\n                        (ownerAddress2).transfer(uplineIncentive.div(2));\r\n                    }\r\n                    amountSentAsIncetives = amountSentAsIncetives.add(uplineIncentive);\r\n                } else {\r\n                    uint256 uplineIncentive = (etherValue.mul(LEVEL_INCENTIVE[_levelForIncentive].inDirectNumerator)).div(percentageDenominator);\r\n                    if(now <= uplineUserLevelExpiry && users[uplineAddress].isExist) {\r\n                        receiver.transfer(uplineIncentive);\r\n                        users[uplineAddress].totalEarningEth = users[uplineAddress].totalEarningEth.add(uplineIncentive);\r\n                    } else {\r\n                        users[uplineAddress].isExist = false;\r\n                        (ownerAddress1).transfer(uplineIncentive.div(2));\r\n                        (ownerAddress2).transfer(uplineIncentive.div(2));\r\n                    }\r\n                    amountSentAsIncetives = amountSentAsIncetives.add(uplineIncentive);\r\n                }\r\n\r\n                //get upline level\r\n                uint256 uplineReferrerId = users[uplineAddress].referrerID;\r\n                uplineAddress = userAddresses[uplineReferrerId];\r\n                //level of upline for user \r\n                uplineLevel = users[uplineAddress].currentLevel;\r\n                uplineUID = users[uplineAddress].id;\r\n                count++;\r\n            }\r\n\r\n            uint256 remAmount = msg.value.sub(amountSentAsIncetives);\r\n            transferToOwner(remAmount);\r\n        }\r\n\r\n        function buyLevel(uint256 _level) public payable userRegistered() validLevel(_level){\r\n            require(msg.value > 0, \"ether value is 0\");\r\n            uint256 userCurrentLevel = users[msg.sender].currentLevel;\r\n            require((_level == userCurrentLevel.add(1)) || (userCurrentLevel == 7 && _level == 7), \"Invalid level upgrade value\");\r\n            users[msg.sender].levelExpiresAt = now.add(PERIOD_LENGTH);\r\n            users[msg.sender].currentLevel = _level;\r\n            uint256 tokenAmount = getTokenAmountByLevel(_level);\r\n            require(ETRM.transferFrom(owner, msg.sender, tokenAmount), \"token transfer failed\");\r\n            //get upline user address\r\n            address userUpline = userAddresses[users[msg.sender].referrerID];\r\n            //transfer payment to all upline from current upline\r\n            transferLevelPayment(userUpline, _level);\r\n            emit BuyLevelEvent(msg.sender, _level, now);\r\n        }\r\n\r\n        /**\r\n         * @dev Contract balance withdraw\r\n         */\r\n        function failSafe() public returns (bool) {\r\n            require(msg.sender == owner, \"only Owner Wallet\");\r\n            require(address(this).balance > 0, \"Insufficient balance\");\r\n            transferToOwner(address(this).balance);\r\n            return true;\r\n        }\r\n\r\n        function transferToOwner(uint256 _amount) internal{\r\n            uint256 amount = _amount.div(2);\r\n            (ownerAddress1).transfer(amount);\r\n            (ownerAddress2).transfer(amount);\r\n        }\r\n\r\n        /**\r\n         * @dev Total earned ETH\r\n         */\r\n        function getTotalEarnedEther() public view returns (uint256) {\r\n            uint256 totalEth;\r\n            for (uint256 i = 1; i <= last_uid; i++) {\r\n                totalEth = totalEth.add(users[userAddresses[i]].totalEarningEth);\r\n            }\r\n            return totalEth;\r\n        }\r\n\r\n        /**\r\n         * @dev get token amount by level i.e,  for L1-> 1*25, L2-> 2*25\r\n         */\r\n        function getTokenAmountByLevel(uint256 _level) public view returns (uint256) {\r\n            return (_level.mul(tokenPerLevel)).mul(10**18);\r\n        }\r\n\r\n        /**\r\n         * @dev View referrals\r\n         */\r\n        function viewUserReferral(address _userAddress) external view returns (address[] memory) {\r\n            return users[_userAddress].referral;\r\n        }\r\n\r\n        /**\r\n         * @dev View level expired time\r\n         */\r\n\r\n        function viewUserLevelExpired(address _userAddress) external view returns (uint256) {\r\n            return users[_userAddress].levelExpiresAt;\r\n        }\r\n\r\n        /**\r\n         * @dev Update old contract data\r\n         */ \r\n        function oldEthrimSync(uint256 limit) public {\r\n            require(address(OldEthrimObj) != address(0), \"Initialize closed\");\r\n            require(msg.sender == owner, \"Access denied\");\r\n            \r\n            uint256 oldUserId = 0;\r\n\r\n            for (uint256 i = 0; i <= limit; i++) {\r\n                UserStruct memory oldUserStruct;\r\n\r\n                address oldUser = OldEthrimObj.userAddresses(oldUserId);\r\n                (oldUserStruct.isExist, \r\n                oldUserStruct.id, \r\n                oldUserStruct.referrerID, \r\n                oldUserStruct.currentLevel,  \r\n                oldUserStruct.totalEarningEth,\r\n                oldUserStruct.levelExpiresAt) = OldEthrimObj.users(oldUser);\r\n\r\n                users[oldUser].isExist = oldUserStruct.isExist;\r\n                users[oldUser].id = oldUserId;\r\n                users[oldUser].referrerID = oldUserStruct.referrerID;\r\n                users[oldUser].levelExpiresAt = oldUserStruct.levelExpiresAt;\r\n                users[oldUser].currentLevel = oldUserStruct.currentLevel;\r\n                users[oldUser].totalEarningEth = oldUserStruct.totalEarningEth;\r\n                users[oldUser].referral = OldEthrimObj.viewUserReferral(oldUser);\r\n\r\n                userAddresses[oldUserId] = oldUser;\r\n\r\n                oldUserId++;\r\n            }\r\n        }\r\n\r\n        // fallback\r\n        fallback() external payable {\r\n            revert(\"Invalid Transaction\");\r\n        }\r\n\r\n        // receive\r\n        receive() external payable {\r\n            revert(\"Invalid Transaction\");\r\n        }\r\n    }","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_ownerAddress1\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_ownerAddress2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_oldEthrimAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"BuyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"RegisterUserEvent\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ETRM\",\"outputs\":[{\"internalType\":\"contract Ethrim\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL_INCENTIVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"directNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inDirectNumerator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OldEthrimObj\",\"outputs\":[{\"internalType\":\"contract Referral\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERIOD_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failSafe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountByLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalEarnedEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_uid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"oldEthrimSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress1\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress2\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrerUniqueID\",\"type\":\"uint256\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarningEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelExpiresAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ProjectEthrim","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e89ec6ea850c44bf3eb952824f348c243dbed0310000000000000000000000003b57ee4c40b2c273ecd6faf43048142c6859f4e3000000000000000000000000e0463631d29a8acf1f134d184ebd9db74dc682380000000000000000000000002b4b57303b6f0ce87392d605567e067021368a4a","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1f314614af2f5cb9d1b68a7e3ad6317e7cdf822f1bfd5d5251f91b01f9208127"}]}