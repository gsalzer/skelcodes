{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// \"SPDX-License-Identifier: UNLICENSED\"\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ninterface ERCIndex {\r\n    function topTokensLength() external returns (uint);\r\n    function getTokenAddressAndBalance(uint index) external returns (ERC20, uint);\r\n}\r\n\r\ncontract UniswapFactoryInterface {\r\n    // Public Variables\r\n    address public exchangeTemplate;\r\n    uint256 public tokenCount;\r\n    // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n}\r\n\r\ncontract UniswapExchangeInterface {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    // function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    // function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    // function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    // function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    // function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    // function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    // function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    // function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    // function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    // function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    // function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\ncontract MyUniswapProxy {\r\n    \r\n    // mainnet = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95\r\n    // ropsten = 0x9c83dCE8CA20E9aAF9D3efc003b2ea62aBC08351\r\n    UniswapFactoryInterface factory;\r\n\r\n    ERCIndex ercIndex;\r\n    \r\n    bool public contractSet = false;\r\n    \r\n    //ERC20 daiToken = ERC20(0x2448eE2641d78CC42D7AD76498917359D961A783); // Rinkeby\r\n    ERC20 daiToken = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); // mainnet\r\n    \r\n    constructor () public {\r\n\r\n        //factory = UniswapFactoryInterface(0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36); // rinkeby\r\n        factory = UniswapFactoryInterface(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95); // mainnet\r\n\r\n    }\r\n    \r\n    // Functions \r\n    \r\n    // make the erc index contract address a constant\r\n    function setERCIndexContract(address _address) public {\r\n        \r\n        require(!contractSet);\r\n        \r\n        ercIndex = ERCIndex(_address);\r\n        \r\n        contractSet = true;\r\n        \r\n    }\r\n    \r\n    /*\r\n    Main function, called from ERCIndex contract\r\n    It reads the balances of the ERCindex contract tokens and calculates their respective values (in DAI)\r\n    It calculates target values and return the index of the token which is most behing its target value\r\n    */\r\n    function calculateIndexValueAndNextTokenIndex(uint _numberOfTokens) public returns(uint, uint) {\r\n        \r\n        require(_numberOfTokens > 0);\r\n        \r\n        uint ethValue = 0; // sum value of all tokens\r\n        \r\n        ERC20 token; // token instance\r\n        \r\n        uint rate; // token's rate\r\n        \r\n        uint tokenBalance; // token's balakce\r\n        \r\n        uint tokenEthValue; // token's eth value (rate * balance)\r\n        \r\n        uint[] memory tokenEthValues = new uint[](_numberOfTokens);\r\n        \r\n        uint[] memory marketCaps = new uint[](_numberOfTokens);\r\n        \r\n        // caluclate value of each token in for loop - O(n)\r\n        for (uint i = 0; i < _numberOfTokens; i++) {\r\n            \r\n            (token, tokenBalance) = ercIndex.getTokenAddressAndBalance(i);\r\n            \r\n            rate = getTokenEthPrice(address(token)); // 1 token is x ETH * (10 ** 18)\r\n            \r\n            tokenEthValue = rate * tokenBalance;\r\n            \r\n            tokenEthValues[i] = tokenEthValue;\r\n            \r\n            marketCaps[i] = rate * token.totalSupply(); // of\r\n            \r\n            ethValue += tokenEthValue;\r\n            \r\n        }\r\n        \r\n        uint daiValue = daiToken.balanceOf(address(ercIndex));\r\n        \r\n        // calculate total value of ERCIndex conract (excluding dai holdings=)\r\n        daiValue += ethValue / getTokenEthPrice(address(daiToken)); // DAIEUR > 0\r\n    \r\n        // note - marketCaps and Value & token Values must all be all in the same currency (eth in this case)\r\n        return (daiValue, calculateBiggestDifference(_numberOfTokens, marketCaps, ethValue, tokenEthValues));\r\n        \r\n    }\r\n    \r\n    /*\r\n    \r\n        Logic for calculating target values for each coin and returning the coin that should be bought - O(n^2)\r\n    \r\n        Recieve market cap of each token in ETH;\r\n        From token with biggest market cap to token with smallest:\r\n        calculate target index value for token, based on number of tokens, total daiAmount in index and the number of tokens\r\n        (target is linearly decreasing with market cap order of token)\r\n        return index of token that has the biggest difference between the index's token holdings and the target balance\r\n    */\r\n    function calculateBiggestDifference(uint _numberOfTokens, uint[] memory _marketCaps, uint _indexValue, uint[] memory _tokenDaiValues) public pure returns (uint) {\r\n    \r\n        uint biggestMcap = 0;\r\n        \r\n        uint biggestMcapIndex = 0;\r\n        \r\n        uint biggestDifference = 0;\r\n        \r\n        uint biggestDifferenceIndex = 0; // index of token that has the biggest difference from the target value\r\n        \r\n        uint baseAmount = _indexValue / (_numberOfTokens * 2);\r\n        \r\n        uint j;\r\n        \r\n        // n - times / for each token ...\r\n        for (uint i = 0; i < _numberOfTokens; i++) {\r\n\r\n            // find the token with the next hightest marketCap (biggestMcapIndex)\r\n            for (j = 0; j < _numberOfTokens; j++) {\r\n                \r\n                if (_marketCaps[j] > biggestMcap) {\r\n                    \r\n                    biggestMcap = _marketCaps[j];\r\n                    \r\n                    biggestMcapIndex = j;\r\n                \r\n                }\r\n                \r\n            }\r\n            \r\n            biggestMcap = 0;\r\n            \r\n            _marketCaps[biggestMcapIndex] = 0;\r\n            \r\n            // target value is calculated with O(1) complexity\r\n            uint targetValue = baseAmount + ((baseAmount * ((_numberOfTokens * 2) - (1 + (2 * i)))) / _numberOfTokens);\r\n            \r\n            // remember which token has the biggest difference from its target value\r\n            if (_tokenDaiValues[biggestMcapIndex] < targetValue && targetValue - _tokenDaiValues[biggestMcapIndex] > biggestDifference) {\r\n                \r\n                biggestDifference = targetValue - _tokenDaiValues[biggestMcapIndex];\r\n                \r\n                biggestDifferenceIndex = biggestMcapIndex;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        return biggestDifferenceIndex;\r\n    \r\n    }\r\n    \r\n    function getTokenEthPrice(address _token) public view returns (uint) {\r\n        // rinkeby DAI: 0x2448eE2641d78CC42D7AD76498917359D961A783\r\n        // rinkeby BAT: 0xDA5B056Cfb861282B4b59d29c9B395bcC238D29B\r\n        // rinkeby MKR: 0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85\r\n        // rinkeby OMG: 0x879884c3C46A24f56089f3bBbe4d5e38dB5788C0\r\n        // rinkeby ZRX: 0xF22e3F33768354c9805d046af3C0926f27741B43\r\n\r\n        address exchange = factory.getExchange(_token);\r\n        \r\n        uint tokenReserve = ERC20(_token).balanceOf(exchange);\r\n        \r\n        uint ethReserve = exchange.balance;\r\n        \r\n        if (tokenReserve == 0) {\r\n            \r\n            return 0;\r\n            \r\n        } else {\r\n            \r\n            return (ethReserve * (10 ** 18)) / tokenReserve;\r\n        \r\n        }\r\n        \r\n    }\r\n    \r\n    // ERCIndex calls this function to execute ERC swaps\r\n    function executeSwap(ERC20 _srcToken, uint _tokensSold, address _destToken, address _destAddress) public {\r\n        \r\n        // Check that the token transferFrom has succeeded\r\n        // use sender instead of msg.sender because thiss will be called by another ERCIndex\r\n        require(_srcToken.transferFrom(msg.sender, address(this), _tokensSold));\r\n\r\n        UniswapExchangeInterface exchange = UniswapExchangeInterface(factory.getExchange(address(_srcToken)));\r\n        \r\n        require(!(address(exchange) == address(0)));\r\n        \r\n        // Mitigate ERC20 Approve front-running attack, by initially setting\r\n        // allowance to 0\r\n        require(_srcToken.approve(address(exchange), 0));\r\n\r\n        // Set the spender's token allowance to tokenQty\r\n        require(_srcToken.approve(address(exchange), _tokensSold));\r\n        \r\n        // tokens_sold: uint256,\r\n        // min_tokens_bought: uint256,\r\n        // min_eth_bought: uint256,\r\n        // deadline: uint256,\r\n        // recipient: address\r\n        // token_addr: address\r\n        exchange.tokenToTokenTransferInput(_tokensSold, 1, 1, now + 10 minutes, _destAddress, _destToken);\r\n    }\r\n    \r\n    /*\r\n    will be used when purchasing with ETH is enabled\r\n    function ethToTokenTransferInput(ERC20 _token) external payable returns (uint256 tokens_bought) {\r\n        UniswapExchangeInterface exchange = UniswapExchangeInterface(factory.getExchange(address(_token)));\r\n        // uint256 min_tokens, uint256 deadline, address recipient\r\n        return exchange.ethToTokenTransferInput.value(msg.value)(1, now + 10 minutes, msg.sender);\r\n        \r\n    }*/\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_marketCaps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_indexValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenDaiValues\",\"type\":\"uint256[]\"}],\"name\":\"calculateBiggestDifference\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"calculateIndexValueAndNextTokenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensSold\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_destToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destAddress\",\"type\":\"address\"}],\"name\":\"executeSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTokenEthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setERCIndexContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MyUniswapProxy","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ab4fe1699b09db74d9213dbbd3264bfee9a7df7ca2af898afaa5cfda39861809"}]}