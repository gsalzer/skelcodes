{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/IBalancerRegistry.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IBalancerRegistry {\r\n    event PoolAdded(\r\n        address indexed pool\r\n    );\r\n    event PoolTokenPairAdded(\r\n        address indexed pool,\r\n        address indexed fromToken,\r\n        address indexed destToken\r\n    );\r\n    event IndicesUpdated(\r\n        address indexed fromToken,\r\n        address indexed destToken,\r\n        bytes32 oldIndices,\r\n        bytes32 newIndices\r\n    );\r\n\r\n    // Get info about pool pair for 1 SLOAD\r\n    function getPairInfo(address pool, address fromToken, address destToken)\r\n        external view returns(uint256 weight1, uint256 weight2, uint256 swapFee);\r\n\r\n    // Pools\r\n    function checkAddedPools(address pool)\r\n        external view returns(bool);\r\n    function getAddedPoolsLength()\r\n        external view returns(uint256);\r\n    function getAddedPools()\r\n        external view returns(address[] memory);\r\n    function getAddedPoolsWithLimit(uint256 offset, uint256 limit)\r\n        external view returns(address[] memory result);\r\n\r\n    // Tokens\r\n    function getAllTokensLength()\r\n        external view returns(uint256);\r\n    function getAllTokens()\r\n        external view returns(address[] memory);\r\n    function getAllTokensWithLimit(uint256 offset, uint256 limit)\r\n        external view returns(address[] memory result);\r\n\r\n    // Pairs\r\n    function getPoolsLength(address fromToken, address destToken)\r\n        external view returns(uint256);\r\n    function getPools(address fromToken, address destToken)\r\n        external view returns(address[] memory);\r\n    function getPoolsWithLimit(address fromToken, address destToken, uint256 offset, uint256 limit)\r\n        external view returns(address[] memory result);\r\n    function getBestPools(address fromToken, address destToken)\r\n        external view returns(address[] memory pools);\r\n    function getBestPoolsWithLimit(address fromToken, address destToken, uint256 limit)\r\n        external view returns(address[] memory pools);\r\n\r\n    // Get swap rates\r\n    function getPoolReturn(address pool, address fromToken, address destToken, uint256 amount)\r\n        external view returns(uint256);\r\n    function getPoolReturns(address pool, address fromToken, address destToken, uint256[] calldata amounts)\r\n        external view returns(uint256[] memory result);\r\n\r\n    // Add and update registry\r\n    function addPool(address pool) external returns(uint256 listed);\r\n    function addPools(address[] calldata pools) external returns(uint256[] memory listed);\r\n    function updatedIndices(address[] calldata tokens, uint256 lengthLimit) external;\r\n}\r\n\r\n// File: contracts/IBalancerPool.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IBalancerPool {\r\n    function getFinalTokens() external view returns(address[] memory tokens);\r\n    function getDenormalizedWeight(address token) external view returns(uint256);\r\n    function getTotalDenormalizedWeight() external view returns(uint256);\r\n    function getBalance(address token) external view returns(uint256);\r\n    function getSwapFee() external view returns(uint256);\r\n}\r\n\r\n// File: contracts/BalancerLib.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary BalancerLib {\r\n    uint public constant BONE              = 10**18;\r\n\r\n    uint public constant MIN_BOUND_TOKENS  = 2;\r\n    uint public constant MAX_BOUND_TOKENS  = 8;\r\n\r\n    uint public constant MIN_FEE           = BONE / 10**6;\r\n    uint public constant MAX_FEE           = BONE / 10;\r\n    uint public constant EXIT_FEE          = 0;\r\n\r\n    uint public constant MIN_WEIGHT        = BONE;\r\n    uint public constant MAX_WEIGHT        = BONE * 50;\r\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\r\n    uint public constant MIN_BALANCE       = BONE / 10**12;\r\n\r\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\r\n\r\n    uint public constant MIN_BPOW_BASE     = 1 wei;\r\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\r\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\r\n\r\n    uint public constant MAX_IN_RATIO      = BONE / 2;\r\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\r\n\r\n    function btoi(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint a, uint n)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint base, uint exp)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint whole  = bfloor(exp);\r\n        uint remain = bsub(exp, whole);\r\n\r\n        uint wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(uint base, uint exp, uint precision)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        // term 0:\r\n        uint a     = exp;\r\n        (uint x, bool xneg)  = bsubSign(base, BONE);\r\n        uint term = BONE;\r\n        uint sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint i = 1; term >= precision; i++) {\r\n            uint bigK = i * BONE;\r\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\r\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\r\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint swapFee\r\n    )\r\n        internal pure\r\n        returns (uint spotPrice)\r\n    {\r\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint ratio = bdiv(numer, denom);\r\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\r\n        return  (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        internal pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint adjustedIn = bsub(BONE, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint foo = bpow(y, weightRatio);\r\n        uint bar = bsub(BONE, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        internal pure\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint y = bdiv(tokenBalanceOut, diff);\r\n        uint foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, BONE);\r\n        tokenAmountIn = bsub(BONE, swapFee);\r\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut         /                                              \\              //\r\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\r\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\r\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\r\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\r\n    // pS = poolSupply            \\\\                    tBi               /        /             //\r\n    // sF = swapFee                \\                                              /              //\r\n    **********************************************************************************************/\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        internal pure\r\n        returns (uint poolAmountOut)\r\n    {\r\n        // Charge the trading fee for the proportion of tokenAi\r\n        ///  which is implicitly traded to the other pool tokens.\r\n        // That proportion is (1- weightTokenIn)\r\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\r\n\r\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\r\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\r\n\r\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\r\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleInGivenPoolOut                                                                  //\r\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\r\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\r\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\r\n    // bI = balanceIn          tAi =  --------------------------------------------               //\r\n    // wI = weightIn                              /      wI  \\                                   //\r\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\r\n    // sF = swapFee                               \\      tW  /                                   //\r\n    **********************************************************************************************/\r\n    function calcSingleInGivenPoolOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountOut,\r\n        uint swapFee\r\n    )\r\n        internal pure\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\r\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\r\n        uint boo = bdiv(BONE, normalizedWeight);\r\n        uint tokenInRatio = bpow(poolRatio, boo);\r\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\r\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\r\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\r\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\r\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\r\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee\r\n    )\r\n        internal pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\r\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\r\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\r\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\r\n\r\n        // charge swap fee on the output token side\r\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolInGivenSingleOut                                                                  //\r\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\r\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\r\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\r\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\r\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\r\n    // tW = totalWeight           -------------------------------------------------------------  //\r\n    // sF = swapFee                                        ( 1 - eF )                            //\r\n    // eF = exitFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcPoolInGivenSingleOut(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        internal pure\r\n        returns (uint poolAmountIn)\r\n    {\r\n\r\n        // charge swap fee on the output token side\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\r\n        uint zoo = bsub(BONE, normalizedWeight);\r\n        uint zar = bmul(zoo, swapFee);\r\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\r\n\r\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\r\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\r\n\r\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\r\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\r\n\r\n        // charge exit fee on the pool token side\r\n        // pAi = pAiAfterExitFee/(1-exitFee)\r\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\r\n        return poolAmountIn;\r\n    }\r\n}\r\n\r\n// File: contracts/AddressSet.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary AddressSet {\r\n    struct Data {\r\n        address[] items;\r\n        mapping(address => uint) lookup;\r\n    }\r\n\r\n    function length(Data storage s) internal view returns(uint) {\r\n        return s.items.length;\r\n    }\r\n\r\n    function at(Data storage s, uint index) internal view returns(address) {\r\n        return s.items[index];\r\n    }\r\n\r\n    function contains(Data storage s, address item) internal view returns(bool) {\r\n        return s.lookup[item] != 0;\r\n    }\r\n\r\n    function add(Data storage s, address item) internal returns(bool) {\r\n        if (s.lookup[item] == 0) {\r\n            s.lookup[item] = s.items.push(item);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function remove(Data storage s, address item) internal returns(bool) {\r\n        uint index = s.lookup[item];\r\n        if (index > 0) {\r\n            if (index < s.items.length) {\r\n                address lastItem = s.items[s.items.length - 1];\r\n                s.items[index - 1] = lastItem;\r\n                s.lookup[lastItem] = index;\r\n            }\r\n            s.items.length -= 1;\r\n            delete s.lookup[item];\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BalancerRegistry.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BalancerRegistry is IBalancerRegistry {\r\n    using SafeMath for uint256;\r\n    using AddressSet for AddressSet.Data;\r\n\r\n    struct PoolPairInfo {\r\n        uint80 weight1;\r\n        uint80 weight2;\r\n        uint80 swapFee;\r\n    }\r\n\r\n    struct SortedPools {\r\n        AddressSet.Data pools;\r\n        bytes32 indices;\r\n    }\r\n\r\n    AddressSet.Data private _allTokens;\r\n    AddressSet.Data private _addedPools;\r\n    mapping(bytes32 => SortedPools) private _pools;\r\n    mapping(address => mapping(bytes32 => PoolPairInfo)) private _infos;\r\n\r\n    function checkAddedPools(address pool)\r\n        external view returns(bool)\r\n    {\r\n        return _addedPools.contains(pool);\r\n    }\r\n\r\n    function getAddedPoolsLength()\r\n        external view returns(uint256)\r\n    {\r\n        return _addedPools.items.length;\r\n    }\r\n\r\n    function getAddedPools()\r\n        external view returns(address[] memory)\r\n    {\r\n        return _addedPools.items;\r\n    }\r\n\r\n    function getAddedPoolsWithLimit(uint256 offset, uint256 limit)\r\n        external view returns(address[] memory result)\r\n    {\r\n        result = new address[](Math.min(limit, _addedPools.items.length - offset));\r\n        for (uint i = 0; i < result.length; i++) {\r\n            result[i] = _addedPools.items[offset + i];\r\n        }\r\n    }\r\n\r\n    function getAllTokensLength()\r\n        external view returns(uint256)\r\n    {\r\n        return _allTokens.items.length;\r\n    }\r\n\r\n    function getAllTokens()\r\n        external view returns(address[] memory)\r\n    {\r\n        return _allTokens.items;\r\n    }\r\n\r\n    function getAllTokensWithLimit(uint256 offset, uint256 limit)\r\n        external view returns(address[] memory result)\r\n    {\r\n        result = new address[](Math.min(limit, _allTokens.items.length - offset));\r\n        for (uint i = 0; i < result.length; i++) {\r\n            result[i] = _allTokens.items[offset + i];\r\n        }\r\n    }\r\n\r\n    function getPairInfo(address pool, address fromToken, address destToken)\r\n        external view returns(uint256 weight1, uint256 weight2, uint256 swapFee)\r\n    {\r\n        bytes32 key = _createKey(fromToken, destToken);\r\n        PoolPairInfo memory info = _infos[pool][key];\r\n        return (info.weight1, info.weight2, info.swapFee);\r\n    }\r\n\r\n    function getPoolsLength(address fromToken, address destToken)\r\n        external view returns(uint256)\r\n    {\r\n        bytes32 key = _createKey(fromToken, destToken);\r\n        return _pools[key].pools.items.length;\r\n    }\r\n\r\n    function getPools(address fromToken, address destToken)\r\n        external view returns(address[] memory)\r\n    {\r\n        bytes32 key = _createKey(fromToken, destToken);\r\n        return _pools[key].pools.items;\r\n    }\r\n\r\n    function getPoolsWithLimit(address fromToken, address destToken, uint256 offset, uint256 limit)\r\n        public view returns(address[] memory result)\r\n    {\r\n        bytes32 key = _createKey(fromToken, destToken);\r\n        result = new address[](Math.min(limit, _pools[key].pools.items.length - offset));\r\n        for (uint i = 0; i < result.length; i++) {\r\n            result[i] = _pools[key].pools.items[offset + i];\r\n        }\r\n    }\r\n\r\n    function getBestPools(address fromToken, address destToken)\r\n        external view returns(address[] memory pools)\r\n    {\r\n        return getBestPoolsWithLimit(fromToken, destToken, 32);\r\n    }\r\n\r\n    function getBestPoolsWithLimit(address fromToken, address destToken, uint256 limit)\r\n        public view returns(address[] memory pools)\r\n    {\r\n        bytes32 key = _createKey(fromToken, destToken);\r\n        bytes32 indices = _pools[key].indices;\r\n        uint256 len = 0;\r\n        while (indices[len] > 0 && len < Math.min(limit, indices.length)) {\r\n            len++;\r\n        }\r\n\r\n        pools = new address[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            uint256 index = uint256(uint8(indices[i])).sub(1);\r\n            pools[i] = _pools[key].pools.items[index];\r\n        }\r\n    }\r\n\r\n    // Swap info\r\n\r\n    function getPoolReturn(address pool, address fromToken, address destToken, uint256 amount)\r\n        external view returns(uint256)\r\n    {\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = amount;\r\n        return getPoolReturns(pool, fromToken, destToken, amounts)[0];\r\n    }\r\n\r\n    function getPoolReturns(address pool, address fromToken, address destToken, uint256[] memory amounts)\r\n        public view returns(uint256[] memory result)\r\n    {\r\n        bytes32 key = _createKey(fromToken, destToken);\r\n        PoolPairInfo memory info = _infos[pool][key];\r\n        result = new uint256[](amounts.length);\r\n        for (uint i = 0; i < amounts.length; i++) {\r\n            result[i] = BalancerLib.calcOutGivenIn(\r\n                IBalancerPool(pool).getBalance(fromToken),\r\n                uint256(fromToken < destToken ? info.weight1 : info.weight2),\r\n                IBalancerPool(pool).getBalance(destToken),\r\n                uint256(fromToken < destToken ? info.weight2 : info.weight1),\r\n                amounts[i],\r\n                info.swapFee\r\n            );\r\n        }\r\n    }\r\n\r\n    // Add and update registry\r\n\r\n    function addPool(address pool) public returns(uint256 listed) {\r\n        if (!_addedPools.add(pool)) {\r\n            return 0;\r\n        }\r\n        emit PoolAdded(pool);\r\n\r\n        address[] memory tokens = IBalancerPool(pool).getFinalTokens();\r\n        uint256[] memory weights = new uint256[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            weights[i] = IBalancerPool(pool).getDenormalizedWeight(tokens[i]);\r\n        }\r\n\r\n        uint256 swapFee = IBalancerPool(pool).getSwapFee();\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            _allTokens.add(tokens[i]);\r\n            for (uint j = i + 1; j < tokens.length; j++) {\r\n                bytes32 key = _createKey(tokens[i], tokens[j]);\r\n                if (_pools[key].pools.add(pool)) {\r\n                    _infos[pool][key] = PoolPairInfo({\r\n                        weight1: uint80(weights[tokens[i] < tokens[j] ? i : j]),\r\n                        weight2: uint80(weights[tokens[i] < tokens[j] ? j : i]),\r\n                        swapFee: uint80(swapFee)\r\n                    });\r\n\r\n                    emit PoolTokenPairAdded(\r\n                        pool,\r\n                        tokens[i] < tokens[j] ? tokens[i] : tokens[j],\r\n                        tokens[i] < tokens[j] ? tokens[j] : tokens[i]\r\n                    );\r\n                    listed++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addPools(address[] calldata pools) external returns(uint256[] memory listed) {\r\n        listed = new uint256[](pools.length);\r\n        for (uint i = 0; i < pools.length; i++) {\r\n            listed[i] = addPool(pools[i]);\r\n        }\r\n    }\r\n\r\n    function updatedIndices(address[] calldata tokens, uint256 lengthLimit) external {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            for (uint j = i + 1; j < tokens.length; j++) {\r\n                bytes32 key = _createKey(tokens[i], tokens[j]);\r\n                address[] memory pools = getPoolsWithLimit(tokens[i], tokens[j], 0, Math.min(256, lengthLimit));\r\n                uint256[] memory invs = _getInvsForPools(tokens[i], tokens[j], pools);\r\n                bytes32 indices = _buildSortIndices(invs);\r\n\r\n                if (indices != _pools[key].indices) {\r\n                    emit IndicesUpdated(\r\n                        tokens[i] < tokens[j] ? tokens[i] : tokens[j],\r\n                        tokens[i] < tokens[j] ? tokens[j] : tokens[i],\r\n                        _pools[key].indices,\r\n                        indices\r\n                    );\r\n                    _pools[key].indices = indices;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Internal\r\n\r\n    function _createKey(address token1, address token2)\r\n        internal pure returns(bytes32)\r\n    {\r\n        return bytes32(\r\n            (uint256(uint128((token1 < token2) ? token1 : token2)) << 128) |\r\n            (uint256(uint128((token1 < token2) ? token2 : token1)))\r\n        );\r\n    }\r\n\r\n    function _getInvsForPools(address fromToken, address destToken, address[] memory pools)\r\n        internal view returns(uint256[] memory invs)\r\n    {\r\n        invs = new uint256[](pools.length);\r\n        for (uint i = 0; i < pools.length; i++) {\r\n            bytes32 key = _createKey(fromToken, destToken);\r\n            PoolPairInfo memory info = _infos[pools[i]][key];\r\n            invs[i] = IBalancerPool(pools[i]).getBalance(fromToken)\r\n                .mul(IBalancerPool(pools[i]).getBalance(destToken));\r\n            invs[i] = invs[i]\r\n                .mul(info.weight1 + info.weight2).div(info.weight1)\r\n                .mul(info.weight1 + info.weight2).div(info.weight2);\r\n        }\r\n    }\r\n\r\n    function _buildSortIndices(uint256[] memory invs)\r\n        internal pure returns(bytes32)\r\n    {\r\n        uint256 result = 0;\r\n        uint256 prevInv = uint256(-1);\r\n        for (uint i = 0; i < Math.min(invs.length, 32); i++) {\r\n            uint256 bestIndex = 0;\r\n            for (uint j = 0; j < invs.length; j++) {\r\n                if ((invs[j] > invs[bestIndex] && invs[j] < prevInv) || invs[bestIndex] >= prevInv) {\r\n                    bestIndex = j;\r\n                }\r\n            }\r\n            prevInv = invs[bestIndex];\r\n            result |= (bestIndex + 1) << (248 - i * 8);\r\n        }\r\n        return bytes32(result);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldIndices\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newIndices\",\"type\":\"bytes32\"}],\"name\":\"IndicesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"PoolTokenPairAdded\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"addPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"listed\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"checkAddedPools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddedPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddedPoolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAddedPoolsWithLimit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getAllTokensWithLimit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"getBestPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getBestPoolsWithLimit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"getPairInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weight1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPoolReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"getPoolReturns\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"result\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"getPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"getPoolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getPoolsWithLimit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lengthLimit\",\"type\":\"uint256\"}],\"name\":\"updatedIndices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BalancerRegistry","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://55306058cbb69a20cfc3a17b924cd882dd00b846e5fc74aa41206365f3aa5c1c"}]}