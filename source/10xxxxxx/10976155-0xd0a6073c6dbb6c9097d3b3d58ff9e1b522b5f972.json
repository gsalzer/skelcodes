{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nlibrary StringUtils {\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\n    /// @return a negative number if `_a` is smaller, zero if they are equal\n    /// and a positive numbe if `_b` is smaller.\n    function compare(string memory _a, string memory _b)\n        internal\n        pure\n        returns (int256)\n    {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint256 minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n        for (uint256 i = 0; i < minLength; i++)\n            if (a[i] < b[i]) return -1;\n            else if (a[i] > b[i]) return 1;\n        if (a.length < b.length) return -1;\n        else if (a.length > b.length) return 1;\n        else return 0;\n    }\n\n    /// @dev Compares two strings and returns true iff they are equal.\n    function equal(string memory _a, string memory _b)\n        internal\n        pure\n        returns (bool)\n    {\n        return compare(_a, _b) == 0;\n    }\n\n    /// @dev Finds the index of the first occurrence of _needle in _haystack\n    function indexOf(string memory _haystack, string memory _needle)\n        internal\n        pure\n        returns (int256)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if (h.length < 1 || n.length < 1 || (n.length > h.length)) return -1;\n        else if (h.length > (2**128 - 1))\n            // since we have to be able to return -1 (if the char isn't found or input error), this function must return an \"int\" type with a max length of (2^128 - 1)\n            return -1;\n        else {\n            uint256 subindex = 0;\n            for (uint256 i = 0; i < h.length; i++) {\n                if (h[i] == n[0]) // found the first char of b\n                {\n                    subindex = 1;\n                    while (\n                        subindex < n.length &&\n                        (i + subindex) < h.length &&\n                        h[i + subindex] == n[subindex] // search until the chars don't match or until we reach the end of a or b\n                    ) {\n                        subindex++;\n                    }\n                    if (subindex == n.length) return int256(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    // function toBytes(address a) \n    //    internal\n    //     pure\n    //     returns (bytes memory) {\n    // return abi.encodePacked(a);\n    // }\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account's access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\ncontract TokenismAdminWhitelist is Context {\n    using Roles for Roles.Role;\n    Roles.Role private _managerWhitelisteds;\n\n    //  Add multiple admins option\n     mapping(address => string) public admins;\n     address superAdmin;\n     address feeAddress;\n\n     //  Setting FeeStatus and fee Percent by Tokenism\n    //  uint8 feeStatus;\n    //  uint8 feePercent;\n    bool public accreditationCheck = true;\n\n    struct whitelistInfoManager {\n        address wallet;\n        string role;\n        bool valid;\n    }\n\n    mapping(address => whitelistInfoManager) whitelistManagers;\n\n     constructor() public {\n        // admin = _msgSender();\n        \n        admins[_msgSender()] = \"superAdmin\";\n        superAdmin = msg.sender;\n       \n    }\n    function addSuperAdmin(address _superAdmin) public {\n\n         require(msg.sender == superAdmin, \"Only super admin can add admin\");\n         admins[_superAdmin] = \"superAdmin\";\n         admins[superAdmin] = \"dev\";\n         superAdmin = _superAdmin;\n        \n    }\n\n    modifier onlyAdmin() {\n       require(\n          StringUtils.equal(admins[_msgSender()], \"superAdmin\") ||\n          StringUtils.equal(admins[_msgSender()], \"dev\") ||\n          StringUtils.equal(admins[_msgSender()], \"fee\") ||\n          StringUtils.equal(admins[_msgSender()], \"admin\"),\n                \"Only admin is allowed\"\n        );\n         _;\n    }\n\n    modifier onlyManager() {\n    require(\n            isWhitelistedManager(_msgSender()) || \n             StringUtils.equal(admins[_msgSender()], \"superAdmin\") ||\n             StringUtils.equal(admins[_msgSender()], \"dev\") ||\n             StringUtils.equal(admins[_msgSender()], \"fee\") ||\n             StringUtils.equal(admins[_msgSender()], \"admin\"),\n            \"TokenismAdminWhitelist: caller does not have the Manager role\"\n        );\n        _;\n    }\n    // Update Accredential Status\n    function updateAccreditationCheck(bool status) public onlyManager {\n        accreditationCheck = status;\n    }\n\n    // Roles\n    function addWhitelistedManager(address _wallet, string memory _role)\n        public\n        onlyAdmin\n    {\n        require(\n            StringUtils.equal(_role, \"finance\") ||\n            StringUtils.equal(_role, \"signer\") ||\n                StringUtils.equal(_role, \"assets\"),\n            \"TokenismAdminWhitelist: caller does not have the Manager role\"\n        );\n\n        whitelistInfoManager storage newManager = whitelistManagers[_wallet];\n\n        _managerWhitelisteds.add(_wallet);\n        newManager.wallet = _wallet;\n        newManager.role = _role;\n        newManager.valid = true;\n    }\n\n    function getManagerRole(address _wallet)\n        public\n        view\n        returns (string memory)\n    {\n        whitelistInfoManager storage m = whitelistManagers[_wallet];\n        return m.role;\n    }\n\n    function updateRoleManager(address _wallet, string memory _role)\n        public\n        onlyAdmin\n    {\n         require(\n            StringUtils.equal(_role, \"finance\") ||\n            StringUtils.equal(_role, \"signer\") ||\n                StringUtils.equal(_role, \"assets\"),\n            \"TokenismAdminWhitelist: Invalid  Manager role\"\n        );\n        whitelistInfoManager storage m = whitelistManagers[_wallet];\n        m.role = _role;\n    }\n\n    function isWhitelistedManager(address _wallet) public view returns (bool) {\n        whitelistInfoManager memory m = whitelistManagers[_wallet];\n\n        if (  StringUtils.equal(admins[_wallet], \"superAdmin\") ||\n              StringUtils.equal(admins[_wallet], \"dev\") ||\n              StringUtils.equal(admins[_wallet], \"fee\") ||\n             StringUtils.equal(admins[_wallet], \"admin\")) return true;\n        else if (!m.valid) return false;\n        else return true;\n    }\n\n    // Only Super Admin\n    function removeWhitelistedManager(address _wallet) public onlyAdmin {\n        _managerWhitelisteds.remove(_wallet);\n        whitelistInfoManager storage m = whitelistManagers[_wallet];\n        m.valid = false;\n    }\n\n    function transferOwnership(address  _newAdmin)\n        public\n        returns (bool)\n    {\n        // admin = _newAdmin;\n        require(_msgSender() == superAdmin, \"Only super admin can add admin\");\n         admins[_newAdmin] = \"superAdmin\";\n         admins[superAdmin] = \"\";\n         superAdmin = _newAdmin;\n\n        return true;\n    }\n    function addAdmin(address  _newAdmin, string memory _role)\n    public\n    onlyAdmin\n    returns (bool)\n    {\n        \n    require(_msgSender() == superAdmin || Address.isContract(_newAdmin) , \"Only super admin can add admin\");\n    require(\n              StringUtils.equal(_role, \"dev\") ||\n              StringUtils.equal(_role, \"fee\") ||\n              StringUtils.equal(_role, \"admin\"),\n             \"undefind admin role\"\n             );\n        admins[_newAdmin] = _role;\n        return true;\n    }\n\n   // Function Add Fee Address \n   function addFeeAddress(address _feeAddress) public {\n       require(_msgSender() == superAdmin, \"Only super admin can add Fee Address\");\n      feeAddress = _feeAddress;\n   }\n   function getFeeAddress()public view returns(address){\n       return feeAddress;\n   } \n\n    // // Fee On off functionality\n    // function setFeeStatus(uint8 option) public returns(bool){ // Fee option must be 0, 1\n    //     require(msg.sender == superAdmin, \"Only SuperAdmin on off fee\");\n    //     require(option == 1 || option == 0, \"Wrong option call only 1 for on and 0 for off\");\n    //     require(feePercent > 0, \"addPlatformFee! You must have set platform fee to on fee\");\n    //     feeStatus = option;\n    //     return true;\n    // }\n    // // Get Fee Status\n    //     return feeStatus;\n    // }\n    // // Add Fee Percent or change Fee Percentage on Tokenism Platform\n    // function addPlatformFee(uint8 _fee)public returns(bool){\n    //     require(msg.sender == superAdmin, \"Only SuperAmin change Platform Fee\");\n    //     require(_fee > 0 && _fee < 100, \"Wrong Percentage!  Fee must be greater 0 and less than 100\");\n    //     feePercent = _fee;\n    //     return true;\n\n    // }\n    //  return feePercent;\n    // }\n    function isAdmin(address _calle)public view returns(bool) {\n        if(StringUtils.equal(admins[_calle] , \"superAdmin\") ||\n             StringUtils.equal(admins[_calle] , \"dev\") ||\n             StringUtils.equal(admins[_calle] , \"fee\") ||\n             StringUtils.equal(admins[_calle] , \"admin\")){\n                 return true;\n             }\n             return false;\n        //  return admins[_calle];   \n    }\n    function isSuperAdmin(address _calle) public view returns(bool){\n        if(StringUtils.equal(admins[_calle] , \"superAdmin\")){\n            return true;\n        }\n        return false;\n    }\n   function isManager(address _calle)public returns(bool) {\n        whitelistInfoManager memory m = whitelistManagers[_calle];\n        return m.valid;\n   }\n}\n\ncontract TokenismWhitelist is Context, TokenismAdminWhitelist {\n    using Roles for Roles.Role;\n    Roles.Role private _userWhitelisteds;\n    mapping(string=> bool) public symbolsDef;\n\n    struct  whitelistInfo {\n        bool valid;\n        address wallet;\n        bool kycVerified;\n        bool accredationVerified;\n        uint256 accredationExpiry;\n        uint256 taxWithholding;\n        string  userType;\n        bool suspend;\n    }\n    mapping(address => whitelistInfo) public whitelistUsers;\n    address[] public userList;\n\n    // userTypes = Basic || Premium\n    function addWhitelistedUser(address _wallet, bool _kycVerified, bool _accredationVerified, uint256 _accredationExpiry) public onlyManager {\n        if(_accredationVerified)\n            require(_accredationExpiry >= block.timestamp, \"accredationExpiry: Accredation Expiry time is before current time\");\n\n        _userWhitelisteds.add(_wallet);\n        whitelistInfo storage newUser = whitelistUsers[_wallet];\n\n        newUser.valid = true;\n        newUser.suspend = false;\n        newUser.taxWithholding = 0;\n\n        newUser.wallet = _wallet;\n        newUser.kycVerified = _kycVerified;\n        newUser.accredationExpiry = _accredationExpiry;\n        newUser.accredationVerified = _accredationVerified;\n        newUser.userType = \"Basic\";\n        // maintain whitelist user list\n        userList.push(_wallet);\n    }\n\n    function getWhitelistedUser(address _wallet) public view returns (address, bool, bool, uint256, uint256){\n        whitelistInfo memory u = whitelistUsers[_wallet];\n        return (u.wallet, u.kycVerified, u.accredationExpiry >= block.timestamp, u.accredationExpiry, u.taxWithholding);\n    }\n\n    function updateKycWhitelistedUser(address _wallet, bool _kycVerified) public onlyManager {\n        whitelistInfo storage u = whitelistUsers[_wallet];\n        u.kycVerified = _kycVerified;\n    }\n\n    function updateAccredationWhitelistedUser(address _wallet, uint256 _accredationExpiry) public onlyManager {\n        require(_accredationExpiry >= block.timestamp, \"accredationExpiry: Accredation Expiry time is before current time\");\n\n        whitelistInfo storage u = whitelistUsers[_wallet];\n        u.accredationExpiry = _accredationExpiry;\n    }\n\n    function updateTaxWhitelistedUser(address _wallet, uint256 _taxWithholding) public onlyManager {\n        whitelistInfo storage u = whitelistUsers[_wallet];\n        u.taxWithholding = _taxWithholding;\n    }\n\n    function suspendUser(address _wallet) public onlyManager {\n        whitelistInfo storage u = whitelistUsers[_wallet];\n        u.suspend = true;\n    }\n\n    function activeUser(address _wallet) public onlyManager {\n        whitelistInfo storage u = whitelistUsers[_wallet];\n        u.suspend = false;\n    }\n\n    function updateUserType(address _wallet, string memory _userType) public onlyManager {\n        require(\n            StringUtils.equal(_userType , 'Basic') || StringUtils.equal(_userType , 'Premium')\n        , \"Please Enter Valid User Type\");\n        whitelistInfo storage u = whitelistUsers[_wallet];\n        u.userType = _userType;\n    }\n\n// Check user status\n    function isWhitelistedUser(address wallet) public view returns (uint) {\n        whitelistInfo storage u = whitelistUsers[wallet];\n    whitelistInfoManager memory m = whitelistManagers[wallet];\n\n       /* Wallet is Super Admin */\n      if(StringUtils.equal(admins[wallet], \"superAdmin\")) return 100;\n\n       /* Wallet is Fee Admin */\n        if(StringUtils.equal(admins[wallet], \"fee\"))   return 110;\n\n         /* Wallet is Dev Admin */\n        if(StringUtils.equal(admins[wallet], \"dev\"))   return 111;\n\n         /* Wallet is Simple Admin */\n        if(StringUtils.equal(admins[wallet], \"admin\")) return 112;\n\n        /* Wallet is Manager Finance */\n        if(StringUtils.equal(m.role, \"finance\"))     return 120;\n\n         /* Wallet is Manager asset */\n         if(StringUtils.equal(m.role, \"assets\"))  return 121;\n\n           /* Wallet is Manager asset */\n         if(StringUtils.equal(m.role, \"signer\"))  return 122;\n         \n        // /* Any type of Manager */\n        // if(isWhitelistedManager(wallet)) return 200;\n\n        /* Wallet is not Added */\n        else if(!u.valid) return 404;\n\n        /* If User is Suspendid */\n        else if(u.suspend) return 401;\n\n        /* Wallet KYC Expired */\n        else if(!u.kycVerified) return 400;\n\n        /* If Accredation check is false then Send 200 */\n        else if(!accreditationCheck) return 200;\n\n        /* Wallet AML Expired */\n        else if(u.accredationExpiry <= block.timestamp)\n            return 201;\n\n        /* Wallet is Whitelisted */\n        else return 200;\n    }\n\n    function removeWhitelistedUser(address _wallet) public onlyManager {\n        _userWhitelisteds.remove(_wallet);\n        whitelistInfo storage u = whitelistUsers[_wallet];\n        u.valid = false;\n    }\n\n    /* Symbols Deployed Add to Contract */\n    function addSymbols(string calldata _symbols)\n        external\n        // onlyManager\n        returns(bool){\n            if(symbolsDef[_symbols] == true)\n                return false;\n            else{\n                symbolsDef[_symbols]=true;\n                return true;\n            }\n        }\n    // On destroy Symbol Removed\n    function removeSymbols(string calldata _symbols)\n        external\n        // onlyManager\n        returns(bool){\n            if(symbolsDef[_symbols] == true)\n            symbolsDef[_symbols] = false;\n            return true;\n\n\n        }\n\n    function closeTokenismWhitelist() public {\n      require(StringUtils.equal(admins[_msgSender()], \"superAdmin\"), \"only superAdmin can destroy Contract\");\n    selfdestruct(msg.sender);\n    } \n\n\n    function storedAllData()public view onlyAdmin returns(\n        address[] memory _userList,\n        bool[] memory _validity,\n        bool[] memory _kycVery,\n        bool[] memory _accredationVery,\n        uint256[] memory _accredationExpir,\n        uint256[] memory _taxWithHold,\n        uint256[] memory _userTypes\n        )\n        {\n\n            uint size = userList.length;\n\n        bool[] memory validity = new bool[](size);\n        bool[] memory kycVery = new bool[](size);\n        bool[] memory accredationVery = new bool[](size);\n        uint256[] memory accredationExpir = new uint256[](size);\n        uint256[] memory taxWithHold = new uint256[](size);\n        uint256[] memory userTypes = new uint256[](size);\n            uint i;\n            for(i=0; i<userList.length; i++){\n                        if(whitelistUsers[userList[i]].valid){\n                            validity[i]= true;\n                        }\n                        else{\n                        validity[i]=false;   \n                        }\n                    if(whitelistUsers[userList[i]].kycVerified)\n                    {\n                    kycVery[i] = true;\n                    }\n                    else{\n                    kycVery[i] = false;\n                    }\n                    if(whitelistUsers[userList[i]].accredationVerified)\n                    {\n                    accredationVery[i] = true;\n                    }\n                    else{\n                    accredationVery[i] = false;\n                    }\n                    accredationExpir[i] = (whitelistUsers[userList[i]].accredationExpiry);\n                    taxWithHold[i] = (whitelistUsers[userList[i]].taxWithholding);\n                    if(StringUtils.equal(whitelistUsers[userList[i]].userType, \"Basic\")){\n                        userTypes[i] = 20; \n                    }\n                    else\n                    userTypes[i] = 100;\n            }\n            return (userList,validity, kycVery,accredationVery, accredationExpir, taxWithHold,userTypes);\n        }\n\n\n\n    function userType(address _caller) public view returns(bool){\n        if(StringUtils.equal(whitelistUsers[_caller].userType, \"Premium\"))\n        return true;\n        return false;\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"activeUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeTokenismWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getManagerRole\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"suspendUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_calle\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"updateAccreditationCheck\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storedAllData\",\"outputs\":[{\"name\":\"_userList\",\"type\":\"address[]\"},{\"name\":\"_validity\",\"type\":\"bool[]\"},{\"name\":\"_kycVery\",\"type\":\"bool[]\"},{\"name\":\"_accredationVery\",\"type\":\"bool[]\"},{\"name\":\"_accredationExpir\",\"type\":\"uint256[]\"},{\"name\":\"_taxWithHold\",\"type\":\"uint256[]\"},{\"name\":\"_userTypes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbols\",\"type\":\"string\"}],\"name\":\"addSymbols\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getWhitelistedUser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_accredationExpiry\",\"type\":\"uint256\"}],\"name\":\"updateAccredationWhitelistedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"string\"}],\"name\":\"symbolsDef\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_taxWithholding\",\"type\":\"uint256\"}],\"name\":\"updateTaxWhitelistedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistUsers\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"kycVerified\",\"type\":\"bool\"},{\"name\":\"accredationVerified\",\"type\":\"bool\"},{\"name\":\"accredationExpiry\",\"type\":\"uint256\"},{\"name\":\"taxWithholding\",\"type\":\"uint256\"},{\"name\":\"userType\",\"type\":\"string\"},{\"name\":\"suspend\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_kycVerified\",\"type\":\"bool\"},{\"name\":\"_accredationVerified\",\"type\":\"bool\"},{\"name\":\"_accredationExpiry\",\"type\":\"uint256\"}],\"name\":\"addWhitelistedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_userType\",\"type\":\"string\"}],\"name\":\"updateUserType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accreditationCheck\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbols\",\"type\":\"string\"}],\"name\":\"removeSymbols\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"addFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_kycVerified\",\"type\":\"bool\"}],\"name\":\"updateKycWhitelistedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"removeWhitelistedManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_superAdmin\",\"type\":\"address\"}],\"name\":\"addSuperAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"removeWhitelistedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"userType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"isWhitelistedManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"addAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isWhitelistedUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_calle\",\"type\":\"address\"}],\"name\":\"isSuperAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"updateRoleManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_calle\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"addWhitelistedManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenismWhitelist","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}