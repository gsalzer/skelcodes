{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) \r\n            return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n\r\n    int256 constant private INT256_MIN = -2^255;\r\n\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        if (a == 0) \r\n            return 0;\r\n        int256 c = a * b;\r\n        require(c / a == b && (a != -1 || b != INT256_MIN));\r\n        return c;\r\n    }\r\n\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0 && b != -1 && a != INT256_MIN);\r\n        int256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal _balances;\r\n    mapping (address => mapping (address => uint256)) internal _allowed;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    uint256 internal _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return A uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param owner address The address which owns the funds.\r\n    * @param spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token to a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param spender The address which will spend the funds.\r\n    * @param value The amount of tokens to be spent.\r\n    */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another.\r\n    * Note that while this function emits an Approval event, this is not required as per the specification,\r\n    * and other compliant implementations may not emit the event.\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20Mintable is ERC20 {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    function _mint(address to, uint256 amount) internal {\r\n        _balances[to] = _balances[to].add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        require(_totalSupply <= 10000e18, \"pool is full\");\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal {\r\n        _balances[from] = _balances[from].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\ncontract CERC20 is ERC20 {\r\n    function borrow(uint256) external returns (uint256);\r\n    function borrowBalanceCurrent(address) external returns (uint256);\r\n    function repayBorrow(uint256) external returns (uint256);\r\n    function mint(uint256) external returns (uint256);\r\n    function redeemUnderlying(uint256) external returns (uint256);\r\n    function balanceOfUnderlying(address) external returns (uint256);\r\n}\r\n\r\n\r\ninterface Comptroller {\r\n    function enterMarkets(address[] calldata) external returns (uint256[] memory);\r\n}\r\n\r\ncontract UniswapV2Router02 {\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n}\r\n\r\ncontract bhsAlpha is ERC20Mintable {\r\n    using SafeMath for *;\r\n\r\n    /***********************************|\r\n    |        Variables && Events        |\r\n    |__________________________________*/\r\n\r\n    string public alarm = \"ALPHA VERSION FOR DEVELOPER TESTING, DO NOT USE.\";\r\n\r\n    Comptroller constant comptroller = Comptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\r\n    UniswapV2Router02 constant uniswap = UniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n    ERC20 constant Comp = ERC20(0xc00e94Cb662C3520282E6f5717214004A7f26888);\r\n    ERC20 constant Dai = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n    ERC20 constant USDC = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    CERC20 constant cDai = CERC20(0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643);\r\n    CERC20 constant cUSDC = CERC20(0x39AA39c021dfbaE8faC545936693aC917d5E7563);\r\n\r\n    event Purchases(address indexed buyer, address indexed buy_token, uint256 inputs, uint256 outputs);\r\n    event AddLiquidity(address indexed provider, uint256 DAIAmount, uint256 USDCAmount);\r\n    event RemoveLiquidity(address indexed provider, uint256 DAIAmount, uint256 USDCAmount);\r\n\r\n    /***********************************|\r\n    |            Constsructor           |\r\n    |__________________________________*/\r\n\r\n    constructor() public {\r\n        symbol = \"BHSc$\";\r\n        name = \"BlackHoleSwap-Compound DAI/USDC v1\";\r\n        decimals = 18;\r\n\r\n        Dai.approve(address(cDai), uint256(-1));\r\n        USDC.approve(address(cUSDC), uint256(-1));\r\n        Comp.approve(address(uniswap), uint256(-1));\r\n\r\n        address[] memory cTokens = new address[](2);\r\n        cTokens[0] = address(cDai);\r\n        cTokens[1] = address(cUSDC);\r\n        uint256[] memory errors = comptroller.enterMarkets(cTokens);\r\n        require(errors[0] == 0 && errors[1] == 0, \"Comptroller.enterMarkets failed.\");\r\n\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /***********************************|\r\n    |        Governmence & Params       |\r\n    |__________________________________*/\r\n\r\n    uint256 public fee = 0.99985e18;\r\n    uint256 public protocolFee = 0;\r\n    uint256 public constant amplifier = 0.75e18;\r\n\r\n    address private admin;\r\n    address private vault;\r\n\r\n    function setAdmin(address _admin) external {\r\n        require(msg.sender == admin);\r\n        admin = _admin;\r\n    }\r\n\r\n    function setParams(uint256 _fee, uint256 _protocolFee) external {\r\n        require(msg.sender == admin);\r\n        require(_fee < 1e18 && _fee >= 0.99e18); //0 < fee <= 1%\r\n        if(_protocolFee > 0)\r\n            require(uint256(1e18).sub(_fee).div(_protocolFee) >= 3); //protocolFee < 33.3% fee\r\n        fee = _fee;\r\n        protocolFee = _protocolFee;\r\n    }\r\n\r\n    function setVault(address _vault) external {\r\n        require(msg.sender == admin);\r\n        vault = _vault;\r\n    }\r\n\r\n    /***********************************|\r\n    |         Getter Functions          |\r\n    |__________________________________*/\r\n\r\n    function getDaiBalance() public returns (uint256, uint256) {\r\n        if (cDai.balanceOf(address(this)) <= 10)\r\n            return (0, cDai.borrowBalanceCurrent(address(this)));\r\n        else\r\n            return (cDai.balanceOfUnderlying(address(this)), cDai.borrowBalanceCurrent(address(this)));\r\n    }\r\n\r\n    function getUSDCBalance() public returns (uint256, uint256) {\r\n        if (cUSDC.balanceOf(address(this)) <= 10)\r\n            return (0, cUSDC.borrowBalanceCurrent(address(this)).mul(rate()) );\r\n        else\r\n            return (cUSDC.balanceOfUnderlying(address(this)).mul(rate()), cUSDC.borrowBalanceCurrent(address(this)).mul(rate()));\r\n    }\r\n\r\n    // DAI + USDC\r\n    function S() public returns (uint256) {\r\n        (uint256 a, uint256 b) = getDaiBalance();\r\n        (uint256 c, uint256 d) = getUSDCBalance();\r\n        return(a.add(c).sub(b).sub(d));\r\n    }\r\n\r\n    function F(int256 _x, int256 x, int256 y) internal pure returns (int256 _y) {\r\n        int256 k;\r\n        {\r\n            // u = x + ay, v = y + ax\r\n            int256 u = x.add(y.mul(int256(amplifier)).div(1e18));\r\n            int256 v = y.add(x.mul(int256(amplifier)).div(1e18));\r\n            k = u.mul(v); // k = u * v\r\n            k = k.mul(1e18).div(int256(amplifier)).sub(_x.mul(_x)); // k = k/a - x^2\r\n        }\r\n        \r\n        _y = y != 0 ? y : 1;\r\n        int256 cst = int256(amplifier).add(1e36.div(int256(amplifier))); // a + 1/a\r\n        int256 b = _x.mul(-cst).div(1e18); //-b\r\n\r\n        for(uint256 j = 0; j < 100; j++) {\r\n            int256 __y = _y;\r\n            _y = k.div(_y).add(b); // y = (k/a - x^2) / y - b\r\n            _y = k.div(_y).add(b).add(_y).div(2); // y = ( (k/a - x^2) / y - b + y ) / 2\r\n            if(__y - _y < 10 && __y - _y > -10) break;\r\n        }\r\n\r\n        if(_y < b.div(2)) // if y < -b/2, then y = -b - y\r\n            _y = b.sub(_y);\r\n    }\r\n\r\n    function getInputPrice(uint256 input, uint256 a, uint256 b, uint256 c, uint256 d) public pure returns (uint256) {\r\n        int256 x = int256(a).sub(int256(b));\r\n        int256 y = int256(c).sub(int256(d));\r\n        int256 _x = x.add(int256(input));\r\n\r\n        int256 _y = F(_x, x, y);\r\n\r\n        return uint256(y.sub(_y));\r\n    }\r\n\r\n    function getOutputPrice(uint256 output, uint256 a, uint256 b, uint256 c, uint256 d) public pure returns (uint256) {\r\n        int256 x = int256(a).sub(int256(b));\r\n        int256 y = int256(c).sub(int256(d));\r\n        int256 _y = y.sub(int256(output));\r\n\r\n        int256 _x = F(_y, y, x);\r\n\r\n        return uint256(_x.sub(x));\r\n    }\r\n\r\n    function rate() public pure returns (uint256) {\r\n        return 1e12;\r\n    }\r\n\r\n    /***********************************|\r\n    |        Exchange Functions         |\r\n    |__________________________________*/\r\n    \r\n    function calcFee(uint256 input, uint256 a, uint256 b, uint256 c, uint256 d) internal {\r\n        if(protocolFee > 0) {\r\n            uint256 _fee = input.mul(protocolFee).div(1e18).mul(_totalSupply).div( a.add(c).sub(b).sub(d) );\r\n            _mint(vault, _fee);\r\n        }\r\n    }\r\n\r\n    function dai2usdcIn(uint256 input, uint256 min_output, uint256 deadline) public returns (uint256) {\r\n        require(block.timestamp <= deadline, \"EXPIRED\");\r\n        (uint256 a, uint256 b) = getDaiBalance();\r\n        (uint256 c, uint256 d) = getUSDCBalance();\r\n\r\n        uint256 output = getInputPrice(input.mul(fee).div(1e18), a, b, c, d);\r\n        securityCheck(input, output, a, b, c, d);\r\n        output = output.div(rate());\r\n        require(output >= min_output, \"SLIPPAGE_DETECTED\");\r\n\r\n        calcFee(input, a, b, c, d);\r\n\r\n        doTransferIn(Dai, cDai, b, msg.sender, input);\r\n        doTransferOut(USDC, cUSDC, c.div(rate()), msg.sender, output);\r\n\r\n        emit Purchases(msg.sender, address(USDC), input, output);\r\n\r\n        return output;\r\n    }\r\n    \r\n    function usdc2daiIn(uint256 input, uint256 min_output, uint256 deadline) public returns (uint256) {\r\n        require(block.timestamp <= deadline, \"EXPIRED\");\r\n        (uint256 a, uint256 b) = getDaiBalance();\r\n        (uint256 c, uint256 d) = getUSDCBalance();\r\n\r\n        uint256 output = getInputPrice(input.mul(fee).div(1e18).mul(rate()), c, d, a, b);\r\n        securityCheck(input, output, c, d, a, b);\r\n        require(output >= min_output, \"SLIPPAGE_DETECTED\");\r\n        \r\n        calcFee(input.mul(rate()), a, b, c, d);\r\n        \r\n        doTransferIn(USDC, cUSDC, d.div(rate()), msg.sender, input);\r\n        doTransferOut(Dai, cDai, a, msg.sender, output);\r\n\r\n        emit Purchases(msg.sender, address(Dai), input, output);\r\n\r\n        return output;\r\n    }\r\n\r\n    function dai2usdcOut(uint256 max_input, uint256 output, uint256 deadline) public returns (uint256) {\r\n        require(block.timestamp <= deadline, \"EXPIRED\");\r\n        (uint256 a, uint256 b) = getDaiBalance();\r\n        (uint256 c, uint256 d) = getUSDCBalance();\r\n\r\n        uint256 input = getOutputPrice(output.mul(rate()), a, b, c, d);\r\n        securityCheck(input, output, a, b, c, d);\r\n        input = input.mul(1e18).div(fee);\r\n        require(input <= max_input, \"SLIPPAGE_DETECTED\");\r\n\r\n        calcFee(input, a, b, c, d);\r\n\r\n        doTransferIn(Dai, cDai, b, msg.sender, input);\r\n        doTransferOut(USDC, cUSDC, c.div(rate()), msg.sender, output);\r\n\r\n        emit Purchases(msg.sender, address(USDC), input, output);\r\n\r\n        return input;\r\n    }\r\n    \r\n    function usdc2daiOut(uint256 max_input, uint256 output, uint256 deadline) public returns (uint256) {\r\n        require(block.timestamp <= deadline, \"EXPIRED\");\r\n        (uint256 a, uint256 b) = getDaiBalance();\r\n        (uint256 c, uint256 d) = getUSDCBalance();\r\n\r\n        uint256 input = getOutputPrice(output, c, d, a, b);\r\n        securityCheck(input, output, c, d, a, b);\r\n        input = input.mul(1e18).div(fee).div(rate());\r\n        require(input <= max_input, \"SLIPPAGE_DETECTED\");\r\n\r\n        calcFee(input.mul(rate()), a, b, c, d);\r\n\r\n        doTransferIn(USDC, cUSDC, d.div(rate()), msg.sender, input);\r\n        doTransferOut(Dai, cDai, a, msg.sender, output);\r\n\r\n        emit Purchases(msg.sender, address(Dai), input, output);\r\n\r\n        return input;\r\n    }\r\n    \r\n    function doTransferIn(ERC20 token, CERC20 ctoken, uint256 debt, address from, uint256 amount) internal {\r\n        require(token.transferFrom(from, address(this), amount));\r\n\r\n        if(debt > 0) {\r\n            if(debt >= amount) {\r\n                require(ctoken.repayBorrow(amount) == 0, \"ctoken.repayBorrow failed\");\r\n            }\r\n            else {\r\n                require(ctoken.repayBorrow(debt) == 0, \"ctoken.repayBorrow failed\");\r\n                require(ctoken.mint(amount.sub(debt)) == 0, \"ctoken.mint failed\");\r\n            }\r\n        }\r\n        else {\r\n            require(ctoken.mint(amount) == 0, \"ctoken.mint failed\");\r\n        }\r\n    }\r\n\r\n    function doTransferOut(ERC20 token, CERC20 ctoken, uint256 balance, address to, uint256 amount) internal {\r\n        if(balance >= amount) {\r\n            require(ctoken.redeemUnderlying(amount) == 0, \"ctoken.redeemUnderlying failed\");\r\n        }\r\n        else {\r\n            if(balance == 0) {\r\n                require(ctoken.borrow(amount) == 0, \"ctoken.borrow failed\");\r\n            }\r\n            else {\r\n                require(ctoken.redeemUnderlying(balance) == 0, \"ctoken.redeemUnderlying failed\");\r\n                require(ctoken.borrow(amount.sub(balance)) == 0, \"ctoken.borrow failed\");\r\n            }\r\n        }\r\n\r\n        require(token.transfer(to, amount));\r\n    }\r\n\r\n    function securityCheck(uint256 input, uint256 output, uint256 a, uint256 b, uint256 c, uint256 d) internal pure {\r\n        if(c < output.add(d))\r\n            require(output.add(d).sub(c).mul(100) < input.add(a).sub(b).mul(62), \"DEBT_TOO_MUCH\"); // debt/collateral < 62%\r\n    }\r\n\r\n    /***********************************|\r\n    |        Liquidity Functions        |\r\n    |__________________________________*/\r\n\r\n    function addLiquidity(uint256 share, uint256[2] memory tokens) public returns (uint256, uint256) {\r\n        require(share >= 1e15, 'INVALID_ARGUMENT'); // 1000 * rate()\r\n\r\n        collectComp();\r\n\r\n        if (_totalSupply > 0) {\r\n            (uint256 a, uint256 b) = getDaiBalance();\r\n            (uint256 c, uint256 d) = getUSDCBalance();\r\n\r\n            if(a < b) {\r\n                uint256 dai_reserve = b.sub(a);\r\n                uint256 usdc_reserve = c.sub(d);\r\n                uint256 dai_amount = share.mul(dai_reserve).div(_totalSupply);\r\n                uint256 usdc_amount = share.mul(usdc_reserve).div(_totalSupply);\r\n                usdc_amount = usdc_amount.div(rate());\r\n                require(dai_amount >= tokens[0] && usdc_amount <= tokens[1], \"SLIPPAGE_DETECTED\");\r\n\r\n                _mint(msg.sender, share);\r\n                doTransferIn(USDC, cUSDC, d.div(rate()), msg.sender, usdc_amount);\r\n                doTransferOut(Dai, cDai, a, msg.sender, dai_amount);\r\n                \r\n                emit AddLiquidity(msg.sender, dai_amount, usdc_amount);\r\n                return (dai_amount, usdc_amount);\r\n\r\n            }\r\n            else if (c < d) {\r\n                uint256 dai_reserve = a.sub(b);\r\n                uint256 usdc_reserve = d.sub(c);\r\n                uint256 dai_amount = share.mul(dai_reserve).div(_totalSupply);\r\n                uint256 usdc_amount = share.mul(usdc_reserve).div(_totalSupply);\r\n                usdc_amount = usdc_amount.div(rate());\r\n                require(dai_amount <= tokens[0] && usdc_amount >= tokens[1], \"SLIPPAGE_DETECTED\");\r\n\r\n                _mint(msg.sender, share);\r\n                doTransferIn(Dai, cDai, b, msg.sender, dai_amount);\r\n                doTransferOut(USDC, cUSDC, c.div(rate()), msg.sender, usdc_amount);\r\n                \r\n                emit AddLiquidity(msg.sender, dai_amount, usdc_amount);\r\n                return (dai_amount, usdc_amount);\r\n\r\n            }\r\n            else {\r\n                uint256 dai_reserve = a.sub(b);\r\n                uint256 usdc_reserve = c.sub(d);\r\n                uint256 dai_amount = share.mul(dai_reserve).div(_totalSupply);\r\n                uint256 usdc_amount = share.mul(usdc_reserve).div(_totalSupply);\r\n                usdc_amount = usdc_amount.div(rate());\r\n                require(dai_amount <= tokens[0] && usdc_amount <= tokens[1], \"SLIPPAGE_DETECTED\");\r\n\r\n                _mint(msg.sender, share);\r\n                doTransferIn(Dai, cDai, b, msg.sender, dai_amount);\r\n                doTransferIn(USDC, cUSDC, d.div(rate()), msg.sender, usdc_amount);\r\n                \r\n                emit AddLiquidity(msg.sender, dai_amount, usdc_amount);\r\n                return (dai_amount, usdc_amount);\r\n            }\r\n        } else {\r\n            uint256 dai_amount = share.div(2);\r\n            uint256 usdc_amount = share.div(rate()).div(2);\r\n\r\n            _mint(msg.sender, share);\r\n            doTransferIn(Dai, cDai, 0, msg.sender, dai_amount);\r\n            doTransferIn(USDC, cUSDC, 0, msg.sender, usdc_amount);\r\n            \r\n            emit AddLiquidity(msg.sender, dai_amount, usdc_amount);\r\n            return (dai_amount, usdc_amount);\r\n        }\r\n    }\r\n\r\n    function removeLiquidity(uint256 share, uint256[2] memory tokens) public returns (uint256, uint256) {\r\n        require(share > 0, 'INVALID_ARGUMENT');\r\n\r\n        collectComp();\r\n\r\n        (uint256 a, uint256 b) = getDaiBalance();\r\n        (uint256 c, uint256 d) = getUSDCBalance();\r\n\r\n        if(a < b) {\r\n            uint256 dai_reserve = b.sub(a);\r\n            uint256 usdc_reserve = c.sub(d);\r\n            uint256 dai_amount = share.mul(dai_reserve).div(_totalSupply);\r\n            uint256 usdc_amount = share.mul(usdc_reserve).div(_totalSupply);\r\n            usdc_amount = usdc_amount.div(rate());\r\n            require(dai_amount <= tokens[0] && usdc_amount >= tokens[1], \"SLIPPAGE_DETECTED\");\r\n\r\n            _burn(msg.sender, share);            \r\n            doTransferIn(Dai, cDai, b, msg.sender, dai_amount);\r\n            doTransferOut(USDC, cUSDC, c.div(rate()), msg.sender, usdc_amount);\r\n            \r\n            emit RemoveLiquidity(msg.sender, dai_amount, usdc_amount);\r\n            return (dai_amount, usdc_amount);\r\n\r\n        }\r\n        else if (c < d) {\r\n            uint256 dai_reserve = a.sub(b);\r\n            uint256 usdc_reserve = d.sub(c);\r\n            uint256 dai_amount = share.mul(dai_reserve).div(_totalSupply);\r\n            uint256 usdc_amount = share.mul(usdc_reserve).div(_totalSupply);\r\n            usdc_amount = usdc_amount.div(rate());\r\n            require(dai_amount >= tokens[0] && usdc_amount <= tokens[1], \"SLIPPAGE_DETECTED\");\r\n\r\n            _burn(msg.sender, share);\r\n            doTransferIn(USDC, cUSDC, d.div(rate()), msg.sender, usdc_amount);\r\n            doTransferOut(Dai, cDai, a, msg.sender, dai_amount);\r\n            \r\n            emit RemoveLiquidity(msg.sender, dai_amount, usdc_amount);\r\n            return (dai_amount, usdc_amount);\r\n\r\n        }\r\n        else {\r\n            uint256 dai_reserve = a.sub(b);\r\n            uint256 usdc_reserve = c.sub(d);\r\n            uint256 dai_amount = share.mul(dai_reserve).div(_totalSupply);\r\n            uint256 usdc_amount = share.mul(usdc_reserve).div(_totalSupply);\r\n            usdc_amount = usdc_amount.div(rate());\r\n            require(dai_amount >= tokens[0] && usdc_amount >= tokens[1], \"SLIPPAGE_DETECTED\");\r\n\r\n            _burn(msg.sender, share);\r\n            doTransferOut(Dai, cDai, a, msg.sender, dai_amount);\r\n            doTransferOut(USDC, cUSDC, c.div(rate()), msg.sender, usdc_amount);\r\n            \r\n            emit RemoveLiquidity(msg.sender, dai_amount, usdc_amount);\r\n            return (dai_amount, usdc_amount);\r\n        }\r\n    }\r\n\r\n    /***********************************|\r\n    |           Collect Comp            |\r\n    |__________________________________*/\r\n\r\n    function collectComp() public {\r\n        uint256 _comp = Comp.balanceOf(address(this));\r\n        if(_comp == 0) return;\r\n\r\n        (uint256 a, uint256 b) = getDaiBalance();\r\n        (uint256 c, uint256 d) = getUSDCBalance();\r\n\r\n        bool isDai = a.add(d) > c.add(b);\r\n\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(Comp);\r\n        path[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; //weth\r\n        path[2] = isDai ? address(Dai) : address(USDC);\r\n        uint256[] memory amounts = uniswap.swapExactTokensForTokens(_comp, 0, path, address(this), now);\r\n\r\n        if(isDai)\r\n            require(cDai.mint(amounts[2]) == 0, \"ctoken.mint failed\");\r\n        else\r\n            require(cUSDC.mint(amounts[2]) == 0, \"ctoken.mint failed\");\r\n\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"DAIAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"USDCAmount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputs\",\"type\":\"uint256\"}],\"name\":\"Purchases\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"DAIAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"USDCAmount\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"S\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"tokens\",\"type\":\"uint256[2]\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"alarm\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amplifier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectComp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"dai2usdcIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max_input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"dai2usdcOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getDaiBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"getInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"getOutputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getUSDCBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"tokens\",\"type\":\"uint256[2]\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"}],\"name\":\"setParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"usdc2daiIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max_input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"usdc2daiOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"bhsAlpha","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://40a591981c372d6b7056bf261c711c09fa1088e61c1bc89f012563047befd735"}]}