{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n@author radarzhhua@gamil.com\r\n*/\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\nlibrary NameFilter {\r\n\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.\r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x\r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input) internal pure returns (bytes32){\r\n        bytes memory _temp = bytes(_input);\r\n        uint _length = _temp.length;\r\n        //sorry limited to 32 characters\r\n        require(_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length - 1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        // convert & check\r\n        for (uint i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                // OR lowercase a-z\r\n                (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                // or 0-9\r\n                (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require(_temp[i + 1] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract PlayerBook is Owned {\r\n    using SafeMath for uint;\r\n    using NameFilter for string;\r\n    bool public actived = false;\r\n    uint public registrationFee_ = 1 finney;            // price to register a name\r\n    uint public pID_;        // total number of players\r\n    mapping(address => uint) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping(uint => Player) public plyr_;               // (pID => data) player data\r\n    mapping(bytes32 => uint) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping(uint => mapping(bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amoungst any name you own)\r\n    mapping(uint => mapping(uint => bytes32)) public plyrNameList_; // (pID => nameNum => name) list of names a player owns\r\n    struct Player {\r\n        address addr;\r\n        bytes32 name;\r\n        uint laff;\r\n        uint names;\r\n    }\r\n    /**\r\n     * @dev prevents contracts from interacting with playerBook\r\n     */\r\n    modifier isHuman {\r\n        address _addr = msg.sender;\r\n        uint _codeLength;\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    modifier isActive {\r\n        require(actived, \"sorry game paused\");\r\n        _;\r\n    }\r\n    modifier isRegistered {\r\n        address _addr = msg.sender;\r\n        uint _pid = pIDxAddr_[msg.sender];\r\n        require(_pid != 0, \" you need register the address\");\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        // premine the admin names (sorry not sorry)\r\n        plyr_[1].addr = 0x2ba0ECF5eC2dD51F115d8526333395beba490363;\r\n        plyr_[1].name = \"admin\";\r\n        plyr_[1].names = 1;\r\n        pIDxAddr_[0x2ba0ECF5eC2dD51F115d8526333395beba490363] = 1;\r\n        pIDxName_[\"admin\"] = 1;\r\n        plyrNames_[1][\"admin\"] = true;\r\n        plyrNameList_[1][1] = \"admin\";\r\n        pID_ = 1;\r\n    }\r\n\r\n    function checkIfNameValid(string _nameStr) public view returns (bool){\r\n        bytes32 _name = _nameStr.nameFilter();\r\n        if (pIDxName_[_name] == 0)\r\n            return (true);\r\n        else\r\n            return (false);\r\n    }\r\n\r\n    function determinePID(address _addr) private returns (bool){\r\n        if (pIDxAddr_[_addr] == 0) {\r\n            pID_++;\r\n            pIDxAddr_[_addr] = pID_;\r\n            plyr_[pID_].addr = _addr;\r\n            // set the new player bool to true\r\n            return (true);\r\n        } else {\r\n            return (false);\r\n        }\r\n    }\r\n\r\n    function registerNameXID(string _nameString, uint _affCode) public isActive isHuman payable {\r\n        // make sure name fees paid\r\n        require(msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        // set up address\r\n        address _addr = msg.sender;\r\n        // set up our tx event data and determine if player is new or not\r\n        determinePID(_addr);\r\n        // fetch player id\r\n        uint _pID = pIDxAddr_[_addr];\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the\r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        //_affCode must little than the pID_\r\n        if (_affCode != 0 && _affCode != plyr_[_pID].laff && _affCode != _pID && _affCode <= pID_) {\r\n            // update last affiliate\r\n            plyr_[_pID].laff = _affCode;\r\n        } else {\r\n            if(plyr_[_pID].laff == 0)\r\n              plyr_[_pID].laff = 1;\r\n        }\r\n        // register name\r\n        plyr_[1].addr.transfer(msg.value);\r\n        registerNameCore(_pID, _name);\r\n    }\r\n\r\n    function registerNameCore(uint _pID, bytes32 _name) private {\r\n        if (pIDxName_[_name] != 0)\r\n            require(plyrNames_[_pID][_name] == true, \"sorry that names already taken\");\r\n        plyr_[_pID].name = _name;\r\n        pIDxName_[_name] = _pID;\r\n        if (plyrNames_[_pID][_name] == false)\r\n        {\r\n            plyrNames_[_pID][_name] = true;\r\n            plyr_[_pID].names++;\r\n            plyrNameList_[_pID][plyr_[_pID].names] = _name;\r\n        }\r\n    }\r\n\r\n    function getPlayerLaffCount(address _addr) internal view returns (uint){\r\n        uint _pid = pIDxAddr_[_addr];\r\n        if (_pid == 0) {\r\n            return 0;\r\n        } else {\r\n            uint result = 0;\r\n            for (uint i = 1; i <= pID_; i++) {\r\n                if (plyr_[i].laff == _pid) {\r\n                    result ++;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function getPlayerID(address _addr) external view returns (uint) {\r\n        return (pIDxAddr_[_addr]);\r\n    }\r\n\r\n    function getPlayerCount() external view returns (uint){\r\n        return pID_;\r\n    }\r\n\r\n    function getPlayerName(uint _pID) external view returns (bytes32){\r\n        return (plyr_[_pID].name);\r\n    }\r\n\r\n    function getPlayerLAff(uint _pID) external view returns (uint){\r\n        return (plyr_[_pID].laff);\r\n    }\r\n\r\n    function getPlayerAddr(uint _pID) external view returns (address){\r\n        return (plyr_[_pID].addr);\r\n    }\r\n\r\n    function getNameFee() external view returns (uint){\r\n        return (registrationFee_);\r\n    }\r\n\r\n    function setRegistrationFee(uint _fee) public onlyOwner {\r\n        require(_fee != 0);\r\n        registrationFee_ = _fee;\r\n    }\r\n\r\n    function active() public onlyOwner {\r\n        actived = true;\r\n    }\r\n}\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\ncontract Treasure is PlayerBook {\r\n    uint private seed = 18;                    //random seed\r\n    /* bool private canSet = true; */\r\n    //module 0,1,2\r\n    uint[3] public gameRound = [1, 1, 1];                         //rounds index by module\r\n    uint[3] public maxKeys = [1200, 12000, 60000];              //index by module\r\n    uint[3] public keyLimits = [100, 1000, 5000];               //index by module\r\n    uint public keyPrice = 10 finney;\r\n    uint public devFee = 10;\r\n    uint public laffFee1 = 10;\r\n    uint public laffFee2 = 1;\r\n    address public devWallet = 0xB4D4709C2D537047683294c4040aBB9d616e23B5;\r\n    mapping(uint => mapping(uint => RoundInfo)) public gameInfo;   //module => round => info\r\n    mapping(uint => mapping(uint => mapping(uint => uint))) public userAff;     //module => round => pid => affCount\r\n    struct RoundInfo {\r\n        uint module;            //module 0,1,2\r\n        uint rd;                // rounds\r\n        uint count;             // player number and id\r\n        uint keys;              // purchased keys\r\n        uint maxKeys;           // end keys\r\n        uint keyLimits;\r\n        uint award;             //award of the round\r\n        address winner;         //winner\r\n        bool isEnd;\r\n        mapping(uint => uint) userKeys;        // pid => keys\r\n        mapping(uint => uint) userId;      // count => pid\r\n    }\r\n\r\n    modifier validModule(uint _module){\r\n        require(_module >= 0 && _module <= 2, \" error module\");\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        initRoundInfo(0, 1);\r\n        initRoundInfo(1, 1);\r\n        initRoundInfo(2, 1);\r\n    }\r\n    //only be called once\r\n    /* function setSeed(uint _seed) public onlyOwner {\r\n      require(canSet);\r\n      canSet = false;\r\n      seed = _seed;\r\n    } */\r\n\r\n    /**\r\n   random int\r\n    */\r\n    function randInt(uint256 _start, uint256 _end, uint256 _nonce)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 _range = _end.sub(_start);\r\n        uint256 value = uint256(keccak256(abi.encodePacked(\r\n                (block.timestamp).add\r\n                (block.difficulty).add\r\n                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n                (block.gaslimit).add\r\n                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n                (block.number),\r\n                _nonce\r\n            )));\r\n        return (_start + value - ((value / _range) * _range));\r\n    }\r\n\r\n    function initRoundInfo(uint _mode, uint _rd) private validModule(_mode) {\r\n        uint _maxKeys = maxKeys[_mode];\r\n        uint _keyLimits = keyLimits[_mode];\r\n        RoundInfo memory rf = RoundInfo({\r\n            module : _mode,\r\n            rd : _rd,\r\n            count : 0,\r\n            keys : 0,\r\n            maxKeys : _maxKeys,\r\n            keyLimits : _keyLimits,\r\n            award : 0,\r\n            winner : address(0),\r\n            isEnd : false\r\n            });\r\n        gameInfo[_mode][_rd] = rf;\r\n    }\r\n    //user detail of one round\r\n    function getUserDetail(uint _mode, uint _rd) public validModule(_mode) view returns (uint _eth, uint _award, uint _affEth){\r\n        address _addr = msg.sender;\r\n        uint _pid = pIDxAddr_[_addr];\r\n        require(_pid != 0, \" you need register the address\");\r\n        uint _userKeys = gameInfo[_mode][_rd].userKeys[_pid];\r\n        _eth = _userKeys * keyPrice;\r\n        if (gameInfo[_mode][_rd].winner == _addr)\r\n            _award = gameInfo[_mode][_rd].award;\r\n        else\r\n            _award = 0;\r\n        _affEth = userAff[_mode][_rd][_pid];\r\n    }\r\n\r\n    function getAllLaffAwards(address _addr) private view returns (uint){\r\n        uint _pid = pIDxAddr_[_addr];\r\n        require(_pid != 0, \" you need register the address\");\r\n        uint sum = 0;\r\n        for (uint i = 0; i < 3; i++) {\r\n            for (uint j = 1; j <= gameRound[i]; j++) {\r\n                uint value = userAff[i][j][_pid];\r\n                if (value > 0)\r\n                    sum = sum.add(value);\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function getPlayerAllDetail() external view returns (uint[] modes, uint[] rounds, uint[] eths, uint[] awards, uint _laffAwards, uint _laffCount){\r\n        address _addr = msg.sender;\r\n        uint _pid = pIDxAddr_[_addr];\r\n        require(_pid != 0, \" you need register the address\");\r\n        uint i = gameRound[0] + gameRound[1] + gameRound[2];\r\n        uint counter = 0;\r\n        RoundInfo[] memory allInfo = new RoundInfo[](i);\r\n        for (i = 0; i < 3; i++) {\r\n            for (uint j = 1; j <= gameRound[i]; j++) {\r\n                if (gameInfo[i][j].userKeys[_pid] > 0) {\r\n                    allInfo[counter] = gameInfo[i][j];\r\n                    counter ++;\r\n                }\r\n            }\r\n        }\r\n        modes = new uint[](counter);\r\n        rounds = new uint[](counter);\r\n        eths = new uint[](counter);\r\n        awards = new uint[](counter);\r\n        for (i = 0; i < counter; i++) {\r\n            modes[i] = allInfo[i].module;\r\n            rounds[i] = allInfo[i].rd;\r\n            eths[i] = gameInfo[modes[i]][rounds[i]].userKeys[_pid].mul(keyPrice);\r\n            if (_addr == allInfo[i].winner) {\r\n                awards[i] = allInfo[i].award;\r\n            } else {\r\n                awards[i] = 0;\r\n            }\r\n        }\r\n        _laffAwards = getAllLaffAwards(_addr);\r\n        _laffCount = getPlayerLaffCount(_addr);\r\n    }\r\n\r\n    function buyKeys(uint _mode, uint _rd) public isHuman isActive validModule(_mode) payable {\r\n        address _addr = msg.sender;\r\n        uint _pid = pIDxAddr_[_addr];\r\n        require(_pid != 0, \" you need register the address\");\r\n        uint _eth = msg.value;\r\n        require(_eth >= keyPrice, \"you need buy one or more keys\");\r\n        require(_rd == gameRound[_mode], \"error round\");\r\n        RoundInfo storage ri = gameInfo[_mode][_rd];\r\n        require(!ri.isEnd, \"the round is end\");\r\n        require(ri.keys < ri.maxKeys, \"the round maxKeys\");\r\n        uint _keys = _eth.div(keyPrice);\r\n        require(ri.userKeys[_pid] < ri.keyLimits);\r\n        if (ri.userKeys[_pid] == 0) {\r\n            ri.count ++;\r\n            ri.userId[ri.count] = _pid;\r\n        }\r\n        if (_keys.add(ri.keys) > ri.maxKeys) {\r\n            _keys = ri.maxKeys.sub(ri.keys);\r\n        }\r\n        if (_keys.add(ri.userKeys[_pid]) > ri.keyLimits) {\r\n            _keys = ri.keyLimits - ri.userKeys[_pid];\r\n        }\r\n        require(_keys > 0);\r\n        uint rand = randInt(0, 100, seed+_keys);\r\n        seed = seed.add(rand);\r\n        _eth = _keys.mul(keyPrice);\r\n        ri.userKeys[_pid] = ri.userKeys[_pid].add(_keys);\r\n        ri.keys = ri.keys.add(_keys);\r\n        //back\r\n        if(msg.value - _eth > 10 szabo )\r\n          msg.sender.transfer(msg.value - _eth);\r\n        checkAff(_mode, _rd, _pid, _eth);\r\n        if (ri.keys >= ri.maxKeys) {\r\n            endRound(_mode, _rd);\r\n        }\r\n    }\r\n\r\n    function getUserInfo(address _addr) public view returns (uint _pID, bytes32 _name, uint _laff, uint[] _keys){\r\n        _pID = pIDxAddr_[_addr];\r\n        _name = plyr_[_pID].name;\r\n        _laff = plyr_[_pID].laff;\r\n        _keys = new uint[](3);\r\n        for (uint i = 0; i < 3; i++) {\r\n            _keys[i] = gameInfo[i][gameRound[i]].userKeys[_pID];\r\n        }\r\n    }\r\n\r\n\r\n    function endRound(uint _mode, uint _rd) private {\r\n        RoundInfo storage ri = gameInfo[_mode][_rd];\r\n        require(!ri.isEnd, \"the rounds has end\");\r\n        ri.isEnd = true;\r\n        uint _eth = ri.award.mul(devFee) / 100;\r\n        uint _win = calWinner(_mode, _rd);\r\n        ri.winner = plyr_[_win].addr;\r\n        gameRound[_mode] = _rd + 1;\r\n        initRoundInfo(_mode, _rd + 1);\r\n        devWallet.transfer(_eth);\r\n        plyr_[_win].addr.transfer(ri.award.sub(_eth));\r\n    }\r\n\r\n    function calWinner(uint _mode, uint _rd) private returns (uint){\r\n        RoundInfo storage ri = gameInfo[_mode][_rd];\r\n        uint rand = randInt(0, ri.maxKeys, seed);\r\n        seed = seed.add(rand);\r\n        uint keySum = 0;\r\n        uint _win = 0;\r\n        for (uint i = 1; i <= ri.count; i++) {\r\n            uint _key = ri.userKeys[ri.userId[i]];\r\n            keySum += _key;\r\n            if (rand < keySum) {\r\n                _win = i;\r\n                break;\r\n            }\r\n        }\r\n        require(_win > 0);\r\n        return ri.userId[_win];\r\n    }\r\n\r\n    function checkAff(uint _mode, uint _rd, uint _pid, uint _eth) private {\r\n        uint fee1 = _eth.mul(laffFee1).div(100);\r\n        uint fee2 = _eth.mul(laffFee2).div(100);\r\n        uint res = _eth.sub(fee1).sub(fee2);\r\n        gameInfo[_mode][_rd].award += res;\r\n        uint laff1 = plyr_[_pid].laff;\r\n        if (laff1 == 0) {\r\n            plyr_[1].addr.transfer(fee1.add(fee2));\r\n        } else {\r\n            plyr_[laff1].addr.transfer(fee1);\r\n            userAff[_mode][_rd][laff1] += fee1;\r\n            uint laff2 = plyr_[laff1].laff;\r\n            if (laff2 == 0) {\r\n                plyr_[1].addr.transfer(fee2);\r\n            } else {\r\n                plyr_[laff2].addr.transfer(fee2);\r\n                userAff[_mode][_rd][laff2] += fee2;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getRoundInfo(uint _mode) external validModule(_mode) view returns (uint _cr, uint _ck, uint _mk, uint _award){\r\n        _cr = gameRound[_mode];\r\n        _ck = gameInfo[_mode][_cr].keys;\r\n        _mk = gameInfo[_mode][_cr].maxKeys;\r\n        _award = gameInfo[_mode][_cr].award;\r\n    }\r\n\r\n    function getRoundIsEnd(uint _mode, uint _rd) external validModule(_mode) view returns (bool){\r\n        require(_rd > 0 && _rd <= gameRound[_mode]);\r\n        return gameInfo[_mode][_rd].isEnd;\r\n    }\r\n\r\n    function getAwardHistorhy(uint _mode) external validModule(_mode) view returns (address[] dh, uint[] ah){\r\n        uint hr = gameRound[_mode] - 1;\r\n        dh = new address[](hr);\r\n        ah = new uint[](hr);\r\n        if (hr != 0) {\r\n            for (uint i = 1; i <= hr; i++) {\r\n                RoundInfo memory rf = gameInfo[_mode][i];\r\n                dh[i - 1] = rf.winner;\r\n                ah[i - 1] = rf.award;\r\n            }\r\n        }\r\n    }\r\n        /* ****************************************************\r\n              *********                            *********\r\n                *********                        *********\r\n                  *********    thanks a lot    *********\r\n                    *********                *********\r\n                      *********            *********\r\n                        *********        *********\r\n                          *********    *********\r\n                            ******************\r\n                              **************\r\n                                **********\r\n                                  *****\r\n                                    *\r\n         *********************************************************/\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameInfo\",\"outputs\":[{\"name\":\"module\",\"type\":\"uint256\"},{\"name\":\"rd\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"maxKeys\",\"type\":\"uint256\"},{\"name\":\"keyLimits\",\"type\":\"uint256\"},{\"name\":\"award\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"isEnd\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keyLimits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"active\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerAllDetail\",\"outputs\":[{\"name\":\"modes\",\"type\":\"uint256[]\"},{\"name\":\"rounds\",\"type\":\"uint256[]\"},{\"name\":\"eths\",\"type\":\"uint256[]\"},{\"name\":\"awards\",\"type\":\"uint256[]\"},{\"name\":\"_laffAwards\",\"type\":\"uint256\"},{\"name\":\"_laffCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNameFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"laffFee2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nameStr\",\"type\":\"string\"}],\"name\":\"checkIfNameValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mode\",\"type\":\"uint256\"}],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"_cr\",\"type\":\"uint256\"},{\"name\":\"_ck\",\"type\":\"uint256\"},{\"name\":\"_mk\",\"type\":\"uint256\"},{\"name\":\"_award\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"laffFee1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrNameList_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mode\",\"type\":\"uint256\"}],\"name\":\"getAwardHistorhy\",\"outputs\":[{\"name\":\"dh\",\"type\":\"address[]\"},{\"name\":\"ah\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mode\",\"type\":\"uint256\"},{\"name\":\"_rd\",\"type\":\"uint256\"}],\"name\":\"getRoundIsEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mode\",\"type\":\"uint256\"},{\"name\":\"_rd\",\"type\":\"uint256\"}],\"name\":\"buyKeys\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mode\",\"type\":\"uint256\"},{\"name\":\"_rd\",\"type\":\"uint256\"}],\"name\":\"getUserDetail\",\"outputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_award\",\"type\":\"uint256\"},{\"name\":\"_affEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"names\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerLAff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actived\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Treasure","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0ca098487e4a20b0af2a8f97077833d410a51803fb26bb3710925f477fb61bdc"}]}