{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract AutomatedExchange{\r\n  function buyTokens() public payable;\r\n  function calculateTokenSell(uint256 tokens) public view returns(uint256);\r\n  function calculateTokenBuy(uint256 eth,uint256 contractBalance) public view returns(uint256);\r\n  function balanceOf(address tokenOwner) public view returns (uint balance);\r\n}\r\ncontract VerifyToken {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    bool public activated;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\ncontract VRFBet is ApproveAndCallFallBack{\r\n  using SafeMath for uint;\r\n  struct Bet{\r\n    uint blockPlaced;\r\n    address bettor;\r\n    uint betAmount;\r\n  }\r\n  mapping(address => bytes) public victoryMessages;\r\n  mapping(uint => Bet) public betQueue;\r\n  uint public MAX_SIMULTANEOUS_BETS=20;\r\n  uint public index=0;//index for processing bets\r\n  uint public indexBetPlace=0;//index for placing bets\r\n  address vrfAddress= 0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;//0xe0832c4f024D2427bBC6BD0C4931096d2ab5CCaF; //0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;\r\n  VerifyToken vrfcontract=VerifyToken(vrfAddress);\r\n  AutomatedExchange exchangecontract=AutomatedExchange(0x48bF5e13A1ee8Bd4385C182904B3ABf73E042675);\r\n\r\n  event Payout(address indexed to, uint tokens);\r\n  event BetFinalized(address indexed bettor,uint tokensWagered,uint tokensAgainst,uint tokensWon,bytes victoryMessage);\r\n\r\n  //Send tokens with ApproveAndCallFallBack, place a bet\r\n  function receiveApproval(address from, uint256 tokens, address token, bytes data) public{\r\n      require(msg.sender==vrfAddress);\r\n      vrfcontract.transferFrom(from,this,tokens);\r\n      _placeBet(tokens,from,data);\r\n  }\r\n  function placeBetEth(bytes victoryMessage) public payable{\r\n    require(indexBetPlace-index<MAX_SIMULTANEOUS_BETS);//ensures you don't get a situation where there are too many existing bets to process, locking VRF in the contract\r\n    uint tokensBefore=vrfcontract.balanceOf(this);\r\n    exchangecontract.buyTokens.value(msg.value)();\r\n    _placeBet(vrfcontract.balanceOf(this).sub(tokensBefore),msg.sender,victoryMessage);\r\n  }\r\n  function payout(address to,uint numTokens) private{\r\n    vrfcontract.transfer(to,numTokens);\r\n    emit Payout(to,numTokens);\r\n  }\r\n  function _placeBet(uint numTokens,address from,bytes victoryMessage) private{\r\n    resolvePriorBets();\r\n    betQueue[indexBetPlace]=Bet({blockPlaced:block.number,bettor:from,betAmount:numTokens});\r\n    indexBetPlace+=1;\r\n    victoryMessages[from]=victoryMessage;\r\n  }\r\n  function resolvePriorBets() public{\r\n    while(betQueue[index].blockPlaced!=0){\r\n      if(betQueue[index+1].blockPlaced!=0){\r\n        if(betQueue[index+1].blockPlaced+250>block.number){//bet is not expired\r\n          if(block.number>betQueue[index+1].blockPlaced){//bet was in the past, future blockhash can be safely used to compute random\r\n\r\n          /*\r\n            Bet is between two players.\r\n            Outcome is computed as whether rand(bet1+bet2)<bet1. This makes the probability of winning proportional to the size of your bet, ensuring all bets are EV neutral.\r\n          */\r\n            uint totalbet=betQueue[index].betAmount+betQueue[index+1].betAmount;\r\n            uint randval= random(totalbet,betQueue[index+1].blockPlaced,betQueue[index+1].bettor);\r\n            if(randval < betQueue[index].betAmount){\r\n              payout(betQueue[index].bettor,totalbet);\r\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,0,victoryMessages[betQueue[index].bettor]);\r\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,totalbet,victoryMessages[betQueue[index].bettor]);\r\n            }\r\n            else{\r\n              payout(betQueue[index+1].bettor,totalbet);\r\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,totalbet,victoryMessages[betQueue[index+1].bettor]);\r\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,0,victoryMessages[betQueue[index+1].bettor]);\r\n            }\r\n            index+=2;\r\n          }\r\n          else{ //bet is in the current block, cannot be resolved, no point in continuing the loop\r\n            return;\r\n          }\r\n        }\r\n        else{//bet has expired, return tokens to users\r\n          payout(betQueue[index+1].bettor,betQueue[index+1].betAmount);\r\n          payout(betQueue[index].bettor,betQueue[index].betAmount);\r\n          index+=2;\r\n          emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,betQueue[index].betAmount,\"\");\r\n          emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,betQueue[index+1].betAmount,\"\");\r\n        }\r\n      }\r\n      else{ //single bet with no other to pair it to, must wait for another bet\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  function cancelBet() public{\r\n    resolvePriorBets();\r\n    require(indexBetPlace-index==1 && betQueue[index].bettor==msg.sender);\r\n    index+=1;//skip the last remaining bet\r\n  }\r\n  /*\r\n    requires an odd number of bets and your bet is the last one\r\n  */\r\n  function canCancelBet() public view returns(bool){\r\n    return indexBetPlace>0 && !isEven(indexBetPlace-index) && betQueue[indexBetPlace-1].bettor==msg.sender;\r\n  }\r\n  function isEven(uint num) public view returns(bool){\r\n    return 2*(num/2)==num;\r\n  }\r\n  function maxRandom(uint blockn, address entropy)\r\n    internal\r\n    returns (uint256 randomNumber)\r\n  {\r\n      return uint256(keccak256(\r\n          abi.encodePacked(\r\n            blockhash(blockn),\r\n            entropy)\r\n      ));\r\n  }\r\n  function random(uint256 upper, uint256 blockn, address entropy)\r\n    internal\r\n    returns (uint256 randomNumber)\r\n  {\r\n      return maxRandom(blockn, entropy) % upper + 1;\r\n  }\r\n  /*\r\n    only for frontend viewing purposes\r\n  */\r\n  function getBetState(address bettor) public view returns(uint){\r\n    for(uint i=index;i<indexBetPlace;i++){\r\n      if(betQueue[i].bettor==bettor){\r\n        if(!isEven(indexBetPlace-index)){//i<indexBetPlace-1){\r\n          return 1;\r\n        }\r\n        else{\r\n          return 2;\r\n        }\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"victoryMessages\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"isEven\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bettor\",\"type\":\"address\"}],\"name\":\"getBetState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betQueue\",\"outputs\":[{\"name\":\"blockPlaced\",\"type\":\"uint256\"},{\"name\":\"bettor\",\"type\":\"address\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"victoryMessage\",\"type\":\"bytes\"}],\"name\":\"placeBetEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canCancelBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"indexBetPlace\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resolvePriorBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SIMULTANEOUS_BETS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bettor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensWagered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensAgainst\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"victoryMessage\",\"type\":\"bytes\"}],\"name\":\"BetFinalized\",\"type\":\"event\"}]","ContractName":"VRFBet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://223385bc6a5db3261a26efa0b5e7f488b982b0347206ff563addf2edcb0f77c6"}]}