{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n* @dev This is a library based implementation of the ERC20 token standard.\r\n* This library allows all values to be set by interface logic. This includes\r\n* the ability to set msg.sender. This allows two distinct advantages:\r\n*  - Access control logic may be layered without the need to change the\r\n*    core logic of the ERC20 system in any way.\r\n*  - Tokens that require administrative action, under some conditions,\r\n*    may take administrative action on an account, without having to\r\n*    create fragile backdoors into the transfer logic of the token. This\r\n*    system makes such administrative priveledge clear, apparent, and\r\n*    more easily auditable to ensure reasonable limitations of power.\r\n*/\r\nlibrary ERC20Lib {\r\n\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Imports\r\n\r\n  /**\r\n  * @dev Prevents underflow and overflow attacks..\r\n  */\r\n  using SafeMath for uint256;\r\n  ///////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Events\r\n\r\n  /**\r\n  * @dev Transfer event emitted in 3 cases; transfers, minting, and burning.\r\n  * for transfers, all fields set as normal\r\n  * for minting from is set to address(0)\r\n  * for burning is set to address(0)\r\n  */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n  * @dev Specifies an approval being granted from an owner to a spender\r\n  * for the amount specified.\r\n  */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Declarations\r\n\r\n  /**\r\n  * @dev Struct like representation of ERC20 state vairiables.\r\n  * this allows the ERC20 logic to become a library under using for syntax\r\n  */\r\n  struct Token{\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowed;\r\n    uint256 _totalSupply;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Logic\r\n\r\n  /**\r\n  * @dev Returns the total supply of the token.\r\n  */\r\n  function totalSupply(Token storage self)\r\n  internal\r\n  view\r\n  returns (uint256) {\r\n    return self._totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the balance of an account.\r\n  */\r\n  function balances(Token storage self, address account)\r\n  internal\r\n  view\r\n  returns (uint256) {\r\n    return self._balances[account];\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the total allowance from the account to the spender..\r\n  */\r\n  function allowance(Token storage self, address account, address spender)\r\n  internal\r\n  view\r\n  returns (uint256) {\r\n    return self._allowed[account][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Issues an allowance from an account to another.\r\n  */\r\n  function approve(Token storage self, address sender, address spender, uint256 value)\r\n  internal {\r\n    require(spender != address(0));\r\n    self._allowed[sender][spender] = value;\r\n    emit Approval(sender, spender, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Cause a transfer to occur based on an existing allowance.\r\n  */\r\n  function transferFrom(Token storage self, address sender, address from, address to, uint256 value)\r\n  internal {\r\n    require(value <= self._allowed[from][sender]);\r\n    self._allowed[from][sender] = self._allowed[from][sender].sub(value);\r\n    transfer(self,from, to, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Increase the allowance from one account to another. Prevents\r\n  * change allowance attack.\r\n  */\r\n  function increaseAllowance(Token storage self, address sender, address spender, uint256 addedValue)\r\n  internal {\r\n    require(spender != address(0));\r\n    self._allowed[sender][spender] = self._allowed[sender][spender].add(addedValue);\r\n    emit Approval(sender, spender, self._allowed[sender][spender]);\r\n  }\r\n\r\n  /**\r\n  * @dev Decrease the allowance from one account to another. Prevents\r\n  * the change allowance attack.\r\n  */\r\n  function decreaseAllowance(Token storage self, address sender, address spender, uint256 subtractedValue)\r\n  internal {\r\n    require(spender != address(0));\r\n    self._allowed[sender][spender] = self._allowed[sender][spender].sub(subtractedValue);\r\n    emit Approval(sender, spender, self._allowed[sender][spender]);\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer tokens from one account to another.\r\n  */\r\n  function transfer(Token storage self, address sender, address to, uint256 value)\r\n  internal {\r\n    require(value <= self._balances[sender]);\r\n    require(to != address(0));\r\n    self._balances[sender] = self._balances[sender].sub(value);\r\n    self._balances[to] = self._balances[to].add(value);\r\n    emit Transfer(sender, to, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Mint new tokens to an account.\r\n  */\r\n  function mint(Token storage self, address account, uint256 value)\r\n  internal {\r\n    require(account != 0);\r\n    self._totalSupply = self._totalSupply.add(value);\r\n    self._balances[account] = self._balances[account].add(value);\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Burn tokens from an account.\r\n  */\r\n  function burn(Token storage self, address account, uint256 value)\r\n  internal {\r\n    require(account != 0);\r\n    require(value <= self._balances[account]);\r\n    self._totalSupply = self._totalSupply.sub(value);\r\n    self._balances[account] = self._balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n}\r\n\r\n\r\n\r\ncontract HubCulture{\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Imports\r\n  using ERC20Lib for ERC20Lib.Token;\r\n  using SafeMath for uint256;\r\n  ///////////////////////////////////////////////////////////////////////////\r\n\r\n  ///////////////////////////////////////////////////////////////////////////\r\n  //Events\r\n  event Pending(address indexed account, uint256 indexed value, uint256 indexed nonce);\r\n  event Deposit(address indexed account, uint256 indexed value, uint256 indexed nonce);\r\n  event Withdraw(address indexed account, uint256 indexed value, uint256 indexed nonce);\r\n  event Decline(address indexed account, uint256 indexed value, uint256 indexed nonce);\r\n  event Registration(address indexed account, bytes32 indexed uuid, uint256 indexed nonce);\r\n  event Unregistered(address indexed account, uint256 indexed nonce);\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Declarations\r\n  mapping(address=>bool) authorities;\r\n  mapping(address=>bool) registered;\r\n  mapping(address=>bool) vaults;\r\n  ERC20Lib.Token token;\r\n  ERC20Lib.Token pending;\r\n  uint256 eventNonce;\r\n  address failsafe;\r\n  address owner;\r\n  bool paused;\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Constructor\r\n  constructor(address _owner,address _failsafe)\r\n  public {\r\n    failsafe = _failsafe;\r\n    owner = _owner;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Modifiers\r\n  modifier onlyFailsafe(){\r\n    require(msg.sender == failsafe);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAdmin(){\r\n    require(msg.sender == owner || msg.sender == failsafe);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAuthority(){\r\n    require(authorities[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier onlyVault(){\r\n    require(vaults[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier notPaused(){\r\n    require(!paused);\r\n    _;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Failsafe Logic\r\n  function isFailsafe(address _failsafe)\r\n  public\r\n  view\r\n  returns (bool){\r\n    return (failsafe == _failsafe);\r\n  }\r\n\r\n  function setFailsafe(address _failsafe)\r\n  public\r\n  onlyFailsafe{\r\n    failsafe = _failsafe;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Owner Logic\r\n  function isOwner(address _owner)\r\n  public\r\n  view\r\n  returns (bool){\r\n    return (owner == _owner);\r\n  }\r\n\r\n  function setOwner(address _owner)\r\n  public\r\n  onlyAdmin{\r\n    owner = _owner;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Vault Logic\r\n  function isVault(address vault)\r\n  public\r\n  view\r\n  returns (bool) {\r\n    return vaults[vault];\r\n  }\r\n\r\n  function addVault(address vault)\r\n  public\r\n  onlyAdmin\r\n  notPaused\r\n  returns (bool) {\r\n    vaults[vault] = true;\r\n    return true;\r\n  }\r\n\r\n  function removeVault(address vault)\r\n  public\r\n  onlyAdmin\r\n  returns (bool) {\r\n    vaults[vault] = false;\r\n    return true;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Authority Logic\r\n  function isAuthority(address authority)\r\n  public\r\n  view\r\n  returns (bool) {\r\n    return authorities[authority];\r\n  }\r\n\r\n  function addAuthority(address authority)\r\n  public\r\n  onlyAdmin\r\n  notPaused\r\n  returns (bool) {\r\n    authorities[authority] = true;\r\n    return true;\r\n  }\r\n\r\n  function removeAuthority(address authority)\r\n  public\r\n  onlyAdmin\r\n  returns (bool) {\r\n    authorities[authority] = false;\r\n    return true;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Pause Logic\r\n\r\n  /**\r\n  * @dev Administrative lockdown check.\r\n  **/\r\n  function isPaused()\r\n  public\r\n  view\r\n  returns (bool) {\r\n    return paused;\r\n  }\r\n\r\n  /**\r\n  * @dev Locks down all actions except administrative actions. Should be used\r\n  * to address security flaws. If this contract has a critical bug, This method\r\n  * should be called to allow for a hault of operations and a migration to occur\r\n  * If this method is called due to a loss of server keys, it will hault\r\n  * operation until root cause may be found.\r\n  **/\r\n  function pause()\r\n  public\r\n  onlyAdmin\r\n  notPaused\r\n  returns (bool) {\r\n    paused = true;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Releases system from administrative lockdown. Requires retrieval of\r\n  * failsafe coldwallet.\r\n  **/\r\n  function unpause()\r\n  public\r\n  onlyFailsafe\r\n  returns (bool) {\r\n    paused = false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Locks down all actions FOREVER! This should only be used in\r\n  * manual contract migration due to critical bug. This will halt all\r\n  *operations and allow a new contract to be built by transfering all balances.\r\n  **/\r\n  function lockForever()\r\n  public\r\n  onlyFailsafe\r\n  returns (bool) {\r\n    pause();\r\n    setOwner(address(this));\r\n    setFailsafe(address(this));\r\n    return true;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Panic Logic\r\n\r\n  /**\r\n  * @dev Lets everyone know if something catastrophic has occured. The owner,\r\n  * and failsafe should not ever be the same entity. This combined with a paused\r\n  * state indicates that panic has most likely been called or this contract has\r\n  * been permanently locked for migration.\r\n  */\r\n  function isBadDay()\r\n  public\r\n  view\r\n  returns (bool) {\r\n    return (isPaused() && (owner == failsafe));\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //ERC20Lib Wrappers\r\n\r\n  /**\r\n  * @dev These methods act as transparent wrappers around the ERC20Lib. The\r\n  * only changes in logic are as follows:\r\n  *  - The msg.sender must be explicitly set by the wrapper\r\n  *  - The totalSupply has been broken up into 3 functions as totalSupply\r\n  *    pendingSupply, and activeSupply.\r\n  * Pending supply is the supply that has been deposited but not released\r\n  * Active supply is the released deposited supply\r\n  * Total supply is the sum of active and pending.\r\n  */\r\n  function totalSupply()\r\n  public\r\n  view\r\n  returns (uint256) {\r\n    uint256 supply = 0;\r\n    supply = supply.add(pending.totalSupply());\r\n    supply = supply.add(token.totalSupply());\r\n    return supply;\r\n  }\r\n\r\n  function pendingSupply()\r\n  public\r\n  view\r\n  returns (uint256) {\r\n    return pending.totalSupply();\r\n  }\r\n\r\n  function availableSupply()\r\n  public\r\n  view\r\n  returns (uint256) {\r\n    return token.totalSupply();\r\n  }\r\n\r\n  function balanceOf(address account)\r\n  public\r\n  view\r\n  returns (uint256) {\r\n    return token.balances(account);\r\n  }\r\n\r\n  function allowance(address account, address spender)\r\n  public\r\n  view\r\n  returns (uint256) {\r\n    return token.allowance(account,spender);\r\n  }\r\n\r\n  function transfer(address to, uint256 value)\r\n  public\r\n  notPaused\r\n  returns (bool) {\r\n    token.transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint256 value)\r\n  public\r\n  notPaused\r\n  returns (bool) {\r\n    token.approve(msg.sender,spender,value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n  public\r\n  notPaused\r\n  returns (bool) {\r\n    token.transferFrom(msg.sender,from,to,value);\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n  public\r\n  notPaused\r\n  returns (bool) {\r\n    token.increaseAllowance(msg.sender,spender,addedValue);\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n  public\r\n  notPaused\r\n  returns (bool) {\r\n    token.decreaseAllowance(msg.sender,spender,subtractedValue);\r\n    return true;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Deposit Logic\r\n\r\n  /**\r\n  * @dev This logic allows for a delay between a deposit\r\n  * and the release of funds. This is accomplished by maintaining\r\n  * two independant ERC20 contracts in this one contract by using\r\n  * the ERC20Lib library.\r\n  * The first is the token contract that is used to transfer value\r\n  * as is normally expected of an ERC20. The second is the system\r\n  * that allows Ven to be dposited and withdrawn from the\r\n  * blockchain such that no extra priveledge is given to HubCulture\r\n  * for on blockchain actions. This system also allows for the time\r\n  * delay based approval of deposits. Further, the entity that\r\n  * creates a deposit request is an authority, but only a vault\r\n  * may release the deposit into the active balances of the ERC20\r\n  * token.\r\n  */\r\n\r\n\r\n  /**\r\n  * @dev Deposit value from HubCulture into ERC20\r\n  * This is a pending deposit that must be released.\r\n  * Only an authority may request a deposit.\r\n  */\r\n  function deposit(address account, uint256 value)\r\n  public\r\n  notPaused\r\n  onlyAuthority\r\n  returns (bool) {\r\n    pending.mint(account,value);\r\n    eventNonce+=1;\r\n    emit Pending(account,value,eventNonce);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Release a deposit from pending state and credit\r\n  * account with the balance due.\r\n  */\r\n  function releaseDeposit(address account, uint256 value)\r\n  public\r\n  notPaused\r\n  onlyVault\r\n  returns (bool) {\r\n    pending.burn(account,value);\r\n    token.mint(account,value);\r\n    eventNonce+=1;\r\n    emit Deposit(account,value,eventNonce);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Cancel a deposit. This prevents the deposit from\r\n  * being released.\r\n  */\r\n  function revokeDeposit(address account, uint256 value)\r\n  public\r\n  notPaused\r\n  onlyVault\r\n  returns (bool) {\r\n    pending.burn(account,value);\r\n    eventNonce+=1;\r\n    emit Decline(account,value,eventNonce);\r\n    return true;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Withdraw Logic\r\n\r\n  /**\r\n  * @dev Withdraw tokens by burning the balance and emitting the event.\r\n  * In order to withdraw the account must be a registered wallet. This is\r\n  * to prevent loss of funds.\r\n  */\r\n  function withdraw(uint256 value)\r\n  public\r\n  notPaused\r\n  returns (bool) {\r\n    require(registered[msg.sender]);\r\n    token.burn(msg.sender,value);\r\n    eventNonce+=1;\r\n    emit Withdraw(msg.sender,value,eventNonce);\r\n    return true;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  //Wallet Registration Logic\r\n\r\n  /**\r\n  * @dev Allows the registration state of a wallet to be queried.\r\n  */\r\n  function isRegistered(address wallet)\r\n  public\r\n  view\r\n  returns (bool) {\r\n    return registered[wallet];\r\n  }\r\n\r\n  /**\r\n  * @dev Allows a HubCulture user to claim thier wallet. This system works\r\n  * as follows:\r\n  *  - User must enter the address they wish to claim on HubCulture\r\n  *  - The user will be provided with a UUID that will be a randomly\r\n  *      generated value (salt) hashed with the user ID for this user.\r\n  *  -  The keccak256 of the uuid and account address will then be\r\n  *      signed by an authority to ensure authenticity.\r\n  *  -  The user must submit a transaction, from the claimed account, with\r\n  *      the uuid, proof, and signature from the authority as arguments to\r\n  *      this method.\r\n  * If all checks pass, the account registration event should be emitted,\r\n  * and this account may now withdraw Ven to HubCulture.\r\n  */\r\n  function register(bytes32 uuid, uint8 v, bytes32 r, bytes32 s)\r\n  public\r\n  notPaused\r\n  returns (bool) {\r\n    require(authorities[ecrecover(keccak256(abi.encodePacked(msg.sender,uuid)),v,r,s)]);\r\n    registered[msg.sender]=true;\r\n    eventNonce+=1;\r\n    emit Registration(msg.sender, uuid, eventNonce);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows an authority to unregister an account. This will prevent\r\n  * a withdraw comand from being issued by this account unless it is\r\n  * re-registered. This is not a security feature. This is a cleanup\r\n  * function to ensure that closed accounts become zeroed out to minimize\r\n  * chain bloat.\r\n  */\r\n  function unregister(address wallet)\r\n  public\r\n  notPaused\r\n  onlyAuthority\r\n  returns (bool) {\r\n    registered[wallet] = false;\r\n    eventNonce+=1;\r\n    emit Unregistered(wallet, eventNonce);\r\n    return true;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////////\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"revokeDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"isAuthority\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"addVault\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"addAuthority\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"unregister\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBadDay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_failsafe\",\"type\":\"address\"}],\"name\":\"setFailsafe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"releaseDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"isVault\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_failsafe\",\"type\":\"address\"}],\"name\":\"isFailsafe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockForever\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"removeVault\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"removeAuthority\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_failsafe\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Pending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Decline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"uuid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Unregistered\",\"type\":\"event\"}]","ContractName":"HubCulture","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b2cae47cb1fd1eaef61a68f74258cd953e3fc362000000000000000000000000b2cae47cb1fd1eaef61a68f74258cd953e3fc362","Library":"","SwarmSource":"bzzr://06b974ed5c46dc1a26d6bf07e5a0eb110d77d58f956bf3d04e34cb26ce870235"}]}