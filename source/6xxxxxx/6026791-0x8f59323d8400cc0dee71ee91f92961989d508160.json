{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * DO NOT SEND ETH TO THIS CONTRACT ON MAINNET.  ITS ONLY DEPLOYED ON MAINNET TO\r\n * DISPROVE SOME FALSE CLAIMS ABOUT FOMO3D AND JEKYLL ISLAND INTERACTION.  YOU \r\n * CAN TEST ALL THE PAYABLE FUNCTIONS SENDING 0 ETH.  OR BETTER YET COPY THIS TO \r\n * THE TESTNETS.\r\n * \r\n * IF YOU SEND ETH TO THIS CONTRACT IT CANNOT BE RECOVERED.  THERE IS NO WITHDRAW.\r\n * \r\n * THE CHECK BALANCE FUNCTIONS ARE FOR WHEN TESTING ON TESTNET TO SHOW THAT ALTHOUGH \r\n * THE CORP BANK COULD BE FORCED TO REVERT TX'S OR TRY AND BURN UP ALL/MOST GAS\r\n * FOMO3D STILL MOVES ON WITHOUT RISK OF LOCKING UP.  AND IN CASES OF REVERT OR  \r\n * OOG INSIDE CORP BANK.  ALL WE AT TEAM JUST WOULD ACCOMPLISH IS JUSTING OURSELVES \r\n * OUT OF THE ETH THAT WAS TO BE SENT TO JEKYLL ISLAND.  FOREVER LEAVING IT UNCLAIMABLE\r\n * IN FOMO3D CONTACT.  SO WE CAN ONLY HARM OURSELVES IF WE TRIED SUCH A USELESS \r\n * THING.  AND FOMO3D WILL CONTINUE ON, UNAFFECTED\r\n */\r\n\r\n// this is deployed on mainnet at:  0x38aEfE9e8E0Fc938475bfC6d7E52aE28D39FEBD8\r\ncontract Fomo3d {\r\n    // create some data tracking vars for testing\r\n    bool public depositSuccessful_;\r\n    uint256 public successfulTransactions_;\r\n    uint256 public gasBefore_;\r\n    uint256 public gasAfter_;\r\n    \r\n    // create forwarder instance\r\n    Forwarder Jekyll_Island_Inc;\r\n    \r\n    // take addr for forwarder in constructor arguments\r\n    constructor(address _addr)\r\n        public\r\n    {\r\n        // set up forwarder to point to its contract location\r\n        Jekyll_Island_Inc = Forwarder(_addr);\r\n    }\r\n\r\n    // some fomo3d function that deposits to Forwarder\r\n    function someFunction()\r\n        public\r\n        payable\r\n    {\r\n        // grab gas left\r\n        gasBefore_ = gasleft();\r\n        \r\n        // deposit to forwarder, uses low level call so forwards all gas\r\n        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(\"deposit()\"))))  \r\n        {\r\n            // give fomo3d work to do that needs gas. what better way than storage \r\n            // write calls, since their so costly.\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n        } else {\r\n            depositSuccessful_ = true;\r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n        }\r\n    }\r\n    \r\n    // some fomo3d function that deposits to Forwarder\r\n    function someFunction2()\r\n        public\r\n        payable\r\n    {\r\n        // grab gas left\r\n        gasBefore_ = gasleft();\r\n        \r\n        // deposit to forwarder, uses low level call so forwards all gas\r\n        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(\"deposit2()\"))))  \r\n        {\r\n            // give fomo3d work to do that needs gas. what better way than storage \r\n            // write calls, since their so costly.\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n        } else {\r\n            depositSuccessful_ = true;\r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n        }\r\n    }\r\n    \r\n    // some fomo3d function that deposits to Forwarder\r\n    function someFunction3()\r\n        public\r\n        payable\r\n    {\r\n        // grab gas left\r\n        gasBefore_ = gasleft();\r\n        \r\n        // deposit to forwarder, uses low level call so forwards all gas\r\n        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(\"deposit3()\"))))  \r\n        {\r\n            // give fomo3d work to do that needs gas. what better way than storage \r\n            // write calls, since their so costly.\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n        } else {\r\n            depositSuccessful_ = true;\r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n        }\r\n    }\r\n    \r\n    // some fomo3d function that deposits to Forwarder\r\n    function someFunction4()\r\n        public\r\n        payable\r\n    {\r\n        // grab gas left\r\n        gasBefore_ = gasleft();\r\n        \r\n        // deposit to forwarder, uses low level call so forwards all gas\r\n        if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(\"deposit4()\"))))  \r\n        {\r\n            // give fomo3d work to do that needs gas. what better way than storage \r\n            // write calls, since their so costly.\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n        } else {\r\n            depositSuccessful_ = true;\r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n        }\r\n    }\r\n    \r\n    // for data tracking lets make a function to check this contracts balance\r\n    function checkBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(address(this).balance);\r\n    }\r\n    \r\n}\r\n\r\n\r\n// heres a sample forwarder with a copy of the jekyll island forwarder (requirements on \r\n// msg.sender removed for simplicity since its irrelevant to testing this.  and some\r\n// tracking vars added for test.)\r\n\r\n// this is deployed on mainnet at:  0x8F59323d8400CC0deE71ee91f92961989D508160\r\ncontract Forwarder {\r\n    // lets create some tracking vars \r\n    bool public depositSuccessful_;\r\n    uint256 public successfulTransactions_;\r\n    uint256 public gasBefore_;\r\n    uint256 public gasAfter_;\r\n    \r\n    // create an instance of the jekyll island bank \r\n    Bank currentCorpBank_;\r\n    \r\n    // take an address in the constructor arguments to set up bank with \r\n    constructor(address _addr)\r\n        public\r\n    {\r\n        // point the created instance to the address given\r\n        currentCorpBank_ = Bank(_addr);\r\n    }\r\n    \r\n    function deposit()\r\n        public \r\n        payable\r\n        returns(bool)\r\n    {\r\n        // grab gas at start\r\n        gasBefore_ = gasleft();\r\n        \r\n        if (currentCorpBank_.deposit.value(msg.value)(msg.sender) == true) {\r\n            depositSuccessful_ = true;    \r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n            return(true);\r\n        } else {\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n            return(false);\r\n        }\r\n    }\r\n    \r\n    function deposit2()\r\n        public \r\n        payable\r\n        returns(bool)\r\n    {\r\n        // grab gas at start\r\n        gasBefore_ = gasleft();\r\n        \r\n        if (currentCorpBank_.deposit2.value(msg.value)(msg.sender) == true) {\r\n            depositSuccessful_ = true;    \r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n            return(true);\r\n        } else {\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n            return(false);\r\n        }\r\n    }\r\n    \r\n    function deposit3()\r\n        public \r\n        payable\r\n        returns(bool)\r\n    {\r\n        // grab gas at start\r\n        gasBefore_ = gasleft();\r\n        \r\n        if (currentCorpBank_.deposit3.value(msg.value)(msg.sender) == true) {\r\n            depositSuccessful_ = true;    \r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n            return(true);\r\n        } else {\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n            return(false);\r\n        }\r\n    }\r\n    \r\n    function deposit4()\r\n        public \r\n        payable\r\n        returns(bool)\r\n    {\r\n        // grab gas at start\r\n        gasBefore_ = gasleft();\r\n        \r\n        if (currentCorpBank_.deposit4.value(msg.value)(msg.sender) == true) {\r\n            depositSuccessful_ = true;    \r\n            successfulTransactions_++;\r\n            gasAfter_ = gasleft();\r\n            return(true);\r\n        } else {\r\n            depositSuccessful_ = false;\r\n            gasAfter_ = gasleft();\r\n            return(false);\r\n        }\r\n    }\r\n    \r\n    // for data tracking lets make a function to check this contracts balance\r\n    function checkBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(address(this).balance);\r\n    }\r\n    \r\n}\r\n\r\n// heres the bank with various ways someone could try and migrate to a bank that \r\n// screws the tx.  to show none of them effect fomo3d.\r\n\r\n// this is deployed on mainnet at:  0x0C2DBC98581e553C4E978Dd699571a5DED408a4F\r\ncontract Bank {\r\n    // lets use storage writes to this to burn up all gas\r\n    uint256 public i = 1000000;\r\n    uint256 public x;\r\n    address public fomo3d;\r\n    \r\n    /**\r\n     * this version will use up most gas.  but return just enough to make it back\r\n     * to fomo3d.  yet not enough for fomo3d to finish its execution (according to \r\n     * the theory of the exploit.  which when you run this you'll find due to my \r\n     * use of ! in the call from fomo3d to forwarder, and the use of a normal function \r\n     * call from forwarder to bank, this fails to stop fomo3d from continuing)\r\n     */\r\n    function deposit(address _fomo3daddress)\r\n        external\r\n        payable\r\n        returns(bool)\r\n    {\r\n        // burn all gas leaving just enough to get back to fomo3d  and it to do\r\n        // a write call in a attempt to make Fomo3d OOG (doesn't work cause fomo3d \r\n        // protects itself from this behavior)\r\n        while (i > 41000)\r\n        {\r\n            i = gasleft();\r\n        }\r\n        \r\n        return(true);\r\n    }\r\n    \r\n    /**\r\n     * this version just tries a plain revert.  (pssst... fomo3d doesn't care)\r\n     */\r\n    function deposit2(address _fomo3daddress)\r\n        external\r\n        payable\r\n        returns(bool)\r\n    {\r\n        // straight up revert (since we use low level call in fomo3d it doesn't \r\n        // care if we revert the internal tx to bank.  this behavior would only \r\n        // screw over team just, not effect fomo3d)\r\n        revert();\r\n    }\r\n    \r\n    /**\r\n     * this one tries an infinite loop (another fail.  fomo3d trudges on)\r\n     */\r\n    function deposit3(address _fomo3daddress)\r\n        external\r\n        payable\r\n        returns(bool)\r\n    {\r\n        // this infinite loop still does not stop fomo3d from running.\r\n        while(1 == 1) {\r\n            x++;\r\n            fomo3d = _fomo3daddress;\r\n        }\r\n        return(true);\r\n    }\r\n    \r\n    /**\r\n     * this one just runs a set length loops that OOG's (and.. again.. fomo3d still works)\r\n     */\r\n    function deposit4(address _fomo3daddress)\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        // burn all gas (fomo3d still keeps going)\r\n        for (uint256 i = 0; i <= 1000; i++)\r\n        {\r\n            x++;\r\n            fomo3d = _fomo3daddress;\r\n        }\r\n    }\r\n    \r\n    // for data tracking lets make a function to check this contracts balance\r\n    function checkBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"depositSuccessful_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"successfulTransactions_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit3\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasAfter_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasBefore_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit4\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Forwarder","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000c2dbc98581e553c4e978dd699571a5ded408a4f","Library":"","SwarmSource":"bzzr://9b76470bfaf56b247dc881973f006937f2d2b20b018478e7fe7634a36244fc86"}]}