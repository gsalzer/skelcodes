{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract DiceGame {\r\n   \r\n    uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\r\n    uint constant MIN_BET = 0.01 ether;\r\n    uint constant MAX_AMOUNT = 1000 ether;\r\n    uint constant MAX_ROLL_UNDER = 96;\r\n    uint constant MIN_ROLL_UNDER = 1;\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n    address public croupier;\r\n    uint public maxProfit;\r\n    uint128 public lockedInBets;\r\n    uint128 public lockedInviteProfits;\r\n\r\n    // A structure representing a single bet.\r\n    struct Game {\r\n        uint amount;\r\n        uint8 rollUnder;\r\n        uint40 placeBlockNumber;\r\n        address player;\r\n        address inviter;\r\n        bool finished;\r\n    }\r\n\r\n    mapping (uint => Game) public bets;\r\n    mapping (bytes32 => bool) public administrators;\r\n    mapping (address => uint) public inviteProfits;\r\n\r\n    \r\n    // Events \r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event Payment(address indexed beneficiary, uint amount);\r\n    event ShowResult(uint reveal, uint result );\r\n    event Commit(uint commit);\r\n\r\n\r\n    modifier onlyAdmin {\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[keccak256(abi.encodePacked(_customerAddress))], \"Only Admin could call this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCroupier {\r\n        require (msg.sender == croupier, \"Only croupier could call this function\");\r\n        _;\r\n    }\r\n\r\n    constructor (address _croupier, uint _maxProfit) public {\r\n        administrators[0x4c709c79c406763d17c915eedc9f1af255061e3bf2e93e236a24e01486c7713a] = true;\r\n        croupier = _croupier;\r\n        require(_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number\");\r\n        maxProfit = _maxProfit;\r\n        lockedInBets = 0;\r\n        lockedInviteProfits = 0;\r\n    }\r\n\r\n    function() public payable {\r\n    }\r\n\r\n    function setAdministrator(bytes32 _identifier, bool _status) external onlyAdmin {\r\n        administrators[_identifier] = _status;\r\n    }\r\n\r\n    function setCroupier(address newCroupier) external onlyAdmin {\r\n        croupier = newCroupier;\r\n    }\r\n\r\n    function setMaxProfit(uint _maxProfit) external onlyAdmin {\r\n        require (_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    function withdrawFunds(address beneficiary, uint withdrawAmount) external onlyAdmin {\r\n        require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\r\n        sendFunds(beneficiary, withdrawAmount);\r\n    }\r\n\r\n    function kill(address _owner) external onlyAdmin {\r\n        require (lockedInBets == 0, \"All games should be processed (settled or refunded) before self-destruct.\");\r\n        selfdestruct(_owner);\r\n    }\r\n\r\n    function placeGame(\r\n        uint rollUnder, \r\n        uint commitLastBlock, \r\n        uint commit, \r\n        bytes32 r, \r\n        bytes32 s,\r\n        address inviter\r\n    ) external payable {\r\n        Game storage bet = bets[commit];\r\n        require (bet.player == address(0), \"Game should be in a 'clean' state.\");\r\n        require (msg.sender != inviter, \"Player and inviter should be different\");\r\n        uint amount = msg.value;\r\n        require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be in range\");\r\n        require (block.number <= commitLastBlock, \"Commit has expired\");\r\n\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(prefix,commit));\r\n\r\n        require (croupier == ecrecover(signatureHash, 27, r, s), \"Invalid signature\");\r\n        require (rollUnder >= MIN_ROLL_UNDER && rollUnder <= MAX_ROLL_UNDER, \"Roll under should be within range.\");\r\n        \r\n        uint possibleWinAmount;\r\n        uint inviteProfit;\r\n        address amountInvitor = inviter != croupier ? inviter : 0;\r\n\r\n        (possibleWinAmount,inviteProfit) = getDiceWinAmount(amount, rollUnder, amountInvitor);\r\n\r\n        require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation.\");\r\n\r\n        lockedInBets += uint128(possibleWinAmount);\r\n        lockedInviteProfits += uint128(inviteProfit);\r\n\r\n        require ((lockedInBets + lockedInviteProfits)  <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        emit Commit(commit);\r\n\r\n        bet.amount = amount;\r\n        bet.rollUnder = uint8(rollUnder);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.player = msg.sender;\r\n        bet.finished = false;\r\n        if (inviter != croupier) {\r\n            bet.inviter = inviter;\r\n        }\r\n    }\r\n\r\n    function settleGame(uint reveal, bytes32 blockHash) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Game storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        require (block.number > placeBlockNumber, \"settleGame in the same block as placeGame, or before.\");\r\n        require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Game has expired\");\r\n        require (blockhash(placeBlockNumber) == blockHash, \"Blockhash is not correct\");\r\n\r\n        settleGameCommon(bet, reveal, blockHash);\r\n    }\r\n\r\n    function refundGame(uint commit) external {\r\n        Game storage bet = bets[commit];\r\n        bet.finished = true;\r\n        uint amount = bet.amount;\r\n\r\n        require (amount != 0, \"Game should be in an 'active' state\");\r\n\r\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Game has not expired yet\");\r\n\r\n        bet.amount = 0;\r\n\r\n        uint diceWinAmount;\r\n        uint inviteProfit;\r\n        (diceWinAmount,inviteProfit) = getDiceWinAmount(amount, bet.rollUnder, bet.inviter);\r\n\r\n        lockedInBets -= uint128(diceWinAmount);\r\n\r\n        sendFunds(bet.player, amount);\r\n    }\r\n\r\n    function withdrawInvitationProfit() external {\r\n        uint amount = inviteProfits[msg.sender];\r\n        require(amount > 0, \"no profit\");\r\n        inviteProfits[msg.sender] = 0;\r\n        lockedInviteProfits -= uint128(amount);\r\n        sendFunds(msg.sender, amount);\r\n    }\r\n\r\n    function getInvitationBalance() external view returns (uint profit){\r\n        profit = inviteProfits[msg.sender];\r\n    }\r\n\r\n  \r\n    function settleGameCommon(Game storage bet, uint reveal, bytes32 entropyBlockHash) private {\r\n        uint amount = bet.amount;\r\n        uint rollUnder = bet.rollUnder;\r\n        address player = bet.player;\r\n\r\n        require (amount != 0, \"Game should be in an 'active' state\");\r\n        bet.amount = 0;\r\n\r\n        bytes32 seed = keccak256(abi.encodePacked(reveal, entropyBlockHash));\r\n\r\n        uint dice = uint(seed) % 100 + 1;\r\n        \r\n        emit ShowResult(reveal, dice);\r\n\r\n        uint diceWinAmount;\r\n        uint inviteProfit;\r\n        \r\n        (diceWinAmount, inviteProfit) = getDiceWinAmount(amount, rollUnder, bet.inviter);\r\n\r\n        uint diceWin = 0;\r\n        \r\n        if (dice <= rollUnder) {\r\n            diceWin = diceWinAmount;\r\n        }\r\n        lockedInBets -= uint128(diceWinAmount);\r\n        inviteProfits[bet.inviter] += inviteProfit;\r\n        \r\n        bet.finished = true;\r\n        sendFunds(player, diceWin);\r\n    }\r\n\r\n    function sendFunds(address beneficiary, uint amount) private {\r\n        if (amount > 0){\r\n            if (beneficiary.send(amount)) {\r\n                emit Payment(beneficiary, amount);\r\n            } else {\r\n                emit FailedPayment(beneficiary, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function getDiceWinAmount(uint amount, uint rollUnder, address inviter) private pure returns (uint winAmount, uint inviteProfit) {\r\n        require (MIN_ROLL_UNDER <= rollUnder && rollUnder <= MAX_ROLL_UNDER, \"Win probability out of range.\");\r\n        uint houseEdge = amount / 50;\r\n        inviteProfit = 0;\r\n        if (inviter > 0) {\r\n            inviteProfit = amount / 100;\r\n            houseEdge = amount / 100;   \r\n        }\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        require (houseEdge <= amount, \"Bet doesn't even cover house edge.\");\r\n        winAmount = (amount - houseEdge - inviteProfit) * 100 / rollUnder;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lockedInviteProfits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"placeGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"rollUnder\",\"type\":\"uint8\"},{\"name\":\"placeBlockNumber\",\"type\":\"uint40\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"inviter\",\"type\":\"address\"},{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawInvitationProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"croupier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviteProfits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvitationBalance\",\"outputs\":[{\"name\":\"profit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"setCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_croupier\",\"type\":\"address\"},{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"reveal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"ShowResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"Commit\",\"type\":\"event\"}]","ContractName":"DiceGame","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ab3204d4ae7d4bbff4207df0946d6728dcc35e7100000000000000000000000000000000000000000000000029a2241af62c0000","Library":"","SwarmSource":"bzzr://4f16e6739aeb0ea3e1048a6c733b85ffecf1df7cac099aa5d09210ab6a6f8f4a"}]}