{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n// expansion on original contract from dav's stronghands contract\r\n\r\n// introducing features:\r\n// Jackpot - 1 in 1000 chance to get jackpot upon losing\r\n// Refund line for loser to get their initial eth back\r\n\r\n// eth distribution:\r\n// each game seeds 0.01 eth to buy P3D with\r\n// each game seeds 0.005 eth to the refund line making a minimum payback each 20 games played\r\n// 0.1 eth to play per player each round\r\n\r\n\r\n// expansion Coded by spielley \r\n\r\n// Thank you for playing Spielleys contract creations.\r\n// spielley is not liable for any contract bugs and exploits known or unknown.\r\ncontract Slaughter3D {\r\n    using SafeMath for uint;\r\n    struct Stage {\r\n        uint8 numberOfPlayers;\r\n        uint256 blocknumber;\r\n        bool finalized;\r\n        mapping (uint8 => address) slotXplayer;\r\n        mapping (address => bool) players;\r\n        mapping (uint8 => address) setMN;\r\n        \r\n    }\r\n    \r\n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\r\n    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\r\n    uint256 constant private P3D_SHARE = 0.005 ether;\r\n    \r\n    uint8 constant public MAX_PLAYERS_PER_STAGE = 2;\r\n    uint256 constant public OFFER_SIZE = 0.1 ether;\r\n    uint256 public Refundpot;\r\n    uint256 public Jackpot;// 1% of P3D divs to be allocated to the Jackpot\r\n    uint256 public SPASMfee;//1% of P3D divs to be shared with SPASM holders\r\n    mapping(address => uint256) public ETHtoP3Dbymasternode; //eth to buy P3D masternode\r\n    \r\n    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\r\n    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \r\n    uint256 public winningsPerRound = 0.185 ether;\r\n    \r\n    mapping(address => string) public Vanity;\r\n    mapping(address => uint256) private playerVault;\r\n    mapping(uint256 => Stage) public stages;\r\n    mapping(uint256 => address) public RefundWaitingLine;\r\n    mapping(uint256 => address) public Loser;\r\n    uint256 public  NextInLine;//next person to be refunded\r\n    uint256 public  NextAtLineEnd;//next spot to add loser\r\n    uint256 private numberOfFinalizedStages;\r\n    \r\n    uint256 public numberOfStages;\r\n    \r\n    event JackpotWon(address indexed winner, uint256 SizeOfJackpot);\r\n    event SacrificeOffered(address indexed player);\r\n    event SacrificeChosen(address indexed sarifice);\r\n    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\r\n    event StageInvalidated(uint256 indexed stage);\r\n    // UI view functions\r\n    \r\n    function previousstagedata()\r\n        public\r\n        view\r\n        returns(address loser , address player1, string van1 ,address player2, string van2 )\r\n    {\r\n        return (Loser[numberOfFinalizedStages],stages[numberOfFinalizedStages].slotXplayer[0],Vanity[stages[numberOfFinalizedStages].slotXplayer[0]],stages[numberOfFinalizedStages].slotXplayer[1],Vanity[stages[numberOfFinalizedStages].slotXplayer[1]]);\r\n    }\r\n    function currentstagedata()\r\n        public\r\n        view\r\n        returns( address player1, string van1 ,address player2, string van2 )\r\n    {\r\n        return (stages[numberOfStages].slotXplayer[0],Vanity[stages[numberOfStages].slotXplayer[0]],stages[numberOfStages].slotXplayer[1],Vanity[stages[numberOfStages].slotXplayer[1]]);\r\n    }\r\n    function jackpotinfo()\r\n        public\r\n        view\r\n        returns(uint256 SizeOfJackpot )\r\n    {\r\n        return (Jackpot);\r\n    }\r\n    function checkstatus()\r\n        public\r\n        view\r\n        returns(bool CanStartBattle )\r\n    {\r\n        bool check;\r\n        if(numberOfStages >= numberOfFinalizedStages)\r\n        {\r\n            if(!stages[numberOfFinalizedStages].finalized && stages[numberOfFinalizedStages].numberOfPlayers < MAX_PLAYERS_PER_STAGE && stages[numberOfFinalizedStages].blocknumber != 0)\r\n            {\r\n                check = true;\r\n            }\r\n        }\r\n        return (check);\r\n    }\r\n    function Refundlineinfo()\r\n        public\r\n        view\r\n        returns(address NextAdresstoRefund, uint256 LengthUnpaidLine,uint256 divsunfetched, uint256 refundpot , string vanityofnexttoberefunded)\r\n    {\r\n        LengthUnpaidLine = NextAtLineEnd - NextInLine;\r\n        uint256 dividends = p3dContract.myDividends(true);\r\n        return (RefundWaitingLine[NextInLine],LengthUnpaidLine, dividends , Refundpot ,Vanity[RefundWaitingLine[NextInLine]]);\r\n    }\r\n    // expansion functions\r\n    \r\n    // Buy P3D by masternode \r\n    function Expand(address masternode) public \r\n    {\r\n    uint256 amt = ETHtoP3Dbymasternode[masternode];\r\n    ETHtoP3Dbymasternode[masternode] = 0;\r\n    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\r\n    p3dContract.buy.value(amt)(masternode);\r\n    \r\n    }\r\n    //fetch P3D divs\r\n    function DivsToRefundpot ()public\r\n    {\r\n        //allocate p3d dividends to contract \r\n            uint256 dividends = p3dContract.myDividends(true);\r\n            require(dividends > 0);\r\n            uint256 base = dividends.div(100);\r\n            p3dContract.withdraw();\r\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\r\n            Refundpot = Refundpot.add(base.mul(94));\r\n            Jackpot = Jackpot.add(base.mul(5)); // allocation to jackpot\r\n            //\r\n    }\r\n    //Donate to losers\r\n    function DonateToLosers ()public payable\r\n    {\r\n            require(msg.value > 0);\r\n            Refundpot = Refundpot.add(msg.value);\r\n\r\n    }\r\n    // next loser payout\r\n    function Payoutnextrefund ()public\r\n    {\r\n        //allocate p3d dividends to sacrifice if existing\r\n            uint256 Pot = Refundpot;\r\n            require(Pot > 0.1 ether);\r\n            Refundpot -= 0.1 ether;\r\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\r\n            NextInLine++;\r\n            //\r\n    }\r\n    //changevanity\r\n    function changevanity(string van , address masternode) public payable\r\n    {\r\n    require(msg.value >= 1  finney);\r\n    Vanity[msg.sender] = van;\r\n    uint256 amt = ETHtoP3Dbymasternode[masternode].add(msg.value);\r\n    ETHtoP3Dbymasternode[masternode] = 0;\r\n    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\r\n    p3dContract.buy.value(amt)(masternode);\r\n    }\r\n    // Sac dep\r\n    modifier isValidOffer()\r\n    {\r\n        require(msg.value == OFFER_SIZE);\r\n        _;\r\n    }\r\n    \r\n    modifier canPayFromVault()\r\n    {\r\n        require(playerVault[msg.sender] >= OFFER_SIZE);\r\n        _;\r\n    }\r\n    \r\n    modifier hasEarnings()\r\n    {\r\n        require(playerVault[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier prepareStage()\r\n    {\r\n        //create a new stage if current has reached max amount of players\r\n        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\r\n           stages[numberOfStages] = Stage(0, 0, false );\r\n           numberOfStages++;\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier isNewToStage()\r\n    {\r\n        require(stages[numberOfStages - 1].players[msg.sender] == false);\r\n        _;\r\n    }\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        stages[numberOfStages] = Stage(0, 0, false);\r\n        numberOfStages++;\r\n    }\r\n    \r\n    function() external payable {}\r\n    \r\n    function offerAsSacrifice(address MN)\r\n        external\r\n        payable\r\n        isValidOffer\r\n        prepareStage\r\n        isNewToStage\r\n    {\r\n        acceptOffer(MN);\r\n        \r\n        //try to choose a sacrifice in an already full stage (finalize a stage)\r\n        tryFinalizeStage();\r\n    }\r\n    \r\n    function offerAsSacrificeFromVault(address MN)\r\n        external\r\n        canPayFromVault\r\n        prepareStage\r\n        isNewToStage\r\n    {\r\n        playerVault[msg.sender] -= OFFER_SIZE;\r\n        \r\n        acceptOffer(MN);\r\n        \r\n        tryFinalizeStage();\r\n    }\r\n    \r\n    function withdraw()\r\n        external\r\n        hasEarnings\r\n    {\r\n        tryFinalizeStage();\r\n        \r\n        uint256 amount = playerVault[msg.sender];\r\n        playerVault[msg.sender] = 0;\r\n        \r\n        emit EarningsWithdrawn(msg.sender, amount); \r\n        \r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    function myEarnings()\r\n        external\r\n        view\r\n        hasEarnings\r\n        returns(uint256)\r\n    {\r\n        return playerVault[msg.sender];\r\n    }\r\n    \r\n    function currentPlayers()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return stages[numberOfStages - 1].numberOfPlayers;\r\n    }\r\n    \r\n    function acceptOffer(address MN)\r\n        private\r\n    {\r\n        Stage storage currentStage = stages[numberOfStages - 1];\r\n        \r\n        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\r\n        \r\n        address player = msg.sender;\r\n        \r\n        //add player to current stage\r\n        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\r\n        currentStage.numberOfPlayers++;\r\n        currentStage.players[player] = true;\r\n        currentStage.setMN[currentStage.numberOfPlayers] = MN;\r\n        emit SacrificeOffered(player);\r\n        \r\n        //add blocknumber to current stage when the last player is added\r\n        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\r\n            currentStage.blocknumber = block.number;\r\n        }\r\n        \r\n    }\r\n    \r\n    function tryFinalizeStage()\r\n        public\r\n    {\r\n        assert(numberOfStages >= numberOfFinalizedStages);\r\n        \r\n        //there are no stages to finalize\r\n        if(numberOfStages == numberOfFinalizedStages) {return;}\r\n        \r\n        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\r\n        \r\n        assert(!stageToFinalize.finalized);\r\n        \r\n        //stage is not ready to be finalized\r\n        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\r\n        \r\n        assert(stageToFinalize.blocknumber != 0);\r\n        \r\n        //check if blockhash can be determined\r\n        if(block.number - 256 <= stageToFinalize.blocknumber) {\r\n            //blocknumber of stage can not be equal to current block number -> blockhash() won't work\r\n            if(block.number == stageToFinalize.blocknumber) {return;}\r\n                \r\n            //determine sacrifice\r\n            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\r\n            uint256 jackpot = uint256(blockhash(stageToFinalize.blocknumber)) % 1000;\r\n            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\r\n            Loser[numberOfFinalizedStages] = sacrifice;\r\n            emit SacrificeChosen(sacrifice);\r\n            \r\n            //allocate winnings to survivors\r\n            allocateSurvivorWinnings(sacrifice);\r\n            \r\n            //check jackpot win\r\n            if(jackpot == 777){\r\n                sacrifice.transfer(Jackpot);\r\n                emit JackpotWon ( sacrifice, Jackpot);\r\n                Jackpot = 0;\r\n            }\r\n            \r\n            \r\n            //add sacrifice to refund waiting line\r\n            RefundWaitingLine[NextAtLineEnd] = sacrifice;\r\n            NextAtLineEnd++;\r\n            \r\n            //set eth to MN for buying P3D \r\n            ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[1]].add(0.005 ether);\r\n            ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[2]].add(0.005 ether);\r\n            \r\n            //add 0.005 ether to Refundpot\r\n            Refundpot = Refundpot.add(0.005 ether);\r\n            //purchase p3d (using ref) deprecated\r\n            //p3dContract.buy.value(p3dPerStage)(address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef));\r\n        } else {\r\n            invalidateStage(numberOfFinalizedStages);\r\n            \r\n            emit StageInvalidated(numberOfFinalizedStages);\r\n        }\r\n        //finalize stage\r\n        stageToFinalize.finalized = true;\r\n        numberOfFinalizedStages++;\r\n    }\r\n    \r\n    function allocateSurvivorWinnings(address sacrifice)\r\n        private\r\n    {\r\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\r\n            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\r\n            if(survivor != sacrifice) {\r\n                playerVault[survivor] += winningsPerRound;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function invalidateStage(uint256 stageIndex)\r\n        private\r\n    {\r\n        Stage storage stageToInvalidate = stages[stageIndex];\r\n        \r\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\r\n            address player = stageToInvalidate.slotXplayer[i];\r\n            playerVault[player] += OFFER_SIZE;\r\n        }\r\n    }\r\n}\r\n\r\ninterface HourglassInterface {\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function withdraw() external;\r\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n}\r\ninterface SPASMInterface  {\r\n    function() payable external;\r\n    function disburse() external  payable;\r\n}\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"previousstagedata\",\"outputs\":[{\"name\":\"loser\",\"type\":\"address\"},{\"name\":\"player1\",\"type\":\"address\"},{\"name\":\"van1\",\"type\":\"string\"},{\"name\":\"player2\",\"type\":\"address\"},{\"name\":\"van2\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DonateToLosers\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentstagedata\",\"outputs\":[{\"name\":\"player1\",\"type\":\"address\"},{\"name\":\"van1\",\"type\":\"string\"},{\"name\":\"player2\",\"type\":\"address\"},{\"name\":\"van2\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefundWaitingLine\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Refundlineinfo\",\"outputs\":[{\"name\":\"NextAdresstoRefund\",\"type\":\"address\"},{\"name\":\"LengthUnpaidLine\",\"type\":\"uint256\"},{\"name\":\"divsunfetched\",\"type\":\"uint256\"},{\"name\":\"refundpot\",\"type\":\"uint256\"},{\"name\":\"vanityofnexttoberefunded\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextAtLineEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotinfo\",\"outputs\":[{\"name\":\"SizeOfJackpot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OFFER_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"masternode\",\"type\":\"address\"}],\"name\":\"Expand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MN\",\"type\":\"address\"}],\"name\":\"offerAsSacrifice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"van\",\"type\":\"string\"},{\"name\":\"masternode\",\"type\":\"address\"}],\"name\":\"changevanity\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkstatus\",\"outputs\":[{\"name\":\"CanStartBattle\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ETHtoP3Dbymasternode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DivsToRefundpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stages\",\"outputs\":[{\"name\":\"numberOfPlayers\",\"type\":\"uint8\"},{\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"name\":\"finalized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Vanity\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningsPerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextInLine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tryFinalizeStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Refundpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SPASMfee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfStages\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Payoutnextrefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PLAYERS_PER_STAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MN\",\"type\":\"address\"}],\"name\":\"offerAsSacrificeFromVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Loser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"SizeOfJackpot\",\"type\":\"uint256\"}],\"name\":\"JackpotWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"SacrificeOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sarifice\",\"type\":\"address\"}],\"name\":\"SacrificeChosen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EarningsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stage\",\"type\":\"uint256\"}],\"name\":\"StageInvalidated\",\"type\":\"event\"}]","ContractName":"Slaughter3D","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b035fca0abb6ff7ed8afd2b63fd1faf029ce91c54bdbbce4c4398015b085ab68"}]}