{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;  \r\n////////////////////////////////////////////////////////////////////////////////\r\nlibrary     SafeMath\r\n{\r\n    //--------------------------------------------------------------------------\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0)     return 0;\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return a/b;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nlibrary     StringLib       // (minimal version)\r\n{\r\n    function same(string strA, string strB) internal pure returns(bool)\r\n    {\r\n        return keccak256(abi.encodePacked(strA))==keccak256(abi.encodePacked(strB));        // using abi.encodePacked since solidity v0.4.23\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract    ERC20 \r\n{\r\n    using SafeMath  for uint256;\r\n    using StringLib for string;\r\n\r\n    //----- VARIABLES\r\n\r\n    address public              owner;          // Owner of this contract\r\n    address public              admin;          // The one who is allowed to do changes \r\n\r\n    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\r\n    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\r\n\r\n    //------ TOKEN SPECIFICATION\r\n\r\n    string  public  constant    name       = \"BqtX Token\";\r\n    string  public  constant    symbol     = \"BQTX\";\r\n    uint256 public  constant    decimals   = 18;      // Handle the coin as FIAT (2 decimals). ETH Handles 18 decimal places\r\n    uint256 public  constant    initSupply = 800000000 * 10**decimals;        // 10**18 max\r\n    uint256 public  constant    supplyReserveVal = 600000000 * 10**decimals;          // if quantity => the ##MACRO## addrs \"* 10**decimals\" \r\n\r\n    //-----\r\n\r\n    uint256 public              totalSupply;\r\n    uint256 public              icoSalesSupply   = 0;                   // Needed when burning tokens\r\n    uint256 public              icoReserveSupply = 0;\r\n    uint256 public              softCap = 10000000   * 10**decimals;\r\n    uint256 public              hardCap = 500000000   * 10**decimals;\r\n\r\n    //---------------------------------------------------- smartcontract control\r\n\r\n    uint256 public              icoDeadLine = 1544313600;     // 2018-12-09 00:00 (GMT+0)\r\n\r\n    bool    public              isIcoPaused            = false; \r\n    bool    public              isStoppingIcoOnHardCap = false;\r\n\r\n    //--------------------------------------------------------------------------\r\n\r\n    modifier duringIcoOnlyTheOwner()  // if not during the ico : everyone is allowed at anytime\r\n    { \r\n        require( now>icoDeadLine || msg.sender==owner );\r\n        _;\r\n    }\r\n\r\n    modifier icoFinished()          { require(now > icoDeadLine);           _; }\r\n    modifier icoNotFinished()       { require(now <= icoDeadLine);          _; }\r\n    modifier icoNotPaused()         { require(isIcoPaused==false);          _; }\r\n    modifier icoPaused()            { require(isIcoPaused==true);           _; }\r\n    modifier onlyOwner()            { require(msg.sender==owner);           _; }\r\n    modifier onlyAdmin()            { require(msg.sender==admin);           _; }\r\n\r\n    //----- EVENTS\r\n\r\n    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\r\n    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\r\n\r\n            //---- extra EVENTS\r\n\r\n    event onAdminUserChanged(   address oldAdmin,       address newAdmin);\r\n    event onOwnershipTransfered(address oldOwner,       address newOwner);\r\n    event onAdminUserChange(    address oldAdmin,       address newAdmin);\r\n    event onIcoDeadlineChanged( uint256 oldIcoDeadLine, uint256 newIcoDeadline);\r\n    event onHardcapChanged(     uint256 hardCap,        uint256 newHardCap);\r\n    event icoIsNowPaused(       uint8 newPauseStatus);\r\n    event icoHasRestarted(      uint8 newPauseStatus);\r\n\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    constructor()   public \r\n    {\r\n        owner       = msg.sender;\r\n        admin       = owner;\r\n\r\n        isIcoPaused = false;\r\n        //-----\r\n\r\n        balances[owner] = initSupply;   // send the tokens to the owner\r\n        totalSupply     = initSupply;\r\n        icoSalesSupply  = totalSupply;   \r\n\r\n        //----- Handling if there is a special maximum amount of tokens to spend during the ICO or not\r\n\r\n        icoSalesSupply   = totalSupply.sub(supplyReserveVal);\r\n        icoReserveSupply = totalSupply.sub(icoSalesSupply);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //----- ERC20 FUNCTIONS\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function balanceOf(address walletAddress) public constant returns (uint256 balance) \r\n    {\r\n        return balances[walletAddress];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function transfer(address toAddr, uint256 amountInWei)  public   duringIcoOnlyTheOwner   returns (bool)     // don't icoNotPaused here. It's a logic issue. \r\n    {\r\n        require(toAddr!=0x0 && toAddr!=msg.sender && amountInWei>0);     // Prevent transfer to 0x0 address and to self, amount must be >0\r\n\r\n        uint256 availableTokens = balances[msg.sender];\r\n\r\n        //----- Checking Token reserve first : if during ICO    \r\n\r\n        if (msg.sender==owner && now <= icoDeadLine)                    // ICO Reserve Supply checking: Don't touch the RESERVE of tokens when owner is selling\r\n        {\r\n            assert(amountInWei<=availableTokens);\r\n\r\n            uint256 balanceAfterTransfer = availableTokens.sub(amountInWei);      \r\n\r\n            assert(balanceAfterTransfer >= icoReserveSupply);           // We try to sell more than allowed during an ICO\r\n        }\r\n\r\n        //-----\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(amountInWei);\r\n        balances[toAddr]     = balances[toAddr].add(amountInWei);\r\n\r\n        emit Transfer(msg.sender, toAddr, amountInWei);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function allowance(address walletAddress, address spender) public constant returns (uint remaining)\r\n    {\r\n        return allowances[walletAddress][spender];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function transferFrom(address fromAddr, address toAddr, uint256 amountInWei)  public  returns (bool) \r\n    {\r\n        if (amountInWei <= 0)                                   return false;\r\n        if (allowances[fromAddr][msg.sender] < amountInWei)     return false;\r\n        if (balances[fromAddr] < amountInWei)                   return false;\r\n\r\n        balances[fromAddr]               = balances[fromAddr].sub(amountInWei);\r\n        balances[toAddr]                 = balances[toAddr].add(amountInWei);\r\n        allowances[fromAddr][msg.sender] = allowances[fromAddr][msg.sender].sub(amountInWei);\r\n\r\n        emit Transfer(fromAddr, toAddr, amountInWei);\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function approve(address spender, uint256 amountInWei) public returns (bool) \r\n    {\r\n        require((amountInWei == 0) || (allowances[msg.sender][spender] == 0));\r\n        allowances[msg.sender][spender] = amountInWei;\r\n        emit Approval(msg.sender, spender, amountInWei);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function() public                       \r\n    {\r\n        assert(true == false);      // If Ether is sent to this address, don't handle it -> send it back.\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\r\n    {\r\n        require(newOwner != address(0));\r\n\r\n        emit onOwnershipTransfered(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    changeAdminUser(address newAdminAddress) public onlyOwner\r\n    {\r\n        require(newAdminAddress!=0x0);\r\n\r\n        emit onAdminUserChange(admin, newAdminAddress);\r\n        admin = newAdminAddress;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    changeIcoDeadLine(uint256 newIcoDeadline) public onlyAdmin\r\n    {\r\n        require(newIcoDeadline!=0);\r\n\r\n        emit onIcoDeadlineChanged(icoDeadLine, newIcoDeadline);\r\n        icoDeadLine = newIcoDeadline;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    changeHardCap(uint256 newHardCap) public onlyAdmin\r\n    {\r\n        require(newHardCap!=0);\r\n\r\n        emit onHardcapChanged(hardCap, newHardCap);\r\n        hardCap = newHardCap;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    isHardcapReached()  public view returns(bool)\r\n    {\r\n        return (isStoppingIcoOnHardCap && initSupply-balances[owner] > hardCap);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    pauseICO()  public onlyAdmin\r\n    {\r\n        isIcoPaused = true;\r\n        emit icoIsNowPaused(1);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    unpauseICO()  public onlyAdmin\r\n    {\r\n        isIcoPaused = false;\r\n        emit icoHasRestarted(0);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    isPausedICO() public view     returns(bool)\r\n    {\r\n        return (isIcoPaused) ? true : false;\r\n    }\r\n    /*--------------------------------------------------------------------------\r\n    //\r\n    // When ICO is closed, send the remaining (unsold) tokens to address 0x0\r\n    // So no one will be able to use it anymore... \r\n    // Anyone can check address 0x0, so to proove unsold tokens belong to no one anymore\r\n    //\r\n    //--------------------------------------------------------------------------*/\r\n    function destroyRemainingTokens() public onlyAdmin icoFinished icoNotPaused  returns(uint)\r\n    {\r\n        require(msg.sender==owner && now>icoDeadLine);\r\n\r\n        address   toAddr = 0x0000000000000000000000000000000000000000;\r\n\r\n        uint256   amountToBurn = balances[owner];\r\n\r\n        if (amountToBurn > icoReserveSupply)\r\n        {\r\n            amountToBurn = amountToBurn.sub(icoReserveSupply);\r\n        }\r\n\r\n        balances[owner]  = balances[owner].sub(amountToBurn);\r\n        balances[toAddr] = balances[toAddr].add(amountToBurn);\r\n\r\n        emit Transfer(msg.sender, toAddr, amountToBurn);\r\n        //Transfer(msg.sender, toAddr, amountToBurn);\r\n\r\n        return 1;\r\n    }        \r\n\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract    Token  is  ERC20\r\n{\r\n    using SafeMath  for uint256;\r\n    using StringLib for string;\r\n\r\n    //-------------------------------------------------------------------------- Constructor\r\n    constructor()   public \r\n    {\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIcoPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromAddr\",\"type\":\"address\"},{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHardCap\",\"type\":\"uint256\"}],\"name\":\"changeHardCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoReserveSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIcoDeadline\",\"type\":\"uint256\"}],\"name\":\"changeIcoDeadLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSalesSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStoppingIcoOnHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoDeadLine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPausedICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyReserveVal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isHardcapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyRemainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdminAddress\",\"type\":\"address\"}],\"name\":\"changeAdminUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"onAdminUserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"onOwnershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"onAdminUserChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldIcoDeadLine\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newIcoDeadline\",\"type\":\"uint256\"}],\"name\":\"onIcoDeadlineChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hardCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newHardCap\",\"type\":\"uint256\"}],\"name\":\"onHardcapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPauseStatus\",\"type\":\"uint8\"}],\"name\":\"icoIsNowPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPauseStatus\",\"type\":\"uint8\"}],\"name\":\"icoHasRestarted\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f0499b377b790a9de0bbc7766a67e60ccbf164e772e9152413302990d1ab2551"}]}