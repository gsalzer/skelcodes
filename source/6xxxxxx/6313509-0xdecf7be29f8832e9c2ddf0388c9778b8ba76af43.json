{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Library that helps prevent integer overflows and underflows,\r\n * inspired by https://github.com/OpenZeppelin/zeppelin-solidity\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title HasOwner\r\n *\r\n * @dev Allows for exclusive access to certain functionality.\r\n */\r\ncontract HasOwner {\r\n    // Current owner.\r\n    address public owner;\r\n\r\n    // Conditionally the new owner.\r\n    address public newOwner;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _owner The address of the owner.\r\n     */\r\n    constructor(address _owner) internal {\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Access control modifier that allows only the current owner to call the function.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The event is fired when the current owner is changed.\r\n     *\r\n     * @param _oldOwner The address of the previous owner.\r\n     * @param _newOwner The address of the new owner.\r\n     */\r\n    event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);\r\n\r\n    /**\r\n     * @dev Transfering the ownership is a two-step process, as we prepare\r\n     * for the transfer by setting `newOwner` and requiring `newOwner` to accept\r\n     * the transfer. This prevents accidental lock-out if something goes wrong\r\n     * when passing the `newOwner` address.\r\n     *\r\n     * @param _newOwner The address of the proposed new owner.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev The `newOwner` finishes the ownership transfer process by accepting the\r\n     * ownership.\r\n     */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n\r\n        emit OwnershipTransfer(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev The standard ERC20 Token interface.\r\n */\r\ncontract ERC20TokenInterface {\r\n    uint256 public totalSupply;  /* shorthand for public function and a property */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n * @title ERC20Token\r\n *\r\n * @dev Implements the operations declared in the `ERC20TokenInterface`.\r\n */\r\ncontract ERC20Token is ERC20TokenInterface {\r\n    using SafeMath for uint256;\r\n\r\n    // Token account balances.\r\n    mapping (address => uint256) balances;\r\n\r\n    // Delegated number of tokens to transfer.\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /**\r\n     * @dev Checks the balance of a certain address.\r\n     *\r\n     * @param _account The address which's balance will be checked.\r\n     *\r\n     * @return Returns the balance of the `_account` address.\r\n     */\r\n    function balanceOf(address _account) public constant returns (uint256 balance) {\r\n        return balances[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from one address to another.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        require(_value > 0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(_value > 0);\r\n        require(_to != address(0));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\t/**\r\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t * approve should be called when allowed[_spender] == 0. To increment\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t *\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _addedValue The amount of tokens to increase the allowance by.\r\n\t */\r\n\tfunction increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\r\n\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t * approve should be called when allowed[_spender] == 0. To decrement\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t *\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t */\r\n\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue >= oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n    /**\r\n     * @dev Shows the number of tokens approved by `_owner` that are allowed to be transferred by `_spender`.\r\n     *\r\n     * @param _owner The account which allowed the transfer.\r\n     * @param _spender The account which will spend the tokens.\r\n     *\r\n     * @return The number of tokens to be transferred.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * Don't accept ETH\r\n     */\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Freezable\r\n * @dev This trait allows to freeze the transactions in a Token\r\n */\r\ncontract Freezable is HasOwner {\r\n    bool public frozen = false;\r\n\r\n    /**\r\n     * @dev Modifier makes methods callable only when the contract is not frozen.\r\n     */\r\n    modifier requireNotFrozen() {\r\n        require(!frozen);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to \"freeze\" the contract.\r\n     */\r\n    function freeze() onlyOwner public {\r\n        frozen = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to \"unfreeze\" the contract.\r\n     */\r\n    function unfreeze() onlyOwner public {\r\n        frozen = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @title FreezableERC20Token\r\n *\r\n * @dev Extends ERC20Token and adds ability to freeze all transfers of tokens.\r\n */\r\ncontract FreezableERC20Token is ERC20Token, Freezable {\r\n    /**\r\n     * @dev Overrides the original ERC20Token implementation by adding whenNotFrozen modifier.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint256 _addedValue) public requireNotFrozen returns (bool) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public requireNotFrozen returns (bool) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n}\r\n\r\n/**\r\n * @title BonusCloudTokenConfig\r\n *\r\n * @dev The static configuration for the Bonus Cloud Token.\r\n */\r\ncontract BonusCloudTokenConfig {\r\n    // The name of the token.\r\n    string constant NAME = \"BonusCloud Token\";\r\n\r\n    // The symbol of the token.\r\n    string constant SYMBOL = \"BxC\";\r\n\r\n    // The number of decimals for the token.\r\n    uint8 constant DECIMALS = 18;\r\n\r\n    // Decimal factor for multiplication purposes.\r\n    uint256 constant DECIMALS_FACTOR = 10 ** uint(DECIMALS);\r\n\r\n    // TotalSupply\r\n    uint256 constant TOTAL_SUPPLY = 7000000000 * DECIMALS_FACTOR;\r\n}\r\n\r\n/**\r\n * @title Bonus Cloud Token\r\n *\r\n * @dev A standard token implementation of the ERC20 token standard with added\r\n *      HasOwner trait and initialized using the configuration constants.\r\n */\r\ncontract BonusCloudToken is BonusCloudTokenConfig, HasOwner, FreezableERC20Token {\r\n    // The name of the token.\r\n    string public name;\r\n\r\n    // The symbol for the token.\r\n    string public symbol;\r\n\r\n    // The decimals of the token.\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     */\r\n    constructor() public HasOwner(msg.sender) {\r\n        name = NAME;\r\n        symbol = SYMBOL;\r\n        decimals = DECIMALS;\r\n        totalSupply = TOTAL_SUPPLY;\r\n        balances[owner] = TOTAL_SUPPLY;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BonusCloudToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5f95755d9830d5eec6a0c54c40dbb715134680c904916c53e190ca7ab689ba0b"}]}