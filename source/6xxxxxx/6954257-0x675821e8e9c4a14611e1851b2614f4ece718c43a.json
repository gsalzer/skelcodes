{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/*\r\n    @KAKUTAN-team\r\n    https://myethergames.fun\r\n    26.12.2018\r\n*/\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract BlackAndWhite is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint8 constant BLACK = 0;\r\n    uint8 constant WHITE = 1;\r\n    uint constant TEAM_PERCENT = 2;\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n    uint public betAmount = 50000000000000000;\r\n    uint public minAmount = 100000000000000000;\r\n    uint public lockedInBets;\r\n    uint public teamBalance;\r\n\r\n    uint betId;\r\n\r\n    struct Bet {\r\n        uint amount;\r\n        uint8 option;\r\n        uint40 placeBlockNumber;\r\n        address gambler;\r\n    }\r\n\r\n    mapping (uint => Bet) bets;\r\n\r\n    address public botAddress;\r\n\r\n    modifier onlyBot {\r\n        require (msg.sender == botAddress);\r\n        _;\r\n    }\r\n\r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event Payment(address indexed beneficiary, uint amount);\r\n\r\n    event Commit(address gambler, uint commit, uint8 option);\r\n    event Reveal(uint betId, uint reveal, uint seed, uint amount, address gambler, uint8 betOption);\r\n\r\n    event NewPrice(uint newPrice);\r\n\r\n\r\n    constructor() public {\r\n        botAddress = 0x3be76eeFF089AF790dd8Cbf3b921e430a962214d;\r\n        betId = 0;\r\n    }\r\n\r\n    function setBotAddress(address newAddress) external onlyOwner {\r\n        botAddress = newAddress;\r\n    }\r\n\r\n    function() external payable {\r\n\r\n    }\r\n\r\n    function placeBet(uint8 option) public payable {\r\n        require(option == BLACK || option == WHITE);\r\n        Bet storage bet = bets[betId];\r\n        require (bet.gambler == address(0));\r\n        betId = betId.add(1);\r\n        uint amount = msg.value;\r\n        require(amount == betAmount);\r\n\r\n        uint possibleWinAmount;\r\n\r\n        possibleWinAmount = getWinAmount(amount);\r\n\r\n        lockedInBets = lockedInBets.add(possibleWinAmount);\r\n\r\n        require (lockedInBets <= address(this).balance);\r\n\r\n        emit Commit(msg.sender, betId.sub(1), option);\r\n\r\n        bet.amount = amount;\r\n        bet.option = option;\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.gambler = msg.sender;\r\n    }\r\n\r\n    function settleBet(uint _betId, uint data) external onlyBot {\r\n        require(data != 0);\r\n        Bet storage bet = bets[_betId];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        require (block.number > placeBlockNumber);\r\n        require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS);\r\n        uint amount = bet.amount;\r\n        address gambler = bet.gambler;\r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        bet.amount = 0;\r\n\r\n        uint possibleWinAmount = getWinAmount(amount);\r\n        uint winAmount = 0;\r\n        uint seed = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));\r\n        uint random = data.add(seed);\r\n\r\n        if(bet.option == BLACK) {\r\n            winAmount = random % 2 == BLACK ? possibleWinAmount : 0;\r\n        }\r\n\r\n        if(bet.option == WHITE) {\r\n            winAmount = random % 2 == WHITE ? possibleWinAmount : 0;\r\n        }\r\n\r\n        if(winAmount > 0) {\r\n            require(address(this).balance >= minAmount + winAmount + teamBalance );\r\n        }\r\n\r\n        teamBalance = teamBalance.add(beneficiaryPercent(amount));\r\n        lockedInBets -= possibleWinAmount;\r\n\r\n        sendFunds(gambler, winAmount);\r\n\r\n        emit Reveal(_betId, data, seed, winAmount, gambler, bet.option);\r\n    }\r\n\r\n    function refundBet(uint _betId) external {\r\n        Bet storage bet = bets[_betId];\r\n        uint amount = bet.amount;\r\n\r\n        require (amount != 0);\r\n\r\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS);\r\n\r\n        bet.amount = 0;\r\n\r\n        uint winAmount;\r\n        winAmount = getWinAmount(amount);\r\n\r\n        lockedInBets -= uint128(winAmount);\r\n\r\n        sendFunds(bet.gambler, amount);\r\n    }\r\n\r\n    function getWinAmount(uint amount) private pure returns (uint winAmount) {\r\n        uint team = beneficiaryPercent(amount);\r\n\r\n        winAmount = (amount * 2) - team;\r\n    }\r\n\r\n    function beneficiaryPercent(uint amount) private pure returns(uint) {\r\n        uint team = amount * TEAM_PERCENT / 100;\r\n        require(team <= amount);\r\n        return team;\r\n    }\r\n\r\n    function sendFunds(address _beneficiary, uint amount) private {\r\n        if (_beneficiary.send(amount)) {\r\n            emit Payment(_beneficiary, amount);\r\n        } else {\r\n            emit FailedPayment(_beneficiary, amount);\r\n        }\r\n    }\r\n\r\n    function withdrawFunds(address _beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance);\r\n        require (lockedInBets + withdrawAmount <= address(this).balance);\r\n        sendFunds(_beneficiary, withdrawAmount);\r\n    }\r\n\r\n    function setPrice(uint newPrice) public onlyOwner {\r\n        betAmount = newPrice;\r\n        emit NewPrice(newPrice);\r\n    }\r\n\r\n    function setMinAmount(uint amount) public onlyOwner{\r\n        minAmount = amount;\r\n    }\r\n\r\n    function canRefund(uint _betId) public constant returns(bool) {\r\n        Bet storage bet = bets[_betId];\r\n        if(block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS && bet.placeBlockNumber > 0 && bet.amount > 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_betId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setBotAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"option\",\"type\":\"uint8\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"botAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_betId\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_betId\",\"type\":\"uint256\"}],\"name\":\"canRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"option\",\"type\":\"uint8\"}],\"name\":\"Commit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reveal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betOption\",\"type\":\"uint8\"}],\"name\":\"Reveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"NewPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BlackAndWhite","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1618fefaf6b7c864edc5974d0ea7f94d469c2e4fdb753b0850e609bfde4090f3"}]}