{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n \r\n/**\r\n*\r\n*  https://fairdapp.com/crash/  https://fairdapp.com/crash/   https://fairdapp.com/crash/\r\n*\r\n*\r\n*        _______     _       ______  _______ ______ ______  \r\n*       (_______)   (_)     (______)(_______|_____ (_____ \\ \r\n*        _____ _____ _  ____ _     _ _______ _____) )____) )\r\n*       |  ___|____ | |/ ___) |   | |  ___  |  ____/  ____/ \r\n*       | |   / ___ | | |   | |__/ /| |   | | |    | |      \r\n*       |_|   \\_____|_|_|   |_____/ |_|   |_|_|    |_|\r\n*       \r\n*        ______       ______     _______                  _     \r\n*       (_____ \\     (_____ \\   (_______)                | |    \r\n*        _____) )   _ _____) )   _        ____ _____  ___| |__  \r\n*       |  ____/ | | |  ____/   | |      / ___|____ |/___)  _ \\ \r\n*       | |     \\ V /| |        | |_____| |   / ___ |___ | | | |\r\n*       |_|      \\_/ |_|         \\______)_|   \\_____(___/|_| |_|\r\n*                                                        \r\n*   \r\n*  Warning: \r\n*\r\n*  This contract is intented for entertainment purpose only.\r\n*  All could be lost by sending anything to this contract address. \r\n*  All users are prohibited to interact with this contract if this \r\n*  contract is in conflict with user’s local regulations or laws.   \r\n*  \r\n*  -Just another unique concept by the FairDAPP community.\r\n*  -The FIRST PvP Crash game ever created!  \r\n*\r\n*/\r\n\r\ncontract FairExchange{\r\n    function balanceOf(address _customerAddress) public view returns(uint256);\r\n    function myTokens() public view returns(uint256);\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) public returns(bool);\r\n}\r\n\r\ncontract PvPCrash {\r\n \r\n    using SafeMath for uint256;\r\n    \r\n    /**\r\n     * @dev Modifiers\r\n     */\r\n \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier gasMin() {\r\n        require(gasleft() >= gasLimit);\r\n        require(tx.gasprice <= gasPriceLimit);\r\n        _;\r\n    }\r\n    \r\n    modifier isHuman() {\r\n        address _customerAddress = msg.sender;\r\n        if (_customerAddress != address(fairExchangeContract)){\r\n            require(_customerAddress == tx.origin);\r\n            _;\r\n        }\r\n    }\r\n    \r\n    event Invest(address investor, uint256 amount);\r\n    event Withdraw(address investor, uint256 amount);\r\n    \r\n    event FairTokenBuy(uint256 indexed ethereum, uint256 indexed tokens);\r\n    event FairTokenTransfer(address indexed userAddress, uint256 indexed tokens, uint256 indexed roundCount);\r\n    event FairTokenFallback(address indexed userAddress, uint256 indexed tokens, bytes indexed data);\r\n\r\n \r\n    mapping(address => mapping (uint256 => uint256)) public investments;\r\n    mapping(address => mapping (uint256 => uint256)) public joined;\r\n    mapping(address => uint256) public userInputAmount;\r\n    mapping(uint256 => uint256) public roundStartTime;\r\n    mapping(uint256 => uint256) public roundEndTime;\r\n    mapping(uint256 => uint256) public withdrawBlock;\r\n    \r\n    bool public gameOpen;\r\n    bool public roundEnded;\r\n    uint256 public roundCount = 1;\r\n    uint256 public startCoolDown = 5 minutes;\r\n    uint256 public endCoolDown = 5 minutes;\r\n    uint256 public minimum = 10 finney;\r\n    uint256 public maximum = 5 ether;\r\n    uint256 public maxNumBlock = 3;\r\n    uint256 public refundRatio = 50;\r\n    uint256 public gasPriceLimit = 25000000000;\r\n    uint256 public gasLimit = 300000;\r\n    \r\n    address constant public owner = 0xbC817A495f0114755Da5305c5AA84fc5ca7ebaBd;\r\n    \r\n    FairExchange constant private fairExchangeContract = FairExchange(0xdE2b11b71AD892Ac3e47ce99D107788d65fE764e);\r\n\r\n    PvPCrashFormula constant private pvpCrashFormula = PvPCrashFormula(0xe3c518815fE5f1e970F8fC5F2eFFcF2871be5C4d);\r\n    \r\n\r\n    /**\r\n     * @dev Сonstructor Sets the original roles of the contract\r\n     */\r\n \r\n    constructor() \r\n        public \r\n    {\r\n        roundStartTime[roundCount] = now + startCoolDown;\r\n        gameOpen = true;\r\n    }\r\n    \r\n    function setGameOpen() \r\n        onlyOwner\r\n        public  \r\n    {\r\n        if (gameOpen) {\r\n            require(roundEnded);\r\n            gameOpen = false;\r\n        } else\r\n            gameOpen = true;\r\n    }\r\n    \r\n    function setMinimum(uint256 _minimum) \r\n        onlyOwner\r\n        public  \r\n    {\r\n        require(_minimum < maximum);\r\n        minimum = _minimum;\r\n    }\r\n    \r\n    function setMaximum(uint256 _maximum) \r\n        onlyOwner\r\n        public  \r\n    {\r\n        require(_maximum > minimum);\r\n        maximum = _maximum;\r\n    }\r\n    \r\n    function setRefundRatio(uint256 _refundRatio) \r\n        onlyOwner\r\n        public \r\n    {\r\n        require(_refundRatio <= 100);\r\n        refundRatio = _refundRatio;\r\n    }\r\n    \r\n    function setGasLimit(uint256 _gasLimit) \r\n        onlyOwner\r\n        public \r\n    {\r\n        require(_gasLimit >= 200000);\r\n        gasLimit = _gasLimit;\r\n    }\r\n    \r\n    function setGasPrice(uint256 _gasPrice) \r\n        onlyOwner\r\n        public \r\n    {\r\n        require(_gasPrice >= 1000000000);\r\n        gasPriceLimit = _gasPrice;\r\n    }\r\n    \r\n    function setStartCoolDown(uint256 _coolDown) \r\n        onlyOwner\r\n        public \r\n    {\r\n        require(!gameOpen);\r\n        startCoolDown = _coolDown;\r\n    }\r\n    \r\n    function setEndCoolDown(uint256 _coolDown) \r\n        onlyOwner\r\n        public \r\n    {\r\n        require(!gameOpen);\r\n        endCoolDown = _coolDown;\r\n    }\r\n    \r\n    function setMaxNumBlock(uint256 _maxNumBlock) \r\n        onlyOwner\r\n        public \r\n    {\r\n        require(!gameOpen);\r\n        maxNumBlock = _maxNumBlock;\r\n    }\r\n    \r\n    function transferFairTokens() \r\n        onlyOwner\r\n        public  \r\n    {\r\n        fairExchangeContract.transfer(owner, fairExchangeContract.myTokens());\r\n    }\r\n    \r\n    function tokenFallback(address _from, uint256 _amountOfTokens, bytes _data) \r\n        public \r\n        returns (bool)\r\n    {\r\n        require(msg.sender == address(fairExchangeContract));\r\n        emit FairTokenFallback(_from, _amountOfTokens, _data);\r\n    }\r\n \r\n    /**\r\n     * @dev Investments\r\n     */\r\n    function ()\r\n        // gameStarted\r\n        isHuman\r\n        payable\r\n        public\r\n    {\r\n        buy();\r\n    }\r\n\r\n    function buy()\r\n        private\r\n    {\r\n        address _user = msg.sender;\r\n        uint256 _amount = msg.value;\r\n        uint256 _roundCount = roundCount;\r\n        uint256 _currentTimestamp = now;\r\n        uint256 _startCoolDown = startCoolDown;\r\n        uint256 _endCoolDown = endCoolDown;\r\n        require(gameOpen);\r\n        require(_amount >= minimum);\r\n        require(_amount <= maximum);\r\n        \r\n        if (roundEnded == true && _currentTimestamp > roundEndTime[_roundCount] + _endCoolDown) {\r\n            roundEnded = false;\r\n            roundCount++;\r\n            _roundCount = roundCount;\r\n            roundStartTime[_roundCount] = _currentTimestamp + _startCoolDown;\r\n            \r\n        } else if (roundEnded) {\r\n            require(_currentTimestamp > roundEndTime[_roundCount] + _endCoolDown);\r\n        }\r\n\r\n        require(investments[_user][_roundCount] == 0);\r\n        if (!roundEnded) {\r\n            if (_currentTimestamp >= roundStartTime[_roundCount].sub(_startCoolDown)\r\n                && _currentTimestamp < roundStartTime[_roundCount]\r\n            ) {\r\n                joined[_user][_roundCount] = roundStartTime[_roundCount];\r\n            }else if(_currentTimestamp >= roundStartTime[_roundCount]){\r\n                joined[_user][_roundCount] = block.timestamp;\r\n            }\r\n            investments[_user][_roundCount] = _amount;\r\n            userInputAmount[_user] = userInputAmount[_user].add(_amount);\r\n            bool _status = address(fairExchangeContract).call.value(_amount / 20).gas(1000000)();\r\n            require(_status);\r\n            emit FairTokenBuy(_amount / 20, myTokens());\r\n            emit Invest(_user, _amount);\r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n    * @dev Withdraw dividends from contract\r\n    */\r\n    function withdraw() \r\n        gasMin\r\n        isHuman \r\n        public \r\n        returns (bool) \r\n    {\r\n        address _user = msg.sender;\r\n        uint256 _roundCount = roundCount;\r\n        uint256 _currentTimestamp = now;\r\n        \r\n        require(joined[_user][_roundCount] > 0);\r\n        require(_currentTimestamp >= roundStartTime[_roundCount]);\r\n        if (roundEndTime[_roundCount] > 0)\r\n            require(_currentTimestamp <= roundEndTime[_roundCount] + endCoolDown);\r\n        \r\n        uint256 _userBalance;\r\n        uint256 _balance = address(this).balance;\r\n        uint256 _totalTokens = fairExchangeContract.myTokens();\r\n        uint256 _tokens;\r\n        uint256 _tokensTransferRatio;\r\n        if (!roundEnded && withdrawBlock[block.number] <= maxNumBlock) {\r\n            _userBalance = getBalance(_user);\r\n            joined[_user][_roundCount] = 0;\r\n            withdrawBlock[block.number]++;\r\n            \r\n            if (_balance > _userBalance) {\r\n                if (_userBalance > 0) {\r\n                    _user.transfer(_userBalance);\r\n                    emit Withdraw(_user, _userBalance);\r\n                }\r\n                return true;\r\n            } else {\r\n                if (_userBalance > 0) {\r\n                    _user.transfer(_balance);\r\n                    if (investments[_user][_roundCount].mul(95).div(100) > _balance) {\r\n                        \r\n                        _tokensTransferRatio = investments[_user][_roundCount] / 0.01 ether * 2;\r\n                        _tokensTransferRatio = _tokensTransferRatio > 20000 ? 20000 : _tokensTransferRatio;\r\n                        _tokens = _totalTokens\r\n                            .mul(_tokensTransferRatio) / 100000;\r\n                        fairExchangeContract.transfer(_user, _tokens);\r\n                        emit FairTokenTransfer(_user, _tokens, _roundCount);\r\n                    }\r\n                    roundEnded = true;\r\n                    roundEndTime[_roundCount] = _currentTimestamp;\r\n                    emit Withdraw(_user, _balance);\r\n                }\r\n                return true;\r\n            }\r\n        } else {\r\n            \r\n            if (!roundEnded) {\r\n                _userBalance = investments[_user][_roundCount].mul(refundRatio).div(100);\r\n                if (_balance > _userBalance) {\r\n                    _user.transfer(_userBalance);\r\n                    emit Withdraw(_user, _userBalance);\r\n                } else {\r\n                    _user.transfer(_balance);\r\n                    roundEnded = true;\r\n                    roundEndTime[_roundCount] = _currentTimestamp;\r\n                    emit Withdraw(_user, _balance);\r\n                }\r\n            }\r\n            _tokensTransferRatio = investments[_user][_roundCount] / 0.01 ether * 2;\r\n            _tokensTransferRatio = _tokensTransferRatio > 20000 ? 20000 : _tokensTransferRatio;\r\n            _tokens = _totalTokens\r\n                .mul(_tokensTransferRatio) / 100000;\r\n            fairExchangeContract.transfer(_user, _tokens);\r\n            joined[_user][_roundCount] = 0;\r\n            emit FairTokenTransfer(_user, _tokens, _roundCount);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Evaluate current balance\r\n    * @param _address Address of player\r\n    */\r\n    function getBalance(address _address) \r\n        view \r\n        public \r\n        returns (uint256) \r\n    {\r\n        uint256 _roundCount = roundCount;\r\n        return pvpCrashFormula.getBalance(\r\n            roundStartTime[_roundCount], \r\n            joined[_address][_roundCount],\r\n            investments[_address][_roundCount],\r\n            userInputAmount[_address],\r\n            fairExchangeContract.balanceOf(_address)\r\n        );\r\n    }\r\n    \r\n    function getAdditionalRewardRatio(address _address) \r\n        view \r\n        public \r\n        returns (uint256) \r\n    {\r\n        return pvpCrashFormula.getAdditionalRewardRatio(\r\n            userInputAmount[_address],\r\n            fairExchangeContract.balanceOf(_address)\r\n        );\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets balance of the sender address.\r\n    * @return An uint256 representing the amount owned by the msg.sender.\r\n    */\r\n    function checkBalance() \r\n        view\r\n        public  \r\n        returns (uint256) \r\n    {\r\n        return getBalance(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets investments of the specified address.\r\n    * @param _investor The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function checkInvestments(address _investor) \r\n        view\r\n        public  \r\n        returns (uint256) \r\n    {\r\n        return investments[_investor][roundCount];\r\n    }\r\n    \r\n    function getFairTokensBalance(address _address) \r\n        view \r\n        public \r\n        returns (uint256) \r\n    {\r\n        return fairExchangeContract.balanceOf(_address);\r\n    }\r\n    \r\n    function myTokens() \r\n        view \r\n        public \r\n        returns (uint256) \r\n    {\r\n        return fairExchangeContract.myTokens();\r\n    }\r\n    \r\n}\r\n\r\ninterface PvPCrashFormula {\r\n    function getBalance(uint256 _roundStartTime, uint256 _joinedTime, uint256 _amount, uint256 _totalAmount, uint256 _tokens) external view returns(uint256);\r\n    function getAdditionalRewardRatio(uint256 _totalAmount, uint256 _tokens) external view returns(uint256);\r\n}\r\n \r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_refundRatio\",\"type\":\"uint256\"}],\"name\":\"setRefundRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"joined\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maximum\",\"type\":\"uint256\"}],\"name\":\"setMaximum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimum\",\"type\":\"uint256\"}],\"name\":\"setMinimum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startCoolDown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInputAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setGameOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endCoolDown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferFairTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"checkInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPriceLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coolDown\",\"type\":\"uint256\"}],\"name\":\"setEndCoolDown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getFairTokensBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxNumBlock\",\"type\":\"uint256\"}],\"name\":\"setMaxNumBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coolDown\",\"type\":\"uint256\"}],\"name\":\"setStartCoolDown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAdditionalRewardRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ethereum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"FairTokenBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundCount\",\"type\":\"uint256\"}],\"name\":\"FairTokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"FairTokenFallback\",\"type\":\"event\"}]","ContractName":"PvPCrash","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4f5e6cb713d4979a2d5a2b9a9a9f7d90a784ddc6b30f14db98402ac81d8d7d9b"}]}