{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Sets contract owner to address of constructor caller\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Change Owner\r\n    *\r\n    *  Changes ownership of this contract. Only owner can call this method.\r\n    *\r\n    * @param newOwner - new owner's address\r\n    */\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        require(newOwner != owner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TokenParameters {\r\n    uint256 internal initialSupply = 828179381000000000000000000;\r\n\r\n    // Production\r\n    address internal constant initialTokenOwnerAddress = 0x68433cFb33A7Fdbfa74Ea5ECad0Bc8b1D97d82E9;\r\n}\r\n\r\ncontract TANToken is Owned, TokenParameters {\r\n    /* Public variables of the token */\r\n    string public standard = 'ERC-20';\r\n    string public name = 'Taklimakan';\r\n    string public symbol = 'TAN';\r\n    uint8 public decimals = 18;\r\n\r\n    /* Arrays of all balances, vesting, approvals, and approval uses */\r\n    mapping (address => uint256) private _balances;   // Total token balances\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n    event Destruction(uint256 _amount); // triggered when the total supply is decreased\r\n    event NewTANToken(address _token);\r\n\r\n    /* Miscellaneous */\r\n    uint256 public totalSupply = 0;\r\n    address private _admin;\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Initializes contract with initial supply tokens to the creator of the contract\r\n    */\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n        _admin = msg.sender;\r\n        mintToken(TokenParameters.initialTokenOwnerAddress, TokenParameters.initialSupply);\r\n        emit NewTANToken(address(this));\r\n    }\r\n\r\n    modifier onlyOwnerOrAdmin() {\r\n        require((msg.sender == owner) || (msg.sender == _admin));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Function to set new admin for automated setting of exchange rate\r\n    *\r\n    */\r\n    function setAdmin(address newAdmin)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(newAdmin != address(0));\r\n        _admin = newAdmin;\r\n    }\r\n\r\n    /**\r\n    *  Get token balance of an address\r\n    *\r\n    * @param addr - address to query\r\n    * @return Token balance of address\r\n    */\r\n    function balanceOf(address addr)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _balances[addr];\r\n    }\r\n\r\n    /**\r\n    *  Get token amount allocated for a transaction from _owner to _spender addresses\r\n    *\r\n    * @param tokenOwner - owner address, i.e. address to transfer from\r\n    * @param tokenSpender - spender address, i.e. address to transfer to\r\n    * @return Remaining amount allowed to be transferred\r\n    */\r\n    function allowance(address tokenOwner, address tokenSpender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowed[tokenOwner][tokenSpender];\r\n    }\r\n\r\n    /**\r\n    *  Send coins from sender's address to address specified in parameters\r\n    *\r\n    * @param to - address to send to\r\n    * @param value - amount to send in Wei\r\n    */\r\n    function transfer(address to, uint256 value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_balances[msg.sender] >= value, \"Insufficient balance for transfer\");\r\n\r\n        // Subtract from the sender\r\n        // _value is never greater than balance of input validation above\r\n        _balances[msg.sender] -= value;\r\n\r\n        // Overflow is never possible due to input validation above\r\n        _balances[to] += value;\r\n\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Create token and credit it to target address\r\n    *  Created tokens need to vest\r\n    *\r\n    */\r\n    function mintToken(address tokenOwner, uint256 amount)\r\n        internal\r\n    {\r\n        // Mint happens right here: Balance becomes non-zero from zero\r\n        _balances[tokenOwner] += amount;\r\n        totalSupply += amount;\r\n\r\n        // Emit Transfer event\r\n        emit Transfer(address(0), tokenOwner, amount);\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param spender - address to allocate tokens for\r\n    * @param value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_balances[msg.sender] >= value, \"Insufficient balance for approval\");\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  A contract attempts to get the coins. Tokens should be previously allocated\r\n    *\r\n    * @param to - address to transfer tokens to\r\n    * @param from - address to transfer tokens from\r\n    * @param value - number of tokens to transfer\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        // Check allowed\r\n        require(value <= _allowed[from][msg.sender]);\r\n        require(_balances[from] >= value);\r\n\r\n        // Subtract from the sender\r\n        // _value is never greater than balance because of input validation above\r\n        _balances[from] -= value;\r\n        // Add the same to the recipient\r\n        // Overflow is not possible because of input validation above\r\n        _balances[to] += value;\r\n\r\n        // Deduct allocation\r\n        // _value is never greater than allowed amount because of input validation above\r\n        _allowed[from][msg.sender] -= value;\r\n\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  This unnamed function is called whenever someone tries to send ether to\r\n    *  it. Just revert transaction because there is nothing that Token can do\r\n    *  with incoming ether.\r\n    *\r\n    *  Missing payable modifier prevents accidental sending of ether\r\n    */\r\n    function() public {\r\n    }\r\n\r\n    /**\r\n    *  Destruction (burning) of owner tokens. Only owner of this contract can\r\n    *  use it to burn their tokens.\r\n    *\r\n    *  Total Supply is decreased by the amount of burned tokens\r\n    *\r\n    * @param amount - Wei amount of tokens to burn\r\n    */\r\n    function destroy(uint256 amount)\r\n        external\r\n        onlyOwnerOrAdmin\r\n    {\r\n        require(amount <= _balances[msg.sender]);\r\n\r\n        // Destroyed amount is never greater than total supply,\r\n        // so no underflow possible here\r\n        totalSupply -= amount;\r\n        _balances[msg.sender] -= amount;\r\n        emit Destruction(amount);\r\n    }\r\n\r\n    /**\r\n    *  Mass distribution of token\r\n    *\r\n    *  Transfers token from admin address to multiple addresses\r\n    *\r\n    * @param _recipients - array of recipient addresses\r\n    * @param _tokenAmounts - array of amounts of tokens to send\r\n    */\r\n    function multiTransfer(address[] _recipients, uint[] _tokenAmounts)\r\n        external\r\n        onlyOwnerOrAdmin\r\n    {\r\n        uint256 totalAmount = 0;\r\n        uint256 len = _recipients.length;\r\n        uint256 i;\r\n\r\n        // Calculate total amount\r\n        for (i=0; i<len; i++)\r\n        {\r\n            totalAmount += _tokenAmounts[i];\r\n        }\r\n        require(_balances[msg.sender] >= totalAmount);\r\n        \r\n        // Decrease sender balance by total amount\r\n        _balances[msg.sender] -= totalAmount;\r\n\r\n        for (i=0; i<len; i++)\r\n        {\r\n            // Increase balance of each recipient\r\n            _balances[_recipients[i]] += _tokenAmounts[i];\r\n\r\n            // Emit Transfer event\r\n            emit Transfer(msg.sender, _recipients[i], _tokenAmounts[i]);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_tokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"tokenSpender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewTANToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TANToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6adeb07bce36da8c3ef3257eacc0c1fb236854e7ca392115710162266b47d2ce"}]}