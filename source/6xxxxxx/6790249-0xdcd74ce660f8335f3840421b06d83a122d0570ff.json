{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath8 {\r\n\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint8 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint8 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath16 {\r\n\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint16 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        uint16 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint16 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint32 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint32 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeConvert {\r\n\r\n    function toUint8(uint256 _value) internal pure returns (uint8) {\r\n        assert(_value <= 255);\r\n        return uint8(_value);\r\n    }\r\n\r\n    function toUint16(uint256 _value) internal pure returns (uint16) {\r\n        assert(_value <= 2**16 - 1);\r\n        return uint16(_value);\r\n    }\r\n\r\n    function toUint32(uint256 _value) internal pure returns (uint32) {\r\n        assert(_value <= 2**32 - 1);\r\n        return uint32(_value);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\ncontract DragonParams {\r\n    function dragonTypesFactors(uint8) external view returns (uint8[5]) {}\r\n    function bodyPartsFactors(uint8) external view returns (uint8[5]) {}\r\n    function geneTypesFactors(uint8) external view returns (uint8[5]) {}\r\n    function experienceToNextLevel(uint8) external view returns (uint8) {}\r\n    function dnaPoints(uint8) external view returns (uint16) {}\r\n    function geneUpgradeDNAPoints(uint8) external view returns (uint8) {}\r\n    function battlePoints() external view returns (uint8) {}\r\n}\r\n\r\ncontract Name {\r\n    using SafeMath256 for uint256;\r\n\r\n    uint8 constant MIN_NAME_LENGTH = 2;\r\n    uint8 constant MAX_NAME_LENGTH = 32;\r\n\r\n    function _convertName(string _input) internal pure returns(bytes32 _initial, bytes32 _lowercase) {\r\n        bytes memory _initialBytes = bytes(_input);\r\n        assembly {\r\n            _initial := mload(add(_initialBytes, 32))\r\n        }\r\n        _lowercase = _toLowercase(_input);\r\n    }\r\n\r\n\r\n    function _toLowercase(string _input) internal pure returns(bytes32 result) {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n\r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length >= 2, \"string must be between 2 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length.sub(1)] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n\r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i = i.add(1))\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint256(_temp[i]).add(32));\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require(_temp[i.add(1)] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n\r\n        assembly {\r\n            result := mload(add(_temp, 32))\r\n        }\r\n    }\r\n}\r\n\r\ncontract DragonUtils {\r\n    using SafeMath8 for uint8;\r\n    using SafeMath256 for uint256;\r\n\r\n    using SafeConvert for uint256;\r\n\r\n\r\n    function _getActiveGene(uint8[16] _gene) internal pure returns (uint8[3] gene) {\r\n        uint8 _index = _getActiveGeneIndex(_gene); // find active gene\r\n        for (uint8 i = 0; i < 3; i++) {\r\n            gene[i] = _gene[i + (_index * 4)]; // get all data for this gene\r\n        }\r\n    }\r\n\r\n    function _getActiveGeneIndex(uint8[16] _gene) internal pure returns (uint8) {\r\n        return _gene[3] >= _gene[7] ? 0 : 1;\r\n    }\r\n\r\n    // returns 10 active genes (one for each part of the body) with the next structure:\r\n    // each gene is an array of 3 elements:\r\n    // 0 - type of dragon\r\n    // 1 - gene type\r\n    // 2 - gene level\r\n    function _getActiveGenes(uint8[16][10] _genome) internal pure returns (uint8[30] genome) {\r\n        uint8[3] memory _activeGene;\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            _activeGene = _getActiveGene(_genome[i]);\r\n            genome[i * 3] = _activeGene[0];\r\n            genome[i * 3 + 1] = _activeGene[1];\r\n            genome[i * 3 + 2] = _activeGene[2];\r\n        }\r\n    }\r\n\r\n    function _getIndexAndFactor(uint8 _counter) internal pure returns (uint8 index, uint8 factor) {\r\n        if (_counter < 44) index = 0;\r\n        else if (_counter < 88) index = 1;\r\n        else if (_counter < 132) index = 2;\r\n        else index = 3;\r\n        factor = _counter.add(1) % 4 == 0 ? 10 : 100;\r\n    }\r\n\r\n    function _parseGenome(uint256[4] _composed) internal pure returns (uint8[16][10] parsed) {\r\n        uint8 counter = 160; // 40 genes with 4 values in each one\r\n        uint8 _factor;\r\n        uint8 _index;\r\n\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            for (uint8 j = 0; j < 16; j++) {\r\n                counter = counter.sub(1);\r\n                // _index - index of value in genome array where current gene is stored\r\n                // _factor - denominator that determines the number of digits\r\n                (_index, _factor) = _getIndexAndFactor(counter);\r\n                parsed[9 - i][15 - j] = (_composed[_index] % _factor).toUint8();\r\n                _composed[_index] /= _factor;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _composeGenome(uint8[16][10] _parsed) internal pure returns (uint256[4] composed) {\r\n        uint8 counter = 0;\r\n        uint8 _index;\r\n        uint8 _factor;\r\n\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            for (uint8 j = 0; j < 16; j++) {\r\n                (_index, _factor) = _getIndexAndFactor(counter);\r\n                composed[_index] = composed[_index].mul(_factor);\r\n                composed[_index] = composed[_index].add(_parsed[i][j]);\r\n                counter = counter.add(1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DragonCoreHelper is Upgradable, DragonUtils, Name {\r\n    using SafeMath16 for uint16;\r\n    using SafeMath32 for uint32;\r\n    using SafeMath256 for uint256;\r\n    using SafeConvert for uint32;\r\n    using SafeConvert for uint256;\r\n\r\n    DragonParams params;\r\n\r\n    uint8 constant PERCENT_MULTIPLIER = 100;\r\n    uint8 constant MAX_PERCENTAGE = 100;\r\n\r\n    uint8 constant MAX_GENE_LVL = 99;\r\n\r\n    uint8 constant MAX_LEVEL = 10;\r\n\r\n    function _min(uint32 lth, uint32 rth) internal pure returns (uint32) {\r\n        return lth > rth ? rth : lth;\r\n    }\r\n\r\n    function _calculateSkillWithBuff(uint32 _skill, uint32 _buff) internal pure returns (uint32) {\r\n        return _buff > 0 ? _skill.mul(_buff).div(100) : _skill; // buff is multiplied by 100\r\n    }\r\n\r\n    function _calculateRegenerationSpeed(uint32 _max) internal pure returns (uint32) {\r\n        // because HP/mana is multiplied by 100 so we need to have step multiplied by 100 too\r\n        return _sqrt(_max.mul(100)).div(2).div(1 minutes); // hp/mana in second\r\n    }\r\n\r\n    function calculateFullRegenerationTime(uint32 _max) external pure returns (uint32) { // in seconds\r\n        return _max.div(_calculateRegenerationSpeed(_max));\r\n    }\r\n\r\n    function calculateCurrent(\r\n        uint256 _pastTime,\r\n        uint32 _max,\r\n        uint32 _remaining\r\n    ) external pure returns (\r\n        uint32 current,\r\n        uint8 percentage\r\n    ) {\r\n        if (_remaining >= _max) {\r\n            return (_max, MAX_PERCENTAGE);\r\n        }\r\n        uint32 _speed = _calculateRegenerationSpeed(_max); // points per second\r\n        uint32 _secondsToFull = _max.sub(_remaining).div(_speed); // seconds to full\r\n        uint32 _secondsPassed = _pastTime.toUint32(); // seconds that already passed\r\n        if (_secondsPassed >= _secondsToFull.add(1)) {\r\n            return (_max, MAX_PERCENTAGE); // return full if passed more or equal to needed\r\n        }\r\n        current = _min(_max, _remaining.add(_speed.mul(_secondsPassed)));\r\n        percentage = _min(MAX_PERCENTAGE, current.mul(PERCENT_MULTIPLIER).div(_max)).toUint8();\r\n    }\r\n\r\n    function calculateHealthAndMana(\r\n        uint32 _initStamina,\r\n        uint32 _initIntelligence,\r\n        uint32 _staminaBuff,\r\n        uint32 _intelligenceBuff\r\n    ) external pure returns (uint32 health, uint32 mana) {\r\n        uint32 _stamina = _initStamina;\r\n        uint32 _intelligence = _initIntelligence;\r\n\r\n        _stamina = _calculateSkillWithBuff(_stamina, _staminaBuff);\r\n        _intelligence = _calculateSkillWithBuff(_intelligence, _intelligenceBuff);\r\n\r\n        health = _stamina.mul(5);\r\n        mana = _intelligence.mul(5);\r\n    }\r\n\r\n    function _sqrt(uint32 x) internal pure returns (uint32 y) {\r\n        uint32 z = x.add(1).div(2);\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = x.div(z).add(z).div(2);\r\n        }\r\n    }\r\n\r\n    // _dragonTypes[i] in [0..39] range, sum of all _dragonTypes items = 40 (number of genes)\r\n    // _random in [0..39] range\r\n    function getSpecialBattleSkillDragonType(uint8[11] _dragonTypes, uint256 _random) external pure returns (uint8 skillDragonType) {\r\n        uint256 _currentChance;\r\n        for (uint8 i = 0; i < 11; i++) {\r\n            _currentChance = _currentChance.add(_dragonTypes[i]);\r\n            if (_random < _currentChance) {\r\n                skillDragonType = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getBaseSkillIndex(uint8 _dragonType) internal pure returns (uint8) {\r\n        // 2 - stamina\r\n        // 0 - attack\r\n        // 3 - speed\r\n        // 1 - defense\r\n        // 4 - intelligence\r\n        uint8[5] memory _skills = [2, 0, 3, 1, 4];\r\n        return _skills[_dragonType];\r\n    }\r\n\r\n    function calculateSpecialBattleSkill(\r\n        uint8 _dragonType,\r\n        uint32[5] _skills\r\n    ) external pure returns (\r\n        uint32 cost,\r\n        uint8 factor,\r\n        uint8 chance\r\n    ) {\r\n        uint32 _baseSkill = _skills[_getBaseSkillIndex(_dragonType)];\r\n        uint32 _intelligence = _skills[4];\r\n\r\n        cost = _baseSkill.mul(3);\r\n        factor = _sqrt(_baseSkill.div(3)).add(10).toUint8(); // factor is increased by 10\r\n        // skill is multiplied by 100 so we divide the result by sqrt(100) = 10\r\n        chance = _sqrt(_intelligence).div(10).add(10).toUint8();\r\n    }\r\n\r\n    function _getSkillIndexBySpecialPeacefulSkillClass(\r\n        uint8 _class\r\n    ) internal pure returns (uint8) {\r\n        // 0 - attack\r\n        // 1 - defense\r\n        // 2 - stamina\r\n        // 3 - speed\r\n        // 4 - intelligence\r\n        uint8[8] memory _buffsIndexes = [0, 0, 1, 2, 3, 4, 2, 4]; // 0 item - no such class\r\n        return _buffsIndexes[_class];\r\n    }\r\n\r\n    function calculateSpecialPeacefulSkill(\r\n        uint8 _class,\r\n        uint32[5] _skills,\r\n        uint32[5] _buffs\r\n    ) external pure returns (uint32 cost, uint32 effect) {\r\n        uint32 _index = _getSkillIndexBySpecialPeacefulSkillClass(_class);\r\n        uint32 _skill = _calculateSkillWithBuff(_skills[_index], _buffs[_index]);\r\n        if (_class == 6 || _class == 7) { // healing or mana recharge\r\n            effect = _skill.mul(2);\r\n        } else {\r\n            // sqrt(skill / 30) + 1\r\n            effect = _sqrt(_skill.mul(10).div(3)).add(100); // effect is increased by 100 as skills\r\n        }\r\n        cost = _skill.mul(3);\r\n    }\r\n\r\n    function _getGeneVarietyFactor(uint8 _type) internal pure returns (uint32 value) {\r\n        // multiplied by 10\r\n        if (_type == 0) value = 5;\r\n        else if (_type < 5) value = 12;\r\n        else if (_type < 8) value = 16;\r\n        else value = 28;\r\n    }\r\n\r\n    function calculateCoolness(uint256[4] _composedGenome) external pure returns (uint32 coolness) {\r\n        uint8[16][10] memory _genome = _parseGenome(_composedGenome);\r\n        uint32 _geneVarietyFactor; // multiplied by 10\r\n        uint8 _strengthCoefficient; // multiplied by 10\r\n        uint8 _geneLevel;\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            for (uint8 j = 0; j < 4; j++) {\r\n                _geneVarietyFactor = _getGeneVarietyFactor(_genome[i][(j * 4) + 1]);\r\n                _strengthCoefficient = (_genome[i][(j * 4) + 3] == 0) ? 7 : 10; // recessive or dominant\r\n                _geneLevel = _genome[i][(j * 4) + 2];\r\n                coolness = coolness.add(_geneVarietyFactor.mul(_geneLevel).mul(_strengthCoefficient));\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateSkills(\r\n        uint256[4] _composed\r\n    ) external view returns (\r\n        uint32, uint32, uint32, uint32, uint32\r\n    ) {\r\n        uint8[30] memory _activeGenes = _getActiveGenes(_parseGenome(_composed));\r\n        uint8[5] memory _dragonTypeFactors;\r\n        uint8[5] memory _bodyPartFactors;\r\n        uint8[5] memory _geneTypeFactors;\r\n        uint8 _level;\r\n        uint32[5] memory _skills;\r\n\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            _bodyPartFactors = params.bodyPartsFactors(i);\r\n            _dragonTypeFactors = params.dragonTypesFactors(_activeGenes[i * 3]);\r\n            _geneTypeFactors = params.geneTypesFactors(_activeGenes[i * 3 + 1]);\r\n            _level = _activeGenes[i * 3 + 2];\r\n\r\n            for (uint8 j = 0; j < 5; j++) {\r\n                _skills[j] = _skills[j].add(uint32(_dragonTypeFactors[j]).mul(_bodyPartFactors[j]).mul(_geneTypeFactors[j]).mul(_level));\r\n            }\r\n        }\r\n        return (_skills[0], _skills[1], _skills[2], _skills[3], _skills[4]);\r\n    }\r\n\r\n    function calculateExperience(\r\n        uint8 _level,\r\n        uint256 _experience,\r\n        uint16 _dnaPoints,\r\n        uint256 _factor\r\n    ) external view returns (\r\n        uint8 level,\r\n        uint256 experience,\r\n        uint16 dnaPoints\r\n    ) {\r\n        level = _level;\r\n        experience = _experience;\r\n        dnaPoints = _dnaPoints;\r\n\r\n        uint8 _expToNextLvl;\r\n        // _factor is multiplied by 10\r\n        experience = experience.add(uint256(params.battlePoints()).mul(_factor).div(10));\r\n        _expToNextLvl = params.experienceToNextLevel(level);\r\n        while (experience >= _expToNextLvl && level < MAX_LEVEL) {\r\n            experience = experience.sub(_expToNextLvl);\r\n            level = level.add(1);\r\n            dnaPoints = dnaPoints.add(params.dnaPoints(level));\r\n            if (level < MAX_LEVEL) {\r\n                _expToNextLvl = params.experienceToNextLevel(level);\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkAndConvertName(string _input) external pure returns(bytes32, bytes32) {\r\n        return _convertName(_input);\r\n    }\r\n\r\n    function _checkIfEnoughDNAPoints(bool _isEnough) internal pure {\r\n        require(_isEnough, \"not enough DNA points for upgrade\");\r\n    }\r\n\r\n    function upgradeGenes(\r\n        uint256[4] _composedGenome,\r\n        uint16[10] _dnaPoints,\r\n        uint16 _availableDNAPoints\r\n    ) external view returns (\r\n        uint256[4],\r\n        uint16\r\n    ) {\r\n        uint16 _sum;\r\n        uint8 _i;\r\n        for (_i = 0; _i < 10; _i++) {\r\n            _checkIfEnoughDNAPoints(_dnaPoints[_i] <= _availableDNAPoints);\r\n            _sum = _sum.add(_dnaPoints[_i]);\r\n        }\r\n        _checkIfEnoughDNAPoints(_sum <= _availableDNAPoints);\r\n        _sum = 0;\r\n\r\n        uint8[16][10] memory _genome = _parseGenome(_composedGenome);\r\n        uint8 _geneLevelIndex;\r\n        uint8 _geneLevel;\r\n        uint16 _geneUpgradeDNAPoints;\r\n        uint8 _levelsToUpgrade;\r\n        uint16 _specificDNAPoints;\r\n        for (_i = 0; _i < 10; _i++) { // 10 active genes\r\n            _specificDNAPoints = _dnaPoints[_i]; // points to upgrade current gene\r\n            if (_specificDNAPoints > 0) {\r\n                _geneLevelIndex = _getActiveGeneIndex(_genome[_i]).mul(4).add(2); // index of main gene level in genome\r\n                _geneLevel = _genome[_i][_geneLevelIndex]; // current level of gene\r\n                if (_geneLevel < MAX_GENE_LVL) {\r\n                    // amount of points to upgrade to next level\r\n                    _geneUpgradeDNAPoints = params.geneUpgradeDNAPoints(_geneLevel);\r\n                    // while enough points and gene level is lower than max gene level\r\n                    while (_specificDNAPoints >= _geneUpgradeDNAPoints && _geneLevel.add(_levelsToUpgrade) < MAX_GENE_LVL) {\r\n                        _levelsToUpgrade = _levelsToUpgrade.add(1);\r\n                        _specificDNAPoints = _specificDNAPoints.sub(_geneUpgradeDNAPoints);\r\n                        _sum = _sum.add(_geneUpgradeDNAPoints); // the sum of used points\r\n                        if (_geneLevel.add(_levelsToUpgrade) < MAX_GENE_LVL) {\r\n                            _geneUpgradeDNAPoints = params.geneUpgradeDNAPoints(_geneLevel.add(_levelsToUpgrade));\r\n                        }\r\n                    }\r\n                    _genome[_i][_geneLevelIndex] = _geneLevel.add(_levelsToUpgrade); // add levels to current gene\r\n                    _levelsToUpgrade = 0;\r\n                }\r\n            }\r\n        }\r\n        return (_composeGenome(_genome), _sum);\r\n    }\r\n\r\n    function getActiveGenes(uint256[4] _composed) external pure returns (uint8[30]) {\r\n        uint8[16][10] memory _genome = _parseGenome(_composed);\r\n        return _getActiveGenes(_genome);\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        super.setInternalDependencies(_newDependencies);\r\n\r\n        params = DragonParams(_newDependencies[0]);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_dragonType\",\"type\":\"uint8\"},{\"name\":\"_skills\",\"type\":\"uint32[5]\"}],\"name\":\"calculateSpecialBattleSkill\",\"outputs\":[{\"name\":\"cost\",\"type\":\"uint32\"},{\"name\":\"factor\",\"type\":\"uint8\"},{\"name\":\"chance\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_experience\",\"type\":\"uint256\"},{\"name\":\"_dnaPoints\",\"type\":\"uint16\"},{\"name\":\"_factor\",\"type\":\"uint256\"}],\"name\":\"calculateExperience\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"experience\",\"type\":\"uint256\"},{\"name\":\"dnaPoints\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_class\",\"type\":\"uint8\"},{\"name\":\"_skills\",\"type\":\"uint32[5]\"},{\"name\":\"_buffs\",\"type\":\"uint32[5]\"}],\"name\":\"calculateSpecialPeacefulSkill\",\"outputs\":[{\"name\":\"cost\",\"type\":\"uint32\"},{\"name\":\"effect\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_composedGenome\",\"type\":\"uint256[4]\"}],\"name\":\"calculateCoolness\",\"outputs\":[{\"name\":\"coolness\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dragonTypes\",\"type\":\"uint8[11]\"},{\"name\":\"_random\",\"type\":\"uint256\"}],\"name\":\"getSpecialBattleSkillDragonType\",\"outputs\":[{\"name\":\"skillDragonType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pastTime\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint32\"},{\"name\":\"_remaining\",\"type\":\"uint32\"}],\"name\":\"calculateCurrent\",\"outputs\":[{\"name\":\"current\",\"type\":\"uint32\"},{\"name\":\"percentage\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_composed\",\"type\":\"uint256[4]\"}],\"name\":\"calculateSkills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max\",\"type\":\"uint32\"}],\"name\":\"calculateFullRegenerationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_composedGenome\",\"type\":\"uint256[4]\"},{\"name\":\"_dnaPoints\",\"type\":\"uint16[10]\"},{\"name\":\"_availableDNAPoints\",\"type\":\"uint16\"}],\"name\":\"upgradeGenes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_composed\",\"type\":\"uint256[4]\"}],\"name\":\"getActiveGenes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[30]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_input\",\"type\":\"string\"}],\"name\":\"checkAndConvertName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_initStamina\",\"type\":\"uint32\"},{\"name\":\"_initIntelligence\",\"type\":\"uint32\"},{\"name\":\"_staminaBuff\",\"type\":\"uint32\"},{\"name\":\"_intelligenceBuff\",\"type\":\"uint32\"}],\"name\":\"calculateHealthAndMana\",\"outputs\":[{\"name\":\"health\",\"type\":\"uint32\"},{\"name\":\"mana\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonCoreHelper","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://82f0afe4e1865bbc5f4e8b48e10b0e9774c0086a17360fd1278ada542226a33a"}]}