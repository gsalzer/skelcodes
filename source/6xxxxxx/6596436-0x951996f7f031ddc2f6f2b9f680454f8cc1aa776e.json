{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/********************* TPL Extended Jurisdiction - Devcon4 ********************\r\n * Use at your own risk, these contracts still need more testing & auditing!  *\r\n * For a more production-ready TPL jurisdiction, see the Basic Jurisdiction.  *\r\n * Documentation & tests at https://github.com/TPL-protocol/tpl-contracts     *\r\n * Implements an Attribute Registry https://github.com/0age/AttributeRegistry *\r\n *                                                                            *\r\n * Source layout:                                    Line #                   *\r\n *  - library ECDSA                                    41                     *\r\n *  - library SafeMath                                108                     *\r\n *  - library Roles                                   172                     *\r\n *  - contract PauserRole                             212                     *\r\n *    - using Roles for Roles.Role                                            *\r\n *  - contract Pausable                               257                     *\r\n *    - is PauserRole                                                         *\r\n *  - contract Ownable                                313                     *\r\n *  - interface AttributeRegistryInterface            386                     *\r\n *  - interface BasicJurisdictionInterface            440                     *\r\n *  - interface ExtendedJurisdictionInterface         658                     *\r\n *  - ExtendedJurisdiction                            926                     *\r\n *    - is Ownable                                                            *\r\n *    - is Pausable                                                           *\r\n *    - is AttributeRegistryInterface                                         *\r\n *    - is BasicJurisdictionInterface                                         *\r\n *    - is ExtendedJurisdictionInterface                                      *\r\n *    - using ECDSA for bytes32                                               *\r\n *    - using SafeMath for uint256                                            *\r\n *                                                                            *\r\n *  https://github.com/TPL-protocol/tpl-contracts/blob/master/LICENSE.md      *\r\n ******************************************************************************/\r\n\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\nlibrary ECDSA {\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes signature)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (signature.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(signature, 0x20))\r\n      s := mload(add(signature, 0x40))\r\n      v := byte(0, mload(add(signature, 0x60)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n    );\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(!has(role, account));\r\n\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(has(role, account));\r\n\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n\r\ncontract PauserRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event PauserAdded(address indexed account);\r\n  event PauserRemoved(address indexed account);\r\n\r\n  Roles.Role private pausers;\r\n\r\n  constructor() internal {\r\n    _addPauser(msg.sender);\r\n  }\r\n\r\n  modifier onlyPauser() {\r\n    require(isPauser(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isPauser(address account) public view returns (bool) {\r\n    return pausers.has(account);\r\n  }\r\n\r\n  function addPauser(address account) public onlyPauser {\r\n    _addPauser(account);\r\n  }\r\n\r\n  function renouncePauser() public {\r\n    _removePauser(msg.sender);\r\n  }\r\n\r\n  function _addPauser(address account) internal {\r\n    pausers.add(account);\r\n    emit PauserAdded(account);\r\n  }\r\n\r\n  function _removePauser(address account) internal {\r\n    pausers.remove(account);\r\n    emit PauserRemoved(account);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n  event Paused(address account);\r\n  event Unpaused(address account);\r\n\r\n  bool private _paused;\r\n\r\n  constructor() internal {\r\n    _paused = false;\r\n  }\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns(bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyPauser whenNotPaused {\r\n    _paused = true;\r\n    emit Paused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyPauser whenPaused {\r\n    _paused = false;\r\n    emit Unpaused(msg.sender);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Attribute Registry interface. EIP-165 ID: 0x5f46473f\r\n */\r\ninterface AttributeRegistryInterface {\r\n  /**\r\n   * @notice Check if an attribute of the type with ID `attributeTypeID` has\r\n   * been assigned to the account at `account` and is currently valid.\r\n   * @param account address The account to check for a valid attribute.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return True if the attribute is assigned and valid, false otherwise.\r\n   * @dev This function MUST return either true or false - i.e. calling this\r\n   * function MUST NOT cause the caller to revert.\r\n   */\r\n  function hasAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Retrieve the value of the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account`, assuming it is valid.\r\n   * @param account address The account to check for the given attribute value.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return The attribute value if the attribute is valid, reverts otherwise.\r\n   * @dev This function MUST revert if a directly preceding or subsequent\r\n   * function call to `hasAttribute` with identical `account` and\r\n   * `attributeTypeID` parameters would return false.\r\n   */\r\n  function getAttributeValue(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the registry.\r\n   * @return The number of available attribute types.\r\n   * @dev This function MUST return a positive integer value  - i.e. calling\r\n   * this function MUST NOT cause the caller to revert.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   * @dev This function MUST revert if the provided `index` value falls outside\r\n   * of the range of the value returned from a directly preceding or subsequent\r\n   * function call to `countAttributeTypes`. It MUST NOT revert if the provided\r\n   * `index` value falls inside said range.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic TPL Jurisdiction Interface.\r\n */\r\ninterface BasicJurisdictionInterface {\r\n  // declare events\r\n  event AttributeTypeAdded(uint256 indexed attributeTypeID, string description);\r\n  \r\n  event AttributeTypeRemoved(uint256 indexed attributeTypeID);\r\n  \r\n  event ValidatorAdded(address indexed validator, string description);\r\n  \r\n  event ValidatorRemoved(address indexed validator);\r\n  \r\n  event ValidatorApprovalAdded(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event ValidatorApprovalRemoved(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event AttributeAdded(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID,\r\n    uint256 attributeValue\r\n  );\r\n\r\n  event AttributeRemoved(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID\r\n  );\r\n\r\n  /**\r\n  * @notice Add an attribute type with ID `ID` and description `description` to\r\n  * the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to add.\r\n  * @param description string A description of the attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description of the\r\n  * attribute type cannot be changed, even if the attribute type is removed and\r\n  * added back later.\r\n  */\r\n  function addAttributeType(uint256 ID, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to remove.\r\n  * @dev All issued attributes of the given type will become invalid upon\r\n  * removal, but will become valid again if the attribute is reinstated.\r\n  */\r\n  function removeAttributeType(uint256 ID) external;\r\n\r\n  /**\r\n  * @notice Add account `validator` as a validator with a description\r\n  * `description` who can be approved to set attributes of specific types.\r\n  * @param validator address The account to assign as the validator.\r\n  * @param description string A description of the validator.\r\n  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\r\n  */\r\n  function addValidator(address validator, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the validator at address `validator` from the jurisdiction.\r\n  * @param validator address The account of the validator to remove.\r\n  * @dev Any attributes issued by the validator will become invalid upon their\r\n  * removal. If the validator is reinstated, those attributes will become valid\r\n  * again. Any approvals to issue attributes of a given type will need to be\r\n  * set from scratch in the event a validator is reinstated.\r\n  */\r\n  function removeValidator(address validator) external;\r\n\r\n  /**\r\n  * @notice Approve the validator at address `validator` to issue attributes of\r\n  * the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator to approve.\r\n  * @param attributeTypeID uint256 The ID of the approved attribute type.\r\n  */\r\n  function addValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Deny the validator at address `validator` the ability to continue to\r\n  * issue attributes of the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator with removed approval.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\r\n  * @dev Any attributes of the specified type issued by the validator in\r\n  * question will become invalid once the approval is removed. If the approval\r\n  * is reinstated, those attributes will become valid again. The approval will\r\n  * also be removed if the approved validator is removed.\r\n  */\r\n  function removeValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\r\n  * of `value` to `account` if `message.caller.address()` is approved validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @param value uint256 An optional value for the issued attribute.\r\n  * @dev Existing attributes of the given type on the address must be removed\r\n  * in order to set a new attribute. Be aware that ownership of the account to\r\n  * which the attribute is assigned may still be transferable - restricting\r\n  * assignment to externally-owned accounts may partially alleviate this issue.\r\n  */\r\n  function issueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value\r\n  ) external payable;\r\n\r\n  /**\r\n  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\r\n  * `account` if `message.caller.address()` is the issuing validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @dev Validators may still revoke issued attributes even after they have been\r\n  * removed or had their approval to issue the attribute type removed - this\r\n  * enables them to address any objectionable issuances before being reinstated.\r\n  */\r\n  function revokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Determine if a validator at account `validator` is able to issue\r\n   * attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canIssueAttributeType(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Get a description of the attribute type with ID `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return A description of the attribute type.\r\n   */\r\n  function getAttributeTypeDescription(\r\n    uint256 attributeTypeID\r\n  ) external view returns (string description);\r\n  \r\n  /**\r\n   * @notice Get a description of the validator at account `validator`.\r\n   * @param validator address The account of the validator in question.\r\n   * @return A description of the validator.\r\n   */\r\n  function getValidatorDescription(\r\n    address validator\r\n  ) external view returns (string description);\r\n\r\n  /**\r\n   * @notice Find the validator that issued the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account` and determine if the\r\n   * validator is still valid.\r\n   * @param account address The account that contains the attribute be checked.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return The validator and the current status of the validator as it\r\n   * pertains to the attribute type in question.\r\n   * @dev if no attribute of the given attribute type exists on the account, the\r\n   * function will return (address(0), false).\r\n   */\r\n  function getAttributeValidator(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (address validator, bool isStillValid);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the jurisdiction.\r\n   * @return The number of available attribute types.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the IDs of all available attribute types on the jurisdiction.\r\n   * @return A dynamic array containing all available attribute type IDs.\r\n   */\r\n  function getAttributeTypeIDs() external view returns (uint256[]);\r\n\r\n  /**\r\n   * @notice Count the number of validators defined by the jurisdiction.\r\n   * @return The number of defined validators.\r\n   */\r\n  function countValidators() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the account of the validator at index `index`.\r\n   * @param index uint256 The index of the validator in question.\r\n   * @return The account of the validator.\r\n   */\r\n  function getValidator(uint256 index) external view returns (address);\r\n\r\n  /**\r\n   * @notice Get the accounts of all available validators on the jurisdiction.\r\n   * @return A dynamic array containing all available validator accounts.\r\n   */\r\n  function getValidators() external view returns (address[]);\r\n}\r\n\r\n/**\r\n * @title Extended TPL Jurisdiction Interface.\r\n * @dev this extends BasicJurisdictionInterface for additional functionality.\r\n */\r\ninterface ExtendedJurisdictionInterface {\r\n  // declare events (NOTE: consider which fields should be indexed)\r\n  event ValidatorSigningKeyModified(\r\n    address indexed validator,\r\n    address newSigningKey\r\n  );\r\n\r\n  event StakeAllocated(\r\n    address indexed staker,\r\n    uint256 indexed attribute,\r\n    uint256 amount\r\n  );\r\n\r\n  event StakeRefunded(\r\n    address indexed staker,\r\n    uint256 indexed attribute,\r\n    uint256 amount\r\n  );\r\n\r\n  event FeePaid(\r\n    address indexed recipient,\r\n    address indexed payee,\r\n    uint256 indexed attribute,\r\n    uint256 amount\r\n  );\r\n  \r\n  event TransactionRebatePaid(\r\n    address indexed submitter,\r\n    address indexed payee,\r\n    uint256 indexed attribute,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n  * @notice Add a restricted attribute type with ID `ID` and description\r\n  * `description` to the jurisdiction. Restricted attribute types can only be\r\n  * removed by the issuing validator or the jurisdiction.\r\n  * @param ID uint256 The ID of the restricted attribute type to add.\r\n  * @param description string A description of the restricted attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description or the\r\n  * restricted status of the attribute type cannot be changed, even if the\r\n  * attribute type is removed and added back later.\r\n  */\r\n  function addRestrictedAttributeType(uint256 ID, string description) external;\r\n\r\n  /**\r\n  * @notice Enable or disable a restriction for a given attribute type ID `ID`\r\n  * that prevents attributes of the given type from being set by operators based\r\n  * on the provided value for `onlyPersonal`.\r\n  * @param ID uint256 The attribute type ID in question.\r\n  * @param onlyPersonal bool Whether the address may only be set personally.\r\n  */\r\n  function setAttributeTypeOnlyPersonal(uint256 ID, bool onlyPersonal) external;\r\n\r\n  /**\r\n  * @notice Set a secondary source for a given attribute type ID `ID`, with an\r\n  * address `registry` of the secondary source in question and a given\r\n  * `sourceAttributeTypeID` for attribute type ID to check on the secondary\r\n  * source. The secondary source will only be checked for the given attribute in\r\n  * cases where no attribute of the given attribute type ID is assigned locally.\r\n  * @param ID uint256 The attribute type ID to set the secondary source for.\r\n  * @param attributeRegistry address The secondary attribute registry account.\r\n  * @param sourceAttributeTypeID uint256 The attribute type ID on the secondary\r\n  * source to check.\r\n  * @dev To remove a secondary source on an attribute type, the registry address\r\n  * should be set to the null address.\r\n  */\r\n  function setAttributeTypeSecondarySource(\r\n    uint256 ID,\r\n    address attributeRegistry,\r\n    uint256 sourceAttributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Set a minimum required stake for a given attribute type ID `ID` and\r\n  * an amount of `stake`, to be locked in the jurisdiction upon assignment of\r\n  * attributes of the given type. The stake will be applied toward a transaction\r\n  * rebate in the event the attribute is revoked, with the remainder returned to\r\n  * the staker.\r\n  * @param ID uint256 The attribute type ID to set a minimum required stake for.\r\n  * @param minimumRequiredStake uint256 The minimum required funds to lock up.\r\n  * @dev To remove a stake requirement from an attribute type, the stake amount\r\n  * should be set to 0.\r\n  */\r\n  function setAttributeTypeMinimumRequiredStake(\r\n    uint256 ID,\r\n    uint256 minimumRequiredStake\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Set a required fee for a given attribute type ID `ID` and an amount\r\n  * of `fee`, to be paid to the owner of the jurisdiction upon assignment of\r\n  * attributes of the given type.\r\n  * @param ID uint256 The attribute type ID to set the required fee for.\r\n  * @param fee uint256 The required fee amount to be paid upon assignment.\r\n  * @dev To remove a fee requirement from an attribute type, the fee amount\r\n  * should be set to 0.\r\n  */\r\n  function setAttributeTypeJurisdictionFee(uint256 ID, uint256 fee) external;\r\n\r\n  /**\r\n  * @notice Set the public address associated with a validator signing key, used\r\n  * to sign off-chain attribute approvals, as `newSigningKey`.\r\n  * @param newSigningKey address The address associated with signing key to set.\r\n  */\r\n  function setValidatorSigningKey(address newSigningKey) external;\r\n\r\n  /**\r\n  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\r\n  * value of `value`, and an associated validator fee of `validatorFee` to\r\n  * account of `msg.sender` by passing in a signed attribute approval with\r\n  * signature `signature`.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to add.\r\n  * @param value uint256 The value for the attribute to add.\r\n  * @param validatorFee uint256 The fee to be paid to the issuing validator.\r\n  * @param signature bytes The signature from the validator attribute approval.\r\n  */\r\n  function addAttribute(\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external payable;\r\n\r\n  /**\r\n  * @notice Remove an attribute of the type with ID `attributeTypeID` from\r\n  * account of `msg.sender`.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to remove.\r\n  */\r\n  function removeAttribute(uint256 attributeTypeID) external;\r\n\r\n  /**\r\n  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\r\n  * value of `value`, and an associated validator fee of `validatorFee` to\r\n  * account `account` by passing in a signed attribute approval with signature\r\n  * `signature`.\r\n  * @param account address The account to add the attribute to.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to add.\r\n  * @param value uint256 The value for the attribute to add.\r\n  * @param validatorFee uint256 The fee to be paid to the issuing validator.\r\n  * @param signature bytes The signature from the validator attribute approval.\r\n  * @dev Restricted attribute types can only be removed by issuing validators or\r\n  * the jurisdiction itself.\r\n  */\r\n  function addAttributeFor(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external payable;\r\n\r\n  /**\r\n  * @notice Remove an attribute of the type with ID `attributeTypeID` from\r\n  * account of `account`.\r\n  * @param account address The account to remove the attribute from.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to remove.\r\n  * @dev Restricted attribute types can only be removed by issuing validators or\r\n  * the jurisdiction itself.\r\n  */\r\n  function removeAttributeFor(address account, uint256 attributeTypeID) external;\r\n\r\n  /**\r\n   * @notice Invalidate a signed attribute approval before it has been set by\r\n   * supplying the hash of the approval `hash` and the signature `signature`.\r\n   * @param hash bytes32 The hash of the attribute approval.\r\n   * @param signature bytes The hash's signature, resolving to the signing key.\r\n   * @dev Attribute approvals can only be removed by issuing validators or the\r\n   * jurisdiction itself.\r\n   */\r\n  function invalidateAttributeApproval(\r\n    bytes32 hash,\r\n    bytes signature\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Get the hash of a given attribute approval.\r\n   * @param account address The account specified by the attribute approval.\r\n   * @param operator address An optional account permitted to submit approval.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @param value uint256 The value of the attribute in the approval.\r\n   * @param fundsRequired uint256 The amount to be included with the approval.\r\n   * @param validatorFee uint256 The required fee to be paid to the validator.\r\n   * @return The hash of the attribute approval.\r\n   */\r\n  function getAttributeApprovalHash(\r\n    address account,\r\n    address operator,\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 fundsRequired,\r\n    uint256 validatorFee\r\n  ) external view returns (bytes32 hash);\r\n\r\n  /**\r\n   * @notice Check if a given signed attribute approval is currently valid when\r\n   * submitted directly by `msg.sender`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @param value uint256 The value of the attribute in the approval.\r\n   * @param fundsRequired uint256 The amount to be included with the approval.\r\n   * @param validatorFee uint256 The required fee to be paid to the validator.\r\n   * @param signature bytes The attribute approval signature, based on a hash of\r\n   * the other parameters and the submitting account.\r\n   * @return True if the approval is currently valid, false otherwise.\r\n   */\r\n  function canAddAttribute(\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 fundsRequired,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Check if a given signed attribute approval is currently valid for a\r\n   * given account when submitted by the operator at `msg.sender`.\r\n   * @param account address The account specified by the attribute approval.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @param value uint256 The value of the attribute in the approval.\r\n   * @param fundsRequired uint256 The amount to be included with the approval.\r\n   * @param validatorFee uint256 The required fee to be paid to the validator.\r\n   * @param signature bytes The attribute approval signature, based on a hash of\r\n   * the other parameters and the submitting account.\r\n   * @return True if the approval is currently valid, false otherwise.\r\n   */\r\n  function canAddAttributeFor(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 fundsRequired,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Get comprehensive information on an attribute type with ID\r\n   * `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The attribute type ID in question.\r\n   * @return Information on the attribute type in question.\r\n   */\r\n  function getAttributeTypeInformation(\r\n    uint256 attributeTypeID\r\n  ) external view returns (\r\n    string description,\r\n    bool isRestricted,\r\n    bool isOnlyPersonal,\r\n    address secondarySource,\r\n    uint256 secondaryId,\r\n    uint256 minimumRequiredStake,\r\n    uint256 jurisdictionFee\r\n  );\r\n  \r\n  /**\r\n   * @notice Get a validator's signing key.\r\n   * @param validator address The account of the validator.\r\n   * @return The account referencing the public component of the signing key.\r\n   */\r\n  function getValidatorSigningKey(\r\n    address validator\r\n  ) external view returns (\r\n    address signingKey\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title An extended TPL jurisdiction for assigning attributes to addresses.\r\n */\r\ncontract ExtendedJurisdiction is Ownable, Pausable, AttributeRegistryInterface, BasicJurisdictionInterface, ExtendedJurisdictionInterface {\r\n  using ECDSA for bytes32;\r\n  using SafeMath for uint256;\r\n\r\n  // validators are entities who can add or authorize addition of new attributes\r\n  struct Validator {\r\n    bool exists;\r\n    uint256 index; // NOTE: consider use of uint88 to pack struct\r\n    address signingKey;\r\n    string description;\r\n  }\r\n\r\n  // attributes are properties that validators associate with specific addresses\r\n  struct IssuedAttribute {\r\n    bool exists;\r\n    bool setPersonally;\r\n    address operator;\r\n    address validator;\r\n    uint256 value;\r\n    uint256 stake;\r\n  }\r\n\r\n  // attributes also have associated type - metadata common to each attribute\r\n  struct AttributeType {\r\n    bool exists;\r\n    bool restricted;\r\n    bool onlyPersonal;\r\n    uint256 index; // NOTE: consider use of uint72 to pack struct\r\n    address secondarySource;\r\n    uint256 secondaryAttributeTypeID;\r\n    uint256 minimumStake;\r\n    uint256 jurisdictionFee;\r\n    string description;\r\n    mapping(address => bool) approvedValidators;\r\n  }\r\n\r\n  // top-level information about attribute types is held in a mapping of structs\r\n  mapping(uint256 => AttributeType) private _attributeTypes;\r\n\r\n  // the jurisdiction retains a mapping of addresses with assigned attributes\r\n  mapping(address => mapping(uint256 => IssuedAttribute)) private _issuedAttributes;\r\n\r\n  // there is also a mapping to identify all approved validators and their keys\r\n  mapping(address => Validator) private _validators;\r\n\r\n  // each registered signing key maps back to a specific validator\r\n  mapping(address => address) private _signingKeys;\r\n\r\n  // once attribute types are assigned to an ID, they cannot be modified\r\n  mapping(uint256 => bytes32) private _attributeTypeHashes;\r\n\r\n  // submitted attribute approvals are retained to prevent reuse after removal \r\n  mapping(bytes32 => bool) private _invalidAttributeApprovalHashes;\r\n\r\n  // attribute approvals by validator are held in a mapping\r\n  mapping(address => uint256[]) private _validatorApprovals;\r\n\r\n   // attribute approval index by validator is tracked as well\r\n  mapping(address => mapping(uint256 => uint256)) private _validatorApprovalsIndex;\r\n\r\n  // IDs for all supplied attributes are held in an array (enables enumeration)\r\n  uint256[] private _attributeIDs;\r\n\r\n  // addresses for all designated validators are also held in an array\r\n  address[] private _validatorAccounts;\r\n\r\n  /**\r\n  * @notice Add an attribute type with ID `ID` and description `description` to\r\n  * the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to add.\r\n  * @param description string A description of the attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description of the\r\n  * attribute type cannot be changed, even if the attribute type is removed and\r\n  * added back later.\r\n  */\r\n  function addAttributeType(\r\n    uint256 ID,\r\n    string description\r\n  ) external onlyOwner whenNotPaused {\r\n    // prevent existing attributes with the same id from being overwritten\r\n    require(\r\n      !isAttributeType(ID),\r\n      \"an attribute type with the provided ID already exists\"\r\n    );\r\n\r\n    // calculate a hash of the attribute type based on the type's properties\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\r\n        ID, false, description\r\n      )\r\n    );\r\n\r\n    // store hash if attribute type is the first one registered with provided ID\r\n    if (_attributeTypeHashes[ID] == bytes32(0)) {\r\n      _attributeTypeHashes[ID] = hash;\r\n    }\r\n\r\n    // prevent addition if different attribute type with the same ID has existed\r\n    require(\r\n      hash == _attributeTypeHashes[ID],\r\n      \"attribute type properties must match initial properties assigned to ID\"\r\n    );\r\n\r\n    // set the attribute mapping, assigning the index as the end of attributeID\r\n    _attributeTypes[ID] = AttributeType({\r\n      exists: true,\r\n      restricted: false, // when true: users can't remove attribute\r\n      onlyPersonal: false, // when true: operators can't add attribute\r\n      index: _attributeIDs.length,\r\n      secondarySource: address(0), // the address of a remote registry\r\n      secondaryAttributeTypeID: uint256(0), // the attribute type id to query\r\n      minimumStake: uint256(0), // when > 0: users must stake ether to set\r\n      jurisdictionFee: uint256(0),\r\n      description: description\r\n      // NOTE: no approvedValidators variable declaration - must be added later\r\n    });\r\n    \r\n    // add the attribute type id to the end of the attributeID array\r\n    _attributeIDs.push(ID);\r\n\r\n    // log the addition of the attribute type\r\n    emit AttributeTypeAdded(ID, description);\r\n  }\r\n\r\n  /**\r\n  * @notice Add a restricted attribute type with ID `ID` and description\r\n  * `description` to the jurisdiction. Restricted attribute types can only be\r\n  * removed by the issuing validator or the jurisdiction.\r\n  * @param ID uint256 The ID of the restricted attribute type to add.\r\n  * @param description string A description of the restricted attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description or the\r\n  * restricted status of the attribute type cannot be changed, even if the\r\n  * attribute type is removed and added back later.\r\n  */\r\n  function addRestrictedAttributeType(\r\n    uint256 ID,\r\n    string description\r\n  ) external onlyOwner whenNotPaused {\r\n    // prevent existing attributes with the same id from being overwritten\r\n    require(\r\n      !isAttributeType(ID),\r\n      \"an attribute type with the provided ID already exists\"\r\n    );\r\n\r\n    // calculate a hash of the attribute type based on the type's properties\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\r\n        ID, true, description\r\n      )\r\n    );\r\n\r\n    // store hash if attribute type is the first one registered with provided ID\r\n    if (_attributeTypeHashes[ID] == bytes32(0)) {\r\n      _attributeTypeHashes[ID] = hash;\r\n    }\r\n\r\n    // prevent addition if different attribute type with the same ID has existed\r\n    require(\r\n      hash == _attributeTypeHashes[ID],\r\n      \"attribute type properties must match initial properties assigned to ID\"\r\n    );\r\n\r\n    // set the attribute mapping, assigning the index as the end of attributeID\r\n    _attributeTypes[ID] = AttributeType({\r\n      exists: true,\r\n      restricted: true, // when true: users can't remove attribute\r\n      onlyPersonal: false, // when true: operators can't add attribute\r\n      index: _attributeIDs.length,\r\n      secondarySource: address(0), // the address of a remote registry\r\n      secondaryAttributeTypeID: uint256(0), // the attribute type id to query\r\n      minimumStake: uint256(0), // when > 0: users must stake ether to set\r\n      jurisdictionFee: uint256(0),\r\n      description: description\r\n      // NOTE: no approvedValidators variable declaration - must be added later\r\n    });\r\n    \r\n    // add the attribute type id to the end of the attributeID array\r\n    _attributeIDs.push(ID);\r\n\r\n    // log the addition of the attribute type\r\n    emit AttributeTypeAdded(ID, description);\r\n  }\r\n\r\n  /**\r\n  * @notice Enable or disable a restriction for a given attribute type ID `ID`\r\n  * that prevents attributes of the given type from being set by operators based\r\n  * on the provided value for `onlyPersonal`.\r\n  * @param ID uint256 The attribute type ID in question.\r\n  * @param onlyPersonal bool Whether the address may only be set personally.\r\n  */\r\n  function setAttributeTypeOnlyPersonal(uint256 ID, bool onlyPersonal) external {\r\n    // if the attribute type ID does not exist, there is nothing to remove\r\n    require(\r\n      isAttributeType(ID),\r\n      \"unable to set to only personal, no attribute type with the provided ID\"\r\n    );\r\n\r\n    // modify the attribute type in the mapping\r\n    _attributeTypes[ID].onlyPersonal = onlyPersonal;\r\n  }\r\n\r\n  /**\r\n  * @notice Set a secondary source for a given attribute type ID `ID`, with an\r\n  * address `registry` of the secondary source in question and a given\r\n  * `sourceAttributeTypeID` for attribute type ID to check on the secondary\r\n  * source. The secondary source will only be checked for the given attribute in\r\n  * cases where no attribute of the given attribute type ID is assigned locally.\r\n  * @param ID uint256 The attribute type ID to set the secondary source for.\r\n  * @param attributeRegistry address The secondary attribute registry account.\r\n  * @param sourceAttributeTypeID uint256 The attribute type ID on the secondary\r\n  * source to check.\r\n  * @dev To remove a secondary source on an attribute type, the registry address\r\n  * should be set to the null address.\r\n  */\r\n  function setAttributeTypeSecondarySource(\r\n    uint256 ID,\r\n    address attributeRegistry,\r\n    uint256 sourceAttributeTypeID\r\n  ) external {\r\n    // if the attribute type ID does not exist, there is nothing to remove\r\n    require(\r\n      isAttributeType(ID),\r\n      \"unable to set secondary source, no attribute type with the provided ID\"\r\n    );\r\n\r\n    // modify the attribute type in the mapping\r\n    _attributeTypes[ID].secondarySource = attributeRegistry;\r\n    _attributeTypes[ID].secondaryAttributeTypeID = sourceAttributeTypeID;\r\n  }\r\n\r\n  /**\r\n  * @notice Set a minimum required stake for a given attribute type ID `ID` and\r\n  * an amount of `stake`, to be locked in the jurisdiction upon assignment of\r\n  * attributes of the given type. The stake will be applied toward a transaction\r\n  * rebate in the event the attribute is revoked, with the remainder returned to\r\n  * the staker.\r\n  * @param ID uint256 The attribute type ID to set a minimum required stake for.\r\n  * @param minimumRequiredStake uint256 The minimum required funds to lock up.\r\n  * @dev To remove a stake requirement from an attribute type, the stake amount\r\n  * should be set to 0.\r\n  */\r\n  function setAttributeTypeMinimumRequiredStake(\r\n    uint256 ID,\r\n    uint256 minimumRequiredStake\r\n  ) external {\r\n    // if the attribute type ID does not exist, there is nothing to remove\r\n    require(\r\n      isAttributeType(ID),\r\n      \"unable to set minimum stake, no attribute type with the provided ID\"\r\n    );\r\n\r\n    // modify the attribute type in the mapping\r\n    _attributeTypes[ID].minimumStake = minimumRequiredStake;\r\n  }\r\n\r\n  /**\r\n  * @notice Set a required fee for a given attribute type ID `ID` and an amount\r\n  * of `fee`, to be paid to the owner of the jurisdiction upon assignment of\r\n  * attributes of the given type.\r\n  * @param ID uint256 The attribute type ID to set the required fee for.\r\n  * @param fee uint256 The required fee amount to be paid upon assignment.\r\n  * @dev To remove a fee requirement from an attribute type, the fee amount\r\n  * should be set to 0.\r\n  */\r\n  function setAttributeTypeJurisdictionFee(uint256 ID, uint256 fee) external {\r\n    // if the attribute type ID does not exist, there is nothing to remove\r\n    require(\r\n      isAttributeType(ID),\r\n      \"unable to set fee, no attribute type with the provided ID\"\r\n    );\r\n\r\n    // modify the attribute type in the mapping\r\n    _attributeTypes[ID].jurisdictionFee = fee;\r\n  }\r\n\r\n  /**\r\n  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to remove.\r\n  * @dev All issued attributes of the given type will become invalid upon\r\n  * removal, but will become valid again if the attribute is reinstated.\r\n  */\r\n  function removeAttributeType(uint256 ID) external onlyOwner whenNotPaused {\r\n    // if the attribute type ID does not exist, there is nothing to remove\r\n    require(\r\n      isAttributeType(ID),\r\n      \"unable to remove, no attribute type with the provided ID\"\r\n    );\r\n\r\n    // get the attribute ID at the last index of the array\r\n    uint256 lastAttributeID = _attributeIDs[_attributeIDs.length.sub(1)];\r\n\r\n    // set the attributeID at attribute-to-delete.index to the last attribute ID\r\n    _attributeIDs[_attributeTypes[ID].index] = lastAttributeID;\r\n\r\n    // update the index of the attribute type that was moved\r\n    _attributeTypes[lastAttributeID].index = _attributeTypes[ID].index;\r\n    \r\n    // remove the (now duplicate) attribute ID at the end by trimming the array\r\n    _attributeIDs.length--;\r\n\r\n    // delete the attribute type's record from the mapping\r\n    delete _attributeTypes[ID];\r\n\r\n    // log the removal of the attribute type\r\n    emit AttributeTypeRemoved(ID);\r\n  }\r\n\r\n  /**\r\n  * @notice Add account `validator` as a validator with a description\r\n  * `description` who can be approved to set attributes of specific types.\r\n  * @param validator address The account to assign as the validator.\r\n  * @param description string A description of the validator.\r\n  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\r\n  */\r\n  function addValidator(\r\n    address validator,\r\n    string description\r\n  ) external onlyOwner whenNotPaused {\r\n    // check that an empty address was not provided by mistake\r\n    require(validator != address(0), \"must supply a valid address\");\r\n\r\n    // prevent existing validators from being overwritten\r\n    require(\r\n      !isValidator(validator),\r\n      \"a validator with the provided address already exists\"\r\n    );\r\n\r\n    // prevent duplicate signing keys from being created\r\n    require(\r\n      _signingKeys[validator] == address(0),\r\n      \"a signing key matching the provided address already exists\"\r\n    );\r\n    \r\n    // create a record for the validator\r\n    _validators[validator] = Validator({\r\n      exists: true,\r\n      index: _validatorAccounts.length,\r\n      signingKey: validator, // NOTE: this will be initially set to same address\r\n      description: description\r\n    });\r\n\r\n    // set the initial signing key (the validator's address) resolving to itself\r\n    _signingKeys[validator] = validator;\r\n\r\n    // add the validator to the end of the _validatorAccounts array\r\n    _validatorAccounts.push(validator);\r\n    \r\n    // log the addition of the new validator\r\n    emit ValidatorAdded(validator, description);\r\n  }\r\n\r\n  /**\r\n  * @notice Remove the validator at address `validator` from the jurisdiction.\r\n  * @param validator address The account of the validator to remove.\r\n  * @dev Any attributes issued by the validator will become invalid upon their\r\n  * removal. If the validator is reinstated, those attributes will become valid\r\n  * again. Any approvals to issue attributes of a given type will need to be\r\n  * set from scratch in the event a validator is reinstated.\r\n  */\r\n  function removeValidator(address validator) external onlyOwner whenNotPaused {\r\n    // check that a validator exists at the provided address\r\n    require(\r\n      isValidator(validator),\r\n      \"unable to remove, no validator located at the provided address\"\r\n    );\r\n\r\n    // first, start removing validator approvals until gas is exhausted\r\n    while (_validatorApprovals[validator].length > 0 && gasleft() > 25000) {\r\n      // locate the index of last attribute ID in the validator approval group\r\n      uint256 lastIndex = _validatorApprovals[validator].length.sub(1);\r\n\r\n      // locate the validator approval to be removed\r\n      uint256 targetApproval = _validatorApprovals[validator][lastIndex];\r\n\r\n      // remove the record of the approval from the associated attribute type\r\n      delete _attributeTypes[targetApproval].approvedValidators[validator];\r\n\r\n      // remove the record of the index of the approval\r\n      delete _validatorApprovalsIndex[validator][targetApproval];\r\n\r\n      // drop the last attribute ID from the validator approval group\r\n      _validatorApprovals[validator].length--;\r\n    }\r\n\r\n    // require that all approvals were successfully removed\r\n    require(\r\n      _validatorApprovals[validator].length == 0,\r\n      \"Cannot remove validator - first remove any existing validator approvals\"\r\n    );\r\n\r\n    // get the validator address at the last index of the array\r\n    address lastAccount = _validatorAccounts[_validatorAccounts.length.sub(1)];\r\n\r\n    // set the address at validator-to-delete.index to last validator address\r\n    _validatorAccounts[_validators[validator].index] = lastAccount;\r\n\r\n    // update the index of the attribute type that was moved\r\n    _validators[lastAccount].index = _validators[validator].index;\r\n    \r\n    // remove (duplicate) validator address at the end by trimming the array\r\n    _validatorAccounts.length--;\r\n\r\n    // remove the validator's signing key from its mapping\r\n    delete _signingKeys[_validators[validator].signingKey];\r\n\r\n    // remove the validator record\r\n    delete _validators[validator];\r\n\r\n    // log the removal of the validator\r\n    emit ValidatorRemoved(validator);\r\n  }\r\n\r\n  /**\r\n  * @notice Approve the validator at address `validator` to issue attributes of\r\n  * the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator to approve.\r\n  * @param attributeTypeID uint256 The ID of the approved attribute type.\r\n  */\r\n  function addValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external onlyOwner whenNotPaused {\r\n    // check that the attribute is predefined and that the validator exists\r\n    require(\r\n      isValidator(validator) && isAttributeType(attributeTypeID),\r\n      \"must specify both a valid attribute and an available validator\"\r\n    );\r\n\r\n    // check that the validator is not already approved\r\n    require(\r\n      !_attributeTypes[attributeTypeID].approvedValidators[validator],\r\n      \"validator is already approved on the provided attribute\"\r\n    );\r\n\r\n    // set the validator approval status on the attribute\r\n    _attributeTypes[attributeTypeID].approvedValidators[validator] = true;\r\n\r\n    // add the record of the index of the validator approval to be added\r\n    uint256 index = _validatorApprovals[validator].length;\r\n    _validatorApprovalsIndex[validator][attributeTypeID] = index;\r\n\r\n    // include the attribute type in the validator approval mapping\r\n    _validatorApprovals[validator].push(attributeTypeID);\r\n\r\n    // log the addition of the validator's attribute type approval\r\n    emit ValidatorApprovalAdded(validator, attributeTypeID);\r\n  }\r\n\r\n  /**\r\n  * @notice Deny the validator at address `validator` the ability to continue to\r\n  * issue attributes of the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator with removed approval.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\r\n  * @dev Any attributes of the specified type issued by the validator in\r\n  * question will become invalid once the approval is removed. If the approval\r\n  * is reinstated, those attributes will become valid again. The approval will\r\n  * also be removed if the approved validator is removed.\r\n  */\r\n  function removeValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external onlyOwner whenNotPaused {\r\n    // check that the attribute is predefined and that the validator exists\r\n    require(\r\n      canValidate(validator, attributeTypeID),\r\n      \"unable to remove validator approval, attribute is already unapproved\"\r\n    );\r\n\r\n    // remove the validator approval status from the attribute\r\n    delete _attributeTypes[attributeTypeID].approvedValidators[validator];\r\n\r\n    // locate the index of the last validator approval\r\n    uint256 lastIndex = _validatorApprovals[validator].length.sub(1);\r\n\r\n    // locate the last attribute ID in the validator approval group\r\n    uint256 lastAttributeID = _validatorApprovals[validator][lastIndex];\r\n\r\n    // locate the index of the validator approval to be removed\r\n    uint256 index = _validatorApprovalsIndex[validator][attributeTypeID];\r\n\r\n    // replace the validator approval with the last approval in the array\r\n    _validatorApprovals[validator][index] = lastAttributeID;\r\n\r\n    // drop the last attribute ID from the validator approval group\r\n    _validatorApprovals[validator].length--;\r\n\r\n    // update the record of the index of the swapped-in approval\r\n    _validatorApprovalsIndex[validator][lastAttributeID] = index;\r\n\r\n    // remove the record of the index of the removed approval\r\n    delete _validatorApprovalsIndex[validator][attributeTypeID];\r\n    \r\n    // log the removal of the validator's attribute type approval\r\n    emit ValidatorApprovalRemoved(validator, attributeTypeID);\r\n  }\r\n\r\n  /**\r\n  * @notice Set the public address associated with a validator signing key, used\r\n  * to sign off-chain attribute approvals, as `newSigningKey`.\r\n  * @param newSigningKey address The address associated with signing key to set.\r\n  * @dev Consider having the validator submit a signed proof demonstrating that\r\n  * the provided signing key is indeed a signing key in their control - this\r\n  * helps mitigate the fringe attack vector where a validator could set the\r\n  * address of another validator candidate (especially in the case of a deployed\r\n  * smart contract) as their \"signing key\" in order to block them from being\r\n  * added to the jurisdiction (due to the required property of signing keys\r\n  * being unique, coupled with the fact that new validators are set up with\r\n  * their address as the default initial signing key).\r\n  */\r\n  function setValidatorSigningKey(address newSigningKey) external {\r\n    require(\r\n      isValidator(msg.sender),\r\n      \"only validators may modify validator signing keys\");\r\n \r\n    // prevent duplicate signing keys from being created\r\n    require(\r\n      _signingKeys[newSigningKey] == address(0),\r\n      \"a signing key matching the provided address already exists\"\r\n    );\r\n\r\n    // remove validator address as the resolved value for the old key\r\n    delete _signingKeys[_validators[msg.sender].signingKey];\r\n\r\n    // set the signing key to the new value\r\n    _validators[msg.sender].signingKey = newSigningKey;\r\n\r\n    // add validator address as the resolved value for the new key\r\n    _signingKeys[newSigningKey] = msg.sender;\r\n\r\n    // log the modification of the signing key\r\n    emit ValidatorSigningKeyModified(msg.sender, newSigningKey);\r\n  }\r\n\r\n  /**\r\n  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\r\n  * of `value` to `account` if `message.caller.address()` is approved validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @param value uint256 An optional value for the issued attribute.\r\n  * @dev Existing attributes of the given type on the address must be removed\r\n  * in order to set a new attribute. Be aware that ownership of the account to\r\n  * which the attribute is assigned may still be transferable - restricting\r\n  * assignment to externally-owned accounts may partially alleviate this issue.\r\n  */\r\n  function issueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value\r\n  ) external payable whenNotPaused {\r\n    require(\r\n      canValidate(msg.sender, attributeTypeID),\r\n      \"only approved validators may assign attributes of this type\"\r\n    );\r\n\r\n    require(\r\n      !_issuedAttributes[account][attributeTypeID].exists,\r\n      \"duplicate attributes are not supported, remove existing attribute first\"\r\n    );\r\n\r\n    // retrieve required minimum stake and jurisdiction fees on attribute type\r\n    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\r\n    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\r\n    uint256 stake = msg.value.sub(jurisdictionFee);\r\n\r\n    require(\r\n      stake >= minimumStake,\r\n      \"attribute requires a greater value than is currently provided\"\r\n    );\r\n\r\n    // store attribute value and amount of ether staked in correct scope\r\n    _issuedAttributes[account][attributeTypeID] = IssuedAttribute({\r\n      exists: true,\r\n      setPersonally: false,\r\n      operator: address(0),\r\n      validator: msg.sender,\r\n      value: value,\r\n      stake: stake\r\n    });\r\n\r\n    // log the addition of the attribute\r\n    emit AttributeAdded(msg.sender, account, attributeTypeID, value);\r\n\r\n    // log allocation of staked funds to the attribute if applicable\r\n    if (stake > 0) {\r\n      emit StakeAllocated(msg.sender, attributeTypeID, stake);\r\n    }\r\n\r\n    // pay jurisdiction fee to the owner of the jurisdiction if applicable\r\n    if (jurisdictionFee > 0) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a improperly\r\n      // configured fallback function could block addition of an attribute\r\n      if (owner().send(jurisdictionFee)) {\r\n        emit FeePaid(owner(), msg.sender, attributeTypeID, jurisdictionFee);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\r\n  * `account` if `message.caller.address()` is the issuing validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @dev Validators may still revoke issued attributes even after they have been\r\n  * removed or had their approval to issue the attribute type removed - this\r\n  * enables them to address any objectionable issuances before being reinstated.\r\n  */\r\n  function revokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external whenNotPaused {\r\n    // ensure that an attribute with the given account and attribute exists\r\n    require(\r\n      _issuedAttributes[account][attributeTypeID].exists,\r\n      \"only existing attributes may be removed\"\r\n    );\r\n\r\n    // determine the assigned validator on the user attribute\r\n    address validator = _issuedAttributes[account][attributeTypeID].validator;\r\n    \r\n    // caller must be either the jurisdiction owner or the assigning validator\r\n    require(\r\n      msg.sender == validator || msg.sender == owner(),\r\n      \"only jurisdiction or issuing validators may revoke arbitrary attributes\"\r\n    );\r\n\r\n    // determine if attribute has any stake in order to refund transaction fee\r\n    uint256 stake = _issuedAttributes[account][attributeTypeID].stake;\r\n\r\n    // determine the correct address to refund the staked amount to\r\n    address refundAddress;\r\n    if (_issuedAttributes[account][attributeTypeID].setPersonally) {\r\n      refundAddress = account;\r\n    } else {\r\n      address operator = _issuedAttributes[account][attributeTypeID].operator;\r\n      if (operator == address(0)) {\r\n        refundAddress = validator;\r\n      } else {\r\n        refundAddress = operator;\r\n      }\r\n    }\r\n\r\n    // remove the attribute from the designated user account\r\n    delete _issuedAttributes[account][attributeTypeID];\r\n\r\n    // log the removal of the attribute\r\n    emit AttributeRemoved(validator, account, attributeTypeID);\r\n\r\n    // pay out any refunds and return the excess stake to the user\r\n    if (stake > 0 && address(this).balance >= stake) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a malicious\r\n      // fallback function could forcibly block an attribute's removal. Another\r\n      // option is to allow a user to pull the staked amount after the removal.\r\n      // NOTE: refine transaction rebate gas calculation! Setting this value too\r\n      // high gives validators the incentive to revoke valid attributes. Simply\r\n      // checking against gasLeft() & adding the final gas usage won't give the\r\n      // correct transaction cost, as freeing space refunds gas upon completion.\r\n      uint256 transactionGas = 37700; // <--- WARNING: THIS IS APPROXIMATE\r\n      uint256 transactionCost = transactionGas.mul(tx.gasprice);\r\n\r\n      // if stake exceeds allocated transaction cost, refund user the difference\r\n      if (stake > transactionCost) {\r\n        // refund the excess stake to the address that contributed the funds\r\n        if (refundAddress.send(stake.sub(transactionCost))) {\r\n          emit StakeRefunded(\r\n            refundAddress,\r\n            attributeTypeID,\r\n            stake.sub(transactionCost)\r\n          );\r\n        }\r\n\r\n        // refund the cost of the transaction to the trasaction submitter\r\n        if (tx.origin.send(transactionCost)) {\r\n          emit TransactionRebatePaid(\r\n            tx.origin,\r\n            refundAddress,\r\n            attributeTypeID,\r\n            transactionCost\r\n          );\r\n        }\r\n\r\n      // otherwise, allocate entire stake to partially refunding the transaction\r\n      } else if (stake > 0 && address(this).balance >= stake) {\r\n        if (tx.origin.send(stake)) {\r\n          emit TransactionRebatePaid(\r\n            tx.origin,\r\n            refundAddress,\r\n            attributeTypeID,\r\n            stake\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\r\n  * value of `value`, and an associated validator fee of `validatorFee` to\r\n  * account of `msg.sender` by passing in a signed attribute approval with\r\n  * signature `signature`.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to add.\r\n  * @param value uint256 The value for the attribute to add.\r\n  * @param validatorFee uint256 The fee to be paid to the issuing validator.\r\n  * @param signature bytes The signature from the validator attribute approval.\r\n  */\r\n  function addAttribute(\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external payable {\r\n    // NOTE: determine best course of action when the attribute already exists\r\n    // NOTE: consider utilizing bytes32 type for attributes and values\r\n    // NOTE: does not currently support an extraData parameter, consider adding\r\n    // NOTE: if msg.sender is a proxy contract, its ownership may be transferred\r\n    // at will, circumventing any token transfer restrictions. Restricting usage\r\n    // to only externally owned accounts may partially alleviate this concern.\r\n    // NOTE: cosider including a salt (or better, nonce) parameter so that when\r\n    // a user adds an attribute, then it gets revoked, the user can get a new\r\n    // signature from the validator and renew the attribute using that. The main\r\n    // downside is that everyone will have to keep track of the extra parameter.\r\n    // Another solution is to just modifiy the required stake or fee amount.\r\n\r\n    require(\r\n      !_issuedAttributes[msg.sender][attributeTypeID].exists,\r\n      \"duplicate attributes are not supported, remove existing attribute first\"\r\n    );\r\n\r\n    // retrieve required minimum stake and jurisdiction fees on attribute type\r\n    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\r\n    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\r\n    uint256 stake = msg.value.sub(validatorFee).sub(jurisdictionFee);\r\n\r\n    require(\r\n      stake >= minimumStake,\r\n      \"attribute requires a greater value than is currently provided\"\r\n    );\r\n\r\n    // signed data hash constructed according to EIP-191-0x45 to prevent replays\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        msg.sender,\r\n        address(0),\r\n        msg.value,\r\n        validatorFee,\r\n        attributeTypeID,\r\n        value\r\n      )\r\n    );\r\n\r\n    require(\r\n      !_invalidAttributeApprovalHashes[hash],\r\n      \"signed attribute approvals from validators may not be reused\"\r\n    );\r\n\r\n    // extract the key used to sign the message hash\r\n    address signingKey = hash.toEthSignedMessageHash().recover(signature);\r\n\r\n    // retrieve the validator who controls the extracted key\r\n    address validator = _signingKeys[signingKey];\r\n\r\n    require(\r\n      canValidate(validator, attributeTypeID),\r\n      \"signature does not match an approved validator for given attribute type\"\r\n    );\r\n\r\n    // store attribute value and amount of ether staked in correct scope\r\n    _issuedAttributes[msg.sender][attributeTypeID] = IssuedAttribute({\r\n      exists: true,\r\n      setPersonally: true,\r\n      operator: address(0),\r\n      validator: validator,\r\n      value: value,\r\n      stake: stake\r\n      // NOTE: no extraData included\r\n    });\r\n\r\n    // flag the signed approval as invalid once it's been used to set attribute\r\n    _invalidAttributeApprovalHashes[hash] = true;\r\n\r\n    // log the addition of the attribute\r\n    emit AttributeAdded(validator, msg.sender, attributeTypeID, value);\r\n\r\n    // log allocation of staked funds to the attribute if applicable\r\n    if (stake > 0) {\r\n      emit StakeAllocated(msg.sender, attributeTypeID, stake);\r\n    }\r\n\r\n    // pay jurisdiction fee to the owner of the jurisdiction if applicable\r\n    if (jurisdictionFee > 0) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a improperly\r\n      // configured fallback function could block addition of an attribute\r\n      if (owner().send(jurisdictionFee)) {\r\n        emit FeePaid(owner(), msg.sender, attributeTypeID, jurisdictionFee);\r\n      }\r\n    }\r\n\r\n    // pay validator fee to the issuing validator's address if applicable\r\n    if (validatorFee > 0) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a improperly\r\n      // configured fallback function could block addition of an attribute\r\n      if (validator.send(validatorFee)) {\r\n        emit FeePaid(validator, msg.sender, attributeTypeID, validatorFee);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Remove an attribute of the type with ID `attributeTypeID` from\r\n  * account of `msg.sender`.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to remove.\r\n  */\r\n  function removeAttribute(uint256 attributeTypeID) external {\r\n    // attributes may only be removed by the user if they are not restricted\r\n    require(\r\n      !_attributeTypes[attributeTypeID].restricted,\r\n      \"only jurisdiction or issuing validator may remove a restricted attribute\"\r\n    );\r\n\r\n    require(\r\n      _issuedAttributes[msg.sender][attributeTypeID].exists,\r\n      \"only existing attributes may be removed\"\r\n    );\r\n\r\n    // determine the assigned validator on the user attribute\r\n    address validator = _issuedAttributes[msg.sender][attributeTypeID].validator;\r\n\r\n    // determine if the attribute has a staked value\r\n    uint256 stake = _issuedAttributes[msg.sender][attributeTypeID].stake;\r\n\r\n    // determine the correct address to refund the staked amount to\r\n    address refundAddress;\r\n    if (_issuedAttributes[msg.sender][attributeTypeID].setPersonally) {\r\n      refundAddress = msg.sender;\r\n    } else {\r\n      address operator = _issuedAttributes[msg.sender][attributeTypeID].operator;\r\n      if (operator == address(0)) {\r\n        refundAddress = validator;\r\n      } else {\r\n        refundAddress = operator;\r\n      }\r\n    }    \r\n\r\n    // remove the attribute from the user address\r\n    delete _issuedAttributes[msg.sender][attributeTypeID];\r\n\r\n    // log the removal of the attribute\r\n    emit AttributeRemoved(validator, msg.sender, attributeTypeID);\r\n\r\n    // if the attribute has any staked balance, refund it to the user\r\n    if (stake > 0 && address(this).balance >= stake) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a malicious\r\n      // fallback function could forcibly block an attribute's removal\r\n      if (refundAddress.send(stake)) {\r\n        emit StakeRefunded(refundAddress, attributeTypeID, stake);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Add an attribute of the type with ID `attributeTypeID`, an attribute\r\n  * value of `value`, and an associated validator fee of `validatorFee` to\r\n  * account `account` by passing in a signed attribute approval with signature\r\n  * `signature`.\r\n  * @param account address The account to add the attribute to.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to add.\r\n  * @param value uint256 The value for the attribute to add.\r\n  * @param validatorFee uint256 The fee to be paid to the issuing validator.\r\n  * @param signature bytes The signature from the validator attribute approval.\r\n  * @dev Restricted attribute types can only be removed by issuing validators or\r\n  * the jurisdiction itself.\r\n  */\r\n  function addAttributeFor(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external payable {\r\n    // NOTE: determine best course of action when the attribute already exists\r\n    // NOTE: consider utilizing bytes32 type for attributes and values\r\n    // NOTE: does not currently support an extraData parameter, consider adding\r\n    // NOTE: if msg.sender is a proxy contract, its ownership may be transferred\r\n    // at will, circumventing any token transfer restrictions. Restricting usage\r\n    // to only externally owned accounts may partially alleviate this concern.\r\n    // NOTE: consider including a salt (or better, nonce) parameter so that when\r\n    // a user adds an attribute, then it gets revoked, the user can get a new\r\n    // signature from the validator and renew the attribute using that. The main\r\n    // downside is that everyone will have to keep track of the extra parameter.\r\n    // Another solution is to just modifiy the required stake or fee amount.\r\n\r\n    // attributes may only be added by a third party if onlyPersonal is false\r\n    require(\r\n      !_attributeTypes[attributeTypeID].onlyPersonal,\r\n      \"only operatable attributes may be added on behalf of another address\"\r\n    );\r\n\r\n    require(\r\n      !_issuedAttributes[account][attributeTypeID].exists,\r\n      \"duplicate attributes are not supported, remove existing attribute first\"\r\n    );\r\n\r\n    // retrieve required minimum stake and jurisdiction fees on attribute type\r\n    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\r\n    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\r\n    uint256 stake = msg.value.sub(validatorFee).sub(jurisdictionFee);\r\n\r\n    require(\r\n      stake >= minimumStake,\r\n      \"attribute requires a greater value than is currently provided\"\r\n    );\r\n\r\n    // signed data hash constructed according to EIP-191-0x45 to prevent replays\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        account,\r\n        msg.sender,\r\n        msg.value,\r\n        validatorFee,\r\n        attributeTypeID,\r\n        value\r\n      )\r\n    );\r\n\r\n    require(\r\n      !_invalidAttributeApprovalHashes[hash],\r\n      \"signed attribute approvals from validators may not be reused\"\r\n    );\r\n\r\n    // extract the key used to sign the message hash\r\n    address signingKey = hash.toEthSignedMessageHash().recover(signature);\r\n\r\n    // retrieve the validator who controls the extracted key\r\n    address validator = _signingKeys[signingKey];\r\n\r\n    require(\r\n      canValidate(validator, attributeTypeID),\r\n      \"signature does not match an approved validator for provided attribute\"\r\n    );\r\n\r\n    // store attribute value and amount of ether staked in correct scope\r\n    _issuedAttributes[account][attributeTypeID] = IssuedAttribute({\r\n      exists: true,\r\n      setPersonally: false,\r\n      operator: msg.sender,\r\n      validator: validator,\r\n      value: value,\r\n      stake: stake\r\n      // NOTE: no extraData included\r\n    });\r\n\r\n    // flag the signed approval as invalid once it's been used to set attribute\r\n    _invalidAttributeApprovalHashes[hash] = true;\r\n\r\n    // log the addition of the attribute\r\n    emit AttributeAdded(validator, account, attributeTypeID, value);\r\n\r\n    // log allocation of staked funds to the attribute if applicable\r\n    // NOTE: the staker is the entity that pays the fee here!\r\n    if (stake > 0) {\r\n      emit StakeAllocated(msg.sender, attributeTypeID, stake);\r\n    }\r\n\r\n    // pay jurisdiction fee to the owner of the jurisdiction if applicable\r\n    if (jurisdictionFee > 0) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a improperly\r\n      // configured fallback function could block addition of an attribute\r\n      if (owner().send(jurisdictionFee)) {\r\n        emit FeePaid(owner(), msg.sender, attributeTypeID, jurisdictionFee);\r\n      }\r\n    }\r\n\r\n    // pay validator fee to the issuing validator's address if applicable\r\n    if (validatorFee > 0) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a improperly\r\n      // configured fallback function could block addition of an attribute\r\n      if (validator.send(validatorFee)) {\r\n        emit FeePaid(validator, msg.sender, attributeTypeID, validatorFee);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Remove an attribute of the type with ID `attributeTypeID` from\r\n  * account of `account`.\r\n  * @param account address The account to remove the attribute from.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to remove.\r\n  * @dev Restricted attribute types can only be removed by issuing validators or\r\n  * the jurisdiction itself.\r\n  */\r\n  function removeAttributeFor(address account, uint256 attributeTypeID) external {\r\n    // attributes may only be removed by the user if they are not restricted\r\n    require(\r\n      !_attributeTypes[attributeTypeID].restricted,\r\n      \"only jurisdiction or issuing validator may remove a restricted attribute\"\r\n    );\r\n\r\n    require(\r\n      _issuedAttributes[account][attributeTypeID].exists,\r\n      \"only existing attributes may be removed\"\r\n    );\r\n\r\n    require(\r\n      _issuedAttributes[account][attributeTypeID].operator == msg.sender,\r\n      \"only an assigning operator may remove attribute on behalf of an address\"\r\n    );\r\n\r\n    // determine the assigned validator on the user attribute\r\n    address validator = _issuedAttributes[account][attributeTypeID].validator;\r\n\r\n    // determine if the attribute has a staked value\r\n    uint256 stake = _issuedAttributes[account][attributeTypeID].stake;\r\n\r\n    // remove the attribute from the user address\r\n    delete _issuedAttributes[account][attributeTypeID];\r\n\r\n    // log the removal of the attribute\r\n    emit AttributeRemoved(validator, account, attributeTypeID);\r\n\r\n    // if the attribute has any staked balance, refund it to the user\r\n    if (stake > 0 && address(this).balance >= stake) {\r\n      // NOTE: send is chosen over transfer to prevent cases where a malicious\r\n      // fallback function could forcibly block an attribute's removal\r\n      if (msg.sender.send(stake)) {\r\n        emit StakeRefunded(msg.sender, attributeTypeID, stake);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Invalidate a signed attribute approval before it has been set by\r\n   * supplying the hash of the approval `hash` and the signature `signature`.\r\n   * @param hash bytes32 The hash of the attribute approval.\r\n   * @param signature bytes The hash's signature, resolving to the signing key.\r\n   * @dev Attribute approvals can only be removed by issuing validators or the\r\n   * jurisdiction itself.\r\n   */\r\n  function invalidateAttributeApproval(\r\n    bytes32 hash,\r\n    bytes signature\r\n  ) external {\r\n    // determine the assigned validator on the signed attribute approval\r\n    address validator = _signingKeys[\r\n      hash.toEthSignedMessageHash().recover(signature) // signingKey\r\n    ];\r\n    \r\n    // caller must be either the jurisdiction owner or the assigning validator\r\n    require(\r\n      msg.sender == validator || msg.sender == owner(),\r\n      \"only jurisdiction or issuing validator may invalidate attribute approval\"\r\n    );\r\n\r\n    // add the hash to the set of invalid attribute approval hashes\r\n    _invalidAttributeApprovalHashes[hash] = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Check if an attribute of the type with ID `attributeTypeID` has\r\n   * been assigned to the account at `account` and is currently valid.\r\n   * @param account address The account to check for a valid attribute.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return True if the attribute is assigned and valid, false otherwise.\r\n   * @dev This function MUST return either true or false - i.e. calling this\r\n   * function MUST NOT cause the caller to revert.\r\n   */\r\n  function hasAttribute(\r\n    address account, \r\n    uint256 attributeTypeID\r\n  ) external view returns (bool) {\r\n    address validator = _issuedAttributes[account][attributeTypeID].validator;\r\n    return (\r\n      (\r\n        _validators[validator].exists &&   // isValidator(validator)\r\n        _attributeTypes[attributeTypeID].approvedValidators[validator] &&\r\n        _attributeTypes[attributeTypeID].exists //isAttributeType(attributeTypeID)\r\n      ) || (\r\n        _attributeTypes[attributeTypeID].secondarySource != address(0) &&\r\n        secondaryHasAttribute(\r\n          _attributeTypes[attributeTypeID].secondarySource,\r\n          account,\r\n          _attributeTypes[attributeTypeID].secondaryAttributeTypeID\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieve the value of the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account`, assuming it is valid.\r\n   * @param account address The account to check for the given attribute value.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return The attribute value if the attribute is valid, reverts otherwise.\r\n   * @dev This function MUST revert if a directly preceding or subsequent\r\n   * function call to `hasAttribute` with identical `account` and\r\n   * `attributeTypeID` parameters would return false.\r\n   */\r\n  function getAttributeValue(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (uint256 value) {\r\n    // gas optimization: get validator & call canValidate function body directly\r\n    address validator = _issuedAttributes[account][attributeTypeID].validator;\r\n    if (\r\n      _validators[validator].exists &&   // isValidator(validator)\r\n      _attributeTypes[attributeTypeID].approvedValidators[validator] &&\r\n      _attributeTypes[attributeTypeID].exists //isAttributeType(attributeTypeID)\r\n    ) {\r\n      return _issuedAttributes[account][attributeTypeID].value;\r\n    } else if (\r\n      _attributeTypes[attributeTypeID].secondarySource != address(0)\r\n    ) {\r\n      // first ensure hasAttribute on the secondary source returns true\r\n      require(\r\n        AttributeRegistryInterface(\r\n          _attributeTypes[attributeTypeID].secondarySource\r\n        ).hasAttribute(\r\n          account, _attributeTypes[attributeTypeID].secondaryAttributeTypeID\r\n        ),\r\n        \"attribute of the provided type is not assigned to the provided account\"\r\n      );\r\n\r\n      return (\r\n        AttributeRegistryInterface(\r\n          _attributeTypes[attributeTypeID].secondarySource\r\n        ).getAttributeValue(\r\n          account, _attributeTypes[attributeTypeID].secondaryAttributeTypeID\r\n        )\r\n      );\r\n    }\r\n\r\n    // NOTE: checking for values of invalid attributes will revert\r\n    revert(\"could not find an attribute value at the provided account and ID\");\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if a validator at account `validator` is able to issue\r\n   * attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canIssueAttributeType(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool) {\r\n    return canValidate(validator, attributeTypeID);\r\n  }\r\n\r\n  /**\r\n   * @notice Get a description of the attribute type with ID `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return A description of the attribute type.\r\n   */\r\n  function getAttributeTypeDescription(\r\n    uint256 attributeTypeID\r\n  ) external view returns (\r\n    string description\r\n  ) {\r\n    return _attributeTypes[attributeTypeID].description;\r\n  }\r\n\r\n  /**\r\n   * @notice Get comprehensive information on an attribute type with ID\r\n   * `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The attribute type ID in question.\r\n   * @return Information on the attribute type in question.\r\n   */\r\n  function getAttributeTypeInformation(\r\n    uint256 attributeTypeID\r\n  ) external view returns (\r\n    string description,\r\n    bool isRestricted,\r\n    bool isOnlyPersonal,\r\n    address secondarySource,\r\n    uint256 secondaryAttributeTypeID,\r\n    uint256 minimumRequiredStake,\r\n    uint256 jurisdictionFee\r\n  ) {\r\n    return (\r\n      _attributeTypes[attributeTypeID].description,\r\n      _attributeTypes[attributeTypeID].restricted,\r\n      _attributeTypes[attributeTypeID].onlyPersonal,\r\n      _attributeTypes[attributeTypeID].secondarySource,\r\n      _attributeTypes[attributeTypeID].secondaryAttributeTypeID,\r\n      _attributeTypes[attributeTypeID].minimumStake,\r\n      _attributeTypes[attributeTypeID].jurisdictionFee\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Get a description of the validator at account `validator`.\r\n   * @param validator address The account of the validator in question.\r\n   * @return A description of the validator.\r\n   */\r\n  function getValidatorDescription(\r\n    address validator\r\n  ) external view returns (\r\n    string description\r\n  ) {\r\n    return _validators[validator].description;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the signing key of the validator at account `validator`.\r\n   * @param validator address The account of the validator in question.\r\n   * @return The signing key of the validator.\r\n   */\r\n  function getValidatorSigningKey(\r\n    address validator\r\n  ) external view returns (\r\n    address signingKey\r\n  ) {\r\n    return _validators[validator].signingKey;\r\n  }\r\n\r\n  /**\r\n   * @notice Find the validator that issued the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account` and determine if the\r\n   * validator is still valid.\r\n   * @param account address The account that contains the attribute be checked.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return The validator and the current status of the validator as it\r\n   * pertains to the attribute type in question.\r\n   * @dev if no attribute of the given attribute type exists on the account, the\r\n   * function will return (address(0), false).\r\n   */\r\n  function getAttributeValidator(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (\r\n    address validator,\r\n    bool isStillValid\r\n  ) {\r\n    address issuer = _issuedAttributes[account][attributeTypeID].validator;\r\n    return (issuer, canValidate(issuer, attributeTypeID));\r\n  }\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the registry.\r\n   * @return The number of available attribute types.\r\n   * @dev This function MUST return a positive integer value  - i.e. calling\r\n   * this function MUST NOT cause the caller to revert.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256) {\r\n    return _attributeIDs.length;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   * @dev This function MUST revert if the provided `index` value falls outside\r\n   * of the range of the value returned from a directly preceding or subsequent\r\n   * function call to `countAttributeTypes`. It MUST NOT revert if the provided\r\n   * `index` value falls inside said range.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256) {\r\n    require(\r\n      index < _attributeIDs.length,\r\n      \"provided index is outside of the range of defined attribute type IDs\"\r\n    );\r\n\r\n    return _attributeIDs[index];\r\n  }\r\n\r\n  /**\r\n   * @notice Get the IDs of all available attribute types on the jurisdiction.\r\n   * @return A dynamic array containing all available attribute type IDs.\r\n   */\r\n  function getAttributeTypeIDs() external view returns (uint256[]) {\r\n    return _attributeIDs;\r\n  }\r\n\r\n  /**\r\n   * @notice Count the number of validators defined by the jurisdiction.\r\n   * @return The number of defined validators.\r\n   */\r\n  function countValidators() external view returns (uint256) {\r\n    return _validatorAccounts.length;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the account of the validator at index `index`.\r\n   * @param index uint256 The index of the validator in question.\r\n   * @return The account of the validator.\r\n   */\r\n  function getValidator(\r\n    uint256 index\r\n  ) external view returns (address) {\r\n    return _validatorAccounts[index];\r\n  }\r\n\r\n  /**\r\n   * @notice Get the accounts of all available validators on the jurisdiction.\r\n   * @return A dynamic array containing all available validator accounts.\r\n   */\r\n  function getValidators() external view returns (address[]) {\r\n    return _validatorAccounts;\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if the interface ID `interfaceID` is supported (ERC-165)\r\n   * @param interfaceID bytes4 The interface ID in question.\r\n   * @return True if the interface is supported, false otherwise.\r\n   * @dev this function will produce a compiler warning recommending that the\r\n   * visibility be set to pure, but the interface expects a view function.\r\n   * Supported interfaces include ERC-165 (0x01ffc9a7) and the attribute\r\n   * registry interface (0x5f46473f).\r\n   */\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n    return (\r\n      interfaceID == this.supportsInterface.selector || // ERC165\r\n      interfaceID == (\r\n        this.hasAttribute.selector \r\n        ^ this.getAttributeValue.selector\r\n        ^ this.countAttributeTypes.selector\r\n        ^ this.getAttributeTypeID.selector\r\n      ) // AttributeRegistryInterface\r\n    ); // 0x01ffc9a7 || 0x5f46473f\r\n  }\r\n\r\n  /**\r\n   * @notice Get the hash of a given attribute approval.\r\n   * @param account address The account specified by the attribute approval.\r\n   * @param operator address An optional account permitted to submit approval.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @param value uint256 The value of the attribute in the approval.\r\n   * @param fundsRequired uint256 The amount to be included with the approval.\r\n   * @param validatorFee uint256 The required fee to be paid to the validator.\r\n   * @return The hash of the attribute approval.\r\n   */\r\n  function getAttributeApprovalHash(\r\n    address account,\r\n    address operator,\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 fundsRequired,\r\n    uint256 validatorFee\r\n  ) external view returns (\r\n    bytes32 hash\r\n  ) {\r\n    return calculateAttributeApprovalHash(\r\n      account,\r\n      operator,\r\n      attributeTypeID,\r\n      value,\r\n      fundsRequired,\r\n      validatorFee\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Check if a given signed attribute approval is currently valid when\r\n   * submitted directly by `msg.sender`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @param value uint256 The value of the attribute in the approval.\r\n   * @param fundsRequired uint256 The amount to be included with the approval.\r\n   * @param validatorFee uint256 The required fee to be paid to the validator.\r\n   * @param signature bytes The attribute approval signature, based on a hash of\r\n   * the other parameters and the submitting account.\r\n   * @return True if the approval is currently valid, false otherwise.\r\n   */\r\n  function canAddAttribute(\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 fundsRequired,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external view returns (bool) {\r\n    // signed data hash constructed according to EIP-191-0x45 to prevent replays\r\n    bytes32 hash = calculateAttributeApprovalHash(\r\n      msg.sender,\r\n      address(0),\r\n      attributeTypeID,\r\n      value,\r\n      fundsRequired,\r\n      validatorFee\r\n    );\r\n\r\n    // recover the address associated with the signature of the message hash\r\n    address signingKey = hash.toEthSignedMessageHash().recover(signature);\r\n    \r\n    // retrieve variables necessary to perform checks\r\n    address validator = _signingKeys[signingKey];\r\n    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\r\n    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\r\n\r\n    // determine if the attribute can currently be added.\r\n    // NOTE: consider returning an error code along with the boolean.\r\n    return (\r\n      fundsRequired >= minimumStake.add(jurisdictionFee).add(validatorFee) &&\r\n      !_invalidAttributeApprovalHashes[hash] &&\r\n      canValidate(validator, attributeTypeID) &&\r\n      !_issuedAttributes[msg.sender][attributeTypeID].exists\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Check if a given signed attribute approval is currently valid for a\r\n   * given account when submitted by the operator at `msg.sender`.\r\n   * @param account address The account specified by the attribute approval.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @param value uint256 The value of the attribute in the approval.\r\n   * @param fundsRequired uint256 The amount to be included with the approval.\r\n   * @param validatorFee uint256 The required fee to be paid to the validator.\r\n   * @param signature bytes The attribute approval signature, based on a hash of\r\n   * the other parameters and the submitting account.\r\n   * @return True if the approval is currently valid, false otherwise.\r\n   */\r\n  function canAddAttributeFor(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 fundsRequired,\r\n    uint256 validatorFee,\r\n    bytes signature\r\n  ) external view returns (bool) {\r\n    // signed data hash constructed according to EIP-191-0x45 to prevent replays\r\n    bytes32 hash = calculateAttributeApprovalHash(\r\n      account,\r\n      msg.sender,\r\n      attributeTypeID,\r\n      value,\r\n      fundsRequired,\r\n      validatorFee\r\n    );\r\n\r\n    // recover the address associated with the signature of the message hash\r\n    address signingKey = hash.toEthSignedMessageHash().recover(signature);\r\n    \r\n    // retrieve variables necessary to perform checks\r\n    address validator = _signingKeys[signingKey];\r\n    uint256 minimumStake = _attributeTypes[attributeTypeID].minimumStake;\r\n    uint256 jurisdictionFee = _attributeTypes[attributeTypeID].jurisdictionFee;\r\n\r\n    // determine if the attribute can currently be added.\r\n    // NOTE: consider returning an error code along with the boolean.\r\n    return (\r\n      fundsRequired >= minimumStake.add(jurisdictionFee).add(validatorFee) &&\r\n      !_invalidAttributeApprovalHashes[hash] &&\r\n      canValidate(validator, attributeTypeID) &&\r\n      !_issuedAttributes[account][attributeTypeID].exists\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if an attribute type with ID `attributeTypeID` is\r\n   * currently defined on the jurisdiction.\r\n   * @param attributeTypeID uint256 The attribute type ID in question.\r\n   * @return True if the attribute type is defined, false otherwise.\r\n   */\r\n  function isAttributeType(uint256 attributeTypeID) public view returns (bool) {\r\n    return _attributeTypes[attributeTypeID].exists;\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if the account `account` is currently assigned as a\r\n   * validator on the jurisdiction.\r\n   * @param account address The account to check for validator status.\r\n   * @return True if the account is assigned as a validator, false otherwise.\r\n   */\r\n  function isValidator(address account) public view returns (bool) {\r\n    return _validators[account].exists;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to determine if a validator at account\r\n   * `validator` can issue attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canValidate(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) internal view returns (bool) {\r\n    return (\r\n      _validators[validator].exists &&   // isValidator(validator)\r\n      _attributeTypes[attributeTypeID].approvedValidators[validator] &&\r\n      _attributeTypes[attributeTypeID].exists // isAttributeType(attributeTypeID)\r\n    );\r\n  }\r\n\r\n  // internal helper function for getting the hash of an attribute approval\r\n  function calculateAttributeApprovalHash(\r\n    address account,\r\n    address operator,\r\n    uint256 attributeTypeID,\r\n    uint256 value,\r\n    uint256 fundsRequired,\r\n    uint256 validatorFee\r\n  ) internal view returns (bytes32 hash) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        account,\r\n        operator,\r\n        fundsRequired,\r\n        validatorFee,\r\n        attributeTypeID,\r\n        value\r\n      )\r\n    );\r\n  }\r\n\r\n  // helper function, won't revert calling hasAttribute on secondary registries\r\n  function secondaryHasAttribute(\r\n    address source,\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) internal view returns (bool result) {\r\n    uint256 maxGas = gasleft() > 20000 ? 20000 : gasleft();\r\n    bytes memory encodedParams = abi.encodeWithSelector(\r\n      this.hasAttribute.selector,\r\n      account,\r\n      attributeTypeID\r\n    );\r\n\r\n    assembly {\r\n      let encodedParams_data := add(0x20, encodedParams)\r\n      let encodedParams_size := mload(encodedParams)\r\n      \r\n      let output := mload(0x40) // get storage start from free memory pointer\r\n      mstore(output, 0x0)       // set up the location for output of staticcall\r\n\r\n      let success := staticcall(\r\n        maxGas,                 // maximum of 20k gas can be forwarded\r\n        source,                 // address of attribute registry to call\r\n        encodedParams_data,     // inputs are stored at pointer location\r\n        encodedParams_size,     // inputs are 68 bytes (4 + 32 * 2)\r\n        output,                 // return to designated free space\r\n        0x20                    // output is one word, or 32 bytes\r\n      )\r\n\r\n      switch success            // instrumentation bug: use switch instead of if\r\n      case 1 {                  // only recognize successful staticcall output \r\n        result := mload(output) // set the output to the return value\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAttributeTypeID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"invalidateAttributeApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"},{\"name\":\"onlyPersonal\",\"type\":\"bool\"}],\"name\":\"setAttributeTypeOnlyPersonal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"getAttributeValidator\",\"outputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"isStillValid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"removeAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSigningKey\",\"type\":\"address\"}],\"name\":\"setValidatorSigningKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"isAttributeType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"removeValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"hasAttribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"issueAttribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"validatorFee\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"addAttribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"addValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"getAttributeTypeInformation\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"isRestricted\",\"type\":\"bool\"},{\"name\":\"isOnlyPersonal\",\"type\":\"bool\"},{\"name\":\"secondarySource\",\"type\":\"address\"},{\"name\":\"secondaryAttributeTypeID\",\"type\":\"uint256\"},{\"name\":\"minimumRequiredStake\",\"type\":\"uint256\"},{\"name\":\"jurisdictionFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"addValidatorApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"}],\"name\":\"removeAttributeType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"validatorFee\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"addAttributeFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getValidatorSigningKey\",\"outputs\":[{\"name\":\"signingKey\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fundsRequired\",\"type\":\"uint256\"},{\"name\":\"validatorFee\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"canAddAttribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAttributeTypeIDs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getValidatorDescription\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"addAttributeType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setAttributeTypeJurisdictionFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fundsRequired\",\"type\":\"uint256\"},{\"name\":\"validatorFee\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"canAddAttributeFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"removeValidatorApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"getAttributeValue\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countAttributeTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fundsRequired\",\"type\":\"uint256\"},{\"name\":\"validatorFee\",\"type\":\"uint256\"}],\"name\":\"getAttributeApprovalHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"},{\"name\":\"minimumRequiredStake\",\"type\":\"uint256\"}],\"name\":\"setAttributeTypeMinimumRequiredStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"},{\"name\":\"attributeRegistry\",\"type\":\"address\"},{\"name\":\"sourceAttributeTypeID\",\"type\":\"uint256\"}],\"name\":\"setAttributeTypeSecondarySource\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"addRestrictedAttributeType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"canIssueAttributeType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"revokeAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"removeAttributeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"getAttributeTypeDescription\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newSigningKey\",\"type\":\"address\"}],\"name\":\"ValidatorSigningKeyModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attribute\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attribute\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attribute\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attribute\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransactionRebatePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"AttributeTypeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"AttributeTypeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ValidatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"ValidatorApprovalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"ValidatorApprovalRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"attributeValue\",\"type\":\"uint256\"}],\"name\":\"AttributeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"AttributeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ExtendedJurisdiction","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b901c27f1bdd773ddb906550fcbaa18e73b810024d9a2c1e18a344ff493050e4"}]}