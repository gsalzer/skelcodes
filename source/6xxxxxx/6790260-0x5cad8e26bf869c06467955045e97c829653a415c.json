{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n//////////////CONTRACT//////////////\r\n\r\n\r\n\r\n\r\ncontract Marketplace is Upgradable {\r\n    using SafeMath256 for uint256;\r\n\r\n    struct Auction {\r\n        address seller;\r\n        uint256 startPrice;\r\n        uint256 endPrice;\r\n        uint16 period; // in hours\r\n        uint256 created;\r\n        bool isGold; // gold or ether\r\n    }\r\n\r\n    uint256 constant MULTIPLIER = 1000000; // for more accurate calculations\r\n    uint16 constant MAX_PERIOD = 8760; // 8760 hours = 1 year\r\n\r\n    uint8 constant FLAT_TYPE = 0;\r\n    uint8 constant INCREASING_TYPE = 1;\r\n    uint8 constant DUTCH_TYPE = 2;\r\n\r\n    mapping (address => uint256[]) internal ownedTokens;\r\n    mapping (uint256 => uint256) internal ownedTokensIndex;\r\n    mapping (uint256 => uint256) allTokensIndex;\r\n    mapping (uint256 => Auction) tokenToAuction;\r\n\r\n    uint256[] allTokens;\r\n\r\n    constructor() public {}\r\n\r\n    function sellToken(\r\n        uint256 _tokenId,\r\n        address _seller,\r\n        uint256 _startPrice,\r\n        uint256 _endPrice,\r\n        uint16 _period,\r\n        bool _isGold\r\n    ) external onlyController {\r\n        Auction memory _auction;\r\n\r\n        require(_startPrice > 0 && _endPrice > 0, \"price must be more than 0\");\r\n        if (_startPrice != _endPrice) {\r\n            require(_period > 0 && _period <= MAX_PERIOD, \"wrong period value\");\r\n        }\r\n        _auction = Auction(_seller, _startPrice, _endPrice, _period, now, _isGold);\r\n\r\n        // if auction doesn't exist\r\n        if (tokenToAuction[_tokenId].seller == address(0)) {\r\n            uint256 length = ownedTokens[_seller].length;\r\n            ownedTokens[_seller].push(_tokenId);\r\n            ownedTokensIndex[_tokenId] = length;\r\n\r\n            allTokensIndex[_tokenId] = allTokens.length;\r\n            allTokens.push(_tokenId);\r\n        }\r\n        tokenToAuction[_tokenId] = _auction;\r\n    }\r\n\r\n    function removeFromAuction(uint256 _tokenId) external onlyController {\r\n        address _seller = tokenToAuction[_tokenId].seller;\r\n        require(_seller != address(0), \"token is not on sale\");\r\n        _remove(_seller, _tokenId);\r\n    }\r\n\r\n    function buyToken(\r\n        uint256 _tokenId,\r\n        uint256 _value,\r\n        uint256 _expectedPrice,\r\n        bool _expectedIsGold\r\n    ) external onlyController returns (uint256 price) {\r\n        Auction memory _auction = tokenToAuction[_tokenId];\r\n\r\n        require(_auction.seller != address(0), \"invalid address\");\r\n        require(_auction.isGold == _expectedIsGold, \"wrong currency\");\r\n        price = _getCurrentPrice(_tokenId);\r\n        require(price <= _expectedPrice, \"wrong price\");\r\n        require(price <= _value, \"not enough ether/gold\");\r\n\r\n        _remove(_auction.seller, _tokenId);\r\n    }\r\n\r\n    function _remove(address _from, uint256 _tokenId) internal {\r\n        require(allTokens.length > 0, \"no auctions\");\r\n\r\n        delete tokenToAuction[_tokenId];\r\n\r\n        _removeFrom(_from, _tokenId);\r\n\r\n        uint256 tokenIndex = allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[tokenIndex] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length--;\r\n        allTokensIndex[_tokenId] = 0;\r\n        allTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    function _removeFrom(address _from, uint256 _tokenId) internal {\r\n        require(ownedTokens[_from].length > 0, \"no seller auctions\");\r\n\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        ownedTokens[_from][lastTokenIndex] = 0;\r\n\r\n        ownedTokens[_from].length--;\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    function _getCurrentPrice(uint256 _id) internal view returns (uint256) {\r\n        Auction memory _auction = tokenToAuction[_id];\r\n        if (_auction.startPrice == _auction.endPrice) {\r\n            return _auction.startPrice;\r\n        }\r\n        return _calculateCurrentPrice(\r\n            _auction.startPrice,\r\n            _auction.endPrice,\r\n            _auction.period,\r\n            _auction.created\r\n        );\r\n    }\r\n\r\n    function _calculateCurrentPrice(\r\n        uint256 _startPrice,\r\n        uint256 _endPrice,\r\n        uint16 _period,\r\n        uint256 _created\r\n    ) internal view returns (uint256) {\r\n        bool isIncreasingType = _startPrice < _endPrice;\r\n        uint256 _fullPeriod = uint256(1 hours).mul(_period); // price changing period\r\n        uint256 _interval = isIncreasingType ? _endPrice.sub(_startPrice) : _startPrice.sub(_endPrice);\r\n        uint256 _pastTime = now.sub(_created);\r\n        if (_pastTime >= _fullPeriod) return _endPrice;\r\n        // how much is _pastTime in percents to period\r\n        uint256 _percent = MULTIPLIER.sub(_fullPeriod.sub(_pastTime).mul(MULTIPLIER).div(_fullPeriod));\r\n        uint256 _diff = _interval.mul(_percent).div(MULTIPLIER);\r\n        return isIncreasingType ? _startPrice.add(_diff) : _startPrice.sub(_diff);\r\n    }\r\n\r\n    // GETTERS\r\n\r\n    function sellerOf(uint256 _id) external view returns (address) {\r\n        return tokenToAuction[_id].seller;\r\n    }\r\n\r\n    function getAuction(uint256 _id) external view returns (\r\n        address, uint256, uint256, uint256, uint16, uint256, bool\r\n    ) {\r\n        Auction memory _auction = tokenToAuction[_id];\r\n        return (\r\n            _auction.seller,\r\n            _getCurrentPrice(_id),\r\n            _auction.startPrice,\r\n            _auction.endPrice,\r\n            _auction.period,\r\n            _auction.created,\r\n            _auction.isGold\r\n        );\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns (uint256[]) {\r\n        return ownedTokens[_owner];\r\n    }\r\n\r\n    function getAllTokens() external view returns (uint256[]) {\r\n        return allTokens;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n}\r\n\r\n\r\ncontract DragonMarketplace is Marketplace {}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_expectedPrice\",\"type\":\"uint256\"},{\"name\":\"_expectedIsGold\",\"type\":\"bool\"}],\"name\":\"buyToken\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_endPrice\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint16\"},{\"name\":\"_isGold\",\"type\":\"bool\"}],\"name\":\"sellToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"removeFromAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"sellerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonMarketplace","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e83793bd7957a3b8eea47c7044db8192612a66902e584dfd602871b07c6b4c01"}]}