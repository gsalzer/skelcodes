{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\ncontract Prosperity {\r\n\t\r\n\t/**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * Remember, there's 0% fee here.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) public returns(bool);\r\n\t\r\n\t/**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n\tfunction myTokens() public view returns(uint256);\r\n\t\r\n\t/**\r\n     * Retrieve the dividends owned by the caller.\r\n     * If `_includeReferralBonus` is 1/true, the referral bonus will be included in the calculations.\r\n     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\r\n     * But in the internal calculations, we want them separate. \r\n     */ \r\n    function myDividends(bool _includeReferralBonus) public view returns(uint256);\r\n\t\r\n\t/**\r\n     * Converts all incoming ethereum to tokens for the caller, and passes down the referral\r\n     */\r\n    function buy(address _referredBy) public payable returns(uint256);\r\n\t\r\n\t/**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw() public;\r\n\t\r\n\t/**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n\tfunction reinvest() public;\r\n\t\r\n\t/**\r\n     * Fallback function to handle ethereum that was send straight to the contract\r\n     * Unfortunately we cannot use a referral address this way.\r\n     */\r\n\tfunction() payable external;\r\n}\r\n\r\n\r\n/**\r\n * Accepts THC tokens: Lending\r\n */\r\ncontract Lending {\r\n\tusing SafeMath for *;\r\n\t\r\n\t/*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    // ERC20\r\n    event Transfer (\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\t\r\n\tevent onDeposit (\r\n\t\taddress indexed customer,\r\n\t\tuint256 tokens\r\n\t);\r\n\t\r\n\tevent onReinvestProfit (\r\n\t\taddress indexed customer,\r\n\t\tuint256 tokens\r\n\t);\r\n\t\r\n\tevent onWithdrawProfit (\r\n\t\taddress indexed customer,\r\n\t\tuint256 tokens\r\n\t);\r\n\t\r\n\tevent onWithdrawCapital (\r\n\t\taddress indexed customer,\r\n\t\tuint256 tokens\r\n\t);\r\n\t\r\n\t\r\n\t/*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\t\r\n\tmodifier onlyTokenContract {\r\n        require(msg.sender == address(tokenContract_));\r\n        _;\r\n    }\r\n\t\r\n\t// only people with deposit\r\n    modifier onlyBagholders() {\r\n        require(myDeposit() > 0);\r\n        _;\r\n    }\r\n    \r\n    // only people with profits\r\n    modifier onlyStronghands() {\r\n        require(myProfit(msg.sender) > 0);\r\n        _;\r\n    }\r\n\t\r\n\t// administrators can:\r\n    // -> set token contract\r\n    // they CANNOT:\r\n    // -> take funds\r\n    // -> disable withdrawals\r\n    // -> kill the contract\r\n    // -> change the price of tokens\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrator_ == _customerAddress);\r\n        _;\r\n    }\r\n\t\r\n\t\r\n\t/*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => Dealer) internal dealers_; \t// address => Dealer\r\n    uint256 internal totalDeposit_ = 0;\r\n\t\r\n\t// token exchange contract\r\n\tProsperity public tokenContract_;\r\n\t\r\n\t// administrator (see above on what they can do)\r\n    address internal administrator_;\r\n\t\r\n\t// Player data\r\n\tstruct Dealer {\r\n\t\tuint256 deposit;\t\t// active deposit\r\n\t\tuint256 profit;\t\t\t// old outstanding profits\r\n\t\tuint256 time;\t\t\t// last time profits have been moved\r\n\t}\r\n    \r\n\t\r\n\t/*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    constructor() public {\r\n\t\tadministrator_ = 0x28436C7453EbA01c6EcbC8a9cAa975f0ADE6Fff1;\r\n    }\r\n\t\r\n\tfunction() payable external {\r\n\t\t// prevent invalid or unintentional calls\r\n\t\t//require(msg.data.length == 0);\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev Standard ERC677 function that will handle incoming token transfers.\r\n    *\r\n    * @param _from  Token sender address.\r\n    * @param _value Amount of tokens.\r\n    * @param _data  Transaction metadata.\r\n    */\r\n    function tokenFallback(address _from, uint256 _value, bytes _data)\r\n\t\tonlyTokenContract()\r\n\t\texternal\r\n\t\treturns (bool)\r\n\t{\r\n        // data setup\r\n\t\tDealer storage _dealer = dealers_[_from];\r\n\t\t\r\n\t\t// profit and deposit tracking\r\n\t\t_dealer.profit = myProfit(_from);\t/* saves the new generated profit; old profit will be taken into account within the calculation\r\n\t\t\t\t\t\t\t\t\t\t\t   last time deposit timer is 0 for the first deposit */\r\n\t\t_dealer.time = now;\t\t\t\t\t// so we set the timer AFTER calculating profits\r\n        \r\n\t\t// allocate tokens\r\n\t\t_dealer.deposit = _dealer.deposit.add(_value);\r\n\t\ttotalDeposit_ = totalDeposit_.add(_value);\r\n\t\t\r\n\t\t// trigger event\r\n\t\temit onDeposit(_from, _value);\r\n\t\t\r\n\t\treturn true;\r\n\t\t\r\n\t\t// silence compiler warning\r\n\t\t_data;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Reinvest generated profit\r\n\t */\r\n\tfunction reinvestProfit()\r\n\t\tonlyStronghands()\r\n\t\tpublic \r\n\t{\r\n\t\taddress _customerAddress = msg.sender;\r\n\t\tDealer storage _dealer = dealers_[_customerAddress];\r\n\t\t\r\n\t\tuint256 _profits = myProfit(_customerAddress);\r\n\t\t\r\n\t\t// update Dealer\r\n\t\t_dealer.deposit = _dealer.deposit.add(_profits);\t// add new tokens to active deposit\r\n\t\t_dealer.profit = 0;\t\t\t\t\t\t\t\t\t// old tokens have been reinvested\r\n\t\t_dealer.time = now;\t\t\t\t\t\t\t\t\t// generate tokens from now\r\n\t\t\r\n\t\t// update total deposit value\r\n\t\ttotalDeposit_ = totalDeposit_.add(_profits);\r\n\t\t\r\n\t\t// trigger event\r\n\t\temit onReinvestProfit(_customerAddress, _profits);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Withdraw profit to token exchange\r\n\t */\r\n\tfunction withdrawProfit()\r\n\t\tonlyStronghands()\r\n\t\tpublic\r\n\t{\r\n\t\taddress _customerAddress = msg.sender;\r\n\t\tDealer storage _dealer = dealers_[_customerAddress];\r\n\t\t\r\n\t\tuint256 _profits = myProfit(_customerAddress);\r\n\t\t\r\n\t\t// update profits\r\n\t\t_dealer.profit = 0;\t\t// old tokens have been reinvested\r\n\t\t_dealer.time = now;\t\t// generate tokens from now\r\n\t\t\r\n\t\t// transfer tokens from exchange to sender\r\n\t\ttokenContract_.transfer(_customerAddress, _profits);\r\n\t\t\r\n\t\t// trigger event\r\n\t\temit onWithdrawProfit(_customerAddress, _profits);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Withdraw deposit to token exchange. 25% fee will be incured\r\n\t */\r\n\tfunction withdrawCapital()\r\n\t\tonlyBagholders()\r\n\t\tpublic\r\n\t{\r\n\t\taddress _customerAddress = msg.sender;\r\n\t\tDealer storage _dealer = dealers_[_customerAddress];\r\n\t\t\r\n\t\tuint256 _deposit = _dealer.deposit;\r\n\t\tuint256 _taxedDeposit = _deposit.mul(75).div(100);\r\n\t\tuint256 _profits = myProfit(_customerAddress);\r\n\t\t\r\n\t\t// update deposit\r\n\t\t_dealer.deposit = 0;\r\n\t\t_dealer.profit = _profits;\r\n\t\t\r\n\t\t// reduce tokens in lending deposit ledger\r\n\t\t// use the untaxed value, bcs Dealers deposit will drop to 0,\r\n\t\t// but token transfer (below) will be taxed\r\n\t\ttotalDeposit_ = totalDeposit_.sub(_deposit);\r\n\t\t\r\n\t\t// transfer tokens from exchange to sender\r\n\t\ttokenContract_.transfer(_customerAddress, _taxedDeposit);\r\n\t\t\r\n\t\t// trigger event\r\n\t\temit onWithdrawCapital(_customerAddress, _taxedDeposit);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Lending will reinvest its ETH\r\n\t */\r\n\tfunction reinvestEther()\r\n\t\tpublic\r\n\t{\r\n\t\tuint256 _balance = address(this).balance;\r\n\t\tif (_balance > 0) {\r\n\t\t\t// triggers exchanges payable fallback buy function\r\n\t\t\tif(!address(tokenContract_).call.value(_balance)()) {\r\n\t\t\t\t// Some failure code\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Lending will reinvest its dividends\r\n\t */\r\n\tfunction reinvestDividends()\r\n\t\tpublic\r\n\t{\r\n\t\tuint256 _dividends = myDividends(true);\r\n\t\tif (_dividends > 0) {\r\n\t\t\ttokenContract_.reinvest();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/*----------  HELPERS AND CALCULATORS  ----------*/\t\r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalDeposit()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalDeposit_;\r\n    }\r\n\t\r\n\t/**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenContract_.myTokens();\r\n    }\r\n\t\r\n\tfunction surplus()\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns(int256)\r\n\t{\r\n\t\tuint256 _tokens = totalSupply();\r\n\t\t\r\n\t\t// we cannot divide by 0\r\n\t\tif (totalDeposit_ > 0) {\r\n\t\t\t// returns a value that indicates the surplus of the lending contract\r\n\t\t\t// based on 1000 => 1000 = 100%; 303 = 30.3%; -200 = -20%\r\n\t\t\treturn int256((1000).mul(_tokens).div(totalDeposit_) - 1000);\r\n\t\t} else {\r\n\t\t\treturn 1000;\t// 100%\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myDeposit()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n\t\taddress _customerAddress = msg.sender;\r\n        Dealer storage _dealer = dealers_[_customerAddress];\r\n        return _dealer.deposit;\r\n    }\r\n\t\r\n\t/**\r\n     * Retrieve the profit of the caller. Profits are virtual\r\n     */\r\n\tfunction myProfit(address _customerAddress)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns(uint256)\r\n\t{\r\n\t\tDealer storage _dealer = dealers_[_customerAddress];\r\n\t\tuint256 _oldProfits = _dealer.profit;\r\n\t\tuint256 _newProfits = 0;\r\n\t\t\r\n\t\tif (\r\n\t\t\t// if time is 0, the dealer has not deposited tokens yet\r\n\t\t\t_dealer.time == 0 ||\r\n\t\t\t\r\n\t\t\t// dealer has currently no tokens deposited\r\n\t\t\t_dealer.deposit == 0\r\n\t\t)\r\n\t\t{\r\n\t\t\t_newProfits = 0;\r\n\t\t} else {\r\n\t\t\t// get the last deposit time stamp\r\n\t\t\tuint256 _timeLending = now - _dealer.time;\r\n\t\t\t\r\n\t\t\t_newProfits = _timeLending\t// time difference since profits are being generated\r\n\t\t\t\t.mul(_dealer.deposit)\t// current deposit\r\n\t\t\t\t.mul(1337)\t\t\t\t// 1.337% (daily)\r\n\t\t\t\t.div(100000)\t\t\t// to base 100%\r\n\t\t\t\t.div(86400);\t\t\t// 1 day in seconds\r\n\t\t}\r\n\t\t\r\n\t\t// Dealer may have tokens in profit wallet left, so always add the old value\r\n\t\treturn _newProfits.add(_oldProfits);\r\n\t}\r\n\t\r\n\tfunction myDividends(bool _includeReferralBonus)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns(uint256)\r\n\t{\r\n\t\treturn tokenContract_.myDividends(_includeReferralBonus);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Set the token contract\r\n\t */\r\n\tfunction setTokenContract(address _tokenContract)\r\n\t\tonlyAdministrator()\r\n\t\tpublic\r\n\t{\r\n\t\ttokenContract_ = Prosperity(_tokenContract);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"myProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"surplus\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawCapital\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvestDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvestProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvestEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onReinvestProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onWithdrawProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onWithdrawCapital\",\"type\":\"event\"}]","ContractName":"Lending","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://676382fd9942aa69f933c04f9e39b73c630bb7513ffcca2781acc0a33b8241f3"}]}