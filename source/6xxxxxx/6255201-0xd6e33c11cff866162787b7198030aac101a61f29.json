{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\ninterface RTCoinInterface {\r\n    \r\n\r\n    /** Functions - ERC20 */\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function transferFrom(address _owner, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool approved);\r\n\r\n    /** Getters - ERC20 */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    /** Getters - Custom */\r\n    function mint(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function stakeContractAddress() external view returns (address);\r\n\r\n    function mergedMinerValidatorAddress() external view returns (address);\r\n    \r\n    /** Functions - Custom */\r\n    function freezeTransfers() external returns (bool);\r\n\r\n    function thawTransfers() external returns (bool);\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ninterface ERC20Interface {\r\n    function owner() external view returns (address);\r\n    function decimals() external view returns (uint8);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  // We use `pure` bbecause it promises that the value for the function depends ONLY\r\n  // on the function arguments\r\n    function mul(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/// @title This contract is used to handle staking, and subsequently can increase RTC token supply\r\n/// @author Postables, RTrade Technologies Ltd\r\n/// @dev We able V5 for safety features, see https://solidity.readthedocs.io/en/v0.4.24/security-considerations.html#take-warnings-seriously\r\ncontract Stake {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // we mark as constant private to reduce gas costs\r\n    // Minimum stake of 1RTC\r\n    uint256 constant private MINSTAKE = 1000000000000000000;\r\n    // NOTE ON MULTIPLIER: this is right now set to 10% this may however change before token is released\r\n    uint256 constant private MULTIPLIER = 100000000000000000;\r\n    // BLOCKHOLDPERIOD is used to determine how many blocks a stake is held for, and how many blocks will mint tokens\r\n    uint256 constant private BLOCKHOLDPERIOD = 2103840;\r\n    // BLOCKSEC uses 15 seconds as an average block time. Ultimately the only thing this \"restricts\" is the time at which a stake is withdrawn\r\n    // Yes, we use block timestamps which can be influenced to some degree by miners, however since this only determines the time at which an initial stake can be withdrawn at\r\n    // due to the fact that this is also limited by block height, it is an acceptable risk\r\n    uint256 constant private BLOCKSEC = 15;\r\n    string  constant public VERSION = \"production\";\r\n    // this is the address of the RTC token contract\r\n    address  constant public TOKENADDRESS = 0xecc043b92834c1ebDE65F2181B59597a6588D616;\r\n    // this is the interface used to interact with the RTC Token\r\n    RTCoinInterface   constant public RTI = RTCoinInterface(TOKENADDRESS);\r\n\r\n    // keeps track of the number of active stakes\r\n    uint256 public activeStakes;\r\n    // keeps track of the admin address. For security purposes this can't be changed once set\r\n    address public admin;\r\n    // keeps track of whether or not new stakes can be made\r\n    bool public newStakesAllowed;\r\n\r\n    // tracks the state of a stake\r\n    enum StakeStateEnum { nil, staking, staked }\r\n\r\n    struct StakeStruct {\r\n        // how many tokens were initially staked\r\n        uint256 initialStake;\r\n        // the block that the stake was made\r\n        uint256 blockLocked;\r\n        // the block at which the initial stake can be withdrawn\r\n        uint256 blockUnlocked;\r\n        // the time at which the initial stake can be withdrawn\r\n        uint256 releaseDate;\r\n        // the total number of coins to mint\r\n        uint256 totalCoinsToMint;\r\n        // the current number of coins that have been minted\r\n        uint256 coinsMinted;\r\n        // the amount of coins generated per block\r\n        uint256 rewardPerBlock;\r\n        // the block at which a stake was last withdrawn at \r\n        uint256 lastBlockWithdrawn;\r\n        // the current state of this stake\r\n        StakeStateEnum    state;\r\n    }\r\n\r\n    event StakesDisabled();\r\n    event StakesEnabled();\r\n    event StakeDeposited(address indexed _staker, uint256 indexed _stakeNum, uint256 _coinsToMint, uint256 _releaseDate, uint256 _releaseBlock);\r\n    event StakeRewardWithdrawn(address indexed _staker, uint256 indexed _stakeNum, uint256 _reward);\r\n    event InitialStakeWithdrawn(address indexed _staker, uint256 indexed _stakeNumber, uint256 _amount);\r\n    event ForeignTokenTransfer(address indexed _sender, address indexed _recipient, uint256 _amount);\r\n\r\n    // keeps track of the stakes a user has\r\n    mapping (address => mapping (uint256 => StakeStruct)) public stakes;\r\n    // keeps track of the total number of stakes a user has\r\n    mapping (address => uint256) public numberOfStakes;\r\n    // keeps track of the user's current RTC balance\r\n    mapping (address => uint256) public internalRTCBalances;\r\n\r\n    modifier validInitialStakeRelease(uint256 _stakeNum) {\r\n        // make sure that the stake is active\r\n        require(stakes[msg.sender][_stakeNum].state == StakeStateEnum.staking, \"stake is not active\");\r\n        require(\r\n            // please see comment at top of contract about why we consider it safe to use block times\r\n            // linter warnings are left enabled on purpose\r\n            now >= stakes[msg.sender][_stakeNum].releaseDate && block.number >= stakes[msg.sender][_stakeNum].blockUnlocked, \r\n            \"attempting to withdraw initial stake before unlock block and date\"\r\n        );\r\n        require(internalRTCBalances[msg.sender] >= stakes[msg.sender][_stakeNum].initialStake, \"invalid internal rtc balance\");\r\n        _;\r\n    }\r\n\r\n    modifier validMint(uint256 _stakeNumber) {\r\n        // allow people to withdraw their rewards even if the staking period is over\r\n        require(\r\n            stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staking || stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, \r\n            \"stake must be active or inactive in order to mint tokens\"\r\n        );\r\n        // make sure that the current coins minted are less than the total coins minted\r\n        require(\r\n            stakes[msg.sender][_stakeNumber].coinsMinted < stakes[msg.sender][_stakeNumber].totalCoinsToMint, \r\n            \"current coins minted must be less than total\"\r\n        );\r\n        uint256 currentBlock = block.number;\r\n        uint256 lastBlockWithdrawn = stakes[msg.sender][_stakeNumber].lastBlockWithdrawn;\r\n        // verify that the current block is one higher than the last block a withdrawal was made\r\n        require(currentBlock > lastBlockWithdrawn, \"current block must be one higher than last withdrawal\");\r\n        _;\r\n    }\r\n\r\n    modifier stakingEnabled(uint256 _numRTC) {\r\n        // make sure this contract can mint coins on the RTC token contract\r\n        require(canMint(), \"staking contract is unable to mint tokens\");\r\n        // make sure new stakes are allowed\r\n        require(newStakesAllowed, \"new stakes are not allowed\");\r\n        // make sure they are staking at least one RTC\r\n        require(_numRTC >= MINSTAKE, \"specified stake is lower than minimum amount\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"sender is not admin\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _admin) public {\r\n        require(TOKENADDRESS != address(0), \"token address not set\");\r\n        admin = _admin;\r\n    }\r\n\r\n    /** @notice Used to disable new stakes from being made\r\n        * Only usable by contract admin\r\n     */\r\n    function disableNewStakes() public onlyAdmin returns (bool) {\r\n        newStakesAllowed = false;\r\n        return true;\r\n    }\r\n\r\n    /** @notice Used to allow new stakes to be made\r\n        * @dev For this to be enabled, the RTC token contract must be configured properly\r\n     */\r\n    function allowNewStakes() public onlyAdmin returns (bool) {\r\n        newStakesAllowed = true;\r\n        require(RTI.stakeContractAddress() == address(this), \"rtc token contract is not set to use this contract as the staking contract\");\r\n        return true;\r\n    }\r\n\r\n    /** @notice Used by a staker to claim currently staked coins\r\n        * @dev Can only be executed when at least one block has passed from the last execution\r\n        * @param _stakeNumber This is the particular stake to withdraw from\r\n     */\r\n    function mint(uint256 _stakeNumber) public validMint(_stakeNumber) returns (bool) {\r\n        // determine the amount of coins to be minted in this withdrawal\r\n        uint256 mintAmount = calculateMint(_stakeNumber);\r\n        // update current coins minted\r\n        stakes[msg.sender][_stakeNumber].coinsMinted = stakes[msg.sender][_stakeNumber].coinsMinted.add(mintAmount);\r\n        // update the last block a withdrawal was made at\r\n        stakes[msg.sender][_stakeNumber].lastBlockWithdrawn = block.number;\r\n        // emit an event\r\n        emit StakeRewardWithdrawn(msg.sender, _stakeNumber, mintAmount);\r\n        // mint the tokenz\r\n        require(RTI.mint(msg.sender, mintAmount), \"token minting failed\");\r\n        return true;\r\n    }\r\n\r\n    /** @notice Used by a staker to withdraw their initial stake\r\n        * @dev Can only be executed after the specified block number, and unix timestamp has been passed\r\n        * @param _stakeNumber This is the particular stake to withdraw from\r\n     */\r\n    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {\r\n        // get the initial stake amount\r\n        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;\r\n        // de-activate the stake\r\n        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.staked;\r\n        // decrease the total number of stakes\r\n        activeStakes = activeStakes.sub(1);\r\n        // reduce their internal RTC balance\r\n        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);\r\n        // emit an event\r\n        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);\r\n        // transfer the tokenz\r\n        require(RTI.transfer(msg.sender, initialStake), \"unable to transfer tokens likely due to incorrect balance\");\r\n        return true;\r\n    }\r\n\r\n    /** @notice This is used to deposit coins and start staking with at least one RTC\r\n        * @dev Staking must be enabled or this function will not execute\r\n        * @param _numRTC This is the number of RTC tokens to stake\r\n     */\r\n    function depositStake(uint256 _numRTC) public stakingEnabled(_numRTC) returns (bool) {\r\n        uint256 stakeCount = getStakeCount(msg.sender);\r\n\r\n        // calculate the various stake parameters\r\n        (uint256 blockLocked, \r\n        uint256 blockReleased, \r\n        uint256 releaseDate, \r\n        uint256 totalCoinsMinted,\r\n        uint256 rewardPerBlock) = calculateStake(_numRTC);\r\n\r\n        // initialize this struct in memory\r\n        StakeStruct memory ss = StakeStruct({\r\n            initialStake: _numRTC,\r\n            blockLocked: blockLocked,\r\n            blockUnlocked: blockReleased,\r\n            releaseDate: releaseDate,\r\n            totalCoinsToMint: totalCoinsMinted,\r\n            coinsMinted: 0,\r\n            rewardPerBlock: rewardPerBlock,\r\n            lastBlockWithdrawn: blockLocked,\r\n            state: StakeStateEnum.staking\r\n        });\r\n\r\n        // update the users list of stakes\r\n        stakes[msg.sender][stakeCount] = ss;\r\n        // update the users total stakes\r\n        numberOfStakes[msg.sender] = numberOfStakes[msg.sender].add(1);\r\n        // update their internal RTC balance\r\n        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].add(_numRTC);\r\n        // increase the number of active stakes\r\n        activeStakes = activeStakes.add(1);\r\n        // emit an event\r\n        emit StakeDeposited(msg.sender, stakeCount, totalCoinsMinted, releaseDate, blockReleased);\r\n        // transfer tokens\r\n        require(RTI.transferFrom(msg.sender, address(this), _numRTC), \"transfer from failed, likely needs approval\");\r\n        return true;\r\n    }\r\n\r\n\r\n    // UTILITY FUNCTIONS //\r\n\r\n    /** @notice This is a helper function used to calculate the parameters of a stake\r\n        * Will determine the block that the initial stake can be withdraw at\r\n        * Will determine the time that the initial stake can be withdrawn at\r\n        * Will determine the total number of RTC to be minted throughout hte stake\r\n        * Will determine how many RTC the stakee will be awarded per block\r\n        * @param _numRTC This is the number of RTC to be staked\r\n     */\r\n    function calculateStake(uint256 _numRTC) \r\n        internal\r\n        view\r\n        returns (\r\n            uint256 blockLocked, \r\n            uint256 blockReleased, \r\n            uint256 releaseDate, \r\n            uint256 totalCoinsMinted,\r\n            uint256 rewardPerBlock\r\n        ) \r\n    {\r\n        // the block that the stake is being made at\r\n        blockLocked = block.number;\r\n        // the block at which the initial stake will be released\r\n        blockReleased = blockLocked.add(BLOCKHOLDPERIOD);\r\n        // the time at which the initial stake will be released\r\n        // please see comment at top of contract about why we consider it safe to use block times\r\n        // linter warnings are left enabled on purpose\r\n        releaseDate = now.add(BLOCKHOLDPERIOD.mul(BLOCKSEC));\r\n        // total coins that will be minted\r\n        totalCoinsMinted = _numRTC.mul(MULTIPLIER);\r\n        // make sure to scale down\r\n        totalCoinsMinted = totalCoinsMinted.div(1 ether);\r\n        // calculate the coins minted per block\r\n        rewardPerBlock = totalCoinsMinted.div(BLOCKHOLDPERIOD);\r\n    }\r\n\r\n    /** @notice This is a helper function used to calculate how many coins will be awarded in a given internal\r\n        * @param _stakeNumber This is the particular stake to calculate from\r\n     */\r\n    function calculateMint(uint256 _stakeNumber)\r\n        internal\r\n        view\r\n        returns (uint256 reward)\r\n    {\r\n        // calculate how many blocks they can claim a stake for\r\n        uint256 currentBlock = calculateCurrentBlock(_stakeNumber);\r\n        //get the last block a withdrawal was made at\r\n        uint256 lastBlockWithdrawn = stakes[msg.sender][_stakeNumber].lastBlockWithdrawn;\r\n        // determine the number of blocks to generate a reward for\r\n        uint256 blocksToReward = currentBlock.sub(lastBlockWithdrawn);\r\n        // calculate the reward\r\n        reward = blocksToReward.mul(stakes[msg.sender][_stakeNumber].rewardPerBlock);\r\n        // get total number of coins to be minted\r\n        uint256 totalToMint = stakes[msg.sender][_stakeNumber].totalCoinsToMint;\r\n        // get current number of coins minted\r\n        uint256 currentCoinsMinted = stakes[msg.sender][_stakeNumber].coinsMinted;\r\n        // get the new numberof total coins to be minted\r\n        uint256 newCoinsMinted = currentCoinsMinted.add(reward);\r\n        // if for some reason more would be generated, prevent that from happening\r\n        if (newCoinsMinted > totalToMint) {\r\n            reward = newCoinsMinted.sub(totalToMint);\r\n        }\r\n    }\r\n\r\n    /** @notice Allow us to transfer tokens that someone might've accidentally sent to this contract\r\n        @param _tokenAddress this is the address of the token contract\r\n        @param _recipient This is the address of the person receiving the tokens\r\n        @param _amount This is the amount of tokens to send\r\n     */\r\n    function transferForeignToken(\r\n        address _tokenAddress,\r\n        address _recipient,\r\n        uint256 _amount)\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        require(_recipient != address(0), \"recipient address can't be empty\");\r\n        // don't allow us to transfer RTC tokens stored in this contract\r\n        require(_tokenAddress != TOKENADDRESS, \"token can't be RTC\");\r\n        ERC20Interface eI = ERC20Interface(_tokenAddress);\r\n        require(eI.transfer(_recipient, _amount), \"token transfer failed\");\r\n        emit ForeignTokenTransfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    /** @notice This is a helper function used to calculate how many blocks to mint coins for\r\n        * @param _stakeNumber This is the stake to be used for calculations\r\n     */\r\n    function calculateCurrentBlock(uint256 _stakeNumber) internal view returns (uint256 currentBlock) {\r\n        currentBlock = block.number;\r\n        // if the current block is greater than the block at which coins can be unlocked at, \r\n        // prevent them from generating more coins that allowed\r\n        if (currentBlock >= stakes[msg.sender][_stakeNumber].blockUnlocked) {\r\n            currentBlock = stakes[msg.sender][_stakeNumber].blockUnlocked;\r\n        }\r\n    }\r\n    \r\n    /** @notice This is a helper function used to get the total number of stakes a \r\n        * @param _staker This is the address of the stakee\r\n     */\r\n    function getStakeCount(address _staker) internal view returns (uint256) {\r\n        return numberOfStakes[_staker];\r\n    }\r\n\r\n    /** @notice This is a helper function that checks whether or not this contract can mint tokens\r\n        * @dev This should only ever be false under extreme circumstances such as a potential vulnerability\r\n     */\r\n    function canMint() public view returns (bool) {\r\n        require(RTI.stakeContractAddress() == address(this), \"rtc token contract is not set to use this contract as the staking contract\");\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"disableNewStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowNewStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeNumber\",\"type\":\"uint256\"}],\"name\":\"withdrawInitialStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"initialStake\",\"type\":\"uint256\"},{\"name\":\"blockLocked\",\"type\":\"uint256\"},{\"name\":\"blockUnlocked\",\"type\":\"uint256\"},{\"name\":\"releaseDate\",\"type\":\"uint256\"},{\"name\":\"totalCoinsToMint\",\"type\":\"uint256\"},{\"name\":\"coinsMinted\",\"type\":\"uint256\"},{\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"name\":\"lastBlockWithdrawn\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RTI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newStakesAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeNumber\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numRTC\",\"type\":\"uint256\"}],\"name\":\"depositStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numberOfStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"internalRTCBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StakesDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StakesEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_stakeNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_coinsToMint\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_releaseDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_releaseBlock\",\"type\":\"uint256\"}],\"name\":\"StakeDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_stakeNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"StakeRewardWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_stakeNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"InitialStakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ForeignTokenTransfer\",\"type\":\"event\"}]","ContractName":"Stake","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000041fb0e5bd1dfe3b61e9a09ebd4105c2e35b0bcbd","Library":"","SwarmSource":"bzzr://fc5228638a7dc266e5b363c2b71e378399a8cd50ad1fe69209b2d27d7cdb201d"}]}