{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ERC20Interface {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract PoolAndSaleInterface {\r\n    address public tokenSaleAddr;\r\n    address public votingAddr;\r\n    address public votingTokenAddr;\r\n    uint256 public tap;\r\n    uint256 public initialTap;\r\n    uint256 public initialRelease;\r\n\r\n    function setTokenSaleContract(address _tokenSaleAddr) external;\r\n    function startProject() external;\r\n}\r\n\r\ncontract DaicoPool is PoolAndSaleInterface, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public tokenSaleAddr;\r\n    address public votingAddr;\r\n    address public votingTokenAddr;\r\n    uint256 public tap;\r\n    uint256 public initialTap;\r\n    uint256 public initialRelease;\r\n    uint256 public releasedBalance;\r\n    uint256 public withdrawnBalance;\r\n    uint256 public lastUpdatedTime;\r\n    uint256 public fundRaised;\r\n    uint256 public closingRelease = 30 days;\r\n\r\n    /* The unit of this variable is [10^-9 wei / token], intending to minimize rouding errors */\r\n    uint256 public refundRateNano = 0;\r\n  \r\n    enum Status {\r\n        Initializing,\r\n        ProjectInProgress,\r\n        Destructed\r\n    }\r\n  \r\n    Status public status;\r\n\r\n    event TapHistory(uint256 new_tap);\r\n    event WithdrawalHistory(string token, uint256 amount);\r\n    event Refund(address receiver, uint256 amount);\r\n\r\n    modifier onlyTokenSaleContract {\r\n        require(msg.sender == tokenSaleAddr);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVoting {\r\n        require(msg.sender == votingAddr);\r\n        _;\r\n    }\r\n\r\n    modifier poolInitializing {\r\n        require(status == Status.Initializing);\r\n        _;\r\n    }\r\n\r\n    modifier poolDestructed {\r\n        require(status == Status.Destructed);\r\n        _;\r\n    }\r\n\r\n    constructor(address _votingTokenAddr, uint256 tap_amount, uint256 _initialRelease) public {\r\n        require(_votingTokenAddr != 0x0);\r\n        require(tap_amount > 0);\r\n\r\n        initialTap = tap_amount;\r\n        votingTokenAddr = _votingTokenAddr;\r\n        status = Status.Initializing;\r\n        initialRelease = _initialRelease;\r\n \r\n        votingAddr = new Voting(ERC20Interface(_votingTokenAddr), address(this));\r\n    }\r\n\r\n    function () external payable {}\r\n\r\n    function setTokenSaleContract(address _tokenSaleAddr) external {\r\n        /* Can be set only once */\r\n        require(tokenSaleAddr == address(0x0));\r\n        require(_tokenSaleAddr != address(0x0));\r\n        tokenSaleAddr = _tokenSaleAddr;\r\n    }\r\n\r\n    function startProject() external onlyTokenSaleContract {\r\n        require(status == Status.Initializing);\r\n        status = Status.ProjectInProgress;\r\n        lastUpdatedTime = block.timestamp;\r\n        releasedBalance = initialRelease;\r\n        updateTap(initialTap);\r\n        fundRaised = address(this).balance;\r\n    }\r\n\r\n    function withdraw(uint256 _amount) public onlyOwner {\r\n        require(_amount > 0);\r\n        uint256 amount = _amount;\r\n\r\n        updateReleasedBalance();\r\n        uint256 available_balance = getAvailableBalance();\r\n        if (amount > available_balance) {\r\n            amount = available_balance;\r\n        }\r\n\r\n        withdrawnBalance = withdrawnBalance.add(amount);\r\n        owner.transfer(amount);\r\n\r\n        emit WithdrawalHistory(\"ETH\", amount);\r\n    }\r\n\r\n    function raiseTap(uint256 tapMultiplierRate) external onlyVoting {\r\n        updateReleasedBalance();\r\n        updateTap(tap.mul(tapMultiplierRate).div(100));\r\n    }\r\n\r\n    function selfDestruction() external onlyVoting {\r\n        status = Status.Destructed;\r\n        updateReleasedBalance();\r\n        releasedBalance = releasedBalance.add(closingRelease.mul(tap));\r\n        updateTap(0);\r\n\r\n        uint256 _totalSupply = ERC20Interface(votingTokenAddr).totalSupply(); \r\n        refundRateNano = address(this).balance.sub(getAvailableBalance()).mul(10**9).div(_totalSupply);\r\n    }\r\n\r\n    function refund(uint256 tokenAmount) external poolDestructed {\r\n        require(ERC20Interface(votingTokenAddr).transferFrom(msg.sender, this, tokenAmount));\r\n\r\n        uint256 refundingEther = tokenAmount.mul(refundRateNano).div(10**9);\r\n        emit Refund(msg.sender, tokenAmount);\r\n        msg.sender.transfer(refundingEther);\r\n    }\r\n\r\n    function getReleasedBalance() public view returns(uint256) {\r\n        uint256 time_elapsed = block.timestamp.sub(lastUpdatedTime);\r\n        return releasedBalance.add(time_elapsed.mul(tap));\r\n    }\r\n \r\n    function getAvailableBalance() public view returns(uint256) {\r\n        uint256 available_balance = getReleasedBalance().sub(withdrawnBalance);\r\n\r\n        if (available_balance > address(this).balance) {\r\n            available_balance = address(this).balance;\r\n        }\r\n\r\n        return available_balance;\r\n    }\r\n\r\n    function isStateInitializing() public view returns(bool) {\r\n        return (status == Status.Initializing); \r\n    }\r\n\r\n    function isStateProjectInProgress() public view returns(bool) {\r\n        return (status == Status.ProjectInProgress); \r\n    }\r\n\r\n    function isStateDestructed() public view returns(bool) {\r\n        return (status == Status.Destructed); \r\n    }\r\n\r\n    function updateReleasedBalance() internal {\r\n        releasedBalance = getReleasedBalance();\r\n        lastUpdatedTime = block.timestamp;\r\n    }\r\n\r\n    function updateTap(uint256 new_tap) private {\r\n        tap = new_tap;\r\n        emit TapHistory(new_tap);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Voting{\r\n    using SafeMath for uint256;\r\n\r\n    address public votingTokenAddr;\r\n    address public poolAddr;\r\n    mapping (uint256 => mapping(address => uint256)) public deposits;\r\n    mapping (uint => bool) public queued;\r\n\r\n    uint256 proposalCostWei = 1 * 10**18;\r\n\r\n    uint256 public constant VOTING_PERIOD = 15 minutes;\r\n\r\n    struct Proposal {\r\n        uint256 start_time;\r\n        uint256 end_time;\r\n        Subject subject;\r\n        string reason;\r\n        mapping (bool => uint256) votes; \r\n        uint256 voter_count;\r\n        bool isFinalized;\r\n        uint256 tapMultiplierRate;\r\n    }\r\n\r\n    Proposal[] public proposals;\r\n    uint public constant PROPOSAL_EMPTY = 0;\r\n\r\n    enum Subject {\r\n        RaiseTap,\r\n        Destruction\r\n    }\r\n\r\n    event Vote(\r\n        address indexed voter,\r\n        uint256 amount\r\n    );\r\n\r\n    event ReturnDeposit(\r\n        address indexed voter,\r\n        uint256 amount\r\n    );\r\n\r\n    event ProposalRaised(\r\n        address indexed proposer,\r\n        string subject \r\n    );\r\n\r\n    /// @dev Constructor.\r\n    /// @param _votingTokenAddr The contract address of ERC20 \r\n    /// @param _poolAddr The contract address of DaicoPool\r\n    /// @return \r\n    constructor (\r\n        address _votingTokenAddr,\r\n        address _poolAddr\r\n    ) public {\r\n        require(_votingTokenAddr != address(0x0));\r\n        require(_poolAddr != address(0x0));\r\n        votingTokenAddr = _votingTokenAddr;\r\n        poolAddr = _poolAddr;\r\n\r\n        // Insert an empty proposal as the header in order to make index 0 to be missing number.\r\n        Proposal memory proposal;\r\n        proposal.subject = Subject.RaiseTap;\r\n        proposal.reason = \"PROPOSAL_HEADER\";\r\n        proposal.start_time = block.timestamp -1;\r\n        proposal.end_time = block.timestamp -1;\r\n        proposal.voter_count = 0;\r\n        proposal.isFinalized = true;\r\n\r\n        proposals.push(proposal);\r\n        assert(proposals.length == 1);\r\n    }\r\n\r\n    /// @dev Make a TAP raising proposal. It costs certain amount of ETH.\r\n    /// @param _reason The reason to raise the TAP. This field can be an URL of a WEB site.\r\n    /// @param _tapMultiplierRate TAP increase rate. From 101 to 200. i.e. 150 = 150% .\r\n    /// @return \r\n    function addRaiseTapProposal (\r\n        string _reason,\r\n        uint256 _tapMultiplierRate\r\n    ) external payable returns(uint256) {\r\n        require(!queued[uint(Subject.RaiseTap)]);\r\n        require(100 < _tapMultiplierRate && _tapMultiplierRate <= 200);\r\n\r\n        uint256 newID = addProposal(Subject.RaiseTap, _reason);\r\n        proposals[newID].tapMultiplierRate = _tapMultiplierRate;\r\n\r\n        queued[uint(Subject.RaiseTap)] = true;\r\n        emit ProposalRaised(msg.sender, \"RaiseTap\");\r\n    }\r\n\r\n    /// @dev Make a self destruction proposal. It costs certain amount of ETH.\r\n    /// @param _reason The reason to destruct the pool. This field can be an URL of a WEB site.\r\n    /// @return \r\n    function addDestructionProposal (string _reason) external payable returns(uint256) {\r\n        require(!queued[uint(Subject.Destruction)]);\r\n\r\n        addProposal(Subject.Destruction, _reason);\r\n\r\n        queued[uint(Subject.Destruction)] = true;\r\n        emit ProposalRaised(msg.sender, \"SelfDestruction\");\r\n    }\r\n\r\n    /// @dev Vote yes or no to current proposal.\r\n    /// @param amount Token amount to be voted.\r\n    /// @return \r\n    function vote (bool agree, uint256 amount) external {\r\n        require(ERC20Interface(votingTokenAddr).transferFrom(msg.sender, this, amount));\r\n        uint256 pid = this.getCurrentVoting();\r\n        require(pid != PROPOSAL_EMPTY);\r\n\r\n        require(proposals[pid].start_time <= block.timestamp);\r\n        require(proposals[pid].end_time >= block.timestamp);\r\n\r\n        if (deposits[pid][msg.sender] == 0) {\r\n            proposals[pid].voter_count = proposals[pid].voter_count.add(1);\r\n        }\r\n\r\n        deposits[pid][msg.sender] = deposits[pid][msg.sender].add(amount);\r\n        proposals[pid].votes[agree] = proposals[pid].votes[agree].add(amount);\r\n        emit Vote(msg.sender, amount);\r\n    }\r\n\r\n    /// @dev Finalize the current voting. It can be invoked when the end time past.\r\n    /// @dev Anyone can invoke this function.\r\n    /// @return \r\n    function finalizeVoting () external {\r\n        uint256 pid = this.getCurrentVoting();\r\n        require(pid != PROPOSAL_EMPTY);\r\n        require(proposals[pid].end_time <= block.timestamp);\r\n        require(!proposals[pid].isFinalized);\r\n\r\n        proposals[pid].isFinalized = true;\r\n\r\n        if (isSubjectRaiseTap(pid)) {\r\n            queued[uint(Subject.RaiseTap)] = false;\r\n            if (isPassed(pid)) {\r\n                DaicoPool(poolAddr).raiseTap(proposals[pid].tapMultiplierRate);\r\n            }\r\n\r\n        } else if (isSubjectDestruction(pid)) {\r\n            queued[uint(Subject.Destruction)] = false;\r\n            if (isPassed(pid)) {\r\n                DaicoPool(poolAddr).selfDestruction();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Return all tokens which specific account used to vote so far.\r\n    /// @param account An address that deposited tokens. It also be the receiver.\r\n    /// @return \r\n    function returnToken (address account) external returns(bool) {\r\n        uint256 amount = 0;\r\n    \r\n        for (uint256 pid = 0; pid < proposals.length; pid++) {\r\n            if(!proposals[pid].isFinalized){\r\n              break;\r\n            }\r\n            amount = amount.add(deposits[pid][account]);\r\n            deposits[pid][account] = 0;\r\n        }\r\n\r\n        if(amount <= 0){\r\n           return false;\r\n        }\r\n\r\n        require(ERC20Interface(votingTokenAddr).transfer(account, amount));\r\n        emit ReturnDeposit(account, amount);\r\n \r\n        return true;\r\n    }\r\n\r\n    /// @dev Return tokens to multiple addresses.\r\n    /// @param accounts Addresses that deposited tokens. They also be the receivers.\r\n    /// @return \r\n    function returnTokenMulti (address[] accounts) external {\r\n        for(uint256 i = 0; i < accounts.length; i++){\r\n            this.returnToken(accounts[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Return the index of on going voting.\r\n    /// @return The index of voting. \r\n    function getCurrentVoting () public view returns(uint256) {\r\n        for (uint256 i = 0; i < proposals.length; i++) {\r\n            if (!proposals[i].isFinalized) {\r\n                return i;\r\n            }\r\n        }\r\n        return PROPOSAL_EMPTY;\r\n    }\r\n\r\n    /// @dev Check if a proposal has been agreed or not.\r\n    /// @param pid Index of a proposal.\r\n    /// @return True if the proposal passed. False otherwise. \r\n    function isPassed (uint256 pid) public view returns(bool) {\r\n        require(proposals[pid].isFinalized);\r\n        uint256 ayes = getAyes(pid);\r\n        uint256 nays = getNays(pid);\r\n        uint256 absent = ERC20Interface(votingTokenAddr).totalSupply().sub(ayes).sub(nays);\r\n        return (ayes > nays.add(absent.div(6)));\r\n    }\r\n\r\n    /// @dev Check if a voting has started or not.\r\n    /// @param pid Index of a proposal.\r\n    /// @return True if the voting already started. False otherwise. \r\n    function isStarted (uint256 pid) public view returns(bool) {\r\n        if (pid > getCurrentVoting()) {\r\n            return false;\r\n        } else if (block.timestamp >= proposals[pid].start_time) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Check if a voting has ended or not.\r\n    /// @param pid Index of a proposal.\r\n    /// @return True if the voting already ended. False otherwise. \r\n    function isEnded (uint256 pid) public view returns(bool) {\r\n        if (pid > getCurrentVoting()) {\r\n            return false;\r\n        } else if (block.timestamp >= proposals[pid].end_time) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Return the reason of a proposal.\r\n    /// @param pid Index of a proposal.\r\n    /// @return Text of the reason that is set when the proposal made. \r\n    function getReason (uint256 pid) external view returns(string) {\r\n        require(pid < proposals.length);\r\n        return proposals[pid].reason;\r\n    }\r\n\r\n    /// @dev Check if a proposal is about TAP raising or not.\r\n    /// @param pid Index of a proposal.\r\n    /// @return True if it's TAP raising. False otherwise.\r\n    function isSubjectRaiseTap (uint256 pid) public view returns(bool) {\r\n        require(pid < proposals.length);\r\n        return proposals[pid].subject == Subject.RaiseTap;\r\n    }\r\n\r\n    /// @dev Check if a proposal is about self destruction or not.\r\n    /// @param pid Index of a proposal.\r\n    /// @return True if it's self destruction. False otherwise.\r\n    function isSubjectDestruction (uint256 pid) public view returns(bool) {\r\n        require(pid < proposals.length);\r\n        return proposals[pid].subject == Subject.Destruction;\r\n    }\r\n\r\n    /// @dev Return the number of voters take part in a specific voting.\r\n    /// @param pid Index of a proposal.\r\n    /// @return The number of voters.\r\n    function getVoterCount (uint256 pid) external view returns(uint256) {\r\n        require(pid < proposals.length);\r\n        return proposals[pid].voter_count;\r\n    }\r\n\r\n    /// @dev Return the number of votes that agrees the proposal.\r\n    /// @param pid Index of a proposal.\r\n    /// @return The number of votes that agrees the proposal.\r\n    function getAyes (uint256 pid) public view returns(uint256) {\r\n        require(pid < proposals.length);\r\n        require(proposals[pid].isFinalized);\r\n        return proposals[pid].votes[true];\r\n    }\r\n\r\n    /// @dev Return the number of votes that disagrees the proposal.\r\n    /// @param pid Index of a proposal.\r\n    /// @return The number of votes that disagrees the proposal.\r\n    function getNays (uint256 pid) public view returns(uint256) {\r\n        require(pid < proposals.length);\r\n        require(proposals[pid].isFinalized);\r\n        return proposals[pid].votes[false];\r\n    }\r\n\r\n    /// @dev Internal function to add a proposal into the voting queue.\r\n    /// @param _subject Subject of the proposal. Can be TAP raising or self destruction.\r\n    /// @param _reason Reason of the proposal. This field can be an URL of a WEB site.\r\n    /// @return Index of the proposal.\r\n    function addProposal (Subject _subject, string _reason) internal returns(uint256) {\r\n        require(msg.value == proposalCostWei);\r\n        require(DaicoPool(poolAddr).isStateProjectInProgress());\r\n        poolAddr.transfer(msg.value);\r\n\r\n        Proposal memory proposal;\r\n        proposal.subject = _subject;\r\n        proposal.reason = _reason;\r\n        proposal.start_time = block.timestamp;\r\n        proposal.end_time = block.timestamp + VOTING_PERIOD;\r\n        proposal.voter_count = 0;\r\n        proposal.isFinalized = false;\r\n\r\n        proposals.push(proposal);\r\n        uint256 newID = proposals.length - 1;\r\n        return newID;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isStateDestructed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawnBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenSaleAddr\",\"type\":\"address\"}],\"name\":\"setTokenSaleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundRateNano\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStateProjectInProgress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tapMultiplierRate\",\"type\":\"uint256\"}],\"name\":\"raiseTap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releasedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingTokenAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUpdatedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialTap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReleasedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStateInitializing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_votingTokenAddr\",\"type\":\"address\"},{\"name\":\"tap_amount\",\"type\":\"uint256\"},{\"name\":\"_initialRelease\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"new_tap\",\"type\":\"uint256\"}],\"name\":\"TapHistory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalHistory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DaicoPool","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008929af76b0b66d260dd6f80ff813fc958e8ea8ff0000000000000000000000000000000000000000000000000000010d7a6a7600000000000000000000000000000000000000000000000000002386f26fc10000","Library":"","SwarmSource":"bzzr://8d475fa66e56fc954172676292b1e3dd6b1a6546658fb00728a22653bc2be50c"}]}