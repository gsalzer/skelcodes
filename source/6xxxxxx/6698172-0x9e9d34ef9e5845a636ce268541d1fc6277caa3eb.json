{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract FastGameMultiplier {\r\n\r\n    //адрес поддержки\r\n    address public support;\r\n\r\n    //Проценты\r\n\tuint constant public PRIZE_PERCENT = 3;\r\n    uint constant public SUPPORT_PERCENT = 2;\r\n    \r\n    //ограничения депозита\r\n    uint constant public MAX_INVESTMENT =  0.2 ether;\r\n    uint constant public MIN_INVESTMENT = 0.01 ether;\r\n    uint constant public MIN_INVESTMENT_FOR_PRIZE = 0.02 ether;\r\n    uint constant public GAS_PRICE_MAX = 20; // максимальная цена газа maximum gas price for contribution transactions\r\n    uint constant public MAX_IDLE_TIME = 10 minutes; //время ожидания до забора приза //Maximum time the deposit should remain the last to receive prize\r\n\r\n    //успешность игры, минимальное количество участников\r\n    uint constant public SIZE_TO_SAVE_INVEST = 10; //минимальное количество участников\r\n    uint constant public TIME_TO_SAVE_INVEST = 5 minutes; //время после которого игру можно отменить\r\n    \r\n    //сетка процентов для вложения в одном старте, старт каждый час (тестово)\r\n    uint8[] MULTIPLIERS = [\r\n        115, //первый\r\n        120, //второй\r\n        125 //третий\r\n    ];\r\n\r\n    //описание депозита\r\n    struct Deposit {\r\n        address depositor; //Адрес депозита\r\n        uint128 deposit;   //Сумма депозита \r\n        uint128 expect;    //Сколько выплатить по депозиту (115%-125%)\r\n    }\r\n\r\n   //Описание номера очереди и номер депозита в очереди\r\n    struct DepositCount {\r\n        int128 stage;\r\n        uint128 count;\r\n    }\r\n\r\n\t//Описание последнего и предпоследнего депозита \r\n    struct LastDepositInfo {\r\n        uint128 index;\r\n        uint128 time;\r\n    }\r\n\r\n    Deposit[] private queue;  //The queue\r\n\r\n    uint public currentReceiverIndex = 0; //Индекс первого инвестора The index of the first depositor in the queue. The receiver of investments!\r\n    uint public currentQueueSize = 0; //Размер очереди The current size of queue (may be less than queue.length)\r\n    LastDepositInfo public lastDepositInfoForPrize; //Последний депозит для Джека The time last deposit made at\r\n    LastDepositInfo public previosDepositInfoForPrize; //Предпоследний депозит для Джека The time last deposit made at\r\n\r\n    uint public prizeAmount = 0; //Сумма приза оставшаяся с прошлого запуска\r\n    uint public prizeStageAmount = 0; //Сумма приза Prize в текущем запуске amount accumulated for the last depositor\r\n    int public stage = 0; //Количество стартов Number of contract runs\r\n    uint128 public lastDepositTime = 0; //Время последнего депозита\r\n    \r\n    mapping(address => DepositCount) public depositsMade; //The number of deposits of different depositors\r\n\r\n    constructor() public {\r\n        support = msg.sender; \r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n    \r\n    //This function receives all the deposits\r\n    //stores them and make immediate payouts\r\n    function () public payable {\r\n        require(tx.gasprice <= GAS_PRICE_MAX * 1000000000);\r\n        require(gasleft() >= 250000, \"We require more gas!\"); //условие ограничения газа\r\n        \r\n        checkAndUpdateStage();\r\n        \r\n        if(msg.value > 0){\r\n            require(msg.value >= MIN_INVESTMENT && msg.value <= MAX_INVESTMENT); //Условие  депозита\r\n            require(lastDepositInfoForPrize.time <= now + MAX_IDLE_TIME); \r\n\r\n            \r\n\r\n            require(getNextStageStartTime() >= now + MAX_IDLE_TIME + 10 minutes);//нельзя инвестировать за MAX_IDLE_TIME до следующего старта\r\n\r\n            //Pay to first investors in line\r\n            if(currentQueueSize < SIZE_TO_SAVE_INVEST){ //страховка от плохого старта\r\n                \r\n                addDeposit(msg.sender, msg.value);\r\n                \r\n            } else {\r\n                \r\n                addDeposit(msg.sender, msg.value);\r\n                pay(); \r\n                \r\n            }\r\n            \r\n        } else if(msg.value == 0 && currentQueueSize > SIZE_TO_SAVE_INVEST){\r\n            \r\n            withdrawPrize(); //выплата приза\r\n            \r\n        } else if(msg.value == 0){\r\n            \r\n            require(currentQueueSize <= SIZE_TO_SAVE_INVEST); //Для возврата должно быть менее, либо равно SIZE_TO_SAVE_INVEST игроков\r\n            require(lastDepositTime > 0 && (now - lastDepositTime) >= TIME_TO_SAVE_INVEST); //Для возврата должно пройти время TIME_TO_SAVE_INVEST\r\n            \r\n            returnPays(); //Вернуть все депозиты\r\n            \r\n        } \r\n    }\r\n\r\n    //Used to pay to current investors\r\n    function pay() private {\r\n        //Try to send all the money on contract to the first investors in line\r\n        uint balance = address(this).balance;\r\n        uint128 money = 0;\r\n        \r\n        if(balance > prizeStageAmount) //The opposite is impossible, however the check will not do any harm\r\n            money = uint128(balance - prizeStageAmount);\r\n\r\n        //Send small part to tech support\r\n        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);\r\n        support.send(moneyS);\r\n        money -= moneyS;\r\n        \r\n        //We will do cycle on the queue\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\r\n\r\n            Deposit storage dep = queue[i]; //get the info of the first investor\r\n\r\n            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor\r\n                    \r\n                dep.depositor.send(dep.expect); \r\n                money -= dep.expect;          \r\n                \r\n                //После выплаты депозиты + процента удаляется из очереди this investor is fully paid, so remove him\r\n                delete queue[i];\r\n            \r\n                \r\n            }else{\r\n                //Here we don't have enough money so partially pay to investor\r\n\r\n                dep.depositor.send(money);      //Send to him everything we have\r\n                money -= dep.expect;            //update money left\r\n\r\n                break;                     //Exit cycle\r\n            }\r\n\r\n            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle\r\n                break;                     //The next investor will process the line further\r\n        }\r\n\r\n        currentReceiverIndex = i; //Update the index of the current first investor\r\n    }\r\n    \r\n    function returnPays() private {\r\n        //Try to send all the money on contract to the first investors in line\r\n        uint balance = address(this).balance;\r\n        uint128 money = 0;\r\n        \r\n        if(balance > prizeAmount) //The opposite is impossible, however the check will not do any harm\r\n            money = uint128(balance - prizeAmount);\r\n        \r\n        //We will do cycle on the queue\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\r\n\r\n            Deposit storage dep = queue[i]; //get the info of the first investor\r\n\r\n                dep.depositor.send(dep.deposit); //Игра не состоялась, возврат\r\n                money -= dep.deposit;            \r\n                \r\n                //После выплаты депозиты + процента удаляется из очереди this investor is fully paid, so remove him\r\n                delete queue[i];\r\n\r\n        }\r\n\r\n        prizeStageAmount = 0; //Вернули деньги, джека текущей очереди нет.\r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n\r\n    function addDeposit(address depositor, uint value) private {\r\n        //Count the number of the deposit at this stage\r\n        DepositCount storage c = depositsMade[depositor];\r\n        if(c.stage != stage){\r\n            c.stage = int128(stage);\r\n            c.count = 0;\r\n        }\r\n\r\n        //Участие в игре за джекпот только минимальном депозите MIN_INVESTMENT_FOR_PRIZE\r\n        if(value >= MIN_INVESTMENT_FOR_PRIZE){\r\n            previosDepositInfoForPrize = lastDepositInfoForPrize;\r\n            lastDepositInfoForPrize = LastDepositInfo(uint128(currentQueueSize), uint128(now));\r\n        }\r\n\r\n        //Compute the multiplier percent for this depositor\r\n        uint multiplier = getDepositorMultiplier(depositor);\r\n        \r\n        push(depositor, value, value*multiplier/100);\r\n\r\n        //Increment number of deposits the depositors made this round\r\n        c.count++;\r\n\r\n        lastDepositTime = uint128(now);\r\n        \r\n        //Save money for prize\r\n        prizeStageAmount += value*PRIZE_PERCENT/100;\r\n    }\r\n\r\n    function checkAndUpdateStage() private {\r\n        int _stage = getCurrentStageByTime();\r\n\r\n        require(_stage >= stage); //старт еще не произошел\r\n\r\n        if(_stage != stage){\r\n            proceedToNewStage(_stage);\r\n        }\r\n    }\r\n\r\n    function proceedToNewStage(int _stage) private {\r\n        //Старт новой игры\r\n        stage = _stage;\r\n        currentQueueSize = 0; \r\n        currentReceiverIndex = 0;\r\n        lastDepositTime = 0;\r\n        prizeAmount += prizeStageAmount; \r\n        prizeStageAmount = 0;\r\n        delete queue;\r\n        delete previosDepositInfoForPrize;\r\n        delete lastDepositInfoForPrize;\r\n    }\r\n\r\n    //отправка приза\r\n    function withdrawPrize() private {\r\n        //You can withdraw prize only if the last deposit was more than MAX_IDLE_TIME ago\r\n        require(lastDepositInfoForPrize.time > 0 && lastDepositInfoForPrize.time <= now - MAX_IDLE_TIME, \"The last depositor is not confirmed yet\");\r\n        //Last depositor will receive prize only if it has not been fully paid\r\n        require(currentReceiverIndex <= lastDepositInfoForPrize.index, \"The last depositor should still be in queue\");\r\n\r\n        uint balance = address(this).balance;\r\n\r\n        //Send donation to the first multiplier for it to spin faster\r\n        //It already contains all the sum, so we must split for father and last depositor only\r\n        //If the .call fails then ether will just stay on the contract to be distributed to\r\n        //the queue at the next stage\r\n\r\n        uint prize = balance;\r\n        if(previosDepositInfoForPrize.index > 0){\r\n            uint prizePrevios = prize*10/100;\r\n            queue[previosDepositInfoForPrize.index].depositor.transfer(prizePrevios);\r\n            prize -= prizePrevios;\r\n        }\r\n\r\n        queue[lastDepositInfoForPrize.index].depositor.send(prize);\r\n        \r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n\r\n    //Добавить выплату в очередь\r\n    function push(address depositor, uint deposit, uint expect) private {\r\n        //Add the investor into the queue\r\n        Deposit memory dep = Deposit(depositor, uint128(deposit), uint128(expect));\r\n        assert(currentQueueSize <= queue.length); //Assert queue size is not corrupted\r\n        if(queue.length == currentQueueSize)\r\n            queue.push(dep);\r\n        else\r\n            queue[currentQueueSize] = dep;\r\n\r\n        currentQueueSize++;\r\n    }\r\n\r\n    //Информация о депозите\r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\r\n        Deposit storage dep = queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expect);\r\n    }\r\n\r\n    //Количество депозитов внесенное игроком\r\n    function getDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; ++i){\r\n            if(queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    //Количество участников игры\r\n    function getQueueLength() public view returns (uint) {\r\n        return currentQueueSize - currentReceiverIndex;\r\n    }\r\n\r\n    //Номер вклада в текущей очереди\r\n    function getDepositorMultiplier(address depositor) public view returns (uint) {\r\n        DepositCount storage c = depositsMade[depositor];\r\n        uint count = 0;\r\n        if(c.stage == getCurrentStageByTime())\r\n            count = c.count;\r\n        if(count < MULTIPLIERS.length)\r\n            return MULTIPLIERS[count];\r\n\r\n        return MULTIPLIERS[MULTIPLIERS.length - 1];\r\n    }\r\n\r\n    // Текущий этап игры\r\n    function getCurrentStageByTime() public view returns (int) {\r\n        return int(now - 17847 * 86400 - 19 * 3600) / (24 * 60 * 60);\r\n    }\r\n\r\n    // Время начала следующей игры\r\n    function getNextStageStartTime() public view returns (uint) {\r\n        return 17847 * 86400 + 19 * 3600 + uint((getCurrentStageByTime() + 1) * 24 * 60 * 60); //старт 22:00\r\n    }\r\n\r\n    //Информация об кандидате на приз\r\n    function getCurrentCandidateForPrize() public view returns (address addr, int timeLeft){\r\n        if(currentReceiverIndex <= lastDepositInfoForPrize.index && lastDepositInfoForPrize.index < currentQueueSize){\r\n            Deposit storage d = queue[lastDepositInfoForPrize.index];\r\n            addr = d.depositor;\r\n            timeLeft = int(lastDepositInfoForPrize.time + MAX_IDLE_TIME) - int(now);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getNextStageStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentQueueSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositInfoForPrize\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"time\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"support\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPPORT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStageByTime\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositorMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_PRICE_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRIZE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT_FOR_PRIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeStageAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositsMade\",\"outputs\":[{\"name\":\"stage\",\"type\":\"int128\"},{\"name\":\"count\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SIZE_TO_SAVE_INVEST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_IDLE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_TO_SAVE_INVEST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentCandidateForPrize\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"timeLeft\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previosDepositInfoForPrize\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"time\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"FastGameMultiplier","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fbf877e79b83848ca792b50bd63a6a1ad3866720190254fc8095ae49484ae6e9"}]}