{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface Token {\r\n    function transfer(address to, uint256 value) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n    function approve(address spender, uint256 value) external returns (bool success);\r\n\r\n    // This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions.\r\n    function totalSupply() external constant returns (uint256 supply);\r\n    function balanceOf(address owner) external constant returns (uint256 balance);\r\n    function allowance(address owner, address spender) external constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface PromissoryToken {\r\n\r\n\tfunction claim() payable external;\r\n\tfunction lastPrice() external returns(uint256);\r\n}\r\n\r\ncontract DutchAuction {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event BidSubmission(address indexed sender, uint256 amount);\r\n    event logPayload(bytes _data, uint _lengt);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant public MAX_TOKENS_SOLD = 10000000 * 10**18; // 10M\r\n    uint constant public WAITING_PERIOD = 45 days;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n\r\n\r\n    address public pWallet;\r\n    Token public KittieFightToken;\r\n    address public owner;\r\n    PromissoryToken public PromissoryTokenIns; \r\n    address constant public promissoryAddr = 0x0348B55AbD6E1A99C6EBC972A6A4582Ec0bcEb5c;\r\n    uint public ceiling;\r\n    uint public priceFactor;\r\n    uint public startBlock;\r\n    uint public endTime;\r\n    uint public totalReceived;\r\n    uint public finalPrice;\r\n    mapping (address => uint) public bids;\r\n    Stages public stage;\r\n\r\n    /*\r\n     *  Enums\r\n     */\r\n    enum Stages {\r\n        AuctionDeployed,\r\n        AuctionSetUp,\r\n        AuctionStarted,\r\n        AuctionEnded,\r\n        TradingStarted\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier atStage(Stages _stage) {\r\n        require(stage == _stage);\r\n            // Contract not in expected state\r\n        _;\r\n    }\r\n\r\n    modifier isOwner() {\r\n        require(msg.sender == owner);\r\n            // Only owner is allowed to proceed\r\n        _;\r\n    }\r\n\r\n    modifier isWallet() {\r\n         require(msg.sender == address(pWallet));\r\n            // Only wallet is allowed to proceed\r\n        _;\r\n    }\r\n\r\n    modifier isValidPayload() {\r\n        emit logPayload(msg.data, msg.data.length);\r\n        require(msg.data.length == 4 || msg.data.length == 36, \"No valid payload\");\r\n        _;\r\n    }\r\n\r\n    modifier timedTransitions() {\r\n        if (stage == Stages.AuctionStarted && calcTokenPrice() <= calcStopPrice())\r\n            finalizeAuction();\r\n        if (stage == Stages.AuctionEnded && now > endTime + WAITING_PERIOD)\r\n            stage = Stages.TradingStarted;\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Contract constructor function sets owner.\r\n    /// @param _pWallet KittieFight promissory wallet.\r\n    /// @param _ceiling Auction ceiling.\r\n    /// @param _priceFactor Auction price factor.\r\n    constructor(address _pWallet, uint _ceiling, uint _priceFactor)\r\n        public\r\n    {\r\n        if (_pWallet == 0 || _ceiling == 0 || _priceFactor == 0)\r\n            // Arguments are null.\r\n            revert();\r\n        owner = msg.sender;\r\n        PromissoryTokenIns = PromissoryToken(promissoryAddr);\r\n        pWallet = _pWallet;\r\n        ceiling = _ceiling;\r\n        priceFactor = _priceFactor;\r\n        stage = Stages.AuctionDeployed;\r\n    }\r\n\r\n    /// @dev Setup function sets external contracts' addresses.\r\n    /// @param _kittieToken  token address.\r\n    function setup(address _kittieToken)\r\n        public\r\n        isOwner\r\n        atStage(Stages.AuctionDeployed)\r\n    {\r\n        if (_kittieToken == 0)\r\n            // Argument is null.\r\n            revert();\r\n        KittieFightToken = Token(_kittieToken);\r\n        // Validate token balance\r\n        if (KittieFightToken.balanceOf(this) != MAX_TOKENS_SOLD)\r\n            revert();\r\n        stage = Stages.AuctionSetUp;\r\n    }\r\n\r\n    /// @dev Starts auction and sets startBlock.\r\n    function startAuction()\r\n        public\r\n        isOwner\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        stage = Stages.AuctionStarted;\r\n        startBlock = block.number;\r\n    }\r\n\r\n    /// @dev Changes auction ceiling and start price factor before auction is started.\r\n    /// @param _ceiling Updated auction ceiling.\r\n    /// @param _priceFactor Updated start price factor.\r\n    function changeSettings(uint _ceiling, uint _priceFactor)\r\n        public\r\n        isWallet\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        ceiling = _ceiling;\r\n        priceFactor = _priceFactor;\r\n    }\r\n\r\n    /// @dev Calculates current token price.\r\n    /// @return Returns token price.\r\n    function calcCurrentTokenPrice()\r\n        public\r\n        timedTransitions\r\n        returns (uint)\r\n    {\r\n        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)\r\n            return finalPrice;\r\n        return calcTokenPrice();\r\n    }\r\n\r\n    /// @dev Returns correct stage, even if a function with timedTransitions modifier has not yet been called yet.\r\n    /// @return Returns current auction stage.\r\n    function updateStage()\r\n        public\r\n        timedTransitions\r\n        returns (Stages)\r\n    {\r\n        return stage;\r\n    }\r\n\r\n    /// @dev Allows to send a bid to the auction.\r\n    /// @param receiver Bid will be assigned to this address if set.\r\n    function bid(address receiver)\r\n        public\r\n        payable\r\n        //isValidPayload\r\n        timedTransitions\r\n        atStage(Stages.AuctionStarted)\r\n        returns (uint amount)\r\n    {\r\n        // If a bid is done on behalf of a user via ShapeShift, the receiver address is set.\r\n        if (receiver == 0)\r\n            receiver = msg.sender;\r\n        amount = msg.value;\r\n        // Prevent that more than 90% of tokens are sold. Only relevant if cap not reached.\r\n        uint maxWei = (MAX_TOKENS_SOLD / 10**18) * calcTokenPrice() - totalReceived;\r\n        uint maxWeiBasedOnTotalReceived = ceiling - totalReceived;\r\n        if (maxWeiBasedOnTotalReceived < maxWei)\r\n            maxWei = maxWeiBasedOnTotalReceived;\r\n        // Only invest maximum possible amount.\r\n        if (amount > maxWei) {\r\n            amount = maxWei;\r\n            // Send change back to receiver address. In case of a ShapeShift bid the user receives the change back directly.\r\n            if (!receiver.send(msg.value - amount))\r\n                // Sending failed\r\n                revert();\r\n        }\r\n        // Forward funding to ether pWallet\r\n        if (amount == 0 || !address(pWallet).send(amount))\r\n            // No amount sent or sending failed\r\n            revert();\r\n        bids[receiver] += amount;\r\n        totalReceived += amount;\r\n        if (maxWei == amount)\r\n            // When maxWei is equal to the big amount the auction is ended and finalizeAuction is triggered.\r\n            finalizeAuction();\r\n        emit BidSubmission(receiver, amount);\r\n    }\r\n\r\n    /// @dev Claims tokens for bidder after auction.\r\n    /// @param receiver Tokens will be assigned to this address if set.\r\n    function claimTokens(address receiver)\r\n        public\r\n        isValidPayload\r\n        timedTransitions\r\n        atStage(Stages.TradingStarted)\r\n    {\r\n        if (receiver == 0)\r\n            receiver = msg.sender;\r\n        uint tokenCount = bids[receiver] * 10**18 / finalPrice;\r\n        bids[receiver] = 0;\r\n        KittieFightToken.transfer(receiver, tokenCount);\r\n    }\r\n\r\n    /// @dev Calculates stop price.\r\n    /// @return Returns stop price.\r\n    function calcStopPrice()\r\n        view\r\n        public\r\n        returns (uint)\r\n    {\r\n        return totalReceived * 10**18 / MAX_TOKENS_SOLD + 1;\r\n    }\r\n\r\n    /// @dev Calculates token price.\r\n    /// @return Returns token price.\r\n    function calcTokenPrice()\r\n        view\r\n        public\r\n        returns (uint)\r\n    {\r\n        return priceFactor * 10**18 / (block.number - startBlock + 7500) + 1;\r\n    }\r\n\r\n    /*\r\n     *  Private functions\r\n     */\r\n    function finalizeAuction()\r\n        private\r\n    {\r\n        stage = Stages.AuctionEnded;\r\n\r\n        if (totalReceived == ceiling)\r\n            finalPrice = calcTokenPrice();\r\n        else\r\n            finalPrice = calcStopPrice();\r\n\r\n        endTime = now;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract Dutchwrapper is DutchAuction {\r\n\r\n\r\n    uint constant public MAX_TOKEN_REFERRAL = 2000000 * 10**18; // One Million and eight hundred  thousand\r\n\r\n    uint public claimedTokenReferral = 0; // 800,000 : eigth hundred thousand limit\r\n    uint public totalEthEarnedByPartners = 0; // Partners earning\r\n\r\n\r\n    // 2,000,000 :  2 million: total MAX_TOKEN_REFERRAL\r\n    uint constant public TOTAL_BONUS_TOKEN = 2000000 * 10**18;\r\n\r\n    uint public softCap;\r\n    bool public softcapReached = false;\r\n\r\n\r\n    uint constant public Partners = 1; // Distinction between promotion groups, partnership for eth\r\n    uint constant public Referrals = 2; // Distinction between promotion groups, referral campaign for tokens\r\n    \r\n\r\n    uint constant public ONE = 1; // NUMBER 1\r\n\r\n    // various reward levels\r\n    uint constant public thirty = 30 * 10**18; // thirty tokens awarded to bidder when earned\r\n    uint constant public twoHundred = 200 * 10**18; // two hundred tokens awarded to bidder when earned\r\n    uint constant public sixHundred = 600 * 10**18; // six hundred tokens awarded to bidder when earned\r\n\r\n    uint constant public oneHundred = 100 * 10**18; // one hundred tokens awarded to refferer when earned\r\n    uint constant public fiveHundred = 500 * 10**18; // five hundred tokens awarded to refferer when earned\r\n    uint constant public oneThousand = 1000 * 10**18; // one thousand tokens awarded to refferer when earned\r\n    uint public residualToken; // variable tracking number of tokens left at near complete token exhaustion\r\n\r\n    mapping (address => uint) public SuperDAOTokens; // amount of bonus Superdao Tokens earned per bidder\r\n    //for participation on auction based on eth bid\r\n\r\n    struct PartnerForEth {\r\n        bytes4 hash; // unique hash for partner\r\n        address addr; //address for partner\r\n        uint totalReferrals; // Number of reffered parties\r\n        uint totalContribution; // total contribution in ETH by reffered parties\r\n        uint[] individualContribution; // individual contribution list, number of eth per contributor\r\n        uint percentage; // percentage share for partner of each referral\r\n        uint EthEarned; // up to date total amount earned\r\n    }\r\n\r\n\taddress [] public PartnersList; // list of partners\r\n\r\n    //for token referal campaign\r\n    struct tokenForReferral {\r\n        bytes4 hash; // hash of this campaign\r\n        address addr; // address of this user\r\n        uint totalReferrals; // total amount of participators refered\r\n        uint totalTokensEarned; // total tokens earned based on referals\r\n        mapping(uint => uint) tokenAmountPerReferred;// Amount of tokens earned for each participator referred\r\n    }\r\n\r\n     address [] public TokenReferalList; // list of partners\r\n\r\n     bytes4 [20] public topAddrHashes; // display top 20 refferers address hashes\r\n     uint [20] public topReferredNum; // display number of bidders reffered by top 20 refferers\r\n\r\n    event topAddrHashesUpdate(bytes4 [20] topAddrHashes); // log display top 20 refferers address hashes ( see function orderTop20 )\r\n    event topNumbersUpdate(uint[20] topNumArray);  // log number of bidders reffered by top 20 refferers (( see function orderTop20 )\r\n    bool public bidderBonus = true; // bolean bonus indicator for both refferers and bidders\r\n\r\n    mapping(bytes4 => PartnerForEth )  public MarketingPartners;\r\n    mapping(bytes4 => tokenForReferral)  public TokenReferrals;\r\n    mapping(address => bool ) public Admins;\r\n\r\n    // statistics on the number of bidders\r\n    struct bidder {\r\n        address addr;\r\n        uint amount;\r\n    }\r\n\r\n    bidder [] public CurrentBidders; // document current bidders\r\n\r\n\r\n    event PartnerReferral(bytes4 _partnerHash,address _addr, uint _amount);//fired after marketing partner referral happens\r\n    event TokenReferral(bytes4 _campaignHash,address _addr, uint _amount);// fired when token referral happens\r\n    event BidEvent(bytes4 _hash, address _addr, uint _amount); //fired when a bid happens\r\n    event SetupReferal(uint _type); //fired when a referal campaign is setup\r\n    event ReferalSignup(bytes4 _Hash, address _addr); // fired when a token promoter signs up\r\n    event ClaimtokenBonus(bytes4 _Hash, address _addr, bool success); //fired when a person claims earned tokens\r\n\r\n\r\n\r\n    // check when dutch auction is ended and trading has started\r\n    modifier tradingstarted(){\r\n        require(stage == Stages.TradingStarted);\r\n        _;\r\n    }\r\n\r\n    // uint constant public MAX_TOKEN_REFERRAL = 1800000 * 10**18; // 1 800,000 : one million and eight hundred  thousand    \r\n    // uint public claimedTokenReferral = 0; // 800,000 : eigth hundred thousand limit\r\n\r\n    // safety check for requiring limits at maximum amount allocated for referrals\r\n    modifier ReferalCampaignLimit() {\r\n        require (claimedTokenReferral < MAX_TOKEN_REFERRAL);\r\n        _;\r\n    }\r\n\r\n\r\n    constructor  (address _pWallet, uint _ceiling, uint _priceFactor, uint _softCap)\r\n        DutchAuction(_pWallet, _ceiling, _priceFactor)  public {\r\n\r\n            softCap = _softCap;\r\n    }\r\n\r\n    function checksoftCAP() internal {\r\n        //require (softcapReached == false);\r\n        if( totalReceived >= softCap ) {\r\n            softcapReached = true;\r\n        }\r\n    }\r\n\r\n    // creates either a marketing partnering for eth or a twitter retweet campaign. referal marketing in\r\n    // exchange for tokens are self generated in referal signup function\r\n\r\n    function setupReferal(address _addr, uint _percentage)\r\n        public\r\n        isOwner\r\n        returns (string successmessage) \r\n    {\r\n\r\n            bytes4 tempHash = bytes4(keccak256(abi.encodePacked(_addr, msg.sender)));\r\n\r\n            MarketingPartners[tempHash].hash = tempHash;\r\n            MarketingPartners[tempHash].addr = _addr;\r\n            MarketingPartners[tempHash].percentage = _percentage;\r\n\r\n            InternalReferalSignupByhash(tempHash, _addr);\r\n\r\n    \t\temit SetupReferal(1); // Marketin partners\r\n            return \"partner signed up\";\r\n    }\r\n\r\n    // generated hash on behalf of partners earning cash and tokensby tokens. referalcampaignlimmit modifier\r\n    //removed because partner signup it will fail if referal tokens are used up\r\n    function InternalReferalSignup(address _addr) internal returns (bytes4 referalhash) {\r\n        \r\n        bytes4 tempHash = bytes4(keccak256(abi.encodePacked(_addr)));\r\n        TokenReferrals[tempHash].addr = msg.sender;\r\n        TokenReferrals[tempHash].hash = tempHash;\r\n        referalhash = tempHash;\r\n        emit ReferalSignup(tempHash, _addr);\r\n    }\r\n\r\n    //\r\n    function InternalReferalSignupByhash(bytes4 _hash, address _addr) internal returns (bytes4 referalhash) {\r\n        TokenReferrals[_hash].addr = _addr;\r\n        TokenReferrals[_hash].hash = _hash;\r\n        referalhash = _hash;\r\n        emit ReferalSignup(_hash, _addr);\r\n    }\r\n\r\n\r\n    // public self generated hash by token earning promoters\r\n    function referralSignup() public ReferalCampaignLimit returns (bytes4 referalhash) {\r\n        bytes4 tempHash = bytes4(keccak256(abi.encodePacked(msg.sender)));\r\n        require (tempHash != TokenReferrals[tempHash].hash); //check prevent overwriting\r\n        TokenReferrals[tempHash].addr = msg.sender;\r\n        TokenReferrals[tempHash].hash = tempHash;\r\n        referalhash = tempHash;\r\n        emit ReferalSignup(tempHash, msg.sender);\r\n    }\r\n\r\n\r\n    // Biding using a referral hash\r\n    function bidReferral(address _receiver, bytes4 _hash) public payable returns (uint) {\r\n\r\n        uint bidAmount = msg.value;\r\n        uint256 promissorytokenLastPrice = PromissoryTokenIns.lastPrice();\r\n\r\n\r\n        if(bidAmount > ceiling - totalReceived) {\r\n            bidAmount = ceiling - totalReceived;\r\n        }\r\n\r\n        require( bid(_receiver) == bidAmount );\r\n\r\n\t\tuint amount = msg.value;\r\n\t\tbidder memory _bidder;\r\n\t\t_bidder.addr = _receiver;\r\n\t\t_bidder.amount = amount;\r\n        SuperDAOTokens[msg.sender] += amount/promissorytokenLastPrice;\r\n\t\tCurrentBidders.push(_bidder);\r\n        checksoftCAP();\r\n\r\n        emit BidEvent(_hash, msg.sender, amount);\r\n\r\n        if (_hash == MarketingPartners[_hash].hash) {\r\n\r\n            MarketingPartners[_hash].totalReferrals += ONE;\r\n            MarketingPartners[_hash].totalContribution += amount;\r\n            MarketingPartners[_hash].individualContribution.push(amount);\r\n            MarketingPartners[_hash].EthEarned += referalPercentage(amount, MarketingPartners[_hash].percentage);\r\n\r\n            totalEthEarnedByPartners += referalPercentage(amount, MarketingPartners[_hash].percentage);\r\n\r\n            if( (msg.value >= 1 ether) && (msg.value <= 3 ether) && (bidderBonus == true)) {\r\n             if(bonusChecker(oneHundred, thirty) == false){\r\n                    discontinueBonus(oneHundred, thirty);\r\n                    return;\r\n                    }\r\n              TokenReferrals[_hash].totalReferrals += ONE;\r\n              orderTop20(TokenReferrals[_hash].totalReferrals, _hash);\r\n              TokenReferrals[_hash].tokenAmountPerReferred[amount] = oneHundred;\r\n              TokenReferrals[_hash].totalTokensEarned += oneHundred;\r\n              bidderEarnings (thirty) == true ? claimedTokenReferral = oneHundred + thirty : claimedTokenReferral += oneHundred;\r\n              emit TokenReferral(_hash ,msg.sender, amount);\r\n\r\n\r\n              } else if ((msg.value > 3 ether)&&(msg.value <= 6 ether) && (bidderBonus == true)) {\r\n                   if(bonusChecker(fiveHundred, twoHundred) == false){\r\n                    discontinueBonus(fiveHundred, twoHundred);\r\n                    return;\r\n                    }\r\n                  TokenReferrals[_hash].totalReferrals += ONE;\r\n                  orderTop20(TokenReferrals[_hash].totalReferrals, _hash);\r\n                  TokenReferrals[_hash].tokenAmountPerReferred[amount] = fiveHundred;\r\n                  TokenReferrals[_hash].totalTokensEarned += fiveHundred;\r\n                  bidderEarnings (twoHundred) == true ? claimedTokenReferral = fiveHundred + twoHundred : claimedTokenReferral += fiveHundred;\r\n                  emit TokenReferral(_hash ,msg.sender, amount);\r\n\r\n\r\n                  } else if ((msg.value > 6 ether) && (bidderBonus == true)) {\r\n                    if(bonusChecker(oneThousand, sixHundred) == false){\r\n                    discontinueBonus(oneThousand, sixHundred);\r\n                    return;\r\n                    }\r\n                    TokenReferrals[_hash].totalReferrals += ONE;\r\n                    orderTop20(TokenReferrals[_hash].totalReferrals, _hash);\r\n                    TokenReferrals[_hash].tokenAmountPerReferred[amount] = oneThousand;\r\n                    TokenReferrals[_hash].totalTokensEarned += oneThousand;\r\n                    bidderEarnings (sixHundred) == true ? claimedTokenReferral = oneThousand + sixHundred : claimedTokenReferral += oneThousand;\r\n                    emit TokenReferral(_hash, msg.sender, amount);\r\n\r\n                  }\r\n\r\n            emit PartnerReferral(_hash, MarketingPartners[_hash].addr, amount);\r\n\r\n            return Partners;\r\n\r\n          } else if (_hash == TokenReferrals[_hash].hash){\r\n\r\n        \t\t\tif( (msg.value >= 1 ether) && (msg.value <= 3 ether) && (bidderBonus == true) ) {\r\n        \t\t\t    if(bonusChecker(oneHundred, thirty) == false){\r\n                            discontinueBonus(oneHundred, thirty);\r\n                                return;\r\n                            }\r\n                            TokenReferrals[_hash].totalReferrals += ONE;\r\n                            orderTop20(TokenReferrals[_hash].totalReferrals, _hash);\r\n            \t\t\t\tTokenReferrals[_hash].tokenAmountPerReferred[amount] = oneHundred;\r\n            \t\t\t\tTokenReferrals[_hash].totalTokensEarned += oneHundred;\r\n                            bidderEarnings (thirty) == true ? claimedTokenReferral = oneHundred + thirty : claimedTokenReferral += oneHundred;\r\n            \t\t\t\temit TokenReferral(_hash ,msg.sender, amount);\r\n            \t\t\t\treturn Referrals;\r\n\r\n        \t\t\t\t} else if ((msg.value > 3 ether)&&(msg.value <= 6 ether) && (bidderBonus == true)) {\r\n        \t\t\t\t    if(bonusChecker(fiveHundred, twoHundred) == false){\r\n                                discontinueBonus(fiveHundred, twoHundred);\r\n                                return;\r\n                                }\r\n                                TokenReferrals[_hash].totalReferrals += ONE;\r\n                                orderTop20(TokenReferrals[_hash].totalReferrals, _hash);\r\n        \t\t\t\t\t\tTokenReferrals[_hash].tokenAmountPerReferred[amount] = fiveHundred;\r\n        \t\t\t\t\t\tTokenReferrals[_hash].totalTokensEarned += fiveHundred;\r\n                                bidderEarnings (twoHundred) == true ? claimedTokenReferral = fiveHundred + twoHundred : claimedTokenReferral += fiveHundred;\r\n        \t\t\t\t\t\temit TokenReferral(_hash ,msg.sender, amount);\r\n        \t\t\t\t\t\treturn Referrals;\r\n\r\n        \t\t\t\t\t\t} else if ((msg.value > 6 ether) && (bidderBonus == true)) {\r\n        \t\t\t\t\t\t    if(bonusChecker(oneThousand, sixHundred) == false){\r\n                                     discontinueBonus(oneThousand, sixHundred);\r\n                                     return;\r\n                                    }\r\n                                    TokenReferrals[_hash].totalReferrals += ONE;\r\n                                    orderTop20(TokenReferrals[_hash].totalReferrals, _hash);\r\n        \t\t\t\t\t\t\tTokenReferrals[_hash].tokenAmountPerReferred[amount] = oneThousand;\r\n        \t\t\t\t\t\t\tTokenReferrals[_hash].totalTokensEarned += oneThousand;\r\n        \t\t\t\t\t\t\tbidderEarnings (sixHundred) == true ? claimedTokenReferral = oneThousand + sixHundred : claimedTokenReferral += oneThousand;\r\n        \t\t\t\t\t\t\temit TokenReferral(_hash, msg.sender, amount);\r\n        \t\t\t\t\t\t\treturn Referrals;\r\n        \t\t\t\t\t\t}\r\n                        }\r\n    \r\n    }\r\n\r\n\r\n\tfunction referalPercentage(uint _amount, uint _percent)\r\n\t    internal\r\n\t    pure\r\n\t    returns (uint) {\r\n            return SafeMath.mul( SafeMath.div( SafeMath.sub(_amount, _amount%100), 100 ), _percent );\r\n\t}\r\n\r\n\r\n    function claimtokenBonus () public returns(bool success)  {\r\n\r\n        bytes4 _personalHash = bytes4(keccak256(abi.encodePacked(msg.sender)));\r\n        \r\n        if ((_personalHash == TokenReferrals[_personalHash].hash) \r\n                && (TokenReferrals[_personalHash].totalTokensEarned > 0)) {\r\n\r\n            uint TokensToTransfer1 = TokenReferrals[_personalHash].totalTokensEarned;\r\n            TokenReferrals[_personalHash].totalTokensEarned = 0;\r\n            KittieFightToken.transfer(TokenReferrals[_personalHash].addr , TokensToTransfer1);\r\n            emit ClaimtokenBonus(_personalHash, msg.sender, true);\r\n         \r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n       }\r\n    }\r\n\r\n\r\n    function claimCampaignTokenBonus(bytes4 _campaignHash) public returns(bool success)  {\r\n        \r\n        bytes4 _marketingCampaignHash = bytes4(keccak256(abi.encodePacked(msg.sender, owner)));\r\n\r\n        if ((_marketingCampaignHash == TokenReferrals[_campaignHash].hash) \r\n                && (TokenReferrals[_campaignHash].totalTokensEarned > 0)) {\r\n\r\n            uint TokensToTransfer1 = TokenReferrals[_campaignHash].totalTokensEarned;\r\n            TokenReferrals[_campaignHash].totalTokensEarned = 0;\r\n            KittieFightToken.transfer(TokenReferrals[_campaignHash].addr , TokensToTransfer1);\r\n            emit ClaimtokenBonus(_campaignHash, msg.sender, true);\r\n         \r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n       }\r\n    }\r\n    \r\n\r\n    /*\r\n     *  Admin transfers all unsold tokens back to token contract\r\n     */\r\n    function transferUnsoldTokens(uint _unsoldTokens, address _addr)\r\n        public\r\n        isOwner\r\n\r\n     {\r\n\r\n        uint soldTokens = totalReceived * 10**18 / finalPrice;\r\n        uint totalSold = (MAX_TOKENS_SOLD + claimedTokenReferral)  - soldTokens;\r\n\r\n        require (_unsoldTokens < totalSold );\r\n        KittieFightToken.transfer(_addr, _unsoldTokens);\r\n    }\r\n\r\n\r\n    function tokenAmountPerReferred(bytes4 _hash, uint _amount ) public view returns(uint tokenAmount) {\r\n        tokenAmount = TokenReferrals[_hash].tokenAmountPerReferred[_amount];\r\n    }\r\n\r\n    function getCurrentBiddersCount () public view returns(uint biddersCount)  {\r\n        biddersCount = CurrentBidders.length;\r\n    }\r\n\r\n    // helper functions  return msg.senders hash\r\n    function calculatPersonalHash() public view returns (bytes4 _hash) {\r\n        _hash = bytes4(keccak256(abi.encodePacked(msg.sender)));\r\n    }\r\n\r\n    function calculatPersonalHashByAddress(address _addr) public view returns (bytes4 _hash) {\r\n        _hash = bytes4(keccak256(abi.encodePacked(_addr)));\r\n    }\r\n\r\n    function calculateCampaignHash(address _addr) public view returns (bytes4 _hash) {\r\n        _hash = bytes4(keccak256(abi.encodePacked(_addr, msg.sender)));\r\n    }\r\n\r\n    // helper functions ordering top 20 address by number of reffered bidders\r\n    // array of addresses and bidder numbers are logged\r\n    function orderTop20(uint _value, bytes4 _hash) private {\r\n        uint i = 0;\r\n        /** get the index of the current max element **/\r\n        for(i; i < topReferredNum.length; i++) {\r\n            if(topReferredNum[i] < _value) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(i < topReferredNum.length)\r\n        {\r\n            if(topAddrHashes[i]!=_hash)\r\n            {\r\n                /** shift the array of one position (getting rid of the last element) **/\r\n                for(uint j = topReferredNum.length - 1; j > i; j--) {\r\n                    (topReferredNum[j], topAddrHashes[j] ) = (topReferredNum[j - 1],topAddrHashes[j - 1]);\r\n                }\r\n\r\n            \r\n            }\r\n            /** update the new max element **/\r\n            (topReferredNum[i], topAddrHashes[i]) = (_value, _hash);\r\n            emit topAddrHashesUpdate (topAddrHashes);\r\n            emit topNumbersUpdate(topReferredNum);\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    // helper functions returning top 20 leading number of reffered bidders by refferers\r\n    function getTop20Reffered() public view returns (uint [20]){\r\n      return topReferredNum;\r\n    }\r\n\r\n    // helper functions  top 20 refferer addresses\r\n    function getTop20Addr() public view returns (bytes4 [20]){\r\n        return topAddrHashes;\r\n     }\r\n\r\n    // helper functions  return msg.senders address from given hash\r\n    function getAddress (bytes4 _hash) public view returns (address){\r\n        return TokenReferrals[_hash].addr;\r\n    }\r\n\r\n    // helper checking existence of bidder as a token refferer\r\n    // creates a token refferer hash for bidder, if bidder is not already a refferer\r\n    // also allocates  20%, 25% or 40% (30, 200, 600 KTY tokens) discounts to bidder, based on amount bid\r\n    function bidderEarnings (uint _amountEarned) private returns (bool){\r\n\r\n        bytes4 bidderTemphash = calculatPersonalHash();\r\n\r\n        if ( bidderTemphash == TokenReferrals[bidderTemphash].hash){\r\n            TokenReferrals[bidderTemphash].totalTokensEarned += _amountEarned;\r\n            return true;\r\n        }else{\r\n            bytes4 newBidderHash = InternalReferalSignup(msg.sender);\r\n            TokenReferrals[newBidderHash].totalTokensEarned = _amountEarned;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n     // check if both bidder bonus and refferer bonus is avalable\r\n     // return true if bonus is available\r\n     function bonusChecker(uint _tokenRefferralBonus, uint _bidderBonusAmount) public view returns (bool){\r\n      return _tokenRefferralBonus + _bidderBonusAmount + claimedTokenReferral <= MAX_TOKEN_REFERRAL ? true : false;\r\n    }\r\n\r\n    //document actual remaining residual tokens\r\n    //call function to terminate bonus\r\n    function discontinueBonus(uint _tokenRefferralBonus, uint _bidderBonusAmount) private returns (string) {\r\n        residualToken = MAX_TOKEN_REFERRAL - (_tokenRefferralBonus + _bidderBonusAmount + claimedTokenReferral);\r\n        return setBonustoFalse();\r\n    }\r\n\r\n\r\n    // bolean bonus switcher, only called when\r\n    // tokens bonus availability is exhuated\r\n    // terminate bonus\r\n    function setBonustoFalse() private returns (string) {\r\n        require (bidderBonus == true,\"no more bonuses\");\r\n        bidderBonus = false;\r\n        return \"tokens exhausted\";\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"oneHundred\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_hash\",\"type\":\"bytes4\"}],\"name\":\"bidReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS_SOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PartnersList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKEN_REFERRAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promissoryAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"TokenReferrals\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes4\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"totalReferrals\",\"type\":\"uint256\"},{\"name\":\"totalTokensEarned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes4\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokenAmountPerReferred\",\"outputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CurrentBidders\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ceiling\",\"type\":\"uint256\"},{\"name\":\"_priceFactor\",\"type\":\"uint256\"}],\"name\":\"changeSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topAddrHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unsoldTokens\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"transferUnsoldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimedTokenReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthEarnedByPartners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes4\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KittieFightToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittieToken\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"residualToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAITING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_BONUS_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidderBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calculatPersonalHashByAddress\",\"outputs\":[{\"name\":\"_hash\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"twoHundred\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"SuperDAOTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTop20Reffered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[20]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topReferredNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculatPersonalHash\",\"outputs\":[{\"name\":\"_hash\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TokenReferalList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"referralSignup\",\"outputs\":[{\"name\":\"referalhash\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"bid\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenRefferralBonus\",\"type\":\"uint256\"},{\"name\":\"_bidderBonusAmount\",\"type\":\"uint256\"}],\"name\":\"bonusChecker\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calculateCampaignHash\",\"outputs\":[{\"name\":\"_hash\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fiveHundred\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PromissoryTokenIns\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTop20Addr\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4[20]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Partners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calcCurrentTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcStopPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"MarketingPartners\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes4\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"totalReferrals\",\"type\":\"uint256\"},{\"name\":\"totalContribution\",\"type\":\"uint256\"},{\"name\":\"percentage\",\"type\":\"uint256\"},{\"name\":\"EthEarned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimtokenBonus\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setupReferal\",\"outputs\":[{\"name\":\"successmessage\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sixHundred\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_campaignHash\",\"type\":\"bytes4\"}],\"name\":\"claimCampaignTokenBonus\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBiddersCount\",\"outputs\":[{\"name\":\"biddersCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oneThousand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pWallet\",\"type\":\"address\"},{\"name\":\"_ceiling\",\"type\":\"uint256\"},{\"name\":\"_priceFactor\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"topAddrHashes\",\"type\":\"bytes4[20]\"}],\"name\":\"topAddrHashesUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"topNumArray\",\"type\":\"uint256[20]\"}],\"name\":\"topNumbersUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_partnerHash\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"PartnerReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_campaignHash\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BidEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"SetupReferal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_Hash\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"ReferalSignup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_Hash\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"ClaimtokenBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BidSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"_lengt\",\"type\":\"uint256\"}],\"name\":\"logPayload\",\"type\":\"event\"}]","ContractName":"Dutchwrapper","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a8a7ca2f8ec6c713c2a4bc371fa0c2726120afa700000000000000000000000000000000000000000000058bc3433f6ed8780000000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000008df9ed1ff17c0c0000","Library":"","SwarmSource":"bzzr://7909dba94817c553fac41e38d228c22a801b701a173c7364b5ebe3472eb35845"}]}