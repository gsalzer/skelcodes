{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n*\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* Web              - https://255eth.club\r\n* Our partners telegram_channel - https://t.me/invest_to_smartcontract\r\n* EN  Telegram_chat: https://t.me/club_255eth_en\r\n* RU  Telegram_chat: https://t.me/club_255eth_ru\r\n* Email:             mailto:support(at sign)255eth.club\r\n* \r\n*  - GAIN 2,55% PER 24 HOURS (every 5900 blocks)\r\n*  - Life-long payments\r\n*  - The revolutionary reliability\r\n*  - Minimal contribution 0.01 eth\r\n*  - Currency and payment - ETH\r\n*  - Contribution allocation schemes:\r\n*    -- 90% payments\r\n*    -- 5% Referral program (3% first level, 2% second level)\r\n*    -- 5% (4% Marketing, 1% Operating Expenses)\r\n* \r\n*  - Referral will be rewarded\r\n*    -- Your referral will receive 3% of his first investment to deposit.\r\n* \r\n*  - HOW TO GET MORE INCOME?\r\n*    -- Marathon \"The Best Investor\"\r\n*       Current winner becomes common referrer for investors without \r\n*       referrer and get a lump sum of 3% of their deposits. \r\n*       To become winner you must invest more than previous winner.\r\n*       \r\n*       How to check: see bestInvestorInfo in the contract\r\n* \r\n*    -- Marathon \"The Best Promoter\"\r\n*       Current winner becomes common referrer for investors without \r\n*       referrer and get a lump sum of 2% of their deposits. \r\n*       To become winner you must invite more than previous winner.\r\n*\r\n*       How to check: see bestPromouterInfo in the contract\r\n* \r\n*    -- Send advertise tokens with contract method massAdvertiseTransfer or transfer \r\n*       and get 1% from first investments of invited wallets.\r\n*       Advertise tokens free for all but you will pay gas fee for call methods.\r\n*\r\n*   ---About the Project\r\n*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \r\n*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \r\n*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \r\n*  freely accessed online. In order to insure our investors' complete security, full control over the \r\n*  project has been transferred from the organizers to the smart contract: nobody can influence the \r\n*  system's permanent autonomous functioning.\r\n* \r\n* ---How to use:\r\n*  1. Send from ETH wallet to the smart contract address 0x19b369f69bc5bd6aadc4d30c179c8ac5ae6cbae0\r\n*     any amount from 0.01 ETH.\r\n*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \r\n*     of your wallet.\r\n*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're \r\n*      spending too much on GAS). But not early then 24 hours from last time claim or invest.\r\n*  OR\r\n*  3b. For reinvest, you need to first remove the accumulated percentage of charges (by sending 0 ether \r\n*      transaction), and only after that, deposit the amount that you want to reinvest.\r\n*  \r\n* RECOMMENDED GAS LIMIT: 350000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* You can check the payments on the etherscan.io site, in the \"Internal Txns\" tab of your wallet.\r\n*\r\n* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \r\n* have private keys.\r\n* \r\n* Contracts reviewed and approved by pros!\r\n* \r\n* Main contract - Revolution. Scroll down to find it.\r\n*/\r\n\r\n\r\ncontract InvestorsStorage {\r\n  struct investor {\r\n    uint keyIndex;\r\n    uint value;\r\n    uint paymentTime;\r\n    uint refs;\r\n    uint refBonus;\r\n  }\r\n  struct bestAddress {\r\n      uint value;\r\n      address addr;\r\n  }\r\n  struct recordStats {\r\n    uint investors;\r\n    uint invested;\r\n  }\r\n  struct itmap {\r\n    mapping(uint => recordStats) stats;\r\n    mapping(address => investor) data;\r\n    address[] keys;\r\n    bestAddress bestInvestor;\r\n    bestAddress bestPromouter;\r\n  }\r\n  itmap private s;\r\n  \r\n  address private owner;\r\n  \r\n  event LogBestInvestorChanged(address indexed addr, uint when, uint invested);\r\n  event LogBestPromouterChanged(address indexed addr, uint when, uint refs);\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"access denied\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    s.keys.length++;\r\n  }\r\n\r\n  function insert(address addr, uint value) public onlyOwner returns (bool) {\r\n    uint keyIndex = s.data[addr].keyIndex;\r\n    if (keyIndex != 0) return false;\r\n    s.data[addr].value = value;\r\n    keyIndex = s.keys.length++;\r\n    s.data[addr].keyIndex = keyIndex;\r\n    s.keys[keyIndex] = addr;\r\n    updateBestInvestor(addr, s.data[addr].value);\r\n    \r\n    return true;\r\n  }\r\n\r\n  function investorFullInfo(address addr) public view returns(uint, uint, uint, uint, uint) {\r\n    return (\r\n      s.data[addr].keyIndex,\r\n      s.data[addr].value,\r\n      s.data[addr].paymentTime,\r\n      s.data[addr].refs,\r\n      s.data[addr].refBonus\r\n    );\r\n  }\r\n\r\n  function investorBaseInfo(address addr) public view returns(uint, uint, uint, uint) {\r\n    return (\r\n      s.data[addr].value,\r\n      s.data[addr].paymentTime,\r\n      s.data[addr].refs,\r\n      s.data[addr].refBonus\r\n    );\r\n  }\r\n\r\n  function investorShortInfo(address addr) public view returns(uint, uint) {\r\n    return (\r\n      s.data[addr].value,\r\n      s.data[addr].refBonus\r\n    );\r\n  }\r\n\r\n  function getBestInvestor() public view returns(uint, address) {\r\n    return (\r\n      s.bestInvestor.value,\r\n      s.bestInvestor.addr\r\n    );\r\n  }\r\n  \r\n  function getBestPromouter() public view returns(uint, address) {\r\n    return (\r\n      s.bestPromouter.value,\r\n      s.bestPromouter.addr\r\n    );\r\n  }\r\n\r\n  function addRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].refBonus += refBonus;\r\n    return true;\r\n  }\r\n  \r\n  function addRefBonusWithRefs(address addr, uint refBonus) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].refBonus += refBonus;\r\n    s.data[addr].refs++;\r\n    updateBestPromouter(addr, s.data[addr].refs);\r\n    \r\n    return true;\r\n  }\r\n\r\n  function addValue(address addr, uint value) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].value += value;\r\n    updateBestInvestor(addr, s.data[addr].value);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  function updateStats(uint dt, uint invested, uint investors) public {\r\n    s.stats[dt].invested += invested;\r\n    s.stats[dt].investors += investors;\r\n  }\r\n  \r\n  function stats(uint dt) public view returns (uint invested, uint investors) {\r\n    return ( \r\n      s.stats[dt].invested,\r\n      s.stats[dt].investors\r\n    );\r\n  }\r\n  \r\n  function updateBestInvestor(address addr, uint investorValue) internal {\r\n    if(investorValue > s.bestInvestor.value){\r\n        s.bestInvestor.value = investorValue;\r\n        s.bestInvestor.addr = addr;\r\n        emit LogBestInvestorChanged(addr, now, s.bestInvestor.value);\r\n    }      \r\n  }\r\n  \r\n  function updateBestPromouter(address addr, uint investorRefs) internal {\r\n    if(investorRefs > s.bestPromouter.value){\r\n        s.bestPromouter.value = investorRefs;\r\n        s.bestPromouter.addr = addr;\r\n        emit LogBestPromouterChanged(addr, now, s.bestPromouter.value);\r\n    }      \r\n  }\r\n\r\n  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].paymentTime = paymentTime;\r\n    return true;\r\n  }\r\n\r\n  function setRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].refBonus = refBonus;\r\n    return true;\r\n  }\r\n\r\n  function keyFromIndex(uint i) public view returns (address) {\r\n    return s.keys[i];\r\n  }\r\n\r\n  function contains(address addr) public view returns (bool) {\r\n    return s.data[addr].keyIndex > 0;\r\n  }\r\n\r\n  function size() public view returns (uint) {\r\n    return s.keys.length;\r\n  }\r\n\r\n  function iterStart() public pure returns (uint) {\r\n    return 1;\r\n  }\r\n}\r\n\r\n\r\ncontract DT {\r\n        struct DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint private constant DAY_IN_SECONDS = 86400;\r\n        uint private constant YEAR_IN_SECONDS = 31536000;\r\n        uint private constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint private constant HOUR_IN_SECONDS = 3600;\r\n        uint private constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 private constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) internal pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) internal pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n        }\r\n        \r\n        function getYear(uint timestamp) internal pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) internal pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) internal pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n}\r\n/**\r\n    ERC20 Token standart for contract advetising\r\n**/\r\ncontract ERC20AdToken {\r\n    using SafeMath for uint;\r\n    using Zero for *;\r\n\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals = 0;\r\n    uint256 public totalSupply;\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n    mapping(address => address) public adtransfers;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor(string _symbol, string _name) public {\r\n        symbol = _symbol;\r\n        name = _name;\r\n        balanceOf[this] = 10000000000;\r\n        totalSupply = 10000000000;\r\n        emit Transfer(address(0), this, 10000000000);\r\n    }\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        //This method do not send anything. It is only notify blockchain that Advertise Token Transfered\r\n        //You can call this method for advertise this contract and invite new investors and gain 1% from each first investments.\r\n        if(!adtransfers[to].notZero()){\r\n            adtransfers[to] = msg.sender;\r\n            emit Transfer(this, to, tokens);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function massAdvertiseTransfer(address[] addresses, uint tokens) public returns (bool success) {\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            if(!adtransfers[addresses[i]].notZero()){\r\n                adtransfers[addresses[i]] = msg.sender;\r\n                emit Transfer(this, addresses[i], tokens);\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n}\r\n\r\ncontract EarnEveryDay_255 is ERC20AdToken, DT {\r\n  using Percent for Percent.percent;\r\n  using SafeMath for uint;\r\n  using Zero for *;\r\n  using ToAddress for *;\r\n  using Convert for *;\r\n\r\n  // investors storage - iterable map;\r\n  InvestorsStorage private m_investors;\r\n  mapping(address => address) private m_referrals;\r\n  bool private m_nextWave;\r\n\r\n  // automatically generates getters\r\n  address public adminAddr;\r\n  uint public waveStartup;\r\n  uint public totalInvestments;\r\n  uint public totalInvested;\r\n  uint public constant minInvesment = 10 finney; // 0.01 eth\r\n  uint public constant maxBalance = 255e5 ether; // 25,500,000 eth\r\n  uint public constant dividendsPeriod = 24 hours; //24 hours\r\n\r\n  // percents \r\n  Percent.percent private m_dividendsPercent = Percent.percent(255, 10000); // 255/10000*100% = 2.55%\r\n  Percent.percent private m_adminPercent = Percent.percent(5, 100); // 5/100*100% = 5%\r\n  Percent.percent private m_refPercent1 = Percent.percent(3, 100); // 3/100*100% = 3%\r\n  Percent.percent private m_refPercent2 = Percent.percent(2, 100); // 2/100*100% = 2%\r\n  Percent.percent private m_adBonus = Percent.percent(1, 100); // 1/100*100% = 1%\r\n\r\n  // more events for easy read from blockchain\r\n  event LogNewInvestor(address indexed addr, uint when, uint value);\r\n  event LogNewInvesment(address indexed addr, uint when, uint value);\r\n  event LogNewReferral(address indexed addr, uint when, uint value);\r\n  event LogPayDividends(address indexed addr, uint when, uint value);\r\n  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\r\n  event LogBalanceChanged(uint when, uint balance);\r\n  event LogNextWave(uint when);\r\n\r\n  modifier balanceChanged {\r\n    _;\r\n    emit LogBalanceChanged(now, address(this).balance);\r\n  }\r\n\r\n  constructor() ERC20AdToken(\"Earn 2.55% Every Day. https://255eth.club\", \r\n                            \"Send your ETH to this contract and earn 2.55% every day for Live-long. https://255eth.club\") public {\r\n    adminAddr = msg.sender;\r\n\r\n    nextWave();\r\n  }\r\n\r\n  function() public payable {\r\n    // investor get him dividends\r\n    if (msg.value == 0) {\r\n      getMyDividends();\r\n      return;\r\n    }\r\n\r\n    // sender do invest\r\n    address a = msg.data.toAddr();\r\n    doInvest(a);\r\n  }\r\n\r\n  function investorsNumber() public view returns(uint) {\r\n    return m_investors.size()-1;\r\n    // -1 because see InvestorsStorage constructor where keys.length++ \r\n  }\r\n\r\n  function balanceETH() public view returns(uint) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function dividendsPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);\r\n  }\r\n\r\n  function adminPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);\r\n  }\r\n\r\n  function referrer1Percent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_refPercent1.num, m_refPercent1.den);\r\n  }\r\n  \r\n  function referrer2Percent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_refPercent2.num, m_refPercent2.den);\r\n  }\r\n  \r\n  function stats(uint date) public view returns(uint invested, uint investors) {\r\n    (invested, investors) = m_investors.stats(date);\r\n  }\r\n\r\n  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refsCount, uint refBonus, bool isReferral) {\r\n    (value, paymentTime, refsCount, refBonus) = m_investors.investorBaseInfo(addr);\r\n    isReferral = m_referrals[addr].notZero();\r\n  }\r\n  \r\n  function bestInvestorInfo() public view returns(uint invested, address addr) {\r\n    (invested, addr) = m_investors.getBestInvestor();\r\n  }\r\n  \r\n  function bestPromouterInfo() public view returns(uint refs, address addr) {\r\n    (refs, addr) = m_investors.getBestPromouter();\r\n  }\r\n  \r\n  function _getMyDividents(bool withoutThrow) private {\r\n    // check investor info\r\n    InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);\r\n    if(investor.keyIndex <= 0){\r\n        if(withoutThrow){\r\n            return;\r\n        }\r\n        \r\n        revert(\"sender is not investor\");\r\n    }\r\n\r\n    // calculate days after latest payment\r\n    uint256 daysAfter = now.sub(investor.paymentTime).div(dividendsPeriod);\r\n    if(daysAfter <= 0){\r\n        if(withoutThrow){\r\n            return;\r\n        }\r\n        \r\n        revert(\"the latest payment was earlier than dividents period\");\r\n    }\r\n    assert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n    // check enough eth \r\n    uint value = m_dividendsPercent.mul(investor.value) * daysAfter;\r\n    if (address(this).balance < value + investor.refBonus) {\r\n      nextWave();\r\n      return;\r\n    }\r\n\r\n    // send dividends and ref bonus\r\n    if (investor.refBonus > 0) {\r\n      assert(m_investors.setRefBonus(msg.sender, 0));\r\n      sendDividendsWithRefBonus(msg.sender, value, investor.refBonus);\r\n    } else {\r\n      sendDividends(msg.sender, value);\r\n    }      \r\n  }\r\n  \r\n  function getMyDividends() public balanceChanged {\r\n    _getMyDividents(false);\r\n  }\r\n\r\n  function doInvest(address ref) public payable balanceChanged {\r\n    require(msg.value >= minInvesment, \"msg.value must be >= minInvesment\");\r\n    require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n\r\n    uint value = msg.value;\r\n    // ref system works only once for sender-referral\r\n    if (!m_referrals[msg.sender].notZero()) {\r\n      // level 1\r\n      if (notZeroNotSender(ref) && m_investors.contains(ref)) {\r\n        uint reward = m_refPercent1.mul(value);\r\n        assert(m_investors.addRefBonusWithRefs(ref, reward)); // referrer 1 bonus\r\n        m_referrals[msg.sender] = ref;\r\n        value = m_dividendsPercent.add(value); // referral bonus\r\n        emit LogNewReferral(msg.sender, now, value); \r\n        // level 2\r\n        if (notZeroNotSender(m_referrals[ref]) && m_investors.contains(m_referrals[ref]) && ref != m_referrals[ref]) { \r\n          reward = m_refPercent2.mul(value);\r\n          assert(m_investors.addRefBonus(m_referrals[ref], reward)); // referrer 2 bonus\r\n        }\r\n      }else{\r\n        InvestorsStorage.bestAddress memory bestInvestor = getMemBestInvestor();\r\n        InvestorsStorage.bestAddress memory bestPromouter = getMemBestPromouter();\r\n        if(notZeroNotSender(bestInvestor.addr)){\r\n          assert(m_investors.addRefBonus(bestInvestor.addr, m_refPercent1.mul(value) )); // referrer 1 bonus\r\n          m_referrals[msg.sender] = bestInvestor.addr;\r\n        }\r\n        if(notZeroNotSender(bestPromouter.addr)){\r\n          assert(m_investors.addRefBonus(bestPromouter.addr, m_refPercent2.mul(value) )); // referrer 2 bonus\r\n          m_referrals[msg.sender] = bestPromouter.addr;\r\n        }\r\n      }\r\n      \r\n      if(notZeroNotSender(adtransfers[msg.sender]) && m_investors.contains(adtransfers[msg.sender])){\r\n          assert(m_investors.addRefBonus(adtransfers[msg.sender], m_adBonus.mul(msg.value) )); // advertise transfer bonud\r\n      }\r\n    }\r\n\r\n    _getMyDividents(true);\r\n\r\n    // commission\r\n    adminAddr.transfer(m_adminPercent.mul(msg.value));\r\n    \r\n    DT.DateTime memory dt = parseTimestamp(now);\r\n    uint today = dt.year.uintToString().strConcat((dt.month<10 ? \"0\":\"\"), dt.month.uintToString(), (dt.day<10 ? \"0\":\"\"), dt.day.uintToString()).stringToUint();\r\n    \r\n    // write to investors storage\r\n    if (m_investors.contains(msg.sender)) {\r\n      assert(m_investors.addValue(msg.sender, value));\r\n      m_investors.updateStats(today, value, 0);\r\n    } else {\r\n      assert(m_investors.insert(msg.sender, value));\r\n      m_investors.updateStats(today, value, 1);\r\n      emit LogNewInvestor(msg.sender, now, value); \r\n    }\r\n    \r\n    assert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n    emit LogNewInvesment(msg.sender, now, value);   \r\n    totalInvestments++;\r\n    totalInvested += msg.value;\r\n  }\r\n\r\n\r\n  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {\r\n    (uint a, uint b, uint c, uint d, uint e) = m_investors.investorFullInfo(addr);\r\n    return InvestorsStorage.investor(a, b, c, d, e);\r\n  }\r\n  \r\n  function getMemBestInvestor() internal view returns(InvestorsStorage.bestAddress) {\r\n    (uint value, address addr) = m_investors.getBestInvestor();\r\n    return InvestorsStorage.bestAddress(value, addr);\r\n  }\r\n  \r\n  function getMemBestPromouter() internal view returns(InvestorsStorage.bestAddress) {\r\n    (uint value, address addr) = m_investors.getBestPromouter();\r\n    return InvestorsStorage.bestAddress(value, addr);\r\n  }\r\n\r\n  function notZeroNotSender(address addr) internal view returns(bool) {\r\n    return addr.notZero() && addr != msg.sender;\r\n  }\r\n\r\n  function sendDividends(address addr, uint value) private {\r\n    if (addr.send(value)) emit LogPayDividends(addr, now, value); \r\n  }\r\n\r\n  function sendDividendsWithRefBonus(address addr, uint value,  uint refBonus) private {\r\n    if (addr.send(value+refBonus)) {\r\n      emit LogPayDividends(addr, now, value);\r\n      emit LogPayReferrerBonus(addr, now, refBonus);\r\n    }\r\n  }\r\n\r\n  function nextWave() private {\r\n    m_investors = new InvestorsStorage();\r\n    totalInvestments = 0;\r\n    waveStartup = now;\r\n    m_nextWave = false;\r\n    emit LogNextWave(now);\r\n  }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) return 0;\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n}\r\n\r\nlibrary Zero {\r\n  function requireNotZero(uint a) internal pure {\r\n    require(a != 0, \"require not zero\");\r\n  }\r\n\r\n  function requireNotZero(address addr) internal pure {\r\n    require(addr != address(0), \"require not zero address\");\r\n  }\r\n\r\n  function notZero(address addr) internal pure returns(bool) {\r\n    return !(addr == address(0));\r\n  }\r\n\r\n  function isZero(address addr) internal pure returns(bool) {\r\n    return addr == address(0);\r\n  }\r\n}\r\n\r\nlibrary ToAddress {\r\n  function toAddr(uint source) internal pure returns(address) {\r\n    return address(source);\r\n  }\r\n\r\n  function toAddr(bytes source) internal pure returns(address addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n}\r\n\r\nlibrary Convert {\r\n    function stringToUint(string s) internal pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint i = 0; i < b.length; i++) { // c = b[i] was not needed\r\n            if (b[i] >= 48 && b[i] <= 57) {\r\n                result = result * 10 + (uint(b[i]) - 48); // bytes and int are not compatible with the operator -.\r\n            }\r\n        }\r\n        return result; // this was missing\r\n    }\r\n    \r\n    function uintToString(uint v) internal pure returns (string) {\r\n        uint maxlength = 100;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n            uint remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = byte(48 + remainder);\r\n        }\r\n        bytes memory s = new bytes(i); // i + 1 is inefficient\r\n        for (uint j = 0; j < i; j++) {\r\n            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\r\n        }\r\n        string memory str = string(s);  // memory isn't implicitly convertible to storage\r\n        return str; // this was missing\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n    \r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"massAdvertiseTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestInvestorInfo\",\"outputs\":[{\"name\":\"invested\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestPromouterInfo\",\"outputs\":[{\"name\":\"refs\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"adtransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrer1Percent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrer2Percent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"stats\",\"outputs\":[{\"name\":\"invested\",\"type\":\"uint256\"},{\"name\":\"investors\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"refsCount\",\"type\":\"uint256\"},{\"name\":\"refBonus\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvesment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPayReferrerBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNextWave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"EarnEveryDay_255","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1403b0aa8905e3172f1710a797cae5bdae7912a2eae8f18a55a18828f14fb273"}]}