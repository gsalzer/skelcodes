{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* \r\n* Web              - https://333eth.io\r\n* \r\n* Twitter          - https://twitter.com/333eth_io\r\n* \r\n* Telegram_channel - https://t.me/Ethereum333\r\n* \r\n* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\r\n* \r\n* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\r\n* \r\n* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\r\n* \r\n* Email:             mailto:support(at sign)333eth.io\r\n* \r\n* \r\n* \r\n* When the timer reaches zero then latest bettor takes the bank. Each bet restart a timer again.\r\n* \r\n* Bet 0.01 ETH - if balance < 100 ETH\r\n* Bet 0.02 ETH - if 100 ETH <= balance <= 200 ETH\r\n* Bet 0.03 ETH - if 200 ETH < balance\r\n* \r\n* The timer turns on for 5 minutes always. \r\n*    \r\n* You need to send such bet`s amounts. If more was sent, then contract will return the difference to the wallet. For example, sending 0.03 ETH system will perceive as a contribution to 0.01 ETH and difference 0.02\r\n* \r\n* The game does not have a fraudulent Ponzi scheme. No fraudulent referral programs.\r\n* \r\n* In the contract of the game realized the refusal of ownership. It is impossible to stop the flow of bets. Bet from smart contracts is prohibited.\r\n* \r\n* Eth distribution:\r\n* 50% paid to the winner.\r\n* 33% is transferred to the next level of the game with the same rules and so on.\r\n* 17% commission.\r\n* \r\n* RECOMMENDED GAS LIMIT: 150000\r\n* \r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n*/\r\n\r\n\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  \r\n  // storage\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n\r\n  function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n    return Percent.percent(p.num, p.den);\r\n  }\r\n\r\n  // memory \r\n  function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function msub(percent memory p, uint a) internal pure returns (uint) {\r\n    uint b = mmul(p, a);\r\n    if (b >= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function madd(percent memory p, uint a) internal pure returns (uint) {\r\n    return a + mmul(p, a);\r\n  }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n  enum AccessRank { None, PayIn, Manager, Full }\r\n  mapping(address => AccessRank) public admins;\r\n  modifier onlyAdmin(AccessRank  r) {\r\n    require(\r\n      admins[msg.sender] == r || admins[msg.sender] == AccessRank.Full,\r\n      \"access denied\"\r\n    );\r\n    _;\r\n  }\r\n  event LogProvideAccess(address indexed whom, AccessRank rank, uint when);\r\n\r\n  constructor() public {\r\n    admins[msg.sender] = AccessRank.Full;\r\n    emit LogProvideAccess(msg.sender, AccessRank.Full, now);\r\n  }\r\n\r\n  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Manager) {\r\n    require(rank <= AccessRank.Manager, \"cannot to give full access rank\");\r\n    if (admins[addr] != rank) {\r\n      admins[addr] = rank;\r\n      emit LogProvideAccess(addr, rank, now);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n\r\nlibrary Timer {\r\n  struct timer {\r\n    uint startup;\r\n    uint duration;\r\n  }\r\n  function start(timer storage t, uint duration) internal {\r\n    t.startup = now;\r\n    t.duration = duration;\r\n  }\r\n\r\n  function timeLeft(timer storage t) internal view returns (uint) {\r\n    if (now >= t.startup + t.duration) {\r\n      return 0;\r\n    }\r\n    return t.startup + t.duration - now;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract LastHero is Accessibility {\r\n  using Percent for Percent.percent;\r\n  using Timer for Timer.timer;\r\n  \r\n  Percent.percent public bankPercent = Percent.percent(50, 100);\r\n  Percent.percent public nextLevelPercent = Percent.percent(33, 100);\r\n  Percent.percent public adminsPercent = Percent.percent(17, 100);\r\n\r\n  bool public isActive;\r\n  uint public nextLevelBankAmount;\r\n  uint private m_bankAmount;\r\n  uint public jackpot;\r\n  uint public level;\r\n  uint public constant betDuration = 5 minutes;\r\n  address public adminsAddress;\r\n  address public bettor;\r\n  Timer.timer public timer;\r\n\r\n  modifier notFromContract() {\r\n    require(msg.sender == tx.origin, \"only externally accounts\");\r\n    _;\r\n\r\n    // we can use 'transfer' for all bettors with it - no thx\r\n  }\r\n\r\n  event LogSendExcessOfEther(address indexed addr, uint excess, uint when);\r\n  event LogNewWinner(address indexed addr, uint indexed level, uint amount, uint when);\r\n  event LogNewLevel(uint indexed level, uint bankAmount, uint when);\r\n  event LogNewBet(address indexed addr, uint indexed amount, uint duration, uint indexed level, uint when);\r\n\r\n\r\n  constructor() public {\r\n    adminsAddress = msg.sender;\r\n    timer.duration = uint(-1); // 2^256 - 1\r\n    nextLevel();\r\n  }\r\n\r\n  function() external payable {\r\n    if (admins[msg.sender] == AccessRank.PayIn) {\r\n      if (level <= 3) {\r\n        increaseJackpot();\r\n      } else {\r\n        increaseBank();\r\n      }\r\n      return ;\r\n    }\r\n\r\n    bet();\r\n  }\r\n\r\n  function timeLeft() external view returns(uint duration) {\r\n    duration = timer.timeLeft();\r\n  }\r\n\r\n  function setAdminsAddress(address addr) external onlyAdmin(AccessRank.Full) {\r\n    require(addr != address(0), \"require not zero address\");\r\n    adminsAddress = addr;\r\n  }\r\n\r\n  function activate() external onlyAdmin(AccessRank.Full) {\r\n    isActive = true;\r\n  }\r\n\r\n  function betAmountAtNow() public view returns(uint amount) {\r\n    uint balance = address(this).balance;\r\n\r\n    // (1) 0.01 ETH - if balance < 100 ETH\r\n    // (2) 0.02 ETH - if 100 ETH <= balance <= 200 ETH\r\n    // (3) 0.03 ETH - if 200 ETH < balance\r\n\r\n    if (balance < 100 ether) {\r\n      amount = 0.01 ether;\r\n    } else if (100 ether <= balance && balance <= 200 ether) {\r\n      amount = 0.02 ether;\r\n    } else {\r\n      amount = 0.03 ether;\r\n    }\r\n  }\r\n  \r\n  function bankAmount() public view returns(uint) {\r\n    if (level <= 3) {\r\n      return jackpot;\r\n    }\r\n    return m_bankAmount;\r\n  }\r\n\r\n  function bet() public payable notFromContract {\r\n    require(isActive, \"game is not active\");\r\n\r\n    if (timer.timeLeft() == 0) {\r\n      uint win = bankAmount();\r\n      if (bettor.send(win)) {\r\n        emit LogNewWinner(bettor, level, win, now);\r\n      }\r\n\r\n      if (level > 3) {\r\n        m_bankAmount = nextLevelBankAmount;\r\n        nextLevelBankAmount = 0;\r\n      }\r\n\r\n      nextLevel();\r\n    }\r\n\r\n    uint betAmount = betAmountAtNow();\r\n    require(msg.value >= betAmount, \"too low msg value\");\r\n    timer.start(betDuration);\r\n    bettor = msg.sender;\r\n\r\n    uint excess = msg.value - betAmount;\r\n    if (excess > 0) {\r\n      if (bettor.send(excess)) {\r\n        emit LogSendExcessOfEther(bettor, excess, now);\r\n      }\r\n    }\r\n \r\n    nextLevelBankAmount += nextLevelPercent.mul(betAmount);\r\n    m_bankAmount += bankPercent.mul(betAmount);\r\n    adminsAddress.send(adminsPercent.mul(betAmount));\r\n\r\n    emit LogNewBet(bettor, betAmount, betDuration, level, now);\r\n  }\r\n\r\n  function increaseJackpot() public payable onlyAdmin(AccessRank.PayIn) {\r\n    require(level <= 3, \"jackpots only on first three levels\");\r\n    jackpot += msg.value / (4 - level); // add for remained levels\r\n  }\r\n\r\n  function increaseBank() public payable onlyAdmin(AccessRank.PayIn) {\r\n    require(level > 3, \"bank amount only above three level\");\r\n    m_bankAmount += msg.value;\r\n    if (jackpot > 0) {\r\n      m_bankAmount += jackpot;\r\n      jackpot = 0;\r\n    }\r\n  }\r\n\r\n  function nextLevel() private {\r\n    level++;\r\n    emit LogNewLevel(level, m_bankAmount, now);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bankPercent\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLeft\",\"outputs\":[{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"level\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"increaseBank\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextLevelPercent\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timer\",\"outputs\":[{\"name\":\"startup\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextLevelBankAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsPercent\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bettor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betAmountAtNow\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"provideAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"excess\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogSendExcessOfEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bankAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogProvideAccess\",\"type\":\"event\"}]","ContractName":"LastHero","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3d424096cc80d0229ac1a90aa6dc279b701ed262b4da2a330ad15ba955b3eb4b"}]}