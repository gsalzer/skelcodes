{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        require(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n    function safeSqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n        require(safeMul(y, y) <= x);\r\n    }\r\n}\r\n\r\ncontract CrossroadsCoin is SafeMath {\r\n    address public owner;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n    uint16 public constant exchangeRate = 10000; // handling fee, 1/10000\r\n\r\n    uint256 public initialRate; // initial ether to CRC rate\r\n    uint256 public minRate; // min ether to CRC rate, minRate should no more than initial rate\r\n\r\n    // rate curve: rate(x) = initialRate - x / k, x represent address(this).balance\r\n    // k should meet minRate = initialRate - destEtherNum / k\r\n    // so k value is destEtherNum / (initialRate - minRate)\r\n    uint256 public destEtherNum; // when contract receive destEtherNum ether, all CRC released\r\n    uint256 public k;\r\n\r\n    // supply curve: totalSupply = initialRate * x - x^2/(2*k);\r\n    // so, while x reach to destEtherNum, the totalSupply = destEtherNum * (initialRate + minRate) / 2\r\n    uint256 public totalSupply = 0; // current supply is 0\r\n\r\n    /* This creates an array with all balances */\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approve(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Exchange(address indexed who, uint256 value); // use ether exchange CRC\r\n\r\n    event Redeem(address indexed who, uint256 value); // use CRC redeem ether\r\n\r\n\r\n    // can accept ether, exchange CRC to msg.sender\r\n    function() public payable {\r\n        require(address(this).balance <= destEtherNum);\r\n        uint256 newSupply = calSupply(address(this).balance);\r\n        uint256 returnCRCNum = SafeMath.safeSub(newSupply, totalSupply);\r\n        totalSupply = newSupply;\r\n        if (msg.sender != owner) {\r\n            uint256 fee = SafeMath.safeDiv(returnCRCNum, exchangeRate);\r\n            balanceOf[owner] = SafeMath.safeAdd(balanceOf[owner],\r\n                fee);\r\n            emit Transfer(msg.sender, owner, fee);\r\n            returnCRCNum = SafeMath.safeSub(returnCRCNum, fee);\r\n        }\r\n        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender],\r\n            returnCRCNum);\r\n        emit Exchange(msg.sender, returnCRCNum);\r\n        emit Transfer(address(0x0), msg.sender, returnCRCNum);\r\n    }\r\n\r\n    // rate curve: rate(x) = initialRate - x / k, x represent address(this).balance\r\n    function calRate() public view returns (uint256){\r\n        uint256 x = address(this).balance;\r\n        return SafeMath.safeSub(initialRate, SafeMath.safeDiv(x, k));\r\n    }\r\n\r\n    // x represent address(this).balance\r\n    // totalSupply = initialRate * x - x^2/(2*k)\r\n    function calSupply(uint256 x) public view returns (uint256){\r\n        uint256 opt1 = SafeMath.safeMul(initialRate, x);\r\n        uint256 opt2 = SafeMath.safeDiv(SafeMath.safeMul(x, x),\r\n            SafeMath.safeMul(2, k));\r\n        return SafeMath.safeSub(opt1, opt2);\r\n    }\r\n\r\n    // because totalSupply = initialRate * x - x^2/(2*k), x represent address(this).balance\r\n    // so, x = initialRate * k - sqrt((initialRate * k)^2 - 2 * k * totalSupply)\r\n    function calEtherNumBySupply(uint256 y) public view returns (uint256){\r\n        uint256 opt1 = SafeMath.safeMul(initialRate, k);\r\n        uint256 sqrtOpt1 = SafeMath.safeMul(opt1, opt1);\r\n        uint256 sqrtOpt2 = SafeMath.safeMul(2, SafeMath.safeMul(k, y));\r\n        uint256 sqrtRes = SafeMath.safeSqrt(SafeMath.safeSub(sqrtOpt1, sqrtOpt2));\r\n        return SafeMath.safeSub(SafeMath.safeMul(initialRate, k), sqrtRes);\r\n    }\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    constructor(uint256 _initialRate, uint256 _minRate, uint256 _destEtherNum) public {\r\n        owner = msg.sender;\r\n        name = \"CrossroadsCoin\";\r\n        symbol = \"CRC\";\r\n        // set exchangeRate\r\n        require(_minRate <= _initialRate);\r\n        require(_destEtherNum > 0);\r\n        initialRate = _initialRate;\r\n        minRate = _minRate;\r\n        destEtherNum = _destEtherNum;\r\n        k = SafeMath.safeDiv(_destEtherNum, SafeMath.safeSub(_initialRate, _minRate));\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value)\r\n    public {\r\n        // Prevent transfer to 0x0 address.\r\n        require(_to != 0x0);\r\n        require(_value > 0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[msg.sender] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        if (_to == address(this)) {\r\n            redeem(_value);\r\n        } else {\r\n            // Add the _value to the recipient\r\n            balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\r\n        }\r\n        // Subtract from the sender\r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);\r\n        // Notify anyone listening that this transfer took place\r\n        emit Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value)\r\n    public returns (bool success) {\r\n        require(_value > 0);\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool success) {\r\n        // Prevent transfer to 0x0 address.\r\n        require(_to != 0x0);\r\n        require(_value > 0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Check allowance\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        if (_to == address(this)) {\r\n            redeem(_value);\r\n        } else {\r\n            // Add the _value to the recipient\r\n            balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\r\n        }\r\n        // Subtract from the sender\r\n        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);\r\n        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function redeem(uint256 _value) private {\r\n        if (msg.sender != owner) {\r\n            uint256 fee = SafeMath.safeDiv(_value, exchangeRate);\r\n            balanceOf[owner] = SafeMath.safeAdd(balanceOf[owner], fee);\r\n            emit Transfer(msg.sender, owner, fee);\r\n            _value = SafeMath.safeSub(_value, fee);\r\n        }\r\n        uint256 newSupply = SafeMath.safeSub(totalSupply, _value);\r\n        require(newSupply >= 0);\r\n        uint256 newEtherNum = calEtherNumBySupply(newSupply);\r\n        uint256 etherBalance = address(this).balance;\r\n        require(newEtherNum <= etherBalance);\r\n        uint256 redeemEtherNum = SafeMath.safeSub(etherBalance, newEtherNum);\r\n        msg.sender.transfer(redeemEtherNum);\r\n        totalSupply = newSupply;\r\n        emit Redeem(msg.sender, redeemEtherNum);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"calEtherNumBySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destEtherNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"calSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"k\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialRate\",\"type\":\"uint256\"},{\"name\":\"_minRate\",\"type\":\"uint256\"},{\"name\":\"_destEtherNum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"}]","ContractName":"CrossroadsCoin","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000004e200000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000d3c21bcecceda1000000","Library":"","SwarmSource":"bzzr://8134005fe3bfd8d3140ef211e49cc4292e7584d6306499a2a9cb0ff89c104b75"}]}