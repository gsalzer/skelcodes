{"status":"1","message":"OK","result":[{"SourceCode":"//  the azimuth polls data store\r\n//  https://azimuth.network\r\n\r\npragma solidity 0.4.24;\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//  Imports\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n// OpenZeppelin's SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// Azimuth's SafeMath8.sol\r\n\r\n/**\r\n * @title SafeMath8\r\n * @dev Math operations for uint8 with safety checks that throw on error\r\n */\r\nlibrary SafeMath8 {\r\n  function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    uint8 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint8 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    uint8 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// Azimuth's SafeMath16.sol\r\n\r\n/**\r\n * @title SafeMath16\r\n * @dev Math operations for uint16 with safety checks that throw on error\r\n */\r\nlibrary SafeMath16 {\r\n  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    uint16 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint16 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    uint16 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// OpenZeppelin's Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//  Polls\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n//  Polls: proposals & votes data contract\r\n//\r\n//    This contract is used for storing all data related to the proposals\r\n//    of the senate (galaxy owners) and their votes on those proposals.\r\n//    It keeps track of votes and uses them to calculate whether a majority\r\n//    is in favor of a proposal.\r\n//\r\n//    Every galaxy can only vote on a proposal exactly once. Votes cannot\r\n//    be changed. If a proposal fails to achieve majority within its\r\n//    duration, it can be restarted after its cooldown period has passed.\r\n//\r\n//    The requirements for a proposal to achieve majority are as follows:\r\n//    - At least 1/4 of the currently active voters (rounded down) must have\r\n//      voted in favor of the proposal,\r\n//    - More than half of the votes cast must be in favor of the proposal,\r\n//      and this can no longer change, either because\r\n//      - the poll duration has passed, or\r\n//      - not enough voters remain to take away the in-favor majority.\r\n//    As soon as these conditions are met, no further interaction with\r\n//    the proposal is possible. Achieving majority is permanent.\r\n//\r\n//    Since data stores are difficult to upgrade, all of the logic unrelated\r\n//    to the voting itself (that is, determining who is eligible to vote)\r\n//    is expected to be implemented by this contract's owner.\r\n//\r\n//    This contract will be owned by the Ecliptic contract.\r\n//\r\ncontract Polls is Ownable\r\n{\r\n  using SafeMath for uint256;\r\n  using SafeMath16 for uint16;\r\n  using SafeMath8 for uint8;\r\n\r\n  //  UpgradePollStarted: a poll on :proposal has opened\r\n  //\r\n  event UpgradePollStarted(address proposal);\r\n\r\n  //  DocumentPollStarted: a poll on :proposal has opened\r\n  //\r\n  event DocumentPollStarted(bytes32 proposal);\r\n\r\n  //  UpgradeMajority: :proposal has achieved majority\r\n  //\r\n  event UpgradeMajority(address proposal);\r\n\r\n  //  DocumentMajority: :proposal has achieved majority\r\n  //\r\n  event DocumentMajority(bytes32 proposal);\r\n\r\n  //  Poll: full poll state\r\n  //\r\n  struct Poll\r\n  {\r\n    //  start: the timestamp at which the poll was started\r\n    //\r\n    uint256 start;\r\n\r\n    //  voted: per galaxy, whether they have voted on this poll\r\n    //\r\n    bool[256] voted;\r\n\r\n    //  yesVotes: amount of votes in favor of the proposal\r\n    //\r\n    uint16 yesVotes;\r\n\r\n    //  noVotes: amount of votes against the proposal\r\n    //\r\n    uint16 noVotes;\r\n\r\n    //  duration: amount of time during which the poll can be voted on\r\n    //\r\n    uint256 duration;\r\n\r\n    //  cooldown: amount of time before the (non-majority) poll can be reopened\r\n    //\r\n    uint256 cooldown;\r\n  }\r\n\r\n  //  pollDuration: duration set for new polls. see also Poll.duration above\r\n  //\r\n  uint256 public pollDuration;\r\n\r\n  //  pollCooldown: cooldown set for new polls. see also Poll.cooldown above\r\n  //\r\n  uint256 public pollCooldown;\r\n\r\n  //  totalVoters: amount of active galaxies\r\n  //\r\n  uint16 public totalVoters;\r\n\r\n  //  upgradeProposals: list of all upgrades ever proposed\r\n  //\r\n  //    this allows clients to discover the existence of polls.\r\n  //    from there, they can do liveness checks on the polls themselves.\r\n  //\r\n  address[] public upgradeProposals;\r\n\r\n  //  upgradePolls: per address, poll held to determine if that address\r\n  //                will become the new ecliptic\r\n  //\r\n  mapping(address => Poll) public upgradePolls;\r\n\r\n  //  upgradeHasAchievedMajority: per address, whether that address\r\n  //                              has ever achieved majority\r\n  //\r\n  //    If we did not store this, we would have to look at old poll data\r\n  //    to see whether or not a proposal has ever achieved majority.\r\n  //    Since the outcome of a poll is calculated based on :totalVoters,\r\n  //    which may not be consistent across time, we need to store outcomes\r\n  //    explicitly instead of re-calculating them. This allows us to always\r\n  //    tell with certainty whether or not a majority was achieved,\r\n  //    regardless of the current :totalVoters.\r\n  //\r\n  mapping(address => bool) public upgradeHasAchievedMajority;\r\n\r\n  //  documentProposals: list of all documents ever proposed\r\n  //\r\n  //    this allows clients to discover the existence of polls.\r\n  //    from there, they can do liveness checks on the polls themselves.\r\n  //\r\n  bytes32[] public documentProposals;\r\n\r\n  //  documentPolls: per hash, poll held to determine if the corresponding\r\n  //                 document is accepted by the galactic senate\r\n  //\r\n  mapping(bytes32 => Poll) public documentPolls;\r\n\r\n  //  documentHasAchievedMajority: per hash, whether that hash has ever\r\n  //                               achieved majority\r\n  //\r\n  //    the note for upgradeHasAchievedMajority above applies here as well\r\n  //\r\n  mapping(bytes32 => bool) public documentHasAchievedMajority;\r\n\r\n  //  documentMajorities: all hashes that have achieved majority\r\n  //\r\n  bytes32[] public documentMajorities;\r\n\r\n  //  constructor(): initial contract configuration\r\n  //\r\n  constructor(uint256 _pollDuration, uint256 _pollCooldown)\r\n    public\r\n  {\r\n    reconfigure(_pollDuration, _pollCooldown);\r\n  }\r\n\r\n  //  reconfigure(): change poll duration and cooldown\r\n  //\r\n  function reconfigure(uint256 _pollDuration, uint256 _pollCooldown)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require( (5 days <= _pollDuration) && (_pollDuration <= 90 days) &&\r\n             (5 days <= _pollCooldown) && (_pollCooldown <= 90 days) );\r\n    pollDuration = _pollDuration;\r\n    pollCooldown = _pollCooldown;\r\n  }\r\n\r\n  //  incrementTotalVoters(): increase the amount of registered voters\r\n  //\r\n  function incrementTotalVoters()\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(totalVoters < 256);\r\n    totalVoters = totalVoters.add(1);\r\n  }\r\n\r\n  //  getAllUpgradeProposals(): return array of all upgrade proposals ever made\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getUpgradeProposals()\r\n    external\r\n    view\r\n    returns (address[] proposals)\r\n  {\r\n    return upgradeProposals;\r\n  }\r\n\r\n  //  getUpgradeProposalCount(): get the number of unique proposed upgrades\r\n  //\r\n  function getUpgradeProposalCount()\r\n    external\r\n    view\r\n    returns (uint256 count)\r\n  {\r\n    return upgradeProposals.length;\r\n  }\r\n\r\n  //  getAllDocumentProposals(): return array of all upgrade proposals ever made\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getDocumentProposals()\r\n    external\r\n    view\r\n    returns (bytes32[] proposals)\r\n  {\r\n    return documentProposals;\r\n  }\r\n\r\n  //  getDocumentProposalCount(): get the number of unique proposed upgrades\r\n  //\r\n  function getDocumentProposalCount()\r\n    external\r\n    view\r\n    returns (uint256 count)\r\n  {\r\n    return documentProposals.length;\r\n  }\r\n\r\n  //  getDocumentMajorities(): return array of all document majorities\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getDocumentMajorities()\r\n    external\r\n    view\r\n    returns (bytes32[] majorities)\r\n  {\r\n    return documentMajorities;\r\n  }\r\n\r\n  //  hasVotedOnUpgradePoll(): returns true if _galaxy has voted\r\n  //                           on the _proposal\r\n  //\r\n  function hasVotedOnUpgradePoll(uint8 _galaxy, address _proposal)\r\n    external\r\n    view\r\n    returns (bool result)\r\n  {\r\n    return upgradePolls[_proposal].voted[_galaxy];\r\n  }\r\n\r\n  //  hasVotedOnDocumentPoll(): returns true if _galaxy has voted\r\n  //                            on the _proposal\r\n  //\r\n  function hasVotedOnDocumentPoll(uint8 _galaxy, bytes32 _proposal)\r\n    external\r\n    view\r\n    returns (bool result)\r\n  {\r\n    return documentPolls[_proposal].voted[_galaxy];\r\n  }\r\n\r\n  //  startUpgradePoll(): open a poll on making _proposal the new ecliptic\r\n  //\r\n  function startUpgradePoll(address _proposal)\r\n    external\r\n    onlyOwner\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!upgradeHasAchievedMajority[_proposal]);\r\n\r\n    Poll storage poll = upgradePolls[_proposal];\r\n\r\n    //  if the proposal is being made for the first time, register it.\r\n    //\r\n    if (0 == poll.start)\r\n    {\r\n      upgradeProposals.push(_proposal);\r\n    }\r\n\r\n    startPoll(poll);\r\n    emit UpgradePollStarted(_proposal);\r\n  }\r\n\r\n  //  startDocumentPoll(): open a poll on accepting the document\r\n  //                       whose hash is _proposal\r\n  //\r\n  function startDocumentPoll(bytes32 _proposal)\r\n    external\r\n    onlyOwner\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!documentHasAchievedMajority[_proposal]);\r\n\r\n    Poll storage poll = documentPolls[_proposal];\r\n\r\n    //  if the proposal is being made for the first time, register it.\r\n    //\r\n    if (0 == poll.start)\r\n    {\r\n      documentProposals.push(_proposal);\r\n    }\r\n\r\n    startPoll(poll);\r\n    emit DocumentPollStarted(_proposal);\r\n  }\r\n\r\n  //  startPoll(): open a new poll, or re-open an old one\r\n  //\r\n  function startPoll(Poll storage _poll)\r\n    internal\r\n  {\r\n    //  check that the poll has cooled down enough to be started again\r\n    //\r\n    //    for completely new polls, the values used will be zero\r\n    //\r\n    require( block.timestamp > ( _poll.start.add(\r\n                                 _poll.duration.add(\r\n                                 _poll.cooldown )) ) );\r\n\r\n    //  set started poll state\r\n    //\r\n    _poll.start = block.timestamp;\r\n    delete _poll.voted;\r\n    _poll.yesVotes = 0;\r\n    _poll.noVotes = 0;\r\n    _poll.duration = pollDuration;\r\n    _poll.cooldown = pollCooldown;\r\n  }\r\n\r\n  //  castUpgradeVote(): as galaxy _as, cast a vote on the _proposal\r\n  //\r\n  //    _vote is true when in favor of the proposal, false otherwise\r\n  //\r\n  function castUpgradeVote(uint8 _as, address _proposal, bool _vote)\r\n    external\r\n    onlyOwner\r\n    returns (bool majority)\r\n  {\r\n    Poll storage poll = upgradePolls[_proposal];\r\n    processVote(poll, _as, _vote);\r\n    return updateUpgradePoll(_proposal);\r\n  }\r\n\r\n  //  castDocumentVote(): as galaxy _as, cast a vote on the _proposal\r\n  //\r\n  //    _vote is true when in favor of the proposal, false otherwise\r\n  //\r\n  function castDocumentVote(uint8 _as, bytes32 _proposal, bool _vote)\r\n    external\r\n    onlyOwner\r\n    returns (bool majority)\r\n  {\r\n    Poll storage poll = documentPolls[_proposal];\r\n    processVote(poll, _as, _vote);\r\n    return updateDocumentPoll(_proposal);\r\n  }\r\n\r\n  //  processVote(): record a vote from _as on the _poll\r\n  //\r\n  function processVote(Poll storage _poll, uint8 _as, bool _vote)\r\n    internal\r\n  {\r\n    //  assist symbolic execution tools\r\n    //\r\n    assert(block.timestamp >= _poll.start);\r\n\r\n    require( //  may only vote once\r\n             //\r\n             !_poll.voted[_as] &&\r\n             //\r\n             //  may only vote when the poll is open\r\n             //\r\n             (block.timestamp < _poll.start.add(_poll.duration)) );\r\n\r\n    //  update poll state to account for the new vote\r\n    //\r\n    _poll.voted[_as] = true;\r\n    if (_vote)\r\n    {\r\n      _poll.yesVotes = _poll.yesVotes.add(1);\r\n    }\r\n    else\r\n    {\r\n      _poll.noVotes = _poll.noVotes.add(1);\r\n    }\r\n  }\r\n\r\n  //  updateUpgradePoll(): check whether the _proposal has achieved\r\n  //                            majority, updating state, sending an event,\r\n  //                            and returning true if it has\r\n  //\r\n  function updateUpgradePoll(address _proposal)\r\n    public\r\n    onlyOwner\r\n    returns (bool majority)\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!upgradeHasAchievedMajority[_proposal]);\r\n\r\n    //  check for majority in the poll\r\n    //\r\n    Poll storage poll = upgradePolls[_proposal];\r\n    majority = checkPollMajority(poll);\r\n\r\n    //  if majority was achieved, update the state and send an event\r\n    //\r\n    if (majority)\r\n    {\r\n      upgradeHasAchievedMajority[_proposal] = true;\r\n      emit UpgradeMajority(_proposal);\r\n    }\r\n    return majority;\r\n  }\r\n\r\n  //  updateDocumentPoll(): check whether the _proposal has achieved majority,\r\n  //                        updating the state and sending an event if it has\r\n  //\r\n  //    this can be called by anyone, because the ecliptic does not\r\n  //    need to be aware of the result\r\n  //\r\n  function updateDocumentPoll(bytes32 _proposal)\r\n    public\r\n    returns (bool majority)\r\n  {\r\n    //  _proposal must not have achieved majority before\r\n    //\r\n    require(!documentHasAchievedMajority[_proposal]);\r\n\r\n    //  check for majority in the poll\r\n    //\r\n    Poll storage poll = documentPolls[_proposal];\r\n    majority = checkPollMajority(poll);\r\n\r\n    //  if majority was achieved, update state and send an event\r\n    //\r\n    if (majority)\r\n    {\r\n      documentHasAchievedMajority[_proposal] = true;\r\n      documentMajorities.push(_proposal);\r\n      emit DocumentMajority(_proposal);\r\n    }\r\n    return majority;\r\n  }\r\n\r\n  //  checkPollMajority(): returns true if the majority is in favor of\r\n  //                       the subject of the poll\r\n  //\r\n  function checkPollMajority(Poll _poll)\r\n    internal\r\n    view\r\n    returns (bool majority)\r\n  {\r\n    return ( //  poll must have at least the minimum required yes-votes\r\n             //\r\n             (_poll.yesVotes >= (totalVoters / 4)) &&\r\n             //\r\n             //  and have a majority...\r\n             //\r\n             (_poll.yesVotes > _poll.noVotes) &&\r\n             //\r\n             //  ...that is indisputable\r\n             //\r\n             ( //  either because the poll has ended\r\n               //\r\n               (block.timestamp > _poll.start.add(_poll.duration)) ||\r\n               //\r\n               //  or there are more yes votes than there can be no votes\r\n               //\r\n               ( _poll.yesVotes > totalVoters.sub(_poll.yesVotes) ) ) );\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"pollDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"bytes32\"}],\"name\":\"updateDocumentPoll\",\"outputs\":[{\"name\":\"majority\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeProposals\",\"outputs\":[{\"name\":\"proposals\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"incrementTotalVoters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDocumentMajorities\",\"outputs\":[{\"name\":\"majorities\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_as\",\"type\":\"uint8\"},{\"name\":\"_proposal\",\"type\":\"address\"},{\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"castUpgradeVote\",\"outputs\":[{\"name\":\"majority\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"updateUpgradePoll\",\"outputs\":[{\"name\":\"majority\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalVoters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_galaxy\",\"type\":\"uint8\"},{\"name\":\"_proposal\",\"type\":\"bytes32\"}],\"name\":\"hasVotedOnDocumentPoll\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_as\",\"type\":\"uint8\"},{\"name\":\"_proposal\",\"type\":\"bytes32\"},{\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"castDocumentVote\",\"outputs\":[{\"name\":\"majority\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"documentHasAchievedMajority\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"bytes32\"}],\"name\":\"startDocumentPoll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradeProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"documentPolls\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"yesVotes\",\"type\":\"uint16\"},{\"name\":\"noVotes\",\"type\":\"uint16\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"documentProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeProposalCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDocumentProposalCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDocumentProposals\",\"outputs\":[{\"name\":\"proposals\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pollCooldown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pollDuration\",\"type\":\"uint256\"},{\"name\":\"_pollCooldown\",\"type\":\"uint256\"}],\"name\":\"reconfigure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgradePolls\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"yesVotes\",\"type\":\"uint16\"},{\"name\":\"noVotes\",\"type\":\"uint16\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgradeHasAchievedMajority\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"startUpgradePoll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"documentMajorities\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_galaxy\",\"type\":\"uint8\"},{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"hasVotedOnUpgradePoll\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pollDuration\",\"type\":\"uint256\"},{\"name\":\"_pollCooldown\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposal\",\"type\":\"address\"}],\"name\":\"UpgradePollStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposal\",\"type\":\"bytes32\"}],\"name\":\"DocumentPollStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposal\",\"type\":\"address\"}],\"name\":\"UpgradeMajority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposal\",\"type\":\"bytes32\"}],\"name\":\"DocumentMajority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Polls","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000278d00","Library":"","SwarmSource":"bzzr://7ddba978801062ab0811349871c0d748d820e1c9e9a8f08d0ca9d0d72e9ff944"}]}