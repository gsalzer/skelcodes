{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether there is code in the target address\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address address to check\r\n   * @return whether there is code in the target address\r\n   */\r\n  function isContract(address addr) internal view returns(bool) {\r\n    uint256 size;\r\n    assembly {\r\n      size: = extcodesize(addr)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeCompare\r\n */\r\nlibrary SafeCompare {\r\n  function stringCompare(string str1, string str2) internal pure returns(bool) {\r\n    return keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract UsdtERC20Basic {\r\n    uint public _totalSupply;\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address who) public constant returns (uint);\r\n    function transfer(address to, uint value) public;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns(uint256);\r\n\r\n  function balanceOf(address who) public view returns(uint256);\r\n\r\n  function transfer(address to, uint256 value) public returns(bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping(address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage _role, address _addr)\r\n  internal {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage _role, address _addr)\r\n  internal {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _addr)\r\n  internal\r\n  view {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _addr)\r\n  internal\r\n  view\r\n  returns(bool) {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * Supports unlimited numbers of roles and addresses.\r\n * See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n * for you to write your own implementation of this interface using Enums or similar.\r\n */\r\ncontract RBAC {\r\n  using Roles\r\n  for Roles.Role;\r\n\r\n  mapping(string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address _operator, string _role)\r\n  public\r\n  view {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address _operator, string _role)\r\n  public\r\n  view\r\n  returns(bool) {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function addRole(address _operator, string _role)\r\n  internal {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function removeRole(address _operator, string _role)\r\n  internal {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string _role) {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract RBACOperator is Ownable, RBAC {\r\n\r\n  /**\r\n   * A constant role name for indicating operator.\r\n   */\r\n  string public constant ROLE_OPERATOR = \"operator\";\r\n\r\n  address public partner;\r\n  /**\r\n   * Event for setPartner logging\r\n   * @param oldPartner the old  Partner\r\n   * @param newPartner the new  Partner\r\n   */\r\n  event SetPartner(address oldPartner, address newPartner);\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner or the Partner.\r\n   */\r\n  modifier onlyOwnerOrPartner() {\r\n    require(msg.sender == owner || msg.sender == partner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the Partner.\r\n   */\r\n  modifier onlyPartner() {\r\n    require(msg.sender == partner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev setPartner, set the  partner address.\r\n   * @param _partner the new  partner address.\r\n   */\r\n  function setPartner(address _partner) public onlyOwner {\r\n    require(_partner != address(0));\r\n    emit SetPartner(partner, _partner);\r\n    partner = _partner;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev removePartner, remove  partner address.\r\n   */\r\n  function removePartner() public onlyOwner {\r\n    delete partner;\r\n  }\r\n\r\n  /**\r\n   * @dev the modifier to operate\r\n   */\r\n  modifier hasOperationPermission() {\r\n    checkRole(msg.sender, ROLE_OPERATOR);\r\n    _;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev add a operator role to an address\r\n   * @param _operator address\r\n   */\r\n  function addOperater(address _operator) public onlyOwnerOrPartner {\r\n    addRole(_operator, ROLE_OPERATOR);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a operator role from an address\r\n   * @param _operator address\r\n   */\r\n  function removeOperater(address _operator) public onlyOwnerOrPartner {\r\n    removeRole(_operator, ROLE_OPERATOR);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns(uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns(bool);\r\n\r\n  function approve(address spender, uint256 value) public returns(bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract UsdtERC20 is UsdtERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n    function transferFrom(address from, address to, uint value) public;\r\n    function approve(address spender, uint value) public;\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract PartnerAuthority is Ownable {\r\n\r\n\r\n  address public partner;\r\n  /**\r\n   * Event for setPartner logging\r\n   * @param oldPartner the old  Partner\r\n   * @param newPartner the new  Partner\r\n   */\r\n  event SetPartner(address oldPartner, address newPartner);\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner or the Partner.\r\n   */\r\n  modifier onlyOwnerOrPartner() {\r\n    require(msg.sender == owner || msg.sender == partner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the Partner.\r\n   */\r\n  modifier onlyPartner() {\r\n    require(msg.sender == partner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev setPartner, set the  partner address.\r\n   */\r\n  function setPartner(address _partner) public onlyOwner {\r\n    require(_partner != address(0));\r\n    emit SetPartner(partner, _partner);\r\n    partner = _partner;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev removePartner, remove  partner address.\r\n   */\r\n  function removePartner() public onlyOwner {\r\n    delete partner;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OrderManageContract\r\n * @dev Order process management contract.\r\n */\r\ncontract OrderManageContract is PartnerAuthority {\r\n  using SafeMath for uint256;\r\n  using SafeCompare for string;\r\n\r\n  /**\r\n   * @dev Status of current business execution contract.\r\n   */\r\n  enum StatusChoices {\r\n    NO_LOAN,\r\n    REPAYMENT_WAITING,\r\n    REPAYMENT_ALL,\r\n    CLOSE_POSITION,\r\n    OVERDUE_STOP\r\n  }\r\n\r\n  string internal constant TOKEN_ETH = \"ETH\";\r\n  string internal constant TOKEN_USDT = \"USDT\";\r\n  address public maker;\r\n  address public taker;\r\n  address internal token20;\r\n\r\n  uint256 public toTime;\r\n  // the amount of the borrower’s final loan.\r\n  uint256 public outLoanSum;\r\n  uint256 public repaymentSum;\r\n  uint256 public lastRepaymentSum;\r\n  string public loanTokenName;\r\n  // Borrower's record of the pledge.\r\n  StatusChoices internal status;\r\n\r\n  // Record the amount of the borrower's offline transfer.\r\n  mapping(address => uint256) public ethAmount;\r\n\r\n  /**\r\n   * Event for takerOrder logging.\r\n   * @param taker address of investor.\r\n   * @param outLoanSum the amount of the borrower’s final loan.\r\n   */\r\n  event TakerOrder(address indexed taker, uint256 outLoanSum);\r\n\r\n\r\n  /**\r\n   * Event for executeOrder logging.\r\n   * @param maker address of borrower.\r\n   * @param lastRepaymentSum current order repayment amount.\r\n   */\r\n  event ExecuteOrder(address indexed maker, uint256 lastRepaymentSum);\r\n\r\n  /**\r\n   * Event for forceCloseOrder logging.\r\n   * @param toTime order repayment due date.\r\n   * @param transferSum balance under current contract.\r\n   */\r\n  event ForceCloseOrder(uint256 indexed toTime, uint256 transferSum);\r\n\r\n  /**\r\n   * Event for WithdrawToken logging.\r\n   * @param taker address of investor.\r\n   * @param refundSum number of tokens withdrawn.\r\n   */\r\n  event WithdrawToken(address indexed taker, uint256 refundSum);\r\n\r\n\r\n\r\n  function() external payable {\r\n    // Record basic information about the borrower's REPAYMENT ETH\r\n    ethAmount[msg.sender] = ethAmount[msg.sender].add(msg.value);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Constructor initial contract configuration parameters\r\n   * @param _loanTokenAddress order type supported by the token.\r\n   */\r\n  constructor(string _loanTokenName, address _loanTokenAddress, address _maker) public {\r\n    require(bytes(_loanTokenName).length > 0 && _maker != address(0));\r\n    if (!_loanTokenName.stringCompare(TOKEN_ETH)) {\r\n      require(_loanTokenAddress != address(0));\r\n      token20 = _loanTokenAddress;\r\n    }\r\n    toTime = now;\r\n    maker = _maker;\r\n    loanTokenName = _loanTokenName;\r\n    status = StatusChoices.NO_LOAN;\r\n  }\r\n\r\n  /**\r\n   * @dev Complete an order combination and issue the loan to the borrower.\r\n   * @param _taker address of investor.\r\n   * @param _toTime order repayment due date.\r\n   * @param _repaymentSum total amount of money that the borrower ultimately needs to return.\r\n   */\r\n  function takerOrder(address _taker, uint32 _toTime, uint256 _repaymentSum) public onlyOwnerOrPartner {\r\n    require(_taker != address(0) && _toTime > 0 && now <= _toTime && _repaymentSum > 0 && status == StatusChoices.NO_LOAN);\r\n    taker = _taker;\r\n    toTime = _toTime;\r\n    repaymentSum = _repaymentSum;\r\n\r\n    // Transfer the token provided by the investor to the borrower's address\r\n    if (loanTokenName.stringCompare(TOKEN_ETH)) {\r\n      require(ethAmount[_taker] > 0 && address(this).balance > 0);\r\n      outLoanSum = address(this).balance;\r\n      maker.transfer(outLoanSum);\r\n    } else {\r\n      require(token20 != address(0) && ERC20(token20).balanceOf(address(this)) > 0);\r\n      outLoanSum = ERC20(token20).balanceOf(address(this));\r\n      require(safeErc20Transfer(maker, outLoanSum));\r\n    }\r\n\r\n    // Update contract business execution status.\r\n    status = StatusChoices.REPAYMENT_WAITING;\r\n\r\n    emit TakerOrder(taker, outLoanSum);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  /**\r\n   * @dev Only the full repayment will execute the contract agreement.\r\n   */\r\n  function executeOrder() public onlyOwnerOrPartner {\r\n    require(now <= toTime && status == StatusChoices.REPAYMENT_WAITING);\r\n    // The borrower pays off the loan and performs two-way operation.\r\n    if (loanTokenName.stringCompare(TOKEN_ETH)) {\r\n      require(ethAmount[maker] >= repaymentSum && address(this).balance >= repaymentSum);\r\n      lastRepaymentSum = address(this).balance;\r\n      taker.transfer(repaymentSum);\r\n    } else {\r\n      require(ERC20(token20).balanceOf(address(this)) >= repaymentSum);\r\n      lastRepaymentSum = ERC20(token20).balanceOf(address(this));\r\n      require(safeErc20Transfer(taker, repaymentSum));\r\n    }\r\n\r\n    PledgeContract(owner)._conclude();\r\n    status = StatusChoices.REPAYMENT_ALL;\r\n    emit ExecuteOrder(maker, lastRepaymentSum);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Close position or due repayment operation.\r\n   */\r\n  function forceCloseOrder() public onlyOwnerOrPartner {\r\n    require(status == StatusChoices.REPAYMENT_WAITING);\r\n    uint256 transferSum = 0;\r\n\r\n    if (now <= toTime) {\r\n      status = StatusChoices.CLOSE_POSITION;\r\n    } else {\r\n      status = StatusChoices.OVERDUE_STOP;\r\n    }\r\n\r\n    if(loanTokenName.stringCompare(TOKEN_ETH)){\r\n        if(ethAmount[maker] > 0 && address(this).balance > 0){\r\n            transferSum = address(this).balance;\r\n            maker.transfer(transferSum);\r\n        }\r\n    }else{\r\n        if(ERC20(token20).balanceOf(address(this)) > 0){\r\n            transferSum = ERC20(token20).balanceOf(address(this));\r\n            require(safeErc20Transfer(maker, transferSum));\r\n        }\r\n    }\r\n\r\n    // Return pledge token.\r\n    PledgeContract(owner)._forceConclude(taker);\r\n    emit ForceCloseOrder(toTime, transferSum);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Withdrawal of the token invested by the taker.\r\n   * @param _taker address of investor.\r\n   * @param _refundSum refundSum number of tokens withdrawn.\r\n   */\r\n  function withdrawToken(address _taker, uint256 _refundSum) public onlyOwnerOrPartner {\r\n    require(status == StatusChoices.NO_LOAN);\r\n    require(_taker != address(0) && _refundSum > 0);\r\n    if (loanTokenName.stringCompare(TOKEN_ETH)) {\r\n      require(address(this).balance >= _refundSum && ethAmount[_taker] >= _refundSum);\r\n      _taker.transfer(_refundSum);\r\n      ethAmount[_taker] = ethAmount[_taker].sub(_refundSum);\r\n    } else {\r\n      require(ERC20(token20).balanceOf(address(this)) >= _refundSum);\r\n      require(safeErc20Transfer(_taker, _refundSum));\r\n    }\r\n    emit WithdrawToken(_taker, _refundSum);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Since the implementation of usdt ERC20.sol transfer code does not design the return value,\r\n   * @dev which is different from most ERC20 token interfaces,most erc20 transfer token agreements return bool.\r\n   * @dev it is necessary to independently adapt the interface for usdt token in order to transfer successfully\r\n   * @dev if not, the transfer may fail.\r\n   */\r\n  function safeErc20Transfer(address _toAddress,uint256 _transferSum) internal returns (bool) {\r\n    if(loanTokenName.stringCompare(TOKEN_USDT)){\r\n      UsdtERC20(token20).transfer(_toAddress, _transferSum);\r\n    }else{\r\n      require(ERC20(token20).transfer(_toAddress, _transferSum));\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Get current contract order status.\r\n   */\r\n  function getPledgeStatus() public view returns(string pledgeStatus) {\r\n    if (status == StatusChoices.NO_LOAN) {\r\n      pledgeStatus = \"NO_LOAN\";\r\n    } else if (status == StatusChoices.REPAYMENT_WAITING) {\r\n      pledgeStatus = \"REPAYMENT_WAITING\";\r\n    } else if (status == StatusChoices.REPAYMENT_ALL) {\r\n      pledgeStatus = \"REPAYMENT_ALL\";\r\n    } else if (status == StatusChoices.CLOSE_POSITION) {\r\n      pledgeStatus = \"CLOSE_POSITION\";\r\n    } else {\r\n      pledgeStatus = \"OVERDUE_STOP\";\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title PledgeFactory\r\n * @dev Pledge factory contract.\r\n * @dev Specially provides the pledge guarantee creation and the statistics function.\r\n */\r\ncontract PledgeFactory is RBACOperator {\r\n  using AddressUtils for address;\r\n\r\n  // initial type of pledge contract.\r\n  string internal constant INIT_TOKEN_NAME = \"UNKNOWN\";\r\n\r\n  mapping(uint256 => EscrowPledge) internal pledgeEscrowById;\r\n  // pledge number unique screening.\r\n  mapping(uint256 => bool) internal isPledgeId;\r\n\r\n  /**\r\n   * @dev Pledge guarantee statistics.\r\n   */\r\n  struct EscrowPledge {\r\n    address pledgeContract;\r\n    string tokenName;\r\n  }\r\n\r\n  /**\r\n   * Event for createOrderContract logging.\r\n   * @param pledgeId management contract id.\r\n   * @param newPledgeAddress pledge management contract address.\r\n   */\r\n  event CreatePledgeContract(uint256 indexed pledgeId, address newPledgeAddress);\r\n\r\n\r\n  /**\r\n   * @dev Create a pledge subcontract\r\n   * @param _pledgeId index number of the pledge contract.\r\n   */\r\n  function createPledgeContract(uint256 _pledgeId, address _escrowPartner) public onlyPartner returns(bool) {\r\n    require(_pledgeId > 0 && !isPledgeId[_pledgeId] && _escrowPartner!=address(0));\r\n\r\n    // Give the pledge contract the right to update statistics.\r\n    PledgeContract pledgeAddress = new PledgeContract(_pledgeId, address(this),partner);\r\n    pledgeAddress.transferOwnership(_escrowPartner);\r\n    addOperater(address(pledgeAddress));\r\n\r\n    // update pledge contract info\r\n    isPledgeId[_pledgeId] = true;\r\n    pledgeEscrowById[_pledgeId] = EscrowPledge(pledgeAddress, INIT_TOKEN_NAME);\r\n\r\n    emit CreatePledgeContract(_pledgeId, address(pledgeAddress));\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Batch create a pledge subcontract\r\n   * @param _pledgeIds index number of the pledge contract.\r\n   */\r\n  function batchCreatePledgeContract(uint256[] _pledgeIds, address _escrowPartner) public onlyPartner {\r\n    require(_pledgeIds.length > 0 && _escrowPartner.isContract());\r\n    for (uint i = 0; i < _pledgeIds.length; i++) {\r\n      require(createPledgeContract(_pledgeIds[i],_escrowPartner));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Use the index to get the basic information of the corresponding pledge contract.\r\n   * @param _pledgeId index number of the pledge contract\r\n   */\r\n  function getEscrowPledge(uint256 _pledgeId) public view returns(string tokenName, address pledgeContract) {\r\n    require(_pledgeId > 0);\r\n    tokenName = pledgeEscrowById[_pledgeId].tokenName;\r\n    pledgeContract = pledgeEscrowById[_pledgeId].pledgeContract;\r\n  }\r\n\r\n\r\n\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (Only the pledge contract has authority to operate)\r\n  // -----------------------------------------\r\n\r\n\r\n  /**\r\n   * @dev Configure permissions to operate on the token pool.\r\n   * @param _tokenPool token pool contract address.\r\n   * @param _pledge pledge contract address.\r\n   */\r\n  function tokenPoolOperater(address _tokenPool, address _pledge) public hasOperationPermission {\r\n    require(_pledge != address(0) && address(msg.sender).isContract() && address(msg.sender) == _pledge);\r\n    PledgePoolBase(_tokenPool).addOperater(_pledge);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Update the basic data of the pledge contract.\r\n   * @param _pledgeId index number of the pledge contract.\r\n   * @param _tokenName pledge contract supported token type.\r\n   */\r\n  function updatePledgeType(uint256 _pledgeId, string _tokenName) public hasOperationPermission {\r\n    require(_pledgeId > 0 && bytes(_tokenName).length > 0 && address(msg.sender).isContract());\r\n    pledgeEscrowById[_pledgeId].tokenName = _tokenName;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EscrowMaintainContract\r\n * @dev Provides configuration and external interfaces.\r\n */\r\ncontract EscrowMaintainContract is PartnerAuthority {\r\n  address public pledgeFactory;\r\n\r\n  // map of token name to token pool address;\r\n  mapping(string => address) internal nameByPool;\r\n  // map of token name to erc20 token address;\r\n  mapping(string => address) internal nameByToken;\r\n\r\n\r\n\r\n  // -----------------------------------------\r\n  // External interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Create a pledge subcontract\r\n   * @param _pledgeId index number of the pledge contract.\r\n   */\r\n  function createPledgeContract(uint256 _pledgeId) public onlyPartner returns(bool) {\r\n    require(_pledgeId > 0 && pledgeFactory!=address(0));\r\n    require(PledgeFactory(pledgeFactory).createPledgeContract(_pledgeId,partner));\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Batch create a pledge subcontract\r\n   * @param _pledgeIds index number of the pledge contract.\r\n   */\r\n  function batchCreatePledgeContract(uint256[] _pledgeIds) public onlyPartner {\r\n    require(_pledgeIds.length > 0);\r\n    PledgeFactory(pledgeFactory).batchCreatePledgeContract(_pledgeIds,partner);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Use the index to get the basic information of the corresponding pledge contract.\r\n   * @param _pledgeId index number of the pledge contract\r\n   */\r\n  function getEscrowPledge(uint256 _pledgeId) public view returns(string tokenName, address pledgeContract) {\r\n    require(_pledgeId > 0);\r\n    (tokenName,pledgeContract) = PledgeFactory(pledgeFactory).getEscrowPledge(_pledgeId);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev setTokenPool, set the token pool contract address of a token name.\r\n   * @param _tokenName set token pool name.\r\n   * @param _address the token pool contract address.\r\n   */\r\n  function setTokenPool(string _tokenName, address _address) public onlyOwner {\r\n    require(_address != address(0) && bytes(_tokenName).length > 0);\r\n    nameByPool[_tokenName] = _address;\r\n  }\r\n\r\n   /**\r\n   * @dev setToken, set the token contract address of a token name.\r\n   * @param _tokenName token name\r\n   * @param _address the ERC20 token contract address.\r\n   */\r\n  function setToken(string _tokenName, address _address) public onlyOwner {\r\n    require(_address != address(0) && bytes(_tokenName).length > 0);\r\n    nameByToken[_tokenName] = _address;\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev setPledgeFactory, Plant contract for configuration management pledge business.\r\n  * @param _factory pledge factory contract.\r\n  */\r\n  function setPledgeFactory(address _factory) public onlyOwner {\r\n    require(_factory != address(0));\r\n    pledgeFactory = _factory;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the current token pool is supported.\r\n   * @param _tokenName token name\r\n   */\r\n  function includeTokenPool(string _tokenName) view public returns(address) {\r\n    require(bytes(_tokenName).length > 0);\r\n    return nameByPool[_tokenName];\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Checks whether the current erc20 token is supported.\r\n   * @param _tokenName token name\r\n   */\r\n  function includeToken(string _tokenName) view public returns(address) {\r\n    require(bytes(_tokenName).length > 0);\r\n    return nameByToken[_tokenName];\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title PledgeContract\r\n * @dev Pledge process management contract\r\n */\r\ncontract PledgeContract is PartnerAuthority {\r\n\r\n  using SafeMath for uint256;\r\n  using SafeCompare for string;\r\n\r\n  /**\r\n   * @dev Type of execution state of the pledge contract（irreversible）\r\n   */\r\n  enum StatusChoices {\r\n    NO_PLEDGE_INFO,\r\n    PLEDGE_CREATE_MATCHING,\r\n    PLEDGE_REFUND\r\n  }\r\n\r\n  string public pledgeTokenName;\r\n  uint256 public pledgeId;\r\n  address internal maker;\r\n  address internal token20;\r\n  address internal factory;\r\n  address internal escrowContract;\r\n  uint256 internal pledgeAccountSum;\r\n  // order contract address\r\n  address internal orderContract;\r\n  string internal loanTokenName;\r\n  StatusChoices internal status;\r\n  address internal tokenPoolAddress;\r\n  string internal constant TOKEN_ETH = \"ETH\";\r\n  string internal constant TOKEN_USDT = \"USDT\";\r\n  // ETH pledge account\r\n  mapping(address => uint256) internal verifyEthAccount;\r\n\r\n\r\n  /**\r\n   * Event for createOrderContract logging.\r\n   * @param newOrderContract management contract address.\r\n   */\r\n  event CreateOrderContract(address newOrderContract);\r\n\r\n\r\n  /**\r\n   * Event for WithdrawToken logging.\r\n   * @param maker address of investor.\r\n   * @param pledgeTokenName token name.\r\n   * @param refundSum number of tokens withdrawn.\r\n   */\r\n  event WithdrawToken(address indexed maker, string pledgeTokenName, uint256 refundSum);\r\n\r\n\r\n  /**\r\n   * Event for appendEscrow logging.\r\n   * @param maker address of borrower.\r\n   * @param appendSum append amount.\r\n   */\r\n  event AppendEscrow(address indexed maker, uint256 appendSum);\r\n\r\n\r\n  /**\r\n   * @dev Constructor initial contract configuration parameters\r\n   */\r\n  constructor(uint256 _pledgeId, address _factory , address _escrowContract) public {\r\n    require(_pledgeId > 0 && _factory != address(0) && _escrowContract != address(0));\r\n    pledgeId = _pledgeId;\r\n    factory = _factory;\r\n    status = StatusChoices.NO_PLEDGE_INFO;\r\n    escrowContract = _escrowContract;\r\n  }\r\n\r\n\r\n\r\n  // -----------------------------------------\r\n  // external interface\r\n  // -----------------------------------------\r\n\r\n\r\n\r\n  function() external payable {\r\n    require(status != StatusChoices.PLEDGE_REFUND);\r\n    // Identify the borrower.\r\n    if (maker != address(0)) {\r\n      require(address(msg.sender) == maker);\r\n    }\r\n    // Record basic information about the borrower's pledge ETH\r\n    verifyEthAccount[msg.sender] = verifyEthAccount[msg.sender].add(msg.value);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Add the pledge information and transfer the pledged token into the corresponding currency pool.\r\n   * @param _pledgeTokenName maker pledge token name.\r\n   * @param _maker borrower address.\r\n   * @param _pledgeSum pledge amount.\r\n   * @param _loanTokenName pledge token type.\r\n   */\r\n  function addRecord(string _pledgeTokenName, address _maker, uint256 _pledgeSum, string _loanTokenName) public onlyOwner {\r\n    require(_maker != address(0) && _pledgeSum > 0 && status != StatusChoices.PLEDGE_REFUND);\r\n    // Add the pledge information for the first time.\r\n    if (status == StatusChoices.NO_PLEDGE_INFO) {\r\n      // public data init.\r\n      maker = _maker;\r\n      pledgeTokenName = _pledgeTokenName;\r\n      tokenPoolAddress = checkedTokenPool(pledgeTokenName);\r\n      PledgeFactory(factory).updatePledgeType(pledgeId, pledgeTokenName);\r\n      // Assign rights to the operation of the contract pool\r\n      PledgeFactory(factory).tokenPoolOperater(tokenPoolAddress, address(this));\r\n      // Create order management contracts.\r\n      createOrderContract(_loanTokenName);\r\n    }\r\n    // Record information of each pledge.\r\n    pledgeAccountSum = pledgeAccountSum.add(_pledgeSum);\r\n    PledgePoolBase(tokenPoolAddress).addRecord(maker, pledgeAccountSum, pledgeId, pledgeTokenName);\r\n    // Transfer the pledge token to the appropriate token pool.\r\n    if (pledgeTokenName.stringCompare(TOKEN_ETH)) {\r\n      require(verifyEthAccount[maker] >= _pledgeSum);\r\n      tokenPoolAddress.transfer(_pledgeSum);\r\n    } else {\r\n      token20 = checkedToken(pledgeTokenName);\r\n      require(ERC20(token20).balanceOf(address(this)) >= _pledgeSum);\r\n      require(safeErc20Transfer(token20,tokenPoolAddress, _pledgeSum));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the number of pledged tokens.\r\n   * @param _appendSum append amount.\r\n   */\r\n  function appendEscrow(uint256 _appendSum) public onlyOwner {\r\n    require(status == StatusChoices.PLEDGE_CREATE_MATCHING);\r\n    addRecord(pledgeTokenName, maker, _appendSum, loanTokenName);\r\n    emit AppendEscrow(maker, _appendSum);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Withdraw pledge behavior.\r\n   * @param _maker borrower address.\r\n   */\r\n  function withdrawToken(address _maker) public onlyOwner {\r\n    require(status != StatusChoices.PLEDGE_REFUND);\r\n    uint256 pledgeSum = 0;\r\n    // there are two types of retractions.\r\n    if (status == StatusChoices.NO_PLEDGE_INFO) {\r\n      pledgeSum = classifySquareUp(_maker);\r\n    } else {\r\n      status = StatusChoices.PLEDGE_REFUND;\r\n      require(PledgePoolBase(tokenPoolAddress).withdrawToken(pledgeId, maker, pledgeAccountSum));\r\n      pledgeSum = pledgeAccountSum;\r\n    }\r\n    emit WithdrawToken(_maker, pledgeTokenName, pledgeSum);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Executed in some extreme unforsee cases, to avoid eth locked.\r\n   * @param _tokenName recycle token type.\r\n   * @param _amount Number of eth to recycle.\r\n   */\r\n  function recycle(string _tokenName, uint256 _amount) public onlyOwner {\r\n    require(status != StatusChoices.NO_PLEDGE_INFO && _amount>0);\r\n    if (_tokenName.stringCompare(TOKEN_ETH)) {\r\n      require(address(this).balance >= _amount);\r\n      owner.transfer(_amount);\r\n    } else {\r\n      address token = checkedToken(_tokenName);\r\n      require(ERC20(token).balanceOf(address(this)) >= _amount);\r\n      require(safeErc20Transfer(token,owner, _amount));\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Since the implementation of usdt ERC20.sol transfer code does not design the return value,\r\n   * @dev which is different from most ERC20 token interfaces,most erc20 transfer token agreements return bool.\r\n   * @dev it is necessary to independently adapt the interface for usdt token in order to transfer successfully\r\n   * @dev if not, the transfer may fail.\r\n   */\r\n  function safeErc20Transfer(address _token20,address _toAddress,uint256 _transferSum) internal returns (bool) {\r\n    if(loanTokenName.stringCompare(TOKEN_USDT)){\r\n      UsdtERC20(_token20).transfer(_toAddress, _transferSum);\r\n    }else{\r\n      require(ERC20(_token20).transfer(_toAddress, _transferSum));\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n  // -----------------------------------------\r\n  // internal interface\r\n  // -----------------------------------------\r\n\r\n\r\n\r\n  /**\r\n   * @dev Create an order process management contract for the match and repayment business.\r\n   * @param _loanTokenName expect loan token type.\r\n   */\r\n  function createOrderContract(string _loanTokenName) internal {\r\n    require(bytes(_loanTokenName).length > 0);\r\n    status = StatusChoices.PLEDGE_CREATE_MATCHING;\r\n    address loanToken20 = checkedToken(_loanTokenName);\r\n    OrderManageContract newOrder = new OrderManageContract(_loanTokenName, loanToken20, maker);\r\n    setPartner(address(newOrder));\r\n    newOrder.setPartner(owner);\r\n    // update contract public data.\r\n    orderContract = newOrder;\r\n    loanTokenName = _loanTokenName;\r\n    emit CreateOrderContract(address(newOrder));\r\n  }\r\n\r\n  /**\r\n   * @dev classification withdraw.\r\n   * @dev Execute without changing the current contract data state.\r\n   * @param _maker borrower address.\r\n   */\r\n  function classifySquareUp(address _maker) internal returns(uint256 sum) {\r\n    if (pledgeTokenName.stringCompare(TOKEN_ETH)) {\r\n      uint256 pledgeSum = verifyEthAccount[_maker];\r\n      require(pledgeSum > 0 && address(this).balance >= pledgeSum);\r\n      _maker.transfer(pledgeSum);\r\n      verifyEthAccount[_maker] = 0;\r\n      sum = pledgeSum;\r\n    } else {\r\n      uint256 balance = ERC20(token20).balanceOf(address(this));\r\n      require(balance > 0);\r\n      require(safeErc20Transfer(token20,_maker, balance));\r\n      sum = balance;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Check wether the token is included for a token name.\r\n   * @param _tokenName token name.\r\n   */\r\n  function checkedToken(string _tokenName) internal view returns(address) {\r\n    address tokenAddress = EscrowMaintainContract(escrowContract).includeToken(_tokenName);\r\n    require(tokenAddress != address(0));\r\n    return tokenAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Check wether the token pool is included for a token name.\r\n   * @param _tokenName pledge token name.\r\n   */\r\n  function checkedTokenPool(string _tokenName) internal view returns(address) {\r\n    address tokenPool = EscrowMaintainContract(escrowContract).includeTokenPool(_tokenName);\r\n    require(tokenPool != address(0));\r\n    return tokenPool;\r\n  }\r\n\r\n\r\n\r\n  // -----------------------------------------\r\n  // business relationship interface\r\n  // (Only the order contract has authority to operate)\r\n  // -----------------------------------------\r\n\r\n\r\n\r\n  /**\r\n   * @dev Refund of the borrower’s pledge.\r\n   */\r\n  function _conclude() public onlyPartner {\r\n    require(status == StatusChoices.PLEDGE_CREATE_MATCHING);\r\n    status = StatusChoices.PLEDGE_REFUND;\r\n    require(PledgePoolBase(tokenPoolAddress).refundTokens(pledgeId, pledgeAccountSum, maker));\r\n  }\r\n\r\n  /**\r\n   * @dev Expired for repayment or close position.\r\n   * @param _taker address of investor.\r\n   */\r\n  function _forceConclude(address _taker) public onlyPartner {\r\n    require(_taker != address(0) && status == StatusChoices.PLEDGE_CREATE_MATCHING);\r\n    status = StatusChoices.PLEDGE_REFUND;\r\n    require(PledgePoolBase(tokenPoolAddress).refundTokens(pledgeId, pledgeAccountSum, _taker));\r\n  }\r\n\r\n\r\n\r\n  // -----------------------------------------\r\n  // query interface (use no gas)\r\n  // -----------------------------------------\r\n\r\n\r\n\r\n  /**\r\n   * @dev Get current contract order status.\r\n   * @return pledgeStatus state indicate.\r\n   */\r\n  function getPledgeStatus() public view returns(string pledgeStatus) {\r\n    if (status == StatusChoices.NO_PLEDGE_INFO) {\r\n      pledgeStatus = \"NO_PLEDGE_INFO\";\r\n    } else if (status == StatusChoices.PLEDGE_CREATE_MATCHING) {\r\n      pledgeStatus = \"PLEDGE_CREATE_MATCHING\";\r\n    } else {\r\n      pledgeStatus = \"PLEDGE_REFUND\";\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev get order contract address. use no gas.\r\n   */\r\n  function getOrderContract() public view returns(address) {\r\n    return orderContract;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total number of tokens pledged under the current contract.\r\n   */\r\n  function getPledgeAccountSum() public view returns(uint256) {\r\n    return pledgeAccountSum;\r\n  }\r\n\r\n  /**\r\n   * @dev get current contract borrower address.\r\n   */\r\n  function getMakerAddress() public view returns(address) {\r\n    return maker;\r\n  }\r\n\r\n  /**\r\n   * @dev get current contract pledge Id.\r\n   */\r\n  function getPledgeId() external view returns(uint256) {\r\n    return pledgeId;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title pledge pool base\r\n * @dev a base tokenPool, any tokenPool for a specific token should inherit from this tokenPool.\r\n */\r\ncontract PledgePoolBase is RBACOperator {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Record pledge details.\r\n  mapping(uint256 => Escrow) internal escrows;\r\n\r\n  /**\r\n   * @dev Information structure of pledge.\r\n   */\r\n  struct Escrow {\r\n    uint256 pledgeSum;\r\n    address payerAddress;\r\n    string tokenName;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // TokenPool external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev addRecord, interface to add record.\r\n   * @param _payerAddress Address performing the pleadge.\r\n   * @param _pledgeSum the value to pleadge.\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _tokenName pledge token name.\r\n   */\r\n  function addRecord(address _payerAddress, uint256 _pledgeSum, uint256 _pledgeId, string _tokenName) public hasOperationPermission returns(bool) {\r\n    _preValidateAddRecord(_payerAddress, _pledgeSum, _pledgeId, _tokenName);\r\n    _processAddRecord(_payerAddress, _pledgeSum, _pledgeId, _tokenName);\r\n    return true;\r\n  }\r\n\r\n\r\n   /**\r\n    * @dev withdrawToken, withdraw pledge token.\r\n    * @param _pledgeId pledge contract index number.\r\n    * @param _maker borrower address.\r\n    * @param _num withdraw token sum.\r\n    */\r\n  function withdrawToken(uint256 _pledgeId, address _maker, uint256 _num) public hasOperationPermission returns(bool) {\r\n    _preValidateWithdraw(_maker, _num, _pledgeId);\r\n    _processWithdraw(_maker, _num, _pledgeId);\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev refundTokens, interface to refund\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _targetAddress transfer target address.\r\n   * @param _returnSum return token sum.\r\n   */\r\n  function refundTokens(uint256 _pledgeId, uint256 _returnSum, address _targetAddress) public hasOperationPermission returns(bool) {\r\n    _preValidateRefund(_returnSum, _targetAddress, _pledgeId);\r\n    _processRefund(_returnSum, _targetAddress, _pledgeId);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev getLedger, Query the pledge details of the pledge number in the pool.\r\n   * @param _pledgeId pledge contract index number.\r\n   */\r\n  function getLedger(uint256 _pledgeId) public view returns(uint256 num, address payerAddress, string tokenName) {\r\n    require(_pledgeId > 0);\r\n    num = escrows[_pledgeId].pledgeSum;\r\n    payerAddress = escrows[_pledgeId].payerAddress;\r\n    tokenName = escrows[_pledgeId].tokenName;\r\n  }\r\n\r\n\r\n\r\n  // -----------------------------------------\r\n  // TokenPool internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n\r\n\r\n  /**\r\n   * @dev _preValidateAddRecord, Validation of an incoming AddRecord. Use require statemens to revert state when conditions are not met.\r\n   * @param _payerAddress Address performing the pleadge.\r\n   * @param _pledgeSum the value to pleadge.\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _tokenName pledge token name.\r\n   */\r\n  function _preValidateAddRecord(address _payerAddress, uint256 _pledgeSum, uint256 _pledgeId, string _tokenName) view internal {\r\n    require(_pledgeSum > 0 && _pledgeId > 0\r\n      && _payerAddress != address(0)\r\n      && bytes(_tokenName).length > 0\r\n      && address(msg.sender).isContract()\r\n      && PledgeContract(msg.sender).getPledgeId()==_pledgeId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev _processAddRecord, Executed when a AddRecord has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _payerAddress Address performing the pleadge.\r\n   * @param _pledgeSum the value to pleadge.\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _tokenName pledge token name.\r\n   */\r\n  function _processAddRecord(address _payerAddress, uint256 _pledgeSum, uint256 _pledgeId, string _tokenName) internal {\r\n    Escrow memory escrow = Escrow(_pledgeSum, _payerAddress, _tokenName);\r\n    escrows[_pledgeId] = escrow;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev _preValidateRefund, Validation of an incoming refund. Use require statemens to revert state when conditions are not met.\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _targetAddress transfer target address.\r\n   * @param _returnSum return token sum.\r\n   */\r\n  function _preValidateRefund(uint256 _returnSum, address _targetAddress, uint256 _pledgeId) view internal {\r\n    require(_returnSum > 0 && _pledgeId > 0\r\n      && _targetAddress != address(0)\r\n      && address(msg.sender).isContract()\r\n      && _returnSum <= escrows[_pledgeId].pledgeSum\r\n      && PledgeContract(msg.sender).getPledgeId()==_pledgeId\r\n    );\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev _processRefund, Executed when a Refund has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _targetAddress transfer target address.\r\n   * @param _returnSum return token sum.\r\n   */\r\n  function _processRefund(uint256 _returnSum, address _targetAddress, uint256 _pledgeId) internal {\r\n    escrows[_pledgeId].pledgeSum = escrows[_pledgeId].pledgeSum.sub(_returnSum);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev _preValidateWithdraw, Withdraw initiated parameter validation.\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _maker borrower address.\r\n   * @param _num withdraw token sum.\r\n   */\r\n  function _preValidateWithdraw(address _maker, uint256 _num, uint256 _pledgeId) view internal {\r\n    require(_num > 0 && _pledgeId > 0\r\n       && _maker != address(0)\r\n       && address(msg.sender).isContract()\r\n       && _num <= escrows[_pledgeId].pledgeSum\r\n       && PledgeContract(msg.sender).getPledgeId()==_pledgeId\r\n    );\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev _processWithdraw, Withdraw data update.\r\n   * @param _pledgeId pledge contract index number.\r\n   * @param _maker borrower address.\r\n   * @param _num withdraw token sum.\r\n   */\r\n  function _processWithdraw(address _maker, uint256 _num, uint256 _pledgeId) internal {\r\n    escrows[_pledgeId].pledgeSum = escrows[_pledgeId].pledgeSum.sub(_num);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title eth pledge pool.\r\n * @dev the tokenPool for ETH.\r\n */\r\ncontract EthPledgePool is PledgePoolBase {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n  // -----------------------------------------\r\n  // TokenPool external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function\r\n   */\r\n  function() external payable {}\r\n\r\n\r\n  /**\r\n   * @dev recycle, Executed in some extreme unforsee cases, to avoid eth locked.\r\n   * @param _amount Number of eth to withdraw\r\n   * @param _contract Multi-signature contracts, for the fair and just treatment of funds.\r\n   */\r\n  function recycle(uint256 _amount,address _contract) public onlyOwner returns(bool) {\r\n    require(_amount <= address(this).balance && _contract.isContract());\r\n    _contract.transfer(_amount);\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev kill, kills the contract and send everything to `_address`..\r\n   */\r\n  function kills() public onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n\r\n  // -----------------------------------------\r\n  // token pool internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n\r\n  /**\r\n   * @dev Executed when a Refund has been validated and is ready to be executed.\r\n   *  Not necessarily emits/sends tokens.\r\n   */\r\n  function _processRefund(uint256 _returnSum, address _targetAddress, uint256 _pledgeId) internal {\r\n    super._processRefund(_returnSum, _targetAddress, _pledgeId);\r\n    require(address(this).balance >= _returnSum);\r\n    _targetAddress.transfer(_returnSum);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw pledge token.\r\n   */\r\n  function _processWithdraw(address _maker, uint256 _num, uint256 _pledgeId) internal {\r\n    super._processWithdraw(_maker, _num, _pledgeId);\r\n    require(address(this).balance >= _num);\r\n    _maker.transfer(_num);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addOperater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pledgeId\",\"type\":\"uint256\"},{\"name\":\"_returnSum\",\"type\":\"uint256\"},{\"name\":\"_targetAddress\",\"type\":\"address\"}],\"name\":\"refundTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removePartner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pledgeId\",\"type\":\"uint256\"},{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pledgeId\",\"type\":\"uint256\"}],\"name\":\"getLedger\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"payerAddress\",\"type\":\"address\"},{\"name\":\"tokenName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kills\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeOperater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"setPartner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payerAddress\",\"type\":\"address\"},{\"name\":\"_pledgeSum\",\"type\":\"uint256\"},{\"name\":\"_pledgeId\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"}],\"name\":\"addRecord\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"recycle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldPartner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPartner\",\"type\":\"address\"}],\"name\":\"SetPartner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthPledgePool","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://283d2ad813330ec0fe8e481dcbecbf64dce32d626fc76fd7d4771b47dc32a30c"}]}