{"status":"1","message":"OK","result":[{"SourceCode":"// The version of the compiler.\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ETH_Silver\r\n * @dev The main contract of the project.\r\n */\r\ncontract ETH_Silver {\r\n\r\n    // Using SafeMath for safe calculations.\r\n    using SafeMath for uint;\r\n\r\n    // A variable for address of the owner.\r\n    address owner;\r\n\r\n    // A variable to store deposits of investors.\r\n    mapping (address => uint) deposit;\r\n    // A variable to store amount of withdrawn money of investors.\r\n    mapping (address => uint) withdrawn;\r\n    // A variable to store reference point to count available money to withdraw.\r\n    mapping (address => uint) lastTimeWithdraw;\r\n\r\n    // A function to transfer ownership of the contract (available only for the owner).\r\n    function transferOwnership(address _newOwner) external {\r\n        require(msg.sender == owner);\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n    }\r\n\r\n    // A function to get key info for investors.\r\n    function getInfo() public view returns(uint Deposit, uint Withdrawn, uint AmountToWithdraw) {\r\n        // 1) Amount of invested money;\r\n        Deposit = deposit[msg.sender];\r\n        // 2) Amount of withdrawn money;\r\n        Withdrawn = withdrawn[msg.sender];\r\n        // 3) Amount of money which is available to withdraw;\r\n        // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 day)) * (Deposit * 3% / 100%) / 1 day\r\n        AmountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(3).div(100)).div(1 days);\r\n    }\r\n\r\n    // A constructor function for the contract. Being used once at the time as contract is deployed and simply set the owner of the contract.\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // A \"fallback\" function. It is automatically being called when anybody sends money to the contract. Function simply calls the \"invest\" function.\r\n    function() external payable {\r\n        invest();\r\n    }\r\n\r\n    // A function which accepts money of investors.\r\n    function invest() public payable {\r\n        // Requires amount of money to be more than 0.01 ETH. If it is less, automatically reverts the whole function.\r\n        require(msg.value > 10000000000000000);\r\n        // Transfers a fee to the owner of the contract. The fee is 20% of the deposit (or Deposit / 5)\r\n        owner.transfer(msg.value.div(5));\r\n        // The special algorithm for investors who increase their deposits:\r\n        if (deposit[msg.sender] > 0) {\r\n            // Amount of money which is available to withdraw;\r\n            // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 day)) * (Deposit * 3% / 100%) / 1 day\r\n            uint amountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(3).div(100)).div(1 days);\r\n            // The additional algorithm for investors who need to withdraw available dividends:\r\n            if (amountToWithdraw != 0) {\r\n                // Increasing amount withdrawn by an investor.\r\n                withdrawn[msg.sender] = withdrawn[msg.sender].add(amountToWithdraw);\r\n                // Transferring available dividends to an investor.\r\n                msg.sender.transfer(amountToWithdraw);\r\n            }\r\n            // Setting the reference point to the current time.\r\n            lastTimeWithdraw[msg.sender] = block.timestamp;\r\n            // Increasing of the deposit of an investor.\r\n            deposit[msg.sender] = deposit[msg.sender].add(msg.value);\r\n            // End of the function for investors who increases their deposits.\r\n            return;\r\n        }\r\n        // The algorithm for new investors:\r\n        // Setting the reference point to the current time.\r\n        lastTimeWithdraw[msg.sender] = block.timestamp;\r\n        // Storing the amount of the deposit for new investors.\r\n        deposit[msg.sender] = (msg.value);\r\n    }\r\n\r\n    // A function to get available dividends of an investor.\r\n    function withdraw() public {\r\n        // Amount of money which is available to withdraw.\r\n        // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 day)) * (Deposit * 3% / 100%) / 1 day\r\n        uint amountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(3).div(100)).div(1 days);\r\n        // Reverting the whole function for investors who got nothing to withdraw yet.\r\n        if (amountToWithdraw == 0) {\r\n            revert();\r\n        }\r\n        // Increasing amount withdrawn by the investor.\r\n        withdrawn[msg.sender] = withdrawn[msg.sender].add(amountToWithdraw);\r\n        // Updating the reference point.\r\n        // Formula without SafeMath: Current Time - ((Current Time - Previous Reference Point) % 1 day)\r\n        lastTimeWithdraw[msg.sender] = block.timestamp.sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days));\r\n        // Transferring the available dividends to an investor.\r\n        msg.sender.transfer(amountToWithdraw);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"Deposit\",\"type\":\"uint256\"},{\"name\":\"Withdrawn\",\"type\":\"uint256\"},{\"name\":\"AmountToWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ETH_Silver","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://87431eed38d6a2279adfdd834ba14246f5514087ae74a697703b89bac07a7bca"}]}