{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/* Smart Contract Security Audit by Callisto Network */\r\n \r\n/* Mizhen Boss represents the right of being a member of Mizhen community \r\n * Holders can use different tools and share profits in all the games developed by Mizhen team\r\n * Total number of MZBoss is 21,000,000\r\n * The price of MZBoss is constant at 0.005 ether\r\n * Purchase fee is 15%, pay customers buy MZBoss, of which 10% is distributed to tokenholders, 5% is sent to community for further development.\r\n * There is not selling fee\r\n * The purchase fee is evenly distributed to the existing MZBoss holders\r\n * All MZBoss holders will receive profit from different game pots\r\n * Mizhen Team\r\n */\r\n \r\ncontract MZBoss {\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier transferCheck(uint256 _amountOfTokens) {\r\n        address _customerAddress = msg.sender;\r\n        require((_amountOfTokens > 0) && (_amountOfTokens <= tokenBalanceLedger_[_customerAddress]));\r\n        _;\r\n    }\r\n    \r\n    // only people with profits\r\n    modifier onlyStronghands() {\r\n        address _customerAddress = msg.sender;\r\n        require(dividendsOf(_customerAddress) > 0);\r\n        _;\r\n    }\r\n    \r\n    // Check if the play has enough ETH to buy tokens\r\n    modifier enoughToreinvest() {\r\n        address _customerAddress = msg.sender;\r\n        uint256 priceForOne = (tokenPriceInitial_*100)/85;\r\n        require((dividendsOf(_customerAddress) >= priceForOne) && (_tokenLeft >= calculateTokensReceived(dividendsOf(_customerAddress))));\r\n        _; \r\n    } \r\n    \r\n    // administrators can:\r\n    // -> change the name of the contract\r\n    // -> change the name of the token\r\n    // they CANNOT:\r\n    // -> take funds\r\n    // -> disable withdrawals\r\n    // -> kill the contract\r\n    // -> change the price of tokens\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[_customerAddress] == true);\r\n        _;\r\n    }\r\n    \r\n    // Check if the play has enough ETH to buy tokens\r\n    modifier enoughToBuytoken (){\r\n        uint256 _amountOfEthereum = msg.value;\r\n        uint256 priceForOne = (tokenPriceInitial_*100)/85;\r\n        require((_amountOfEthereum >= priceForOne) && (_tokenLeft >= calculateTokensReceived(_amountOfEthereum)));\r\n        _; \r\n    } \r\n    \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    \r\n    event OnTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensBought,\r\n        uint256 tokenSupplyUpdate,\r\n        uint256 tokenLeftUpdate\r\n    );\r\n    \r\n    event OnTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensSold,\r\n        uint256 ethereumEarned,\r\n        uint256 tokenSupplyUpdate,\r\n        uint256 tokenLeftUpdate\r\n    );\r\n    \r\n    event OnReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensBought,\r\n        uint256 tokenSupplyUpdate,\r\n        uint256 tokenLeftUpdate\r\n    );\r\n    \r\n    event OnWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    \r\n    \r\n    // distribution of profit from pot\r\n    event OnTotalProfitPot(\r\n        uint256 _totalProfitPot\r\n    );\r\n    \r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"Mizhen\";\r\n    string public symbol = \"MZBoss\";\r\n    uint256 constant public totalToken = 21000000e18; //total 21000000 MZBoss tokens \r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal dividendFee_ = 10; // percentage of fee sent to token holders \r\n    uint8 constant internal toCommunity_ = 5; // percentage of fee sent to community. \r\n    uint256 constant internal tokenPriceInitial_ = 5e15; // the price is constant and does not change as the purchase increases.\r\n    uint256 constant internal magnitude = 1e18; // related to payoutsTo_, profitPershare_, profitPerSharePot_, profitPerShareNew_\r\n\r\n    \r\n    // ambassador program\r\n    mapping(address => bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_ = 1e19;\r\n    uint256 constant internal ambassadorQuota_ = 1e19;\r\n    \r\n    // exchange address, in the future customers can exchange MZBoss without the price limitation\r\n    mapping(address => bool) public exchangeAddress_;\r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) public tokenBalanceLedger_;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\r\n\r\n    uint256 public tokenSupply_ = 0; // total sold tokens \r\n    uint256 public _tokenLeft = 21000000e18;\r\n    uint256 public totalEthereumBalance1 = 0;\r\n    uint256 public profitPerShare_ = 0 ;\r\n\r\n    uint256 public _totalProfitPot = 0;\r\n    address constant internal _communityAddress = 0x43e8587aCcE957629C9FD2185dD700dcDdE1dD1E;\r\n    \r\n    // administrator list (see above on what they can do)\r\n    mapping(address => bool) public administrators;\r\n    \r\n    // when this is set to true, only ambassadors can purchase tokens \r\n    bool public onlyAmbassadors = true;\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    constructor ()\r\n        public\r\n    \r\n    {\r\n        // add administrators here\r\n        administrators[0x6dAd1d9D24674bC9199237F93beb6E25b55Ec763] = true;\r\n\r\n        // add the ambassadors here.\r\n        ambassadors_[0x64BFD8F0F51569AEbeBE6AD2a1418462bCBeD842] = true;\r\n    }\r\n    \r\n    function purchaseTokens()  \r\n        enoughToBuytoken ()\r\n        public\r\n        payable\r\n    {\r\n           address _customerAddress = msg.sender;\r\n           uint256 _amountOfEthereum = msg.value;\r\n        \r\n        // are we still in the ambassador phase? \r\n        if( onlyAmbassadors && (SafeMath.sub(totalEthereumBalance(), _amountOfEthereum) < ambassadorQuota_ )){ \r\n            require(\r\n                // is the customer in the ambassador list? \r\n                (ambassadors_[_customerAddress] == true) &&\r\n                \r\n                // does the customer purchase exceed the max ambassador quota? \r\n                (SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum) <= ambassadorMaxPurchase_)\r\n            );\r\n            \r\n            // updated the accumulated quota    \r\n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\r\n            \r\n            totalEthereumBalance1 = SafeMath.add(totalEthereumBalance1, _amountOfEthereum);\r\n            uint256 _amountOfTokens = ethereumToTokens_(_amountOfEthereum); \r\n            \r\n            tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n            \r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens); \r\n            \r\n            _tokenLeft = SafeMath.sub(totalToken, tokenSupply_); \r\n            \r\n            emit OnTokenPurchase(_customerAddress, _amountOfEthereum, _amountOfTokens, tokenSupply_, _tokenLeft);\r\n         \r\n        } \r\n        \r\n        else {\r\n            // in case the ether count drops low, the ambassador phase won't reinitiate\r\n            onlyAmbassadors = false;\r\n            \r\n            purchaseTokensAfter(_amountOfEthereum); \r\n                \r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * profit distribution from game pot\r\n     */\r\n    function potDistribution()\r\n        public\r\n        payable\r\n    {\r\n        //\r\n        require(msg.value > 0);\r\n        uint256 _incomingEthereum = msg.value;\r\n        if(tokenSupply_ > 0){\r\n            \r\n            // profit per share \r\n            uint256 profitPerSharePot_ = SafeMath.mul(_incomingEthereum, magnitude) / (tokenSupply_);\r\n            \r\n            // update profitPerShare_, adding profit from game pot\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, profitPerSharePot_);\r\n            \r\n        } else {\r\n            // send to community\r\n            payoutsTo_[_communityAddress] -=  (int256) (_incomingEthereum);\r\n            \r\n        }\r\n        \r\n        //update _totalProfitPot\r\n        _totalProfitPot = SafeMath.add(_incomingEthereum, _totalProfitPot); \r\n    }\r\n    \r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function reinvest()\r\n        enoughToreinvest()\r\n        public\r\n    {\r\n        \r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        \r\n        // fetch dividends\r\n        uint256 _dividends = dividendsOf(_customerAddress); \r\n        \r\n        uint256 priceForOne = (tokenPriceInitial_*100)/85;\r\n        \r\n        // minimum purchase 1 ether token\r\n        if (_dividends >= priceForOne) { \r\n        \r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        purchaseTokensAfter(_dividends);\r\n            \r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends);\r\n        \r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw()\r\n        onlyStronghands()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = dividendsOf(_customerAddress); \r\n        \r\n        // update dividend tracker, in order to calculate with payoutsTo which is int256, _dividends need to be casted to int256 first\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends);\r\n\r\n        \r\n        // send eth\r\n        _customerAddress.transfer(_dividends);\r\n        \r\n        // fire event\r\n        emit OnWithdraw(_customerAddress, _dividends);\r\n    }\r\n    \r\n    /**\r\n     * Liquifies tokens to ethereum.\r\n     */\r\n    function sell(uint256 _amountOfTokens)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, 0); // no fee when sell, but there is transaction fee included here\r\n        \r\n        require((tokenBalanceLedger_[_customerAddress] >= _amountOfTokens) && ( totalEthereumBalance1 >= _taxedEthereum ) && (_amountOfTokens > 0));\r\n        \r\n        // update the amount of the sold tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n        totalEthereumBalance1 = SafeMath.sub(totalEthereumBalance1, _taxedEthereum);\r\n        \r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (SafeMath.add(SafeMath.mul(profitPerShare_, _tokens)/magnitude, _taxedEthereum));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;       \r\n        \r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        _tokenLeft = SafeMath.sub(totalToken, tokenSupply_);\r\n        \r\n        // fire event\r\n        emit OnTokenSell(_customerAddress, _tokens, _taxedEthereum, tokenSupply_, _tokenLeft);\r\n    }\r\n    \r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     */\r\n    function transfer(uint256 _amountOfTokens, address _toAddress)\r\n        transferCheck(_amountOfTokens)\r\n        public\r\n        returns(bool)\r\n    {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n\r\n        // withdraw all outstanding dividends first\r\n        if(dividendsOf(_customerAddress) > 0) withdraw();\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n        \r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256) (SafeMath.mul(profitPerShare_ , _amountOfTokens)/magnitude);\r\n        payoutsTo_[_toAddress] += (int256) (SafeMath.mul(profitPerShare_ , _amountOfTokens)/magnitude);\r\n        \r\n        // fire event\r\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\r\n        \r\n        // ERC20\r\n        return true;\r\n       \r\n    }\r\n\r\n    \r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    /**\r\n     * In case we need to replace ourselves.\r\n     */\r\n    function setAdministrator(address _identifier, bool _status)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n    \r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setName(string _name)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        name = _name;\r\n    }\r\n    \r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setSymbol(string _symbol)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n\r\n    \r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     * \r\n     */\r\n    function totalEthereumBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    /**\r\n     * Method to view the current sold tokens\r\n     * \r\n     */\r\n    function tokenSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the payoutsTo_ of any single address.\r\n     */\r\n    function payoutsTo(address _customerAddress)\r\n        public\r\n        view\r\n        returns(int256)\r\n    {\r\n        return payoutsTo_[_customerAddress];\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address _customerAddress)\r\n        public \r\n        view\r\n        returns(uint256)\r\n    {\r\n        \r\n        uint256 _TokensEther = tokenBalanceLedger_[_customerAddress];\r\n        \r\n        if ((int256(SafeMath.mul(profitPerShare_, _TokensEther)/magnitude) - payoutsTo_[_customerAddress]) > 0 )\r\n           return uint256(int256(SafeMath.mul(profitPerShare_, _TokensEther)/magnitude) - payoutsTo_[_customerAddress]);  \r\n        else \r\n           return 0;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n     */\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) \r\n        public \r\n        pure \r\n        returns(uint256)\r\n    {\r\n        uint256 _dividends = SafeMath.mul(_ethereumToSpend, dividendFee_) / 100;\r\n        uint256 _communityDistribution = SafeMath.mul(_ethereumToSpend, toCommunity_) / 100;\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, SafeMath.add(_communityDistribution,_dividends));\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n     */\r\n    function calculateEthereumReceived(uint256 _tokensToSell) \r\n        public \r\n        pure \r\n        returns(uint256)\r\n    {\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, 0); // transaction fee\r\n        return _taxedEthereum;\r\n    }\r\n    \r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    function purchaseTokensAfter(uint256 _incomingEthereum) \r\n        private\r\n    {\r\n        // data setup\r\n        address _customerAddress = msg.sender;\r\n        \r\n        // distribution as dividend to token holders\r\n        uint256 _dividends = SafeMath.mul(_incomingEthereum, dividendFee_) / 100; \r\n        \r\n        // sent to community address\r\n        uint256 _communityDistribution = SafeMath.mul(_incomingEthereum, toCommunity_) / 100;\r\n        \r\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, SafeMath.add(_communityDistribution, _dividends));\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum); \r\n\r\n        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\r\n        // minimum purchase 1 token\r\n        require((_amountOfTokens >= 1e18) && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_)); \r\n\r\n        \r\n        // profitPerShare calculation assuming the _dividends are only distributed to the holders before the new customer\r\n        // the tokenSupply_ here is the supply without considering the new customer's buying amount\r\n        \r\n        if (tokenSupply_ == 0){\r\n            \r\n            uint256 profitPerShareNew_ = 0;\r\n        }else{\r\n            \r\n            profitPerShareNew_ = SafeMath.mul(_dividends, magnitude) / (tokenSupply_); \r\n        } \r\n        \r\n        // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n        profitPerShare_ = SafeMath.add(profitPerShare_, profitPerShareNew_); \r\n        \r\n        // assumed total dividends considering the new customer's buying amount \r\n        uint256 _dividendsAssumed = SafeMath.div(SafeMath.mul(profitPerShare_, _amountOfTokens), magnitude);\r\n            \r\n        // extra dividends in the assumed dividens, which does not exist \r\n        // this part is considered as the existing payoutsTo_ to the new customer\r\n        uint256 _dividendsExtra = _dividendsAssumed;\r\n        \r\n        \r\n        // update the new customer's payoutsTo_; cast _dividendsExtra to int256 first because payoutsTo is int256\r\n        payoutsTo_[_customerAddress] += (int256) (_dividendsExtra);\r\n            \r\n        // add tokens to the pool, update the tokenSupply_\r\n        tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens); \r\n            \r\n        _tokenLeft = SafeMath.sub(totalToken, tokenSupply_);\r\n        totalEthereumBalance1 = SafeMath.add(totalEthereumBalance1, _taxedEthereum);\r\n        \r\n        // send to community\r\n        _communityAddress.transfer(_communityDistribution);\r\n        \r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        \r\n        // fire event\r\n        emit OnTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, tokenSupply_, _tokenLeft);\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     */\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        require (_ethereum > 0);\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_;\r\n        \r\n        uint256 _tokensReceived = SafeMath.mul(_ethereum, magnitude) / _tokenPriceInitial;\r\n                    \r\n        return _tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * Calculate token sell value.\r\n     */\r\n     function tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {   \r\n        uint256 tokens_ = _tokens;\r\n        \r\n        uint256 _etherReceived = SafeMath.mul (tokenPriceInitial_, tokens_) / magnitude;\r\n            \r\n        return _etherReceived;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"payoutsTo\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalanceLedger_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeAddress_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSupply_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitPerShare_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalProfitPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"potDistribution\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_tokenLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"},{\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSupplyUpdate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenLeftUpdate\",\"type\":\"uint256\"}],\"name\":\"OnTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSupplyUpdate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenLeftUpdate\",\"type\":\"uint256\"}],\"name\":\"OnTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSupplyUpdate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenLeftUpdate\",\"type\":\"uint256\"}],\"name\":\"OnReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"OnWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_totalProfitPot\",\"type\":\"uint256\"}],\"name\":\"OnTotalProfitPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MZBoss","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://21683a19df2da429c78a86208478240a5fc84789697eef836685ac3ae4aeed5c"}]}