{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter;\r\n\r\n  constructor() internal {\r\n    // The counter starts at one to prevent changing it from zero to a non-zero\r\n    // value, which is a more expensive operation.\r\n    _guardCounter = 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: lib/CanReclaimToken.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20 compatible tokens\r\n   * @param token ERC20 The address of the token contract\r\n   */\r\n  function reclaimToken(IERC20 token) external onlyOwner {\r\n    if (address(token) == address(0)) {\r\n      owner().transfer(address(this).balance);\r\n      return;\r\n    }\r\n    uint256 balance = token.balanceOf(this);\r\n    token.transfer(owner(), balance);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(!has(role, account));\r\n\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(has(role, account));\r\n\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: lib/ServiceRole.sol\r\n\r\ncontract ServiceRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event ServiceAdded(address indexed account);\r\n  event ServiceRemoved(address indexed account);\r\n\r\n  Roles.Role private services;\r\n\r\n  constructor() internal {\r\n    _addService(msg.sender);\r\n  }\r\n\r\n  modifier onlyService() {\r\n    require(isService(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isService(address account) public view returns (bool) {\r\n    return services.has(account);\r\n  }\r\n\r\n  function renounceService() public {\r\n    _removeService(msg.sender);\r\n  }\r\n\r\n  function _addService(address account) internal {\r\n    services.add(account);\r\n    emit ServiceAdded(account);\r\n  }\r\n\r\n  function _removeService(address account) internal {\r\n    services.remove(account);\r\n    emit ServiceRemoved(account);\r\n  }\r\n}\r\n\r\n// File: contracts/Fights.sol\r\n\r\ninterface HEROES {\r\n  function getLevel(uint256 tokenId) external view returns (uint256);\r\n  function getGenes(uint256 tokenId) external view returns (uint256);\r\n  function getRace(uint256 tokenId) external view returns (uint256);\r\n  function lock(uint256 tokenId, uint256 lockedTo, bool onlyFreeze) external returns (bool);\r\n  function unlock(uint256 tokenId) external returns (bool);\r\n  function ownerOf(uint256 tokenId) external view returns (address);\r\n  function addWin(uint256 tokenId, uint winsCount, uint levelUp) external returns (bool);\r\n  function addLoss(uint256 tokenId, uint256 lossesCount, uint levelDown) external returns (bool);\r\n}\r\n\r\n//Crypto Hero Rocket coin\r\ninterface CHR {\r\n  //  function mint(address _to, uint256 _amount) external returns (bool);\r\n  function burn(address _from, uint256 _amount) external returns (bool);\r\n}\r\n\r\n\r\ncontract Fights is Ownable, ServiceRole, ReentrancyGuard, CanReclaimToken {\r\n  using SafeMath for uint256;\r\n\r\n  event SetFightInterval(uint startsFrom, uint pastFightsCount, uint fightsInterval, uint fightPeriod, uint applicationPeriod, uint betsPeriod);\r\n  event EnterArena(uint tokenId, uint fightId, uint startsAt, uint level, uint enemyRace);\r\n  event ChangeEnemy(uint tokenId, uint fightId, uint enemyRace);\r\n  event LeaveArena(uint tokenId, uint fightId, Result result, uint level);\r\n  event StartFight(uint fightId, uint startAt);\r\n  event RemoveFight(uint fightId);\r\n  event FightResult(uint fightId, uint[] races, uint[] values);\r\n  event FinishFight(uint fightId, uint startedAt, uint finishedAt, uint startCheckedAt, uint finishCheckedAt);\r\n\r\n  HEROES public heroes;\r\n  CHR public coin;\r\n\r\n  enum Result {QUAIL, WIN, LOSS, DRAW}\r\n\r\n  struct Fighter {\r\n    uint index;\r\n    bool exists;\r\n    uint race;\r\n    uint level;\r\n    uint enemyRace;\r\n    bool finished;\r\n  }\r\n\r\n  struct Race {\r\n    uint index;\r\n    bool exists;\r\n    uint count; //число участников данной рассы\r\n    uint enemyCount; //число игроков выбравших эту расу соперником\r\n    uint levelSum; //сумма всех уникальных значений уровней\r\n    //level => count\r\n    mapping(uint => uint) levelCount; // количество участников по уровням\r\n    //результат битвы в универсальных единицах, может быть отрицательным (32бит)\r\n    //измеряется в % изменении курса валюты по отношению к доллару на начало и конец периода\r\n    //пример курс BTC на 12:00 - 6450.33, на 17:00 - 6387.22, изменение = (6387.22 - 6450.33) / 6450.33 = -0,009784 = -0.978%\r\n    //учитываем 3 знака после запятой и переводим в целое число умножи на 1000 = -978\r\n    int32 result;\r\n  }\r\n\r\n  struct Fight {\r\n    uint startedAt;\r\n    uint finishedAt;\r\n    uint startCheckedAt;\r\n    uint finishCheckedAt;\r\n    //index участника => tokenId\r\n    mapping(uint => uint) arena;\r\n    //tokenId => структура Бойца\r\n    mapping(uint => Fighter) fighters;\r\n    uint fightersCount;\r\n    // raceId => Race\r\n    mapping(uint => Race) races;\r\n    // race index => raceId\r\n    mapping(uint => uint) raceList;\r\n    uint raceCount;\r\n  }\r\n\r\n\r\n  //массив произошедших битв, в него помещаются только id состоявшихся битв\r\n  uint[] public fightsList;\r\n  //tokenId => fightId помним ид последней битвы персонажа, чтобы он мог выйти с использованием монетки\r\n  mapping(uint => uint[]) public characterFights;\r\n\r\n  //id битвы, жестко привязан к интервалам времени\r\n  //т.е. если интервал = 1 час, то через 10 часов даже если не было ни одной битвы, id = 10\r\n  //fightId => Fight\r\n  mapping(uint => Fight) fights;\r\n\r\n  //структура описывающая интервалы битв\r\n  struct FightInterval {\r\n    uint fightsInterval;\r\n    uint startsFrom;\r\n    uint fightsCount; //число уже завершенных битв до этого интервала\r\n    uint betsPeriod;\r\n    uint applicationPeriod;\r\n    uint fightPeriod;\r\n  }\r\n\r\n  //массив хранит историю изменений настроек битв\r\n  //чтобы можно было иметь доступ к прошлым битвам, в случае если интервалы изменится\r\n  FightInterval[] public intervalHistory;\r\n\r\n  uint public constant FightEpoch = 1542240000; //Thursday, 15 November 2018 г., 0:00:00\r\n  uint public minBetsLevel = 5;\r\n  bool public allowEnterDuringBets = true;\r\n\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(heroes.ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  constructor(HEROES _heroes, CHR _coin) public {\r\n    require(address(_heroes) != address(0));\r\n    require(address(_coin) != address(0));\r\n    heroes = _heroes;\r\n    coin = _coin;\r\n\r\n    //  uint public fightsInterval = 12 * 60 * 60; //12 hours, интервал с которым проводятся бои\r\n    //  uint public betsPeriod = 2 * 60 * 60; //период в течении которого доступны ставки 2 hours\r\n    //  uint public applicationPeriod = 11 * 60 * 60; //11 hours, период в течении которого можно подать заявку на участие в бою до начала боя\r\n    //  uint public fightPeriod = 5 * 60 * 60;//длительность боя, 5 часов\r\n\r\n    intervalHistory.push(FightInterval({\r\n      fightPeriod: 5 * 60 * 60, //длительность боя, 5 часов,\r\n      startsFrom : FightEpoch,\r\n      fightsCount : 0,\r\n      fightsInterval : 12 * 60 * 60, //12 hours, интервал с которым проводятся бои,\r\n      betsPeriod : 2 * 60 * 60, //период в течении которого доступны ставки 2 hours,\r\n      applicationPeriod : 11 * 60 * 60 //11 hours, период в течении которого можно подать заявку на участие в бою до начала боя\r\n      }));\r\n  }\r\n\r\n  /// @notice The fallback function payable\r\n  function() external payable {\r\n    require(msg.value > 0);\r\n    address(heroes).transfer(msg.value);\r\n  }\r\n\r\n  function addService(address account) public onlyOwner {\r\n    _addService(account);\r\n  }\r\n\r\n  function removeService(address account) public onlyOwner {\r\n    _removeService(account);\r\n  }\r\n\r\n\r\n  //устанавливает новые значения интервалов битв\r\n  function setFightInterval(uint _fightsInterval, uint _applicationPeriod, uint _betsPeriod, uint _fightPeriod) external onlyOwner {\r\n    FightInterval memory i = _getFightIntervalAt(now);\r\n    //todo проверить )\r\n    // количество интервалов прошедших с момента последней записи в истории\r\n    uint intervalsCount = (now - i.startsFrom) / i.fightsInterval + 1;\r\n    FightInterval memory ni = FightInterval({\r\n      fightsInterval : _fightsInterval,\r\n      startsFrom : i.startsFrom + i.fightsInterval * intervalsCount,\r\n      fightsCount : intervalsCount + i.fightsCount,\r\n      applicationPeriod : _applicationPeriod,\r\n      betsPeriod : _betsPeriod,\r\n      fightPeriod : _fightPeriod\r\n      });\r\n    intervalHistory.push(ni);\r\n    emit SetFightInterval(ni.startsFrom, ni.fightsCount, _fightsInterval, _fightPeriod, _applicationPeriod, _betsPeriod);\r\n  }\r\n\r\n  //устанавливает новые значения дополнительных параметров\r\n  function setParameters(uint _minBetsLevel, bool _allowEnterDuringBets) external onlyOwner {\r\n    minBetsLevel = _minBetsLevel;\r\n    allowEnterDuringBets = _allowEnterDuringBets;\r\n  }\r\n\r\n  function enterArena(uint _tokenId, uint _enemyRace) public onlyOwnerOf(_tokenId) {\r\n    //only if finished last fight\r\n    require(isAllowed(_tokenId));\r\n    uint intervalId = _getFightIntervalIdAt(now);\r\n    FightInterval memory i = intervalHistory[intervalId];\r\n    uint nextStartsAt = _getFightStartsAt(intervalId, 1);\r\n    //вступить в арену можно только в период приема заявок\r\n    require(now >= nextStartsAt - i.applicationPeriod);\r\n    //вступить в арену можно только до начала битвы или до начала ставок\r\n    require(now < nextStartsAt - (allowEnterDuringBets ? 0 : i.betsPeriod));\r\n\r\n    uint nextFightId = getFightId(intervalId, 1);\r\n    Fight storage f = fights[nextFightId];\r\n    //на всякий случай, если мы вдруг решим закрыть определенную битву в будущем\r\n//    require(f.finishedAt != 0);\r\n\r\n    //участник еще не на арене\r\n    require(!f.fighters[_tokenId].exists);\r\n\r\n    uint level = heroes.getLevel(_tokenId);\r\n    uint race = heroes.getRace(_tokenId);\r\n    require(race != _enemyRace);\r\n\r\n    //начать fight если он еще не был начат\r\n    if (f.startedAt == 0) {\r\n      f.startedAt = nextStartsAt;\r\n      fightsList.push(nextFightId);\r\n      emit StartFight(nextFightId, nextStartsAt);\r\n      //todo что еще?\r\n    }\r\n\r\n    //добавляем на арену\r\n    f.fighters[_tokenId] = Fighter({\r\n      exists : true,\r\n      finished : false,\r\n      index : f.fightersCount,\r\n      race : race,\r\n      enemyRace : _enemyRace,\r\n      level: level\r\n      });\r\n    f.arena[f.fightersCount++] = _tokenId;\r\n    //запоминаем в списке битв конкретного токена\r\n    characterFights[_tokenId].push(nextFightId);\r\n\r\n    Race storage r = f.races[race];\r\n    if (!r.exists) {\r\n      r.exists = true;\r\n      r.index = f.raceCount;\r\n      f.raceList[f.raceCount++] = race;\r\n    }\r\n    r.count++;\r\n    //для будущего расчета выигрыша\r\n    //учет только игроков 5 и выше уровня\r\n    if (level >= minBetsLevel) {\r\n      //если еще не было участников с таким уровнем, считаем что это новый уникальный\r\n      if (r.levelCount[level] == 0) {\r\n        //суммируем уникальное значения уровня\r\n        r.levelSum = r.levelSum.add(level);\r\n      }\r\n      //счетчик количества игроков с данным уровнем\r\n      r.levelCount[level]++;\r\n    }\r\n    //учтем вражескую расу, просто создаем ее и добавляем в список, без изменения количеств,\r\n    //чтобы потом с бэкенда было проще пройтись по списку рас\r\n    Race storage er = f.races[_enemyRace];\r\n    if (!er.exists) {\r\n      er.exists = true;\r\n      er.index = f.raceCount;\r\n      f.raceList[f.raceCount++] = _enemyRace;\r\n    }\r\n    er.enemyCount++;\r\n\r\n    //устанавливаем блокировку до конца битвы\r\n    require(heroes.lock(_tokenId, nextStartsAt + i.fightPeriod, false));\r\n    emit EnterArena(_tokenId, nextFightId, nextStartsAt, level, _enemyRace);\r\n\r\n  }\r\n\r\n\r\n  function changeEnemy(uint _tokenId, uint _enemyRace) public onlyOwnerOf(_tokenId) {\r\n    uint fightId = characterLastFightId(_tokenId);\r\n\r\n    //последняя битва должны существовать\r\n    require(fightId != 0);\r\n    Fight storage f = fights[fightId];\r\n    Fighter storage fr = f.fighters[_tokenId];\r\n    //участник уже на арене\r\n    //todo излишне, такого быть не должно, проанализировать\r\n    require(fr.exists);\r\n    //только если еще не завершена битва для  данного бойца\r\n    require(!fr.finished);\r\n\r\n    //поменять на новую только\r\n    require(fr.enemyRace != _enemyRace);\r\n\r\n    FightInterval memory i = _getFightIntervalAt(f.startedAt);\r\n\r\n    //требуем либо текущее время до начала ставок\r\n    //todo излишне, достаточно now < f.startedAt - params.betsPeriod\r\n    //т.к. в теории игрок не может находится до начала периода заявок\r\n    require(now >= f.startedAt - i.applicationPeriod && now < f.startedAt - i.betsPeriod && f.finishedAt != 0);\r\n\r\n    fr.enemyRace = _enemyRace;\r\n\r\n    //уменьшаем счетчик расс врагов\r\n    Race storage er_old = f.races[fr.enemyRace];\r\n    er_old.enemyCount--;\r\n\r\n    if (er_old.count == 0 && er_old.enemyCount == 0) {\r\n      f.races[f.raceList[--f.raceCount]].index = er_old.index;\r\n      f.raceList[er_old.index] = f.raceList[f.raceCount];\r\n      delete f.arena[f.raceCount];\r\n      delete f.races[fr.enemyRace];\r\n    }\r\n\r\n    //учтем вражескую расу, просто создаем ее и добавляем в список, без изменения количеств,\r\n    //чтобы потом с бэкенда было проще пройтись по списку рас\r\n    Race storage er_new = f.races[_enemyRace];\r\n    if (!er_new.exists) {\r\n      er_new.index = f.raceCount;\r\n      f.raceList[f.raceCount++] = _enemyRace;\r\n    }\r\n    er_new.enemyCount++;\r\n    emit ChangeEnemy(_tokenId, fightId, _enemyRace);\r\n  }\r\n\r\n  function reenterArena(uint _tokenId, uint _enemyRace, bool _useCoin) public onlyOwnerOf(_tokenId) {\r\n    uint fightId = characterLastFightId(_tokenId);\r\n    //последняя битва должны существовать\r\n    require(fightId != 0);\r\n    Fight storage f = fights[fightId];\r\n    Fighter storage fr = f.fighters[_tokenId];\r\n    //участник уже на арене\r\n    //todo излишне, такого быть не должно, проанализировать\r\n    require(fr.exists);\r\n    //нельзя перезайти из не начатой битвы\r\n//    require (f.startedAt != 0);\r\n\r\n    //только если еще не завершена битва для  данного бойца\r\n    require(!fr.finished);\r\n\r\n    //требуем либо текущее время после конца битвы, которая завершена\r\n    require(f.finishedAt != 0 && now > f.finishedAt);\r\n\r\n    Result result = Result.QUAIL;\r\n\r\n    //обработка результатов\r\n    if (f.races[f.fighters[_tokenId].race].result > f.races[f.fighters[_tokenId].enemyRace].result) {\r\n      result = Result.WIN;\r\n      //wins +1, level + 1\r\n      heroes.addWin(_tokenId, 1, 1);\r\n    } else if (f.races[f.fighters[_tokenId].race].result < f.races[f.fighters[_tokenId].enemyRace].result) {\r\n      result = Result.LOSS;\r\n      //засчитываем поражение\r\n      if (_useCoin) {\r\n        require(coin.burn(heroes.ownerOf(_tokenId), 1));\r\n        //losses +1, level the same\r\n        heroes.addLoss(_tokenId, 1, 0);\r\n      } else {\r\n        //losses +1, level - 1\r\n        heroes.addLoss(_tokenId, 1, 1);\r\n      }\r\n    } else {\r\n      //todo ничья\r\n//      result = Result.QUAIL;\r\n    }\r\n    fr.finished = true;\r\n\r\n    emit LeaveArena(_tokenId, fightId, result, fr.level);\r\n    //вход на арену\r\n    enterArena(_tokenId, _enemyRace);\r\n  }\r\n\r\n\r\n  //покинуть арену можно до начала ставок или после окончания, и естественно только последнюю\r\n  function leaveArena(uint _tokenId, bool _useCoin) public onlyOwnerOf(_tokenId) {\r\n    uint fightId = characterLastFightId(_tokenId);\r\n\r\n    //последняя битва должны существовать\r\n    require(fightId != 0);\r\n    Fight storage f = fights[fightId];\r\n    Fighter storage fr = f.fighters[_tokenId];\r\n    //участник уже на арене\r\n    //todo излишне, такого быть не должно, проанализировать\r\n    require(fr.exists);\r\n\r\n    //нельзя покинуть не начатую битву\r\n    //    require (f.startedAt != 0);\r\n\r\n    //только если еще не завершена битва для  данного бойца\r\n    require(!fr.finished);\r\n\r\n    FightInterval memory i = _getFightIntervalAt(f.startedAt);\r\n\r\n    //требуем либо текущее время до начала ставок, либо уже после конца битвы, которая завершена\r\n    require(now < f.startedAt - i.betsPeriod || (f.finishedAt != 0 && now > f.finishedAt));\r\n    Result result = Result.QUAIL;\r\n    //выход до начала битвы\r\n    if (f.finishedAt == 0) {\r\n\r\n      Race storage r = f.races[fr.race];\r\n      //учет только игроков 5 и выше уровня\r\n      if (fr.level >= minBetsLevel) {\r\n        //уменьшаем счетчик игроков этого уровня\r\n        r.levelCount[fr.level]--;\r\n        //если это был последний игрок\r\n        if (r.levelCount[fr.level] == 0) {\r\n          r.levelSum = r.levelSum.sub(fr.level);\r\n        }\r\n      }\r\n      r.count--;\r\n\r\n      Race storage er = f.races[fr.enemyRace];\r\n      er.enemyCount--;\r\n\r\n      //если больше не осталось игроков в этих расах удаляем их\r\n      if (r.count == 0 && r.enemyCount == 0) {\r\n        f.races[f.raceList[--f.raceCount]].index = r.index;\r\n        f.raceList[r.index] = f.raceList[f.raceCount];\r\n        delete f.arena[f.raceCount];\r\n        delete f.races[fr.race];\r\n      }\r\n      if (er.count == 0 && er.enemyCount == 0) {\r\n          f.races[f.raceList[--f.raceCount]].index = er.index;\r\n        f.raceList[er.index] = f.raceList[f.raceCount];\r\n        delete f.arena[f.raceCount];\r\n        delete f.races[fr.enemyRace];\r\n      }\r\n\r\n      // удалить с арены\r\n      f.fighters[f.arena[--f.fightersCount]].index = fr.index;\r\n      f.arena[fr.index] = f.arena[f.fightersCount];\r\n      delete f.arena[f.fightersCount];\r\n      delete f.fighters[_tokenId];\r\n      //удаляем из списка битв\r\n      delete characterFights[_tokenId][characterFights[_tokenId].length--];\r\n\r\n      //todo если участник последний - то удалить битву\r\n      if (f.fightersCount == 0) {\r\n        delete fights[fightId];\r\n        emit RemoveFight(fightId);\r\n      }\r\n    } else {\r\n\r\n      //выход после окончания битвы\r\n      if (f.races[f.fighters[_tokenId].race].result > f.races[f.fighters[_tokenId].enemyRace].result) {\r\n        result = Result.WIN;\r\n        heroes.addWin(_tokenId, 1, 1);\r\n      } else if (f.races[f.fighters[_tokenId].race].result < f.races[f.fighters[_tokenId].enemyRace].result) {\r\n        result = Result.LOSS;\r\n        //засчитываем поражение\r\n        if (_useCoin) {\r\n          //сжигаем 1 монетку\r\n          require(coin.burn(heroes.ownerOf(_tokenId), 1));\r\n          //при использовании монетки не уменьшаем уровень, при этом счетчик поражений +1\r\n          heroes.addLoss(_tokenId, 1, 0);\r\n        } else {\r\n          heroes.addLoss(_tokenId, 1, 1);\r\n        }\r\n      } else {\r\n        //todo ничья\r\n        result = Result.DRAW;\r\n      }\r\n\r\n      fr.finished = true;\r\n    }\r\n    //разблокируем игрока\r\n    require(heroes.unlock(_tokenId));\r\n    emit LeaveArena(_tokenId, fightId, result, fr.level);\r\n\r\n  }\r\n\r\n  function fightsCount() public view returns (uint) {\r\n    return fightsList.length;\r\n  }\r\n\r\n  //возвращает id битвы актуальный в данный момент\r\n  function getCurrentFightId() public view returns (uint) {\r\n    return getFightId(_getFightIntervalIdAt(now), 0);\r\n  }\r\n\r\n  function getNextFightId() public view returns (uint) {\r\n    return getFightId(_getFightIntervalIdAt(now), 1);\r\n  }\r\n\r\n  function getFightId(uint intervalId, uint nextShift) internal view returns (uint) {\r\n    FightInterval memory i = intervalHistory[intervalId];\r\n    return (now - i.startsFrom) / i.fightsInterval + i.fightsCount + nextShift;\r\n  }\r\n\r\n  function characterFightsCount(uint _tokenId) public view returns (uint) {\r\n    return characterFights[_tokenId].length;\r\n  }\r\n\r\n  function characterLastFightId(uint _tokenId) public view returns (uint) {\r\n    //    require(characterFights[_tokenId].length > 0);\r\n    return characterFights[_tokenId].length > 0 ? characterFights[_tokenId][characterFights[_tokenId].length - 1] : 0;\r\n  }\r\n\r\n  function characterLastFight(uint _tokenId) public view returns (\r\n    uint index,\r\n    uint race,\r\n    uint level,\r\n    uint enemyRace,\r\n    bool finished\r\n  ) {\r\n    return getFightFighter(characterLastFightId(_tokenId), _tokenId);\r\n  }\r\n\r\n  function getFightFighter(uint _fightId, uint _tokenId) public view returns (\r\n    uint index,\r\n    uint race,\r\n    uint level,\r\n    uint enemyRace,\r\n    bool finished\r\n  ) {\r\n    Fighter memory fr = fights[_fightId].fighters[_tokenId];\r\n    return (fr.index, fr.race, fr.level, fr.enemyRace, fr.finished);\r\n  }\r\n\r\n  function getFightArenaFighter(uint _fightId, uint _fighterIndex) public view returns (\r\n    uint tokenId,\r\n    uint race,\r\n    uint level,\r\n    uint enemyRace,\r\n    bool finished\r\n  ) {\r\n    uint _tokenId = fights[_fightId].arena[_fighterIndex];\r\n    Fighter memory fr = fights[_fightId].fighters[_tokenId];\r\n    return (_tokenId, fr.race, fr.level, fr.enemyRace, fr.finished);\r\n  }\r\n\r\n  function getFightRaces(uint _fightId) public view returns(uint[]) {\r\n    Fight storage f = fights[_fightId];\r\n    if (f.startedAt == 0) return;\r\n    uint[] memory r = new uint[](f.raceCount);\r\n    for(uint i; i < f.raceCount; i++) {\r\n      r[i] = f.raceList[i];\r\n    }\r\n    return r;\r\n  }\r\n\r\n  function getFightRace(uint _fightId, uint _race) external view returns (\r\n    uint index,\r\n    uint count, //число участников данной рассы\r\n    uint enemyCount, //число игроков выбравших эту расу соперником\r\n    int32 result\r\n  ){\r\n    Race memory r = fights[_fightId].races[_race];\r\n    return (r.index, r.count, r.enemyCount, r.result);\r\n  }\r\n\r\n  function getFightRaceLevelStat(uint _fightId, uint _race, uint _level) external view returns (\r\n    uint levelCount, //число участников данной рассы данного уровня\r\n    uint levelSum //сумма уникальных значений всех уровней данной рассы\r\n  ){\r\n    Race storage r = fights[_fightId].races[_race];\r\n    return (r.levelCount[_level], r.levelSum);\r\n  }\r\n\r\n  function getFightResult(uint _fightId, uint _tokenId) public view returns (Result) {\r\n//    uint fightId = getCharacterLastFightId(_tokenId);\r\n    //    require(fightId != 0);\r\n    Fight storage f = fights[_fightId];\r\n    Fighter storage fr = f.fighters[_tokenId];\r\n    //участник существует\r\n    if (!fr.exists) {\r\n      return Result.QUAIL;\r\n    }\r\n//    return (int(f.races[fr.race].result) - int(f.races[fr.enemyRace].result));\r\n    return f.races[fr.race].result > f.races[fr.enemyRace].result ? Result.WIN : f.races[fr.race].result < f.races[fr.enemyRace].result ? Result.LOSS : Result.DRAW;\r\n  }\r\n\r\n\r\n  function isAllowed(uint tokenId) public view returns (bool) {\r\n    uint fightId = characterLastFightId(tokenId);\r\n    return fightId == 0 ? true : fights[fightId].fighters[tokenId].finished;\r\n  }\r\n\r\n  function getCurrentFight() public view returns (\r\n    uint256 fightId,\r\n    uint256 startedAt,\r\n    uint256 finishedAt,\r\n    uint256 startCheckedAt,\r\n    uint256 finishCheckedAt,\r\n    uint256 fightersCount,\r\n    uint256 raceCount\r\n  ) {\r\n    fightId = getCurrentFightId();\r\n    (startedAt, finishedAt, startCheckedAt, finishCheckedAt, fightersCount, raceCount) = getFight(fightId);\r\n  }\r\n\r\n  function getNextFight() public view returns (\r\n    uint256 fightId,\r\n    uint256 startedAt,\r\n    uint256 finishedAt,\r\n    uint256 startCheckedAt,\r\n    uint256 finishCheckedAt,\r\n    uint256 fightersCount,\r\n    uint256 raceCount\r\n  ) {\r\n    fightId = getNextFightId();\r\n    (startedAt, finishedAt, startCheckedAt, finishCheckedAt, fightersCount, raceCount) = getFight(fightId);\r\n  }\r\n\r\n  function getFight(uint _fightId) public view returns (\r\n    uint256 startedAt,\r\n    uint256 finishedAt,\r\n    uint256 startCheckedAt,\r\n    uint256 finishCheckedAt,\r\n    uint256 fightersCount,\r\n    uint256 raceCount\r\n  ) {\r\n    Fight memory f = fights[_fightId];\r\n    return (f.startedAt, f.finishedAt, f.startCheckedAt, f.finishCheckedAt, f.fightersCount, f.raceCount);\r\n  }\r\n\r\n  function getNextFightInterval() external view returns (\r\n    uint fightId,\r\n    uint currentTime,\r\n    uint applicationStartAt,\r\n    uint betsStartAt,\r\n    uint fightStartAt,\r\n    uint fightFinishAt\r\n  ) {\r\n    uint intervalId = _getFightIntervalIdAt(now);\r\n    fightId = getFightId(intervalId, 1);\r\n    (currentTime, applicationStartAt, betsStartAt, fightStartAt, fightFinishAt) = _getFightInterval(intervalId, 1);\r\n  }\r\n\r\n  function getCurrentFightInterval() external view returns (\r\n    uint fightId,\r\n    uint currentTime,\r\n    uint applicationStartAt,\r\n    uint betsStartAt,\r\n    uint fightStartAt,\r\n    uint fightFinishAt\r\n  ) {\r\n    uint intervalId = _getFightIntervalIdAt(now);\r\n    fightId = getFightId(intervalId, 0);\r\n    (currentTime, applicationStartAt, betsStartAt, fightStartAt, fightFinishAt) = _getFightInterval(intervalId, 0);\r\n  }\r\n\r\n  function _getFightInterval(uint intervalId, uint nextShift) internal view returns (\r\n//    uint fightId,\r\n    uint currentTime,\r\n    uint applicationStartAt,\r\n    uint betsStartAt,\r\n    uint fightStartAt,\r\n    uint fightFinishAt\r\n  ) {\r\n\r\n    fightStartAt = _getFightStartsAt(intervalId, nextShift);\r\n\r\n    FightInterval memory i = intervalHistory[intervalId];\r\n    currentTime = now;\r\n    applicationStartAt = fightStartAt - i.applicationPeriod;\r\n    betsStartAt = fightStartAt - i.betsPeriod;\r\n    fightFinishAt = fightStartAt + i.fightPeriod;\r\n  }\r\n\r\n  function _getFightStartsAt(uint intervalId, uint nextShift) internal view returns (uint) {\r\n    FightInterval memory i = intervalHistory[intervalId];\r\n    uint intervalsCount = (now - i.startsFrom) / i.fightsInterval + nextShift;\r\n    return i.startsFrom + i.fightsInterval * intervalsCount;\r\n  }\r\n\r\n\r\n  function getCurrentIntervals() external view returns (\r\n    uint fightsInterval,\r\n    uint fightPeriod,\r\n    uint applicationPeriod,\r\n    uint betsPeriod\r\n  ) {\r\n    FightInterval memory i = _getFightIntervalAt(now);\r\n    fightsInterval = i.fightsInterval;\r\n    fightPeriod = i.fightPeriod;\r\n    applicationPeriod = i.applicationPeriod;\r\n    betsPeriod = i.betsPeriod;\r\n  }\r\n\r\n\r\n  function _getFightIntervalAt(uint _time)  internal view returns (FightInterval memory) {\r\n    return intervalHistory[_getFightIntervalIdAt(_time)];\r\n  }\r\n\r\n\r\n  function _getFightIntervalIdAt(uint _time)  internal view returns (uint) {\r\n    require(intervalHistory.length>0);\r\n    //    if (intervalHistory.length == 0) return 0;\r\n\r\n    // Shortcut for the actual value\r\n    if (_time >= intervalHistory[intervalHistory.length - 1].startsFrom)\r\n      return intervalHistory.length - 1;\r\n    if (_time < intervalHistory[0].startsFrom) return 0;\r\n\r\n    // Binary search of the value in the array\r\n    uint min = 0;\r\n    uint max = intervalHistory.length - 1;\r\n    while (max > min) {\r\n      uint mid = (max + min + 1) / 2;\r\n      if (intervalHistory[mid].startsFrom <= _time) {\r\n        min = mid;\r\n      } else {\r\n        max = mid - 1;\r\n      }\r\n    }\r\n    return min;\r\n  }\r\n\r\n\r\n  //устанавливает результаты для битвы для всех расс\r\n  //принимает 2 соответствующих массива id расс и значений результата битвы\r\n  //значения 32битные, упакованы в uint256\r\n  // !!! закрытие битвы отдельной функцией, т.к. результатов может быть очень много и не уложится в один вызов !!!\r\n  function setFightResult(uint fightId, uint count, uint[] packedRaces, uint[] packedResults) public onlyService {\r\n    require(packedRaces.length == packedResults.length);\r\n    require(packedRaces.length * 8 >= count);\r\n\r\n    Fight storage f = fights[fightId];\r\n    require(f.startedAt != 0 && f.finishedAt == 0);\r\n\r\n    //    f.finishedAt = now;\r\n    for (uint i = 0; i < count; i++) {\r\n//      for (uint n = 0; n < 8 || ; n++) {\r\n        f.races[_upack(packedRaces[i / 8], i % 8)].result = int32(_upack(packedResults[i / 8], i % 8));\r\n//      }\r\n    }\r\n    emit FightResult(fightId, packedRaces, packedResults);\r\n\r\n  }\r\n\r\n  //close the fight, save check points time\r\n  function finishFight(uint fightId, uint startCheckedAt, uint finishCheckedAt) public onlyService {\r\n    Fight storage f = fights[fightId];\r\n    require(f.startedAt != 0 && f.finishedAt == 0);\r\n    FightInterval memory i = _getFightIntervalAt(f.startedAt);\r\n    //нельзя закрыть до истечения периода битвы\r\n    require(now >= f.startedAt + i.fightPeriod);\r\n    f.finishedAt = now;\r\n    f.startCheckedAt = startCheckedAt;\r\n    f.finishCheckedAt = finishCheckedAt;\r\n    emit FinishFight(fightId, f.startedAt, f.finishedAt, startCheckedAt, finishCheckedAt);\r\n  }\r\n\r\n  //extract n-th 32-bit int from uint\r\n  function _upack(uint _v, uint _n) internal pure returns (uint) {\r\n    //    _n = _n & 7; //be sure < 8\r\n    return (_v >> (32 * _n)) & 0xFFFFFFFF;\r\n  }\r\n\r\n  //merge n-th 32-bit int to uint\r\n  function _puck(uint _v, uint _n, uint _x) internal pure returns (uint) {\r\n    //    _n = _n & 7; //be sure < 8\r\n    //number = number & ~(1 << n) | (x << n);\r\n    return _v & ~(0xFFFFFFFF << (32 * _n)) | ((_x & 0xFFFFFFFF) << (32 * _n));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_fightId\",\"type\":\"uint256\"}],\"name\":\"getFightRaces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFightId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBetsLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fightId\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"}],\"name\":\"finishFight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fightsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heroes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFight\",\"outputs\":[{\"name\":\"fightId\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"},{\"name\":\"fightersCount\",\"type\":\"uint256\"},{\"name\":\"raceCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fightId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getFightFighter\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"race\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"characterLastFight\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"race\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fightId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getFightResult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fightId\",\"type\":\"uint256\"},{\"name\":\"_race\",\"type\":\"uint256\"}],\"name\":\"getFightRace\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"enemyCount\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fightsList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFightInterval\",\"outputs\":[{\"name\":\"fightId\",\"type\":\"uint256\"},{\"name\":\"currentTime\",\"type\":\"uint256\"},{\"name\":\"applicationStartAt\",\"type\":\"uint256\"},{\"name\":\"betsStartAt\",\"type\":\"uint256\"},{\"name\":\"fightStartAt\",\"type\":\"uint256\"},{\"name\":\"fightFinishAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"characterFights\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fightId\",\"type\":\"uint256\"},{\"name\":\"_race\",\"type\":\"uint256\"},{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getFightRaceLevelStat\",\"outputs\":[{\"name\":\"levelCount\",\"type\":\"uint256\"},{\"name\":\"levelSum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_enemyRace\",\"type\":\"uint256\"},{\"name\":\"_useCoin\",\"type\":\"bool\"}],\"name\":\"reenterArena\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fightId\",\"type\":\"uint256\"}],\"name\":\"getFight\",\"outputs\":[{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"},{\"name\":\"fightersCount\",\"type\":\"uint256\"},{\"name\":\"raceCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fightsInterval\",\"type\":\"uint256\"},{\"name\":\"_applicationPeriod\",\"type\":\"uint256\"},{\"name\":\"_betsPeriod\",\"type\":\"uint256\"},{\"name\":\"_fightPeriod\",\"type\":\"uint256\"}],\"name\":\"setFightInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fightId\",\"type\":\"uint256\"},{\"name\":\"_fighterIndex\",\"type\":\"uint256\"}],\"name\":\"getFightArenaFighter\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"race\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"enemyRace\",\"type\":\"uint256\"},{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minBetsLevel\",\"type\":\"uint256\"},{\"name\":\"_allowEnterDuringBets\",\"type\":\"bool\"}],\"name\":\"setParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextFightId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowEnterDuringBets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FightEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fightId\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"packedRaces\",\"type\":\"uint256[]\"},{\"name\":\"packedResults\",\"type\":\"uint256[]\"}],\"name\":\"setFightResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextFight\",\"outputs\":[{\"name\":\"fightId\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"name\":\"finishCheckedAt\",\"type\":\"uint256\"},{\"name\":\"fightersCount\",\"type\":\"uint256\"},{\"name\":\"raceCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"characterFightsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextFightInterval\",\"outputs\":[{\"name\":\"fightId\",\"type\":\"uint256\"},{\"name\":\"currentTime\",\"type\":\"uint256\"},{\"name\":\"applicationStartAt\",\"type\":\"uint256\"},{\"name\":\"betsStartAt\",\"type\":\"uint256\"},{\"name\":\"fightStartAt\",\"type\":\"uint256\"},{\"name\":\"fightFinishAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_enemyRace\",\"type\":\"uint256\"}],\"name\":\"enterArena\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentIntervals\",\"outputs\":[{\"name\":\"fightsInterval\",\"type\":\"uint256\"},{\"name\":\"fightPeriod\",\"type\":\"uint256\"},{\"name\":\"applicationPeriod\",\"type\":\"uint256\"},{\"name\":\"betsPeriod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_useCoin\",\"type\":\"bool\"}],\"name\":\"leaveArena\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"intervalHistory\",\"outputs\":[{\"name\":\"fightsInterval\",\"type\":\"uint256\"},{\"name\":\"startsFrom\",\"type\":\"uint256\"},{\"name\":\"fightsCount\",\"type\":\"uint256\"},{\"name\":\"betsPeriod\",\"type\":\"uint256\"},{\"name\":\"applicationPeriod\",\"type\":\"uint256\"},{\"name\":\"fightPeriod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"characterLastFightId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_enemyRace\",\"type\":\"uint256\"}],\"name\":\"changeEnemy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_heroes\",\"type\":\"address\"},{\"name\":\"_coin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startsFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pastFightsCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightsInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"applicationPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betsPeriod\",\"type\":\"uint256\"}],\"name\":\"SetFightInterval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startsAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"enemyRace\",\"type\":\"uint256\"}],\"name\":\"EnterArena\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"enemyRace\",\"type\":\"uint256\"}],\"name\":\"ChangeEnemy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"LeaveArena\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fightId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startAt\",\"type\":\"uint256\"}],\"name\":\"StartFight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fightId\",\"type\":\"uint256\"}],\"name\":\"RemoveFight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fightId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"races\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"FightResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fightId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startCheckedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finishCheckedAt\",\"type\":\"uint256\"}],\"name\":\"FinishFight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ServiceAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ServiceRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Fights","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d2bae9a30a40376d25353773010ffe52dba0d68800000000000000000000000004c271ef0e8dd18a24c194ae7e72d74398b3b4b0","Library":"","SwarmSource":"bzzr://f99b744a2eb8d48c4a31296b86052f5cf578220eef8053c1aa4a8e2b84f984f8"}]}