{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n*..................................Mokens......................................*\r\n*.....................General purpose cryptocollectibles.......................*\r\n*..............................................................................*\r\n/******************************************************************************/\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, <nick@mokens.io>\r\n* Copyright (c) 2018\r\n*\r\n* The Mokens contract is a proxy contract that delegates all functionality\r\n* to delegate contracts. This design enables new functionality and improvements\r\n* to be added to the Mokens contract over time.\r\n*\r\n* Changes to the Mokens contract are transparent and visible. To make changes\r\n* easier to monitor the ContractUpdated event is emitted any time a function is\r\n* added, removed or updated. The ContractUpdated event exists in the\r\n* MokenUpdates delegate contract\r\n*\r\n* The source code for all delegate contracts used by the Mokens contract can be\r\n* found online and inspected.\r\n*\r\n* The Mokens contract is reflective or self inspecting. It contains functions\r\n* for inspecting what delegate contracts it has and what functions they have.\r\n* Specifically, the QueryMokenDelegates delegate contract contains functions for\r\n* querying delegate contracts and functions.\r\n*\r\n*    Here are some of the other delegate contracts:\r\n*\r\n*  - MokenERC721: Implements the ERC721 standard for mokens.\r\n*  - MokenERC721Batch: Implements batch transfers and approvals.\r\n*  - MokenERC998ERC721TopDown: Implements ERC998 composable functionality.\r\n*  - MokenERC998ERC20TopDown: Implements ERC998 composable functionality.\r\n*  - MokenERC998ERC721BottomUp: Implements ERC998 composable functionality.\r\n*  - MokenMinting: Implements moken minting functionality.\r\n*  - MokenEras: Implements moken era functionality.\r\n*  - QueryMokenData: Implements functions to query info about mokens.\r\n/******************************************************************************/\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n// All storage variables are declared here\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Storage version 0\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Contract Management\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n    address internal contractOwner;\r\n    string[] internal functionSignatures;\r\n    // signature => index+1\r\n    mapping(string => uint256) internal functionSignatureToIndex;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //SupportsInterfaces\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //RootOwnerOf\r\n    //ERC721Metadata\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n    //tokenId => moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength;\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC721\r\n    //ERC721Enumerable\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC998ERC721TopDown\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC998ERC20TopDown\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC998ERC721BottomUp\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Era\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // index => era\r\n    mapping(uint256 => bytes32) internal eras;\r\n    uint256 internal eraLength;\r\n    // era => index+1\r\n    mapping(bytes32 => uint256) internal eraIndex;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Minting\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    uint256 internal mintPriceOffset; // = 0 szabo;\r\n    uint256 internal mintStepPrice; // = 500 szabo;\r\n    uint256 internal mintPriceBuffer; // = 5000 szabo;\r\n    address[] internal mintContracts;\r\n    mapping(address => uint256) internal mintContractIndex;\r\n    //moken name => tokenId+1\r\n    mapping(string => uint256) internal tokenByName_;\r\n}\r\n\r\ncontract Mokens is Storage0 {\r\n    constructor(address mokenUpdates) public {\r\n        //0x584fc325 == \"initializeMokensContract()\"\r\n        bytes memory calldata = abi.encodeWithSelector(0x584fc325,mokenUpdates);\r\n        assembly {\r\n            let callSuccess := delegatecall(gas, mokenUpdates, add(calldata, 0x20), mload(calldata), 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(calldata, 0, size)\r\n            if eq(callSuccess,0) {revert(calldata, size)}\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        address delegate = delegates[msg.sig];\r\n        require(delegate != address(0), \"Mokens function does not exist.\");\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n            switch result\r\n            case 0 {revert(ptr, size)}\r\n            default {return (ptr, size)}\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"name\":\"mokenUpdates\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Mokens","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"0000000000000000000000002ece144c64132ee748e83955e2e12ee84df0a9b2","Library":"","SwarmSource":"bzzr://2bfc4b8f591747c90e04b5c63bde926667592d436e6a5b3c93049221654b07ea"}]}