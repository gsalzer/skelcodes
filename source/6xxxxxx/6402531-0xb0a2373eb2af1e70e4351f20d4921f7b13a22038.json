{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/** \r\nDo not transfer tokens to TimelockERC20 directly (via transfer method)! Tokens will be stuck permanently.\r\nUse approvals and accept method.\r\n**/\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\ncontract IERC20{\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address who) external view returns (uint);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  \r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ITimeMachine {\r\n  function getTimestamp_() internal view returns (uint);\r\n}\r\n\r\n\r\ncontract TimeMachineP is ITimeMachine {\r\n  /**\r\n  * @dev get current real timestamp\r\n  * @return current real timestamp\r\n  */\r\n  function getTimestamp_() internal view returns(uint) {\r\n    return block.timestamp;\r\n  }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract SafeERC20Timelock is ITimeMachine, Ownable {\r\n  using SafeMath for uint;\r\n\r\n  event Lock(address indexed _from, address indexed _for, uint indexed timestamp, uint value);\r\n  event Withdraw(address indexed _for, uint indexed timestamp, uint value);\r\n\r\n\r\n\r\n  mapping (address => mapping(uint => uint)) public balance;\r\n  IERC20 public token;\r\n  uint public totalBalance;\r\n\r\n  constructor (address _token) public {\r\n    token = IERC20(_token);\r\n  }\r\n\r\n  function contractBalance_() internal view returns(uint) {\r\n    return token.balanceOf(this);\r\n  }\r\n\r\n  /**\r\n  * @dev accept token into timelock\r\n  * @param _for address of future tokenholder\r\n  * @param _timestamp lock timestamp\r\n  * @return result of operation: true if success\r\n  */\r\n  function accept(address _for, uint _timestamp, uint _tvalue) public returns(bool){\r\n    require(_for != address(0));\r\n    require(_for != address(this));\r\n    require(_timestamp > getTimestamp_());\r\n    require(_tvalue > 0);\r\n    uint _contractBalance = contractBalance_();\r\n    uint _balance = balance[_for][_timestamp];\r\n    uint _totalBalance = totalBalance;\r\n    require(token.transferFrom(msg.sender, this, _tvalue));\r\n    uint _value = contractBalance_().sub(_contractBalance);\r\n    balance[_for][_timestamp] = _balance.add(_value);\r\n    totalBalance = _totalBalance.add(_value);\r\n    emit Lock(msg.sender, _for, _timestamp, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev release timelock tokens\r\n  * @param _for address of future tokenholder\r\n  * @param _timestamp array of timestamps to unlock\r\n  * @param _value array of amounts to unlock\r\n  * @return result of operation: true if success\r\n  */\r\n  function release_(address _for, uint[] _timestamp, uint[] _value) internal returns(bool) {\r\n    uint _len = _timestamp.length;\r\n    require(_len == _value.length);\r\n    uint _totalValue;\r\n    uint _curValue;\r\n    uint _curTimestamp;\r\n    uint _subValue;\r\n    uint _now = getTimestamp_();\r\n    for (uint i = 0; i < _len; i++){\r\n      _curTimestamp = _timestamp[i];\r\n      _curValue = balance[_for][_curTimestamp];\r\n      _subValue = _value[i];\r\n      require(_curValue >= _subValue);\r\n      require(_curTimestamp <= _now);\r\n      balance[_for][_curTimestamp] = _curValue.sub(_subValue);\r\n      _totalValue = _totalValue.add(_subValue);\r\n      emit Withdraw(_for, _curTimestamp, _subValue);\r\n    }\r\n    totalBalance = totalBalance.sub(_totalValue);\r\n    require(token.transfer(_for, _totalValue));\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev release timelock tokens\r\n  * @param _timestamp array of timestamps to unlock\r\n  * @param _value array of amounts to unlock\r\n  * @return result of operation: true if success\r\n  */\r\n  function release(uint[] _timestamp, uint[] _value) external returns(bool) {\r\n    return release_(msg.sender, _timestamp, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev release timelock tokens by force\r\n  * @param _for address of future tokenholder\r\n  * @param _timestamp array of timestamps to unlock\r\n  * @param _value array of amounts to unlock\r\n  * @return result of operation: true if success\r\n  */\r\n  function releaseForce(address _for, uint[] _timestamp, uint[] _value) external returns(bool) {\r\n    return release_(_for, _timestamp, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Allow to use functions of other contract from this contract\r\n  * @param _token address of ERC20 contract to call\r\n  * @param _to address to transfer ERC20 tokens\r\n  * @param _amount amount to transfer\r\n  * @return result of operation, true if success\r\n  */\r\n  function saveLockedERC20Tokens(address _token, address _to, uint  _amount) onlyOwner external returns (bool) {\r\n    require(IERC20(_token).transfer(_to, _amount));\r\n    require(totalBalance <= contractBalance_());\r\n    return true;\r\n  }\r\n\r\n  function () public payable {\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\ncontract SafeERC20TimelockProd is TimeMachineP, SafeERC20Timelock {\r\n  constructor () public SafeERC20Timelock(0x45245bc59219eeaaf6cd3f382e078a461ff9de7b) {\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"releaseForce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_tvalue\",\"type\":\"uint256\"}],\"name\":\"accept\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"saveLockedERC20Tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_for\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_for\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SafeERC20TimelockProd","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://29f90a9330d3e5c4017ec455240345f032b6be6d97a9f7c20f2e5fa2f379a44c"}]}