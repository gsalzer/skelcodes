{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: contracts/EventRegistry.sol\r\n\r\ncontract EventRegistry {\r\n    address[] verityEvents;\r\n    mapping(address => bool) verityEventsMap;\r\n\r\n    mapping(address => address[]) userEvents;\r\n\r\n    event NewVerityEvent(address eventAddress);\r\n\r\n    function registerEvent() public {\r\n        verityEvents.push(msg.sender);\r\n        verityEventsMap[msg.sender] = true;\r\n        emit NewVerityEvent(msg.sender);\r\n    }\r\n\r\n    function getUserEvents() public view returns(address[]) {\r\n        return userEvents[msg.sender];\r\n    }\r\n\r\n    function addEventToUser(address _user) external {\r\n        require(verityEventsMap[msg.sender]);\r\n\r\n        userEvents[_user].push(msg.sender);\r\n    }\r\n\r\n    function getEventsLength() public view returns(uint) {\r\n        return verityEvents.length;\r\n    }\r\n\r\n    function getEventsByIds(uint[] _ids) public view returns(uint[], address[]) {\r\n        address[] memory _events = new address[](_ids.length);\r\n\r\n        for(uint i = 0; i < _ids.length; ++i) {\r\n            _events[i] = verityEvents[_ids[i]];\r\n        }\r\n\r\n        return (_ids, _events);\r\n    }\r\n\r\n    function getUserEventsLength(address _user)\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return userEvents[_user].length;\r\n    }\r\n\r\n    function getUserEventsByIds(address _user, uint[] _ids)\r\n        public\r\n        view\r\n        returns(uint[], address[])\r\n    {\r\n        address[] memory _events = new address[](_ids.length);\r\n\r\n        for(uint i = 0; i < _ids.length; ++i) {\r\n            _events[i] = userEvents[_user][_ids[i]];\r\n        }\r\n\r\n        return (_ids, _events);\r\n    }\r\n}\r\n\r\n// File: contracts/VerityToken.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract VerityToken is StandardToken {\r\n  string public name = \"VerityToken\";\r\n  string public symbol = \"VTY\";\r\n  uint8 public decimals = 18;\r\n  uint public INITIAL_SUPPLY = 500000000 * 10 ** uint(decimals);\r\n\r\n  constructor() public {\r\n    totalSupply_ = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n  }\r\n}\r\n\r\n// File: contracts/VerityEvent.sol\r\n\r\ncontract VerityEvent {\r\n    /// Contract's owner, used for permission management\r\n    address public owner;\r\n\r\n    /// Token contract address, used for tokend distribution\r\n    address public tokenAddress;\r\n\r\n    /// Event registry contract address\r\n    address public eventRegistryAddress;\r\n\r\n    /// Designated validation nodes that will decide rewards.\r\n    address[] eventResolvers;\r\n\r\n    /// - WaitingForRewards: Waiting for current master to set rewards.\r\n    /// - Validating: Master has set rewards. Vaiting for node validation.\r\n    /// - Finished: Either successfully validated or failed.\r\n    enum ValidationState {\r\n        WaitingForRewards,\r\n        Validating,\r\n        Finished\r\n    }\r\n    ValidationState validationState = ValidationState.WaitingForRewards;\r\n\r\n    struct RewardsValidation {\r\n        address currentMasterNode;\r\n        string rewardsHash;\r\n        uint approvalCount;\r\n        uint rejectionCount;\r\n        string[] altHashes;\r\n        mapping(address => uint) votersRound;\r\n        mapping(string => address[]) altHashVotes;\r\n        mapping(string => bool) rejectedHashes;\r\n    }\r\n    RewardsValidation rewardsValidation;\r\n\r\n    /// Round of validation. Increases by each failed validation\r\n    uint public rewardsValidationRound;\r\n\r\n    /// A list of all the participating wallet addresses, implemented as a mapping\r\n    /// to provide constant lookup times.\r\n    mapping(address => bool) participants;\r\n    address[] participantsIndex;\r\n\r\n    enum RewardType {\r\n        Ether,\r\n        Token\r\n    }\r\n    RewardType rewardType;\r\n\r\n    /// A mapping of addresses to their assigned rewards\r\n    mapping(address => mapping(uint => uint)) rewards;\r\n    address[] rewardsIndex;\r\n\r\n    /// Event application start time, users cannot apply to participate before it\r\n    uint applicationStartTime;\r\n\r\n    /// Event application end time, users cannot apply after this time\r\n    uint applicationEndTime;\r\n\r\n    /// Event actual start time, votes before this should not be accepted\r\n    uint eventStartTime;\r\n\r\n    /// Event end time, it is calculated in the constructor\r\n    uint eventEndTime;\r\n\r\n    /// Ipfs event data hash\r\n    string ipfsEventHash;\r\n\r\n    /// Event name, here for informational use - not used otherwise\r\n    /// owner can recover tokens and ether after this time\r\n    uint leftoversRecoverableAfter;\r\n\r\n    /// Amount of tokens that each user must stake before voting.\r\n    uint public stakingAmount;\r\n\r\n    struct Dispute {\r\n        uint amount;\r\n        uint timeout;\r\n        uint round;\r\n        uint expiresAt;\r\n        uint multiplier;\r\n        mapping(address => bool) disputers;\r\n        address currentDisputer;\r\n    }\r\n    Dispute dispute;\r\n\r\n    uint defaultDisputeTimeExtension = 1800; // 30 minutes\r\n\r\n    string public eventName;\r\n\r\n    /// Data feed hash, used for verification\r\n    string public dataFeedHash;\r\n\r\n    bytes32[] results;\r\n\r\n    enum RewardsDistribution {\r\n        Linear, // 0\r\n        Exponential // 1\r\n    }\r\n\r\n    struct ConsensusRules {\r\n        uint minTotalVotes;\r\n        uint minConsensusVotes;\r\n        uint minConsensusRatio;\r\n        uint minParticipantRatio;\r\n        uint maxParticipants;\r\n        RewardsDistribution rewardsDistribution;\r\n    }\r\n    ConsensusRules consensusRules;\r\n\r\n    /// Event's states\r\n    /// Events advance in the order defined here. Once the event reaches \"Reward\"\r\n    /// state, it cannot advance further.\r\n    /// Event states:\r\n    ///   - Waiting         -- Contract has been created, nothing is happening yet\r\n    ///   - Application     -- After applicationStartTime, the event advances here\r\n    ///                        new wallets can be added to the participats list during this state.\r\n    ///   - Running         -- Event is running, no new participants can be added\r\n    ///   - DisputeTimeout  -- Dispute possible\r\n    ///   - Reward          -- Participants can claim their payouts here - final state; can't be modified.\r\n    ///   - Failed          -- Event failed (no consensus, not enough users, timeout, ...) - final state; can't be modified\r\n    enum EventStates {\r\n        Waiting,\r\n        Application,\r\n        Running,\r\n        DisputeTimeout,\r\n        Reward,\r\n        Failed\r\n    }\r\n    EventStates eventState = EventStates.Waiting;\r\n\r\n    event StateTransition(EventStates newState);\r\n    event JoinEvent(address wallet);\r\n    event ClaimReward(address recipient);\r\n    event Error(string description);\r\n    event EventFailed(string description);\r\n    event ValidationStarted(uint validationRound);\r\n    event ValidationRestart(uint validationRound);\r\n    event DisputeTriggered(address byAddress);\r\n    event ClaimStake(address recipient);\r\n\r\n    constructor(\r\n        string _eventName,\r\n        uint _applicationStartTime,\r\n        uint _applicationEndTime,\r\n        uint _eventStartTime,\r\n        uint _eventRunTime, // in seconds\r\n        address _tokenAddress,\r\n        address _registry,\r\n        address[] _eventResolvers,\r\n        uint _leftoversRecoverableAfter, // with timestamp (in seconds)\r\n        uint[6] _consensusRules, // [minTotalVotes, minConsensusVotes, minConsensusRatio, minParticipantRatio, maxParticipants, distribution]\r\n        uint _stakingAmount,\r\n        uint[3] _disputeRules, // [dispute amount, dispute timeout, dispute multiplier]\r\n        string _ipfsEventHash\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        require(_applicationStartTime < _applicationEndTime);\r\n        require(_eventStartTime > _applicationEndTime, \"Event can't start before applications close.\");\r\n\r\n        applicationStartTime = _applicationStartTime;\r\n        applicationEndTime = _applicationEndTime;\r\n        tokenAddress = _tokenAddress;\r\n\r\n        eventName = _eventName;\r\n        eventStartTime = _eventStartTime;\r\n        eventEndTime = _eventStartTime + _eventRunTime;\r\n\r\n        eventResolvers = _eventResolvers;\r\n\r\n        owner = msg.sender;\r\n        leftoversRecoverableAfter = _leftoversRecoverableAfter;\r\n\r\n        rewardsValidationRound = 1;\r\n        rewardsValidation.currentMasterNode = eventResolvers[0];\r\n\r\n        stakingAmount = _stakingAmount;\r\n\r\n        ipfsEventHash = _ipfsEventHash;\r\n\r\n        setConsensusRules(_consensusRules);\r\n        setDisputeData(_disputeRules);\r\n\r\n        eventRegistryAddress = _registry;\r\n\r\n        EventRegistry(eventRegistryAddress).registerEvent();\r\n    }\r\n\r\n    /// A modifier signifiying that a certain method can only be used by the creator\r\n    /// of the contract.\r\n    /// Rollbacks the transaction on failure.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// A modifier signifiying that rewards can be set only by the designated master node.\r\n    /// Rollbacks the transaction on failure.\r\n    modifier onlyCurrentMaster() {\r\n        require(\r\n            msg.sender == rewardsValidation.currentMasterNode,\r\n            \"Not a designated master node.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    ///\tA modifier signifying that a certain method can only be used by a wallet\r\n    ///\tmarked as a participant.\r\n    ///\tRollbacks the transaction or failure.\r\n    modifier onlyParticipating() {\r\n        require(\r\n            isParticipating(msg.sender),\r\n            \"Not participating.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// A modifier signifying that a certain method can only be used when the event\r\n    /// is in a certain state.\r\n    /// @param _state The event's required state\r\n    /// Example:\r\n    /// \tfunction claimReward() onlyParticipanting onlyState(EventStates.Reward) {\r\n    /// \t\t// ... content\r\n    /// \t}\r\n    modifier onlyState(EventStates _state) {\r\n        require(\r\n            _state == eventState,\r\n            \"Not possible in current event state.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// A modifier taking care of all the timed state transitions.\r\n    /// Should always be used before all other modifiers, especially `onlyState`,\r\n    /// since it can change state.\r\n    /// Should probably be used in ALL non-constant (transaction) methods of\r\n    /// the contract.\r\n    modifier timedStateTransition() {\r\n        if (eventState == EventStates.Waiting && now >= applicationStartTime) {\r\n            advanceState();\r\n        }\r\n\r\n        if (eventState == EventStates.Application && now >= applicationEndTime) {\r\n            if (participantsIndex.length < consensusRules.minTotalVotes) {\r\n                markAsFailed(\"Not enough users joined for required minimum votes.\");\r\n            } else {\r\n                advanceState();\r\n            }\r\n        }\r\n\r\n        if (eventState == EventStates.DisputeTimeout && now >= dispute.expiresAt) {\r\n            advanceState();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyChangeableState() {\r\n        require(\r\n            uint(eventState) < uint(EventStates.Reward),\r\n            \"Event state can't be modified anymore.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterLefroversCanBeRecovered() {\r\n        require(now >= leftoversRecoverableAfter);\r\n        _;\r\n    }\r\n\r\n    modifier canValidateRewards(uint forRound) {\r\n        require(\r\n            isNode(msg.sender) && !isMasterNode(),\r\n            \"Not a valid sender address.\"\r\n        );\r\n\r\n        require(\r\n            validationState == ValidationState.Validating,\r\n            \"Not validating rewards.\"\r\n        );\r\n\r\n        require(\r\n            forRound == rewardsValidationRound,\r\n            \"Validation round mismatch.\"\r\n        );\r\n\r\n        require(\r\n            rewardsValidation.votersRound[msg.sender] < rewardsValidationRound,\r\n            \"Already voted for this round.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// Ensure we can receive money at any time.\r\n    /// Not used, but we might want to extend the reward fund while event is running.\r\n    function() public payable {}\r\n\r\n    /// Apply for participation in this event.\r\n    /// Available only during the Application state.\r\n    /// A transaction to this function has to be done by the users themselves,\r\n    /// registering their wallet address as a participent.\r\n    /// The transaction does not have to include any funds.\r\n    function joinEvent()\r\n        public\r\n        timedStateTransition\r\n    {\r\n        if (isParticipating(msg.sender)) {\r\n            emit Error(\"You are already participating.\");\r\n            return;\r\n        }\r\n\r\n        if (eventState != EventStates.Application) {\r\n            emit Error(\"You can only join in the Application state.\");\r\n            return;\r\n        }\r\n\r\n        if (\r\n            stakingAmount > 0 &&\r\n            VerityToken(tokenAddress).allowance(msg.sender, address(this)) < stakingAmount\r\n        ) {\r\n            emit Error(\"Not enough tokens staked.\");\r\n            return;\r\n        }\r\n\r\n        if (stakingAmount > 0) {\r\n            VerityToken(tokenAddress).transferFrom(msg.sender, address(this), stakingAmount);\r\n        }\r\n        participants[msg.sender] = true;\r\n        participantsIndex.push(msg.sender);\r\n        EventRegistry(eventRegistryAddress).addEventToUser(msg.sender);\r\n        emit JoinEvent(msg.sender);\r\n    }\r\n\r\n    /// Checks whether an address is participating in this event.\r\n    /// @param _user The addres to check for participation\r\n    /// @return {bool} Whether the given address is a participant of this event\r\n    function isParticipating(address _user) public view returns(bool) {\r\n        return participants[_user];\r\n    }\r\n\r\n    function getParticipants() public view returns(address[]) {\r\n        return participantsIndex;\r\n    }\r\n\r\n    function getEventTimes() public view returns(uint[5]) {\r\n        return [\r\n            applicationStartTime,\r\n            applicationEndTime,\r\n            eventStartTime,\r\n            eventEndTime,\r\n            leftoversRecoverableAfter\r\n        ];\r\n    }\r\n\r\n    /// Assign the actual rewards.\r\n    /// Receives a list of addresses and a list rewards. Mapping between the two\r\n    /// is done by the addresses' and reward's numerical index in the list, so\r\n    /// order is important.\r\n    /// @param _addresses A list of addresses\r\n    /// @param _etherRewards A list of ether rewards, must be the exact same length as addresses\r\n    /// @param _tokenRewards A list of token rewards, must be the exact same length as addresses\r\n    function setRewards(\r\n        address[] _addresses,\r\n        uint[] _etherRewards,\r\n        uint[] _tokenRewards\r\n    )\r\n        public\r\n        onlyCurrentMaster\r\n        timedStateTransition\r\n        onlyState(EventStates.Running)\r\n    {\r\n        require(\r\n            _addresses.length == _etherRewards.length &&\r\n            _addresses.length == _tokenRewards.length\r\n        );\r\n\r\n        require(\r\n            validationState == ValidationState.WaitingForRewards,\r\n            \"Not possible in this validation state.\"\r\n        );\r\n\r\n        for (uint i = 0; i < _addresses.length; ++i) {\r\n            rewards[_addresses[i]][uint(RewardType.Ether)] = _etherRewards[i];\r\n            rewards[_addresses[i]][uint(RewardType.Token)] = _tokenRewards[i];\r\n            rewardsIndex.push(_addresses[i]);\r\n        }\r\n    }\r\n\r\n    /// Triggered by the master node once rewards are set and ready to validate\r\n    function markRewardsSet(string rewardsHash)\r\n        public\r\n        onlyCurrentMaster\r\n        timedStateTransition\r\n        onlyState(EventStates.Running)\r\n    {\r\n        require(\r\n            validationState == ValidationState.WaitingForRewards,\r\n            \"Not possible in this validation state.\"\r\n        );\r\n\r\n        rewardsValidation.rewardsHash = rewardsHash;\r\n        rewardsValidation.approvalCount = 1;\r\n        validationState = ValidationState.Validating;\r\n        emit ValidationStarted(rewardsValidationRound);\r\n    }\r\n\r\n    /// Called by event resolver nodes if they agree with rewards\r\n    function approveRewards(uint validationRound)\r\n        public\r\n        onlyState(EventStates.Running)\r\n        canValidateRewards(validationRound)\r\n    {\r\n        ++rewardsValidation.approvalCount;\r\n        rewardsValidation.votersRound[msg.sender] = rewardsValidationRound;\r\n        checkApprovalRatio();\r\n    }\r\n\r\n    /// Called by event resolvers if they don't agree with rewards\r\n    function rejectRewards(uint validationRound, string altHash)\r\n        public\r\n        onlyState(EventStates.Running)\r\n        canValidateRewards(validationRound)\r\n    {\r\n        ++rewardsValidation.rejectionCount;\r\n        rewardsValidation.votersRound[msg.sender] = rewardsValidationRound;\r\n\r\n        if (!rewardsValidation.rejectedHashes[altHash]) {\r\n            rewardsValidation.altHashes.push(altHash);\r\n            rewardsValidation.altHashVotes[altHash].push(msg.sender);\r\n        }\r\n\r\n        checkRejectionRatio();\r\n    }\r\n\r\n    /// Trigger a dispute.\r\n    function triggerDispute()\r\n        public\r\n        timedStateTransition\r\n        onlyParticipating\r\n        onlyState(EventStates.DisputeTimeout)\r\n    {\r\n        require(\r\n            VerityToken(tokenAddress).allowance(msg.sender, address(this)) >=\r\n            dispute.amount * dispute.multiplier**dispute.round,\r\n            \"Not enough tokens staked for dispute.\"\r\n        );\r\n\r\n        require(\r\n            dispute.disputers[msg.sender] == false,\r\n            \"Already triggered a dispute.\"\r\n        );\r\n\r\n        /// Increase dispute amount for next dispute and store disputer\r\n        dispute.amount = dispute.amount * dispute.multiplier**dispute.round;\r\n        ++dispute.round;\r\n        dispute.disputers[msg.sender] = true;\r\n        dispute.currentDisputer = msg.sender;\r\n\r\n        /// Transfer staked amount\r\n        VerityToken(tokenAddress).transferFrom(msg.sender, address(this), dispute.amount);\r\n\r\n        /// Restart event\r\n        deleteValidationData();\r\n        deleteRewards();\r\n        eventState = EventStates.Application;\r\n        applicationEndTime = eventStartTime = now + defaultDisputeTimeExtension;\r\n        eventEndTime = eventStartTime + defaultDisputeTimeExtension;\r\n\r\n        /// Make consensus rules stricter\r\n        /// Increases by ~10% of consensus diff\r\n        consensusRules.minConsensusRatio += (100 - consensusRules.minConsensusRatio) * 100 / 1000;\r\n        /// Increase total votes required my ~10% and consensus votes by consensus ratio\r\n        uint votesIncrease = consensusRules.minTotalVotes * 100 / 1000;\r\n        consensusRules.minTotalVotes += votesIncrease;\r\n        consensusRules.minConsensusVotes += votesIncrease * consensusRules.minConsensusRatio / 100;\r\n\r\n        emit DisputeTriggered(msg.sender);\r\n    }\r\n\r\n    /// Checks current approvals for threshold\r\n    function checkApprovalRatio() private {\r\n        if (approvalRatio() >= consensusRules.minConsensusRatio) {\r\n            validationState = ValidationState.Finished;\r\n            dispute.expiresAt = now + dispute.timeout;\r\n            advanceState();\r\n        }\r\n    }\r\n\r\n    /// Checks current rejections for threshold\r\n    function checkRejectionRatio() private {\r\n        if (rejectionRatio() >= (100 - consensusRules.minConsensusRatio)) {\r\n            rejectCurrentValidation();\r\n        }\r\n    }\r\n\r\n    /// Handle the rejection of current rewards\r\n    function rejectCurrentValidation() private {\r\n        rewardsValidation.rejectedHashes[rewardsValidation.rewardsHash] = true;\r\n\r\n        // If approved votes are over the threshold all other hashes will also fail\r\n        if (\r\n            rewardsValidation.approvalCount + rewardsValidationRound - 1 >\r\n            rewardsValidation.rejectionCount - rewardsValidation.altHashes.length + 1\r\n        ) {\r\n            markAsFailed(\"Consensus can't be reached\");\r\n        } else {\r\n            restartValidation();\r\n        }\r\n    }\r\n\r\n    function restartValidation() private {\r\n        ++rewardsValidationRound;\r\n        rewardsValidation.currentMasterNode = rewardsValidation.altHashVotes[rewardsValidation.altHashes[0]][0];\r\n\r\n        deleteValidationData();\r\n        deleteRewards();\r\n\r\n        emit ValidationRestart(rewardsValidationRound);\r\n    }\r\n\r\n    /// Delete rewards.\r\n    function deleteRewards() private {\r\n        for (uint j = 0; j < rewardsIndex.length; ++j) {\r\n            rewards[rewardsIndex[j]][uint(RewardType.Ether)] = 0;\r\n            rewards[rewardsIndex[j]][uint(RewardType.Token)] = 0;\r\n        }\r\n        delete rewardsIndex;\r\n    }\r\n\r\n    /// Delete validation data\r\n    function deleteValidationData() private {\r\n        rewardsValidation.approvalCount = 0;\r\n        rewardsValidation.rejectionCount = 0;\r\n        for (uint i = 0; i < rewardsValidation.altHashes.length; ++i) {\r\n            delete rewardsValidation.altHashVotes[rewardsValidation.altHashes[i]];\r\n        }\r\n        delete rewardsValidation.altHashes;\r\n        validationState = ValidationState.WaitingForRewards;\r\n    }\r\n\r\n    /// Ratio of nodes that approved of current hash\r\n    function approvalRatio() private view returns(uint) {\r\n        return rewardsValidation.approvalCount * 100 / eventResolvers.length;\r\n    }\r\n\r\n    /// Ratio of nodes that rejected the current hash\r\n    function rejectionRatio() private view returns(uint) {\r\n        return rewardsValidation.rejectionCount * 100 / eventResolvers.length;\r\n    }\r\n\r\n    /// Returns the whole array of event resolvers.\r\n    function getEventResolvers() public view returns(address[]) {\r\n        return eventResolvers;\r\n    }\r\n\r\n    /// Checks if the address is current master node.\r\n    function isMasterNode() public view returns(bool) {\r\n        return rewardsValidation.currentMasterNode == msg.sender;\r\n    }\r\n\r\n    function isNode(address node) private view returns(bool) {\r\n        for(uint i = 0; i < eventResolvers.length; ++i) {\r\n            if(eventResolvers[i] == node) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// Returns the calling user's assigned rewards. Can be 0.\r\n    /// Only available to participating users in the Reward state, since rewards\r\n    /// are not assigned before that.\r\n    function getReward()\r\n        public\r\n        view\r\n        returns(uint[2])\r\n    {\r\n        return [\r\n            rewards[msg.sender][uint(RewardType.Ether)],\r\n            rewards[msg.sender][uint(RewardType.Token)]\r\n        ];\r\n    }\r\n\r\n    /// Returns all the addresses that have rewards set.\r\n    function getRewardsIndex() public view returns(address[]) {\r\n        return rewardsIndex;\r\n    }\r\n\r\n    /// Returns rewards for specified addresses.\r\n    /// [[ethRewards, tokenRewards], [ethRewards, tokenRewards], ...]\r\n    function getRewards(address[] _addresses)\r\n        public\r\n        view\r\n        returns(uint[], uint[])\r\n    {\r\n        uint[] memory ethRewards = new uint[](_addresses.length);\r\n        uint[] memory tokenRewards = new uint[](_addresses.length);\r\n\r\n        for(uint i = 0; i < _addresses.length; ++i) {\r\n            ethRewards[i] = rewards[_addresses[i]][uint(RewardType.Ether)];\r\n            tokenRewards[i] = rewards[_addresses[i]][uint(RewardType.Token)];\r\n        }\r\n\r\n        return (ethRewards, tokenRewards);\r\n    }\r\n\r\n    /// Claim a reward.\r\n    /// Needs to be called by the users themselves.\r\n    /// Only available in the Reward state, after rewards have been received from\r\n    /// the validation nodes.\r\n    function claimReward()\r\n        public\r\n        onlyParticipating\r\n        timedStateTransition\r\n        onlyState(EventStates.Reward)\r\n    {\r\n        uint etherReward = rewards[msg.sender][uint(RewardType.Ether)];\r\n        uint tokenReward = rewards[msg.sender][uint(RewardType.Token)];\r\n\r\n        if (etherReward == 0 && tokenReward == 0) {\r\n            emit Error(\"You do not have any rewards to claim.\");\r\n            return;\r\n        }\r\n\r\n        if (\r\n            address(this).balance < rewards[msg.sender][uint(RewardType.Ether)] ||\r\n            VerityToken(tokenAddress).balanceOf(address(this)) < rewards[msg.sender][uint(RewardType.Token)]\r\n        ) {\r\n            emit Error(\"Critical error: not enough balance to pay out reward. Contact Verity.\");\r\n            return;\r\n        }\r\n\r\n        rewards[msg.sender][uint(RewardType.Ether)] = 0;\r\n        rewards[msg.sender][uint(RewardType.Token)] = 0;\r\n\r\n        msg.sender.transfer(etherReward);\r\n        if (tokenReward > 0) {\r\n            VerityToken(tokenAddress).transfer(msg.sender, tokenReward);\r\n        }\r\n\r\n        emit ClaimReward(msg.sender);\r\n    }\r\n\r\n    function claimFailed()\r\n        public\r\n        onlyParticipating\r\n        timedStateTransition\r\n        onlyState(EventStates.Failed)\r\n    {\r\n        require(\r\n            stakingAmount > 0,\r\n            \"No stake to claim\"\r\n        );\r\n\r\n        VerityToken(tokenAddress).transfer(msg.sender, stakingAmount);\r\n        participants[msg.sender] = false;\r\n        emit ClaimStake(msg.sender);\r\n    }\r\n\r\n    function setDataFeedHash(string _hash) public onlyOwner {\r\n        dataFeedHash = _hash;\r\n    }\r\n\r\n    function setResults(bytes32[] _results)\r\n        public\r\n        onlyCurrentMaster\r\n        timedStateTransition\r\n        onlyState(EventStates.Running)\r\n    {\r\n        results = _results;\r\n    }\r\n\r\n    function getResults() public view returns(bytes32[]) {\r\n        return results;\r\n    }\r\n\r\n    function getState() public view returns(uint) {\r\n        return uint(eventState);\r\n    }\r\n\r\n    function getBalance() public view returns(uint[2]) {\r\n        return [\r\n            address(this).balance,\r\n            VerityToken(tokenAddress).balanceOf(address(this))\r\n        ];\r\n    }\r\n\r\n    /// Returns an array of consensus rules.\r\n    /// [minTotalVotes, minConsensusVotes, minConsensusRatio, minParticipantRatio, maxParticipants]\r\n    function getConsensusRules() public view returns(uint[6]) {\r\n        return [\r\n            consensusRules.minTotalVotes,\r\n            consensusRules.minConsensusVotes,\r\n            consensusRules.minConsensusRatio,\r\n            consensusRules.minParticipantRatio,\r\n            consensusRules.maxParticipants,\r\n            uint(consensusRules.rewardsDistribution)\r\n        ];\r\n    }\r\n\r\n    /// Returns an array of dispute rules.\r\n    /// [dispute amount, dispute timeout, dispute round]\r\n    function getDisputeData() public view returns(uint[4], address) {\r\n        return ([\r\n            dispute.amount,\r\n            dispute.timeout,\r\n            dispute.multiplier,\r\n            dispute.round\r\n        ], dispute.currentDisputer);\r\n    }\r\n\r\n    function recoverLeftovers()\r\n        public\r\n        onlyOwner\r\n        onlyAfterLefroversCanBeRecovered\r\n    {\r\n        owner.transfer(address(this).balance);\r\n        uint tokenBalance = VerityToken(tokenAddress).balanceOf(address(this));\r\n        VerityToken(tokenAddress).transfer(owner, tokenBalance);\r\n    }\r\n\r\n    /// Advances the event's state to the next one. Only for internal use.\r\n    function advanceState() private onlyChangeableState {\r\n        eventState = EventStates(uint(eventState) + 1);\r\n        emit StateTransition(eventState);\r\n    }\r\n\r\n    /// Sets consensus rules. For internal use only.\r\n    function setConsensusRules(uint[6] rules) private {\r\n        consensusRules.minTotalVotes = rules[0];\r\n        consensusRules.minConsensusVotes = rules[1];\r\n        consensusRules.minConsensusRatio = rules[2];\r\n        consensusRules.minParticipantRatio = rules[3];\r\n        consensusRules.maxParticipants = rules[4];\r\n        consensusRules.rewardsDistribution = RewardsDistribution(rules[5]);\r\n    }\r\n\r\n    function markAsFailed(string description) private onlyChangeableState {\r\n        eventState = EventStates.Failed;\r\n        emit EventFailed(description);\r\n    }\r\n\r\n    function setDisputeData(uint[3] rules) private {\r\n        uint _multiplier = rules[2];\r\n        if (_multiplier <= 1) {\r\n            _multiplier = 1;\r\n        }\r\n\r\n        dispute.amount = rules[0];\r\n        dispute.timeout = rules[1];\r\n        dispute.multiplier = _multiplier;\r\n        dispute.round = 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"rewardsValidationRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventRegistryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMasterNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_etherRewards\",\"type\":\"uint256[]\"},{\"name\":\"_tokenRewards\",\"type\":\"uint256[]\"}],\"name\":\"setRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataFeedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"setDataFeedHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResults\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rewardsHash\",\"type\":\"string\"}],\"name\":\"markRewardsSet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"getRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRewardsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventResolvers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validationRound\",\"type\":\"uint256\"},{\"name\":\"altHash\",\"type\":\"string\"}],\"name\":\"rejectRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConsensusRules\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[6]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validationRound\",\"type\":\"uint256\"}],\"name\":\"approveRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_results\",\"type\":\"bytes32[]\"}],\"name\":\"setResults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recoverLeftovers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isParticipating\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"joinEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_eventName\",\"type\":\"string\"},{\"name\":\"_applicationStartTime\",\"type\":\"uint256\"},{\"name\":\"_applicationEndTime\",\"type\":\"uint256\"},{\"name\":\"_eventStartTime\",\"type\":\"uint256\"},{\"name\":\"_eventRunTime\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_eventResolvers\",\"type\":\"address[]\"},{\"name\":\"_leftoversRecoverableAfter\",\"type\":\"uint256\"},{\"name\":\"_consensusRules\",\"type\":\"uint256[6]\"},{\"name\":\"_stakingAmount\",\"type\":\"uint256\"},{\"name\":\"_disputeRules\",\"type\":\"uint256[3]\"},{\"name\":\"_ipfsEventHash\",\"type\":\"string\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"JoinEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"EventFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validationRound\",\"type\":\"uint256\"}],\"name\":\"ValidationStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validationRound\",\"type\":\"uint256\"}],\"name\":\"ValidationRestart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"byAddress\",\"type\":\"address\"}],\"name\":\"DisputeTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ClaimStake\",\"type\":\"event\"}]","ContractName":"VerityEvent","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000005a730140000000000000000000000000000000000000000000000000000000005c10dcd0000000000000000000000000000000000000000000000000000000005c10dd0c000000000000000000000000000000000000000000000000000000000000c3500000000000000000000000007ba8a5d59b21390a70b2ba968a183712e12a049c0000000000000000000000008fe4d35c5bcc714b97e93999ff1fa18691ebaf3a00000000000000000000000000000000000000000000000000000000000002e0000000000000000000000000000000000000000000000000000000000000c73800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000003c0000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000002c4d6f7374206f66207573206861766520656174656e20612073706964657220696e206f757220736c6565702e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000036ea5b38740a747eead5f473f41d8531b5364be000000000000000000000000191d9603282537f9225281c1a7afa6a75e00cf75000000000000000000000000243284de5e76a5c0493ce7b7f4fe9f33cfdda12a00000000000000000000000000000000000000000000000000000000000000086970667368617368000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://55dadf00f9451ee698b8a63887185899fcc57f091bc3f68ccf6381e792d1ce95"}]}