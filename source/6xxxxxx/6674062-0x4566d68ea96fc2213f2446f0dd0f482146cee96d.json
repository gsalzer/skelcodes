{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract EternalStorage {\r\n\r\n    /// @notice Internal mappings used to store all kinds on data into the contract\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n    mapping(bytes32 => bytes32) internal bytes32Storage;\r\n\r\n    /// @notice Internal mappings used to store arrays of different data types\r\n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\r\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\r\n    mapping(bytes32 => address[]) internal addressArrayStorage;\r\n    mapping(bytes32 => string[]) internal stringArrayStorage;\r\n\r\n    //////////////////\r\n    //// set functions\r\n    //////////////////\r\n    /// @notice Set the key values using the Overloaded `set` functions\r\n    /// Ex- string version = \"0.0.1\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"version\"), \"0.0.1\");\r\n    /// same for the other variables as well some more example listed below\r\n    /// ex1 - address securityTokenAddress = 0x123; replace to\r\n    /// set(keccak256(abi.encodePacked(\"securityTokenAddress\"), 0x123);\r\n    /// ex2 - bytes32 tokenDetails = \"I am ST20\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"tokenDetails\"), \"I am ST20\");\r\n    /// ex3 - mapping(string => address) ownedToken;\r\n    /// set(keccak256(abi.encodePacked(\"ownedToken\", \"Chris\")), 0x123);\r\n    /// ex4 - mapping(string => uint) tokenIndex;\r\n    /// tokenIndex[\"TOKEN\"] = 1; replace to set(keccak256(abi.encodePacked(\"tokenIndex\", \"TOKEN\"), 1);\r\n    /// ex5 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// registeredSymbols[\"TOKEN\"].name = \"MyFristToken\"; replace to set(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"), \"MyFirstToken\");\r\n    /// More generalized- set(keccak256(abi.encodePacked(\"registeredSymbols_<struct variable>\", \"keyname\"), \"value\");\r\n\r\n    function set(bytes32 _key, uint256 _value) internal {\r\n        uintStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, address _value) internal {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bool _value) internal {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bytes32 _value) internal {\r\n        bytes32Storage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, string _value) internal {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    ////////////////////\r\n    /// get functions\r\n    ////////////////////\r\n    /// @notice Get function use to get the value of the singleton state variables\r\n    /// Ex1- string public version = \"0.0.1\";\r\n    /// string _version = getString(keccak256(abi.encodePacked(\"version\"));\r\n    /// Ex2 - assert(temp1 == temp2); replace to\r\n    /// assert(getUint(keccak256(abi.encodePacked(temp1)) == getUint(keccak256(abi.encodePacked(temp2));\r\n    /// Ex3 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// string _name = getString(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"));\r\n\r\n    function getBool(bytes32 _key) internal view returns (bool) {\r\n        return boolStorage[_key];\r\n    }\r\n\r\n    function getUint(bytes32 _key) internal view returns (uint256) {\r\n        return uintStorage[_key];\r\n    }\r\n\r\n    function getAddress(bytes32 _key) internal view returns (address) {\r\n        return addressStorage[_key];\r\n    }\r\n\r\n    function getString(bytes32 _key) internal view returns (string) {\r\n        return stringStorage[_key];\r\n    }\r\n\r\n    function getBytes32(bytes32 _key) internal view returns (bytes32) {\r\n        return bytes32Storage[_key];\r\n    }\r\n\r\n\r\n    ////////////////////////////\r\n    // deleteArray functions\r\n    ////////////////////////////\r\n    /// @notice Function used to delete the array element.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// For deleting the item from array developers needs to create a funtion for that similarly\r\n    /// in this case we have the helper function deleteArrayBytes32() which will do it for us\r\n    /// deleteArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1), 3); -- it will delete the index 3\r\n\r\n\r\n    //Deletes from mapping (bytes32 => array[]) at index _index\r\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\r\n        address[] storage array = addressArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\r\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\r\n        bytes32[] storage array = bytes32ArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => uint[]) at index _index\r\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\r\n        uint256[] storage array = uintArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => string[]) at index _index\r\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\r\n        string[] storage array = stringArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    ////////////////////////////\r\n    //// pushArray functions\r\n    ///////////////////////////\r\n    /// @notice Below are the helper functions to facilitate storing arrays of different data types.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByTicker;\r\n    /// tokensOwnedByTicker[owner] = tokensOwnedByTicker[owner].push(\"xyz\"); replace with\r\n    /// pushArray(keccak256(abi.encodePacked(\"tokensOwnedByTicker\", owner), \"xyz\");\r\n\r\n    /// @notice use to store the values for the array\r\n    /// @param _key bytes32 type\r\n    /// @param _value [uint256, string, bytes32, address] any of the data type in array\r\n    function pushArray(bytes32 _key, address _value) internal {\r\n        addressArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, string _value) internal {\r\n        stringArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, uint256 _value) internal {\r\n        uintArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    /////////////////////////\r\n    //// Set Array functions\r\n    ////////////////////////\r\n    /// @notice used to intialize the array\r\n    /// Ex1- mapping (address => address[]) public reputation;\r\n    /// reputation[0x1] = new address[](0); It can be replaced as\r\n    /// setArray(hash('reputation', 0x1), new address[](0)); \r\n    \r\n    function setArray(bytes32 _key, address[] _value) internal {\r\n        addressArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, uint256[] _value) internal {\r\n        uintArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, bytes32[] _value) internal {\r\n        bytes32ArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, string[] _value) internal {\r\n        stringArrayStorage[_key] = _value;\r\n    }\r\n\r\n    /////////////////////////\r\n    /// getArray functions\r\n    /////////////////////////\r\n    /// @notice Get functions to get the array of the required data type\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)); It return the bytes32 array\r\n    /// Ex2- uint256 _len =  tokensOwnedByOwner[0x1].length; replace with\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)).length;\r\n\r\n    function getArrayAddress(bytes32 _key) internal view returns(address[]) {\r\n        return addressArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayBytes32(bytes32 _key) internal view returns(bytes32[]) {\r\n        return bytes32ArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayString(bytes32 _key) internal view returns(string[]) {\r\n        return stringArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayUint(bytes32 _key) internal view returns(uint[]) {\r\n        return uintArrayStorage[_key];\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    /// setArrayIndexValue() functions\r\n    ///////////////////////////////////\r\n    /// @notice set the value of particular index of the address array\r\n    /// Ex1- mapping(bytes32 => address[]) moduleList;\r\n    /// general way is -- moduleList[moduleType][index] = temp; \r\n    /// It can be re-write as -- setArrayIndexValue(keccak256(abi.encodePacked('moduleList', moduleType)), index, temp); \r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\r\n        addressArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\r\n        uintArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string _value) internal {\r\n        stringArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n        /////////////////////////////\r\n        /// Public getters functions\r\n        /////////////////////////////\r\n\r\n    function getUintValues(bytes32 _variable) public view returns(uint256) {\r\n        return uintStorage[_variable];\r\n    }\r\n\r\n    function getBoolValues(bytes32 _variable) public view returns(bool) {\r\n        return boolStorage[_variable];\r\n    }\r\n\r\n    function getStringValues(bytes32 _variable) public view returns(string) {\r\n        return stringStorage[_variable];\r\n    }\r\n\r\n    function getAddressValues(bytes32 _variable) public view returns(address) {\r\n        return addressStorage[_variable];\r\n    }\r\n\r\n    function getBytes32Values(bytes32 _variable) public view returns(bytes32) {\r\n        return bytes32Storage[_variable];\r\n    }\r\n\r\n    function getBytesValues(bytes32 _variable) public view returns(bytes) {\r\n        return bytesStorage[_variable];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function _implementation() internal view returns (address);\r\n\r\n    /**\r\n    * @dev Fallback function.\r\n    * Implemented entirely in `_fallback`.\r\n    */\r\n    function _fallback() internal {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function _delegate(address implementation) internal {\r\n        /*solium-disable-next-line security/no-inline-assembly*/\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n\r\n    function () public payable {\r\n        _fallback();\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n\r\n    // Version name of the current implementation\r\n    string internal __version;\r\n\r\n    // Address of the current implementation\r\n    address internal __implementation;\r\n\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param _newVersion representing the version name of the upgraded implementation\r\n    * @param _newImplementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(string _newVersion, address indexed _newImplementation);\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newVersion representing the version name of the new implementation to be set\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(string _newVersion, address _newImplementation) internal {\r\n        require(\r\n            __implementation != _newImplementation && _newImplementation != address(0),\r\n            \"Old address is not allowed and implementation address should not be 0x\"\r\n        );\r\n        require(AddressUtils.isContract(_newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n        require(bytes(_newVersion).length > 0, \"Version should not be empty string\");\r\n        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), \"New version equals to current\");\r\n        __version = _newVersion;\r\n        __implementation = _newImplementation;\r\n        emit Upgraded(_newVersion, _newImplementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n\r\n    // Owner of the contract\r\n    address private __upgradeabilityOwner;\r\n\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param _previousOwner representing the address of the previous owner\r\n    * @param _newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address _previousOwner, address _newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier ifOwner() {\r\n        if (msg.sender == _upgradeabilityOwner()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor() public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function _upgradeabilityOwner() internal view returns (address) {\r\n        return __upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {\r\n        require(_newUpgradeabilityOwner != address(0), \"Address should not be 0x\");\r\n        __upgradeabilityOwner = _newUpgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function to provide the address of the implementation contract\r\n    */\r\n    function _implementation() internal view returns (address) {\r\n        return __implementation;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the proxy owner\r\n    * @return the address of the proxy owner\r\n    */\r\n    function proxyOwner() external ifOwner returns (address) {\r\n        return _upgradeabilityOwner();\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the version name of the current implementation\r\n    * @return string representing the name of the current version\r\n    */\r\n    function version() external ifOwner returns (string) {\r\n        return __version;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() external ifOwner returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) external ifOwner {\r\n        require(_newOwner != address(0), \"Address should not be 0x\");\r\n        emit ProxyOwnershipTransferred(_upgradeabilityOwner(), _newOwner);\r\n        _setUpgradeabilityOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(string _newVersion, address _newImplementation) external ifOwner {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation\r\n    * to initialize whatever is needed through a low level call.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n    * signature of the implementation to be called with the needed payload\r\n    */\r\n    function upgradeToAndCall(string _newVersion, address _newImplementation, bytes _data) external payable ifOwner {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n        /*solium-disable-next-line security/no-call-value*/\r\n        require(address(this).call.value(msg.value)(_data), \"Fail in executing the function of implementation contract\");\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ModuleRegistryProxy\r\n * @dev This proxy holds the storage of the ModuleRegistry contract and delegates every call to the current implementation set.\r\n * Besides, it allows upgrading the contract's behaviour towards further implementations, and provides basic\r\n * authorization control functionalities\r\n */\r\n/*solium-disable-next-line no-empty-blocks*/\r\ncontract ModuleRegistryProxy is EternalStorage, OwnedUpgradeabilityProxy {\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBoolValues\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getUintValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVersion\",\"type\":\"string\"},{\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getStringValues\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVersion\",\"type\":\"string\"},{\"name\":\"_newImplementation\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytes32Values\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getAddressValues\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytesValues\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ProxyOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newVersion\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]","ContractName":"ModuleRegistryProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e5343f1a791e80d37ed22d19b5b82616a96002df85f9d211517f55176bbc0eb9"}]}