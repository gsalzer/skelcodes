{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Brave3d {\r\n\r\n    struct Stage {\r\n        uint8 cnt;\r\n        uint256 blocknumber;\r\n        bool isFinish;\r\n        uint8 deadIndex;\r\n        mapping(uint8 => address) playerMap;\r\n    }\r\n\r\n\r\n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n\r\n    address constant private  OFFICIAL = 0x97397C2129517f82031a28742247465BC75E1849;\r\n    address constant private  OFFICIAL_P3D = 0x97397C2129517f82031a28742247465BC75E1849;\r\n\r\n    uint8 constant private MAX_PLAYERS = 3;\r\n    uint256 constant private PRICE = 0.1 ether;\r\n    uint256 constant private P3D_VALUE = 0.019 ether;\r\n    uint256 constant private REFEREE_VALUE = 0.007 ether;\r\n    uint256 constant private  WIN_VALUE = 0.13 ether;\r\n\r\n    mapping(address => uint256) private _valueMap;\r\n    mapping(address => uint256) private _referredMap;\r\n    mapping(address => address) private _addressMap;\r\n    mapping(string => address)  private _nameAddressMap;\r\n    mapping(address => string)  private _addressNameMap;\r\n\r\n    mapping(uint8 => mapping(uint256 => Stage)) private _stageMap;\r\n    mapping(uint8 => uint256) private _finishMap;\r\n    mapping(uint8 => uint256) private _currentMap;\r\n\r\n    event BravePlayer(address indexed player, uint8 rate);\r\n    event BraveDeadPlayer(address indexed deadPlayer, uint8 rate);\r\n    event BraveWithdraw(address indexed player, uint256 indexed amount);\r\n    event BraveInvalidateStage(uint256 indexed stage, uint8 rate);\r\n\r\n\r\n    modifier hasEarnings()\r\n    {\r\n        require(_valueMap[msg.sender] > 0);\r\n        _;\r\n    }\r\n\r\n    modifier isExistsOfNameAddressMap(string name){\r\n        require(_nameAddressMap[name]==0);\r\n        _;\r\n    }\r\n\r\n    modifier isExistsOfAddressNameMap(){\r\n        require(bytes(_addressNameMap[msg.sender]).length<=0);\r\n        _;\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        _stageMap[1][0] = Stage(0, 0, false, 0);\r\n        _stageMap[5][0] = Stage(0, 0, false, 0);\r\n        _stageMap[10][0] = Stage(0, 0, false, 0);\r\n\r\n        _currentMap[1] = 1;\r\n        _currentMap[5] = 1;\r\n        _currentMap[10] = 1;\r\n\r\n        _finishMap[1] = 0;\r\n        _finishMap[5] = 0;\r\n        _finishMap[10] = 0;\r\n\r\n        _nameAddressMap[\"\"] = OFFICIAL;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function buyByAddress(address referee)\r\n    external\r\n    payable\r\n    {\r\n        uint8 rate = 1;\r\n        if (msg.value == PRICE) {\r\n            rate = 1;\r\n        } else if (msg.value == PRICE * 5) {\r\n            rate = 5;\r\n        } else if (msg.value == PRICE * 10) {\r\n            rate = 10;\r\n        } else {\r\n            require(false);\r\n        }\r\n\r\n        resetStage(rate);\r\n\r\n        buy(rate);\r\n\r\n        overStage(rate);\r\n\r\n        if (_addressMap[msg.sender] == 0) {\r\n            if (referee != 0x0000000000000000000000000000000000000000 && referee != msg.sender && _valueMap[referee] > 0) {\r\n                _addressMap[msg.sender] = referee;\r\n            } else {\r\n                _addressMap[msg.sender] = OFFICIAL;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setName(string name)\r\n    external\r\n    isExistsOfNameAddressMap(name)\r\n    isExistsOfAddressNameMap\r\n    {\r\n        _nameAddressMap[name] = msg.sender;\r\n        _addressNameMap[msg.sender] = name;\r\n\r\n        overStage(1);\r\n        overStage(5);\r\n        overStage(10);\r\n    }\r\n\r\n    function getName()\r\n    external\r\n    view\r\n    returns (string)\r\n    {\r\n        return _addressNameMap[msg.sender];\r\n    }\r\n\r\n\r\n    function buyByName(string name)\r\n    external\r\n    payable\r\n    {\r\n        uint8 rate = 1;\r\n        if (msg.value == PRICE) {\r\n            rate = 1;\r\n        } else if (msg.value == PRICE * 5) {\r\n            rate = 5;\r\n        } else if (msg.value == PRICE * 10) {\r\n            rate = 10;\r\n        } else {\r\n            require(false);\r\n        }\r\n\r\n        resetStage(rate);\r\n\r\n        buy(rate);\r\n\r\n        overStage(rate);\r\n\r\n        if (_addressMap[msg.sender] == 0) {\r\n\r\n            if (_nameAddressMap[name] == 0) {\r\n\r\n                _addressMap[msg.sender] = OFFICIAL;\r\n\r\n            } else {\r\n\r\n                address referee = _nameAddressMap[name];\r\n                if (referee != 0x0000000000000000000000000000000000000000 && referee != msg.sender && _valueMap[referee] > 0) {\r\n\r\n                    _addressMap[msg.sender] = referee;\r\n                } else {\r\n\r\n                    _addressMap[msg.sender] = OFFICIAL;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function buyFromValue(uint8 rate)\r\n    external\r\n    {\r\n        require(rate == 1 || rate == 5 || rate == 10);\r\n        require(_valueMap[msg.sender] >= PRICE * rate);\r\n\r\n        resetStage(rate);\r\n\r\n        _valueMap[msg.sender] -= PRICE * rate;\r\n\r\n        buy(rate);\r\n\r\n        overStage(rate);\r\n    }\r\n\r\n    function withdraw()\r\n    external\r\n    hasEarnings\r\n    {\r\n\r\n        uint256 amount = _valueMap[msg.sender];\r\n        _valueMap[msg.sender] = 0;\r\n\r\n        emit BraveWithdraw(msg.sender, amount);\r\n\r\n        msg.sender.transfer(amount);\r\n\r\n        overStage(1);\r\n        overStage(5);\r\n        overStage(10);\r\n    }\r\n\r\n    function myEarnings()\r\n    external\r\n    view\r\n    hasEarnings\r\n    returns (uint256)\r\n    {\r\n        return _valueMap[msg.sender];\r\n    }\r\n\r\n    function getEarnings(address adr)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return _valueMap[adr];\r\n    }\r\n\r\n    function myReferee()\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return _referredMap[msg.sender];\r\n    }\r\n\r\n    function getReferee(address adr)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return _referredMap[adr];\r\n    }\r\n\r\n    function getRefereeAddress(address adr)\r\n    external\r\n    view\r\n    returns (address)\r\n    {\r\n        return _addressMap[adr];\r\n    }\r\n\r\n    function currentStageData(uint8 rate)\r\n    external\r\n    view\r\n    returns (uint256, uint256)\r\n    {\r\n        require(rate == 1 || rate == 5 || rate == 10);\r\n        uint256 curIndex = _currentMap[rate];\r\n        return (curIndex, _stageMap[rate][curIndex - 1].cnt);\r\n    }\r\n\r\n    function getStageData(uint8 rate, uint256 index)\r\n    external\r\n    view\r\n    returns (address, address, address, bool, uint8)\r\n    {\r\n        require(rate == 1 || rate == 5 || rate == 10);\r\n        require(_finishMap[rate] >= index - 1);\r\n\r\n        Stage storage finishStage = _stageMap[rate][index - 1];\r\n\r\n        return (finishStage.playerMap[0], finishStage.playerMap[1], finishStage.playerMap[2], finishStage.isFinish, finishStage.deadIndex);\r\n    }\r\n\r\n    function buy(uint8 rate)\r\n    private\r\n    {\r\n        Stage storage curStage = _stageMap[rate][_currentMap[rate] - 1];\r\n\r\n        assert(curStage.cnt < MAX_PLAYERS);\r\n\r\n        address player = msg.sender;\r\n\r\n        curStage.playerMap[curStage.cnt] = player;\r\n        curStage.cnt++;\r\n\r\n        emit BravePlayer(player, rate);\r\n\r\n        if (curStage.cnt == MAX_PLAYERS) {\r\n            curStage.blocknumber = block.number;\r\n        }\r\n    }\r\n\r\n    function overStage(uint8 rate)\r\n    private\r\n    {\r\n        uint256 curStageIndex = _currentMap[rate];\r\n        uint256 finishStageIndex = _finishMap[rate];\r\n\r\n        assert(curStageIndex >= finishStageIndex);\r\n\r\n        if (curStageIndex == finishStageIndex) {return;}\r\n\r\n        Stage storage finishStage = _stageMap[rate][finishStageIndex];\r\n\r\n        assert(!finishStage.isFinish);\r\n\r\n        if (finishStage.cnt < MAX_PLAYERS) {return;}\r\n\r\n        assert(finishStage.blocknumber != 0);\r\n\r\n        if (block.number - 256 <= finishStage.blocknumber) {\r\n\r\n            if (block.number == finishStage.blocknumber) {return;}\r\n\r\n            uint8 deadIndex = uint8(blockhash(finishStage.blocknumber)) % MAX_PLAYERS;\r\n            address deadPlayer = finishStage.playerMap[deadIndex];\r\n            emit BraveDeadPlayer(deadPlayer, rate);\r\n            finishStage.deadIndex = deadIndex;\r\n\r\n            for (uint8 i = 0; i < MAX_PLAYERS; i++) {\r\n                address player = finishStage.playerMap[i];\r\n                if (deadIndex != i) {\r\n                    _valueMap[player] += WIN_VALUE * rate;\r\n                }\r\n\r\n                address referee = _addressMap[player];\r\n                _valueMap[referee] += REFEREE_VALUE * rate;\r\n                _referredMap[referee] += REFEREE_VALUE * rate;\r\n            }\r\n\r\n\r\n            uint256 dividends = p3dContract.myDividends(true);\r\n            if (dividends > 0) {\r\n                p3dContract.withdraw();\r\n                _valueMap[deadPlayer] += dividends;\r\n            }\r\n\r\n            p3dContract.buy.value(P3D_VALUE * rate)(address(OFFICIAL_P3D));\r\n\r\n        } else {\r\n\r\n            for (uint8 j = 0; j < MAX_PLAYERS; j++) {\r\n                _valueMap[finishStage.playerMap[j]] += PRICE * rate;\r\n            }\r\n\r\n            emit BraveInvalidateStage(finishStageIndex, rate);\r\n        }\r\n\r\n        finishStage.isFinish = true;\r\n        finishStageIndex++;\r\n        _finishMap[rate] = finishStageIndex;\r\n    }\r\n\r\n    function resetStage(uint8 rate)\r\n    private\r\n    {\r\n        uint256 curStageIndex = _currentMap[rate];\r\n        if (_stageMap[rate][curStageIndex - 1].cnt == MAX_PLAYERS) {\r\n            _stageMap[rate][curStageIndex] = Stage(0, 0, false, 0);\r\n            curStageIndex++;\r\n            _currentMap[rate] = curStageIndex;\r\n        }\r\n    }\r\n}\r\n\r\ninterface HourglassInterface {\r\n    function buy(address _playerAddress) payable external returns (uint256);\r\n    function withdraw() external;\r\n    function myDividends(bool _includeReferralBonus) external view returns (uint256);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"buyFromValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getRefereeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint8\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStageData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getReferee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myReferee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"currentStageData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"buyByAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"buyByName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"BravePlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deadPlayer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"BraveDeadPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BraveWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"BraveInvalidateStage\",\"type\":\"event\"}]","ContractName":"Brave3d","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5a652a1ed799e602a0212283d93d90d19029d3261a3ab2f80fdc2c54ce2128da"}]}