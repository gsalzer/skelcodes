{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: zeppelin-solidity/contracts/ECRecovery.sol\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n    );\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/BookingPoC.sol\r\n\r\n/**\r\n * @title BookingPoC\r\n * @dev A contract to offer hotel rooms for booking, the payment can be done\r\n * with ETH or Lif\r\n */\r\ncontract BookingPoC is Ownable {\r\n\r\n  using SafeMath for uint256;\r\n  using ECRecovery for bytes32;\r\n\r\n  // The account that will sign the offers\r\n  address public offerSigner;\r\n\r\n  // The time where no more bookings can be done\r\n  uint256 public endBookings;\r\n\r\n  // A mapping of the rooms booked by night, it saves the guest address by\r\n  // room/night\r\n  // RoomType => Night => Room => Booking\r\n  struct Booking {\r\n    address guest;\r\n    bytes32 bookingHash;\r\n    uint256 payed;\r\n    bool isEther;\r\n  }\r\n  struct RoomType {\r\n    uint256 totalRooms;\r\n    mapping(uint256 => mapping(uint256 => Booking)) nights;\r\n  }\r\n  mapping(string => RoomType) rooms;\r\n\r\n  // An array of the refund polices, it has to be ordered by beforeTime\r\n  struct Refund {\r\n    uint256 beforeTime;\r\n    uint8 dividedBy;\r\n  }\r\n  Refund[] public refunds;\r\n\r\n  // The total amount of nights offered for booking\r\n  uint256 public totalNights;\r\n\r\n  // The ERC20 lifToken that will be used for payment\r\n  ERC20 public lifToken;\r\n\r\n  event BookingCanceled(\r\n    string roomType, uint256[] nights, uint256 room,\r\n    address newGuest, bytes32 bookingHash\r\n  );\r\n\r\n  event BookingChanged(\r\n    string roomType, uint256[] nights, uint256 room,\r\n    address newGuest, bytes32 bookingHash\r\n  );\r\n\r\n  event BookingDone(\r\n    string roomType, uint256[] nights, uint256 room,\r\n    address guest, bytes32 bookingHash\r\n  );\r\n\r\n  event RoomsAdded(string roomType, uint256 newRooms);\r\n\r\n  /**\r\n   * @dev Constructor\r\n   * @param _offerSigner Address of the account that will sign offers\r\n   * @param _lifToken Address of the Lif token contract\r\n   * @param _totalNights The max amount of nights to be booked\r\n   */\r\n  constructor(\r\n    address _offerSigner, address _lifToken,\r\n    uint256 _totalNights, uint256 _endBookings\r\n  ) public {\r\n    require(_offerSigner != address(0));\r\n    require(_lifToken != address(0));\r\n    require(_totalNights > 0);\r\n    require(_endBookings > now);\r\n    offerSigner = _offerSigner;\r\n    lifToken = ERC20(_lifToken);\r\n    totalNights = _totalNights;\r\n    endBookings = _endBookings;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the signer or lif token addresses, only called by owner\r\n   * @param _offerSigner Address of the account that will sign offers\r\n   * @param _lifToken Address of the Lif token contract\r\n   */\r\n  function edit(address _offerSigner, address _lifToken) onlyOwner public {\r\n    require(_offerSigner != address(0));\r\n    require(_lifToken != address(0));\r\n    offerSigner = _offerSigner;\r\n    lifToken = ERC20(_lifToken);\r\n  }\r\n\r\n  /**\r\n   * @dev Add a refund policy\r\n   * @param _beforeTime The time before this refund can be executed\r\n   * @param _dividedBy The divisor of the payment value\r\n   */\r\n  function addRefund(uint256 _beforeTime, uint8 _dividedBy) onlyOwner public {\r\n    if (refunds.length > 0)\r\n      require(refunds[refunds.length-1].beforeTime > _beforeTime);\r\n    refunds.push(Refund(_beforeTime, _dividedBy));\r\n  }\r\n\r\n  /**\r\n   * @dev Change a refund policy\r\n   * @param _beforeTime The time before this refund can be executed\r\n   * @param _dividedBy The divisor of the payment value\r\n   */\r\n  function changeRefund(\r\n    uint8 _refundIndex, uint256 _beforeTime, uint8 _dividedBy\r\n  ) onlyOwner public {\r\n    if (_refundIndex > 0)\r\n      require(refunds[_refundIndex-1].beforeTime > _beforeTime);\r\n    refunds[_refundIndex].beforeTime = _beforeTime;\r\n    refunds[_refundIndex].dividedBy = _dividedBy;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of rooms offered, only called by owner\r\n   * @param roomType The room type to be added\r\n   * @param amount The amount of rooms to be increased\r\n   */\r\n  function addRooms(string roomType, uint256 amount) onlyOwner public {\r\n    rooms[roomType].totalRooms = rooms[roomType].totalRooms.add(amount);\r\n    emit RoomsAdded(roomType, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Book a room for a certain address, internal function\r\n   * @param roomType The room type to be booked\r\n   * @param _nights The nights that we want to book\r\n   * @param room The room that wants to be booked\r\n   * @param guest The address of the guest that will book the room\r\n   */\r\n  function bookRoom(\r\n    string roomType, uint256[] _nights, uint256 room,\r\n    address guest, bytes32 bookingHash, uint256 weiPerNight, bool isEther\r\n  ) internal {\r\n    for (uint i = 0; i < _nights.length; i ++) {\r\n      rooms[roomType].nights[_nights[i]][room].guest = guest;\r\n      rooms[roomType].nights[_nights[i]][room].bookingHash = bookingHash;\r\n      rooms[roomType].nights[_nights[i]][room].payed = weiPerNight;\r\n      rooms[roomType].nights[_nights[i]][room].isEther = isEther;\r\n    }\r\n    emit BookingDone(roomType, _nights, room, guest, bookingHash);\r\n  }\r\n\r\n  event log(uint256 msg);\r\n\r\n  /**\r\n   * @dev Cancel a booking\r\n   * @param roomType The room type to be booked\r\n   * @param _nights The nights that we want to book\r\n   * @param room The room that wants to be booked\r\n   */\r\n  function cancelBooking(\r\n    string roomType, uint256[] _nights,\r\n    uint256 room, bytes32 bookingHash, bool isEther\r\n  ) public {\r\n\r\n    // Check the booking and delete it\r\n    uint256 totalPayed = 0;\r\n    for (uint i = 0; i < _nights.length; i ++) {\r\n      require(rooms[roomType].nights[_nights[i]][room].guest == msg.sender);\r\n      require(rooms[roomType].nights[_nights[i]][room].isEther == isEther);\r\n      require(rooms[roomType].nights[_nights[i]][room].bookingHash == bookingHash);\r\n      totalPayed = totalPayed.add(\r\n        rooms[roomType].nights[_nights[i]][room].payed\r\n      );\r\n      delete rooms[roomType].nights[_nights[i]][room];\r\n    }\r\n\r\n    // Calculate refund amount\r\n    uint256 refundAmount = 0;\r\n    for (i = 0; i < refunds.length; i ++) {\r\n      if (now < endBookings.sub(refunds[i].beforeTime)){\r\n        refundAmount = totalPayed.div(refunds[i].dividedBy);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Forward refund funds\r\n    if (isEther)\r\n      msg.sender.transfer(refundAmount);\r\n    else\r\n      lifToken.transfer(msg.sender, refundAmount);\r\n\r\n    emit BookingCanceled(roomType, _nights, room, msg.sender, bookingHash);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw tokens and eth, only from owner contract\r\n   */\r\n  function withdraw() public onlyOwner {\r\n    require(now > endBookings);\r\n    lifToken.transfer(owner, lifToken.balanceOf(address(this)));\r\n    owner.transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * @dev Book a room paying with ETH\r\n   * @param pricePerNight The price per night in wei\r\n   * @param offerTimestamp The timestamp of when the offer ends\r\n   * @param offerSignature The signature provided by the offer signer\r\n   * @param roomType The room type that the guest wants to book\r\n   * @param _nights The nights that the guest wants to book\r\n   */\r\n  function bookWithEth(\r\n    uint256 pricePerNight,\r\n    uint256 offerTimestamp,\r\n    bytes offerSignature,\r\n    string roomType,\r\n    uint256[] _nights,\r\n    bytes32 bookingHash\r\n  ) public payable {\r\n    // Check that the offer is still valid\r\n    require(offerTimestamp < now);\r\n    require(now < endBookings);\r\n\r\n    // Check the eth sent\r\n    require(pricePerNight.mul(_nights.length) <= msg.value);\r\n\r\n    // Check if there is at least one room available\r\n    uint256 available = firstRoomAvailable(roomType, _nights);\r\n    require(available > 0);\r\n\r\n    // Check the signer of the offer is the right address\r\n    bytes32 priceSigned = keccak256(abi.encodePacked(\r\n      roomType, pricePerNight, offerTimestamp, \"eth\", bookingHash\r\n    )).toEthSignedMessageHash();\r\n    require(offerSigner == priceSigned.recover(offerSignature));\r\n\r\n    // Assign the available room to the guest\r\n    bookRoom(\r\n      roomType, _nights, available, msg.sender,\r\n      bookingHash, pricePerNight, true\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Book a room paying with Lif\r\n   * @param pricePerNight The price per night in wei\r\n   * @param offerTimestamp The timestamp of when the offer ends\r\n   * @param offerSignature The signature provided by the offer signer\r\n   * @param roomType The room type that the guest wants to book\r\n   * @param _nights The nights that the guest wants to book\r\n   */\r\n  function bookWithLif(\r\n    uint256 pricePerNight,\r\n    uint256 offerTimestamp,\r\n    bytes offerSignature,\r\n    string roomType,\r\n    uint256[] _nights,\r\n    bytes32 bookingHash\r\n  ) public {\r\n    // Check that the offer is still valid\r\n    require(offerTimestamp < now);\r\n\r\n    // Check the amount of lifTokens allowed to be spent by this contract\r\n    uint256 lifTokenAllowance = lifToken.allowance(msg.sender, address(this));\r\n    require(pricePerNight.mul(_nights.length) <= lifTokenAllowance);\r\n\r\n    // Check if there is at least one room available\r\n    uint256 available = firstRoomAvailable(roomType, _nights);\r\n    require(available > 0);\r\n\r\n    // Check the signer of the offer is the right address\r\n    bytes32 priceSigned = keccak256(abi.encodePacked(\r\n      roomType, pricePerNight, offerTimestamp, \"lif\", bookingHash\r\n    )).toEthSignedMessageHash();\r\n    require(offerSigner == priceSigned.recover(offerSignature));\r\n\r\n    // Assign the available room to the guest\r\n    bookRoom(\r\n      roomType, _nights, available, msg.sender,\r\n      bookingHash, pricePerNight, false\r\n    );\r\n\r\n    // Transfer the lifTokens to booking\r\n    lifToken.transferFrom(msg.sender, address(this), lifTokenAllowance);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the total rooms for a room type\r\n   * @param roomType The room type that wants to be booked\r\n   */\r\n  function totalRooms(string roomType) view public returns (uint256) {\r\n    return rooms[roomType].totalRooms;\r\n  }\r\n\r\n  /**\r\n   * @dev Get a booking information\r\n   * @param roomType The room type\r\n   * @param room The room booked\r\n   * @param night The night of the booking\r\n   */\r\n  function getBooking(\r\n    string roomType, uint256 room, uint256 night\r\n  ) view public returns (address, uint256, bytes32, bool) {\r\n    return (\r\n      rooms[roomType].nights[night][room].guest,\r\n      rooms[roomType].nights[night][room].payed,\r\n      rooms[roomType].nights[night][room].bookingHash,\r\n      rooms[roomType].nights[night][room].isEther\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Get the availability of a specific room\r\n   * @param roomType The room type that wants to be booked\r\n   * @param _nights The nights to check availability\r\n   * @param room The room that wants to be booked\r\n   * @return bool If the room is available or not\r\n   */\r\n  function roomAvailable(\r\n    string roomType, uint256[] _nights, uint256 room\r\n  ) view public returns (bool) {\r\n    require(room <= rooms[roomType].totalRooms);\r\n    for (uint i = 0; i < _nights.length; i ++) {\r\n      require(_nights[i] <= totalNights);\r\n      if (rooms[roomType].nights[_nights[i]][room].guest != address(0))\r\n        return false;\r\n      }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Get the available rooms for certain nights\r\n   * @param roomType The room type that wants to be booked\r\n   * @param _nights The nights to check availability\r\n   * @return uint256 Array of the rooms available for that nights\r\n   */\r\n  function roomsAvailable(\r\n    string roomType, uint256[] _nights\r\n  ) view public returns (uint256[]) {\r\n    require(_nights[i] <= totalNights);\r\n    uint256[] memory available = new uint256[](rooms[roomType].totalRooms);\r\n    for (uint z = 1; z <= rooms[roomType].totalRooms; z ++) {\r\n      available[z-1] = z;\r\n      for (uint i = 0; i < _nights.length; i ++)\r\n        if (rooms[roomType].nights[_nights[i]][z].guest != address(0)) {\r\n          available[z-1] = 0;\r\n          break;\r\n        }\r\n    }\r\n    return available;\r\n  }\r\n\r\n  /**\r\n   * @dev Get the first available room for certain nights\r\n   * @param roomType The room type that wants to be booked\r\n   * @param _nights The nights to check availability\r\n   * @return uint256 The first available room\r\n   */\r\n  function firstRoomAvailable(\r\n    string roomType, uint256[] _nights\r\n  ) internal returns (uint256) {\r\n    require(_nights[i] <= totalNights);\r\n    uint256 available = 0;\r\n    bool isAvailable;\r\n    for (uint z = rooms[roomType].totalRooms; z >= 1 ; z --) {\r\n      isAvailable = true;\r\n      for (uint i = 0; i < _nights.length; i ++) {\r\n        if (rooms[roomType].nights[_nights[i]][z].guest != address(0))\r\n          isAvailable = false;\r\n          break;\r\n        }\r\n      if (isAvailable)\r\n        available = z;\r\n    }\r\n    return available;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"roomType\",\"type\":\"string\"},{\"name\":\"_nights\",\"type\":\"uint256[]\"}],\"name\":\"roomsAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roomType\",\"type\":\"string\"},{\"name\":\"_nights\",\"type\":\"uint256[]\"},{\"name\":\"room\",\"type\":\"uint256\"},{\"name\":\"bookingHash\",\"type\":\"bytes32\"},{\"name\":\"isEther\",\"type\":\"bool\"}],\"name\":\"cancelBooking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refundIndex\",\"type\":\"uint8\"},{\"name\":\"_beforeTime\",\"type\":\"uint256\"},{\"name\":\"_dividedBy\",\"type\":\"uint8\"}],\"name\":\"changeRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNights\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pricePerNight\",\"type\":\"uint256\"},{\"name\":\"offerTimestamp\",\"type\":\"uint256\"},{\"name\":\"offerSignature\",\"type\":\"bytes\"},{\"name\":\"roomType\",\"type\":\"string\"},{\"name\":\"_nights\",\"type\":\"uint256[]\"},{\"name\":\"bookingHash\",\"type\":\"bytes32\"}],\"name\":\"bookWithLif\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lifToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roomType\",\"type\":\"string\"},{\"name\":\"room\",\"type\":\"uint256\"},{\"name\":\"night\",\"type\":\"uint256\"}],\"name\":\"getBooking\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pricePerNight\",\"type\":\"uint256\"},{\"name\":\"offerTimestamp\",\"type\":\"uint256\"},{\"name\":\"offerSignature\",\"type\":\"bytes\"},{\"name\":\"roomType\",\"type\":\"string\"},{\"name\":\"_nights\",\"type\":\"uint256[]\"},{\"name\":\"bookingHash\",\"type\":\"bytes32\"}],\"name\":\"bookWithEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"offerSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offerSigner\",\"type\":\"address\"},{\"name\":\"_lifToken\",\"type\":\"address\"}],\"name\":\"edit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roomType\",\"type\":\"string\"},{\"name\":\"_nights\",\"type\":\"uint256[]\"},{\"name\":\"room\",\"type\":\"uint256\"}],\"name\":\"roomAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beforeTime\",\"type\":\"uint256\"},{\"name\":\"_dividedBy\",\"type\":\"uint8\"}],\"name\":\"addRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roomType\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addRooms\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refunds\",\"outputs\":[{\"name\":\"beforeTime\",\"type\":\"uint256\"},{\"name\":\"dividedBy\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBookings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roomType\",\"type\":\"string\"}],\"name\":\"totalRooms\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_offerSigner\",\"type\":\"address\"},{\"name\":\"_lifToken\",\"type\":\"address\"},{\"name\":\"_totalNights\",\"type\":\"uint256\"},{\"name\":\"_endBookings\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roomType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"nights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"room\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newGuest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bookingHash\",\"type\":\"bytes32\"}],\"name\":\"BookingCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roomType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"nights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"room\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newGuest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bookingHash\",\"type\":\"bytes32\"}],\"name\":\"BookingChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roomType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"nights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"room\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"guest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bookingHash\",\"type\":\"bytes32\"}],\"name\":\"BookingDone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roomType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newRooms\",\"type\":\"uint256\"}],\"name\":\"RoomsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"uint256\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BookingPoC","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000074bd3b20b47043a6e69146b5d23f92911c5effbb000000000000000000000000eb9951021698b42e4399f9cbb6267aa35f82d59d0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000005b906e00","Library":"","SwarmSource":"bzzr://153e2dfe48a6d56e76d423cbe616098312bd6173462542c3bebeb564b52ca127"}]}