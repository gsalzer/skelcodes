{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Devery Contracts - The Monolithic Registry\r\n//\r\n// Deployed to Ropsten Testnet at 0x654f4a3e3B7573D6b4bB7201AB70d718961765CD\r\n//\r\n// Enjoy.\r\n//\r\n// (c) BokkyPooBah / Bok Consulting Pty Ltd for Devery 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Administrators\r\n// ----------------------------------------------------------------------------\r\ncontract Admined is Owned {\r\n\r\n    mapping (address => bool) public admins;\r\n\r\n    event AdminAdded(address addr);\r\n    event AdminRemoved(address addr);\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isAdmin(address addr) public constant returns (bool) {\r\n        return (admins[addr] || owner == addr);\r\n    }\r\n    function addAdmin(address addr) public onlyOwner {\r\n        require(!admins[addr] && addr != owner);\r\n        admins[addr] = true;\r\n        AdminAdded(addr);\r\n    }\r\n    function removeAdmin(address addr) public onlyOwner {\r\n        require(admins[addr]);\r\n        delete admins[addr];\r\n        AdminRemoved(addr);\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Devery Registry\r\n// ----------------------------------------------------------------------------\r\ncontract DeveryRegistry is Admined {\r\n\r\n    struct App {\r\n        address appAccount;\r\n        string appName;\r\n        address feeAccount;\r\n        uint fee;\r\n        bool active;\r\n    }\r\n    struct Brand {\r\n        address brandAccount;\r\n        address appAccount;\r\n        string brandName;\r\n        bool active;\r\n    }\r\n    struct Product {\r\n        address productAccount;\r\n        address brandAccount;\r\n        string description;\r\n        string details;\r\n        uint year;\r\n        string origin;\r\n        bool active;\r\n    }\r\n\r\n    ERC20Interface public token;\r\n    address public feeAccount;\r\n    uint public fee;\r\n    mapping(address => App) public apps;\r\n    mapping(address => Brand) public brands;\r\n    mapping(address => Product) public products;\r\n    mapping(address => mapping(address => bool)) permissions;\r\n    mapping(bytes32 => address) markings;\r\n    address[] public appAccounts;\r\n    address[] public brandAccounts;\r\n    address[] public productAccounts;\r\n\r\n    event TokenUpdated(address indexed oldToken, address indexed newToken);\r\n    event FeeUpdated(address indexed oldFeeAccount, address indexed newFeeAccount, uint oldFee, uint newFee);\r\n    event AppAdded(address indexed appAccount, string appName, address feeAccount, uint fee, bool active);\r\n    event AppUpdated(address indexed appAccount, string appName, address feeAccount, uint fee, bool active);\r\n    event BrandAdded(address indexed brandAccount, address indexed appAccount, string brandName, bool active);\r\n    event BrandUpdated(address indexed brandAccount, address indexed appAccount, string brandName, bool active);\r\n    event ProductAdded(address indexed productAccount, address indexed brandAccount, address indexed appAccount, string description, bool active);\r\n    event ProductUpdated(address indexed productAccount, address indexed brandAccount, address indexed appAccount, string description, bool active);\r\n    event Permissioned(address indexed marker, address indexed brandAccount, bool permission);\r\n    event Marked(address indexed marker, address indexed productAccount, address appFeeAccount, address feeAccount, uint appFee, uint fee, bytes32 itemHash);\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token, fee account and fee\r\n    // ------------------------------------------------------------------------\r\n    function setToken(address _token) public onlyAdmin {\r\n        TokenUpdated(address(token), _token);\r\n        token = ERC20Interface(_token);\r\n    }\r\n    function setFee(address _feeAccount, uint _fee) public onlyAdmin {\r\n        FeeUpdated(feeAccount, _feeAccount, fee, _fee);\r\n        feeAccount = _feeAccount;\r\n        fee = _fee;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Account can add itself as an App account\r\n    // ------------------------------------------------------------------------\r\n    function addApp(string appName, address _feeAccount, uint _fee) public {\r\n        App storage e = apps[msg.sender];\r\n        require(e.appAccount == address(0));\r\n        apps[msg.sender] = App({\r\n            appAccount: msg.sender,\r\n            appName: appName,\r\n            feeAccount: _feeAccount,\r\n            fee: _fee,\r\n            active: true\r\n        });\r\n        appAccounts.push(msg.sender);\r\n        AppAdded(msg.sender, appName, _feeAccount, _fee, true);\r\n    }\r\n    function updateApp(string appName, address _feeAccount, uint _fee, bool active) public {\r\n        App storage e = apps[msg.sender];\r\n        require(msg.sender == e.appAccount);\r\n        e.appName = appName;\r\n        e.feeAccount = _feeAccount;\r\n        e.fee = _fee;\r\n        e.active = active;\r\n        AppUpdated(msg.sender, appName, _feeAccount, _fee, active);\r\n    }\r\n    function getApp(address appAccount) public constant returns (App app) {\r\n        app = apps[appAccount];\r\n    }\r\n    function getAppData(address appAccount) public constant returns (address _feeAccount, uint _fee, bool active) {\r\n        App storage e = apps[appAccount];\r\n        _feeAccount = e.feeAccount;\r\n        _fee = e.fee;\r\n        active = e.active;\r\n    }\r\n    function appAccountsLength() public constant returns (uint) {\r\n        return appAccounts.length;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // App account can add Brand account\r\n    // ------------------------------------------------------------------------\r\n    function addBrand(address brandAccount, string brandName) public {\r\n        App storage app = apps[msg.sender];\r\n        require(app.appAccount != address(0));\r\n        Brand storage brand = brands[brandAccount];\r\n        require(brand.brandAccount == address(0));\r\n        brands[brandAccount] = Brand({\r\n            brandAccount: brandAccount,\r\n            appAccount: msg.sender,\r\n            brandName: brandName,\r\n            active: true\r\n        });\r\n        brandAccounts.push(brandAccount);\r\n        BrandAdded(brandAccount, msg.sender, brandName, true);\r\n    }\r\n    function updateBrand(address brandAccount, string brandName, bool active) public {\r\n        Brand storage brand = brands[brandAccount];\r\n        require(brand.appAccount == msg.sender);\r\n        brand.brandName = brandName;\r\n        brand.active = active;\r\n\r\n        BrandUpdated(brandAccount, msg.sender, brandName, active);\r\n    }\r\n    function getBrand(address brandAccount) public constant returns (Brand brand) {\r\n        brand = brands[brandAccount];\r\n    }\r\n    function getBrandData(address brandAccount) public constant returns (address appAccount, address appFeeAccount, bool active) {\r\n        Brand storage brand = brands[brandAccount];\r\n        require(brand.appAccount != address(0));\r\n        App storage app = apps[brand.appAccount];\r\n        require(app.appAccount != address(0));\r\n        appAccount = app.appAccount;\r\n        appFeeAccount = app.feeAccount;\r\n        active = app.active && brand.active;\r\n    }\r\n    function brandAccountsLength() public constant returns (uint) {\r\n        return brandAccounts.length;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Brand account can add Product account\r\n    // ------------------------------------------------------------------------\r\n    function addProduct(address productAccount, string description, string details, uint year, string origin) public {\r\n        Brand storage brand = brands[msg.sender];\r\n        require(brand.brandAccount != address(0));\r\n        App storage app = apps[brand.appAccount];\r\n        require(app.appAccount != address(0));\r\n        Product storage product = products[productAccount];\r\n        require(product.productAccount == address(0));\r\n        products[productAccount] = Product({\r\n            productAccount: productAccount,\r\n            brandAccount: msg.sender,\r\n            description: description,\r\n            details: details,\r\n            year: year,\r\n            origin: origin,\r\n            active: true\r\n        });\r\n        productAccounts.push(productAccount);\r\n        ProductAdded(productAccount, msg.sender, app.appAccount, description, true);\r\n    }\r\n    function updateProduct(address productAccount, string description, string details, uint year, string origin, bool active) public {\r\n        Product storage product = products[productAccount];\r\n        require(product.brandAccount == msg.sender);\r\n        Brand storage brand = brands[msg.sender];\r\n        require(brand.brandAccount == msg.sender);\r\n        App storage app = apps[brand.appAccount];\r\n        product.description = description;\r\n        product.details = details;\r\n        product.year = year;\r\n        product.origin = origin;\r\n        product.active = active;\r\n        ProductUpdated(productAccount, product.brandAccount, app.appAccount, description, active);\r\n    }\r\n    function getProduct(address productAccount) public constant returns (Product product) {\r\n        product = products[productAccount];\r\n    }\r\n    function getProductData(address productAccount) public constant returns (address brandAccount, address appAccount, address appFeeAccount, bool active) {\r\n        Product storage product = products[productAccount];\r\n        require(product.brandAccount != address(0));\r\n        Brand storage brand = brands[brandAccount];\r\n        require(brand.appAccount != address(0));\r\n        App storage app = apps[brand.appAccount];\r\n        require(app.appAccount != address(0));\r\n        brandAccount = product.brandAccount;\r\n        appAccount = app.appAccount;\r\n        appFeeAccount = app.feeAccount;\r\n        active = app.active && brand.active && brand.active;\r\n    }\r\n    function productAccountsLength() public constant returns (uint) {\r\n        return productAccounts.length;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Brand account can permission accounts as markers\r\n    // ------------------------------------------------------------------------\r\n    function permissionMarker(address marker, bool permission) public {\r\n        Brand storage brand = brands[msg.sender];\r\n        require(brand.brandAccount != address(0));\r\n        permissions[marker][msg.sender] = permission;\r\n        Permissioned(marker, msg.sender, permission);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Compute item hash from the public key\r\n    // ------------------------------------------------------------------------\r\n    function addressHash(address item) public pure returns (bytes32 hash) {\r\n        hash = keccak256(item);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Markers can add [productAccount, sha3(itemPublicKey)]\r\n    // ------------------------------------------------------------------------\r\n    function mark(address productAccount, bytes32 itemHash) public {\r\n        Product storage product = products[productAccount];\r\n        require(product.brandAccount != address(0) && product.active);\r\n        Brand storage brand = brands[product.brandAccount];\r\n        require(brand.brandAccount != address(0) && brand.active);\r\n        App storage app = apps[brand.appAccount];\r\n        require(app.appAccount != address(0) && app.active);\r\n        bool permissioned = permissions[msg.sender][brand.brandAccount];\r\n        require(permissioned);\r\n        markings[itemHash] = productAccount;\r\n        Marked(msg.sender, productAccount, app.feeAccount, feeAccount, app.fee, fee, itemHash);\r\n        if (app.fee > 0) {\r\n            token.transferFrom(brand.brandAccount, app.feeAccount, app.fee);\r\n        }\r\n        if (fee > 0) {\r\n            token.transferFrom(brand.brandAccount, feeAccount, fee);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Check itemPublicKey has been registered\r\n    // ------------------------------------------------------------------------\r\n    function check(address item) public constant returns (address productAccount, address brandAccount, address appAccount) {\r\n        bytes32 hash = keccak256(item);\r\n        productAccount = markings[hash];\r\n        // require(productAccount != address(0));\r\n        Product storage product = products[productAccount];\r\n        // require(product.brandAccount != address(0));\r\n        Brand storage brand = brands[product.brandAccount];\r\n        // require(brand.brandAccount != address(0));\r\n        brandAccount = product.brandAccount;\r\n        appAccount = brand.appAccount;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Admined","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c6a62ba5401b63981152bc892a0316c9d7455deddd6c1d14714902810449c245"}]}