{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\ninterface DelegatedERC20 {\r\n    function allowance(address _owner, address _spender) external view returns (uint256); \r\n    function transferFrom(address from, address to, uint256 value, address sender) external returns (bool); \r\n    function approve(address _spender, uint256 _value, address sender) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value, address sender) external returns (bool);\r\n}\r\n\r\n\r\ninterface ICapTables {\r\n    function balanceOf(uint256 token, address user) external view returns (uint256);\r\n    function initialize(uint256 supply, address holder) external returns (uint256);\r\n    function migrate(uint256 security, address newAddress) external;\r\n    function totalSupply(uint256 security) external view returns (uint256);\r\n    function transfer(uint256 security, address src, address dest, uint256 amount) external;\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DelegatedTokenLogic empty token\r\n */\r\ncontract DelegatedTokenLogic is Ownable, DelegatedERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    address public capTables;\r\n    address public front;\r\n\r\n    /**\r\n    * @Dev Index of this security in the global cap table store.\r\n    */\r\n    uint256 public index;\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    modifier onlyFront() {\r\n        require(msg.sender == front, \"this method is reserved for the token front\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Set the fronting token.\r\n    */\r\n    function setFront(address _front) public onlyOwner {\r\n        front = _front;\r\n    }\r\n\r\n    /**\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return ICapTables(capTables).totalSupply(index);\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value, address sender) \r\n        public \r\n        onlyFront \r\n        returns (bool) \r\n    {\r\n        require(_to != address(0), \"tokens MUST NOT be transferred to the zero address\");\r\n        ICapTables(capTables).transfer(index, sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return ICapTables(capTables).balanceOf(index, _owner);\r\n    }\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value, address sender) \r\n        public \r\n        onlyFront\r\n        returns (bool) \r\n    {\r\n        require(_to != address(0), \"tokens MUST NOT go to the zero address\");\r\n        require(_value <= allowed[_from][sender], \"transfer value MUST NOT exceed allowance\");\r\n\r\n        ICapTables(capTables).transfer(index, _from, _to, _value);\r\n        allowed[_from][sender] = allowed[_from][sender].sub(_value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value, address sender) \r\n        public \r\n        onlyFront\r\n        returns (bool) \r\n    {\r\n        allowed[sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n/** \r\n * @title IndexConsumer\r\n * @dev This contract adds an autoincrementing index to contracts. \r\n */\r\ncontract IndexConsumer {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /** The index */\r\n    uint256 private freshIndex = 0;\r\n\r\n    /** Fetch the next index */\r\n    function nextIndex() internal returns (uint256) {\r\n        uint256 theIndex = freshIndex;\r\n        freshIndex = freshIndex.add(1);\r\n        return theIndex;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * One method for implementing a permissioned token is to appoint some\r\n * authority which must decide whether to approve or refuse trades.  This\r\n * contract implements this functionality.  \r\n */\r\n\r\ncontract SimplifiedLogic is IndexConsumer, DelegatedTokenLogic {\r\n\r\n    string public name = \"Test Fox Token\";\r\n    string public symbol = \"TFT\";\r\n\r\n\r\n    enum TransferStatus {\r\n        Unused,\r\n        Active,\r\n        Resolved\r\n    }\r\n\r\n    /** Data associated to a (request to) transfer */\r\n    struct TokenTransfer {\r\n        address src;\r\n        address dest;\r\n        uint256 amount;\r\n        address spender;\r\n        TransferStatus status;\r\n    }\r\n    \r\n    /** \r\n     * The resolver determines whether a transfer ought to proceed and\r\n     * executes or nulls it. \r\n     */\r\n    address public resolver;\r\n\r\n    /** \r\n     * Transfer requests are generated when a token owner (or delegate) wants\r\n     * to transfer some tokens.  They must be either executed or nulled by the\r\n     * resolver. \r\n     */\r\n    mapping(uint256 => TokenTransfer) public transferRequests;\r\n\r\n    /**\r\n     * The contract may be deactivated during a migration.\r\n     */\r\n    bool public contractActive = true;\r\n    \r\n    /** Represents that a user intends to make a transfer. */\r\n    event TransferRequest(\r\n        uint256 indexed index,\r\n        address src,\r\n        address dest,\r\n        uint256 amount,\r\n        address spender\r\n    );\r\n    \r\n    /** Represents the resolver's decision about the transfer. */\r\n    event TransferResult(\r\n        uint256 indexed index,\r\n        uint16 code\r\n    );\r\n        \r\n    /** \r\n     * Methods that are only safe when the contract is in the active state.\r\n     */\r\n    modifier onlyActive() {\r\n        require(contractActive, \"the contract MUST be active\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Forbidden to all but the resolver.\r\n     */\r\n    modifier onlyResolver() {\r\n        require(msg.sender == resolver, \"this method is reserved for the designated resolver\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _index,\r\n        address _capTables,\r\n        address _owner,\r\n        address _resolver\r\n    ) public {\r\n        index = _index;\r\n        capTables = _capTables;\r\n        owner = _owner;\r\n        resolver = _resolver;\r\n    }\r\n\r\n    function transfer(address _dest, uint256 _amount, address _sender) \r\n        public \r\n        onlyFront \r\n        onlyActive \r\n        returns (bool) \r\n    {\r\n        uint256 txfrIndex = nextIndex();\r\n        transferRequests[txfrIndex] = TokenTransfer(\r\n            _sender, \r\n            _dest, \r\n            _amount, \r\n            _sender, \r\n            TransferStatus.Active\r\n        );\r\n        emit TransferRequest(\r\n            txfrIndex,\r\n            _sender,\r\n            _dest,\r\n            _amount,\r\n            _sender\r\n        );\r\n        return false; // The transfer has not taken place yet\r\n    }\r\n\r\n    function transferFrom(address _src, address _dest, uint256 _amount, address _sender) \r\n        public \r\n        onlyFront \r\n        onlyActive \r\n        returns (bool)\r\n    {\r\n        require(_amount <= allowed[_src][_sender], \"the transfer amount MUST NOT exceed the allowance\");\r\n        uint txfrIndex = nextIndex();\r\n        transferRequests[txfrIndex] = TokenTransfer(\r\n            _src, \r\n            _dest, \r\n            _amount, \r\n            _sender, \r\n            TransferStatus.Active\r\n        );\r\n        emit TransferRequest(\r\n            txfrIndex,\r\n            _src,\r\n            _dest,\r\n            _amount,\r\n            _sender\r\n        );\r\n        return false; // The transfer has not taken place yet\r\n    }\r\n\r\n    function setResolver(address _resolver)\r\n        public\r\n        onlyOwner\r\n    {\r\n        resolver = _resolver;\r\n    }\r\n\r\n    function resolve(uint256 _txfrIndex, uint16 _code) \r\n        public \r\n        onlyResolver\r\n        returns (bool result)\r\n    {\r\n        require(transferRequests[_txfrIndex].status == TransferStatus.Active, \"the transfer request MUST be active\");\r\n        TokenTransfer storage tfr = transferRequests[_txfrIndex];\r\n        result = false;\r\n        if (_code == 0) {\r\n            result = true;\r\n            if (tfr.spender == tfr.src) {\r\n                // Vanilla transfer\r\n                ICapTables(capTables).transfer(index, tfr.src, tfr.dest, tfr.amount);\r\n            } else {\r\n                // Requires an allowance\r\n                ICapTables(capTables).transfer(index, tfr.src, tfr.dest, tfr.amount);\r\n                allowed[tfr.src][tfr.spender] = allowed[tfr.src][tfr.spender].sub(tfr.amount);\r\n            }\r\n        } \r\n        transferRequests[_txfrIndex].status = TransferStatus.Resolved;\r\n        emit TransferResult(_txfrIndex, _code);\r\n    }\r\n\r\n    function migrate(address newLogic) public onlyOwner {\r\n        contractActive = false;\r\n        ICapTables(capTables).migrate(index, newLogic);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferRequests\",\"outputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"},{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"front\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capTables\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_txfrIndex\",\"type\":\"uint256\"},{\"name\":\"_code\",\"type\":\"uint16\"}],\"name\":\"resolve\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_front\",\"type\":\"address\"}],\"name\":\"setFront\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_capTables\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"TransferRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"code\",\"type\":\"uint16\"}],\"name\":\"TransferResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SimplifiedLogic","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000008f4974946420c7b779009821ceab2ef4e6e73081000000000000000000000000d2ba630e74050b0149fa3747081200154da735df000000000000000000000000d2ba630e74050b0149fa3747081200154da735df","Library":"","SwarmSource":"bzzr://06c8607dea4b3a2d5253e2b3f503de17e0f123a3677556dbcba49b44e72016e6"}]}