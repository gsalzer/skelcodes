{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// ////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//                     ___           ___           ___                    __      \r\n//       ___          /  /\\         /  /\\         /  /\\                  |  |\\    \r\n//      /__/\\        /  /::\\       /  /::\\       /  /::|                 |  |:|   \r\n//      \\  \\:\\      /  /:/\\:\\     /  /:/\\:\\     /  /:|:|                 |  |:|   \r\n//       \\__\\:\\    /  /::\\ \\:\\   /  /::\\ \\:\\   /  /:/|:|__               |__|:|__ \r\n//       /  /::\\  /__/:/\\:\\ \\:\\ /__/:/\\:\\_\\:\\ /__/:/_|::::\\          ____/__/::::\\\r\n//      /  /:/\\:\\ \\  \\:\\ \\:\\_\\/ \\__\\/  \\:\\/:/ \\__\\/  /~~/:/          \\__\\::::/~~~~\r\n//     /  /:/__\\/  \\  \\:\\ \\:\\        \\__\\::/        /  /:/              |~~|:|    \r\n//    /__/:/        \\  \\:\\_\\/        /  /:/        /  /:/               |  |:|    \r\n//    \\__\\/          \\  \\:\\         /__/:/        /__/:/                |__|:|    \r\n//                    \\__\\/         \\__\\/         \\__\\/                  \\__\\|    \r\n//  ______   ______   ______   _____    _    _   ______  ______  _____ \r\n// | |  | \\ | |  | \\ / |  | \\ | | \\ \\  | |  | | | |     | |     | | \\ \\ \r\n// | |__|_/ | |__| | | |  | | | |  | | | |  | | | |     | |---- | |  | |\r\n// |_|      |_|  \\_\\ \\_|__|_/ |_|_/_/  \\_|__|_| |_|____ |_|____ |_|_/_/ \r\n// \r\n// TEAM X All Rights Received. http://teamx.club \r\n// This product is protected under license.  Any unauthorized copy, modification, or use without \r\n// express written consent from the creators is prohibited.\r\n// v 0.1.3\r\n// Any cooperation Please email: service@teamx.club\r\n// Follow these step to become a site owner:\r\n// 1. fork git repository: https://github.com/teamx-club/escape-mmm\r\n// 2. modify file: js/config.js\r\n// 3. replace siteOwner with your address\r\n// 4. search for how to use github pages and bind your domain, setup the forked repository\r\n// 5. having fun, you will earn 5% every privode from your site page\r\n// ////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//=========================================================...\r\n// (~   _  _ _|_ _  .\r\n// (_\\/(/_| | | _\\  . Events\r\n//=========================================================                   \r\ncontract EscapeMmmEvents {\r\n    event onOffered (\r\n        address indexed playerAddress,\r\n        uint256 offerAmount,\r\n        address affiliateAddress,\r\n        address siteOwner,\r\n        uint256 timestamp\r\n    );\r\n    event onAccepted (\r\n        address indexed playerAddress,\r\n        uint256 acceptAmount\r\n    );\r\n    event onWithdraw (\r\n        address indexed playerAddress,\r\n        uint256 withdrawAmount\r\n    );\r\n    event onAirDrop (\r\n        address indexed playerAddress,\r\n        uint256 airdropAmount,\r\n        uint256 offerAmount\r\n    );\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n//=========================================================...\r\n// |\\/| _ . _   /~` _  _ _|_ _ _  __|_  .\r\n// |  |(_||| |  \\_,(_)| | | | (_|(_ |   . Main Contract\r\n//=========================================================                   \r\ncontract EFMAPlatform is EscapeMmmEvents, Ownable {\r\n    using SafeMath for *;\r\n\r\n    //=========================================================...\r\n    //  _ _  _  |`. _     _ _  .\r\n    // (_(_)| |~|~|(_||_|| (/_ .  system settings\r\n    //==============_|=========================================        \r\n    string constant public name = \"Escape Financial Mutual Aid Platform\";\r\n    string constant public symbol = \"EFMAP\";\r\n\r\n    address private xTokenAddress = 0xfe8b40a35ff222c8475385f74e77d33954531b41;\r\n\r\n    uint8 public feePercent_ = 1; // 1% for fee\r\n    uint8 public affPercent_ = 5; // 5% for affiliate\r\n    uint8 public sitePercent_ = 5; // 5% for site owner\r\n    uint8 public airDropPercent_ = 10; // 10% for air drop\r\n    uint8 public xTokenPercent_ = 3; // 3% for x token\r\n\r\n    uint256 constant public interestPeriod_ = 1 hours;\r\n    uint256 constant public maxInterestTime_ = 7 days;\r\n    //=========================================================...\r\n    //  _| _ _|_ _    _ _ _|_   _  .\r\n    // (_|(_| | (_|  _\\(/_ ||_||_) . data setup\r\n    //=========================|===============================  \r\n    uint256 public airDropPool_;\r\n    uint256 public airDropTracker_ = 0; // +1 every (0.001 ether) time triggered; if 0.002 eth, trigger twice\r\n\r\n    //=========================================================...\r\n    //  _ | _ _|_|` _  _ _ _    _| _ _|_ _  .\r\n    // |_)|(_| |~|~(_)| | | |  (_|(_| | (_| . platform data\r\n    //=|=======================================================\r\n    mapping (address => FMAPDatasets.Player) public players_;\r\n    mapping (address => mapping (uint256 => FMAPDatasets.OfferInfo)) public playerOfferOrders_; // player => player offer count => offerInfo.\r\n    mapping (address => mapping (uint256 => uint256)) public playerAcceptOrders_; // player => count => orderId. player orders to accept;\r\n    uint256 private restOfferAmount_ = 0; // offered amount that not been accepted;\r\n    FMAPDatasets.AcceptOrder private currentOrder_; // unmatched current order;\r\n    mapping (uint256 => FMAPDatasets.AcceptOrder) public acceptOrders_; // accept orders;\r\n\r\n    address private teamXWallet;\r\n    uint256 public _totalFee;\r\n    uint256 public _totalXT;\r\n\r\n    //=========================================================...\r\n    //  _ _  _  __|_ _   __|_ _  _\r\n    // (_(_)| |_\\ | ||_|(_ | (_)| \r\n    //=========================================================\r\n    constructor() public {\r\n        teamXWallet = msg.sender;\r\n        // setting something ?\r\n        FMAPDatasets.AcceptOrder memory ao;\r\n        ao.nextOrder = 1;\r\n        ao.playerAddress = msg.sender;\r\n        ao.acceptAmount = 1 finney;\r\n        acceptOrders_[0] = ao;\r\n        currentOrder_ = ao;\r\n    }\r\n\r\n    function transFee() public onlyOwner {\r\n        teamXWallet.transfer(_totalFee);\r\n    }\r\n    function setTeamWallet(address wallet) public onlyOwner {\r\n        teamXWallet = wallet;\r\n    }\r\n    function setXToken(address xToken) public onlyOwner {\r\n        xTokenAddress = xToken;\r\n    }\r\n\r\n    //=========================================================...\r\n    //  _ _  _  _|. |`. _  _ _ .\r\n    // | | |(_)(_||~|~|(/_| _\\ . modifiers\r\n    //=========================================================\r\n    modifier isHuman() {\r\n        require(AddressUtils.isContract(msg.sender) == false, \"sorry, only human allowed\");\r\n        _;\r\n    }\r\n\r\n    //=========================================================...\r\n    //  _    |_ |. _   |`    _  __|_. _  _  _  .\r\n    // |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  . public functions\r\n    //=|=======================================================\r\n    /**\r\n     * offer help directly\r\n     */\r\n    function() isHuman() public payable {\r\n        FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(address(0), msg.value);\r\n        offerCore(offerInfo, false);\r\n    }\r\n\r\n    function offerHelp(address siteOwner, address affiliate) isHuman() public payable {\r\n        FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(siteOwner, msg.value);\r\n        bool updateAff = false;\r\n        if(affiliate != address(0) && affiliate != offerInfo.affiliateAddress) {\r\n            offerInfo.affiliateAddress = affiliate;\r\n            updateAff = true;\r\n        }\r\n        offerCore(offerInfo, updateAff);\r\n\r\n        emit onOffered(offerInfo.playerAddress, offerInfo.offerAmount, offerInfo.affiliateAddress, offerInfo.siteOwner, offerInfo.timestamp);\r\n    }\r\n\r\n    function offerHelpUsingBalance(address siteOwner, address affiliate, uint256 ethAmount) isHuman() public {\r\n        require(ethAmount <= players_[msg.sender].balance, \"sorry, you don't have enough balance\");\r\n        FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(siteOwner, ethAmount);\r\n        bool updateAff = false;\r\n        if(affiliate != address(0) && affiliate != offerInfo.affiliateAddress) {\r\n            offerInfo.affiliateAddress = affiliate;\r\n            updateAff = true;\r\n        }\r\n        players_[msg.sender].balance = players_[msg.sender].balance.sub(ethAmount);\r\n        offerCore(offerInfo, updateAff);\r\n\r\n        emit onOffered(offerInfo.playerAddress, offerInfo.offerAmount, offerInfo.affiliateAddress, offerInfo.siteOwner, offerInfo.timestamp);\r\n    }\r\n\r\n    function acceptHelp(uint256 amount) isHuman() public returns (uint256 canAcceptLeft) {\r\n        (canAcceptLeft, ) = calcCanAcceptAmount(msg.sender, true, 0);\r\n        require(amount <= canAcceptLeft, \"sorry, you don't have enough acceptable amount\");\r\n\r\n        uint256 _nextOrderId = currentOrder_.nextOrder;\r\n        FMAPDatasets.AcceptOrder memory acceptOrder;\r\n        acceptOrder.playerAddress = msg.sender;\r\n        acceptOrder.acceptAmount = amount;\r\n        acceptOrder.acceptedAmount = 0;\r\n        acceptOrder.nextOrder = _nextOrderId + 1;\r\n        acceptOrders_[_nextOrderId] = acceptOrder;\r\n\r\n        // see if currentOrder_ is finished\r\n        if (currentOrder_.orderId == _nextOrderId || currentOrder_.acceptAmount == currentOrder_.acceptedAmount) {\r\n            currentOrder_ = acceptOrder;\r\n        }\r\n\r\n        players_[acceptOrder.playerAddress].totalAccepted = amount.add(players_[acceptOrder.playerAddress].totalAccepted);\r\n        players_[acceptOrder.playerAddress].acceptOrderCount++;\r\n\r\n        if (restOfferAmount_ > 0) {\r\n            matching();\r\n        }\r\n        calcAndSetPlayerTotalCanAccept(acceptOrder.playerAddress, amount);\r\n\r\n        emit onAccepted(acceptOrder.playerAddress, acceptOrder.acceptAmount);\r\n\r\n        return (canAcceptLeft);\r\n    }\r\n\r\n    function withdraw() isHuman() public {\r\n        require(players_[msg.sender].balance >= 1 finney, \"sorry, withdraw at least 1 finney\");\r\n\r\n        uint256 _balance = players_[msg.sender].balance;\r\n        players_[msg.sender].balance = 0;\r\n        msg.sender.transfer(_balance);\r\n\r\n        emit onWithdraw(msg.sender, _balance);\r\n    }\r\n\r\n    //=========================================================...\r\n    //   . _      |`    _  __|_. _  _  _  .\r\n    // \\/|(/_VV  ~|~|_|| |(_ | |(_)| |_\\  . view functions\r\n    //=========================================================\r\n    function getCanAcceptAmount(address playerAddr) public view returns (uint256 canAccept, uint256 earliest) {\r\n        (canAccept, earliest) = calcCanAcceptAmount(playerAddr, true, 0);\r\n        return (canAccept, earliest);\r\n    }\r\n\r\n    function getBalance(address playerAddr) public view returns (uint256) {\r\n        uint256 balance = players_[playerAddr].balance;\r\n        return (balance);\r\n    }\r\n\r\n    function getPlayerInfo(address playerAddr) public view\r\n        returns (uint256 totalAssets, uint256 nextPeriodAssets, uint256 balance, uint256 canAccept, uint256 airdrop, uint256 offered, uint256 accepted, uint256 affiliateEarned, uint256 siteEarned, uint256 nextUpdateTime) {\r\n        FMAPDatasets.Player memory _player = players_[playerAddr];\r\n        uint256 _calculatedCanAccept;\r\n        (_calculatedCanAccept, ) = calcCanAcceptAmount(playerAddr, false, 0);\r\n        totalAssets = _player.balance.add(_calculatedCanAccept);\r\n        (_calculatedCanAccept, ) = calcCanAcceptAmount(playerAddr, false, interestPeriod_);\r\n        nextPeriodAssets = _player.balance.add(_calculatedCanAccept);\r\n        (canAccept, nextUpdateTime) = calcCanAcceptAmount(playerAddr, true, 0);\r\n\r\n        return (totalAssets, nextPeriodAssets, _player.balance, canAccept, _player.airDroped, _player.totalOffered, _player.totalAccepted, _player.affiliateEarned, _player.siteEarned, nextUpdateTime);\r\n    }\r\n\r\n    //=========================================================...\r\n    //  _  _.   _ _|_ _    |`    _  __|_. _  _  _  .\r\n    // |_)| |\\/(_| | (/_  ~|~|_|| |(_ | |(_)| |_\\  . private functions\r\n    //=|=======================================================\r\n    function packageOfferInfo(address siteOwner, uint256 amount) private view returns (FMAPDatasets.OfferInfo) {\r\n        FMAPDatasets.OfferInfo memory offerInfo;\r\n        offerInfo.playerAddress = msg.sender;\r\n        offerInfo.offerAmount = amount;\r\n        offerInfo.affiliateAddress = players_[msg.sender].lastAffiliate;\r\n        offerInfo.siteOwner = siteOwner;\r\n        offerInfo.timestamp = block.timestamp;\r\n        offerInfo.interesting = true;\r\n        return (offerInfo);\r\n    }\r\n\r\n    //=========================================================...\r\n    //  _ _  _ _    |`    _  __|_. _  _  _  .\r\n    // (_(_)| (/_  ~|~|_|| |(_ | |(_)| |_\\  .  core functions\r\n    //=========================================================\r\n    function offerCore(FMAPDatasets.OfferInfo memory offerInfo, bool updateAff) private {\r\n        uint256 _fee = (offerInfo.offerAmount).mul(feePercent_).div(100); // 1% for fee\r\n        uint256 _aff = (offerInfo.offerAmount).mul(affPercent_).div(100); // 5% for affiliate\r\n        uint256 _sit = (offerInfo.offerAmount).mul(sitePercent_).div(100); // 5% for site owner\r\n        uint256 _air = (offerInfo.offerAmount).mul(airDropPercent_).div(100); // 10% for air drop\r\n        uint256 _xt = (offerInfo.offerAmount).mul(xTokenPercent_).div(100); // 3% for x token\r\n\r\n        uint256 _leftAmount = offerInfo.offerAmount;\r\n\r\n        if (offerInfo.affiliateAddress == offerInfo.siteOwner) { // site owner is forbid to be affiliater\r\n            offerInfo.affiliateAddress = address(0);\r\n        }\r\n        // fee\r\n        players_[offerInfo.playerAddress].totalOffered = (offerInfo.offerAmount).add(players_[offerInfo.playerAddress].totalOffered);\r\n        if (offerInfo.affiliateAddress == address(0) || offerInfo.affiliateAddress == offerInfo.playerAddress) {\r\n            _fee = _fee.add(_aff);\r\n            _aff = 0;\r\n        }\r\n        if (offerInfo.siteOwner == address(0) || offerInfo.siteOwner == offerInfo.playerAddress) {\r\n            _fee = _fee.add(_sit);\r\n            _sit = 0;\r\n        }\r\n\r\n        _totalFee = _totalFee.add(_fee);\r\n        _totalXT = _totalXT.add(_xt);\r\n        if (_totalXT > 1 finney) {\r\n            xTokenAddress.transfer(_totalXT);\r\n        }\r\n\r\n        _leftAmount = _leftAmount.sub(_fee);\r\n\r\n        // affiliate\r\n        if (_aff > 0) {\r\n            players_[offerInfo.affiliateAddress].balance = _aff.add(players_[offerInfo.affiliateAddress].balance);\r\n            players_[offerInfo.affiliateAddress].affiliateEarned = _aff.add(players_[offerInfo.affiliateAddress].affiliateEarned);\r\n            _leftAmount = _leftAmount.sub(_aff);\r\n        }\r\n        // site\r\n        if (_sit > 0) {\r\n            players_[offerInfo.siteOwner].balance = _sit.add(players_[offerInfo.siteOwner].balance);\r\n            players_[offerInfo.siteOwner].siteEarned = _sit.add(players_[offerInfo.siteOwner].siteEarned);\r\n            _leftAmount = _leftAmount.sub(_sit);\r\n        }\r\n\r\n        // air drop\r\n        if (offerInfo.offerAmount >= 1 finney) {\r\n            airDropTracker_ = airDropTracker_ + FMAPMath.calcTrackerCount(offerInfo.offerAmount);\r\n            if (airdrop() == true) {\r\n                uint256 _airdrop = FMAPMath.calcAirDropAmount(offerInfo.offerAmount);\r\n                players_[offerInfo.playerAddress].balance = _airdrop.add(players_[offerInfo.playerAddress].balance);\r\n                players_[offerInfo.playerAddress].airDroped = _airdrop.add(players_[offerInfo.playerAddress].airDroped);\r\n                emit onAirDrop(offerInfo.playerAddress, _airdrop, offerInfo.offerAmount);\r\n            }\r\n        }\r\n        airDropPool_ = airDropPool_.add(_air);\r\n        _leftAmount = _leftAmount.sub(_air);\r\n\r\n        if (updateAff) {\r\n            players_[offerInfo.playerAddress].lastAffiliate = offerInfo.affiliateAddress;\r\n        }\r\n\r\n        restOfferAmount_ = restOfferAmount_.add(_leftAmount);\r\n        if (currentOrder_.acceptAmount > currentOrder_.acceptedAmount) {\r\n            matching();\r\n        }\r\n\r\n        playerOfferOrders_[offerInfo.playerAddress][players_[offerInfo.playerAddress].offeredCount] = offerInfo;\r\n        players_[offerInfo.playerAddress].offeredCount = (players_[offerInfo.playerAddress].offeredCount).add(1);\r\n\r\n        if (players_[offerInfo.playerAddress].playerAddress == address(0)) {\r\n            players_[offerInfo.playerAddress].playerAddress = offerInfo.playerAddress;\r\n        }\r\n    }\r\n\r\n    function matching() private {\r\n        while (restOfferAmount_ > 0 && currentOrder_.acceptAmount > currentOrder_.acceptedAmount) {\r\n            uint256 needAcceptAmount = (currentOrder_.acceptAmount).sub(currentOrder_.acceptedAmount);\r\n            if (needAcceptAmount <= restOfferAmount_) { // currentOrder finished\r\n                restOfferAmount_ = restOfferAmount_.sub(needAcceptAmount);\r\n                players_[currentOrder_.playerAddress].balance = needAcceptAmount.add(players_[currentOrder_.playerAddress].balance);\r\n                currentOrder_.acceptedAmount = (currentOrder_.acceptedAmount).add(needAcceptAmount);\r\n                currentOrder_ = acceptOrders_[currentOrder_.nextOrder];\r\n            } else { // offer end\r\n                currentOrder_.acceptedAmount = (currentOrder_.acceptedAmount).add(restOfferAmount_);\r\n                players_[currentOrder_.playerAddress].balance = (players_[currentOrder_.playerAddress].balance).add(restOfferAmount_);\r\n                restOfferAmount_ = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function calcAndSetPlayerTotalCanAccept(address pAddr, uint256 acceptAmount) private {\r\n        uint256 _now = block.timestamp;\r\n        uint256 _latestCalced = players_[pAddr].lastCalcOfferNo;\r\n        uint256 _acceptedAmount = acceptAmount;\r\n\r\n        while(_latestCalced < players_[pAddr].offeredCount) {\r\n            FMAPDatasets.OfferInfo storage oi = playerOfferOrders_[pAddr][_latestCalced];\r\n            uint256 _ts = _now.sub(oi.timestamp);\r\n            if (oi.interesting == true) {\r\n                if (_ts >= maxInterestTime_) {                    \r\n                    // stop interesting...\r\n                    uint256 interest1 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_); // 24 * 7\r\n                    players_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest1);\r\n                    oi.interesting = false;\r\n\r\n                    // set accept\r\n                    if (oi.offerAmount.sub(oi.acceptAmount) > _acceptedAmount) {\r\n                        _acceptedAmount = 0;\r\n                        oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\r\n                    } else {\r\n                        _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\r\n                        oi.acceptAmount = oi.offerAmount;\r\n                    }\r\n                } else if (_acceptedAmount > 0) {\r\n                    if (_acceptedAmount < oi.offerAmount.sub(oi.acceptAmount)) {\r\n                        oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\r\n                        _acceptedAmount = 0;\r\n                    } else {\r\n                        uint256 interest0 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(_ts / interestPeriod_);\r\n                        players_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest0);\r\n                        oi.interesting = false;\r\n                        \r\n                        _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\r\n                        oi.acceptAmount = oi.offerAmount;\r\n            \r\n                    }\r\n                }\r\n            } else if (oi.offerAmount > oi.acceptAmount && _acceptedAmount > 0) {\r\n                // set accept\r\n                if (oi.offerAmount.sub(oi.acceptAmount) > _acceptedAmount) {\r\n                    _acceptedAmount = 0;\r\n                    oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\r\n                } else {\r\n                    _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\r\n                    oi.acceptAmount = oi.offerAmount;\r\n                }\r\n            }\r\n            if (_acceptedAmount == 0) {\r\n                break;\r\n            }\r\n            _latestCalced = _latestCalced + 1;\r\n        }\r\n        players_[pAddr].lastCalcOfferNo = _latestCalced;\r\n    }\r\n\r\n    function airdrop() private view returns (bool) {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, block.number, block.timestamp, block.difficulty, block.gaslimit, airDropTracker_, block.coinbase, msg.sender)));\r\n        if(seed - (seed / 10000).mul(10000) < airDropTracker_) {\r\n            return (true);\r\n        }\r\n        return (false);\r\n    }\r\n\r\n    function calcCanAcceptAmount(address pAddr, bool isLimit, uint256 offsetTime) private view returns (uint256, uint256 nextUpdateTime) {\r\n        uint256 _totalCanAccepted = players_[pAddr].canAccept;\r\n        uint256 i = players_[pAddr].offeredCount;\r\n        uint256 _now = block.timestamp.add(offsetTime);\r\n        uint256 _nextUpdateTime = _now.add(interestPeriod_);\r\n        for(;i > 0; i--) {\r\n            FMAPDatasets.OfferInfo memory oi = playerOfferOrders_[pAddr][i - 1];\r\n            if (oi.interesting == true) {\r\n                uint256 timepassed = _now.sub(oi.timestamp);\r\n                if (!isLimit || (timepassed >= interestPeriod_)) { // at least 1 period\r\n                    uint256 interest;\r\n                    if (timepassed < maxInterestTime_) {\r\n                        interest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(timepassed / interestPeriod_);\r\n                        \r\n                        uint256 oiNextUpdateTime = (timepassed / interestPeriod_).add(1).mul(interestPeriod_).add(oi.timestamp);\r\n                        if (_nextUpdateTime > oiNextUpdateTime) {\r\n                            _nextUpdateTime = oiNextUpdateTime;\r\n                        }\r\n                    } else {\r\n                        interest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_);\r\n                    }\r\n                    _totalCanAccepted = _totalCanAccepted.add(oi.offerAmount).add(interest);\r\n                }\r\n            } else if (oi.timestamp == 0) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return (_totalCanAccepted.sub(players_[pAddr].totalAccepted), _nextUpdateTime);\r\n    }\r\n\r\n}\r\n\r\n//=========================================================...\r\n//  _ _  _ _|_|_   |.|_  _ _  _   .\r\n// | | |(_| | | |  |||_)| (_||\\/  . math library\r\n//============================/============================    \r\nlibrary FMAPMath {\r\n    using SafeMath for uint256;\r\n    function calcTrackerCount(uint256 ethAmount) internal pure returns (uint256) {\r\n        if (ethAmount >= 1 finney && ethAmount < 10 finney) {\r\n            return (1);\r\n        } else if (ethAmount < 50 finney) {\r\n            return (2);\r\n        } else if (ethAmount < 200 finney) {\r\n            return (3);\r\n        } else if (ethAmount < 500 finney) {\r\n            return (4);\r\n        } else if (ethAmount < 1 ether) {\r\n            return (5);\r\n        } else if (ethAmount >= 1 ether) {\r\n            return ethAmount.div(1 ether).add(5);\r\n        }\r\n        return (0);\r\n    }\r\n    function calcAirDropAmount(uint256 ethAmount) internal pure returns (uint256) {\r\n        if (ethAmount >= 1 finney && ethAmount < 10 finney) {\r\n            return (5);\r\n        } else if (ethAmount < 50 finney) {\r\n            return (10);\r\n        } else if (ethAmount < 200 finney) {\r\n            return (15);\r\n        } else if (ethAmount < 500 finney) {\r\n            return (20);\r\n        } else if (ethAmount < 1 ether) {\r\n            return (25);\r\n        } else if (ethAmount >= 1 ether) {\r\n            uint256 a = ethAmount.div(1 ether).add(5).mul(5);\r\n            return (a > 75 ? 75 : a);\r\n        }\r\n        return (0);\r\n    }\r\n}\r\n//=========================================================...\r\n//  __|_ _   __|_  .\r\n// _\\ | ||_|(_ |   .\r\n//=========================================================\r\nlibrary FMAPDatasets {\r\n    struct OfferInfo {\r\n        address playerAddress;\r\n        uint256 offerAmount;\r\n        uint256 acceptAmount; // 不再计算利息\r\n        address affiliateAddress;\r\n        address siteOwner;\r\n        uint256 timestamp;\r\n        bool interesting;\r\n    }\r\n    struct AcceptOrder {\r\n        uint256 orderId;\r\n        address playerAddress;\r\n        uint256 acceptAmount;\r\n        uint256 acceptedAmount;\r\n        uint256 nextOrder;\r\n    }\r\n    struct Player {\r\n        address playerAddress;\r\n        address lastAffiliate;\r\n        uint256 totalOffered;\r\n        uint256 totalAccepted;\r\n        uint256 airDroped;\r\n        uint256 balance; // can withdraw\r\n        uint256 offeredCount;\r\n        uint256 acceptOrderCount;\r\n        uint256 canAccept;\r\n        uint256 lastCalcOfferNo;\r\n        uint256 affiliateEarned;\r\n        uint256 siteEarned;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n    /**\r\n    * Returns whether the target address is a contract\r\n    * @dev This function will return false if invoked during the constructor of a contract,\r\n    * as the code is not actually created until after the constructor finishes.\r\n    * @param addr address to check\r\n    * @return whether the target address is a contract\r\n    */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players_\",\"outputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"lastAffiliate\",\"type\":\"address\"},{\"name\":\"totalOffered\",\"type\":\"uint256\"},{\"name\":\"totalAccepted\",\"type\":\"uint256\"},{\"name\":\"airDroped\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"offeredCount\",\"type\":\"uint256\"},{\"name\":\"acceptOrderCount\",\"type\":\"uint256\"},{\"name\":\"canAccept\",\"type\":\"uint256\"},{\"name\":\"lastCalcOfferNo\",\"type\":\"uint256\"},{\"name\":\"affiliateEarned\",\"type\":\"uint256\"},{\"name\":\"siteEarned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"siteOwner\",\"type\":\"address\"},{\"name\":\"affiliate\",\"type\":\"address\"},{\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"offerHelpUsingBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setTeamWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPool_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestPeriod_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerOfferOrders_\",\"outputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"name\":\"acceptAmount\",\"type\":\"uint256\"},{\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"name\":\"siteOwner\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"interesting\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"acceptOrders_\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"},{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"acceptAmount\",\"type\":\"uint256\"},{\"name\":\"acceptedAmount\",\"type\":\"uint256\"},{\"name\":\"nextOrder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalXT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"totalAssets\",\"type\":\"uint256\"},{\"name\":\"nextPeriodAssets\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"canAccept\",\"type\":\"uint256\"},{\"name\":\"airdrop\",\"type\":\"uint256\"},{\"name\":\"offered\",\"type\":\"uint256\"},{\"name\":\"accepted\",\"type\":\"uint256\"},{\"name\":\"affiliateEarned\",\"type\":\"uint256\"},{\"name\":\"siteEarned\",\"type\":\"uint256\"},{\"name\":\"nextUpdateTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPercent_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"xToken\",\"type\":\"address\"}],\"name\":\"setXToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xTokenPercent_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerAcceptOrders_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"siteOwner\",\"type\":\"address\"},{\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"offerHelp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affPercent_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercent_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"acceptHelp\",\"outputs\":[{\"name\":\"canAcceptLeft\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getCanAcceptAmount\",\"outputs\":[{\"name\":\"canAccept\",\"type\":\"uint256\"},{\"name\":\"earliest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxInterestTime_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sitePercent_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"siteOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"acceptAmount\",\"type\":\"uint256\"}],\"name\":\"onAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"airdropAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offerAmount\",\"type\":\"uint256\"}],\"name\":\"onAirDrop\",\"type\":\"event\"}]","ContractName":"EFMAPlatform","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7d7e36237fc3ac0e69ce863022a527e06c54efa096884e658d7bd91ae3cfd846"}]}