{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface MilAuthInterface {\r\n    function requiredSignatures() external view returns(uint256);\r\n    function requiredDevSignatures() external view returns(uint256);\r\n    function adminCount() external view returns(uint256);\r\n    function devCount() external view returns(uint256);\r\n    function adminName(address _who) external view returns(bytes32);\r\n    function isAdmin(address _who) external view returns(bool);\r\n    function isDev(address _who) external view returns(bool);\r\n    function checkGameRegiester(address _gameAddr) external view returns(bool);\r\n    function checkGameClosed(address _gameAddr) external view returns(bool);\r\n}\r\ninterface MillionaireInterface {\r\n    function invest(address _addr, uint256 _affID, uint256 _mfCoin, uint256 _general) external payable;\r\n    function updateGenVaultAndMask(address _addr, uint256 _affID) external payable;\r\n    function clearGenVaultAndMask(address _addr, uint256 _affID, uint256 _eth, uint256 _milFee) external;\r\n    function assign(address _addr) external payable;\r\n    function splitPot() external payable;   \r\n}\r\ninterface MilFoldInterface {\r\n    function addPot() external payable;\r\n    function activate() external;    \r\n}\r\n\r\ncontract Milevents {\r\n\r\n    // fired whenever a player registers\r\n    event onNewPlayer\r\n    (\r\n        address indexed playerAddress,\r\n        uint256 playerID,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    // fired at end of buy or reload\r\n    event onEndTx\r\n    (\r\n        uint256 rid,                    //current round id\r\n        address indexed buyerAddress,   //buyer address\r\n        uint256 compressData,           //action << 96 | time << 64 | drawCode << 32 | txAction << 8 | roundState\r\n        uint256 eth,                    //buy amount\r\n        uint256 totalPot,               //current total pot\r\n        uint256 tickets,                //buy tickets\r\n        uint256 timeStamp               //buy time\r\n    );\r\n\r\n    // fired at end of buy or reload\r\n    event onGameClose\r\n    (\r\n        address indexed gameAddr,       //game address\r\n        uint256 amount,                 //split eth amount\r\n        uint256 timeStamp               //close time\r\n    );\r\n\r\n    // fired at time who satisfy the reward condition\r\n    event onReward\r\n    (\r\n        address indexed         rewardAddr,     //reward address\r\n        Mildatasets.RewardType  rewardType,     //rewardType\r\n        uint256 amount                          //reward amount\r\n    );\r\n\r\n\t// fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        address indexed playerAddress,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onAffiliatePayout\r\n    (\r\n        address indexed affiliateAddress,\r\n        address indexed buyerAddress,\r\n        uint256 eth,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    // fired at every ico\r\n    event onICO\r\n    (\r\n        address indexed buyerAddress,   //user address who buy ico\r\n        uint256 buyAmount,              //buy ico amount\r\n        uint256 buyMf,                  //eth exchange mfcoin amount\r\n        uint256 totalIco,               //now total ico amount\r\n        bool    ended                   //is ico ended\r\n    );\r\n\r\n    // fired whenever an player win the playround\r\n    event onPlayerWin(\r\n        address indexed addr,\r\n        uint256 roundID,\r\n        uint256 winAmount,\r\n        uint256 winNums\r\n    );\r\n\r\n    event onClaimWinner(\r\n        address indexed addr,\r\n        uint256 winnerNum,\r\n        uint256 totalNum\r\n    );\r\n\r\n    event onBuyMFCoins(\r\n        address indexed addr,\r\n        uint256 ethAmount,\r\n        uint256 mfAmount,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onSellMFCoins(\r\n        address indexed addr,\r\n        uint256 ethAmount,\r\n        uint256 mfAmount,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onUpdateGenVault(\r\n        address indexed addr,\r\n        uint256 mfAmount,\r\n        uint256 genAmount,\r\n        uint256 ethAmount\r\n    );\r\n}\r\n\r\ncontract Millionaire is MillionaireInterface,Milevents {\r\n    using SafeMath for *;\r\n    using MFCoinsCalc for uint256;\r\n\r\n//==============================================================================\r\n//     _ _  _  |`. _     _ _ |_ | _  _  .\r\n//    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\r\n//=================_|===========================================================\r\n    string  constant private    name_ = \"Millionaire Official\";\r\n    uint256 constant private    icoRndMax_ = 2 weeks;        // ico max period\r\n    uint256 private             icoEndtime_;                    // ico end time\r\n    uint256 private             icoAmount_;                     // ico eth amount;\r\n    uint256 private             sequence_;                      // affiliate id sequence\r\n    bool    private             activated_;                     // mark contract is activated;\r\n    bool    private             icoEnd_;                        // is ico ended;\r\n\r\n    MilFoldInterface     public          milFold_;                       // milFold contract\r\n    MilAuthInterface constant private milAuth_ = MilAuthInterface(0xf856f6a413f7756FfaF423aa2101b37E2B3aFFD9);\r\n\r\n    uint256     public          globalMask_;                    // use to calc player gen\r\n    uint256     public          mfCoinPool_;                    // MFCoin Pool\r\n    uint256     public          totalSupply_;                   // MFCoin current supply\r\n\r\n    address constant private fundAddr_ = 0xB0c7Dc00E8A74c9dEc8688EFb98CcB2e24584E3B; // foundation address\r\n    uint256 constant private REGISTER_FEE = 0.01 ether;         // register affiliate fees\r\n    uint256 constant private MAX_ICO_AMOUNT = 3000 ether;       // max tickets you can buy one time\r\n\r\n    mapping(address => uint256) private balance_;               // player coin balance\r\n    mapping(uint256 => address) private plyrAddr_;             // (id => address) returns player id by address\r\n    mapping(address => Mildatasets.Player) private plyr_;      // (addr => data) player data\r\n\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has\r\n     * been activated.\r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not ready start\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting with Millionare\r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 0.1 ether, \"must > 0.1 ether\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev check sender must be devs\r\n     */\r\n    modifier onlyDevs()\r\n    {\r\n        require(milAuth_.isDev(msg.sender) == true, \"msg sender is not a dev\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev default buy set to ico\r\n     */\r\n    function()\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        payable\r\n    {\r\n        icoCore(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev buy MFCoin use eth in ico phase\r\n     */\r\n    function buyICO()\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        payable\r\n    {\r\n        icoCore(msg.value);\r\n    }\r\n\r\n    function icoCore(uint256 _eth) private {\r\n        if (icoEnd_) {\r\n            plyr_[msg.sender].eth = plyr_[msg.sender].eth.add(_eth);\r\n        } else {\r\n            if (block.timestamp > icoEndtime_ || icoAmount_ >= MAX_ICO_AMOUNT) {\r\n                plyr_[msg.sender].eth = plyr_[msg.sender].eth.add(_eth);\r\n                icoEnd_ = true;\r\n\r\n                milFold_.activate();\r\n                emit onICO(msg.sender, 0, 0, MAX_ICO_AMOUNT, icoEnd_);\r\n            } else {\r\n                uint256 ethAmount = _eth;\r\n                if (ethAmount + icoAmount_ > MAX_ICO_AMOUNT) {\r\n                    ethAmount = MAX_ICO_AMOUNT.sub(icoAmount_);\r\n                    plyr_[msg.sender].eth = _eth.sub(ethAmount);\r\n                }\r\n                icoAmount_ = icoAmount_.add(ethAmount);\r\n\r\n                uint256 converts = ethAmount.mul(65)/100;\r\n                uint256 pot = ethAmount.sub(converts);\r\n\r\n                //65% of your eth use to convert MFCoin\r\n                uint256 buytMf = buyMFCoins(msg.sender, converts);\r\n\r\n                //35% of your eth use to pot\r\n                milFold_.addPot.value(pot)();\r\n\r\n                if (icoAmount_ >= MAX_ICO_AMOUNT) {\r\n                    icoEnd_ = true;\r\n\r\n                    milFold_.activate();\r\n                }\r\n                emit onICO(msg.sender, ethAmount, buytMf, icoAmount_, icoEnd_);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw all you earnings to your address\r\n     */\r\n    function withdraw()\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n    {\r\n        updateGenVault(msg.sender);\r\n        if (plyr_[msg.sender].eth > 0) {\r\n            uint256 amount = plyr_[msg.sender].eth;\r\n            plyr_[msg.sender].eth = 0;\r\n            msg.sender.transfer(amount);\r\n            emit onWithdraw(\r\n                msg.sender,\r\n                amount,\r\n                block.timestamp\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev register as a affiliate\r\n     */\r\n    function registerAff()\r\n        public\r\n        isHuman()\r\n        payable\r\n    {\r\n        require (msg.value >= REGISTER_FEE, \"register affiliate fees must >= 0.01 ether\");\r\n        require (plyr_[msg.sender].playerID == 0, \"you already register!\");\r\n        plyrAddr_[++sequence_] = msg.sender;\r\n        plyr_[msg.sender].playerID = sequence_;\r\n        fundAddr_.transfer(msg.value);\r\n        emit onNewPlayer(msg.sender,sequence_, block.timestamp);\r\n    }\r\n\r\n    function setMilFold(address _milFoldAddr)\r\n        public\r\n        onlyDevs\r\n    {\r\n        require(address(milFold_) == 0, \"milFold has been set\");\r\n        require(_milFoldAddr != 0, \"milFold is invalid\");\r\n\r\n        milFold_ = MilFoldInterface(_milFoldAddr);\r\n    }\r\n\r\n    function activate()\r\n        public\r\n        onlyDevs\r\n    {\r\n        require(address(milFold_) != 0, \"milFold has not been set\");\r\n        require(activated_ == false, \"ICO already activated\");\r\n\r\n        // activate the ico\r\n        activated_ = true;\r\n        icoEndtime_ = block.timestamp + icoRndMax_;\r\n    }\r\n\r\n    /**\r\n     * @dev external contracts interact with Millionare via investing MF Coin\r\n     * @param _addr player's address\r\n     * @param _affID affiliate ID\r\n     * @param _mfCoin eth amount to buy MF Coin\r\n     * @param _general eth amount assign to general\r\n     */\r\n    function invest(address _addr, uint256 _affID, uint256 _mfCoin, uint256 _general)\r\n        external\r\n        isActivated()\r\n        payable\r\n    {\r\n        require(milAuth_.checkGameRegiester(msg.sender), \"game no register\");\r\n        require(_mfCoin.add(_general) <= msg.value, \"account is insufficient\");\r\n\r\n        if (msg.value > 0) {\r\n            uint256 tmpAffID = 0;\r\n            if (_affID == 0 || plyrAddr_[_affID] == _addr) {\r\n                tmpAffID = plyr_[_addr].laff;\r\n            } else if (plyr_[_addr].laff == 0 && plyrAddr_[_affID] != address(0)) {\r\n                plyr_[_addr].laff = _affID;\r\n                tmpAffID = _affID;\r\n            }\r\n            \r\n            // if affiliate not exist, assign affiliate to general, i.e. set affiliate to zero\r\n            uint256 _affiliate = msg.value.sub(_mfCoin).sub(_general);\r\n            if (tmpAffID > 0 && _affiliate > 0) {\r\n                address affAddr = plyrAddr_[tmpAffID];\r\n                plyr_[affAddr].affTotal = plyr_[affAddr].affTotal.add(_affiliate);\r\n                plyr_[affAddr].eth = plyr_[affAddr].eth.add(_affiliate);\r\n                emit onAffiliatePayout(affAddr, _addr, _affiliate, block.timestamp);\r\n            }\r\n\r\n            if (totalSupply_ > 0) {\r\n                uint256 delta = _general.mul(1 ether).div(totalSupply_);\r\n                globalMask_ = globalMask_.add(delta);\r\n            } else {\r\n                //if nobody hold MFCoin,so nobody get general,it will give foundation\r\n                fundAddr_.transfer(_general);\r\n            }\r\n\r\n            updateGenVault(_addr);\r\n            \r\n            buyMFCoins(_addr, _mfCoin);\r\n\r\n            emit onUpdateGenVault(_addr, balance_[_addr], plyr_[_addr].genTotal, plyr_[_addr].eth);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\r\n     * @return earnings in wei format\r\n     */\r\n    function calcUnMaskedEarnings(address _addr)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 diffMask = globalMask_.sub(plyr_[_addr].mask);\r\n        if (diffMask > 0) {\r\n            return diffMask.mul(balance_[_addr]).div(1 ether);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev updates masks for round and player when keys are bought\r\n     */\r\n    function updateGenVaultAndMask(address _addr, uint256 _affID)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(milFold_), \"no authrity\");\r\n\r\n        if (msg.value > 0) {\r\n            /**\r\n             * 50/80 use to convert MFCoin\r\n             * 10/80 use to affiliate\r\n             * 20/80 use to general\r\n             */\r\n            uint256 converts = msg.value.mul(50).div(80);\r\n\r\n            uint256 tmpAffID = 0;\r\n            if (_affID == 0 || plyrAddr_[_affID] == _addr) {\r\n                tmpAffID = plyr_[_addr].laff;\r\n            } else if (plyr_[_addr].laff == 0 && plyrAddr_[_affID] != address(0)) {\r\n                plyr_[_addr].laff = _affID;\r\n                tmpAffID = _affID;\r\n            }\r\n            uint256 affAmount = 0;\r\n            if (tmpAffID > 0) {\r\n                affAmount = msg.value.mul(10).div(80);\r\n                address affAddr = plyrAddr_[tmpAffID];\r\n                plyr_[affAddr].affTotal = plyr_[affAddr].affTotal.add(affAmount);\r\n                plyr_[affAddr].eth = plyr_[affAddr].eth.add(affAmount);\r\n                emit onAffiliatePayout(affAddr, _addr, affAmount, block.timestamp);\r\n            }\r\n            if (totalSupply_ > 0) {\r\n                uint256 delta = msg.value.sub(converts).sub(affAmount).mul(1 ether).div(totalSupply_);\r\n                globalMask_ = globalMask_.add(delta);\r\n            } else {\r\n                //if nobody hold MFCoin,so nobody get general,it will give foundation\r\n                fundAddr_.transfer(msg.value.sub(converts).sub(affAmount));\r\n            }\r\n            \r\n            updateGenVault(_addr);\r\n            \r\n            buyMFCoins(_addr, converts);\r\n\r\n            emit onUpdateGenVault(_addr, balance_[_addr], plyr_[_addr].genTotal, plyr_[_addr].eth);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev game contract has been paid 20% amount for Millionaire and paid back now\r\n     */\r\n    function clearGenVaultAndMask(address _addr, uint256 _affID, uint256 _eth, uint256 _milFee)\r\n        external\r\n    {\r\n        require(msg.sender == address(milFold_), \"no authrity\");\r\n\r\n        //check player eth balance is enough pay for\r\n        uint256 _earnings = calcUnMaskedEarnings(_addr);\r\n        require(plyr_[_addr].eth.add(_earnings) >= _eth, \"eth balance not enough\");\r\n        \r\n        /**\r\n         * 50/80 use to convert MFCoin\r\n         * 10/80 use to affiliate\r\n         * 20/80 use to general\r\n         */\r\n        uint256 converts = _milFee.mul(50).div(80);\r\n        \r\n        uint256 tmpAffID = 0;\r\n        if (_affID == 0 || plyrAddr_[_affID] == _addr) {\r\n            tmpAffID = plyr_[_addr].laff;\r\n        } else if (plyr_[_addr].laff == 0 && plyrAddr_[_affID] != address(0)) {\r\n            plyr_[_addr].laff = _affID;\r\n            tmpAffID = _affID;\r\n        }\r\n        \r\n        uint256 affAmount = 0;\r\n        if (tmpAffID > 0) {\r\n            affAmount = _milFee.mul(10).div(80);\r\n            address affAddr = plyrAddr_[tmpAffID];\r\n            plyr_[affAddr].affTotal = plyr_[affAddr].affTotal.add(affAmount);\r\n            plyr_[affAddr].eth = plyr_[affAddr].eth.add(affAmount);\r\n\r\n            emit onAffiliatePayout(affAddr, _addr, affAmount, block.timestamp);\r\n        }\r\n        if (totalSupply_ > 0) {\r\n            uint256 delta = _milFee.sub(converts).sub(affAmount).mul(1 ether).div(totalSupply_);\r\n            globalMask_ = globalMask_.add(delta);\r\n        } else {\r\n            //if nobody hold MFCoin,so nobody get general,it will give foundation\r\n            fundAddr_.transfer(_milFee.sub(converts).sub(affAmount));\r\n        }\r\n\r\n        updateGenVault(_addr);\r\n        \r\n        buyMFCoins(_addr,converts);\r\n\r\n        plyr_[_addr].eth = plyr_[_addr].eth.sub(_eth);\r\n        milFold_.addPot.value(_eth.sub(_milFee))();\r\n\r\n        emit onUpdateGenVault(_addr, balance_[_addr], plyr_[_addr].genTotal, plyr_[_addr].eth);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(address _addr) private\r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_addr);\r\n        if (_earnings > 0) {\r\n            plyr_[_addr].mask = globalMask_;\r\n            plyr_[_addr].genTotal = plyr_[_addr].genTotal.add(_earnings);\r\n            plyr_[_addr].eth = plyr_[_addr].eth.add(_earnings);\r\n        } else if (globalMask_ > plyr_[_addr].mask) {\r\n            plyr_[_addr].mask = globalMask_;\r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @dev convert eth to coin\r\n     * @param _addr user address\r\n     * @return return back coins\r\n     */\r\n    function buyMFCoins(address _addr, uint256 _eth) private returns(uint256) {\r\n        uint256 _coins = calcCoinsReceived(_eth);\r\n        mfCoinPool_ = mfCoinPool_.add(_eth);\r\n        totalSupply_ = totalSupply_.add(_coins);\r\n        balance_[_addr] = balance_[_addr].add(_coins);\r\n\r\n        emit onBuyMFCoins(_addr, _eth, _coins, now);\r\n        return _coins;\r\n    }\r\n\r\n    /**\r\n     * @dev sell coin to eth\r\n     * @param _coins sell coins\r\n     * @return return back eth\r\n     */\r\n    function sellMFCoins(uint256 _coins) public {\r\n        require(icoEnd_, \"ico phase not end\");\r\n        require(balance_[msg.sender] >= _coins, \"coins amount is out of range\");\r\n\r\n        updateGenVault(msg.sender);\r\n        \r\n        uint256 _eth = totalSupply_.ethRec(_coins);\r\n        mfCoinPool_ = mfCoinPool_.sub(_eth);\r\n        totalSupply_ = totalSupply_.sub(_coins);\r\n        balance_[msg.sender] = balance_[msg.sender].sub(_coins);\r\n\r\n        if (milAuth_.checkGameClosed(address(milFold_))) {\r\n            plyr_[msg.sender].eth = plyr_[msg.sender].eth.add(_eth);\r\n        } else {\r\n            /**\r\n             * 10/100 transfer to pot\r\n             * 90/100 transfer to owner\r\n             */\r\n            uint256 earnAmount = _eth.mul(90).div(100);\r\n            plyr_[msg.sender].eth = plyr_[msg.sender].eth.add(earnAmount);\r\n    \r\n            milFold_.addPot.value(_eth.sub(earnAmount))();\r\n        }\r\n        \r\n        emit onSellMFCoins(msg.sender, earnAmount, _coins, now);\r\n    }\r\n\r\n    /**\r\n     * @dev anyone winner of milfold will call this function\r\n     * @param _addr winner address\r\n     */\r\n    function assign(address _addr)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(milFold_), \"no authrity\");\r\n\r\n        plyr_[_addr].eth = plyr_[_addr].eth.add(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev If unfortunate the game has problem or has no winner at long time, we'll end the game and divide the pot equally among all MF users\r\n     */\r\n    function splitPot()\r\n        external\r\n        payable\r\n    {\r\n        require(milAuth_.checkGameClosed(msg.sender), \"game has not been closed\");\r\n        \r\n        uint256 delta = msg.value.mul(1 ether).div(totalSupply_);\r\n        globalMask_ = globalMask_.add(delta);\r\n        emit onGameClose(msg.sender, msg.value, now);\r\n    }\r\n\r\n    /**\r\n     * @dev returns ico info\r\n     * @return ico end time\r\n     * @return already ico summary\r\n     * @return ico phase is end\r\n     */\r\n    function getIcoInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, bool) {\r\n        return (icoAmount_, icoEndtime_, icoEnd_);\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address\r\n     * @param _addr address of the player you want to lookup\r\n     * @return player ID\r\n     * @return player eth balance\r\n     * @return player MFCoin\r\n     * @return general vault\r\n     * @return affiliate vault\r\n     */\r\n    function getPlayerAccount(address _addr)\r\n        public\r\n        isActivated()\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        uint256 genAmount = calcUnMaskedEarnings(_addr);\r\n        return (\r\n            plyr_[_addr].playerID,\r\n            plyr_[_addr].eth.add(genAmount),\r\n            balance_[_addr],\r\n            plyr_[_addr].genTotal.add(genAmount),\r\n            plyr_[_addr].affTotal\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev give _eth can convert how much MFCoin\r\n     * @param _eth eth i will give\r\n     * @return MFCoin will return back\r\n     */\r\n    function calcCoinsReceived(uint256 _eth)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return mfCoinPool_.keysRec(_eth);\r\n    }\r\n\r\n    /**\r\n     * @dev returns current eth price for X coins.\r\n     * @param _coins number of coins desired (in 18 decimal format)\r\n     * @return amount of eth needed to send\r\n     */\r\n    function calcEthReceived(uint256 _coins)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (totalSupply_ < _coins) {\r\n            return 0;\r\n        }\r\n        return totalSupply_.ethRec(_coins);\r\n    }\r\n\r\n    function getMFBalance(address _addr)\r\n        public\r\n        view\r\n        returns(uint256) {\r\n        return balance_[_addr];\r\n    }\r\n\r\n}\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary Mildatasets {\r\n\r\n    // between `DRAWN' and `ASSIGNED', someone need to claim winners.\r\n    enum RoundState {\r\n        UNKNOWN,        // aim to differ from normal states\r\n        STARTED,        // start current round\r\n        STOPPED,        // stop current round\r\n        DRAWN,          // draw code\r\n        ASSIGNED        // assign to foundation, winners, and migrate the rest to the next round\r\n    }\r\n\r\n    // MilFold Transaction Action.\r\n    enum TxAction {\r\n        UNKNOWN,        // default\r\n        BUY,            // buy or reload tickets and so on \r\n        DRAW,           // draw code of game \r\n        ASSIGN,         // assign to winners\r\n        ENDROUND        // end game and start new round\r\n    }\r\n\r\n    // RewardType\r\n    enum RewardType {\r\n        UNKNOWN,        // default\r\n        DRAW,           // draw code\r\n        ASSIGN,         // assign winner\r\n        END,            // end game\r\n        CLIAM           // winner cliam\r\n    }\r\n\r\n    struct Player {\r\n        uint256 playerID;       // Player id(use to affiliate other player)\r\n        uint256 eth;            // player eth balance\r\n        uint256 mask;           // player mask\r\n        uint256 genTotal;       // general total vault\r\n        uint256 affTotal;       // affiliate total vault\r\n        uint256 laff;           // last affiliate id used\r\n    }\r\n\r\n    struct Round {\r\n        uint256                         roundDeadline;      // deadline to end round\r\n        uint256                         claimDeadline;      // deadline to claim winners\r\n        uint256                         pot;                // pot\r\n        uint256                         blockNumber;        // draw block number(last one)\r\n        RoundState                      state;              // round state\r\n        uint256                         drawCode;           // draw code\r\n        uint256                         totalNum;           // total number\r\n        mapping (address => uint256)    winnerNum;          // winners' number\r\n        address[]                       winners;            // winners\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr\r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  |  _      _ _ | _  .\r\n//  |<(/_\\/  (_(_||(_  .\r\n//=======/======================================================================\r\nlibrary MFCoinsCalc {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth\r\n     * @param _curEth current amount of eth in contract\r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys\r\n     * @param _curKeys current amount of keys that exist\r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return (((((_eth).mul(1000000000000000000).mul(2000000000000000000000000000)).add(39999800000250000000000000000000000000000000000000000000000000000)).sqrt()).sub(199999500000000000000000000000000)) / (1000000000);\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\"\r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((500000000).mul(_keys.sq()).add(((399999000000000).mul(_keys.mul(1000000000000000000))) / (2) )) / ((1000000000000000000).sq());\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_coins\",\"type\":\"uint256\"}],\"name\":\"calcEthReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerAff\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mfCoinPool_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_affID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_milFee\",\"type\":\"uint256\"}],\"name\":\"clearGenVaultAndMask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcCoinsReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_milFoldAddr\",\"type\":\"address\"}],\"name\":\"setMilFold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIcoInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"assign\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"milFold_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coins\",\"type\":\"uint256\"}],\"name\":\"sellMFCoins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getMFBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_affID\",\"type\":\"uint256\"}],\"name\":\"updateGenVaultAndMask\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalMask_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyICO\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"splitPot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_affID\",\"type\":\"uint256\"},{\"name\":\"_mfCoin\",\"type\":\"uint256\"},{\"name\":\"_general\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"compressData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tickets\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onGameClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rewardAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyMf\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalIco\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ended\",\"type\":\"bool\"}],\"name\":\"onICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winNums\",\"type\":\"uint256\"}],\"name\":\"onPlayerWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalNum\",\"type\":\"uint256\"}],\"name\":\"onClaimWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mfAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onBuyMFCoins\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mfAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onSellMFCoins\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mfAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"onUpdateGenVault\",\"type\":\"event\"}]","ContractName":"Millionaire","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://19344f09337febac2ce136703d5a2e1deb14f3d31e0b173b4d29c86dd14c2bed"}]}