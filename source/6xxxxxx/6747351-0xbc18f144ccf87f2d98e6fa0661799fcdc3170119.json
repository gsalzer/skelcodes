{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Interface for the Polymath Module Registry contract\r\n */\r\ninterface IModuleRegistry {\r\n\r\n    /**\r\n     * @notice Called by a security token to notify the registry it is using a module\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     */\r\n    function useModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner to register new modules for SecurityToken to use\r\n     * @param _moduleFactory is the address of the module factory to be registered\r\n     */\r\n    function registerModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner or registry curator to delete a ModuleFactory\r\n     * @param _moduleFactory is the address of the module factory to be deleted\r\n     */\r\n    function removeModule(address _moduleFactory) external;\r\n\r\n    /**\r\n    * @notice Called by Polymath to verify modules for SecurityToken to use.\r\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\r\n    * @notice (The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry)\r\n    * @param _moduleFactory is the address of the module factory to be registered\r\n    */\r\n    function verifyModule(address _moduleFactory, bool _verified) external;\r\n\r\n    /**\r\n     * @notice Used to get the reputation of a Module Factory\r\n     * @param _factoryAddress address of the Module Factory\r\n     * @return address array which has the list of securityToken's uses that module factory\r\n     */\r\n    function getReputationByFactory(address _factoryAddress) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @param _securityToken is the token\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns(bytes32[], address[]);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByType(uint8 _moduleType) external view returns(bytes32[], address[]);\r\n\r\n    /**\r\n     * @notice Returns the list of addresses of Module Factory of a particular type\r\n     * @param _moduleType Type of Module\r\n     * @return address array that contains the list of addresses of module factory contracts.\r\n     */\r\n    function getModulesByType(uint8 _moduleType) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice Returns the list of available Module factory addresses of a particular type for a given token.\r\n     * @param _moduleType is the module type to look for\r\n     * @param _securityToken is the address of SecurityToken\r\n     * @return address array that contains the list of available addresses of module factory contracts.\r\n     */\r\n    function getModulesByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Use to get the latest contract address of the regstries\r\n     */\r\n    function updateFromRegistry() external;\r\n\r\n    /**\r\n     * @notice Get the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address);\r\n\r\n    /**\r\n     * @notice Check whether the contract operations is paused or not\r\n     * @return bool \r\n     */\r\n    function isPaused() external view returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module factory contract should implement\r\n */\r\ninterface IModuleFactory {\r\n\r\n    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);\r\n    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\r\n    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\r\n    event GenerateModuleFromFactory(\r\n        address _module,\r\n        bytes32 indexed _moduleName,\r\n        address indexed _moduleFactory,\r\n        address _creator,\r\n        uint256 _setupCost,\r\n        uint256 _timestamp\r\n    );\r\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    //Should create an instance of the Module, or throw\r\n    function deploy(bytes _data) external returns(address);\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getTypes() external view returns(uint8[]);\r\n\r\n    /**\r\n     * @notice Get the name of the Module\r\n     */\r\n    function getName() external view returns(bytes32);\r\n\r\n    /**\r\n     * @notice Returns the instructions associated with the module\r\n     */\r\n    function getInstructions() external view returns (string);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() external view returns (bytes32[]);\r\n\r\n    /**\r\n     * @notice Used to change the setup fee\r\n     * @param _newSetupCost New setup fee\r\n     */\r\n    function changeFactorySetupFee(uint256 _newSetupCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the usage fee\r\n     * @param _newUsageCost New usage fee\r\n     */\r\n    function changeFactoryUsageFee(uint256 _newUsageCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the subscription fee\r\n     * @param _newSubscriptionCost New subscription fee\r\n     */\r\n    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) external;\r\n\r\n    /**\r\n     * @notice Function use to change the lower and upper bound of the compatible version st\r\n     * @param _boundType Type of bound\r\n     * @param _newVersion New version array\r\n     */\r\n    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external;\r\n\r\n   /**\r\n     * @notice Get the setup cost of the module\r\n     */\r\n    function getSetupCost() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Used to get the lower bound\r\n     * @return Lower bound\r\n     */\r\n    function getLowerSTVersionBounds() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Used to get the upper bound\r\n     * @return Upper bound\r\n     */\r\n    function getUpperSTVersionBounds() external view returns(uint8[]);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for the Polymath Security Token Registry contract\r\n */\r\ninterface ISecurityTokenRegistry {\r\n\r\n   /**\r\n     * @notice Creates a new Security Token and saves it to the registry\r\n     * @param _name Name of the token\r\n     * @param _ticker Ticker ticker of the security token\r\n     * @param _tokenDetails Off-chain details of the token\r\n     * @param _divisible Whether the token is divisible or not\r\n     */\r\n    function generateSecurityToken(string _name, string _ticker, string _tokenDetails, bool _divisible) external;\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _name Name of the token\r\n     * @param _ticker Ticker of the security token\r\n     * @param _owner Owner of the token\r\n     * @param _securityToken Address of the securityToken\r\n     * @param _tokenDetails Off-chain details of the token\r\n     * @param _deployedAt Timestamp at which security token comes deployed on the ethereum blockchain\r\n     */\r\n    function modifySecurityToken(\r\n        string _name,\r\n        string _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Registers the token ticker for its particular owner\r\n     * @notice once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner Address of the owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     */\r\n    function registerTicker(address _owner, string _ticker, string _tokenName) external;\r\n\r\n    /**\r\n    * @notice Changes the protocol version and the SecurityToken contract\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _STFactoryAddress Address of the proxy.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n    * @notice Check that Security Token is registered\r\n    * @param _securityToken Address of the Scurity token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n    /**\r\n     * @notice Get security token address by ticker name\r\n     * @param _ticker Symbol of the Scurity token\r\n     * @return address\r\n     */\r\n    function getSecurityTokenAddress(string _ticker) external view returns (address);\r\n\r\n     /**\r\n     * @notice Get security token data by its address\r\n     * @param _securityToken Address of the Scurity token.\r\n     * @return string Symbol of the Security Token.\r\n     * @return address Address of the issuer of Security Token.\r\n     * @return string Details of the Token.\r\n     * @return uint256 Timestamp at which Security Token get launched on Polymath platform.\r\n     */\r\n    function getSecurityTokenData(address _securityToken) external view returns (string, address, string, uint256);\r\n\r\n    /**\r\n     * @notice Get the current STFactory Address\r\n     */\r\n    function getSTFactoryAddress() external view returns(address);\r\n\r\n    /**\r\n     * @notice Get Protocol version\r\n     */\r\n    function getProtocolVersion() external view returns(uint8[]);\r\n\r\n    /**\r\n     * @notice Used to get the ticker list as per the owner\r\n     * @param _owner Address which owns the list of tickers\r\n     */\r\n    function getTickersByOwner(address _owner) external view returns(bytes32[]);\r\n\r\n    /**\r\n     * @notice Returns the list of tokens owned by the selected address\r\n     * @param _owner is the address which owns the list of tickers\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokensByOwner(address _owner) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice Returns the owner and timestamp for a given ticker\r\n     * @param _ticker ticker\r\n     * @return address\r\n     * @return uint256\r\n     * @return uint256\r\n     * @return string\r\n     * @return bool\r\n     */\r\n    function getTickerDetails(string _ticker) external view returns (address, uint256, uint256, string, bool);\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only polymath account has the ability\r\n     * to do so. Only allowed to modify the tickers which are not yet deployed\r\n     * @param _owner Owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     * @param _registrationDate Date on which ticker get registered\r\n     * @param _expiryDate Expiry date of the ticker\r\n     * @param _status Token deployed status\r\n     */\r\n    function modifyTicker(\r\n        address _owner,\r\n        string _ticker,\r\n        string _tokenName,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        external;\r\n\r\n     /**\r\n     * @notice Removes the ticker details and associated ownership & security token mapping\r\n     * @param _ticker Token ticker\r\n     */\r\n    function removeTicker(string _ticker) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of the ticker\r\n     * @dev _newOwner Address whom ownership to transfer\r\n     * @dev _ticker Ticker\r\n     */\r\n    function transferTickerOwnership(address _newOwner, string _ticker) external;\r\n\r\n    /**\r\n     * @notice Changes the expiry time for the token ticker\r\n     * @param _newExpiry New time period for token ticker expiry\r\n     */\r\n    function changeExpiryLimit(uint256 _newExpiry) external;\r\n\r\n    /**\r\n    * @notice Sets the ticker registration fee in POLY tokens\r\n    * @param _tickerRegFee Registration fee in POLY tokens (base 18 decimals)\r\n    */\r\n   function changeTickerRegistrationFee(uint256 _tickerRegFee) external;\r\n\r\n   /**\r\n    * @notice Sets the ticker registration fee in POLY tokens\r\n    * @param _stLaunchFee Registration fee in POLY tokens (base 18 decimals)\r\n    */\r\n   function changeSecurityLaunchFee(uint256 _stLaunchFee) external;\r\n\r\n    /**\r\n     * @notice Change the PolyToken address\r\n     * @param _newAddress Address of the polytoken\r\n     */\r\n    function updatePolyTokenAddress(address _newAddress) external;\r\n\r\n    /**\r\n     * @notice Gets the security token launch fee\r\n     * @return Fee amount\r\n     */\r\n    function getSecurityTokenLaunchFee() external view returns(uint256);\r\n\r\n    /**\r\n     * @notice Gets the ticker registration fee\r\n     * @return Fee amount\r\n     */\r\n    function getTickerRegistrationFee() external view returns(uint256);\r\n\r\n    /**\r\n     * @notice Gets the expiry limit\r\n     * @return Expiry limit\r\n     */\r\n    function getExpiryLimit() external view returns(uint256);\r\n\r\n    /**\r\n     * @notice Checks whether the registry is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() external view returns(bool);\r\n\r\n    /**\r\n     * @notice Gets the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address);\r\n\r\n}\r\n\r\ninterface IPolymathRegistry {\r\n\r\n    /**\r\n     * @notice Returns the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @return address\r\n     */\r\n    function getAddress(string _nameKey) external view returns(address);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for managing polymath feature switches\r\n */\r\ninterface IFeatureRegistry {\r\n\r\n    /**\r\n     * @notice Get the status of a feature\r\n     * @param _nameKey is the key for the feature status mapping\r\n     * @return bool\r\n     */\r\n    function getFeatureStatus(string _nameKey) external view returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Helper library use to compare or validate the semantic versions\r\n */\r\n\r\nlibrary VersionUtils {\r\n\r\n    /**\r\n     * @notice This function is used to validate the version submitted\r\n     * @param _current Array holds the present version of ST\r\n     * @param _new Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function isValidVersion(uint8[] _current, uint8[] _new) internal pure returns(bool) {\r\n        bool[] memory _temp = new bool[](_current.length);\r\n        uint8 counter = 0;\r\n        for (uint8 i = 0; i < _current.length; i++) {\r\n            if (_current[i] < _new[i])\r\n                _temp[i] = true;\r\n            else\r\n                _temp[i] = false;\r\n        }\r\n\r\n        for (i = 0; i < _current.length; i++) {\r\n            if (i == 0) {\r\n                if (_current[i] <= _new[i])\r\n                    if(_temp[0]) {\r\n                        counter = counter + 3;\r\n                        break;\r\n                    } else\r\n                        counter++;\r\n                else\r\n                    return false;\r\n            } else {\r\n                if (_temp[i-1])\r\n                    counter++;\r\n                else if (_current[i] <= _new[i])\r\n                    counter++;\r\n                else\r\n                    return false;\r\n            }\r\n        }\r\n        if (counter == _current.length)\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to compare the lower bound with the latest version\r\n     * @param _version1 Array holds the lower bound of the version\r\n     * @param _version2 Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function compareLowerBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\r\n        require(_version1.length == _version2.length, \"Input length mismatch\");\r\n        uint counter = 0;\r\n        for (uint8 j = 0; j < _version1.length; j++) {\r\n            if (_version1[j] == 0)\r\n                counter ++;\r\n        }\r\n        if (counter != _version1.length) {\r\n            counter = 0;\r\n            for (uint8 i = 0; i < _version1.length; i++) {\r\n                if (_version2[i] > _version1[i])\r\n                    return true;\r\n                else if (_version2[i] < _version1[i])\r\n                    return false;\r\n                else\r\n                    counter++;\r\n            }\r\n            if (counter == _version1.length - 1)\r\n                return true;\r\n            else\r\n                return false;\r\n        } else\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to compare the upper bound with the latest version\r\n     * @param _version1 Array holds the upper bound of the version\r\n     * @param _version2 Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function compareUpperBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\r\n        require(_version1.length == _version2.length, \"Input length mismatch\");\r\n        uint counter = 0;\r\n        for (uint8 j = 0; j < _version1.length; j++) {\r\n            if (_version1[j] == 0)\r\n                counter ++;\r\n        }\r\n        if (counter != _version1.length) {\r\n            counter = 0;\r\n            for (uint8 i = 0; i < _version1.length; i++) {\r\n                if (_version1[i] > _version2[i])\r\n                    return true;\r\n                else if (_version1[i] < _version2[i])\r\n                    return false;\r\n                else\r\n                    counter++;\r\n            }\r\n            if (counter == _version1.length - 1)\r\n                return true;\r\n            else\r\n                return false;\r\n        } else\r\n            return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Used to pack the uint8[] array data into uint24 value\r\n     * @param _major Major version\r\n     * @param _minor Minor version\r\n     * @param _patch Patch version\r\n     */\r\n    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {\r\n        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to convert packed data into uint8 array\r\n     * @param _packedVersion Packed data\r\n     */\r\n    function unpack(uint24 _packedVersion) internal pure returns (uint8[]) {\r\n        uint8[] memory _unpackVersion = new uint8[](3);\r\n        _unpackVersion[0] = uint8(_packedVersion >> 16);\r\n        _unpackVersion[1] = uint8(_packedVersion >> 8);\r\n        _unpackVersion[2] = uint8(_packedVersion);\r\n        return _unpackVersion;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract EternalStorage {\r\n\r\n    /// @notice Internal mappings used to store all kinds on data into the contract\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n    mapping(bytes32 => bytes32) internal bytes32Storage;\r\n\r\n    /// @notice Internal mappings used to store arrays of different data types\r\n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\r\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\r\n    mapping(bytes32 => address[]) internal addressArrayStorage;\r\n    mapping(bytes32 => string[]) internal stringArrayStorage;\r\n\r\n    //////////////////\r\n    //// set functions\r\n    //////////////////\r\n    /// @notice Set the key values using the Overloaded `set` functions\r\n    /// Ex- string version = \"0.0.1\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"version\"), \"0.0.1\");\r\n    /// same for the other variables as well some more example listed below\r\n    /// ex1 - address securityTokenAddress = 0x123; replace to\r\n    /// set(keccak256(abi.encodePacked(\"securityTokenAddress\"), 0x123);\r\n    /// ex2 - bytes32 tokenDetails = \"I am ST20\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"tokenDetails\"), \"I am ST20\");\r\n    /// ex3 - mapping(string => address) ownedToken;\r\n    /// set(keccak256(abi.encodePacked(\"ownedToken\", \"Chris\")), 0x123);\r\n    /// ex4 - mapping(string => uint) tokenIndex;\r\n    /// tokenIndex[\"TOKEN\"] = 1; replace to set(keccak256(abi.encodePacked(\"tokenIndex\", \"TOKEN\"), 1);\r\n    /// ex5 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// registeredSymbols[\"TOKEN\"].name = \"MyFristToken\"; replace to set(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"), \"MyFirstToken\");\r\n    /// More generalized- set(keccak256(abi.encodePacked(\"registeredSymbols_<struct variable>\", \"keyname\"), \"value\");\r\n\r\n    function set(bytes32 _key, uint256 _value) internal {\r\n        uintStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, address _value) internal {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bool _value) internal {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bytes32 _value) internal {\r\n        bytes32Storage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, string _value) internal {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    ////////////////////\r\n    /// get functions\r\n    ////////////////////\r\n    /// @notice Get function use to get the value of the singleton state variables\r\n    /// Ex1- string public version = \"0.0.1\";\r\n    /// string _version = getString(keccak256(abi.encodePacked(\"version\"));\r\n    /// Ex2 - assert(temp1 == temp2); replace to\r\n    /// assert(getUint(keccak256(abi.encodePacked(temp1)) == getUint(keccak256(abi.encodePacked(temp2));\r\n    /// Ex3 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// string _name = getString(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"));\r\n\r\n    function getBool(bytes32 _key) internal view returns (bool) {\r\n        return boolStorage[_key];\r\n    }\r\n\r\n    function getUint(bytes32 _key) internal view returns (uint256) {\r\n        return uintStorage[_key];\r\n    }\r\n\r\n    function getAddress(bytes32 _key) internal view returns (address) {\r\n        return addressStorage[_key];\r\n    }\r\n\r\n    function getString(bytes32 _key) internal view returns (string) {\r\n        return stringStorage[_key];\r\n    }\r\n\r\n    function getBytes32(bytes32 _key) internal view returns (bytes32) {\r\n        return bytes32Storage[_key];\r\n    }\r\n\r\n\r\n    ////////////////////////////\r\n    // deleteArray functions\r\n    ////////////////////////////\r\n    /// @notice Function used to delete the array element.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// For deleting the item from array developers needs to create a funtion for that similarly\r\n    /// in this case we have the helper function deleteArrayBytes32() which will do it for us\r\n    /// deleteArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1), 3); -- it will delete the index 3\r\n\r\n\r\n    //Deletes from mapping (bytes32 => array[]) at index _index\r\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\r\n        address[] storage array = addressArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\r\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\r\n        bytes32[] storage array = bytes32ArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => uint[]) at index _index\r\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\r\n        uint256[] storage array = uintArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => string[]) at index _index\r\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\r\n        string[] storage array = stringArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    ////////////////////////////\r\n    //// pushArray functions\r\n    ///////////////////////////\r\n    /// @notice Below are the helper functions to facilitate storing arrays of different data types.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByTicker;\r\n    /// tokensOwnedByTicker[owner] = tokensOwnedByTicker[owner].push(\"xyz\"); replace with\r\n    /// pushArray(keccak256(abi.encodePacked(\"tokensOwnedByTicker\", owner), \"xyz\");\r\n\r\n    /// @notice use to store the values for the array\r\n    /// @param _key bytes32 type\r\n    /// @param _value [uint256, string, bytes32, address] any of the data type in array\r\n    function pushArray(bytes32 _key, address _value) internal {\r\n        addressArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, string _value) internal {\r\n        stringArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, uint256 _value) internal {\r\n        uintArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    /////////////////////////\r\n    //// Set Array functions\r\n    ////////////////////////\r\n    /// @notice used to intialize the array\r\n    /// Ex1- mapping (address => address[]) public reputation;\r\n    /// reputation[0x1] = new address[](0); It can be replaced as\r\n    /// setArray(hash('reputation', 0x1), new address[](0)); \r\n    \r\n    function setArray(bytes32 _key, address[] _value) internal {\r\n        addressArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, uint256[] _value) internal {\r\n        uintArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, bytes32[] _value) internal {\r\n        bytes32ArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, string[] _value) internal {\r\n        stringArrayStorage[_key] = _value;\r\n    }\r\n\r\n    /////////////////////////\r\n    /// getArray functions\r\n    /////////////////////////\r\n    /// @notice Get functions to get the array of the required data type\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)); It return the bytes32 array\r\n    /// Ex2- uint256 _len =  tokensOwnedByOwner[0x1].length; replace with\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)).length;\r\n\r\n    function getArrayAddress(bytes32 _key) internal view returns(address[]) {\r\n        return addressArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayBytes32(bytes32 _key) internal view returns(bytes32[]) {\r\n        return bytes32ArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayString(bytes32 _key) internal view returns(string[]) {\r\n        return stringArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayUint(bytes32 _key) internal view returns(uint[]) {\r\n        return uintArrayStorage[_key];\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    /// setArrayIndexValue() functions\r\n    ///////////////////////////////////\r\n    /// @notice set the value of particular index of the address array\r\n    /// Ex1- mapping(bytes32 => address[]) moduleList;\r\n    /// general way is -- moduleList[moduleType][index] = temp; \r\n    /// It can be re-write as -- setArrayIndexValue(keccak256(abi.encodePacked('moduleList', moduleType)), index, temp); \r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\r\n        addressArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\r\n        uintArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string _value) internal {\r\n        stringArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n        /////////////////////////////\r\n        /// Public getters functions\r\n        /////////////////////////////\r\n\r\n    function getUintValues(bytes32 _variable) public view returns(uint256) {\r\n        return uintStorage[_variable];\r\n    }\r\n\r\n    function getBoolValues(bytes32 _variable) public view returns(bool) {\r\n        return boolStorage[_variable];\r\n    }\r\n\r\n    function getStringValues(bytes32 _variable) public view returns(string) {\r\n        return stringStorage[_variable];\r\n    }\r\n\r\n    function getAddressValues(bytes32 _variable) public view returns(address) {\r\n        return addressStorage[_variable];\r\n    }\r\n\r\n    function getBytes32Values(bytes32 _variable) public view returns(bytes32) {\r\n        return bytes32Storage[_variable];\r\n    }\r\n\r\n    function getBytesValues(bytes32 _variable) public view returns(bytes) {\r\n        return bytesStorage[_variable];\r\n    }\r\n\r\n}\r\n\r\nlibrary Encoder {\r\n\r\n    function getKey(string _key) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function getKey(string _key1, address _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, string _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, uint256 _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, bytes32 _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, bool _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ninterface IOwnable {\r\n    /**\r\n    * @dev Returns owner\r\n    */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    */\r\n    function renounceOwnership() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n\r\n    // Standard ERC20 interface\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    //transfer, transferFrom must respect the result of verifyTransfer\r\n    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is the amount of tokens that will be minted to the investor\r\n     */\r\n    function mint(address _investor, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is The amount of tokens that will be minted to the investor\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken on behalf of someone else\r\n     * @param _from Address for whom to burn tokens\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnFromWithData(address _from, uint256 _value, bytes _data) external;\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnWithData(uint256 _value, bytes _data) external;\r\n\r\n    event Minted(address indexed _to, uint256 _value);\r\n    event Burnt(address indexed _burner, uint256 _value);\r\n\r\n    // Permissions this to a Permission module, which has a key of 1\r\n    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\r\n    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Module type\r\n     * @return uint256 Module index\r\n     * @return uint256 Name index\r\n\r\n     */\r\n    function getModule(address _module) external view returns(bytes32, address, address, bool, uint8, uint256, uint256);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets length of investors array\r\n     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors\r\n     * @return Length\r\n     */\r\n    function getInvestors() external view returns (address[]);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]);\r\n    \r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Gets an investor at a particular index\r\n    * @param _index Index to return address from\r\n    * @return Investor address\r\n    */\r\n    function investors(uint256 _index) external view returns (address);\r\n\r\n   /**\r\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n    * @param _tokenContract Address of the ERC20Basic compliance token\r\n    * @param _value Amount of POLY to withdraw\r\n    */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to approve more POLY to one of the modules\r\n    * @param _module Module address\r\n    * @param _budget New budget\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _budget) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n    * @notice Removes addresses with zero balances from the investors list\r\n    * @param _start Index in investors list at which to start removing zero balances\r\n    * @param _iters Max number of iterations of the for loop\r\n    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\r\n    */\r\n    function pruneInvestors(uint256 _start, uint256 _iters) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Ends token minting period permanently\r\n     */\r\n    function freezeMinting() external;\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target investors.\r\n     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)\r\n     * @param _investors A list of addresses to whom the minted tokens will be delivered\r\n     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list\r\n     * @return Success\r\n     */\r\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     */\r\n    function addModule(\r\n        address _moduleFactory,\r\n        bytes _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget\r\n    ) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a forced transfer\r\n     * @param _from address from which to take tokens\r\n     * @param _to address where to send tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a foced burn\r\n     * @param _from address from which to take tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n     function disableController() external;\r\n\r\n     /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n     function getVersion() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Gets the investor count\r\n     */\r\n     function getInvestorCount() external view returns(uint256);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);\r\n\r\n     /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n     function granularity() external view returns(uint256);\r\n}\r\n\r\n/**\r\n* @title Registry contract to store registered modules\r\n* @notice Only Polymath can register and verify module factories to make them available for issuers to attach.\r\n*/\r\ncontract ModuleRegistry is IModuleRegistry, EternalStorage {\r\n    /*\r\n        // Mapping used to hold the type of module factory corresponds to the address of the Module factory contract\r\n        mapping (address => uint8) public registry;\r\n\r\n        // Mapping used to hold the reputation of the factory\r\n        mapping (address => address[]) public reputation;\r\n\r\n        // Mapping containing the list of addresses of Module Factories of a particular type\r\n        mapping (uint8 => address[]) public moduleList;\r\n\r\n        // Mapping to store the index of the Module Factory in the moduleList\r\n        mapping(address => uint8) private moduleListIndex;\r\n\r\n        // contains the list of verified modules\r\n        mapping (address => bool) public verified;\r\n\r\n    */\r\n\r\n    ///////////\r\n    // Events\r\n    //////////\r\n\r\n    // Emit when network becomes paused\r\n    event Pause(uint256 _timestammp);\r\n     // Emit when network becomes unpaused\r\n    event Unpause(uint256 _timestamp);\r\n    // Emit when Module is used by the SecurityToken\r\n    event ModuleUsed(address indexed _moduleFactory, address indexed _securityToken);\r\n    // Emit when the Module Factory gets registered on the ModuleRegistry contract\r\n    event ModuleRegistered(address indexed _moduleFactory, address indexed _owner);\r\n    // Emit when the module gets verified by Polymath\r\n    event ModuleVerified(address indexed _moduleFactory, bool _verified);\r\n    // Emit when a ModuleFactory is removed by Polymath\r\n    event ModuleRemoved(address indexed _moduleFactory, address indexed _decisionMaker);\r\n    // Emit when ownership gets transferred\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    ///////////////\r\n    //// Modifiers\r\n    ///////////////\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(),\"sender must be owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPausedOrOwner() {\r\n        if (msg.sender == owner())\r\n            _;\r\n        else {\r\n            require(!isPaused(), \"Already paused\");\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is not paused and ignore is msg.sender is owner.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!isPaused(), \"Already paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(isPaused(), \"Should not be paused\");\r\n        _;\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Initialization\r\n    /////////////////////////////\r\n\r\n    // Constructor\r\n    constructor () public\r\n    {\r\n\r\n    }\r\n\r\n    function initialize(address _polymathRegistry, address _owner) external payable {\r\n        require(!getBool(Encoder.getKey(\"initialised\")),\"already initialized\");\r\n        require(_owner != address(0) && _polymathRegistry != address(0), \"0x address is invalid\");\r\n        set(Encoder.getKey(\"polymathRegistry\"), _polymathRegistry);\r\n        set(Encoder.getKey(\"owner\"), _owner);\r\n        set(Encoder.getKey(\"paused\"), false);\r\n        set(Encoder.getKey(\"initialised\"), true);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a SecurityToken to check if the ModuleFactory is verified or appropriate custom module\r\n     * @dev ModuleFactory reputation increases by one every time it is deployed(used) by a ST.\r\n     * @dev Any module can be added during token creation without being registered if it is defined in the token proxy deployment contract\r\n     * @dev The feature switch for custom modules is labelled \"customModulesAllowed\"\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     */\r\n    function useModule(address _moduleFactory) external {\r\n        // This if statement is required to be able to add modules from the token proxy contract during deployment\r\n        if (ISecurityTokenRegistry(getAddress(Encoder.getKey(\"securityTokenRegistry\"))).isSecurityToken(msg.sender)) {\r\n            if (IFeatureRegistry(getAddress(Encoder.getKey(\"featureRegistry\"))).getFeatureStatus(\"customModulesAllowed\")) {\r\n                require(getBool(Encoder.getKey(\"verified\", _moduleFactory)) || IOwnable(_moduleFactory).owner() == IOwnable(msg.sender).owner(),\"ModuleFactory must be verified or SecurityToken owner must be ModuleFactory owner\");\r\n            } else {\r\n                require(getBool(Encoder.getKey(\"verified\", _moduleFactory)), \"ModuleFactory must be verified\");\r\n            }\r\n            require(_isCompatibleModule(_moduleFactory, msg.sender), \"Version should within the compatible range of ST\");\r\n            pushArray(Encoder.getKey(\"reputation\", _moduleFactory), msg.sender);\r\n            emit ModuleUsed(_moduleFactory, msg.sender);\r\n        }\r\n    }\r\n\r\n    function _isCompatibleModule(address _moduleFactory, address _securityToken) internal view returns(bool) {\r\n        uint8[] memory _latestVersion = ISecurityToken(_securityToken).getVersion();\r\n        uint8[] memory _lowerBound = IModuleFactory(_moduleFactory).getLowerSTVersionBounds();\r\n        uint8[] memory _upperBound = IModuleFactory(_moduleFactory).getUpperSTVersionBounds();\r\n        bool _isLowerAllowed = VersionUtils.compareLowerBound(_lowerBound, _latestVersion);\r\n        bool _isUpperAllowed = VersionUtils.compareUpperBound(_upperBound, _latestVersion);\r\n        return (_isLowerAllowed && _isUpperAllowed);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner to register new modules for SecurityTokens to use\r\n     * @param _moduleFactory is the address of the module factory to be registered\r\n     */\r\n    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {\r\n        if (IFeatureRegistry(getAddress(Encoder.getKey(\"featureRegistry\"))).getFeatureStatus(\"customModulesAllowed\")) {\r\n            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(),\"msg.sender must be the Module Factory owner or registry curator\");\r\n        } else {\r\n            require(msg.sender == owner(), \"Only owner allowed to register modules\");\r\n        }\r\n        require(getUint(Encoder.getKey(\"registry\", _moduleFactory)) == 0, \"Module factory should not be pre-registered\");\r\n        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\r\n        //Enforce type uniqueness\r\n        uint256 i;\r\n        uint256 j;\r\n        uint8[] memory moduleTypes = moduleFactory.getTypes();\r\n        for (i = 1; i < moduleTypes.length; i++) {\r\n            for (j = 0; j < i; j++) {\r\n                require(moduleTypes[i] != moduleTypes[j], \"Type mismatch\");\r\n            }\r\n        }\r\n        require(moduleTypes.length != 0, \"Factory must have type\");\r\n        // NB - here we index by the first type of the module.\r\n        uint8 moduleType = moduleFactory.getTypes()[0];\r\n        set(Encoder.getKey(\"registry\", _moduleFactory), uint256(moduleType));\r\n        set(\r\n            Encoder.getKey(\"moduleListIndex\", _moduleFactory),\r\n            uint256(getArrayAddress(Encoder.getKey(\"moduleList\", uint256(moduleType))).length)\r\n        );\r\n        pushArray(Encoder.getKey(\"moduleList\", uint256(moduleType)), _moduleFactory);\r\n        emit ModuleRegistered (_moduleFactory, IOwnable(_moduleFactory).owner());\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner or registry curator to delete a ModuleFactory from the registry\r\n     * @param _moduleFactory is the address of the module factory to be deleted from the registry\r\n     */\r\n    function removeModule(address _moduleFactory) external whenNotPausedOrOwner {\r\n        uint256 moduleType = getUint(Encoder.getKey(\"registry\", _moduleFactory));\r\n\r\n        require(moduleType != 0, \"Module factory should be registered\");\r\n        require(\r\n            msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(),\r\n            \"msg.sender must be the Module Factory owner or registry curator\"\r\n        );\r\n        uint256 index = getUint(Encoder.getKey(\"moduleListIndex\", _moduleFactory));\r\n        uint256 last = getArrayAddress(Encoder.getKey(\"moduleList\", moduleType)).length - 1;\r\n        address temp = getArrayAddress(Encoder.getKey(\"moduleList\", moduleType))[last];\r\n\r\n        // pop from array and re-order\r\n        if (index != last) {\r\n            // moduleList[moduleType][index] = temp;\r\n            setArrayIndexValue(Encoder.getKey(\"moduleList\", moduleType), index, temp);\r\n            set(Encoder.getKey(\"moduleListIndex\", temp), index);\r\n        }\r\n        deleteArrayAddress(Encoder.getKey(\"moduleList\", moduleType), last);\r\n\r\n        // delete registry[_moduleFactory];\r\n        set(Encoder.getKey(\"registry\", _moduleFactory), uint256(0));\r\n        // delete reputation[_moduleFactory];\r\n        setArray(Encoder.getKey(\"reputation\", _moduleFactory), new address[](0));\r\n        // delete verified[_moduleFactory];\r\n        set(Encoder.getKey(\"verified\", _moduleFactory), false);\r\n        // delete moduleListIndex[_moduleFactory];\r\n        set(Encoder.getKey(\"moduleListIndex\", _moduleFactory), uint256(0));\r\n        emit ModuleRemoved(_moduleFactory, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by Polymath to verify Module Factories for SecurityTokens to use.\r\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\r\n    * @notice (The only exception to this is that the author of the module is the owner of the ST)\r\n    * @notice -> Only if Polymath enabled the feature.\r\n    * @param _moduleFactory is the address of the module factory to be verified\r\n    * @return bool\r\n    */\r\n    function verifyModule(address _moduleFactory, bool _verified) external onlyOwner {\r\n        require(getUint(Encoder.getKey(\"registry\", _moduleFactory)) != uint256(0), \"Module factory must be registered\");\r\n        set(Encoder.getKey(\"verified\", _moduleFactory), _verified);\r\n        emit ModuleVerified(_moduleFactory, _verified);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @param _securityToken is the token\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns(bytes32[], address[]) {\r\n        address[] memory modules = getModulesByTypeAndToken(_moduleType, _securityToken);\r\n        return _tagsByModules(modules);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByType(uint8 _moduleType) external view returns(bytes32[], address[]) {\r\n        address[] memory modules = getModulesByType(_moduleType);\r\n        return _tagsByModules(modules);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the modules provided\r\n     * @param _modules modules to return tags for\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function _tagsByModules(address[] _modules) internal view returns(bytes32[], address[]) {\r\n        uint256 counter = 0;\r\n        uint256 i;\r\n        uint256 j;\r\n        for (i = 0; i < _modules.length; i++) {\r\n            counter = counter + IModuleFactory(_modules[i]).getTags().length;\r\n        }\r\n        bytes32[] memory tags = new bytes32[](counter);\r\n        address[] memory modules = new address[](counter);\r\n        bytes32[] memory tempTags;\r\n        counter = 0;\r\n        for (i = 0; i < _modules.length; i++) {\r\n            tempTags = IModuleFactory(_modules[i]).getTags();\r\n            for (j = 0; j < tempTags.length; j++) {\r\n                tags[counter] = tempTags[j];\r\n                modules[counter] = _modules[i];\r\n                counter++;\r\n            }\r\n        }\r\n        return (tags, modules);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the reputation of the entered Module Factory\r\n     * @param _factoryAddress is the address of the module factory\r\n     * @return address array which contains the list of securityTokens that use that module factory\r\n     */\r\n    function getReputationByFactory(address _factoryAddress) external view returns(address[]) {\r\n        return getArrayAddress(Encoder.getKey(\"reputation\", _factoryAddress));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the list of addresses of Module Factory of a particular type\r\n     * @param _moduleType Type of Module\r\n     * @return address array that contains the list of addresses of module factory contracts.\r\n     */\r\n    function getModulesByType(uint8 _moduleType) public view returns(address[]) {\r\n        return getArrayAddress(Encoder.getKey(\"moduleList\", uint256(_moduleType)));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the list of available Module factory addresses of a particular type for a given token.\r\n     * @param _moduleType is the module type to look for\r\n     * @param _securityToken is the address of SecurityToken\r\n     * @return address array that contains the list of available addresses of module factory contracts.\r\n     */\r\n    function getModulesByTypeAndToken(uint8 _moduleType, address _securityToken) public view returns (address[]) {\r\n        uint256 _len = getArrayAddress(Encoder.getKey(\"moduleList\", uint256(_moduleType))).length;\r\n        address[] memory _addressList = getArrayAddress(Encoder.getKey(\"moduleList\", uint256(_moduleType)));\r\n        bool _isCustomModuleAllowed = IFeatureRegistry(getAddress(Encoder.getKey(\"featureRegistry\"))).getFeatureStatus(\"customModulesAllowed\");\r\n        uint256 counter = 0;\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            if (_isCustomModuleAllowed) {\r\n                if (IOwnable(_addressList[i]).owner() == IOwnable(_securityToken).owner() || getBool(Encoder.getKey(\"verified\", _addressList[i])))\r\n                    if(_isCompatibleModule(_addressList[i], _securityToken))\r\n                        counter++;\r\n            }\r\n            else if (getBool(Encoder.getKey(\"verified\", _addressList[i]))) {\r\n                if(_isCompatibleModule(_addressList[i], _securityToken))\r\n                    counter++;\r\n            }\r\n        }\r\n        address[] memory _tempArray = new address[](counter);\r\n        counter = 0;\r\n        for (uint256 j = 0; j < _len; j++) {\r\n            if (_isCustomModuleAllowed) {\r\n                if (IOwnable(_addressList[j]).owner() == IOwnable(_securityToken).owner() || getBool(Encoder.getKey(\"verified\", _addressList[j]))) {\r\n                    if(_isCompatibleModule(_addressList[j], _securityToken)) {\r\n                        _tempArray[counter] = _addressList[j];\r\n                        counter ++;\r\n                    }\r\n                }\r\n            }\r\n            else if (getBool(Encoder.getKey(\"verified\", _addressList[j]))) {\r\n                if(_isCompatibleModule(_addressList[j], _securityToken)) {\r\n                    _tempArray[counter] = _addressList[j];\r\n                    counter ++;\r\n                }\r\n            }\r\n        }\r\n        return _tempArray;\r\n    }\r\n\r\n    /**\r\n    * @notice Reclaims all ERC20Basic compatible tokens\r\n    * @param _tokenContract The address of the token contract\r\n    */\r\n    function reclaimERC20(address _tokenContract) external onlyOwner {\r\n        require(_tokenContract != address(0), \"0x address is invalid\");\r\n        IERC20 token = IERC20(_tokenContract);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(owner(), balance),\"token transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() external whenNotPaused onlyOwner {\r\n        set(Encoder.getKey(\"paused\"), true);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Pause(now);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external whenPaused onlyOwner {\r\n        set(Encoder.getKey(\"paused\"), false);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Unpause(now);\r\n    }\r\n\r\n    /**\r\n     * @notice Stores the contract addresses of other key contracts from the PolymathRegistry\r\n     */\r\n    function updateFromRegistry() external onlyOwner {\r\n        address _polymathRegistry = getAddress(Encoder.getKey(\"polymathRegistry\"));\r\n        set(Encoder.getKey(\"securityTokenRegistry\"), IPolymathRegistry(_polymathRegistry).getAddress(\"SecurityTokenRegistry\"));\r\n        set(Encoder.getKey(\"featureRegistry\"), IPolymathRegistry(_polymathRegistry).getAddress(\"FeatureRegistry\"));\r\n        set(Encoder.getKey(\"polyToken\"), IPolymathRegistry(_polymathRegistry).getAddress(\"PolyToken\"));\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner(), _newOwner);\r\n        set(Encoder.getKey(\"owner\"), _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() public view returns(address) {\r\n        return getAddress(Encoder.getKey(\"owner\"));\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether the contract operations is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() public view returns(bool) {\r\n        return getBool(Encoder.getKey(\"paused\"));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_factoryAddress\",\"type\":\"address\"}],\"name\":\"getReputationByFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_moduleType\",\"type\":\"uint8\"},{\"name\":\"_securityToken\",\"type\":\"address\"}],\"name\":\"getTagsByTypeAndToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBoolValues\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getUintValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_polymathRegistry\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_moduleType\",\"type\":\"uint8\"}],\"name\":\"getTagsByType\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getStringValues\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moduleFactory\",\"type\":\"address\"}],\"name\":\"removeModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_moduleType\",\"type\":\"uint8\"}],\"name\":\"getModulesByType\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moduleFactory\",\"type\":\"address\"}],\"name\":\"registerModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytes32Values\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getAddressValues\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytesValues\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moduleFactory\",\"type\":\"address\"}],\"name\":\"useModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_moduleType\",\"type\":\"uint8\"},{\"name\":\"_securityToken\",\"type\":\"address\"}],\"name\":\"getModulesByTypeAndToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"name\":\"_verified\",\"type\":\"bool\"}],\"name\":\"verifyModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateFromRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestammp\",\"type\":\"uint256\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_securityToken\",\"type\":\"address\"}],\"name\":\"ModuleUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ModuleRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_verified\",\"type\":\"bool\"}],\"name\":\"ModuleVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_decisionMaker\",\"type\":\"address\"}],\"name\":\"ModuleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ModuleRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a435a0abda3971bf4d8b37dbb8b279550969bb22a56bfa9ce469682198615f4c"}]}