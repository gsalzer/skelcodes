{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/*  \r\n     ==================================================================\r\n    ||  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  ||\r\n    ||  + Digital Multi Level Marketing in Ethereum smart-contract +  ||\r\n    ||  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  ||\r\n     ==================================================================\r\n     \r\n    https://ethmlm.com\r\n    https://t.me/ethmlm\r\n    \r\n    \r\n         ``..................``  ``....................``  ``..``             ``.``          \r\n        `..,,,,,,,,,,,,,,,,,,.` ``.,,,,,,,,,,,,,,,,,,,,.`  `.,,.`            `..,.``         \r\n        `.:::::,,,,,,,,,,,,,,.```.,,,,,,,:::::::,,,,,,,.`  `,::,.            `.,:,.`         \r\n        `,:;:,,...............`  `.......,,:;::,,.......`  .,::,.`           `.:;,.`         \r\n        `,:;:,.```````````````   ````````.,:::,.````````   .,::,.`           `.:;,.`         \r\n     ++++++++++++++++++++    ++++++++++++++++++++++,   ,+++.,::,.`        ++++.:;,.`         \r\n     ####################    ######################:   ,###.,::,.`        ####.:;,.`         \r\n     ###';'';;:::::::::::````:::::::::+###;;'';::::.   ,###.,::,.`````````####,:;,.`         \r\n     ###;,:;:,,.............``        +###.,::,`       ,###.,:;:,,........####::;,.`         \r\n     ###;,:;:::,,,,,,,,,,,,,.`        +###.,::,`       ,###.,:;::,,,,,,,,,####::;,.`         \r\n     ###;,:;::,,,,,,,,,,,,,,.`        +###.,::,`       ,###.,:;::,,,,,,,,,####::;,.`         \r\n     ###;,:;:,..............``        +###.,::,`       ,###.,:::,.````````####,:;,.`         \r\n     ###;,:;:.``````````````          +###.,::,`       ,###.,::,.`        ####,:;,.`         \r\n     ###################              +###.,::,`       ,######################.:;,.`         \r\n     ###################              +###.,::,`       ,######################.:;,.`         \r\n     ###;,:;:.````````````````        +###.,::,`       ,###.,::,.`        ####.:;,.`         \r\n     ###;,:;:,................``      +###.,::,`       ,###.,::,.`        ####.:;,.`         \r\n     ###;,:;:::,,,,,,,,,,,,,,,.`      +###.,::,`       ,###.,::,.`        ####.:;,.`         \r\n     ###:.,,,,,,,,,,,,,,,,,,,,.`      +###`.,,.`       ,###`.,,.`         ####.,,,.`         \r\n     ###:`....................``      +###``..``       ,###``..``         ####`...`          \r\n     ###: `````````````````````       +### ````        ,### ````          #### ```           \r\n     #####################            +###             ,###               ####               \r\n     #####################            +###             ,###               ####               \r\n     ,,,,,,,,,,,,,,,,,,,,,     `````` .,,,`````        `,,,     ```````   ,,,,        `````` \r\n        `..,,,.``             `..,,.``   ``.,.`                `..,,,.``             `..,,.``\r\n        `.::::,.`            `.,:::,.`   `.,:,.`               `.,:::,.`            `.,:::,.`\r\n        .,:;;;:,.`           .,:;;;:.`   `,:;,.`               .,:;;;:,.`           .,:;;;:,`\r\n        .,:;::::,`          `.,:;;;:.`   `,:;,.`               .,:;::::,`          `.,:::;:,`\r\n        .,::::::,.`        `.,::::;:.`   `,:;,.`               .,:;::::,.`        `.,::::;:,`\r\n    .#####+::,,::,`       ######::;:.,###`,:;,.`            ######::::::,`       +#####::;:,`\r\n    .######:,,,::,.`      ######,:;:.,###`,:;,.`            ######:,,,::,.`      ######,,;:,`\r\n    .######+,..,::,`     #######,:;:.,###`,:;,.`            ###'###,..,::,`     #######.,;:,`\r\n    .###.###,.`.,:,.`   .##+####.:;:.,###`,:;,.`            ###.###,.`.,:,.`    #######.,;:,`\r\n    .###.+###.``,::,`   ###:####.:;:.,###`,:;,.`            ###.'###.`.,::,`   ###:####.,;:,`\r\n    .###.,###. `.,:,.` :##':####.:;:.,###`,:;,.`            ###.,###,``.,:,.` `##+:####.,;:,`\r\n    .###.,+###  `,::,.`###:,####.:;:.,###`,:;,.`            ###.,'###` `,::,. ###:,####.,;:,`\r\n    .###.,:###` `.,::.'##;:,####.:;:.,###`,:;,.`            ###.,:###, `.,::.,##':,####.,;:,`\r\n    .###.,:'###  `,::,###:,.####.:;:.,###`,:;,.`            ###.,:;###  `,::,###:,.####.,;:,`\r\n    .###.,::###` `.,:+##::,`####.:;:.,###`,:;,.`            ###.,::###: `.,:'##;:,`####.,;:,`\r\n    .###.,::;###  `,:###:,.`####.:;:.,###`,:;:,............`###.,::,###  `,:###:,.`####.,;:,`\r\n    .###.,::,###. `.###::,` ####.:;:.,###`,:;::,,,,,,,,,,,,.###.,::,###; `.+##;:,` ####.,;:,`\r\n    .###`.::.,###  `##+:,.` ####.,:,.,###`.,:::,,,,,,,,,,,,.###`.,:,.###  `###:,.` ####.,:,.`\r\n    .###`....`###, ###,..`  ####`.,.`,###``.,,,,,,,,,,,,,,..###`....`###' +##,..`  ####`.,.``\r\n    .### ```` `###`##'```   ####`````,### ``````````````````### ````  ### ##+```   ####````` \r\n    .###       ######       ####     .###                   ###       +#####       ####      \r\n    .###        ####,       ####     .#################     ###        ####'       ####      \r\n    .###        ####        ####     .#################     ###        '###        ####     \r\n    \r\n\r\n*/\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param account address of the account to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter;\r\n\r\n  constructor() internal {\r\n    // The counter starts at one to prevent changing it from zero to a non-zero\r\n    // value, which is a more expensive operation.\r\n    _guardCounter = 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract MLM_FOMO_BANK is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    //  time to win FOMO bank\r\n    uint public fomo_period = 3600;     // 1 hour\r\n    \r\n    //  FOMO bank balance\r\n    uint public balance;\r\n    //  next winner address\r\n    address public winner;\r\n    //  win time\r\n    uint public finish_time;\r\n    \r\n    //  MLM contract\r\n    address _mlm;\r\n    \r\n    //  only MLM contract can call method\r\n    modifier onlyMLM() {\r\n        require(msg.sender == _mlm);\r\n        _;\r\n    }\r\n\r\n    \r\n    event Win(address indexed user, uint amount);\r\n    \r\n    \r\n    function SetMLM(address mlm) public onlyOwner {\r\n        _mlm = mlm;\r\n    }\r\n    \r\n    //  fill the bank\r\n    function AddToBank(address user) public payable onlyMLM {\r\n        //  check for winner\r\n        CheckWinner();\r\n        \r\n        // save last payment info\r\n        balance = balance.add(msg.value);\r\n        winner = user;\r\n        finish_time = now + fomo_period;\r\n    }\r\n    \r\n    // check winner\r\n    function CheckWinner() internal {\r\n        if(now > finish_time && winner != address(0)){\r\n            emit Win(winner, balance);\r\n            \r\n            //  it should not be reentrancy, but just in case\r\n            uint prev_balance = balance;\r\n            balance = 0;\r\n            //  send ethers to winner\r\n            winner.transfer(prev_balance);\r\n            winner = address(0);\r\n        }\r\n    }\r\n    \r\n    //  get cuurent FOMO info {balance, finish_time, winner }\r\n    function GetInfo() public view returns (uint, uint, address) {\r\n        return (\r\n            balance,\r\n            finish_time,\r\n            winner\r\n        );\r\n    }\r\n}\r\n\r\ncontract MLM is Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    // FOMO bank contract\r\n    MLM_FOMO_BANK _fomo;\r\n    \r\n    struct userStruct {\r\n        address[] referrers;    //  array with 3 level referrers\r\n        address[] referrals;    //  array with referrals\r\n        uint next_payment;      //  time to next payments, seconds\r\n        bool isRegitered;       //  is user registered\r\n        bytes32 ref_link;       //  referral link\r\n    }\r\n    \r\n    // mapping with users\r\n    mapping(address=>userStruct) users;\r\n    //  mapping with referral links\r\n    mapping(bytes32=>address) ref_to_users;\r\n    \r\n    uint public min_paymnet = 100 finney;               //  minimum payment amount 0,1ETH\r\n    uint public min_time_to_add = 604800;               //  Time need to add after miimum payment, seconds | 1 week\r\n    uint[] public reward_parts = [35, 25, 15, 15, 10];  //  how much need to send to referrers, %\r\n\r\n    event RegisterEvent(address indexed user, address indexed referrer);\r\n    event PayEvent(address indexed payer, uint amount, bool[3] levels);\r\n    \r\n    \r\n    constructor(MLM_FOMO_BANK fomo) public {\r\n        //  set FOMO contract\r\n        _fomo = fomo;\r\n    }\r\n    \r\n\r\n\r\n    function() public payable {\r\n        //  sender should not be a contract\r\n        require(!address(msg.sender).isContract());\r\n        //  user should be registered\r\n        require(users[msg.sender].isRegitered);\r\n        //  referrer address is 0x00 because user is already registered and referrer is stored on the first payment\r\n        Pay(0x00);\r\n    }\r\n    \r\n    \r\n    /*\r\n    Make a payment\r\n    --------------\r\n    [bytes32 referrer_addr] - referrer's address. it is used only on first payment to save sender as a referral\r\n    */\r\n    function Pay(bytes32 referrer_addr) public payable nonReentrant {\r\n        //  sender should not be a contract\r\n        require(!address(msg.sender).isContract());\r\n        //  check minimum amount\r\n        require(msg.value >= min_paymnet);\r\n        \r\n        //  if it is a first payment need to register sender\r\n        if(!users[msg.sender].isRegitered){\r\n            _register(referrer_addr);\r\n        }\r\n        \r\n        uint amount = msg.value;\r\n        //  what referrer levels will received a payments, need on UI\r\n        bool[3] memory levels = [false,false,false];\r\n        //  iterate of sender's referrers\r\n        for(uint i = 0; i < users[msg.sender].referrers.length; i++){\r\n            //  referrer address at level i\r\n            address ref = users[msg.sender].referrers[i];\r\n            //  if referrer is active need to pay him\r\n            if(users[ref].next_payment > now){\r\n                //  calculate reward part, i.e. 0.1 * 35 / 100  = 0.035\r\n                uint reward = amount.mul(reward_parts[i]).div(100);\r\n                //  send reward to referrer\r\n                ref.transfer(reward);\r\n                //  set referrer's level ad payment\r\n                levels[i] = true;\r\n            }\r\n        }\r\n        \r\n        //  what address will be saved to FOMO bank, referrer or current sender\r\n        address fomo_user = msg.sender;\r\n        if(users[msg.sender].referrers.length>0 && users[users[msg.sender].referrers[0]].next_payment > now)\r\n            fomo_user = users[msg.sender].referrers[0];\r\n            \r\n        //  send 15% to FOMO bank and store selceted user\r\n        _fomo.AddToBank.value(amount.mul(reward_parts[3]).div(100)).gas(gasleft())(fomo_user);\r\n        \r\n        // prolong referral link life\r\n        if(now > users[msg.sender].next_payment)\r\n            users[msg.sender].next_payment = now.add(amount.mul(min_time_to_add).div(min_paymnet));\r\n        else \r\n            users[msg.sender].next_payment = users[msg.sender].next_payment.add(amount.mul(min_time_to_add).div(min_paymnet));\r\n        \r\n        emit PayEvent(msg.sender, amount, levels);\r\n    }\r\n    \r\n    \r\n    \r\n    function _register(bytes32 referrer_addr) internal {\r\n        // sender should not be registered\r\n        require(!users[msg.sender].isRegitered);\r\n        \r\n        // get referrer address\r\n        address referrer = ref_to_users[referrer_addr];\r\n        // users could not be a referrer\r\n        require(referrer!=msg.sender);\r\n        \r\n        //  if there is referrer\r\n        if(referrer != address(0)){\r\n            //  set refferers for currnet user\r\n            _setReferrers(referrer, 0);\r\n        }\r\n        //  mark user as registered\r\n        users[msg.sender].isRegitered = true;\r\n        //  calculate referral link\r\n        _getReferralLink(referrer);\r\n        \r\n\r\n        emit RegisterEvent(msg.sender, referrer);\r\n    }\r\n    \r\n    //  generate a referral link\r\n    function _getReferralLink(address referrer) internal {\r\n        do{\r\n            users[msg.sender].ref_link = keccak256(abi.encodePacked(uint(msg.sender) ^  uint(referrer) ^ now));\r\n        } while(ref_to_users[users[msg.sender].ref_link] != address(0));\r\n        ref_to_users[users[msg.sender].ref_link] = msg.sender;\r\n    }\r\n    \r\n    // set referrers\r\n    function _setReferrers(address referrer, uint level) internal {\r\n        //  set referrer only for active user other case use his referrer\r\n        if(users[referrer].next_payment > now){\r\n            users[msg.sender].referrers.push(referrer);\r\n            if(level == 0){\r\n                //  add current user to referrer's referrals list\r\n                users[referrer].referrals.push(msg.sender);\r\n            }\r\n            level++;\r\n        }\r\n        //  set referrers for 3 levels\r\n        if(level<3 && users[referrer].referrers.length>0)\r\n            _setReferrers(users[referrer].referrers[0], level);\r\n    }\r\n    \r\n    /*  Get user info\r\n    \r\n        uint next_payment\r\n        bool isRegitered\r\n        bytes32 ref_link\r\n    */\r\n    function GetUser() public view returns(uint, bool, bytes32) {\r\n        return (\r\n            users[msg.sender].next_payment,\r\n            users[msg.sender].isRegitered,\r\n            users[msg.sender].ref_link\r\n        );\r\n    }\r\n    \r\n    // Get sender's referrers\r\n    function GetReferrers() public view returns(address[] memory) {\r\n        return users[msg.sender].referrers;\r\n    }\r\n    \r\n    //  Get sender's referrals\r\n    function GetReferrals() public view returns(address[] memory) {\r\n        return users[msg.sender].referrals;\r\n    }\r\n    \r\n    //  Project's owner can widthdraw contract's balance\r\n    function widthdraw(address to, uint amount) public onlyOwner {\r\n        to.transfer(amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"GetReferrers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer_addr\",\"type\":\"bytes32\"}],\"name\":\"Pay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reward_parts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_paymnet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetReferrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_time_to_add\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"widthdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"fomo\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegisterEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"levels\",\"type\":\"bool[3]\"}],\"name\":\"PayEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MLM","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e20a3aa6b1ef8eb0eab44bfa9503f09635a5ac50","Library":"","SwarmSource":"bzzr://981b13dd984091444d4fa8c1c5560fcda23c278f087e119b26d9cf26a4bbc8da"}]}