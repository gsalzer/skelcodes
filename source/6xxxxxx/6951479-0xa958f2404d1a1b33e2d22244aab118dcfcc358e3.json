{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Proxy {\r\n    using SafeMath for uint256;\r\n    uint256 public contribution = 0;\r\n    Lottery lottery;\r\n    \r\n    constructor() public {\r\n        lottery = Lottery(msg.sender);\r\n    }\r\n    function() public payable {\r\n        contribution = contribution.add(msg.value);\r\n        address(lottery).transfer(msg.value);\r\n    }\r\n    function resetContribution() external {\r\n        require(msg.sender == lottery.owner());\r\n        contribution = 0;\r\n    }\r\n}\r\n\r\ncontract Lottery {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public ONE_HUNDRED_PERCENTS = 10000;               // 100%\r\n    uint256[] public DAILY_INTEREST = [111, 133, 222, 333, 444];        // 1.11%, 2.22%, 3.33%, 4.44%\r\n    uint256 public MARKETING_AND_TEAM_FEE = 1000;                       // 10%\r\n    uint256 public referralPercents = 1000;                             // 10%\r\n    uint256 constant public MAX_DIVIDEND_RATE = 25000;                  // 250%\r\n    uint256 constant public MINIMUM_DEPOSIT = 100 finney;               // 0.1 eth\r\n    uint256 public wave = 0;\r\n    uint256 public totalInvest = 0;\r\n    uint256 public totalDividend = 0;\r\n    mapping(address => bool) public isProxy;\r\n\r\n    struct Deposit {\r\n        uint256 amount;\r\n        uint256 interest;\r\n        uint256 withdrawedRate;\r\n    }\r\n\r\n    struct User {\r\n        address referrer;\r\n        uint256 referralAmount;\r\n        uint256 firstTime;\r\n        uint256 lastPayment;\r\n        Deposit[] deposits;\r\n        uint256 referBonus;\r\n    }\r\n\r\n    address public marketingAndTechnicalSupport = 0xFaea7fa229C29526698657e7Ab7063E20581A50c; // need to change\r\n    address public owner = 0x4e3e605b9f7b333e413E1CD9E577f2eba447f876;\r\n    mapping(uint256 => mapping(address => User)) public users;\r\n\r\n    event InvestorAdded(address indexed investor);\r\n    event ReferrerAdded(address indexed investor, address indexed referrer);\r\n    event DepositAdded(address indexed investor, uint256 indexed depositsCount, uint256 amount);\r\n    event UserDividendPayed(address indexed investor, uint256 dividend);\r\n    event DepositDividendPayed(address indexed investor, uint256 indexed index, uint256 deposit, uint256 totalPayed, uint256 dividend);\r\n    event FeePayed(address indexed investor, uint256 amount);\r\n    event BalanceChanged(uint256 balance);\r\n    event NewWave();\r\n    \r\n    function() public payable {\r\n        require(isProxy[msg.sender]);\r\n        \r\n        if(msg.value == 0) {\r\n            // Dividends\r\n            withdrawDividends();\r\n            return;\r\n        }\r\n\r\n        // Deposit\r\n        doInvest();\r\n    }\r\n        \r\n    function withdrawDividends() internal {\r\n        uint256 dividendsSum = getDividends(tx.origin);\r\n        require(dividendsSum > 0);\r\n        \r\n        if (address(this).balance <= dividendsSum) {\r\n            wave = wave.add(1);\r\n            totalInvest = 0;\r\n            dividendsSum = address(this).balance;\r\n            emit NewWave();\r\n        }\r\n        tx.origin.transfer(dividendsSum);\r\n        emit UserDividendPayed(tx.origin, dividendsSum);\r\n        emit BalanceChanged(address(this).balance);\r\n    }\r\n    \r\n    function getDividends(address wallet) internal returns(uint256 sum) {\r\n        User storage user = users[wave][wallet];\r\n        for (uint i = 0; i < user.deposits.length; i++) {\r\n            uint256 withdrawRate = dividendRate(tx.origin, i);\r\n            user.deposits[i].withdrawedRate = user.deposits[i].withdrawedRate.add(withdrawRate);\r\n            sum = sum.add(user.deposits[i].amount.mul(withdrawRate).div(ONE_HUNDRED_PERCENTS));\r\n            emit DepositDividendPayed(\r\n                tx.origin,\r\n                i,\r\n                user.deposits[i].amount,\r\n                user.deposits[i].amount.mul(user.deposits[i].withdrawedRate.div(ONE_HUNDRED_PERCENTS)),\r\n                user.deposits[i].amount.mul(withdrawRate.div(ONE_HUNDRED_PERCENTS))\r\n            );\r\n        }\r\n        user.lastPayment = now;\r\n        sum = sum.add(user.referBonus);\r\n        user.referBonus = 0;\r\n        totalDividend = totalDividend.add(sum);\r\n    }\r\n\r\n    function dividendRate(address wallet, uint256 index) internal view returns(uint256 rate) {\r\n        User memory user = users[wave][wallet];\r\n        uint256 duration = now.sub(user.lastPayment);\r\n        rate = user.deposits[index].interest.mul(duration).div(1 days);\r\n        uint256 leftRate = MAX_DIVIDEND_RATE.sub(user.deposits[index].withdrawedRate);\r\n        rate = min(rate, leftRate);\r\n    }\r\n\r\n    function doInvest() internal {\r\n        uint256 investment = msg.value;\r\n        require (investment >= MINIMUM_DEPOSIT);\r\n        \r\n        User storage user = users[wave][tx.origin];\r\n        if (user.firstTime == 0) {\r\n            user.firstTime = now;\r\n            user.lastPayment = now;\r\n            emit InvestorAdded(tx.origin);\r\n        }\r\n\r\n        // Add referral if possible\r\n        if (user.referrer == address(0) && msg.data.length == 20 && user.firstTime == now) {\r\n            address newReferrer = _bytesToAddress(msg.data);\r\n            if (newReferrer != address(0) && newReferrer != tx.origin && users[wave][newReferrer].firstTime > 0) {\r\n                user.referrer = newReferrer;\r\n                emit ReferrerAdded(tx.origin, newReferrer);\r\n            }\r\n        }\r\n        \r\n        // Referrers fees\r\n        if (user.referrer != address(0)) {\r\n            uint256 refAmount = investment.mul(referralPercents).div(ONE_HUNDRED_PERCENTS);\r\n            users[wave][user.referrer].referralAmount = users[wave][user.referrer].referralAmount.add(investment);\r\n            user.referrer.transfer(refAmount);\r\n        }\r\n        \r\n        // Reinvest\r\n        investment = investment.add(getDividends(tx.origin));\r\n        \r\n        totalInvest = totalInvest.add(investment);\r\n        \r\n        // Create deposit\r\n        user.deposits.push(Deposit({\r\n            amount: investment,\r\n            interest: getUserInterest(tx.origin),\r\n            withdrawedRate: 0\r\n        }));\r\n        emit DepositAdded(tx.origin, user.deposits.length, investment);\r\n\r\n        // Marketing and Team fee\r\n        uint256 marketingAndTeamFee = msg.value.mul(MARKETING_AND_TEAM_FEE).div(ONE_HUNDRED_PERCENTS);\r\n        marketingAndTechnicalSupport.transfer(marketingAndTeamFee);\r\n        emit FeePayed(tx.origin, marketingAndTeamFee);\r\n    \r\n        emit BalanceChanged(address(this).balance);\r\n    }\r\n    \r\n    function getUserInterest(address wallet) public view returns (uint256) {\r\n        User memory user = users[wave][wallet];\r\n        if (user.referralAmount < 1 ether) {\r\n            if(user.referrer == address(0)) return DAILY_INTEREST[0];\r\n            return DAILY_INTEREST[1];\r\n        } else if (user.referralAmount < 10 ether) {\r\n            return DAILY_INTEREST[2];\r\n        } else if (user.referralAmount < 20 ether) {\r\n            return DAILY_INTEREST[3];\r\n        } else {\r\n            return DAILY_INTEREST[4];\r\n        }\r\n    }\r\n\r\n    function _bytesToAddress(bytes data) private pure returns(address addr) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            addr := mload(add(data, 20)) \r\n        }\r\n    }\r\n    \r\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if(a < b) return a;\r\n        return b;\r\n    }\r\n    \r\n    function depositForUser(address wallet) external view returns(uint256 sum) {\r\n        User memory user = users[wave][wallet];\r\n        for (uint i = 0; i < user.deposits.length; i++) {\r\n            sum = sum.add(user.deposits[i].amount);\r\n        }\r\n    }\r\n    \r\n    function dividendsSumForUser(address wallet) external view returns(uint256 dividendsSum) {\r\n        User memory user = users[wave][wallet];\r\n        for (uint i = 0; i < user.deposits.length; i++) {\r\n            uint256 withdrawAmount = user.deposits[i].amount.mul(dividendRate(wallet, i)).div(ONE_HUNDRED_PERCENTS);\r\n            dividendsSum = dividendsSum.add(withdrawAmount);\r\n        }\r\n        dividendsSum = dividendsSum.add(user.referBonus);\r\n        dividendsSum = min(dividendsSum, address(this).balance);\r\n    }\r\n    \r\n    function changeInterest(uint256[] interestList) external {\r\n        require(address(msg.sender) == owner);\r\n        DAILY_INTEREST = interestList;\r\n    }\r\n    \r\n    function changeTeamFee(uint256 feeRate) external {\r\n        require(address(msg.sender) == owner);\r\n        MARKETING_AND_TEAM_FEE = feeRate;\r\n    }\r\n    \r\n    function virtualInvest(address from, uint256 amount) public {\r\n        require(address(msg.sender) == owner);\r\n        \r\n        User storage user = users[wave][from];\r\n        if (user.firstTime == 0) {\r\n            user.firstTime = now;\r\n            user.lastPayment = now;\r\n            emit InvestorAdded(from);\r\n        }\r\n        \r\n        // Reinvest\r\n        amount = amount.add(getDividends(from));\r\n        \r\n        user.deposits.push(Deposit({\r\n            amount: amount,\r\n            interest: getUserInterest(from),\r\n            withdrawedRate: 0\r\n        }));\r\n        emit DepositAdded(from, user.deposits.length, amount);\r\n    }\r\n    \r\n    function createProxy() external {\r\n        require(msg.sender == owner);\r\n        Proxy newProxy = new Proxy();\r\n        isProxy[address(newProxy)] = true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"feeRate\",\"type\":\"uint256\"}],\"name\":\"changeTeamFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DAILY_INTEREST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"depositForUser\",\"outputs\":[{\"name\":\"sum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wave\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"virtualInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_HUNDRED_PERCENTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MARKETING_AND_TEAM_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingAndTechnicalSupport\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"referralAmount\",\"type\":\"uint256\"},{\"name\":\"firstTime\",\"type\":\"uint256\"},{\"name\":\"lastPayment\",\"type\":\"uint256\"},{\"name\":\"referBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getUserInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_DIVIDEND_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralPercents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"interestList\",\"type\":\"uint256[]\"}],\"name\":\"changeInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"dividendsSumForUser\",\"outputs\":[{\"name\":\"dividendsSum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_DEPOSIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"InvestorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"ReferrerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"depositsCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dividend\",\"type\":\"uint256\"}],\"name\":\"UserDividendPayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPayed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividend\",\"type\":\"uint256\"}],\"name\":\"DepositDividendPayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewWave\",\"type\":\"event\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e2dda3366182a7a0a97ec4c8f38a3a1120fe1a5b169f880b571623e07ae2aa8a"}]}