{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface IDRCWalletMgrParams {\r\n    function singleWithdrawMin() external returns (uint256); // min value of single withdraw\r\n    function singleWithdrawMax() external returns (uint256); // Max value of single withdraw\r\n    function dayWithdraw() external returns (uint256); // Max value of one day of withdraw\r\n    function monthWithdraw() external returns (uint256); // Max value of one month of withdraw\r\n    function dayWithdrawCount() external returns (uint256); // Max number of withdraw counting\r\n\r\n    function chargeFee() external returns (uint256); // the charge fee for withdraw\r\n    function chargeFeePool() external returns (address); // the address that will get the returned charge fees.\r\n}\r\n\r\ninterface IDRCWalletStorage {\r\n    // get the deposit address for this _wallet address\r\n    function walletDeposits(address _wallet) external view returns (address);\r\n\r\n    // get frozen status for the deposit address\r\n    function frozenDeposits(address _deposit) external view returns (bool);\r\n\r\n    // get a wallet address by the deposit address and the index\r\n    function wallet(address _deposit, uint256 _ind) external view returns (address);\r\n\r\n    // get a wallet name by the deposit address and the index\r\n    function walletName(address _deposit, uint256 _ind) external view returns (bytes32);\r\n\r\n    // get the wallets number of a deposit address\r\n    function walletsNumber(address _deposit) external view returns (uint256);\r\n\r\n    // get the frozen amount of the deposit address\r\n    function frozenAmount(address _deposit) external view returns (uint256);\r\n\r\n    // get the balance of the deposit address\r\n    function balanceOf(address _deposit) external view returns (uint256);\r\n\r\n    // get the deposit address by index\r\n    function depositAddressByIndex(uint256 _ind) external view returns (address);\r\n\r\n    // get the frozen amount of the deposit address\r\n    function size() external view returns (uint256);\r\n\r\n    // judge if the _deposit address exsisted.\r\n    function isExisted(address _deposit) external view returns (bool);\r\n\r\n    // add one deposit address for that wallet\r\n    function addDeposit(address _wallet, address _depositAddr) external returns (bool);\r\n\r\n    // change the default wallet address for the deposit address\r\n    function changeDefaultWallet(address _oldWallet, address _newWallet) external returns (bool);\r\n\r\n    // freeze or release the tokens that has been deposited in the deposit address.\r\n    function freezeTokens(address _deposit, bool _freeze, uint256 _value) external returns (bool);\r\n\r\n    // increase balance of this deposit address\r\n    function increaseBalance(address _deposit, uint256 _value) external returns (bool);\r\n\r\n    // decrease balance of this deposit address\r\n    function decreaseBalance(address _deposit, uint256 _value) external returns (bool);\r\n\r\n    // add withdraw address for one deposit addresss\r\n    function addWithdraw(address _deposit, bytes32 _name, address _withdraw) external returns (bool);\r\n\r\n    // change the withdraw wallet name\r\n    function changeWalletName(address _deposit, bytes32 _newName, address _wallet) external returns (bool);\r\n\r\n    // remove deposit contract address from storage\r\n    function removeDeposit(address _depositAddr) external returns (bool);\r\n\r\n    // withdraw tokens from this contract\r\n    function withdrawToken(address _token, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract Withdrawable is Ownable {\r\n    event ReceiveEther(address _from, uint256 _value);\r\n    event WithdrawEther(address _to, uint256 _value);\r\n    event WithdrawToken(address _token, address _to, uint256 _value);\r\n\r\n    /**\r\n         * @dev recording receiving ether from msn.sender\r\n         */\r\n    function () payable public {\r\n        emit ReceiveEther(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n         * @dev withdraw,send ether to target\r\n         * @param _to is where the ether will be sent to\r\n         *        _amount is the number of the ether\r\n         */\r\n    function withdraw(address _to, uint _amount) public onlyOwner returns (bool) {\r\n        require(_to != address(0));\r\n        _to.transfer(_amount);\r\n        emit WithdrawEther(_to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n         * @dev withdraw tokens, send tokens to target\r\n     *\r\n     * @param _token the token address that will be withdraw\r\n         * @param _to is where the tokens will be sent to\r\n         *        _value is the number of the token\r\n         */\r\n    function withdrawToken(address _token, address _to, uint256 _value) public onlyOwner returns (bool) {\r\n        require(_to != address(0));\r\n        require(_token != address(0));\r\n\r\n        ERC20 tk = ERC20(_token);\r\n        tk.transfer(_to, _value);\r\n        emit WithdrawToken(_token, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev receive approval from an ERC20 token contract, and then gain the tokens,\r\n     *      then take a record\r\n     *\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _value uint256 the amounts of tokens to be sent\r\n     * @param _token address the ERC20 token address\r\n     * @param _extraData bytes the extra data for the record\r\n     */\r\n    // function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\r\n    //     require(_token != address(0));\r\n    //     require(_from != address(0));\r\n\r\n    //     ERC20 tk = ERC20(_token);\r\n    //     require(tk.transferFrom(_from, this, _value));\r\n\r\n    //     emit ReceiveDeposit(_from, _value, _token, _extraData);\r\n    // }\r\n}\r\n\r\ncontract TokenDestructible is Ownable {\r\n\r\n  constructor() public payable { }\r\n\r\n  /**\r\n   * @notice Terminate contract and refund to owner\r\n   * @param _tokens List of addresses of ERC20 or ERC20Basic token contracts to\r\n   refund.\r\n   * @notice The called token contracts could try to re-enter this contract. Only\r\n   supply token contracts you trust.\r\n   */\r\n  function destroy(address[] _tokens) public onlyOwner {\r\n\r\n    // Transfer tokens to owner\r\n    for (uint256 i = 0; i < _tokens.length; i++) {\r\n      ERC20Basic token = ERC20Basic(_tokens[i]);\r\n      uint256 balance = token.balanceOf(this);\r\n      token.transfer(owner, balance);\r\n    }\r\n\r\n    // Transfer Eth to owner and terminate contract\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\ncontract DepositWithdraw is Claimable, Withdrawable, TokenDestructible {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * transaction record\r\n     */\r\n    struct TransferRecord {\r\n        uint256 timeStamp;\r\n        address account;\r\n        uint256 value;\r\n    }\r\n\r\n    /**\r\n     * accumulated transferring amount record\r\n     */\r\n    struct accumulatedRecord {\r\n        uint256 mul;\r\n        uint256 count;\r\n        uint256 value;\r\n    }\r\n\r\n    TransferRecord[] deposRecs; // record all the deposit tx data\r\n    TransferRecord[] withdrRecs; // record all the withdraw tx data\r\n\r\n    accumulatedRecord dayWithdrawRec; // accumulated amount record for one day\r\n    accumulatedRecord monthWithdrawRec; // accumulated amount record for one month\r\n\r\n    address wallet; // the binded withdraw address\r\n\r\n    event ReceiveDeposit(address _from, uint256 _value, address _token, bytes _extraData);\r\n\r\n    /**\r\n     * @dev constructor of the DepositWithdraw contract\r\n     * @param _wallet the binded wallet address to this depositwithdraw contract\r\n     */\r\n    constructor(address _wallet) public {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n    }\r\n\r\n    /**\r\n         * @dev set the default wallet address\r\n         * @param _wallet the default wallet address binded to this deposit contract\r\n         */\r\n    function setWithdrawWallet(address _wallet) onlyOwner public returns (bool) {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n         * @dev util function to change bytes data to bytes32 data\r\n         * @param _data the bytes data to be converted\r\n         */\r\n    function bytesToBytes32(bytes _data) public pure returns (bytes32 result) {\r\n        assembly {\r\n            result := mload(add(_data, 32))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev receive approval from an ERC20 token contract, take a record\r\n     *\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _value uint256 the amounts of tokens to be sent\r\n     * @param _token address the ERC20 token address\r\n     * @param _extraData bytes the extra data for the record\r\n     */\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) onlyOwner public {\r\n        require(_token != address(0));\r\n        require(_from != address(0));\r\n\r\n        ERC20 tk = ERC20(_token);\r\n        require(tk.transferFrom(_from, this, _value));\r\n        bytes32 timestamp = bytesToBytes32(_extraData);\r\n        deposRecs.push(TransferRecord(uint256(timestamp), _from, _value));\r\n        emit ReceiveDeposit(_from, _value, _token, _extraData);\r\n    }\r\n\r\n    // function authorize(address _token, address _spender, uint256 _value) onlyOwner public returns (bool) {\r\n    //     ERC20 tk = ERC20(_token);\r\n    //     require(tk.approve(_spender, _value));\r\n\r\n    //     return true;\r\n    // }\r\n\r\n    /**\r\n     * @dev record withdraw into this contract\r\n     *\r\n     * @param _time the timstamp of the withdraw time\r\n     * @param _to is where the tokens will be sent to\r\n     * @param _value is the number of the token\r\n     */\r\n    function recordWithdraw(uint256 _time, address _to, uint256 _value) onlyOwner public {\r\n        withdrRecs.push(TransferRecord(_time, _to, _value));\r\n    }\r\n\r\n    /**\r\n     * @dev check if withdraw amount is not valid\r\n     *\r\n     * @param _params the limitation parameters for withdraw\r\n     * @param _value is the number of the token\r\n     * @param _time the timstamp of the withdraw time\r\n     */\r\n    function checkWithdrawAmount(address _params, uint256 _value, uint256 _time) public returns (bool) {\r\n        IDRCWalletMgrParams params = IDRCWalletMgrParams(_params);\r\n        require(_value <= params.singleWithdrawMax());\r\n        require(_value >= params.singleWithdrawMin());\r\n\r\n        uint256 daysCount = _time.div(86400); // one day of seconds\r\n        if (daysCount <= dayWithdrawRec.mul) {\r\n            dayWithdrawRec.count = dayWithdrawRec.count.add(1);\r\n            dayWithdrawRec.value = dayWithdrawRec.value.add(_value);\r\n            require(dayWithdrawRec.count <= params.dayWithdrawCount());\r\n            require(dayWithdrawRec.value <= params.dayWithdraw());\r\n        } else {\r\n            dayWithdrawRec.mul = daysCount;\r\n            dayWithdrawRec.count = 1;\r\n            dayWithdrawRec.value = _value;\r\n        }\r\n\r\n        uint256 monthsCount = _time.div(86400 * 30);\r\n        if (monthsCount <= monthWithdrawRec.mul) {\r\n            monthWithdrawRec.count = monthWithdrawRec.count.add(1);\r\n            monthWithdrawRec.value = monthWithdrawRec.value.add(_value);\r\n            require(monthWithdrawRec.value <= params.monthWithdraw());\r\n        } else {\r\n            monthWithdrawRec.mul = monthsCount;\r\n            monthWithdrawRec.count = 1;\r\n            monthWithdrawRec.value = _value;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n         * @dev withdraw tokens, send tokens to target\r\n     *\r\n     * @param _token the token address that will be withdraw\r\n     * @param _params the limitation parameters for withdraw\r\n     * @param _time the timstamp of the withdraw time\r\n         * @param _to is where the tokens will be sent to\r\n         *        _value is the number of the token\r\n     *        _fee is the amount of the transferring costs\r\n     *        _tokenReturn is the address that return back the tokens of the _fee\r\n         */\r\n    function withdrawToken(address _token, address _params, uint256 _time, address _to, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\r\n        require(_to != address(0));\r\n        require(_token != address(0));\r\n        require(_value > _fee);\r\n        // require(_tokenReturn != address(0));\r\n\r\n        require(checkWithdrawAmount(_params, _value, _time));\r\n\r\n        ERC20 tk = ERC20(_token);\r\n        uint256 realAmount = _value.sub(_fee);\r\n        require(tk.transfer(_to, realAmount));\r\n        if (_tokenReturn != address(0) && _fee > 0) {\r\n            require(tk.transfer(_tokenReturn, _fee));\r\n        }\r\n\r\n        recordWithdraw(_time, _to, realAmount);\r\n        emit WithdrawToken(_token, _to, realAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n         * @dev withdraw tokens, send tokens to target default wallet\r\n     *\r\n     * @param _token the token address that will be withdraw\r\n     * @param _params the limitation parameters for withdraw\r\n     * @param _time the timestamp occur the withdraw record\r\n         * @param _value is the number of the token\r\n     *        _fee is the amount of the transferring costs\r\n     *        â€”tokenReturn is the address that return back the tokens of the _fee\r\n         */\r\n    function withdrawTokenToDefault(address _token, address _params, uint256 _time, uint256 _value, uint256 _fee, address _tokenReturn) public onlyOwner returns (bool) {\r\n        return withdrawToken(_token, _params, _time, wallet, _value, _fee, _tokenReturn);\r\n    }\r\n\r\n    /**\r\n         * @dev get the Deposit records number\r\n     *\r\n     */\r\n    function getDepositNum() public view returns (uint256) {\r\n        return deposRecs.length;\r\n    }\r\n\r\n    /**\r\n         * @dev get the one of the Deposit records\r\n     *\r\n     * @param _ind the deposit record index\r\n     */\r\n    function getOneDepositRec(uint256 _ind) public view returns (uint256, address, uint256) {\r\n        require(_ind < deposRecs.length);\r\n\r\n        return (deposRecs[_ind].timeStamp, deposRecs[_ind].account, deposRecs[_ind].value);\r\n    }\r\n\r\n    /**\r\n         * @dev get the withdraw records number\r\n     *\r\n     */\r\n    function getWithdrawNum() public view returns (uint256) {\r\n        return withdrRecs.length;\r\n    }\r\n\r\n    /**\r\n         * @dev get the one of the withdraw records\r\n     *\r\n     * @param _ind the withdraw record index\r\n     */\r\n    function getOneWithdrawRec(uint256 _ind) public view returns (uint256, address, uint256) {\r\n        require(_ind < withdrRecs.length);\r\n\r\n        return (withdrRecs[_ind].timeStamp, withdrRecs[_ind].account, withdrRecs[_ind].value);\r\n    }\r\n}\r\n\r\ncontract DelayedClaimable is Claimable {\r\n\r\n  uint256 public end;\r\n  uint256 public start;\r\n\r\n  /**\r\n   * @dev Used to specify the time period during which a pending\r\n   * owner can claim ownership.\r\n   * @param _start The earliest time ownership can be claimed.\r\n   * @param _end The latest time ownership can be claimed.\r\n   */\r\n  function setLimits(uint256 _start, uint256 _end) public onlyOwner {\r\n    require(_start <= _end);\r\n    end = _end;\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\r\n   * the specified start and end time.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    require((block.number <= end) && (block.number >= start));\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n    end = 0;\r\n  }\r\n\r\n}\r\n\r\ncontract OwnerContract is DelayedClaimable {\r\n    Claimable public ownedContract;\r\n    address public pendingOwnedOwner;\r\n    // address internal origOwner;\r\n\r\n    /**\r\n     * @dev bind a contract as its owner\r\n     *\r\n     * @param _contract the contract address that will be binded by this Owner Contract\r\n     */\r\n    function bindContract(address _contract) onlyOwner public returns (bool) {\r\n        require(_contract != address(0));\r\n        ownedContract = Claimable(_contract);\r\n        // origOwner = ownedContract.owner();\r\n\r\n        // take ownership of the owned contract\r\n        if (ownedContract.owner() != address(this)) {\r\n            ownedContract.claimOwnership();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change the owner of the contract from this contract address to the original one.\r\n     *\r\n     */\r\n    // function transferOwnershipBack() onlyOwner public {\r\n    //     ownedContract.transferOwnership(origOwner);\r\n    //     ownedContract = Claimable(address(0));\r\n    //     origOwner = address(0);\r\n    // }\r\n\r\n    /**\r\n     * @dev change the owner of the contract from this contract address to another one.\r\n     *\r\n     * @param _nextOwner the contract address that will be next Owner of the original Contract\r\n     */\r\n    function changeOwnershipto(address _nextOwner)  onlyOwner public {\r\n        require(ownedContract != address(0));\r\n\r\n        if (ownedContract.owner() != pendingOwnedOwner) {\r\n            ownedContract.transferOwnership(_nextOwner);\r\n            pendingOwnedOwner = _nextOwner;\r\n            // ownedContract = Claimable(address(0));\r\n            // origOwner = address(0);\r\n        } else {\r\n            // the pending owner has already taken the ownership\r\n            ownedContract = Claimable(address(0));\r\n            pendingOwnedOwner = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to confirm the owner of the owned contract has already been transferred.\r\n     *\r\n     */\r\n    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\r\n        require(ownedContract != address(0));\r\n        if (ownedContract.owner() == pendingOwnedOwner) {\r\n            // the pending owner has already taken the ownership\r\n            ownedContract = Claimable(address(0));\r\n            pendingOwnedOwner = address(0);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * withdraw wallet description\r\n     */\r\n    // struct WithdrawWallet {\r\n    //     bytes32 name;\r\n    //     address walletAddr;\r\n    // }\r\n\r\n    /**\r\n     * Deposit data storage\r\n     */\r\n    // struct DepositRepository {\r\n    //     // uint256 balance;\r\n    //     uint256 frozen;\r\n    //     WithdrawWallet[] withdrawWallets;\r\n    //     // mapping (bytes32 => address) withdrawWallets;\r\n    // }\r\n\r\n    // mapping (address => DepositRepository) depositRepos;\r\n    // mapping (address => address) public walletDeposits;\r\n    // mapping (address => bool) public frozenDeposits;\r\n\r\n    ERC20 public tk; // the token will be managed\r\n    IDRCWalletMgrParams public params; // the parameters that the management needs\r\n    IDRCWalletStorage public walletStorage; // the deposits and wallets data stored in a contract\r\n\r\n    event CreateDepositAddress(address indexed _wallet, address _deposit);\r\n    event FrozenTokens(address indexed _deposit, bool _freeze, uint256 _value);\r\n    event ChangeDefaultWallet(address indexed _oldWallet, address _newWallet);\r\n\r\n    /**\r\n         * @dev initialize this contract with token, parameters and storage address\r\n     *\r\n     * @param _token the token address that will be withdraw\r\n     * @param _walletParams the wallet management parameters\r\n         */\r\n    function initialize(address _token, address _walletParams, address _walletStorage) onlyOwner public returns (bool) {\r\n        require(_token != address(0));\r\n        require(_walletParams != address(0));\r\n\r\n        tk = ERC20(_token);\r\n        params = IDRCWalletMgrParams(_walletParams);\r\n        walletStorage = IDRCWalletStorage(_walletStorage);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n         * @dev create deposit contract address for the default withdraw wallet\r\n     *\r\n     * @param _wallet the binded default withdraw wallet address\r\n         */\r\n    function createDepositContract(address _wallet) onlyOwner public returns (address) {\r\n        require(_wallet != address(0));\r\n\r\n        DepositWithdraw deposWithdr = new DepositWithdraw(_wallet); // new contract for deposit\r\n        address _deposit = address(deposWithdr);\r\n        // walletDeposits[_wallet] = _deposit;\r\n        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\r\n        // withdrawWalletList.push(WithdrawWallet(\"default wallet\", _wallet));\r\n        // // depositRepos[_deposit].balance = 0;\r\n        // depositRepos[_deposit].frozen = 0;\r\n\r\n        walletStorage.addDeposit(_wallet, _deposit);\r\n\r\n        // deposWithdr.authorize(address(tk), this, 1e27); // give authorization to owner contract\r\n\r\n        emit CreateDepositAddress(_wallet, _deposit);\r\n        return _deposit;\r\n    }\r\n\r\n    /**\r\n         * @dev deposit a value of funds to the deposit address\r\n     *\r\n     * @param _deposit the deposit address\r\n     * @param _increase increase or decrease the value\r\n     * @param _value the deposit funds value\r\n         */\r\n    function doDeposit(address _deposit, bool _increase, uint256 _value) onlyOwner public returns (bool) {\r\n        return (_increase\r\n                ? walletStorage.increaseBalance(_deposit, _value)\r\n                : walletStorage.decreaseBalance(_deposit, _value));\r\n    }\r\n\r\n    /**\r\n         * @dev get deposit contract address by using the default withdraw wallet\r\n     *\r\n     * @param _wallet the binded default withdraw wallet address\r\n         */\r\n    function getDepositAddress(address _wallet) onlyOwner public view returns (address) {\r\n        require(_wallet != address(0));\r\n        // address deposit = walletDeposits[_wallet];\r\n\r\n        // return deposit;\r\n        return walletStorage.walletDeposits(_wallet);\r\n    }\r\n\r\n    /**\r\n         * @dev get deposit balance and frozen amount by using the deposit address\r\n     *\r\n     * @param _deposit the deposit contract address\r\n         */\r\n    function getDepositInfo(address _deposit) onlyOwner public view returns (uint256, uint256) {\r\n        require(_deposit != address(0));\r\n        uint256 _balance = walletStorage.balanceOf(_deposit);\r\n        // uint256 frozenAmount = depositRepos[_deposit].frozen;\r\n        uint256 frozenAmount = walletStorage.frozenAmount(_deposit);\r\n        // depositRepos[_deposit].balance = _balance;\r\n\r\n        return (_balance, frozenAmount);\r\n    }\r\n\r\n    /**\r\n         * @dev get the number of withdraw wallet addresses bindig to the deposit contract address\r\n     *\r\n     * @param _deposit the deposit contract address\r\n         */\r\n    function getDepositWithdrawCount(address _deposit) onlyOwner public view returns (uint) {\r\n        require(_deposit != address(0));\r\n\r\n        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\r\n        // uint len = withdrawWalletList.length;\r\n        uint len = walletStorage.walletsNumber(_deposit);\r\n\r\n        return len;\r\n    }\r\n\r\n    /**\r\n         * @dev get the withdraw wallet addresses list binding to the deposit contract address\r\n     *\r\n     * @param _deposit the deposit contract address\r\n     * @param _indices the array of indices of the withdraw wallets\r\n         */\r\n    function getDepositWithdrawList(address _deposit, uint[] _indices) onlyOwner public view returns (bytes32[], address[]) {\r\n        require(_indices.length != 0);\r\n\r\n        bytes32[] memory names = new bytes32[](_indices.length);\r\n        address[] memory wallets = new address[](_indices.length);\r\n\r\n        for (uint i = 0; i < _indices.length; i = i.add(1)) {\r\n            // WithdrawWallet storage wallet = depositRepos[_deposit].withdrawWallets[_indices[i]];\r\n            // names[i] = wallet.name;\r\n            // wallets[i] = wallet.walletAddr;\r\n            names[i] = walletStorage.walletName(_deposit, i);\r\n            wallets[i] = walletStorage.wallet(_deposit, i);\r\n        }\r\n\r\n        return (names, wallets);\r\n    }\r\n\r\n    /**\r\n         * @dev change the default withdraw wallet address binding to the deposit contract address\r\n     *\r\n     * @param _oldWallet the previous default withdraw wallet\r\n     * @param _newWallet the new default withdraw wallet\r\n         */\r\n    function changeDefaultWithdraw(address _oldWallet, address _newWallet) onlyOwner public returns (bool) {\r\n        require(_oldWallet != address(0));\r\n        require(_newWallet != address(0));\r\n\r\n        address deposit = walletStorage.walletDeposits(_oldWallet);\r\n        DepositWithdraw deposWithdr = DepositWithdraw(deposit);\r\n        require(deposWithdr.setWithdrawWallet(_newWallet));\r\n\r\n        // WithdrawWallet[] storage withdrawWalletList = depositRepos[deposit].withdrawWallets;\r\n        // withdrawWalletList[0].walletAddr = _newWallet;\r\n        bool res = walletStorage.changeDefaultWallet(_oldWallet, _newWallet);\r\n        emit ChangeDefaultWallet(_oldWallet, _newWallet);\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n         * @dev freeze the tokens in the deposit address\r\n     *\r\n     * @param _deposit the deposit address\r\n     * @param _freeze to freeze or release\r\n     * @param _value the amount of tokens need to be frozen\r\n         */\r\n    function freezeTokens(address _deposit, bool _freeze, uint256 _value) onlyOwner public returns (bool) {\r\n        // require(_deposit != address(0));\r\n\r\n        // frozenDeposits[_deposit] = _freeze;\r\n        // if (_freeze) {\r\n        //     depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.add(_value);\r\n        // } else {\r\n        //     require(_value <= depositRepos[_deposit].frozen);\r\n        //     depositRepos[_deposit].frozen = depositRepos[_deposit].frozen.sub(_value);\r\n        // }\r\n\r\n        bool res = walletStorage.freezeTokens(_deposit, _freeze, _value);\r\n\r\n        emit FrozenTokens(_deposit, _freeze, _value);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n         * @dev withdraw the tokens from the deposit address to default wallet with charge fee\r\n     *\r\n     * @param _deposit the deposit address\r\n     * @param _time the timestamp the withdraw occurs\r\n     * @param _value the amount of tokens need to be frozen\r\n     * @param _check if we will check the value is valid or meet the limit condition\r\n         */\r\n    function withdrawWithFee(address _deposit, uint256 _time, uint256 _value, bool _check) onlyOwner public returns (bool) {\r\n        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\r\n        // return withdrawWithFee(_deposit, _time, withdrawWalletList[0].name, withdrawWalletList[0].walletAddr, _value, _check);\r\n        bytes32 defaultWalletName = walletStorage.walletName(_deposit, 0);\r\n        address defaultWallet = walletStorage.wallet(_deposit, 0);\r\n        return withdrawWithFee(_deposit, _time, defaultWalletName, defaultWallet, _value, _check);\r\n    }\r\n\r\n    /**\r\n         * @dev check if the wallet name is not matching the expected wallet address\r\n     *\r\n     * @param _deposit the deposit address\r\n     * @param _name the withdraw wallet name\r\n     * @param _to the withdraw wallet address\r\n         */\r\n    function checkWithdrawAddress(address _deposit, bytes32 _name, address _to) public view returns (bool, bool) {\r\n        // uint len = depositRepos[_deposit].withdrawWallets.length;\r\n        uint len = walletStorage.walletsNumber(_deposit);\r\n        for (uint i = 0; i < len; i = i.add(1)) {\r\n            // WithdrawWallet memory wallet = depositRepos[_deposit].withdrawWallets[i];\r\n            // if (_name == wallet.name) {\r\n            //     return(true, (_to == wallet.walletAddr));\r\n            // }\r\n            // if (_to == wallet.walletAddr) {\r\n            //     return(true, true);\r\n            // }\r\n            bytes32 walletName = walletStorage.walletName(_deposit, i);\r\n            address walletAddr = walletStorage.wallet(_deposit, i);\r\n            if (_name == walletName) {\r\n                return(true, (_to == walletAddr));\r\n            }\r\n            if (_to == walletAddr) {\r\n                return(false, true);\r\n            }\r\n        }\r\n\r\n        return (false, false);\r\n    }\r\n\r\n    /**\r\n         * @dev withdraw tokens from this contract, send tokens to target withdraw wallet\r\n     *\r\n     * @param _deposWithdr the deposit contract that will record withdrawing\r\n     * @param _time the timestamp occur the withdraw record\r\n     * @param _to the address the token will be transfer to\r\n     * @param _value the token transferred value\r\n         */\r\n    function withdrawFromThis(DepositWithdraw _deposWithdr, uint256 _time, address _to, uint256 _value) private returns (bool) {\r\n        uint256 fee = params.chargeFee();\r\n        uint256 realAmount = _value.sub(fee);\r\n        address tokenReturn = params.chargeFeePool();\r\n        if (tokenReturn != address(0) && fee > 0) {\r\n            // require(tk.transfer(tokenReturn, fee));\r\n            require(walletStorage.withdrawToken(tk, tokenReturn, fee));\r\n        }\r\n\r\n        // require (tk.transfer(_to, realAmount));\r\n        require(walletStorage.withdrawToken(tk, _to, realAmount));\r\n        _deposWithdr.recordWithdraw(_time, _to, realAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n         * @dev withdraw tokens, send tokens to target withdraw wallet\r\n     *\r\n     * @param _deposit the deposit address that will be withdraw from\r\n     * @param _time the timestamp occur the withdraw record\r\n         * @param _name the withdraw address alias name to verify\r\n     * @param _to the address the token will be transfer to\r\n     * @param _value the token transferred value\r\n     * @param _check if we will check the value is valid or meet the limit condition\r\n         */\r\n    function withdrawWithFee(address _deposit,\r\n                             uint256 _time,\r\n                             bytes32 _name,\r\n                             address _to,\r\n                             uint256 _value,\r\n                             bool _check) onlyOwner public returns (bool) {\r\n        require(_deposit != address(0));\r\n        require(_to != address(0));\r\n\r\n        uint256 totalBalance = walletStorage.balanceOf(_deposit);\r\n        uint256 frozen = walletStorage.frozenAmount(_deposit);\r\n        // uint256 available = totalBalance.sub(frozen);\r\n        // require(_value <= available);\r\n        if (_check) {\r\n            require(_value <= totalBalance.sub(frozen));\r\n        }\r\n\r\n        uint256 _balance = tk.balanceOf(_deposit);\r\n\r\n        bool exist;\r\n        bool correct;\r\n        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;\r\n        (exist, correct) = checkWithdrawAddress(_deposit, _name, _to);\r\n        if(!exist) {\r\n            // withdrawWalletList.push(WithdrawWallet(_name, _to));\r\n            if (!correct) {\r\n                walletStorage.addWithdraw(_deposit, _name, _to);\r\n            } else {\r\n                walletStorage.changeWalletName(_deposit, _name, _to);\r\n            }\r\n        } else {\r\n            require(correct, \"wallet address must be correct with wallet name!\");\r\n        }\r\n\r\n        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\r\n        /**\r\n         * if deposit address doesn't have enough tokens to withdraw,\r\n         * then withdraw from this contract. Record this in the independent deposit contract.\r\n         */\r\n        if (_value > _balance) {\r\n            require(deposWithdr.checkWithdrawAmount(address(params), _value, _time));\r\n            if(_balance > 0) {\r\n                require(deposWithdr.withdrawToken(address(tk), address(walletStorage), _balance));\r\n            }\r\n\r\n            require(withdrawFromThis(deposWithdr, _time, _to, _value));\r\n            // return true;\r\n        } else {\r\n            require(deposWithdr.withdrawToken(address(tk), address(params), _time, _to, _value, params.chargeFee(), params.chargeFeePool()));\r\n        }\r\n\r\n        return walletStorage.decreaseBalance(_deposit, _value);\r\n    }\r\n\r\n    /**\r\n         * @dev destory the old depoist contract and take back the tokens\r\n     *\r\n     * @param _deposit the deposit address\r\n         */\r\n    function destroyDepositContract(address _deposit) onlyOwner public returns (bool) {\r\n        require(_deposit != address(0));\r\n\r\n        DepositWithdraw deposWithdr = DepositWithdraw(_deposit);\r\n        address[] memory tokens = new address[](1);\r\n        tokens[0] = address(tk);\r\n        deposWithdr.destroy(tokens);\r\n\r\n        return walletStorage.removeDeposit(_deposit);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"}],\"name\":\"getDepositWithdrawCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tk\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"freezeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldWallet\",\"type\":\"address\"},{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"changeDefaultWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwnedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_check\",\"type\":\"bool\"}],\"name\":\"withdrawWithFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"},{\"name\":\"_increase\",\"type\":\"bool\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"doDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"}],\"name\":\"getDepositInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"checkWithdrawAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"},{\"name\":\"_indices\",\"type\":\"uint256[]\"}],\"name\":\"getDepositWithdrawList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"bindContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"}],\"name\":\"destroyDepositContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"createDepositContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownedContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_walletParams\",\"type\":\"address\"},{\"name\":\"_walletStorage\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"params\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getDepositAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownedOwnershipTransferred\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"changeOwnershipto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_check\",\"type\":\"bool\"}],\"name\":\"withdrawWithFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_deposit\",\"type\":\"address\"}],\"name\":\"CreateDepositAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_deposit\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_freeze\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"FrozenTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"ChangeDefaultWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ReceiveEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"WithdrawEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"WithdrawToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DRCWalletManager","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://712a232f462a2374baadf9e545d65a9fb8b18f294852f8502b5b4969c8692271"}]}