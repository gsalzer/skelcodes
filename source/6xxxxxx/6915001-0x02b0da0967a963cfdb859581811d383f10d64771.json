{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2018 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract IOwnable {\r\n\r\n    function transferOwnership(address newOwner)\r\n        public;\r\n}\r\n\r\n\r\ncontract Ownable is\r\n    IOwnable\r\n{\r\n    address public owner;\r\n\r\n    constructor ()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"ONLY_CONTRACT_OWNER\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract IAuthorizable is\r\n    IOwnable\r\n{\r\n    /// @dev Authorizes an address.\r\n    /// @param target Address to authorize.\r\n    function addAuthorizedAddress(address target)\r\n        external;\r\n\r\n    /// @dev Removes authorizion of an address.\r\n    /// @param target Address to remove authorization from.\r\n    function removeAuthorizedAddress(address target)\r\n        external;\r\n\r\n    /// @dev Removes authorizion of an address.\r\n    /// @param target Address to remove authorization from.\r\n    /// @param index Index of target in authorities array.\r\n    function removeAuthorizedAddressAtIndex(\r\n        address target,\r\n        uint256 index\r\n    )\r\n        external;\r\n    \r\n    /// @dev Gets all authorized addresses.\r\n    /// @return Array of authorized addresses.\r\n    function getAuthorizedAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n}\r\n\r\n\r\n\r\ncontract MAuthorizable is\r\n    IAuthorizable\r\n{\r\n    // Event logged when a new address is authorized.\r\n    event AuthorizedAddressAdded(\r\n        address indexed target,\r\n        address indexed caller\r\n    );\r\n\r\n    // Event logged when a currently authorized address is unauthorized.\r\n    event AuthorizedAddressRemoved(\r\n        address indexed target,\r\n        address indexed caller\r\n    );\r\n\r\n    /// @dev Only authorized addresses can invoke functions with this modifier.\r\n    modifier onlyAuthorized { revert(); _; }\r\n}\r\n\r\n\r\ncontract MixinAuthorizable is\r\n    Ownable,\r\n    MAuthorizable\r\n{\r\n    /// @dev Only authorized addresses can invoke functions with this modifier.\r\n    modifier onlyAuthorized {\r\n        require(\r\n            authorized[msg.sender],\r\n            \"SENDER_NOT_AUTHORIZED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    mapping (address => bool) public authorized;\r\n    address[] public authorities;\r\n\r\n    /// @dev Authorizes an address.\r\n    /// @param target Address to authorize.\r\n    function addAuthorizedAddress(address target)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            !authorized[target],\r\n            \"TARGET_ALREADY_AUTHORIZED\"\r\n        );\r\n\r\n        authorized[target] = true;\r\n        authorities.push(target);\r\n        emit AuthorizedAddressAdded(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Removes authorizion of an address.\r\n    /// @param target Address to remove authorization from.\r\n    function removeAuthorizedAddress(address target)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            authorized[target],\r\n            \"TARGET_NOT_AUTHORIZED\"\r\n        );\r\n\r\n        delete authorized[target];\r\n        for (uint256 i = 0; i < authorities.length; i++) {\r\n            if (authorities[i] == target) {\r\n                authorities[i] = authorities[authorities.length - 1];\r\n                authorities.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        emit AuthorizedAddressRemoved(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Removes authorizion of an address.\r\n    /// @param target Address to remove authorization from.\r\n    /// @param index Index of target in authorities array.\r\n    function removeAuthorizedAddressAtIndex(\r\n        address target,\r\n        uint256 index\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            authorized[target],\r\n            \"TARGET_NOT_AUTHORIZED\"\r\n        );\r\n        require(\r\n            index < authorities.length,\r\n            \"INDEX_OUT_OF_BOUNDS\"\r\n        );\r\n        require(\r\n            authorities[index] == target,\r\n            \"AUTHORIZED_ADDRESS_MISMATCH\"\r\n        );\r\n\r\n        delete authorized[target];\r\n        authorities[index] = authorities[authorities.length - 1];\r\n        authorities.length -= 1;\r\n        emit AuthorizedAddressRemoved(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Gets all authorized addresses.\r\n    /// @return Array of authorized addresses.\r\n    function getAuthorizedAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return authorities;\r\n    }\r\n}\r\n\r\ncontract IAssetProxy is\r\n    IAuthorizable\r\n{\r\n    /// @dev Transfers assets. Either succeeds or throws.\r\n    /// @param assetData Byte array encoded for the respective asset proxy.\r\n    /// @param from Address to transfer asset from.\r\n    /// @param to Address to transfer asset to.\r\n    /// @param amount Amount of asset to transfer.\r\n    function transferFrom(\r\n        bytes assetData,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        external;\r\n    \r\n    /// @dev Gets the proxy id associated with the proxy address.\r\n    /// @return Proxy id.\r\n    function getProxyId()\r\n        external\r\n        pure\r\n        returns (bytes4);\r\n}\r\n\r\n\r\ncontract IAssetProxyDispatcher {\r\n\r\n    /// @dev Registers an asset proxy to its asset proxy id.\r\n    ///      Once an asset proxy is registered, it cannot be unregistered.\r\n    /// @param assetProxy Address of new asset proxy to register.\r\n    function registerAssetProxy(address assetProxy)\r\n        external;\r\n\r\n    /// @dev Gets an asset proxy.\r\n    /// @param assetProxyId Id of the asset proxy.\r\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\r\n    function getAssetProxy(bytes4 assetProxyId)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n\r\ncontract MAssetProxyDispatcher is\r\n    IAssetProxyDispatcher\r\n{\r\n    // Logs registration of new asset proxy\r\n    event AssetProxyRegistered(\r\n        bytes4 id,              // Id of new registered AssetProxy.\r\n        address assetProxy      // Address of new registered AssetProxy.\r\n    );\r\n\r\n    /// @dev Forwards arguments to assetProxy and calls `transferFrom`. Either succeeds or throws.\r\n    /// @param assetData Byte array encoded for the asset.\r\n    /// @param from Address to transfer token from.\r\n    /// @param to Address to transfer token to.\r\n    /// @param amount Amount of token to transfer.\r\n    function dispatchTransferFrom(\r\n        bytes memory assetData,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal;\r\n}\r\n\r\ncontract MixinAssetProxyDispatcher is\r\n    Ownable,\r\n    MAssetProxyDispatcher\r\n{\r\n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\r\n    mapping (bytes4 => IAssetProxy) public assetProxies;\r\n\r\n    /// @dev Registers an asset proxy to its asset proxy id.\r\n    ///      Once an asset proxy is registered, it cannot be unregistered.\r\n    /// @param assetProxy Address of new asset proxy to register.\r\n    function registerAssetProxy(address assetProxy)\r\n        external\r\n        onlyOwner\r\n    {\r\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\r\n\r\n        // Ensure that no asset proxy exists with current id.\r\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\r\n        address currentAssetProxy = assetProxies[assetProxyId];\r\n        require(\r\n            currentAssetProxy == address(0),\r\n            \"ASSET_PROXY_ALREADY_EXISTS\"\r\n        );\r\n\r\n        // Add asset proxy and log registration.\r\n        assetProxies[assetProxyId] = assetProxyContract;\r\n        emit AssetProxyRegistered(\r\n            assetProxyId,\r\n            assetProxy\r\n        );\r\n    }\r\n\r\n    /// @dev Gets an asset proxy.\r\n    /// @param assetProxyId Id of the asset proxy.\r\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\r\n    function getAssetProxy(bytes4 assetProxyId)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return assetProxies[assetProxyId];\r\n    }\r\n\r\n    /// @dev Forwards arguments to assetProxy and calls `transferFrom`. Either succeeds or throws.\r\n    /// @param assetData Byte array encoded for the asset.\r\n    /// @param from Address to transfer token from.\r\n    /// @param to Address to transfer token to.\r\n    /// @param amount Amount of token to transfer.\r\n    function dispatchTransferFrom(\r\n        bytes memory assetData,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        // Do nothing if no amount should be transferred.\r\n        if (amount > 0 && from != to) {\r\n            // Ensure assetData length is valid\r\n            require(\r\n                assetData.length > 3,\r\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\r\n            );\r\n            \r\n            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\r\n            bytes4 assetProxyId;\r\n            assembly {\r\n                assetProxyId := and(mload(\r\n                    add(assetData, 32)),\r\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n                )\r\n            }\r\n            address assetProxy = assetProxies[assetProxyId];\r\n\r\n            // Ensure that assetProxy exists\r\n            require(\r\n                assetProxy != address(0),\r\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\r\n            );\r\n            \r\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\r\n            // The layout of this calldata is in the table below.\r\n            // \r\n            // | Area     | Offset | Length  | Contents                                    |\r\n            // | -------- |--------|---------|-------------------------------------------- |\r\n            // | Header   | 0      | 4       | function selector                           |\r\n            // | Params   |        | 4 * 32  | function parameters:                        |\r\n            // |          | 4      |         |   1. offset to assetData (*)                |\r\n            // |          | 36     |         |   2. from                                   |\r\n            // |          | 68     |         |   3. to                                     |\r\n            // |          | 100    |         |   4. amount                                 |\r\n            // | Data     |        |         | assetData:                                  |\r\n            // |          | 132    | 32      | assetData Length                            |\r\n            // |          | 164    | **      | assetData Contents                          |\r\n\r\n            assembly {\r\n                /////// Setup State ///////\r\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\r\n                let cdStart := mload(64)\r\n                // `dataAreaLength` is the total number of words needed to store `assetData`\r\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\r\n                //  and includes 32-bytes for length.\r\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\r\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\r\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\r\n\r\n                \r\n                /////// Setup Header Area ///////\r\n                // This area holds the 4-byte `transferFromSelector`.\r\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\r\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\r\n                \r\n                /////// Setup Params Area ///////\r\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\r\n                // Notes:\r\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\r\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\r\n                mstore(add(cdStart, 4), 128)\r\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(cdStart, 100), amount)\r\n                \r\n                /////// Setup Data Area ///////\r\n                // This area holds `assetData`.\r\n                let dataArea := add(cdStart, 132)\r\n                // solhint-disable-next-line no-empty-blocks\r\n                for {} lt(dataArea, cdEnd) {} {\r\n                    mstore(dataArea, mload(assetData))\r\n                    dataArea := add(dataArea, 32)\r\n                    assetData := add(assetData, 32)\r\n                }\r\n\r\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\r\n                let success := call(\r\n                    gas,                    // forward all gas\r\n                    assetProxy,             // call address of asset proxy\r\n                    0,                      // don't send any ETH\r\n                    cdStart,                // pointer to start of input\r\n                    sub(cdEnd, cdStart),    // length of input  \r\n                    cdStart,                // write output over input\r\n                    512                     // reserve 512 bytes for output\r\n                )\r\n                if iszero(success) {\r\n                    revert(cdStart, returndatasize())\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract MultiAssetProxy is\r\n    MixinAssetProxyDispatcher,\r\n    MixinAuthorizable\r\n{\r\n    // Id of this proxy.\r\n    bytes4 constant internal PROXY_ID = bytes4(keccak256(\"MultiAsset(uint256[],bytes[])\"));\r\n\r\n    // solhint-disable-next-line payable-fallback\r\n    function ()\r\n        external\r\n    {\r\n        assembly {\r\n            // The first 4 bytes of calldata holds the function selector\r\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\r\n\r\n            // `transferFrom` will be called with the following parameters:\r\n            // assetData Encoded byte array.\r\n            // from Address to transfer asset from.\r\n            // to Address to transfer asset to.\r\n            // amount Amount of asset to transfer.\r\n            // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\r\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\r\n\r\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\r\n                // where k is the key left padded to 32 bytes and p is the storage slot\r\n                mstore(0, caller)\r\n                mstore(32, authorized_slot)\r\n\r\n                // Revert if authorized[msg.sender] == false\r\n                if iszero(sload(keccak256(0, 64))) {\r\n                    // Revert with `Error(\"SENDER_NOT_AUTHORIZED\")`\r\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\r\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\r\n                    mstore(96, 0)\r\n                    revert(0, 100)\r\n                }\r\n\r\n                // `transferFrom`.\r\n                // The function is marked `external`, so no abi decoding is done for\r\n                // us. Instead, we expect the `calldata` memory to contain the\r\n                // following:\r\n                //\r\n                // | Area     | Offset | Length  | Contents                            |\r\n                // |----------|--------|---------|-------------------------------------|\r\n                // | Header   | 0      | 4       | function selector                   |\r\n                // | Params   |        | 4 * 32  | function parameters:                |\r\n                // |          | 4      |         |   1. offset to assetData (*)        |\r\n                // |          | 36     |         |   2. from                           |\r\n                // |          | 68     |         |   3. to                             |\r\n                // |          | 100    |         |   4. amount                         |\r\n                // | Data     |        |         | assetData:                          |\r\n                // |          | 132    | 32      | assetData Length                    |\r\n                // |          | 164    | **      | assetData Contents                  |\r\n                //\r\n                // (*): offset is computed from start of function parameters, so offset\r\n                //      by an additional 4 bytes in the calldata.\r\n                //\r\n                // (**): see table below to compute length of assetData Contents\r\n                //\r\n                // WARNING: The ABIv2 specification allows additional padding between\r\n                //          the Params and Data section. This will result in a larger\r\n                //          offset to assetData.\r\n\r\n                // Load offset to `assetData`\r\n                let assetDataOffset := calldataload(4)\r\n\r\n                // Asset data itself is encoded as follows:\r\n                //\r\n                // | Area     | Offset      | Length  | Contents                            |\r\n                // |----------|-------------|---------|-------------------------------------|\r\n                // | Header   | 0           | 4       | assetProxyId                        |\r\n                // | Params   |             | 2 * 32  | function parameters:                |\r\n                // |          | 4           |         |   1. offset to amounts (*)          |\r\n                // |          | 36          |         |   2. offset to nestedAssetData (*)  |\r\n                // | Data     |             |         | amounts:                            |\r\n                // |          | 68          | 32      | amounts Length                      |\r\n                // |          | 100         | a       | amounts Contents                    | \r\n                // |          |             |         | nestedAssetData:                    |\r\n                // |          | 100 + a     | 32      | nestedAssetData Length              |\r\n                // |          | 132 + a     | b       | nestedAssetData Contents (offsets)  |\r\n                // |          | 132 + a + b |         | nestedAssetData[0, ..., len]        |\r\n\r\n                // In order to find the offset to `amounts`, we must add:\r\n                // 4 (function selector)\r\n                // + assetDataOffset\r\n                // + 32 (assetData len)\r\n                // + 4 (assetProxyId)\r\n                let amountsOffset := calldataload(add(assetDataOffset, 40))\r\n\r\n                // In order to find the offset to `nestedAssetData`, we must add:\r\n                // 4 (function selector)\r\n                // + assetDataOffset\r\n                // + 32 (assetData len)\r\n                // + 4 (assetProxyId)\r\n                // + 32 (amounts offset)\r\n                let nestedAssetDataOffset := calldataload(add(assetDataOffset, 72))\r\n\r\n                // In order to find the start of the `amounts` contents, we must add: \r\n                // 4 (function selector) \r\n                // + assetDataOffset \r\n                // + 32 (assetData len)\r\n                // + 4 (assetProxyId)\r\n                // + amountsOffset\r\n                // + 32 (amounts len)\r\n                let amountsContentsStart := add(assetDataOffset, add(amountsOffset, 72))\r\n\r\n                // Load number of elements in `amounts`\r\n                let amountsLen := calldataload(sub(amountsContentsStart, 32))\r\n\r\n                // In order to find the start of the `nestedAssetData` contents, we must add: \r\n                // 4 (function selector) \r\n                // + assetDataOffset \r\n                // + 32 (assetData len)\r\n                // + 4 (assetProxyId)\r\n                // + nestedAssetDataOffset\r\n                // + 32 (nestedAssetData len)\r\n                let nestedAssetDataContentsStart := add(assetDataOffset, add(nestedAssetDataOffset, 72))\r\n\r\n                // Load number of elements in `nestedAssetData`\r\n                let nestedAssetDataLen := calldataload(sub(nestedAssetDataContentsStart, 32))\r\n\r\n                // Revert if number of elements in `amounts` differs from number of elements in `nestedAssetData`\r\n                if iszero(eq(amountsLen, nestedAssetDataLen)) {\r\n                    // Revert with `Error(\"LENGTH_MISMATCH\")`\r\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\r\n                    mstore(64, 0x0000000f4c454e4754485f4d49534d4154434800000000000000000000000000)\r\n                    mstore(96, 0)\r\n                    revert(0, 100)\r\n                }\r\n\r\n                // Copy `transferFrom` selector, offset to `assetData`, `from`, and `to` from calldata to memory\r\n                calldatacopy(\r\n                    0,   // memory can safely be overwritten from beginning\r\n                    0,   // start of calldata\r\n                    100  // length of selector (4) and 3 params (32 * 3)\r\n                )\r\n\r\n                // Overwrite existing offset to `assetData` with our own\r\n                mstore(4, 128)\r\n                \r\n                // Load `amount`\r\n                let amount := calldataload(100)\r\n        \r\n                // Calculate number of bytes in `amounts` contents\r\n                let amountsByteLen := mul(amountsLen, 32)\r\n\r\n                // Initialize `assetProxyId` and `assetProxy` to 0\r\n                let assetProxyId := 0\r\n                let assetProxy := 0\r\n\r\n                // Loop through `amounts` and `nestedAssetData`, calling `transferFrom` for each respective element\r\n                for {let i := 0} lt(i, amountsByteLen) {i := add(i, 32)} {\r\n\r\n                    // Calculate the total amount\r\n                    let amountsElement := calldataload(add(amountsContentsStart, i))\r\n                    let totalAmount := mul(amountsElement, amount)\r\n\r\n                    // Revert if multiplication resulted in an overflow\r\n                    if iszero(eq(div(totalAmount, amount), amountsElement)) {\r\n                        // Revert with `Error(\"UINT256_OVERFLOW\")`\r\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                        mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\r\n                        mstore(64, 0x0000001055494e543235365f4f564552464c4f57000000000000000000000000)\r\n                        mstore(96, 0)\r\n                        revert(0, 100)\r\n                    }\r\n\r\n                    // Write `totalAmount` to memory\r\n                    mstore(100, totalAmount)\r\n\r\n                    // Load offset to `nestedAssetData[i]`\r\n                    let nestedAssetDataElementOffset := calldataload(add(nestedAssetDataContentsStart, i))\r\n\r\n                    // In order to find the start of the `nestedAssetData[i]` contents, we must add:\r\n                    // 4 (function selector) \r\n                    // + assetDataOffset \r\n                    // + 32 (assetData len)\r\n                    // + 4 (assetProxyId)\r\n                    // + nestedAssetDataOffset\r\n                    // + 32 (nestedAssetData len)\r\n                    // + nestedAssetDataElementOffset\r\n                    // + 32 (nestedAssetDataElement len)\r\n                    let nestedAssetDataElementContentsStart := add(assetDataOffset, add(nestedAssetDataOffset, add(nestedAssetDataElementOffset, 104)))\r\n\r\n                    // Load length of `nestedAssetData[i]`\r\n                    let nestedAssetDataElementLenStart := sub(nestedAssetDataElementContentsStart, 32)\r\n                    let nestedAssetDataElementLen := calldataload(nestedAssetDataElementLenStart)\r\n\r\n                    // Revert if the `nestedAssetData` does not contain a 4 byte `assetProxyId`\r\n                    if lt(nestedAssetDataElementLen, 4) {\r\n                        // Revert with `Error(\"LENGTH_GREATER_THAN_3_REQUIRED\")`\r\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                        mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\r\n                        mstore(64, 0x0000001e4c454e4754485f475245415445525f5448414e5f335f524551554952)\r\n                        mstore(96, 0x4544000000000000000000000000000000000000000000000000000000000000)\r\n                        revert(0, 100)\r\n                    }\r\n\r\n                    // Load AssetProxy id\r\n                    let currentAssetProxyId := and(\r\n                        calldataload(nestedAssetDataElementContentsStart),\r\n                        0xffffffff00000000000000000000000000000000000000000000000000000000\r\n                    )\r\n\r\n                    // Only load `assetProxy` if `currentAssetProxyId` does not equal `assetProxyId`\r\n                    // We do not need to check if `currentAssetProxyId` is 0 since `assetProxy` is also initialized to 0\r\n                    if iszero(eq(currentAssetProxyId, assetProxyId)) {\r\n                        // Update `assetProxyId`\r\n                        assetProxyId := currentAssetProxyId\r\n                        // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\r\n                        // where k is the key left padded to 32 bytes and p is the storage slot\r\n                        mstore(132, assetProxyId)\r\n                        mstore(164, assetProxies_slot)\r\n                        assetProxy := sload(keccak256(132, 64))\r\n                    }\r\n                    \r\n                    // Revert if AssetProxy with given id does not exist\r\n                    if iszero(assetProxy) {\r\n                        // Revert with `Error(\"ASSET_PROXY_DOES_NOT_EXIST\")`\r\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                        mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\r\n                        mstore(64, 0x0000001a41535345545f50524f58595f444f45535f4e4f545f45584953540000)\r\n                        mstore(96, 0)\r\n                        revert(0, 100)\r\n                    }\r\n    \r\n                    // Copy `nestedAssetData[i]` from calldata to memory\r\n                    calldatacopy(\r\n                        132,                                // memory slot after `amounts[i]`\r\n                        nestedAssetDataElementLenStart,     // location of `nestedAssetData[i]` in calldata\r\n                        add(nestedAssetDataElementLen, 32)  // `nestedAssetData[i].length` plus 32 byte length\r\n                    )\r\n\r\n                    // call `assetProxy.transferFrom`\r\n                    let success := call(\r\n                        gas,                                    // forward all gas\r\n                        assetProxy,                             // call address of asset proxy\r\n                        0,                                      // don't send any ETH\r\n                        0,                                      // pointer to start of input\r\n                        add(164, nestedAssetDataElementLen),    // length of input  \r\n                        0,                                      // write output over memory that won't be reused\r\n                        0                                       // don't copy output to memory\r\n                    )\r\n\r\n                    // Revert with reason given by AssetProxy if `transferFrom` call failed\r\n                    if iszero(success) {\r\n                        returndatacopy(\r\n                            0,                // copy to memory at 0\r\n                            0,                // copy from return data at 0\r\n                            returndatasize()  // copy all return data\r\n                        )\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n\r\n                // Return if no `transferFrom` calls reverted\r\n                return(0, 0)\r\n            }\r\n\r\n            // Revert if undefined function is called\r\n            revert(0, 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Gets the proxy id associated with the proxy address.\r\n    /// @return Proxy id.\r\n    function getProxyId()\r\n        external\r\n        pure\r\n        returns (bytes4)\r\n    {\r\n        return PROXY_ID;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"assetProxies\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"addAuthorizedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorities\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetProxyId\",\"type\":\"bytes4\"}],\"name\":\"getAssetProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"removeAuthorizedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeAuthorizedAddressAtIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProxyId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetProxy\",\"type\":\"address\"}],\"name\":\"registerAssetProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthorizedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"AuthorizedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"AuthorizedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"assetProxy\",\"type\":\"address\"}],\"name\":\"AssetProxyRegistered\",\"type\":\"event\"}]","ContractName":"MultiAssetProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://64bd3a11cef3eb2456c9d4165ff6e5b96485cfb8604dcb2f357b728141643c10"}]}