{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface ERC721 /* is ERC165 */ {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n  function ownerOf(uint256 _tokenId) external view returns (address);\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n  function approve(address _approved, uint256 _tokenId) external payable;\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n  function getApproved(uint256 _tokenId) external view returns (address);\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath32\r\n * @dev SafeMath library implemented for uint32\r\n */\r\nlibrary SafeMath32 {\r\n\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath16\r\n * @dev SafeMath library implemented for uint16\r\n */\r\nlibrary SafeMath16 {\r\n\r\n  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint16 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint16 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    uint16 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owner {\r\n\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev set the owner of contract\r\n   */\r\n  constructor() public {\r\n      owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev only the owner\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * @title GreedyCoin\r\n */\r\ncontract GreedyCoin is Owner,ERC721 {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  // total supply\r\n  uint16  constant ISSUE_MAX = 2100;\r\n\r\n  // init price\r\n  uint256 constant START_PRICE = 0.1 ether;\r\n\r\n  // min price\r\n  uint256 constant PRICE_MIN = 0.000000000000000001 ether;\r\n\r\n  // max price\r\n  uint256 constant PRICE_LIMIT = 100000000 ether;\r\n\r\n  // percent of fee\r\n  uint256 constant PROCEDURE_FEE_PERCENT = 10;\r\n\r\n  // GreedyCoin token\r\n  struct TokenGDC{\r\n    bytes32 token_hash;\r\n    uint256 last_deal_time;\r\n    uint256 buying_price;\r\n    uint256 price;\r\n  }\r\n\r\n  /**\r\n   * @dev token structure\r\n  */\r\n  TokenGDC[] stTokens;\r\n\r\n  /**\r\n   * @dev owner of tokens ( index => address )\r\n  */\r\n  mapping (uint256 => address) stTokenIndexToOwner;\r\n\r\n  /**\r\n   * @dev GreedyCoin count of one address\r\n  */\r\n  mapping (address => uint256) stOwnerTokenCount;\r\n\r\n  /**\r\n   * @dev set transfer token permission\r\n  */\r\n  mapping (uint256 => address) stTokenApprovals;\r\n\r\n  /**\r\n  * @dev set approved address\r\n  */\r\n  mapping (address => mapping (address => bool) ) stApprovalForAll;\r\n\r\n\r\n  /*\r\n   * @dev (ERC721)\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256 balance){\r\n    balance = stOwnerTokenCount[owner];\r\n  }\r\n  \r\n  /**\r\n   * @dev query the owner of one GreedyCoin\r\n   */\r\n  function ownerOf(uint256 token_id) external view returns (address owner){\r\n    owner = stTokenIndexToOwner[token_id];\r\n  }\r\n\r\n  /**\r\n   * @dev transfer from\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n    require(msg.sender == _from);\r\n    require(_to != address(0));\r\n    require(_tokenId >= 0 && _tokenId < ISSUE_MAX - 1);\r\n    _transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev approve before transfer\r\n   */\r\n  function approve(address to, uint256 token_id) external payable {\r\n    require(msg.sender == stTokenIndexToOwner[token_id]);\r\n    stTokenApprovals[token_id] = to;\r\n    emit Approval(msg.sender, to, token_id);\r\n  }\r\n\r\n  /**\r\n   * @dev get approve\r\n   */\r\n  function getApproved(uint256 _tokenId) external view returns (address){\r\n    return stTokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev setApprovalForAll\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved) external {\r\n    stApprovalForAll[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev isApprovedForAll\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n    return stApprovalForAll[_owner][_operator] == true;\r\n  }\r\n\r\n  /**\r\n   * @dev _transfer\r\n   */\r\n  function _transfer(address from, address to, uint256 token_id) private {\r\n    require(stTokenApprovals[token_id] == to || stApprovalForAll[from][to]);\r\n    stOwnerTokenCount[to] = stOwnerTokenCount[to].add(1);\r\n    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].sub(1);\r\n    stTokenIndexToOwner[token_id] = to;\r\n    emit Transfer(from, to, token_id);\r\n  }\r\n\r\n  /**\r\n   * @dev query detail of one GreedyCoin\r\n   */\r\n  function queryToken(uint256 _tokenId) external view returns ( uint256 price, uint256 last_deal_time ) {\r\n    TokenGDC memory token = stTokens[_tokenId];\r\n    price = token.price;\r\n    last_deal_time = token.last_deal_time;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev get all GreedyCoins of msg.sender\r\n   */\r\n  function getMyTokens() external view returns ( uint256[] arr_token_id, uint256[] arr_last_deal_time, uint256[] buying_price_arr, uint256[] price_arr ){\r\n\r\n    TokenGDC memory token;\r\n\r\n    uint256 count = stOwnerTokenCount[msg.sender];\r\n    arr_last_deal_time = new uint256[](count);\r\n    buying_price_arr = new uint256[](count);\r\n    price_arr = new uint256[](count);\r\n    arr_token_id = new uint256[](count);\r\n\r\n    uint256 index = 0;\r\n    for ( uint i = 0; i < stTokens.length; i++ ){\r\n      if ( stTokenIndexToOwner[i] == msg.sender ) {\r\n        token = stTokens[i];\r\n        arr_last_deal_time[index] = token.last_deal_time;\r\n        buying_price_arr[index] = token.buying_price;\r\n        price_arr[index] = token.price;\r\n        arr_token_id[index] = i;\r\n        index = index + 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ncontract Market is GreedyCoin {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  event Bought (address indexed purchaser,uint256 indexed token_price, uint256 indexed next_price);\r\n  event HitFunds (address indexed purchaser,uint256 indexed funds, uint256 indexed hit_time);\r\n  event Recommended (address indexed recommender, uint256 indexed agency_fee);\r\n\r\n  // buy (only accept normal address)\r\n  function buy(uint256 next_price, bool is_recommend, uint256 recommend_token_id) external payable mustCommonAddress {\r\n\r\n    require (next_price >= PRICE_MIN && next_price <= PRICE_LIMIT);\r\n\r\n    _checkRecommend(is_recommend,recommend_token_id);\r\n    if (stTokens.length < ISSUE_MAX ){\r\n      _buyAndCreateToken(next_price,is_recommend,recommend_token_id);\r\n    } else {\r\n      _buyFromMarket(next_price,is_recommend,recommend_token_id);\r\n    }\r\n  }\r\n\r\n  // query current blance of fees\r\n  function queryCurrentContractFunds() external view returns (uint256) {\r\n    return (address)(this).balance;\r\n  }\r\n\r\n  // query the lowest price\r\n  function queryCurrentTradablePrice() external view returns (uint256 token_id,uint256 price) {\r\n    if (stTokens.length < ISSUE_MAX){\r\n      token_id = stTokens.length;\r\n      price = START_PRICE;\r\n    } else {\r\n      token_id = _getCurrentTradableToken();\r\n      price = stTokens[token_id].price;\r\n    }\r\n  }\r\n\r\n  // get the cheapest GreedyCoin\r\n  function _getCurrentTradableToken() private view returns(uint256 token_id) {\r\n    uint256 token_count = stTokens.length;\r\n    uint256 min_price = stTokens[0].price;\r\n    token_id = 0;\r\n    for ( uint i = 0; i < token_count; i++ ){\r\n      // token = stTokens[i];\r\n      uint256 price = stTokens[i].price;\r\n      if (price < min_price) {\r\n        // token = stTokens[i];\r\n        min_price = price;\r\n        token_id = i;\r\n      }\r\n    }\r\n  }\r\n\r\n  // create GreedyCoin\r\n  function _buyAndCreateToken(uint256 next_price, bool is_recommend, uint256 recommend_token_id ) private {\r\n\r\n    require( msg.value >= START_PRICE );\r\n\r\n    // create\r\n    uint256 now_time = now;\r\n    uint256 token_id = stTokens.length;\r\n    TokenGDC memory token;\r\n    token = TokenGDC({\r\n      token_hash: keccak256(abi.encodePacked((address)(this), token_id)),\r\n      last_deal_time: now_time,\r\n      buying_price: START_PRICE,\r\n      price: next_price\r\n    });\r\n    stTokens.push(token);\r\n\r\n    stTokenIndexToOwner[token_id] = msg.sender;\r\n    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].add(1);\r\n\r\n    // 10% fee\r\n    uint256 current_fund = START_PRICE.div(100 / PROCEDURE_FEE_PERCENT);\r\n\r\n    // hash of GreedyCoin\r\n    bytes32 current_token_hash = token.token_hash;\r\n\r\n    owner.transfer( START_PRICE - current_fund );\r\n\r\n    // if get all fees\r\n    _gambling(current_fund, current_token_hash, now_time);\r\n\r\n    // recommendation\r\n    _awardForRecommender(is_recommend, recommend_token_id, current_fund);\r\n\r\n    _refund(msg.value - START_PRICE);\r\n\r\n    // emit event\r\n    emit Bought(msg.sender, START_PRICE, next_price);\r\n\r\n  }\r\n\r\n// buy GreedyCoin from each other,after all GreedyCoins has been created\r\n  function _buyFromMarket(uint256 next_price, bool is_recommend, uint256 recommend_token_id ) private {\r\n\r\n    uint256 current_tradable_token_id = _getCurrentTradableToken();\r\n    TokenGDC storage token = stTokens[current_tradable_token_id];\r\n\r\n    uint256 current_token_price = token.price;\r\n\r\n    bytes32 current_token_hash = token.token_hash;\r\n\r\n    uint256 last_deal_time = token.last_deal_time;\r\n\r\n    require( msg.value >= current_token_price );\r\n\r\n    uint256 refund_amount = msg.value - current_token_price;\r\n\r\n    token.price = next_price;\r\n\r\n    token.buying_price = current_token_price;\r\n\r\n    token.last_deal_time = now;\r\n\r\n    address origin_owner = stTokenIndexToOwner[current_tradable_token_id];\r\n\r\n    stOwnerTokenCount[origin_owner] =  stOwnerTokenCount[origin_owner].sub(1);\r\n\r\n    stOwnerTokenCount[msg.sender] = stOwnerTokenCount[msg.sender].add(1);\r\n\r\n    stTokenIndexToOwner[current_tradable_token_id] = msg.sender;\r\n\r\n    uint256 current_fund = current_token_price.div(100 / PROCEDURE_FEE_PERCENT);\r\n\r\n    origin_owner.transfer( current_token_price - current_fund );\r\n\r\n    _gambling(current_fund, current_token_hash, last_deal_time);\r\n\r\n    _awardForRecommender(is_recommend, recommend_token_id, current_fund);\r\n\r\n    _refund(refund_amount);\r\n\r\n    emit Bought(msg.sender, current_token_price, next_price);\r\n  }\r\n\r\n  function _awardForRecommender(bool is_recommend, uint256 recommend_token_id, uint256 current_fund) private {\r\n\r\n    if ( is_recommend && stTokens.length >= recommend_token_id) {\r\n\r\n      address recommender = stTokenIndexToOwner[recommend_token_id];\r\n\r\n      // 50% of fee\r\n      uint256 agency_fee = current_fund.div(2);\r\n\r\n      recommender.transfer(agency_fee);\r\n\r\n      emit Recommended(recommender,agency_fee);\r\n    }\r\n  }\r\n\r\n  function _refund(uint256 refund_amount) private {\r\n    if ( refund_amount > 0 ) {\r\n      msg.sender.transfer(refund_amount);\r\n    }\r\n  }\r\n\r\n  // 10% change of getting all blance of fees\r\n  function _gambling(uint256 current_fund, bytes32 current_token_hash, uint256 last_deal_time) private {\r\n\r\n    // random 0 - 99\r\n    uint256 random_number = _createRandomNumber(current_token_hash,last_deal_time);\r\n\r\n    if ( random_number < 10 ) {\r\n\r\n      // contract address\r\n      address contract_address = (address)(this);\r\n\r\n      uint256 hit_funds = contract_address.balance.sub(current_fund);\r\n\r\n      msg.sender.transfer(hit_funds);\r\n\r\n      emit HitFunds(msg.sender, hit_funds, now);\r\n    }\r\n  }\r\n\r\n  function _createRandomNumber(bytes32 current_token_hash, uint256 last_deal_time) private pure returns (uint256) {\r\n    return (uint256)(keccak256(abi.encodePacked(current_token_hash, last_deal_time))) % 100;\r\n  }\r\n\r\n  function _checkRecommend(bool is_recommend, uint256 recommend_token_id) private view {\r\n    if ( is_recommend ) {\r\n      if ( stTokens.length > 0 ) {\r\n        require(recommend_token_id >= 0 && recommend_token_id < stTokens.length);\r\n      } \r\n    }\r\n  }\r\n\r\n  modifier aboveMinNextPrice(uint next_price) { \r\n    require (next_price >= PRICE_MIN && next_price <= PRICE_LIMIT);\r\n    _;\r\n  }\r\n\r\n  // must be a normal address\r\n  modifier mustCommonAddress() { \r\n    require (_isContract(msg.sender) == false);\r\n    _; \r\n  }\r\n\r\n  // check if it is the address of contract\r\n  function _isContract(address addr) private view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryCurrentTradablePrice\",\"outputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"next_price\",\"type\":\"uint256\"},{\"name\":\"is_recommend\",\"type\":\"bool\"},{\"name\":\"recommend_token_id\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyTokens\",\"outputs\":[{\"name\":\"arr_token_id\",\"type\":\"uint256[]\"},{\"name\":\"arr_last_deal_time\",\"type\":\"uint256[]\"},{\"name\":\"buying_price_arr\",\"type\":\"uint256[]\"},{\"name\":\"price_arr\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryCurrentContractFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"queryToken\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"last_deal_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token_price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"next_price\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"hit_time\",\"type\":\"uint256\"}],\"name\":\"HitFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recommender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"agency_fee\",\"type\":\"uint256\"}],\"name\":\"Recommended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"Market","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b62ab98943e9d20c47ef63e2e063a67d68b210f1bda632e6784f8dd94f7209d6"}]}