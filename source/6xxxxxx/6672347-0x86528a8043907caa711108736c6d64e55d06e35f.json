{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n * CONTRACT FOR EtherGold.Me\r\n * \r\n * What's is EtherGold\r\n *  - 1% advertisement and PR expenses FEE\r\n *  - You can refund anytime\r\n *  - GAIN 2% ~ 3% (up on your deposited value) PER 24 HOURS (every 5900 blocks)\r\n *  - 0 ~ 1 ether     2% \r\n *  - 1 ~ 10 ether    2.5%\r\n *  - over 10 ether   3% \r\n * \r\n * Multi-level Referral Bonus\r\n *  - 5% for Direct \r\n *  - 3% for Second Level\r\n *  - 1% for Third Level\r\n * \r\n * How to use:\r\n *  1. Send any amount of ether to make an investment\r\n *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're spending too much on GAS)\r\n *  OR\r\n *  2b. Send more ether to reinvest AND get your profit at the same time\r\n *  OR\r\n *  2c. view on website: https://EtherGold.Me\r\n * \r\n * How to refund:\r\n *  - Send 0.002 ether to refund\r\n *  - 1% refund fee\r\n *  - refundValue = (depositedValue - withdrewValue - refundFee) * 99%\r\n *  \r\n *\r\n * RECOMMENDED GAS LIMIT: 70000\r\n * RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n *\r\n * Contract reviewed and approved by pros!\r\n**/\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_b <= _a);\r\n        return _a - _b;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n        c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function toAddress(bytes bys) internal pure returns (address addr) {\r\n        assembly { addr := mload(add(bys, 20)) }\r\n        return addr;\r\n    }\r\n}\r\n\r\ncontract EthGold {\r\n    using SafeMath for uint256;\r\n    using Address for *;\r\n    address private devAddr;\r\n    address private depositedLock;\r\n    \r\n    struct Investor {\r\n        uint256 deposited;\r\n        uint256 withdrew;\r\n        address referrer;\r\n        uint256 m_1_refCount;\r\n        uint256 m_1_refValue;\r\n        uint256 m_2_refCount;\r\n        uint256 m_2_refValue;\r\n        uint256 m_3_refCount;\r\n        uint256 m_3_refValue;\r\n        uint256 blockNumber;\r\n        uint256 wallet;\r\n    }\r\n    \r\n    mapping (address => Investor) private investors;\r\n    uint256 public totalDepositedWei = 0;\r\n    uint256 public totalWithdrewWei = 0;\r\n    \r\n    constructor() public {\r\n        devAddr = msg.sender;\r\n        depositedLock = msg.sender;\r\n    }\r\n\r\n    function getUserDeposited(address _address) public view returns(uint256) {\r\n        return investors[_address].deposited;\r\n    }\r\n    \r\n    function getUserWithdrew(address _address) public view returns(uint256) {\r\n        return investors[_address].withdrew;\r\n    }\r\n    \r\n    function userDividendsWei(address _address) public view returns (uint256) {\r\n        uint256 userDeposited = investors[_address].deposited;\r\n        \r\n        // 0-1 ETH can dividend 2% every days;\r\n        if ( userDeposited > 0 ether && userDeposited <= 1 ether) {\r\n            return userDeposited.mul(2).div(100).mul(block.number-investors[_address].blockNumber).div(5900);\r\n        }\r\n        \r\n        // 1-10 ETH can dividend 2.5% every days;\r\n        if ( userDeposited > 1 ether && userDeposited <= 10 ether) {\r\n            return userDeposited.mul(5).div(200).mul(block.number-investors[_address].blockNumber).div(5900);\r\n        }\r\n        \r\n        // more than 10 ETH can dividend 3% every days;\r\n        if ( userDeposited > 10 ether ) {\r\n            return userDeposited.mul(3).div(100).mul(block.number-investors[_address].blockNumber).div(5900);\r\n        }\r\n\t\t\r\n    }\r\n    \r\n    function() public payable {\r\n        if ( msg.value == 0 ) {\r\n            withdraw();\r\n        } else if ( msg.value == 0.002 ether) {\r\n            refund(msg.sender);\r\n        } else {\r\n            doInvest(msg.data.toAddress(), msg.value);    \r\n        }\r\n    }\r\n    \r\n    function getBalance() public view returns(uint256){\r\n        return address(this).balance;\r\n    }\r\n    \r\n    function getUserInfo(address _addr) public view returns(uint256 deposited, \r\n            uint256 withdrew,\r\n            address referrer,\r\n            uint256 m_1_refCount,\r\n            uint256 m_1_refValue,\r\n            uint256 m_2_refCount,\r\n            uint256 m_2_refValue,\r\n            uint256 m_3_refCount,\r\n            uint256 m_3_refValue,\r\n            uint256 wallet) {\r\n        deposited = investors[_addr].deposited;\r\n        withdrew = investors[_addr].withdrew;\r\n        referrer = investors[_addr].referrer;\r\n        m_1_refCount = investors[_addr].m_1_refCount;\r\n        m_1_refValue = investors[_addr].m_1_refValue;\r\n        m_2_refCount = investors[_addr].m_2_refCount;\r\n        m_2_refValue = investors[_addr].m_2_refValue;\r\n        m_3_refCount = investors[_addr].m_3_refCount;\r\n        m_3_refValue = investors[_addr].m_3_refValue;\r\n        wallet = investors[_addr].wallet;\r\n    }\r\n    \r\n    function transferMoney(address _address, uint256 _value) private {\r\n        uint256 contractBalance = getBalance();\r\n        if (contractBalance < _value) {\r\n            _address.transfer(contractBalance);    \r\n        } else {\r\n            _address.transfer(_value);    \r\n        }\r\n    }\r\n    \r\n    function withdraw() public {\r\n        if (investors[msg.sender].deposited != 0 && block.number > investors[msg.sender].blockNumber) {\r\n            uint256 depositsPercents = investors[msg.sender].deposited.mul(2).div(100).mul(block.number-investors[msg.sender].blockNumber).div(5900);\r\n            uint256 walletAmount = investors[msg.sender].wallet;\r\n            transferMoney(msg.sender, depositsPercents + walletAmount);\r\n            investors[msg.sender].wallet = 0;\r\n            investors[msg.sender].withdrew += (depositsPercents + walletAmount);\r\n            totalWithdrewWei = totalWithdrewWei.add(depositsPercents + walletAmount);\r\n        }\r\n    }\r\n    \r\n    function doInvest(address referrer, uint256 value) internal {\r\n        // 1% for dev fee.\r\n        investors[devAddr].wallet += value.mul(1).div(100); \r\n        if (referrer > 0x0 && referrer != msg.sender && investors[msg.sender].referrer == 0x0){\r\n            investors[msg.sender].referrer = referrer;\r\n        }\r\n        \r\n        uint256 m1ref;\r\n        uint256 m2ref;\r\n        uint256 m3ref;\r\n        address m1refAddr = investors[msg.sender].referrer;\r\n        address m2refAddr = investors[m1refAddr].referrer;\r\n        address m3refAddr = investors[m2refAddr].referrer;\r\n        \r\n        // m1\r\n        if ( m1refAddr > 0x0 ) {\r\n            \r\n            uint256 m1refDeposited = investors[m1refAddr].deposited;\r\n            \r\n            if ( m1refDeposited > value ) {\r\n                m1ref = value.mul(5).div(100);\r\n            } else {\r\n                m1ref = m1refDeposited.mul(5).div(100);\r\n            }\r\n            \r\n            investors[m1refAddr].wallet += m1ref;\r\n            investors[m1refAddr].m_1_refCount += 1;\r\n            investors[m1refAddr].m_1_refValue += m1ref;\r\n            \r\n            // m2\r\n            if( m2refAddr > 0x0 && m2refAddr != msg.sender && m2refAddr != m1refAddr){\r\n                \r\n                uint256 m2refDeposited = investors[m2refAddr].deposited;\r\n                \r\n                if ( m2refDeposited > value ) {\r\n                    m2ref = value.mul(3).div(100);\r\n                } else {\r\n                    m2ref = m2refDeposited.mul(3).div(100);\r\n                }\r\n                \r\n                investors[m2refAddr].wallet += m2ref;\r\n                investors[m2refAddr].m_2_refValue += m2ref;\r\n                investors[m2refAddr].m_2_refCount += 1;\r\n                \r\n                // m3\r\n                if( m3refAddr > 0x0 && m3refAddr != msg.sender && m3refAddr != m1refAddr && m3refAddr != m2refAddr){\r\n                    \r\n                    uint256 m3refDeposited = investors[m3refAddr].deposited;\r\n                    \r\n                    if ( m3refDeposited > value ) {\r\n                        m3ref = value.mul(3).div(100);\r\n                    } else {\r\n                        m3ref = m3refDeposited.mul(3).div(100);\r\n                    }\r\n                    \r\n                    investors[m3refAddr].wallet += m3ref;\r\n                    investors[m3refAddr].m_3_refValue += m3ref;\r\n                    investors[m3refAddr].m_3_refCount += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        investors[msg.sender].deposited += value;\r\n        investors[msg.sender].blockNumber = block.number;\r\n        totalDepositedWei = totalDepositedWei.add(value);\r\n    }\r\n    \r\n    function reIvest() public {\r\n        uint256 wallet = investors[msg.sender].wallet;\r\n        uint256 dividends = userDividendsWei(msg.sender);\r\n        uint256 reinvestment = wallet + dividends;\r\n        investors[msg.sender].wallet = 0;\r\n        investors[msg.sender].blockNumber = block.number;\r\n        investors[msg.sender].withdrew += reinvestment;\r\n        totalWithdrewWei += reinvestment;\r\n        doInvest(investors[msg.sender].referrer, reinvestment);\r\n    }\r\n    \r\n    function newInvest(address referrer) payable public{\r\n        doInvest(referrer, msg.value);\r\n    }\r\n    \r\n    function refund(address _exitUser) internal {\r\n        uint256 refundValue = investors[_exitUser].deposited.mul(90).div(100);\r\n        \r\n        // refund need 1% fee.\r\n        if ( _exitUser != devAddr ) {\r\n            uint256 refundFee = refundValue.mul(1).div(100);\r\n            refundValue -= refundFee;\r\n            investors[devAddr].wallet += refundFee;\r\n            investors[depositedLock].wallet = totalDepositedWei - refundFee;   \r\n        }\r\n        refundValue -= investors[_exitUser].withdrew;\r\n        \r\n        transferMoney(_exitUser, refundValue);\r\n        totalDepositedWei -= refundValue;\r\n        investors[_exitUser].deposited = 0;\r\n        investors[_exitUser].withdrew = 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"userDividendsWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserWithdrew\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"newInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"name\":\"deposited\",\"type\":\"uint256\"},{\"name\":\"withdrew\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"m_1_refCount\",\"type\":\"uint256\"},{\"name\":\"m_1_refValue\",\"type\":\"uint256\"},{\"name\":\"m_2_refCount\",\"type\":\"uint256\"},{\"name\":\"m_2_refValue\",\"type\":\"uint256\"},{\"name\":\"m_3_refCount\",\"type\":\"uint256\"},{\"name\":\"m_3_refValue\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reIvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrewWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDepositedWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserDeposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"EthGold","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5fc98ee600d60af65e317a91123da2e3667ba187cb2fe318bec02feae60573a4"}]}