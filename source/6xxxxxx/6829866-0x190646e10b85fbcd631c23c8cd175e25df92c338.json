{"status":"1","message":"OK","result":[{"SourceCode":"// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract EthBattle is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant TOKEN_USE_BONUS = 15; //%, adds weight of win on top of the market price\r\n    uint256 constant REFERRAL_REWARD = 2 ether; // GTA, 10*19\r\n    uint256 constant MIN_PLAY_AMOUNT = 50 finney; //wei, equal 0.05 ETH\r\n\r\n    uint256 public roundIndex = 0;\r\n    mapping(uint256 => address) public rounds;\r\n\r\n    address[] private currentRewardingAddresses;\r\n\r\n    PlaySeedInterface private playSeedGenerator;\r\n    GTAInterface public token;\r\n    AMUStoreInterface public store;\r\n\r\n    mapping(address => address) public referralBacklog; //backlog of players and their referrals\r\n\r\n    mapping(address => uint256) public tokens; //map of deposited tokens\r\n\r\n    event RoundCreated(address createdAddress, uint256 index);\r\n    event Deposit(address user, uint amount, uint balance);\r\n    event Withdraw(address user, uint amount, uint balance);\r\n\r\n    /**\r\n    * @dev Default fallback function, just deposits funds to the pot\r\n    */\r\n    function () public payable {\r\n        getLastRound().getDevWallet().transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n    * @dev The EthBattle constructor\r\n    * @param _playSeedAddress address of the play seed generator\r\n    * @param _tokenAddress GTA address\r\n    * @param _storeAddress store contract address\r\n    */\r\n    constructor (address _playSeedAddress, address _tokenAddress, address _storeAddress) public {\r\n        playSeedGenerator = PlaySeedInterface(_playSeedAddress);\r\n        token = GTAInterface(_tokenAddress);\r\n        store = AMUStoreInterface(_storeAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Try (must be allowed by the seed generator itself) to claim ownership of the seed generator\r\n    */\r\n    function claimSeedOwnership() onlyOwner public {\r\n        playSeedGenerator.claimOwnership();\r\n    }\r\n\r\n    /**\r\n    * @dev Inject the new round contract, and sets the round with a new index\r\n    * NOTE! Injected round must have had transferred ownership to this EthBattle already\r\n    * @param _roundAddress address of the new round to use\r\n    */\r\n    function startRound(address _roundAddress) onlyOwner public {\r\n        RoundInterface round = RoundInterface(_roundAddress);\r\n\r\n        round.claimOwnership();\r\n\r\n        roundIndex++;\r\n        rounds[roundIndex] = round;\r\n        emit RoundCreated(round, roundIndex);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Interrupts the round to enable participants to claim funds back\r\n    */\r\n    function interruptLastRound() onlyOwner public {\r\n        getLastRound().enableRefunds();\r\n    }\r\n\r\n    /**\r\n    * @dev End last round so no new plays is possible, but ongoing plays are fine to win\r\n    */\r\n    function finishLastRound() onlyOwner public {\r\n        getLastRound().coolDown();\r\n    }\r\n\r\n    function getLastRound() public view returns (RoundInterface){\r\n        return RoundInterface(rounds[roundIndex]);\r\n    }\r\n\r\n    function getLastRoundAddress() external view returns (address){\r\n        return rounds[roundIndex];\r\n    }\r\n\r\n    /**\r\n    * @dev Player starts a new play providing\r\n    * @param _referral (Optional) referral address is any\r\n    * @param _gtaBet (Optional) additional bet in GTA\r\n    */\r\n    function play(address _referral, uint256 _gtaBet) public payable {\r\n        address player = msg.sender;\r\n        uint256 weiAmount = msg.value;\r\n\r\n        require(player != address(0), \"Player's address is missing\");\r\n        require(weiAmount >= MIN_PLAY_AMOUNT, \"The bet is too low\");\r\n        require(_gtaBet <= balanceOf(player), \"Player's got not enough GTA\");\r\n\r\n        if (_referral != address(0) && referralBacklog[player] == address(0)) {\r\n            //new referral for this player\r\n            referralBacklog[player] = _referral;\r\n            //reward the referral. Tokens remains in this contract\r\n            //but become available for withdrawal by _referral\r\n            transferInternally(owner, _referral, REFERRAL_REWARD);\r\n        }\r\n\r\n        playSeedGenerator.newPlaySeed(player);\r\n\r\n        uint256 _bet = aggregateBet(weiAmount, _gtaBet);\r\n\r\n        if (_gtaBet > 0) {\r\n            //player's using GTA\r\n            transferInternally(player, owner, _gtaBet);\r\n        }\r\n\r\n        if (referralBacklog[player] != address(0)) {\r\n            //ongoing round might not know about the _referral\r\n            //delegate the knowledge of the referral to the ongoing round\r\n            getLastRound().setReferral(player, referralBacklog[player]);\r\n        }\r\n        getLastRound().playRound.value(msg.value)(player, _bet);\r\n    }\r\n\r\n    /**\r\n    * @dev Player claims a win\r\n    * @param _seed secret seed\r\n    */\r\n    function win(bytes32 _seed) public {\r\n        address player = msg.sender;\r\n\r\n        require(player != address(0), \"Winner's address is missing\");\r\n        require(playSeedGenerator.findSeed(player) == _seed, \"Wrong seed!\");\r\n        playSeedGenerator.cleanSeedUp(player);\r\n\r\n        getLastRound().win(player);\r\n    }\r\n\r\n    function findSeedAuthorized(address player) onlyOwner public view returns (bytes32){\r\n        return playSeedGenerator.findSeed(player);\r\n    }\r\n\r\n    function aggregateBet(uint256 _bet, uint256 _gtaBet) internal view returns (uint256) {\r\n        //get market price of the GTA, multiply by bet, and apply a bonus on it.\r\n        //since both 'price' and 'bet' are in 'wei', we need to drop 10*18 decimals at the end\r\n        uint256 _gtaValueWei = store.getTokenBuyPrice().mul(_gtaBet).div(1 ether).mul(100 + TOKEN_USE_BONUS).div(100);\r\n\r\n        //sum up with ETH bet\r\n        uint256 _resultBet = _bet.add(_gtaValueWei);\r\n\r\n        return _resultBet;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the prize amount for this player by now\r\n    * Note: the result is not the final one and a subject to change once more plays/wins occur\r\n    * @return The prize in wei\r\n    */\r\n    function prizeByNow() public view returns (uint256) {\r\n        return getLastRound().currentPrize(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the prediction on the prize amount for this player and this bet\r\n    * Note: the result is not the final one and a subject to change once more plays/wins occur\r\n    * @param _bet hypothetical bet in wei\r\n    * @param _gtaBet hypothetical bet in GTA\r\n    * @return The prediction in wei\r\n    */\r\n    function prizeProjection(uint256 _bet, uint256 _gtaBet) public view returns (uint256) {\r\n        return getLastRound().projectedPrizeForPlayer(msg.sender, aggregateBet(_bet, _gtaBet));\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Deposit GTA to the EthBattle contract so it can be spent (used) immediately\r\n    * Note: this call must follow the approve() call on the token itself\r\n    * @param _amount amount to deposit\r\n    */\r\n    function depositGTA(uint256 _amount) public {\r\n        require(token.transferFrom(msg.sender, this, _amount), \"Insufficient funds\");\r\n        tokens[msg.sender] = tokens[msg.sender].add(_amount);\r\n        emit Deposit(msg.sender, _amount, tokens[msg.sender]);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw GTA from this contract to the own (caller) address\r\n    * @param _amount amount to withdraw\r\n    */\r\n    function withdrawGTA(uint256 _amount) public {\r\n        require(tokens[msg.sender] >= _amount, \"Amount exceeds the available balance\");\r\n        tokens[msg.sender] = tokens[msg.sender].sub(_amount);\r\n        require(token.transfer(msg.sender, _amount), \"Amount exceeds the available balance\");\r\n        emit Withdraw(msg.sender, _amount, tokens[msg.sender]);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal transfer of the token.\r\n    * Funds remain in this contract but become available for withdrawal\r\n    */\r\n    function transferInternally(address _from, address _to, uint256 _amount) internal {\r\n        require(tokens[_from] >= _amount, \"Too much to transfer\");\r\n        tokens[_from] = tokens[_from].sub(_amount);\r\n        tokens[_to] = tokens[_to].add(_amount);\r\n    }\r\n\r\n    function balanceOf(address _user) public view returns (uint256) {\r\n        return tokens[_user];\r\n    }\r\n\r\n    function setPlaySeed(address _playSeedAddress) onlyOwner public {\r\n        playSeedGenerator = PlaySeedInterface(_playSeedAddress);\r\n    }\r\n\r\n    function setStore(address _storeAddress) onlyOwner public {\r\n        store = AMUStoreInterface(_storeAddress);\r\n    }\r\n\r\n    function getTokenBuyPrice() public view returns (uint256) {\r\n        return store.getTokenBuyPrice();\r\n    }\r\n\r\n    function getTokenSellPrice() public view returns (uint256) {\r\n        return store.getTokenSellPrice();\r\n    }\r\n\r\n    /**\r\n    * @dev Recover the history of referrals in case of the contract migration.\r\n    */\r\n    function setReferralsMap(address[] _players, address[] _referrals) onlyOwner public {\r\n        require(_players.length == _referrals.length, \"Size of players must be equal to the size of referrals\");\r\n        for (uint i = 0; i < _players.length; ++i) {\r\n            referralBacklog[_players[i]] = _referrals[i];\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title PlaySeed contract interface\r\n */\r\ninterface PlaySeedInterface {\r\n\r\n    function newPlaySeed(address _player) external;\r\n\r\n    function findSeed(address _player) external view returns (bytes32);\r\n\r\n    function cleanSeedUp(address _player) external;\r\n\r\n    function claimOwnership() external;\r\n\r\n}\r\n\r\n/**\r\n * @title GTA contract interface\r\n */\r\ninterface GTAInterface {\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n}\r\n\r\n/**\r\n * @title EthBattleRound contract interface\r\n */\r\ninterface RoundInterface {\r\n\r\n    function claimOwnership() external;\r\n\r\n    function setReferral(address _player, address _referral) external;\r\n\r\n    function playRound(address _player, uint256 _bet) external payable;\r\n\r\n    function enableRefunds() external;\r\n\r\n    function coolDown() external;\r\n\r\n    function currentPrize(address _player) external view returns (uint256);\r\n\r\n    function projectedPrizeForPlayer(address _player, uint256 _bet) external view returns (uint256);\r\n\r\n    function win(address _player) external;\r\n\r\n    function getDevWallet() external view returns (address);\r\n\r\n}\r\n\r\n/**\r\n * @title Ammu-Nation contract interface\r\n */\r\ninterface AMUStoreInterface {\r\n\r\n    function getTokenBuyPrice() external view returns (uint256);\r\n\r\n    function getTokenSellPrice() external view returns (uint256);\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_roundAddress\",\"type\":\"address\"}],\"name\":\"startRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimSeedOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_storeAddress\",\"type\":\"address\"}],\"name\":\"setStore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_players\",\"type\":\"address[]\"},{\"name\":\"_referrals\",\"type\":\"address[]\"}],\"name\":\"setReferralsMap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"interruptLastRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastRound\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeByNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawGTA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralBacklog\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seed\",\"type\":\"bytes32\"}],\"name\":\"win\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"store\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_playSeedAddress\",\"type\":\"address\"}],\"name\":\"setPlaySeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositGTA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bet\",\"type\":\"uint256\"},{\"name\":\"_gtaBet\",\"type\":\"uint256\"}],\"name\":\"prizeProjection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"findSeedAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishLastRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastRoundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referral\",\"type\":\"address\"},{\"name\":\"_gtaBet\",\"type\":\"uint256\"}],\"name\":\"play\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_playSeedAddress\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_storeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"createdAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthBattle","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005ddf6fc0bb34ef7785e162a52300bcf7ec67e6c9000000000000000000000000ef26c2766972cbac10575aa85c0ab0691b967d20000000000000000000000000b06590e0b9fe47ff9abad84919a3e40bd59b16d4","Library":"","SwarmSource":"bzzr://98e6251c88452fbc987df86d747fe4de966e598c4864b94e0854e61e1582d666"}]}