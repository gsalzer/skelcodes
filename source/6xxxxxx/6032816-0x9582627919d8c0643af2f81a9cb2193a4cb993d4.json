{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() constant public returns (uint);\r\n\r\n  function balanceOf(address who) constant public returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() public {owner = msg.sender;}\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\ncontract Callable is Owned {\r\n\r\n    //sender => _allowed\r\n    mapping(address => bool) public callers;\r\n\r\n    //modifiers\r\n    modifier onlyCaller {\r\n        require(callers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    //management of the repositories\r\n    function updateCaller(address _caller, bool allowed) public onlyOwner {\r\n        callers[_caller] = allowed;\r\n    }\r\n}\r\n\r\ncontract EternalStorage is Callable {\r\n\r\n    mapping(bytes32 => uint) uIntStorage;\r\n    mapping(bytes32 => string) stringStorage;\r\n    mapping(bytes32 => address) addressStorage;\r\n    mapping(bytes32 => bytes) bytesStorage;\r\n    mapping(bytes32 => bool) boolStorage;\r\n    mapping(bytes32 => int) intStorage;\r\n\r\n    // *** Getter Methods ***\r\n    function getUint(bytes32 _key) external view returns (uint) {\r\n        return uIntStorage[_key];\r\n    }\r\n\r\n    function getString(bytes32 _key) external view returns (string) {\r\n        return stringStorage[_key];\r\n    }\r\n\r\n    function getAddress(bytes32 _key) external view returns (address) {\r\n        return addressStorage[_key];\r\n    }\r\n\r\n    function getBytes(bytes32 _key) external view returns (bytes) {\r\n        return bytesStorage[_key];\r\n    }\r\n\r\n    function getBool(bytes32 _key) external view returns (bool) {\r\n        return boolStorage[_key];\r\n    }\r\n\r\n    function getInt(bytes32 _key) external view returns (int) {\r\n        return intStorage[_key];\r\n    }\r\n\r\n    // *** Setter Methods ***\r\n    function setUint(bytes32 _key, uint _value) onlyCaller external {\r\n        uIntStorage[_key] = _value;\r\n    }\r\n\r\n    function setString(bytes32 _key, string _value) onlyCaller external {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    function setAddress(bytes32 _key, address _value) onlyCaller external {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    function setBytes(bytes32 _key, bytes _value) onlyCaller external {\r\n        bytesStorage[_key] = _value;\r\n    }\r\n\r\n    function setBool(bytes32 _key, bool _value) onlyCaller external {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    function setInt(bytes32 _key, int _value) onlyCaller external {\r\n        intStorage[_key] = _value;\r\n    }\r\n\r\n    // *** Delete Methods ***\r\n    function deleteUint(bytes32 _key) onlyCaller external {\r\n        delete uIntStorage[_key];\r\n    }\r\n\r\n    function deleteString(bytes32 _key) onlyCaller external {\r\n        delete stringStorage[_key];\r\n    }\r\n\r\n    function deleteAddress(bytes32 _key) onlyCaller external {\r\n        delete addressStorage[_key];\r\n    }\r\n\r\n    function deleteBytes(bytes32 _key) onlyCaller external {\r\n        delete bytesStorage[_key];\r\n    }\r\n\r\n    function deleteBool(bytes32 _key) onlyCaller external {\r\n        delete boolStorage[_key];\r\n    }\r\n\r\n    function deleteInt(bytes32 _key) onlyCaller external {\r\n        delete intStorage[_key];\r\n    }\r\n}\r\n\r\n/*\r\n * Database Contract\r\n * Davy Van Roy\r\n * Quinten De Swaef\r\n */\r\ncontract FundRepository is Callable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    EternalStorage public db;\r\n\r\n    //platform -> platformId => _funding\r\n    mapping(bytes32 => mapping(string => Funding)) funds;\r\n\r\n    struct Funding {\r\n        address[] funders; //funders that funded tokens\r\n        address[] tokens; //tokens that were funded\r\n        mapping(address => TokenFunding) tokenFunding;\r\n    }\r\n\r\n    struct TokenFunding {\r\n        mapping(address => uint256) balance;\r\n        uint256 totalTokenBalance;\r\n    }\r\n\r\n    constructor(address _eternalStorage) public {\r\n        db = EternalStorage(_eternalStorage);\r\n    }\r\n\r\n    function updateFunders(address _from, bytes32 _platform, string _platformId) public onlyCaller {\r\n        bool existing = db.getBool(keccak256(abi.encodePacked(\"funds.userHasFunded\", _platform, _platformId, _from)));\r\n        if (!existing) {\r\n            uint funderCount = getFunderCount(_platform, _platformId);\r\n            db.setAddress(keccak256(abi.encodePacked(\"funds.funders.address\", _platform, _platformId, funderCount)), _from);\r\n            db.setUint(keccak256(abi.encodePacked(\"funds.funderCount\", _platform, _platformId)), funderCount.add(1));\r\n        }\r\n    }\r\n\r\n    function updateBalances(address _from, bytes32 _platform, string _platformId, address _token, uint256 _value) public onlyCaller {\r\n        if (db.getBool(keccak256(abi.encodePacked(\"funds.token.address\", _platform, _platformId, _token))) == false) {\r\n            db.setBool(keccak256(abi.encodePacked(\"funds.token.address\", _platform, _platformId, _token)), true);\r\n            //add to the list of tokens for this platformId\r\n            uint tokenCount = getFundedTokenCount(_platform, _platformId);\r\n            db.setAddress(keccak256(abi.encodePacked(\"funds.token.address\", _platform, _platformId, tokenCount)), _token);\r\n            db.setUint(keccak256(abi.encodePacked(\"funds.tokenCount\", _platform, _platformId)), tokenCount.add(1));\r\n        }\r\n\r\n        //add to the balance of this platformId for this token\r\n        db.setUint(keccak256(abi.encodePacked(\"funds.tokenBalance\", _platform, _platformId, _token)), balance(_platform, _platformId, _token).add(_value));\r\n\r\n        //add to the balance the user has funded for the request\r\n        db.setUint(keccak256(abi.encodePacked(\"funds.amountFundedByUser\", _platform, _platformId, _from, _token)), amountFunded(_platform, _platformId, _from, _token).add(_value));\r\n\r\n        //add the fact that the user has now funded this platformId\r\n        db.setBool(keccak256(abi.encodePacked(\"funds.userHasFunded\", _platform, _platformId, _from)), true);\r\n    }\r\n\r\n    function claimToken(bytes32 platform, string platformId, address _token) public onlyCaller returns (uint256) {\r\n        require(!issueResolved(platform, platformId), \"Can't claim token, issue is already resolved.\");\r\n        uint256 totalTokenBalance = balance(platform, platformId, _token);\r\n        db.deleteUint(keccak256(abi.encodePacked(\"funds.tokenBalance\", platform, platformId, _token)));\r\n        return totalTokenBalance;\r\n    }\r\n\r\n    function refundToken(bytes32 _platform, string _platformId, address _owner, address _token) public onlyCaller returns (uint256) {\r\n        require(!issueResolved(_platform, _platformId), \"Can't refund token, issue is already resolved.\");\r\n\r\n        //delete amount from user, so he can't refund again\r\n        uint256 userTokenBalance = amountFunded(_platform, _platformId, _owner, _token);\r\n        db.deleteUint(keccak256(abi.encodePacked(\"funds.amountFundedByUser\", _platform, _platformId, _owner, _token)));\r\n\r\n\r\n        uint256 oldBalance = balance(_platform, _platformId, _token);\r\n        uint256 newBalance = oldBalance.sub(userTokenBalance);\r\n\r\n        require(newBalance <= oldBalance);\r\n\r\n        //subtract amount from tokenBalance\r\n        db.setUint(keccak256(abi.encodePacked(\"funds.tokenBalance\", _platform, _platformId, _token)), newBalance);\r\n\r\n        return userTokenBalance;\r\n    }\r\n\r\n    function finishResolveFund(bytes32 platform, string platformId) public onlyCaller returns (bool) {\r\n        db.setBool(keccak256(abi.encodePacked(\"funds.issueResolved\", platform, platformId)), true);\r\n        db.deleteUint(keccak256(abi.encodePacked(\"funds.funderCount\", platform, platformId)));\r\n        return true;\r\n    }\r\n\r\n    //constants\r\n    function getFundInfo(bytes32 _platform, string _platformId, address _funder, address _token) public view returns (uint256, uint256, uint256) {\r\n        return (\r\n        getFunderCount(_platform, _platformId),\r\n        balance(_platform, _platformId, _token),\r\n        amountFunded(_platform, _platformId, _funder, _token)\r\n        );\r\n    }\r\n\r\n    function issueResolved(bytes32 _platform, string _platformId) public view returns (bool) {\r\n        return db.getBool(keccak256(abi.encodePacked(\"funds.issueResolved\", _platform, _platformId)));\r\n    }\r\n\r\n    function getFundedTokenCount(bytes32 _platform, string _platformId) public view returns (uint256) {\r\n        return db.getUint(keccak256(abi.encodePacked(\"funds.tokenCount\", _platform, _platformId)));\r\n    }\r\n\r\n    function getFundedTokensByIndex(bytes32 _platform, string _platformId, uint _index) public view returns (address) {\r\n        return db.getAddress(keccak256(abi.encodePacked(\"funds.token.address\", _platform, _platformId, _index)));\r\n    }\r\n\r\n    function getFunderCount(bytes32 _platform, string _platformId) public view returns (uint) {\r\n        return db.getUint(keccak256(abi.encodePacked(\"funds.funderCount\", _platform, _platformId)));\r\n    }\r\n\r\n    function getFunderByIndex(bytes32 _platform, string _platformId, uint index) external view returns (address) {\r\n        return db.getAddress(keccak256(abi.encodePacked(\"funds.funders.address\", _platform, _platformId, index)));\r\n    }\r\n\r\n    function amountFunded(bytes32 _platform, string _platformId, address _funder, address _token) public view returns (uint256) {\r\n        return db.getUint(keccak256(abi.encodePacked(\"funds.amountFundedByUser\", _platform, _platformId, _funder, _token)));\r\n    }\r\n\r\n    function balance(bytes32 _platform, string _platformId, address _token) view public returns (uint256) {\r\n        return db.getUint(keccak256(abi.encodePacked(\"funds.tokenBalance\", _platform, _platformId, _token)));\r\n    }\r\n}\r\n\r\ncontract ClaimRepository is Callable {\r\n    using SafeMath for uint256;\r\n\r\n    EternalStorage public db;\r\n\r\n    constructor(address _eternalStorage) public {\r\n        //constructor\r\n        require(_eternalStorage != address(0), \"Eternal storage cannot be 0x0\");\r\n        db = EternalStorage(_eternalStorage);\r\n    }\r\n\r\n    function addClaim(address _solverAddress, bytes32 _platform, string _platformId, string _solver, address _token, uint256 _requestBalance) public onlyCaller returns (bool) {\r\n        if (db.getAddress(keccak256(abi.encodePacked(\"claims.solver_address\", _platform, _platformId))) != address(0)) {\r\n            require(db.getAddress(keccak256(abi.encodePacked(\"claims.solver_address\", _platform, _platformId))) == _solverAddress, \"Adding a claim needs to happen with the same claimer as before\");\r\n        } else {\r\n            db.setString(keccak256(abi.encodePacked(\"claims.solver\", _platform, _platformId)), _solver);\r\n            db.setAddress(keccak256(abi.encodePacked(\"claims.solver_address\", _platform, _platformId)), _solverAddress);\r\n        }\r\n\r\n        uint tokenCount = db.getUint(keccak256(abi.encodePacked(\"claims.tokenCount\", _platform, _platformId)));\r\n        db.setUint(keccak256(abi.encodePacked(\"claims.tokenCount\", _platform, _platformId)), tokenCount.add(1));\r\n        db.setUint(keccak256(abi.encodePacked(\"claims.token.amount\", _platform, _platformId, _token)), _requestBalance);\r\n        db.setAddress(keccak256(abi.encodePacked(\"claims.token.address\", _platform, _platformId, tokenCount)), _token);\r\n        return true;\r\n    }\r\n\r\n    function isClaimed(bytes32 _platform, string _platformId) view external returns (bool claimed) {\r\n        return db.getAddress(keccak256(abi.encodePacked(\"claims.solver_address\", _platform, _platformId))) != address(0);\r\n    }\r\n\r\n    function getSolverAddress(bytes32 _platform, string _platformId) view external returns (address solverAddress) {\r\n        return db.getAddress(keccak256(abi.encodePacked(\"claims.solver_address\", _platform, _platformId)));\r\n    }\r\n\r\n    function getSolver(bytes32 _platform, string _platformId) view external returns (string){\r\n        return db.getString(keccak256(abi.encodePacked(\"claims.solver\", _platform, _platformId)));\r\n    }\r\n\r\n    function getTokenCount(bytes32 _platform, string _platformId) view external returns (uint count) {\r\n        return db.getUint(keccak256(abi.encodePacked(\"claims.tokenCount\", _platform, _platformId)));\r\n    }\r\n\r\n    function getTokenByIndex(bytes32 _platform, string _platformId, uint _index) view external returns (address token) {\r\n        return db.getAddress(keccak256(abi.encodePacked(\"claims.token.address\", _platform, _platformId, _index)));\r\n    }\r\n\r\n    function getAmountByToken(bytes32 _platform, string _platformId, address _token) view external returns (uint token) {\r\n        return db.getUint(keccak256(abi.encodePacked(\"claims.token.amount\", _platform, _platformId, _token)));\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n  function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Functionality in this library is largely implemented using an\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\n *      anything from the entire string to a single character, or even no\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\n *      expensive than copying and manipulating the strings they reference.\r\n *\r\n *      To further reduce gas costs, most functions on slice that need to return\r\n *      a slice modify the original one instead of allocating a new one; for\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\n *      In situations where you do not want to modify the original slice, you\r\n *      can make a copy first with `.copy()`, for example:\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\n *      Solidity has no memory management, it will result in allocating many\r\n *      short-lived slices that are later discarded.\r\n *\r\n *      Functions that return two slices come in two versions: a non-allocating\r\n *      version that takes the second slice as an argument, modifying it in\r\n *      place, and an allocating version that allocates and returns the second\r\n *      slice; see `nextRune` for example.\r\n *\r\n *      Functions that have to copy string data will return strings rather than\r\n *      slices; these can be cast back to slices for further processing if\r\n *      required.\r\n *\r\n *      For convenience, some functions are provided with non-modifying\r\n *      variants that create a new slice and return both; for instance,\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\n *      corresponding to the left and right parts of the string.\r\n */\r\n\r\n\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string self) internal pure returns (slice) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-termintaed utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice self) internal pure returns (slice) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice self) internal pure returns (string) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly {retptr := add(ret, 32)}\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly {b := and(mload(ptr), 0xFF)}\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if (b < 0xE0) {\r\n                ptr += 2;\r\n            } else if (b < 0xF0) {\r\n                ptr += 3;\r\n            } else if (b < 0xF8) {\r\n                ptr += 4;\r\n            } else if (b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice self, slice other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice self, slice other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice self, slice rune) internal pure returns (slice) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly {b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)}\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if (b < 0xE0) {\r\n            l = 2;\r\n        } else if (b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice self) internal pure returns (slice ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly {word := mload(mload(add(self, 32)))}\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if (b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if (b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice self, slice needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice self, slice needle) internal pure returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice self, slice needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice self, slice needle) internal pure returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    event log_bytemask(bytes32 mask);\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly {needledata := and(mload(needleptr), mask)}\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly {ptrdata := and(mload(ptr), mask)}\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly {ptrdata := and(mload(ptr), mask)}\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly {hash := sha3(needleptr, needlelen)}\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly {testHash := sha3(ptr, needlelen)}\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly {needledata := and(mload(needleptr), mask)}\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly {ptrdata := and(mload(ptr), mask)}\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly {ptrdata := and(mload(ptr), mask)}\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly {hash := sha3(needleptr, needlelen)}\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly {testHash := sha3(ptr, needlelen)}\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice self, slice needle) internal pure returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice self, slice needle) internal pure returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice self, slice needle, slice token) internal pure returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice self, slice needle) internal pure returns (slice token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice self, slice needle) internal pure returns (slice token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice self, slice needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice self, slice needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice self, slice other) internal pure returns (string) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly {retptr := add(ret, 32)}\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice self, slice[] parts) internal pure returns (string) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for (uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly {retptr := add(ret, 32)}\r\n\r\n        for (i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n    * Additions by the FundRequest Team\r\n    */\r\n\r\n    function toBytes32(slice self) internal pure returns (bytes32 result) {\r\n        string memory source = toString(self);\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) pure internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) pure internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) pure internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) pure internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function addressToString(address x) internal pure returns (string) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            byte b = byte(uint8(uint(x) / (2 ** (8 * (19 - i)))));\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[2 * i] = charToByte(hi);\r\n            s[2 * i + 1] = charToByte(lo);\r\n        }\r\n        return strConcat(\"0x\", string(s));\r\n    }\r\n\r\n    function charToByte(byte b) internal pure returns (byte c) {\r\n        if (b < 10) return byte(uint8(b) + 0x30);\r\n        else return byte(uint8(b) + 0x57);\r\n    }\r\n\r\n    function bytes32ToString(bytes32 x) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte ch = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (ch != 0) {\r\n                bytesString[charCount] = ch;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\ncontract Precondition is Owned {\r\n\r\n    string public name;\r\n    uint public version;\r\n    bool public active = false;\r\n\r\n    constructor(string _name, uint _version, bool _active) public {\r\n        name = _name;\r\n        version = _version;\r\n        active = _active;\r\n    }\r\n\r\n    function setActive(bool _active) external onlyOwner {\r\n        active = _active;\r\n    }\r\n\r\n    function isValid(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) external view returns (bool valid);\r\n}\r\n\r\n/*\r\n * Main FundRequest Contract. The entrypoint for every claim/refund\r\n * Davy Van Roy\r\n * Quinten De Swaef\r\n */\r\ncontract FundRequestContract is Callable, ApproveAndCallFallBack {\r\n\r\n    using SafeMath for uint256;\r\n    using strings for *;\r\n\r\n    event Funded(address indexed from, bytes32 platform, string platformId, address token, uint256 value);\r\n\r\n    event Claimed(address indexed solverAddress, bytes32 platform, string platformId, string solver, address token, uint256 value);\r\n\r\n    event Refund(address indexed owner, bytes32 platform, string platformId, address token, uint256 value);\r\n\r\n    address constant public ETHER_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n\r\n    //repositories\r\n    FundRepository public fundRepository;\r\n\r\n    ClaimRepository public claimRepository;\r\n\r\n    address public claimSignerAddress;\r\n\r\n    Precondition[] public preconditions;\r\n\r\n    constructor(address _fundRepository, address _claimRepository) public {\r\n        setFundRepository(_fundRepository);\r\n        setClaimRepository(_claimRepository);\r\n    }\r\n\r\n    //ENTRYPOINTS\r\n\r\n    /*\r\n     * Public function, can only be called from the outside.\r\n     * Fund an issue, providing a token and value.\r\n     * Requires an allowance > _value of the token.\r\n     */\r\n    function fund(bytes32 _platform, string _platformId, address _token, uint256 _value) external returns (bool success) {\r\n        require(doFunding(_platform, _platformId, _token, _value, msg.sender), \"funding with token failed\");\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Public function, can only be called from the outside.\r\n     * Fund an issue, ether as value of the transaction.\r\n     * Requires ether to be whitelisted in a precondition.\r\n     */\r\n    function etherFund(bytes32 _platform, string _platformId) payable external returns (bool success) {\r\n        require(doFunding(_platform, _platformId, ETHER_ADDRESS, msg.value, msg.sender), \"funding with ether failed\");\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Public function, supposed to be called from another contract, after receiving approval\r\n     * Funds an issue, expects platform, platformid to be concatted with |AAC| as delimiter and provided as _data\r\n     * Only used with the FundRequest approveAndCall function at the moment. Might be removed later in favor of 2 calls.\r\n     */\r\n    function receiveApproval(address _from, uint _amount, address _token, bytes _data) public {\r\n        var sliced = string(_data).toSlice();\r\n        var platform = sliced.split(\"|AAC|\".toSlice());\r\n        var platformId = sliced.split(\"|AAC|\".toSlice());\r\n        require(doFunding(platform.toBytes32(), platformId.toString(), _token, _amount, _from));\r\n    }\r\n\r\n    /*\r\n     * Claim: Public function, only supposed to be called from the outside\r\n     * Anyone can call this function, but a valid signature from FundRequest is required\r\n     */\r\n    function claim(bytes32 platform, string platformId, string solver, address solverAddress, bytes32 r, bytes32 s, uint8 v) public returns (bool) {\r\n        require(validClaim(platform, platformId, solver, solverAddress, r, s, v), \"Claimsignature was not valid\");\r\n        uint256 tokenCount = fundRepository.getFundedTokenCount(platform, platformId);\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            address token = fundRepository.getFundedTokensByIndex(platform, platformId, i);\r\n            uint256 tokenAmount = fundRepository.claimToken(platform, platformId, token);\r\n            if (token == ETHER_ADDRESS) {\r\n                solverAddress.transfer(tokenAmount);\r\n            } else {\r\n                require(ERC20(token).transfer(solverAddress, tokenAmount), \"transfer of tokens from contract failed\");\r\n            }\r\n            require(claimRepository.addClaim(solverAddress, platform, platformId, solver, token, tokenAmount), \"adding claim to repository failed\");\r\n            emit Claimed(solverAddress, platform, platformId, solver, token, tokenAmount);\r\n        }\r\n        require(fundRepository.finishResolveFund(platform, platformId), \"Resolving the fund failed\");\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Claim: Public function, only supposed to be called from the outside\r\n     * Only FundRequest can call this function for now, which will refund a user for a specific issue.\r\n     */\r\n    function refund(bytes32 _platform, string _platformId, address _funder) external onlyCaller returns (bool) {\r\n        uint256 tokenCount = fundRepository.getFundedTokenCount(_platform, _platformId);\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            address token = fundRepository.getFundedTokensByIndex(_platform, _platformId, i);\r\n            uint256 tokenAmount = fundRepository.refundToken(_platform, _platformId, _funder, token);\r\n            if (tokenAmount > 0) {\r\n                if (token == ETHER_ADDRESS) {\r\n                    _funder.transfer(tokenAmount);\r\n                } else {\r\n                    require(ERC20(token).transfer(_funder, tokenAmount), \"transfer of tokens from contract failed\");\r\n                }\r\n            }\r\n            emit Refund(_funder, _platform, _platformId, token, tokenAmount);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * only called from within the this contract itself, will actually do the funding\r\n     */\r\n    function doFunding(bytes32 _platform, string _platformId, address _token, uint256 _value, address _funder) internal returns (bool success) {\r\n        if (_token == ETHER_ADDRESS) {\r\n            //must check this, so we don't have people foefeling with the amounts\r\n            require(msg.value == _value);\r\n        }\r\n        require(!fundRepository.issueResolved(_platform, _platformId), \"Can't fund tokens, platformId already claimed\");\r\n        for (uint idx = 0; idx < preconditions.length; idx++) {\r\n            if (address(preconditions[idx]) != address(0)) {\r\n                require(preconditions[idx].isValid(_platform, _platformId, _token, _value, _funder));\r\n            }\r\n        }\r\n        require(_value > 0, \"amount of tokens needs to be more than 0\");\r\n\r\n        if (_token != ETHER_ADDRESS) {\r\n            require(ERC20(_token).transferFrom(_funder, address(this), _value), \"Transfer of tokens to contract failed\");\r\n        }\r\n\r\n        fundRepository.updateFunders(_funder, _platform, _platformId);\r\n        fundRepository.updateBalances(_funder, _platform, _platformId, _token, _value);\r\n        emit Funded(_funder, _platform, _platformId, _token, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * checks if a claim is valid, by checking the signature\r\n     */\r\n    function validClaim(bytes32 platform, string platformId, string solver, address solverAddress, bytes32 r, bytes32 s, uint8 v) internal view returns (bool) {\r\n        bytes32 h = keccak256(abi.encodePacked(createClaimMsg(platform, platformId, solver, solverAddress)));\r\n        address signerAddress = ecrecover(h, v, r, s);\r\n        return claimSignerAddress == signerAddress;\r\n    }\r\n\r\n    function createClaimMsg(bytes32 platform, string platformId, string solver, address solverAddress) internal pure returns (string) {\r\n        return strings.bytes32ToString(platform)\r\n        .strConcat(prependUnderscore(platformId))\r\n        .strConcat(prependUnderscore(solver))\r\n        .strConcat(prependUnderscore(strings.addressToString(solverAddress)));\r\n    }\r\n\r\n    function addPrecondition(address _precondition) external onlyOwner {\r\n        preconditions.push(Precondition(_precondition));\r\n    }\r\n\r\n    function removePrecondition(uint _index) external onlyOwner {\r\n        if (_index >= preconditions.length) return;\r\n\r\n        for (uint i = _index; i < preconditions.length - 1; i++) {\r\n            preconditions[i] = preconditions[i + 1];\r\n        }\r\n\r\n        delete preconditions[preconditions.length - 1];\r\n        preconditions.length--;\r\n    }\r\n\r\n    function setFundRepository(address _repositoryAddress) public onlyOwner {\r\n        fundRepository = FundRepository(_repositoryAddress);\r\n    }\r\n\r\n    function setClaimRepository(address _claimRepository) public onlyOwner {\r\n        claimRepository = ClaimRepository(_claimRepository);\r\n    }\r\n\r\n    function setClaimSignerAddress(address _claimSignerAddress) addressNotNull(_claimSignerAddress) public onlyOwner {\r\n        claimSignerAddress = _claimSignerAddress;\r\n    }\r\n\r\n    function prependUnderscore(string str) internal pure returns (string) {\r\n        return \"_\".strConcat(str);\r\n    }\r\n\r\n    //required to be able to migrate to a new FundRequestContract\r\n    function migrateTokens(address _token, address newContract) external onlyOwner {\r\n        require(newContract != address(0));\r\n        if (_token == ETHER_ADDRESS) {\r\n            newContract.transfer(address(this).balance);\r\n        } else {\r\n            ERC20 token = ERC20(_token);\r\n            token.transfer(newContract, token.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    modifier addressNotNull(address target) {\r\n        require(target != address(0), \"target address can not be 0x0\");\r\n        _;\r\n    }\r\n\r\n    //required should there be an issue with available ether\r\n    function deposit() external onlyOwner payable {\r\n        require(msg.value > 0, \"Should at least be 1 wei deposited\");\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"claimSignerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"preconditions\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRepository\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_claimRepository\",\"type\":\"address\"}],\"name\":\"setClaimRepository\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_repositoryAddress\",\"type\":\"address\"}],\"name\":\"setFundRepository\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removePrecondition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"callers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_precondition\",\"type\":\"address\"}],\"name\":\"addPrecondition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimRepository\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"migrateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_platform\",\"type\":\"bytes32\"},{\"name\":\"_platformId\",\"type\":\"string\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_platform\",\"type\":\"bytes32\"},{\"name\":\"_platformId\",\"type\":\"string\"},{\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_claimSignerAddress\",\"type\":\"address\"}],\"name\":\"setClaimSignerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"platform\",\"type\":\"bytes32\"},{\"name\":\"platformId\",\"type\":\"string\"},{\"name\":\"solver\",\"type\":\"string\"},{\"name\":\"solverAddress\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_platform\",\"type\":\"bytes32\"},{\"name\":\"_platformId\",\"type\":\"string\"}],\"name\":\"etherFund\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_caller\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fundRepository\",\"type\":\"address\"},{\"name\":\"_claimRepository\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"platform\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"platformId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"solverAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"platform\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"platformId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"solver\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"platform\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"platformId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"FundRequestContract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ce089b8b079597662614df7557e215f19ec8c3fa000000000000000000000000634074a19df5d6509ccc68fa86e3fe8205f37946","Library":"","SwarmSource":"bzzr://2a6858b7667557e33a20f8a3dea8e00b0fa47ef477c4eefd038ac9d44779ba33"}]}