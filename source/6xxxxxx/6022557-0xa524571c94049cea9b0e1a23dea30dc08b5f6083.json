{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract OracleInterface {\r\n    struct PriceData {\r\n        uint ARTTokenPrice;\r\n        uint blockHeight;\r\n    }\r\n\r\n    mapping(uint => PriceData) public historicPricing;\r\n    uint public index;\r\n    address public owner;\r\n    uint8 public decimals;\r\n\r\n    function setPrice(uint price) public returns (uint _index) {}\r\n\r\n    function getPrice() public view returns (uint price, uint _index, uint blockHeight) {}\r\n\r\n    function getHistoricalPrice(uint _index) public view returns (uint price, uint blockHeight) {}\r\n\r\n    event Updated(uint indexed price, uint indexed index);\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20Interface is ERC20Basic {\r\n    uint8 public decimals;\r\n}\r\n\r\ncontract HasNoTokens {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param from_ address The address that is transferring the tokens\r\n  * @param value_ uint256 the amount of the specified token\r\n  * @param data_ Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\r\n    from_;\r\n    value_;\r\n    data_;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  constructor() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\ncontract DutchAuction is Ownable, HasNoEther, HasNoTokens {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Auction Data\r\n    uint public min_shares_to_sell;\r\n    uint public max_shares_to_sell;\r\n    uint public min_share_price;\r\n    uint public available_shares;\r\n\r\n    bool private fundraise_defined;\r\n    uint public fundraise_max;\r\n\r\n    /// @notice Auction status\r\n    state public status = state.pending;\r\n    enum state { pending, active, ended, decrypted, success, failure }\r\n\r\n    /// @notice Events\r\n    event Started(uint block_number);\r\n    event BidAdded(uint index);\r\n    event Ended(uint block_number);\r\n    event BidDecrypted(uint index, bool it_will_process);\r\n    event FundraiseDefined(uint min_share_price, uint max);\r\n    event BidBurned(uint index);\r\n    event Decrypted(uint blocknumber, uint bids_decrypted, uint bids_burned);\r\n    event Computed(uint index, uint share_price, uint shares_count);\r\n    event Assigned(uint index, uint shares, uint executed_amout, uint refunded);\r\n    event Refunded(uint index, uint refunded);\r\n    event Success(uint raised, uint share_price, uint delivered_shares);\r\n    event Failure(uint raised, uint share_price);\r\n\r\n    event Execution(address destination,uint value,bytes data);\r\n    event ExecutionFailure(address destination,uint value,bytes data);\r\n\r\n    /// @notice Token assignment data\r\n    uint public final_share_price;\r\n    uint public computed_fundraise;\r\n    uint public final_fundraise;\r\n    uint public computed_shares_sold;\r\n    uint public final_shares_sold;\r\n    uint public winner_bids;\r\n    uint public assigned_bids;\r\n    uint public assigned_shares;\r\n\r\n    /// @notice Bidding data\r\n    struct BidData {\r\n        uint origin_index;\r\n        uint bid_id;\r\n        address investor_address;\r\n        uint share_price;\r\n        uint shares_count;\r\n        uint transfer_valuation;\r\n        uint transfer_token;\r\n        uint asigned_shares_count;\r\n        uint executed_amount;\r\n        bool closed;\r\n    }\r\n    uint public bids_sorted_count;\r\n    uint public bids_sorted_refunded;\r\n    mapping (uint => BidData) public bids_sorted; //Is sorted\r\n\r\n    uint public bids_burned_count;\r\n    mapping (uint => uint) public bids_burned;\r\n\r\n    uint public bids_ignored_count;\r\n    uint public bids_ignored_refunded;\r\n    mapping (uint => BidData) public bids_ignored;\r\n\r\n\r\n    uint public bids_decrypted_count;\r\n    mapping (uint => uint) public bids_decrypted;\r\n    uint private bids_reset_count;\r\n\r\n    struct Bid {\r\n        // https://ethereum.stackexchange.com/questions/3184/what-is-the-cheapest-hash-function-available-in-solidity#3200\r\n        bytes32 bid_hash;\r\n        uint art_price;\r\n        uint art_price_index;\r\n        bool exist;\r\n        bool is_decrypted;\r\n        bool is_burned;\r\n        bool will_compute;\r\n    }\r\n    uint public bids_count;\r\n    mapping (uint => Bid) public bids;\r\n\r\n    uint public bids_computed_cursor;\r\n\r\n    uint public shares_holders_count;\r\n    mapping (uint => address) public shares_holders;\r\n    mapping (address => uint) public shares_holders_balance;\r\n\r\n    /// @notice External dependencies\r\n\r\n    OracleInterface oracle;\r\n    uint public oracle_price_decimals_factor;\r\n    ERC20Interface art_token_contract;\r\n    uint public decimal_precission_difference_factor;\r\n\r\n    /// @notice Set up the dutch auction\r\n    /// @param _min_shares_to_sell The minimum amount of asset shares to be sold\r\n    /// @param _max_shares_to_sell The maximum amount of asset shares to be sold\r\n    /// @param _available_shares The total share amount the asset will be divided into\r\n    /// @param _oracle Address of the ART/USD price oracle contract\r\n    /// @param _art_token_contract Address of the ART token contract\r\n    constructor(\r\n        uint _min_shares_to_sell,\r\n        uint _max_shares_to_sell,\r\n        uint _available_shares,\r\n        address _oracle,\r\n        address _art_token_contract\r\n    ) public {\r\n        require(_max_shares_to_sell > 0);\r\n        require(_max_shares_to_sell >= _min_shares_to_sell);\r\n        require(_available_shares >= _max_shares_to_sell);\r\n        require(_oracle != address(0x0));\r\n        owner = msg.sender;\r\n        min_shares_to_sell = _min_shares_to_sell;\r\n        max_shares_to_sell = _max_shares_to_sell;\r\n        available_shares = _available_shares;\r\n        oracle = OracleInterface(_oracle);\r\n        uint256 oracle_decimals = uint256(oracle.decimals());\r\n        oracle_price_decimals_factor = 10**oracle_decimals;\r\n        art_token_contract = ERC20Interface(_art_token_contract);\r\n        uint256 art_token_decimals = uint256(art_token_contract.decimals());\r\n        decimal_precission_difference_factor = 10**(art_token_decimals.sub(oracle_decimals));\r\n    }\r\n\r\n    /// @notice Allows configuration of the final parameters needed for\r\n    /// auction end state calculation. This is only allowed once the auction\r\n    /// has closed and no more bids can enter\r\n    /// @param _min_share_price Minimum price accepted for individual asset shares\r\n    /// @param _fundraise_max Maximum cap for fundraised capital\r\n    function setFundraiseLimits(uint _min_share_price, uint _fundraise_max) public onlyOwner{\r\n        require(!fundraise_defined);\r\n        require(_min_share_price > 0);\r\n        require(_fundraise_max > 0);\r\n        require(status == state.ended);\r\n        fundraise_max = _fundraise_max;\r\n        min_share_price = _min_share_price;\r\n        emit FundraiseDefined(min_share_price,fundraise_max);\r\n        fundraise_defined = true;\r\n    }\r\n\r\n    /// @notice Starts the auction\r\n    function startAuction() public onlyOwner{\r\n        require(status == state.pending);\r\n        status = state.active;\r\n        emit Started(block.number);\r\n    }\r\n\r\n    /// @notice Ends the auction, preventing new bids from entering\r\n    function endAuction() public onlyOwner{\r\n        require(status == state.active);\r\n        status = state.ended;\r\n        emit Ended(block.number);\r\n    }\r\n\r\n    /// @notice Append an encrypted bid to the auction. This allows the contract\r\n    /// to keep a count on how many bids it has, while staying ignorant of the \r\n    /// bid contents.\r\n    function appendEncryptedBid(bytes32 _bid_hash, uint price_index) public onlyOwner returns (uint index){\r\n        require(status == state.active);\r\n        uint art_price;\r\n        uint art_price_blockHeight;\r\n        (art_price, art_price_blockHeight) = oracle.getHistoricalPrice(price_index);\r\n        bids[bids_count] = Bid(_bid_hash, art_price, price_index, true, false, false, false);\r\n        index = bids_count;\r\n        emit BidAdded(bids_count++);\r\n    }\r\n\r\n    /// @notice Helper function for calculating a bid's hash.\r\n    function getBidHash(uint nonce, uint bid_id, address investor_address, uint share_price, uint shares_count) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(nonce, bid_id, investor_address, share_price, shares_count));\r\n    }\r\n\r\n    /// @notice Allows the \"burning\" of a bid, for cases in which a bid was corrupted and can't be decrypted.\r\n    /// \"Burnt\" bids do not participate in the final calculations for auction participants\r\n    /// @param _index Indicates the index of the bid to be burnt\r\n    function burnBid(uint _index) public onlyOwner {\r\n        require(status == state.ended);\r\n        require(bids_sorted_count == 0);\r\n        require(bids[_index].exist == true);\r\n        require(bids[_index].is_decrypted == false);\r\n        require(bids[_index].is_burned == false);\r\n        \r\n        bids_burned[bids_burned_count] = _index;\r\n        bids_burned_count++;\r\n        \r\n        bids_decrypted[bids_decrypted_count] = _index;\r\n        bids_decrypted_count++;\r\n\r\n        bids[_index].is_burned = true;\r\n        emit BidBurned(_index);\r\n    }\r\n\r\n    /// @notice Appends the bid's data to the contract, for use in the final calculations\r\n    /// Once all bids are appended, the auction is locked and changes its state to \"decrypted\"\r\n    /// @dev Bids MUST be appended in order of asset valuation,\r\n    /// since the contract relies on off-chain sorting and checks if the order is correct\r\n    /// @param _nonce Bid parameter\r\n    /// @param _index Bid's index inside the contract\r\n    /// @param _bid_id Bid parameter\r\n    /// @param _investor_address Bid parameter - address of the bid's originator\r\n    /// @param _share_price Bid parameter - estimated value of the asset's share price\r\n    /// @param _shares_count Bid parameter - amount of shares bid for\r\n    /// @param _transfered_token Bid parameter - amount of ART tokens sent with the bid\r\n    function appendDecryptedBid(uint _nonce, uint _index, uint _bid_id, address _investor_address, uint _share_price, uint _shares_count, uint _transfered_token) onlyOwner public {\r\n        require(status == state.ended);\r\n        require(fundraise_defined);\r\n        require(bids[_index].exist == true);\r\n        require(bids[_index].is_decrypted == false);\r\n        require(bids[_index].is_burned == false);\r\n        require(_share_price > 0);\r\n        require(_shares_count > 0);\r\n        require(_transfered_token >= convert_valuation_to_art(_shares_count.mul(_share_price),bids[_index].art_price));\r\n        \r\n        if (bids_sorted_count > 0){\r\n            BidData memory previous_bid_data = bids_sorted[bids_sorted_count-1];\r\n            require(_share_price <= previous_bid_data.share_price);\r\n            if (_share_price == previous_bid_data.share_price){\r\n                require(_index > previous_bid_data.origin_index);\r\n            }\r\n        }\r\n        \r\n        require(\r\n            getBidHash(_nonce, _bid_id,_investor_address,_share_price,_shares_count) == bids[_index].bid_hash\r\n        );\r\n        \r\n        uint _transfer_amount = _share_price.mul(_shares_count);\r\n        \r\n        BidData memory bid_data = BidData(_index, _bid_id, _investor_address, _share_price, _shares_count, _transfer_amount, _transfered_token, 0, 0, false);\r\n        bids[_index].is_decrypted = true;\r\n        \r\n        if (_share_price >= min_share_price){\r\n            bids[_index].will_compute = true;\r\n            bids_sorted[bids_sorted_count] = bid_data;\r\n            bids_sorted_count++;\r\n            emit BidDecrypted(_index,true);\r\n        }else{\r\n            bids[_index].will_compute = false;\r\n            bids_ignored[bids_ignored_count] = bid_data;\r\n            bids_ignored_count++;\r\n            emit BidDecrypted(_index,false);\r\n        }\r\n        bids_decrypted[bids_decrypted_count] = _index;\r\n        bids_decrypted_count++;\r\n        if(bids_decrypted_count == bids_count){\r\n            emit Decrypted(block.number, bids_decrypted_count.sub(bids_burned_count), bids_burned_count);\r\n            status = state.decrypted;\r\n        }\r\n    }\r\n\r\n    /// @notice Allows appending multiple decrypted bids (in order) at once.\r\n    /// @dev Parameters are the same as appendDecryptedBid but in array format.\r\n    function appendDecryptedBids(uint[] _nonce, uint[] _index, uint[] _bid_id, address[] _investor_address, uint[] _share_price, uint[] _shares_count, uint[] _transfered_token) public onlyOwner {\r\n        require(_nonce.length == _index.length);\r\n        require(_index.length == _bid_id.length);\r\n        require(_bid_id.length == _investor_address.length);\r\n        require(_investor_address.length == _share_price.length);\r\n        require(_share_price.length == _shares_count.length);\r\n        require(_shares_count.length == _transfered_token.length);\r\n        require(bids_count.sub(bids_decrypted_count) > 0);\r\n        for (uint i = 0; i < _index.length; i++){\r\n            appendDecryptedBid(_nonce[i], _index[i], _bid_id[i], _investor_address[i], _share_price[i], _shares_count[i], _transfered_token[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows resetting the entire bid decryption/appending process\r\n    /// in case a mistake was made and it is not possible to continue appending further bids.\r\n    function resetAppendDecryptedBids(uint _count) public onlyOwner{\r\n        require(status == state.ended);\r\n        require(bids_decrypted_count > 0);\r\n        require(_count > 0);\r\n        if (bids_reset_count == 0){\r\n            bids_reset_count = bids_decrypted_count;\r\n        }\r\n        uint count = _count;\r\n        if(bids_reset_count < count){\r\n            count = bids_reset_count;\r\n        }\r\n\r\n        do {\r\n            bids_reset_count--;\r\n            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;\r\n            bids[bids_decrypted[bids_reset_count]].is_burned = false;\r\n            bids[bids_decrypted[bids_reset_count]].will_compute = false;\r\n            count--;\r\n        } while(count > 0);\r\n        \r\n        if (bids_reset_count == 0){\r\n            bids_sorted_count = 0;\r\n            bids_ignored_count = 0;\r\n            bids_decrypted_count = 0;\r\n            bids_burned_count = 0;\r\n        }\r\n    }\r\n\r\n    /// @notice Performs the computation of auction winners and losers.\r\n    /// Also, determines if the auction is successful or failed.\r\n    /// Bids which place the asset valuation below the minimum fundraise cap\r\n    /// as well as bids below the final valuation are marked as ignored or \"loser\" respectively\r\n    /// and do not count towards the process.\r\n    /// @dev Since this function is resource intensive, computation is done in batches\r\n    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\r\n    /// of the process.\r\n    /// @param _count Amount of bids to be processed in this run.\r\n    function computeBids(uint _count) public onlyOwner{\r\n        require(status == state.decrypted);\r\n        require(_count > 0);\r\n        uint count = _count;\r\n        // No bids\r\n        if (bids_sorted_count == 0){\r\n            status = state.failure;\r\n            emit Failure(0, 0);\r\n            return;\r\n        }\r\n        //bids_computed_cursor: How many bid already processed\r\n        //bids_sorted_count: How many bids can compunte\r\n        require(bids_computed_cursor < bids_sorted_count);\r\n        \r\n        //bid: Auxiliary variable\r\n        BidData memory bid;\r\n\r\n        do{\r\n            //bid: Current bid to compute\r\n            bid = bids_sorted[bids_computed_cursor];\r\n            //if only one share of current bid leave us out of fundraise limitis, ignore the bid\r\n            //computed_shares_sold: Sumarize shares sold\r\n            if (bid.share_price.mul(computed_shares_sold).add(bid.share_price) > fundraise_max){\r\n                if(bids_computed_cursor > 0){\r\n                    bids_computed_cursor--;\r\n                }\r\n                bid = bids_sorted[bids_computed_cursor];\r\n                break;\r\n            }\r\n            //computed_shares_sold: Sumarize cumpued shares\r\n            computed_shares_sold = computed_shares_sold.add(bid.shares_count);\r\n            //computed_fundraise: Sumarize fundraise\r\n            computed_fundraise = bid.share_price.mul(computed_shares_sold);\r\n            emit Computed(bid.origin_index, bid.share_price, bid.shares_count);\r\n            //Next bid\r\n            bids_computed_cursor++;\r\n            count--;\r\n        }while(\r\n            count > 0 && //We have limite to compute\r\n            bids_computed_cursor < bids_sorted_count && //We have more bids to compute \r\n            (\r\n                computed_fundraise < fundraise_max && //Fundraise is more or equal to max\r\n                computed_shares_sold < max_shares_to_sell //Assigned shares are more or equal to max\r\n            )\r\n        );\r\n\r\n        if (\r\n            bids_computed_cursor == bids_sorted_count ||  //All bids computed\r\n            computed_fundraise >= fundraise_max ||//Fundraise is more or equal to max\r\n            computed_shares_sold >= max_shares_to_sell//Max shares raised\r\n        ){\r\n            \r\n            final_share_price = bid.share_price;\r\n            \r\n            //More than max shares\r\n            if(computed_shares_sold >= max_shares_to_sell){\r\n                computed_shares_sold = max_shares_to_sell;//Limit shares\r\n                computed_fundraise = final_share_price.mul(computed_shares_sold);\r\n                winner_bids = bids_computed_cursor;\r\n                status = state.success;\r\n                emit Success(computed_fundraise, final_share_price, computed_shares_sold);\r\n                return;            \r\n            }\r\n\r\n            //Max fundraise is raised\r\n            if(computed_fundraise.add(final_share_price.mul(1)) >= fundraise_max){//More than max fundraise\r\n                computed_fundraise = fundraise_max;//Limit fundraise\r\n                winner_bids = bids_computed_cursor;\r\n                status = state.success;\r\n                emit Success(computed_fundraise, final_share_price, computed_shares_sold);\r\n                return;\r\n            }\r\n            \r\n            //All bids computed\r\n            if (bids_computed_cursor == bids_sorted_count){\r\n                if (computed_shares_sold >= min_shares_to_sell){\r\n                    winner_bids = bids_computed_cursor;\r\n                    status = state.success;\r\n                    emit Success(computed_fundraise, final_share_price, computed_shares_sold);\r\n                    return;\r\n                }else{\r\n                    status = state.failure;\r\n                    emit Failure(computed_fundraise, final_share_price);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Helper function that calculates the valuation of the asset\r\n    /// in terms of an ART token quantity.\r\n    function convert_valuation_to_art(uint _valuation, uint _art_price) view public returns(uint amount){\r\n        amount = ((\r\n                _valuation.mul(oracle_price_decimals_factor)\r\n            ).div(\r\n                _art_price\r\n            )).mul(decimal_precission_difference_factor);\r\n    }\r\n\r\n    /// @notice Performs the refund of the ignored bids ART tokens\r\n    /// @dev Since this function is resource intensive, computation is done in batches\r\n    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\r\n    /// of the process.\r\n    /// @param _count Amount of bids to be processed in this run.\r\n    function refundIgnoredBids(uint _count) public onlyOwner{\r\n        require(status == state.success || status == state.failure);\r\n        uint count = _count;\r\n        if(bids_ignored_count < bids_ignored_refunded.add(count)){\r\n            count = bids_ignored_count.sub(bids_ignored_refunded);\r\n        }\r\n        require(count > 0);\r\n        uint cursor = bids_ignored_refunded;\r\n        bids_ignored_refunded = bids_ignored_refunded.add(count);\r\n        BidData storage bid;\r\n        while (count > 0) {\r\n            bid = bids_ignored[cursor];\r\n            if(bid.closed){\r\n                continue;\r\n            }\r\n            bid.closed = true;\r\n            art_token_contract.transfer(bid.investor_address, bid.transfer_token);\r\n            emit Refunded(bid.origin_index, bid.transfer_token);\r\n            cursor ++;\r\n            count --;\r\n        }\r\n    }\r\n\r\n    /// @notice Performs the refund of the \"loser\" bids ART tokens\r\n    /// @dev Since this function is resource intensive, computation is done in batches\r\n    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\r\n    /// of the process.\r\n    /// @param _count Amount of bids to be processed in this run.\r\n    function refundLosersBids(uint _count) public onlyOwner{\r\n        require(status == state.success || status == state.failure);\r\n        uint count = _count;\r\n        if(bids_sorted_count.sub(winner_bids) < bids_sorted_refunded.add(count)){\r\n            count = bids_sorted_count.sub(winner_bids).sub(bids_sorted_refunded);\r\n        }\r\n        require(count > 0);\r\n        uint cursor = bids_sorted_refunded.add(winner_bids);\r\n        bids_sorted_refunded = bids_sorted_refunded.add(count);\r\n        BidData memory bid;\r\n        while (count > 0) {\r\n            bid = bids_sorted[cursor];\r\n            if(bid.closed){\r\n                continue;\r\n            }\r\n            bids_sorted[cursor].closed = true;\r\n            art_token_contract.transfer(bid.investor_address, bid.transfer_token);\r\n            emit Refunded(bid.origin_index, bid.transfer_token);\r\n            cursor ++;\r\n            count --;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates how many shares are assigned to a bid.\r\n    /// @param _shares_count Amount of shares bid for.\r\n    /// @param _transfer_valuation Unused parameter\r\n    /// @param _final_share_price Final share price calculated from all winning bids\r\n    /// @param _art_price Price of the ART token\r\n    /// @param transfer_token Amount of ART tokens transferred with the bid\r\n    function calculate_shares_and_return(uint _shares_count, uint _share_price, uint _transfer_valuation, uint _final_share_price, uint _art_price, uint transfer_token) view public \r\n        returns(\r\n            uint _shares_to_assign,\r\n            uint _executed_amount_valuation,\r\n            uint _return_amount\r\n        ){\r\n        if(assigned_shares.add(_shares_count) > max_shares_to_sell){\r\n            _shares_to_assign = max_shares_to_sell.sub(assigned_shares);\r\n        }else{\r\n            _shares_to_assign = _shares_count;\r\n        }\r\n        _executed_amount_valuation = _shares_to_assign.mul(_final_share_price);\r\n        if (final_fundraise.add(_executed_amount_valuation) > fundraise_max){\r\n            _executed_amount_valuation = fundraise_max.sub(final_fundraise);\r\n            _shares_to_assign = _executed_amount_valuation.div(_final_share_price);\r\n            _executed_amount_valuation = _shares_to_assign.mul(_final_share_price);\r\n        }\r\n        uint _executed_amount = convert_valuation_to_art(_executed_amount_valuation, _art_price);\r\n        _return_amount = transfer_token.sub(_executed_amount);\r\n    }\r\n\r\n\r\n    /// @notice Assign the asset share tokens to winner bid's authors\r\n    /// @dev Since this function is resource intensive, computation is done in batches\r\n    /// of `_count` bids, so as to not encounter an OutOfGas exception in the middle\r\n    /// of the process.\r\n    /// @param _count Amount of bids to be processed in this run.\r\n    function assignShareTokens(uint _count) public onlyOwner{\r\n        require(status == state.success);\r\n        uint count = _count;\r\n        if(winner_bids < assigned_bids.add(count)){\r\n            count = winner_bids.sub(assigned_bids);\r\n        }\r\n        require(count > 0);\r\n        uint cursor = assigned_bids;\r\n        assigned_bids = assigned_bids.add(count);\r\n        BidData storage bid;\r\n\r\n        while (count > 0) {\r\n            bid = bids_sorted[cursor];\r\n            uint _shares_to_assign;\r\n            uint _executed_amount_valuation;\r\n            uint _return_amount;\r\n            (_shares_to_assign, _executed_amount_valuation, _return_amount) = calculate_shares_and_return(\r\n                bid.shares_count,\r\n                bid.share_price,\r\n                bid.transfer_valuation,\r\n                final_share_price,\r\n                bids[bid.origin_index].art_price,\r\n                bid.transfer_token\r\n            );\r\n            bid.executed_amount = _executed_amount_valuation;\r\n            bid.asigned_shares_count = _shares_to_assign;\r\n            assigned_shares = assigned_shares.add(_shares_to_assign);\r\n            final_fundraise = final_fundraise.add(_executed_amount_valuation);\r\n            final_shares_sold = final_shares_sold.add(_shares_to_assign);\r\n            if(_return_amount > 0){\r\n                art_token_contract.transfer(bid.investor_address, _return_amount);\r\n            }\r\n            bid.closed = true;\r\n            if (shares_holders_balance[bid.investor_address] == 0){\r\n                shares_holders[shares_holders_count++] = bid.investor_address;\r\n            }\r\n            emit Assigned(bid.origin_index,_shares_to_assign, _executed_amount_valuation, _return_amount);\r\n            shares_holders_balance[bid.investor_address] = shares_holders_balance[bid.investor_address].add(_shares_to_assign);\r\n            cursor ++;\r\n            count --;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Return share balance of sender\r\n    * @return uint256 share_balance\r\n    */\r\n    function getShareBalance() view public returns (uint256 share_balance){\r\n        require(status == state.success);\r\n        require(winner_bids == assigned_bids);\r\n        share_balance = shares_holders_balance[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @dev Reclaim all (Except ART) ERC20Basic compatible tokens\r\n    * @param token ERC20Basic The address of the token contract\r\n    */\r\n    function reclaimToken(ERC20Basic token) external onlyOwner {\r\n        require(token != art_token_contract);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n    }\r\n\r\n    function reclaim_art_token() external onlyOwner {\r\n        require(status == state.success || status == state.failure);\r\n        require(winner_bids == assigned_bids);\r\n        uint256 balance = art_token_contract.balanceOf(this);\r\n        art_token_contract.transfer(owner, balance); \r\n    }\r\n\r\n    /// @notice Proxy function which allows sending of transactions\r\n    /// in behalf of the contract\r\n    function executeTransaction(\r\n        address destination,\r\n        uint value,\r\n        bytes data\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (destination.call.value(value)(data))\r\n            emit Execution(destination,value,data);\r\n        else\r\n            emit ExecutionFailure(destination,value,data);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bids_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"computed_fundraise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"resetAppendDecryptedBids\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids_decrypted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bids_burned_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getShareBalance\",\"outputs\":[{\"name\":\"share_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bid_hash\",\"type\":\"bytes32\"},{\"name\":\"price_index\",\"type\":\"uint256\"}],\"name\":\"appendEncryptedBid\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimal_precission_difference_factor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids_sorted\",\"outputs\":[{\"name\":\"origin_index\",\"type\":\"uint256\"},{\"name\":\"bid_id\",\"type\":\"uint256\"},{\"name\":\"investor_address\",\"type\":\"address\"},{\"name\":\"share_price\",\"type\":\"uint256\"},{\"name\":\"shares_count\",\"type\":\"uint256\"},{\"name\":\"transfer_valuation\",\"type\":\"uint256\"},{\"name\":\"transfer_token\",\"type\":\"uint256\"},{\"name\":\"asigned_shares_count\",\"type\":\"uint256\"},{\"name\":\"executed_amount\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shares_holders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shares_holders_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_share_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bids_sorted_refunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"bid_hash\",\"type\":\"bytes32\"},{\"name\":\"art_price\",\"type\":\"uint256\"},{\"name\":\"art_price_index\",\"type\":\"uint256\"},{\"name\":\"exist\",\"type\":\"bool\"},{\"name\":\"is_decrypted\",\"type\":\"bool\"},{\"name\":\"is_burned\",\"type\":\"bool\"},{\"name\":\"will_compute\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assigned_shares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares_holders_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_shares_to_sell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"final_shares_sold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"available_shares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shares_count\",\"type\":\"uint256\"},{\"name\":\"_share_price\",\"type\":\"uint256\"},{\"name\":\"_transfer_valuation\",\"type\":\"uint256\"},{\"name\":\"_final_share_price\",\"type\":\"uint256\"},{\"name\":\"_art_price\",\"type\":\"uint256\"},{\"name\":\"transfer_token\",\"type\":\"uint256\"}],\"name\":\"calculate_shares_and_return\",\"outputs\":[{\"name\":\"_shares_to_assign\",\"type\":\"uint256\"},{\"name\":\"_executed_amount_valuation\",\"type\":\"uint256\"},{\"name\":\"_return_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bids_sorted_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"bid_id\",\"type\":\"uint256\"},{\"name\":\"investor_address\",\"type\":\"address\"},{\"name\":\"share_price\",\"type\":\"uint256\"},{\"name\":\"shares_count\",\"type\":\"uint256\"}],\"name\":\"getBidHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"computeBids\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle_price_decimals_factor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaim_art_token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_bid_id\",\"type\":\"uint256\"},{\"name\":\"_investor_address\",\"type\":\"address\"},{\"name\":\"_share_price\",\"type\":\"uint256\"},{\"name\":\"_shares_count\",\"type\":\"uint256\"},{\"name\":\"_transfered_token\",\"type\":\"uint256\"}],\"name\":\"appendDecryptedBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_shares_to_sell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nonce\",\"type\":\"uint256[]\"},{\"name\":\"_index\",\"type\":\"uint256[]\"},{\"name\":\"_bid_id\",\"type\":\"uint256[]\"},{\"name\":\"_investor_address\",\"type\":\"address[]\"},{\"name\":\"_share_price\",\"type\":\"uint256[]\"},{\"name\":\"_shares_count\",\"type\":\"uint256[]\"},{\"name\":\"_transfered_token\",\"type\":\"uint256[]\"}],\"name\":\"appendDecryptedBids\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bids_computed_cursor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"burnBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"final_fundraise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundraise_max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_valuation\",\"type\":\"uint256\"},{\"name\":\"_art_price\",\"type\":\"uint256\"}],\"name\":\"convert_valuation_to_art\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"final_share_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"computed_shares_sold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"refundLosersBids\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from_\",\"type\":\"address\"},{\"name\":\"value_\",\"type\":\"uint256\"},{\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bids_ignored_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bids_decrypted_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids_burned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"assignShareTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids_ignored\",\"outputs\":[{\"name\":\"origin_index\",\"type\":\"uint256\"},{\"name\":\"bid_id\",\"type\":\"uint256\"},{\"name\":\"investor_address\",\"type\":\"address\"},{\"name\":\"share_price\",\"type\":\"uint256\"},{\"name\":\"shares_count\",\"type\":\"uint256\"},{\"name\":\"transfer_valuation\",\"type\":\"uint256\"},{\"name\":\"transfer_token\",\"type\":\"uint256\"},{\"name\":\"asigned_shares_count\",\"type\":\"uint256\"},{\"name\":\"executed_amount\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_min_share_price\",\"type\":\"uint256\"},{\"name\":\"_fundraise_max\",\"type\":\"uint256\"}],\"name\":\"setFundraiseLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"refundIgnoredBids\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bids_ignored_refunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner_bids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assigned_bids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_min_shares_to_sell\",\"type\":\"uint256\"},{\"name\":\"_max_shares_to_sell\",\"type\":\"uint256\"},{\"name\":\"_available_shares\",\"type\":\"uint256\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_art_token_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"block_number\",\"type\":\"uint256\"}],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"BidAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"block_number\",\"type\":\"uint256\"}],\"name\":\"Ended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"it_will_process\",\"type\":\"bool\"}],\"name\":\"BidDecrypted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"min_share_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"FundraiseDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"BidBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bids_decrypted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bids_burned\",\"type\":\"uint256\"}],\"name\":\"Decrypted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"share_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"shares_count\",\"type\":\"uint256\"}],\"name\":\"Computed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executed_amout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refunded\",\"type\":\"uint256\"}],\"name\":\"Assigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refunded\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"raised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"share_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"delivered_shares\",\"type\":\"uint256\"}],\"name\":\"Success\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"raised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"share_price\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DutchAuction","CompilerVersion":"v0.4.25-nightly.2018.6.6+commit.59b35fa5","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000003d0900000000000000000000000000000000000000000000000000000000000077a1000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000f9ac18e0ce26d6daaec2574aae2cb110de6d4a25000000000000000000000000fec0cf7fe078a500abf15f1284958f22049c2c7e","Library":"","SwarmSource":"bzzr://985634af3d3d12be4710d9681807d9fcde5be3d6112794701e822e29367100e2"}]}