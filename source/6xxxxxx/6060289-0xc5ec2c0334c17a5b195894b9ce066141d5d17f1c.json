{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary bn256g1 {\r\n    uint256 internal constant FIELD_ORDER = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\r\n    uint256 internal constant GEN_ORDER = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\r\n    uint256 internal constant CURVE_B = 3;\r\n    uint256 internal constant CURVE_A = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52;\r\n    struct Point {\r\n        uint256 X;\r\n        uint256 Y;\r\n    }\r\n    function genOrder() internal pure returns (uint256) {\r\n        return GEN_ORDER;\r\n    }\r\n    function fieldOrder() internal pure returns (uint256) {\r\n        return FIELD_ORDER;\r\n    }\r\n    function infinity() internal pure returns (Point) {\r\n        return Point(0, 0);\r\n    }\r\n    function generator() internal pure returns (Point) {\r\n        return Point(1, 2);\r\n    }\r\n    function equal(Point a, Point b) internal pure returns (bool) {\r\n        return a.X == b.X && a.Y == b.Y;\r\n    }\r\n    function negate(Point p) internal pure returns (Point) {\r\n        if(p.X == 0 && p.Y == 0) {\r\n            return Point(0, 0);\r\n        }\r\n        return Point(p.X, FIELD_ORDER - (p.Y % FIELD_ORDER));\r\n    }\r\n    function hashToPoint(bytes32 s) internal view returns (Point) {\r\n        uint256 beta = 0;\r\n        uint256 y = 0;\r\n        uint256 x = uint256(s) % GEN_ORDER;\r\n        while( true ) {\r\n            (beta, y) = findYforX(x);\r\n            if(beta == mulmod(y, y, FIELD_ORDER)) {\r\n                return Point(x, y);\r\n            }\r\n\r\n            x = addmod(x, 1, FIELD_ORDER);\r\n        }\r\n    }\r\n    function findYforX(uint256 x) internal view returns (uint256, uint256) {\r\n        uint256 beta = addmod(mulmod(mulmod(x, x, FIELD_ORDER), x, FIELD_ORDER), CURVE_B, FIELD_ORDER);\r\n        uint256 y = expMod(beta, CURVE_A, FIELD_ORDER);\r\n        return (beta, y);\r\n    }\r\n    function isInfinity(Point p) internal pure returns (bool) {\r\n        return p.X == 0 && p.Y == 0;\r\n    }\r\n    function isOnCurve(Point p) internal pure returns (bool) {\r\n        uint256 p_squared = mulmod(p.X, p.X, FIELD_ORDER);\r\n        uint256 p_cubed = mulmod(p_squared, p.X, FIELD_ORDER);\r\n        return addmod(p_cubed, CURVE_B, FIELD_ORDER) == mulmod(p.Y, p.Y, FIELD_ORDER);\r\n    }\r\n    function scalarBaseMult(uint256 x) internal view returns (Point r) {\r\n        return scalarMult(generator(), x);\r\n    }\r\n    function pointAdd(Point p1, Point p2) internal view returns (Point r) {\r\n        uint256[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 6, input, 0x80, r, 0x40)\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require(success);\r\n    }\r\n    function scalarMult(Point p, uint256 s) internal view returns (Point r) {\r\n        uint256[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 7, input, 0x60, r, 0x40)\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require(success);\r\n    }\r\n    function expMod(uint256 base, uint256 exponent, uint256 modulus)\r\n        internal view returns (uint256 retval)\r\n    {\r\n        bool success;\r\n        uint256[1] memory output;\r\n        uint256[6] memory input;\r\n        input[0] = 0x20;\r\n        input[1] = 0x20;\r\n        input[2] = 0x20;\r\n        input[3] = base;\r\n        input[4] = exponent;\r\n        input[5] = modulus;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 5, input, 0xc0, output, 0x20)\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require(success);\r\n        return output[0];\r\n    }\r\n}\r\n\r\nlibrary LinkableRing {\r\n    using bn256g1 for bn256g1.Point;\r\n    uint256 public constant RING_SIZE = 1;\r\n    struct Data {\r\n        bn256g1.Point hash;\r\n        bn256g1.Point[] pubkeys;\r\n        uint256[] tags;\r\n    }\r\n    function message(Data storage self) internal view returns (bytes32) {\r\n        require(isFull(self));\r\n        return bytes32(self.hash.X);\r\n    }\r\n    function isDead(Data storage self) internal view returns (bool) {\r\n        return self.hash.X == 0 || (self.tags.length >= RING_SIZE && self.pubkeys.length >= RING_SIZE);\r\n    }\r\n    function pubExists(Data storage self, uint256 pub_x) internal view returns (bool) {\r\n        for(uint i = 0; i < self.pubkeys.length; i++) {\r\n            if(self.pubkeys[i].X == pub_x) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function tagExists(Data storage self, uint256 pub_x) internal view returns (bool) {\r\n        for(uint i = 0; i < self.tags.length; i++) {\r\n            if(self.tags[i] == pub_x) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function isInitialized(Data storage self) internal view returns (bool) {\r\n        return self.hash.X != 0;\r\n    }\r\n    function initialize(Data storage self, bytes32 guid) internal returns (bool) {\r\n        require(uint256(guid) != 0);\r\n        require(self.hash.X == 0);\r\n        self.hash.X = uint256(guid);\r\n        return true;\r\n    }\r\n    function isFull(Data storage self) internal view returns (bool) {\r\n        return self.pubkeys.length == RING_SIZE;\r\n    }\r\n    function addParticipant(Data storage self, uint256 pub_x, uint256 pub_y)\r\n        internal returns (bool)\r\n    {\r\n        require(!isFull(self));\r\n        require(!pubExists(self, pub_x));\r\n        bn256g1.Point memory pub = bn256g1.Point(pub_x, pub_y);\r\n        require(pub.isOnCurve());\r\n        self.hash.X = uint256(sha256(self.hash.X, pub.X, pub.Y));\r\n        self.pubkeys.push(pub);\r\n        if(isFull(self)) {\r\n            self.hash = bn256g1.hashToPoint(bytes32(self.hash.X));\r\n        }\r\n        return true;\r\n    }\r\n    function tagAdd(Data storage self, uint256 tag_x) internal {\r\n        self.tags.push(tag_x);\r\n    }\r\n    function ringLink(uint256 previous_hash, uint256 cj, uint256 tj, bn256g1.Point tau, bn256g1.Point h, bn256g1.Point yj)\r\n        internal view returns (uint256 ho)\r\n    {\r\n        bn256g1.Point memory yc = yj.scalarMult(cj);\r\n        bn256g1.Point memory a = bn256g1.scalarBaseMult(tj).pointAdd(yc);\r\n        bn256g1.Point memory b = h.scalarMult(tj).pointAdd(tau.scalarMult(cj));\r\n        return uint256(sha256(previous_hash, a.X, a.Y, b.X, b.Y));\r\n    }\r\n    function isSignatureValid(Data storage self, uint256 tag_x, uint256 tag_y, uint256[] ctlist)\r\n        internal view returns (bool)\r\n    {\r\n        require(isFull(self));\r\n        require(!tagExists(self, tag_x));\r\n        uint256 hashout = uint256(sha256(self.hash.X, tag_x, tag_y));\r\n        uint256 csum = 0;\r\n\r\n        for (uint i = 0; i < self.pubkeys.length; i++) {\r\n            uint256 cj = ctlist[2*i] % bn256g1.genOrder();\r\n            uint256 tj = ctlist[2*i+1] % bn256g1.genOrder();\r\n            hashout = ringLink(hashout, cj, tj, bn256g1.Point(tag_x, tag_y), self.hash, self.pubkeys[i]);\r\n            csum = addmod(csum, cj, bn256g1.genOrder());\r\n        }\r\n\r\n        hashout %= bn256g1.genOrder();\r\n        return hashout == csum;\r\n    }\r\n}\r\n\r\ninterface ERC223 {\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external returns (uint);\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n}\r\n\r\ncontract ERC223ReceivingContract {\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\ncontract ERC20Compatible {\r\n    function transferFrom(address from, address to, uint256 value) public;\r\n    function transfer(address to, uint256 value) public;\r\n}\r\n\r\ncontract Mixer {\r\n    using LinkableRing for LinkableRing.Data;\r\n\r\n    struct Data {\r\n        bytes32 guid;\r\n        uint256 denomination;\r\n        address token;\r\n        LinkableRing.Data ring;\r\n    }\r\n\r\n    mapping(bytes32 => Data) internal m_rings;\r\n    mapping(uint256 => bytes32) internal m_pubx_to_ring;\r\n    mapping(bytes32 => bytes32) internal m_filling;\r\n    \r\n    uint256 internal m_ring_ctr;\r\n\r\n    event LogMixerDeposit(bytes32 indexed ring_id,uint256 indexed pub_x,address token,uint256 value);\r\n    event LogMixerWithdraw(bytes32 indexed ring_id,uint256 tag_x,address token,uint256 value);\r\n    event LogMixerReady(bytes32 indexed ring_id, bytes32 message);\r\n    event LogMixerDead(bytes32 indexed ring_id);\r\n\r\n    function () public {\r\n        revert();\r\n    }\r\n\r\n    function message(bytes32 ring_guid) public view returns (bytes32)\r\n    {\r\n        Data storage entry = m_rings[ring_guid];\r\n        LinkableRing.Data storage ring = entry.ring;\r\n        require(0 != entry.denomination);\r\n        return ring.message();\r\n    }\r\n\r\n    function depositEther(address token, uint256 denomination, uint256 pub_x, uint256 pub_y) public payable returns (bytes32)\r\n    {\r\n        require(token == 0);\r\n        require(denomination == msg.value);\r\n        bytes32 ring_guid = depositLogic(token, denomination, pub_x, pub_y);\r\n        return ring_guid;\r\n    }\r\n\r\n    function depositERC20Compatible(address token, uint256 denomination, uint256 pub_x, uint256 pub_y) public returns (bytes32)\r\n    {\r\n        uint256 codeLength;\r\n        assembly {\r\n            codeLength := extcodesize(token)\r\n        }\r\n\r\n        require(token != 0 && codeLength > 0);\r\n        bytes32 ring_guid = depositLogic(token, denomination, pub_x, pub_y);\r\n        ERC20Compatible untrustedErc20Token = ERC20Compatible(token);\r\n        untrustedErc20Token.transferFrom(msg.sender, this, denomination);\r\n        return ring_guid;\r\n    }\r\n\r\n    function withdrawEther(bytes32 ring_id, uint256 tag_x, uint256 tag_y, uint256[] ctlist) public returns (bool)\r\n    {\r\n        Data memory entry = withdrawLogic(ring_id, tag_x, tag_y, ctlist);\r\n        msg.sender.transfer(entry.denomination);\r\n        return true;\r\n    }\r\n\r\n    function withdrawERC20Compatible(bytes32 ring_id, uint256 tag_x, uint256 tag_y, uint256[] ctlist) public returns (bool)\r\n    {\r\n        Data memory entry = withdrawLogic(ring_id, tag_x, tag_y, ctlist);\r\n        ERC20Compatible untrustedErc20Token = ERC20Compatible(entry.token);\r\n        untrustedErc20Token.transfer(msg.sender, entry.denomination);\r\n        return true;\r\n    }\r\n\r\n    function lookupFillingRing(address token, uint256 denomination) internal returns (bytes32, Data storage)\r\n    {\r\n        bytes32 filling_id = sha256(token, denomination);\r\n        bytes32 ring_guid = m_filling[filling_id];\r\n        if(ring_guid != 0) {\r\n            return (filling_id, m_rings[ring_guid]);\r\n        }\r\n        ring_guid = sha256(address(this), m_ring_ctr, filling_id);\r\n        Data storage entry = m_rings[ring_guid];\r\n        require(0 == entry.denomination);\r\n        require(entry.ring.initialize(ring_guid));\r\n        entry.guid = ring_guid;\r\n        entry.token = token;\r\n        entry.denomination = denomination;\r\n        m_ring_ctr += 1;\r\n        m_filling[filling_id] = ring_guid;\r\n        return (filling_id, entry);\r\n    }\r\n\r\n    function depositLogic(address token, uint256 denomination, uint256 pub_x, uint256 pub_y)\r\n        internal returns (bytes32)\r\n    {\r\n        require(denomination != 0 && 0 == (denomination & (denomination - 1)));\r\n        require(0 == uint256(m_pubx_to_ring[pub_x]));\r\n        bytes32 filling_id;\r\n        Data storage entry;\r\n        (filling_id, entry) = lookupFillingRing(token, denomination);\r\n        LinkableRing.Data storage ring = entry.ring;\r\n        require(ring.addParticipant(pub_x, pub_y));\r\n        bytes32 ring_guid = entry.guid;\r\n        m_pubx_to_ring[pub_x] = ring_guid;\r\n        emit LogMixerDeposit(ring_guid, pub_x, token, denomination);\r\n        if(ring.isFull()) {\r\n            delete m_filling[filling_id];\r\n            emit LogMixerReady(ring_guid, ring.message());\r\n        }\r\n        return ring_guid;\r\n    }\r\n\r\n    function withdrawLogic(bytes32 ring_id, uint256 tag_x, uint256 tag_y, uint256[] ctlist)\r\n        internal returns (Data)\r\n    {\r\n        Data storage entry = m_rings[ring_id];\r\n        LinkableRing.Data storage ring = entry.ring;\r\n        require(0 != entry.denomination);\r\n        require(ring.isFull());\r\n        require(ring.isSignatureValid(tag_x, tag_y, ctlist));\r\n        ring.tagAdd(tag_x);\r\n        emit LogMixerWithdraw(ring_id, tag_x, entry.token, entry.denomination);\r\n        Data memory entrySaved = entry;\r\n        if(ring.isDead()) {\r\n            for(uint i = 0; i < ring.pubkeys.length; i++) {\r\n                delete m_pubx_to_ring[ring.pubkeys[i].X];\r\n            }\r\n            delete m_rings[ring_id];\r\n            emit LogMixerDead(ring_id);\r\n        }\r\n        return entrySaved;\r\n    }\r\n}\r\n//This project was developed by Apolo Blockchain Technologies LLC - HA08-07C23-10V26-02 - CD10-05A29-09F10-08","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"ring_guid\",\"type\":\"bytes32\"}],\"name\":\"message\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"denomination\",\"type\":\"uint256\"},{\"name\":\"pub_x\",\"type\":\"uint256\"},{\"name\":\"pub_y\",\"type\":\"uint256\"}],\"name\":\"depositERC20Compatible\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ring_id\",\"type\":\"bytes32\"},{\"name\":\"tag_x\",\"type\":\"uint256\"},{\"name\":\"tag_y\",\"type\":\"uint256\"},{\"name\":\"ctlist\",\"type\":\"uint256[]\"}],\"name\":\"withdrawERC20Compatible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"denomination\",\"type\":\"uint256\"},{\"name\":\"pub_x\",\"type\":\"uint256\"},{\"name\":\"pub_y\",\"type\":\"uint256\"}],\"name\":\"depositEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ring_id\",\"type\":\"bytes32\"},{\"name\":\"tag_x\",\"type\":\"uint256\"},{\"name\":\"tag_y\",\"type\":\"uint256\"},{\"name\":\"ctlist\",\"type\":\"uint256[]\"}],\"name\":\"withdrawEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ring_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"pub_x\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogMixerDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ring_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tag_x\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogMixerWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ring_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"bytes32\"}],\"name\":\"LogMixerReady\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ring_id\",\"type\":\"bytes32\"}],\"name\":\"LogMixerDead\",\"type\":\"event\"}]","ContractName":"Mixer","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d4b49f81597c3cdadef28c8488e473164e57e3b24e65887ddd8689725f3de4d2"}]}