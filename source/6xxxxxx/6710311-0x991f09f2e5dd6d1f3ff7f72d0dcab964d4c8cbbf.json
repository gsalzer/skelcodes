{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address _who) external view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0,\"Math error\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a,\"Math error\");\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0,\"Math error\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @dev Implementation of the basic standard token.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal balances_;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed_;\r\n\r\n    uint256 private totalSupply_;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances_[_owner];\r\n    }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n      public\r\n      view\r\n      returns (uint256)\r\n    {\r\n        return allowed_[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances_[msg.sender],\"Invalid value\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[msg.sender] = balances_[msg.sender].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed_[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        require(_value <= balances_[_from],\"Value is more than balance\");\r\n        require(_value <= allowed_[_from][msg.sender],\"Value is more than alloved\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[_from] = balances_[_from].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        allowed_[msg.sender][_spender] = (allowed_[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        uint256 oldValue = allowed_[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed_[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed_[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that mints an amount of the token and assigns it to\r\n    * an account. This encapsulates the modification of balances such that the\r\n    * proper events are emitted.\r\n    * @param _account The account that will receive the created tokens.\r\n    * @param _amount The amount that will be created.\r\n    */\r\n    function _mint(address _account, uint256 _amount) internal {\r\n        require(_account != 0,\"Invalid address\");\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances_[_account] = balances_[_account].add(_amount);\r\n        emit Transfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account.\r\n    * @param _account The account whose tokens will be burnt.\r\n    * @param _amount The amount that will be burnt.\r\n    */\r\n    function _burn(address _account, uint256 _amount) internal {\r\n        require(_account != 0,\"Invalid address\");\r\n        require(_amount <= balances_[_account],\"Amount is more than balance\");\r\n\r\n        totalSupply_ = totalSupply_.sub(_amount);\r\n        balances_[_account] = balances_[_account].sub(_amount);\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    function safeTransfer(\r\n        IERC20 _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.transfer(_to, _value),\"Transfer error\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.transferFrom(_from, _to, _value),\"Tranfer error\");\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 _token,\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.approve(_spender, _value),\"Approve error\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable {\r\n    event Paused();\r\n    event Unpaused();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused,\"Contract is paused, sorry\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is running now\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev ERC20 modified with pausable transfers.\r\n **/\r\ncontract ERC20Pausable is ERC20, Pausable {\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Contract ATHLETICO token\r\n * @dev ERC20 compatible token contract\r\n */\r\ncontract ATHLETICOToken is ERC20Pausable {\r\n    string public constant name = \"ATHLETICO TOKEN\";\r\n    string public constant symbol = \"ATH\";\r\n    uint32 public constant decimals = 18;\r\n    uint256 public INITIAL_SUPPLY = 1000000000 * 1 ether; // 1 000 000 000\r\n    address public CrowdsaleAddress;\r\n    bool public ICOover;\r\n\r\n    mapping (address => bool) public kyc;\r\n    mapping (address => uint256) public sponsors;\r\n\r\n    event LogSponsor(\r\n        address indexed from,\r\n        uint256 value\r\n    );\r\n\r\n    constructor(address _CrowdsaleAddress) public {\r\n    \r\n        CrowdsaleAddress = _CrowdsaleAddress;\r\n        _mint(_CrowdsaleAddress, INITIAL_SUPPLY);\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == CrowdsaleAddress,\"Only CrowdSale contract can run this\");\r\n        _;\r\n    }\r\n    \r\n    modifier validDestination( address to ) {\r\n        require(to != address(0),\"Empty address\");\r\n        require(to != address(this),\"RESTO Token address\");\r\n        _;\r\n    }\r\n    \r\n    modifier isICOover {\r\n        if (msg.sender != CrowdsaleAddress){\r\n            require(ICOover == true,\"Transfer of tokens is prohibited until the end of the ICO\");\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transfer(address _to, uint256 _value) public validDestination(_to) isICOover returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) \r\n    public validDestination(_to) isICOover returns (bool) \r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    \r\n  /**\r\n   * @dev Function to mint tokens\r\n   * can run only from crowdsale contract\r\n   * @param to The address that will receive the minted tokens.\r\n   * @param _value The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n    function mint(address to, uint256 _value) public onlyOwner {\r\n        _mint(to, _value);\r\n    }\r\n\r\n\r\n   /**\r\n    * @dev Function to burn tokens\r\n    * Anyone can burn their tokens and in this way help the project.\r\n    * Information about sponsors is public.\r\n    * On the project website you can get a sponsor certificate.\r\n    */\r\n    function burn(uint256 _value) public {\r\n        _burn(msg.sender, _value);\r\n        sponsors[msg.sender] = sponsors[msg.sender].add(_value);\r\n        emit LogSponsor(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev function set kyc bool to true\r\n    * can run only from crowdsale contract\r\n    * @param _investor The investor who passed the procedure KYC\r\n    */\r\n    function kycPass(address _investor) public onlyOwner {\r\n        kyc[_investor] = true;\r\n    }\r\n\r\n    /**\r\n    * @dev function set kyc bool to false\r\n    * can run only from crowdsale contract\r\n    * @param _investor The investor who not passed the procedure KYC (change after passing kyc - something wrong)\r\n    */\r\n    function kycNotPass(address _investor) public onlyOwner {\r\n        kyc[_investor] = false;\r\n    }\r\n\r\n    /**\r\n    * @dev function set ICOOver bool to true\r\n    * can run only from crowdsale contract\r\n    */\r\n    function setICOover() public onlyOwner {\r\n        ICOover = true;\r\n    }\r\n\r\n    /**\r\n     * @dev function transfer tokens from special address to users\r\n     * can run only from crowdsale contract\r\n     */\r\n    function transferTokensFromSpecialAddress(address _from, address _to, uint256 _value) public onlyOwner whenNotPaused returns (bool){\r\n        require (balances_[_from] >= _value,\"Decrease value\");\r\n        \r\n        balances_[_from] = balances_[_from].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        \r\n        emit Transfer(_from, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev called from crowdsale contract to pause, triggers stopped state\r\n     * can run only from crowdsale contract\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    /**\r\n     * @dev called from crowdsale contract to unpause, returns to normal state\r\n     * can run only from crowdsale contract\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n \r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner and DAOContract addresses, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public DAOContract;\r\n    address private candidate;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        DAOContract = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner,\"Access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDAO() {\r\n        require(msg.sender == DAOContract,\"Access denied\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0),\"Invalid address\");\r\n        candidate = _newOwner;\r\n    }\r\n\r\n    function setDAOContract(address _newDAOContract) public onlyOwner {\r\n        require(_newDAOContract != address(0),\"Invalid address\");\r\n        DAOContract = _newDAOContract;\r\n    }\r\n\r\n\r\n    function confirmOwnership() public {\r\n        require(candidate == msg.sender,\"Only from candidate\");\r\n        owner = candidate;\r\n        delete candidate;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract TeamAddress {\r\n\r\n}\r\n\r\n\r\ncontract BountyAddress {\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale\r\n */\r\ncontract Crowdsale is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ATHLETICOToken;\r\n\r\n    event LogStateSwitch(State newState);\r\n    event LogRefunding(address indexed to, uint256 amount);\r\n    mapping(address => uint) public crowdsaleBalances;\r\n\r\n    uint256 public softCap = 250 * 1 ether;\r\n    address internal myAddress = this;\r\n    ATHLETICOToken public token = new ATHLETICOToken(myAddress);\r\n    uint64 public crowdSaleStartTime;       \r\n    uint64 public crowdSaleEndTime = 1559347200;       // 01.06.2019 0:00:00\r\n    uint256 internal minValue = 0.005 ether;\r\n\r\n    //Addresses for store tokens\r\n    TeamAddress public teamAddress = new TeamAddress();\r\n    BountyAddress public bountyAddress = new BountyAddress();\r\n      \r\n    // How many token units a buyer gets per wei.\r\n    uint256 public rate;\r\n\r\n    // Amount of wei raised\r\n    uint256 public weiRaised;\r\n\r\n    event LogWithdraw(\r\n        address indexed from, \r\n        address indexed to, \r\n        uint256 amount\r\n    );\r\n\r\n    event LogTokensPurchased(\r\n        address indexed purchaser,\r\n        address indexed beneficiary,\r\n        uint256 value,\r\n        uint256 amount\r\n    );\r\n\r\n    // Create state of contract\r\n    enum State { \r\n        Init,    \r\n        CrowdSale,\r\n        Refunding,\r\n        WorkTime\r\n    }\r\n\r\n    State public currentState = State.Init;\r\n\r\n    modifier onlyInState(State state){ \r\n        require(state==currentState); \r\n        _; \r\n    }\r\n\r\n\r\n    constructor() public {\r\n        uint256 totalTokens = token.INITIAL_SUPPLY();\r\n        /**\r\n        * @dev Inicial distributing tokens to special adresses\r\n        * TeamAddress - 10%\r\n        * BountyAddress - 5%\r\n        */\r\n        _deliverTokens(teamAddress, totalTokens.div(10));\r\n        _deliverTokens(bountyAddress, totalTokens.div(20));\r\n\r\n        rate = 20000;\r\n        setState(State.CrowdSale);\r\n        crowdSaleStartTime = uint64(now);\r\n    }\r\n\r\n    /**\r\n     * @dev public function finishing crowdsale if enddate is coming or softcap is passed\r\n     */\r\n    function finishCrowdSale() public onlyInState(State.CrowdSale) {\r\n        require(now >= crowdSaleEndTime || myAddress.balance >= softCap, \"Too early\");\r\n        if(myAddress.balance >= softCap) {\r\n        setState(State.WorkTime);\r\n        token.setICOover();\r\n        } else {\r\n        setState(State.Refunding);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev fallback function\r\n    */\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev token purchase\r\n    * @param _beneficiary Address performing the token purchase\r\n    */\r\n    function buyTokens(address _beneficiary) public payable {\r\n        uint256 weiAmount = msg.value;\r\n        _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        _processPurchase(_beneficiary, tokens);\r\n\r\n        crowdsaleBalances[_beneficiary] = crowdsaleBalances[_beneficiary].add(weiAmount);\r\n        \r\n        emit LogTokensPurchased(\r\n            msg.sender,\r\n            _beneficiary,\r\n            weiAmount,\r\n            tokens\r\n        );\r\n\r\n    }\r\n\r\n\r\n    function setState(State _state) internal {\r\n        currentState = _state;\r\n        emit LogStateSwitch(_state);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pauseCrowdsale() public onlyOwner {\r\n        token.pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpauseCrowdsale() public onlyOwner {\r\n        token.unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the DAO to set new rate\r\n     */\r\n    function setRate(uint256 _newRate) public onlyDAO {\r\n        rate = _newRate;\r\n    }\r\n\r\n    /**\r\n     * @dev function set kyc bool to true\r\n     * @param _investor The investor who passed the procedure KYC\r\n     */\r\n    function setKYCpassed(address _investor) public onlyDAO returns(bool){\r\n        token.kycPass(_investor);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function set kyc bool to false\r\n     * @param _investor The investor who not passed the procedure KYC after passing\r\n     */\r\n    function setKYCNotPassed(address _investor) public onlyDAO returns(bool){\r\n        token.kycNotPass(_investor);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev the function tranfer tokens from TeamAddress \r\n     */\r\n    function transferTokensFromTeamAddress(address _investor, uint256 _value) public onlyDAO returns(bool){\r\n        token.transferTokensFromSpecialAddress(address(teamAddress), _investor, _value); \r\n        return true;\r\n    } \r\n\r\n    \r\n    /**\r\n     * @dev the function tranfer tokens from BountyAddress \r\n     */\r\n    function transferTokensFromBountyAddress(address _investor, uint256 _value) public onlyDAO returns(bool){\r\n        token.transferTokensFromSpecialAddress(address(bountyAddress), _investor, _value); \r\n        return true;\r\n    } \r\n    \r\n    /**\r\n     * @dev Validation of an incoming purchase. internal function.\r\n     * @param _beneficiary Address performing the token purchase\r\n     * @param _weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view{\r\n        require(_beneficiary != address(0),\"Invalid address\");\r\n        require(_weiAmount >= minValue,\"Min amount is 0.005 ether\");\r\n        require(currentState != State.Refunding, \"Only for CrowdSale and Work stage.\");\r\n    }\r\n\r\n    /**\r\n     * @dev internal function\r\n     * @param _beneficiary Address performing the token purchase\r\n     * @param _tokenAmount Number of tokens to be emitted\r\n     */\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        token.safeTransfer(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Function transfer token to new investors\r\n     * Access restricted DAO\r\n     */ \r\n    function transferTokens(address _newInvestor, uint256 _tokenAmount) public onlyDAO {\r\n        _deliverTokens(_newInvestor, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function mint tokens to winners or prize funds contracts\r\n     * Access restricted DAO\r\n     */ \r\n    function mintTokensToWinners(address _address, uint256 _tokenAmount) public onlyDAO {\r\n        require(currentState == State.WorkTime, \"CrowdSale is not finished yet. Access denied.\");\r\n        token.mint(_address, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _tokenAmount Number of tokens to be purchased\r\n    */\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n        _deliverTokens(_beneficiary, _tokenAmount);\r\n        \r\n    }\r\n\r\n\r\n    /**\r\n    * @dev this function is ether converted to tokens.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        uint256 bonus = 0;\r\n        uint256 resultAmount = _weiAmount;\r\n\r\n\r\n        /**\r\n        * ICO bonus                        UnisTimeStamp \r\n        *                                  Start date       End date\r\n        * StartTime -01.01.2019 - 100%     1543622400       1546300800\r\n        * 01.01.2019-01.02.2019 - 50%      1546300800       1548979200\r\n        * 01.02.2019-01.03.2019 - 25%      1548979200       1551398400\r\n        */\r\n        if (now >= crowdSaleStartTime && now < 1546300800) {\r\n            bonus = 100;\r\n        }\r\n        if (now >= 1546300800 && now < 1548979200) {\r\n            bonus = 50;\r\n        }\r\n        if (now >= 1548979200 && now < 1551398400) {\r\n            bonus = 25;\r\n        }\r\n        \r\n        if (bonus > 0) {\r\n            resultAmount += _weiAmount.mul(bonus).div(100);\r\n        }\r\n        return resultAmount.mul(rate);\r\n    }\r\n\r\n    /**\r\n     * @dev function returns funds to investors in case of project failure.\r\n     */\r\n    function refund() public payable{\r\n        require(currentState == State.Refunding, \"Only for Refunding stage.\");\r\n        // refund ether to investors\r\n        uint value = crowdsaleBalances[msg.sender]; \r\n        crowdsaleBalances[msg.sender] = 0; \r\n        msg.sender.transfer(value);\r\n        emit LogRefunding(msg.sender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev function of withdrawal of funds for the development of the project if successful\r\n     */\r\n    function withdrawFunds (address _to, uint256 _value) public onlyDAO {\r\n        require(currentState == State.WorkTime, \"CrowdSale is not finished yet. Access denied.\");\r\n        require (myAddress.balance >= _value,\"Value is more than balance\");\r\n        require(_to != address(0),\"Invalid address\");\r\n        _to.transfer(_value);\r\n        emit LogWithdraw(msg.sender, _to, _value);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"crowdsaleBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromTeamAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"setKYCNotPassed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDAOContract\",\"type\":\"address\"}],\"name\":\"setDAOContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"mintTokensToWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAOContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromBountyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newInvestor\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"setKYCpassed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"LogStateSwitch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRefunding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTokensPurchased\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://05887fea05b0deb8a7d9155e2ac95647bad57be9900bc9ca408fbd3150463c2e"}]}