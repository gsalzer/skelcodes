{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @summary: CryptoRome Land ERC-998 Bottom-Up Composable NFT Contract (and additional helper contracts)\r\n * @author: GigLabs, LLC\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n *  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\n */\r\ninterface ERC721 /* is ERC165 */ {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _tokenOwner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _tokenOwner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _tokenOwner) external view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address _tokenOwner);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address _operator);\r\n    function isApprovedForAll(address _tokenOwner, address _operator) external view returns (bool);\r\n}\r\n \r\n \r\n/**\r\n * @notice Query if a contract implements an interface\r\n * @dev Interface identification is specified in ERC-165. This function\r\n * uses less than 30,000 gas.\r\n */\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    /** \r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `transfer`. This function MAY throw to revert and reject the\r\n     * transfer. Return of other than the magic value MUST result in the\r\n     * transaction being reverted.\r\n     * Note: the contract address is always the message sender.\r\n     * @param _operator The address which called `safeTransferFrom` function\r\n     * @param _from The address which previously owned the token\r\n     * @param _tokenId The NFT identifier which is being transferred\r\n     * @param _data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     * unless throwing\r\n     */\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n * Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\n */\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    function name() external view returns (string _name);\r\n    function symbol() external view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n * Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\n */\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title ERC998ERC721 Bottom-Up Composable Non-Fungible Token\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md\r\n * Note: the ERC-165 identifier for this interface is 0xa1b23002\r\n */\r\ninterface ERC998ERC721BottomUp {\r\n    event TransferToParent(address indexed _toContract, uint256 indexed _toTokenId, uint256 _tokenId);\r\n    event TransferFromParent(address indexed _fromContract, uint256 indexed _fromTokenId, uint256 _tokenId);\r\n\r\n\r\n    function rootOwnerOf(uint256 _tokenId) public view returns (bytes32 rootOwner);\r\n\r\n    /**\r\n    * The tokenOwnerOf function gets the owner of the _tokenId which can be a user address or another ERC721 token.\r\n    * The tokenOwner address return value can be either a user address or an ERC721 contract address.\r\n    * If the tokenOwner address is a user address then parentTokenId will be 0 and should not be used or considered.\r\n    * If tokenOwner address is a user address then isParent is false, otherwise isChild is true, which means that\r\n    * tokenOwner is an ERC721 contract address and _tokenId is a child of tokenOwner and parentTokenId.\r\n    */\r\n    function tokenOwnerOf(uint256 _tokenId) external view returns (bytes32 tokenOwner, uint256 parentTokenId, bool isParent);\r\n\r\n    // Transfers _tokenId as a child to _toContract and _toTokenId\r\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) public;\r\n    // Transfers _tokenId from a parent ERC721 token to a user address.\r\n    function transferFromParent(address _fromContract, uint256 _fromTokenId, address _to, uint256 _tokenId, bytes _data) public;\r\n    // Transfers _tokenId from a parent ERC721 token to a parent ERC721 token.\r\n    function transferAsChild(address _fromContract, uint256 _fromTokenId, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;\r\n\r\n}\r\n\r\n/**\r\n * @title ERC998ERC721 Bottom-Up Composable, optional enumerable extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md\r\n * Note: The ERC-165 identifier for this interface is 0x8318b539\r\n */\r\ninterface ERC998ERC721BottomUpEnumerable {\r\n    function totalChildTokens(address _parentContract, uint256 _parentTokenId) external view returns (uint256);\r\n    function childTokenByIndex(address _parentContract, uint256 _parentTokenId, uint256 _index) external view returns (uint256);\r\n}\r\n\r\ncontract ERC998ERC721BottomUpToken is ERC721, ERC721Metadata, ERC721Enumerable, ERC165, ERC998ERC721BottomUp, ERC998ERC721BottomUpEnumerable {\r\n    using SafeMath for uint256;\r\n\r\n    struct TokenOwner {\r\n        address tokenOwner;\r\n        uint256 parentTokenId;\r\n    }\r\n\r\n    // return this.rootOwnerOf.selector ^ this.rootOwnerOfChild.selector ^\r\n    //   this.tokenOwnerOf.selector ^ this.ownerOfChild.selector;\r\n    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;\r\n\r\n    // total number of tokens\r\n    uint256 internal tokenCount;\r\n\r\n    // tokenId => token owner\r\n    mapping(uint256 => TokenOwner) internal tokenIdToTokenOwner;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) internal ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint256[])) internal parentToChildTokenIds;\r\n\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n\r\n    // Token name\r\n    string internal name_;\r\n\r\n    // Token symbol\r\n    string internal symbol_;\r\n\r\n    // Token URI\r\n    string internal tokenURIBase;\r\n\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    //from zepellin ERC721Receiver.sol\r\n    //old version\r\n    bytes4 constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(_addr)}\r\n        return size > 0;\r\n    }\r\n\r\n    constructor () public {\r\n        //ERC165\r\n        supportedInterfaces[0x01ffc9a7] = true;\r\n        //ERC721\r\n        supportedInterfaces[0x80ac58cd] = true;\r\n        //ERC721Metadata\r\n        supportedInterfaces[0x5b5e139f] = true;\r\n        //ERC721Enumerable\r\n        supportedInterfaces[0x780e9d63] = true;\r\n        //ERC998ERC721BottomUp\r\n        supportedInterfaces[0xa1b23002] = true;\r\n        //ERC998ERC721BottomUpEnumerable\r\n        supportedInterfaces[0x8318b539] = true;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // ERC165Impl\r\n    //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // ERC721 implementation & ERC998 Authentication\r\n    //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    function balanceOf(address _tokenOwner) public view returns (uint256) {\r\n        require(_tokenOwner != address(0));\r\n        return ownedTokens[_tokenOwner].length;\r\n    }\r\n\r\n    // returns the immediate owner of the token\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address tokenOwner = tokenIdToTokenOwner[_tokenId].tokenOwner;\r\n        require(tokenOwner != address(0));\r\n        return tokenOwner;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        require(_to != address(this));\r\n        _transferFromOwnerCheck(_from, _to, _tokenId);\r\n        _transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _transferFromOwnerCheck(_from, _to, _tokenId);\r\n        _transferFrom(_from, _to, _tokenId);\r\n        require(_checkAndCallSafeTransfer(_from, _to, _tokenId, \"\"));\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\r\n        _transferFromOwnerCheck(_from, _to, _tokenId);\r\n        _transferFrom(_from, _to, _tokenId);\r\n        require(_checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    function _checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data) internal view returns (bool) {\r\n        if (!isContract(_to)) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n\r\n    function _transferFromOwnerCheck(address _from, address _to, uint256 _tokenId) internal {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require(tokenIdToTokenOwner[_tokenId].tokenOwner == _from);\r\n        require(tokenIdToTokenOwner[_tokenId].parentTokenId == 0);\r\n\r\n        // check child approved\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n        if(msg.sender != _from) {\r\n            bytes32 tokenOwner;\r\n            bool callSuccess;\r\n            // 0xeadb80b8 == ownerOfChild(address,uint256)\r\n            bytes memory calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, _from, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    tokenOwner := mload(calldata)\r\n                }\r\n            }\r\n            if(callSuccess == true) {\r\n                require(tokenOwner >> 224 != ERC998_MAGIC_VALUE);\r\n            }\r\n            require(tokenOwnerToOperators[_from][msg.sender] || approvedAddress == msg.sender);\r\n        }\r\n\r\n        // clear approval\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n            emit Approval(_from, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    function _transferFrom(address _from, address _to, uint256 _tokenId) internal {\r\n        // first remove the token from the owner list of owned tokens\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastTokenId = ownedTokens[_from][lastTokenIndex];\r\n        if (lastTokenId != _tokenId) {\r\n            // replace the _tokenId in the list of ownedTokens with the\r\n            // last token id in the list. Make sure ownedTokensIndex gets updated\r\n            // with the new position of the last token id as well.\r\n            uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n            ownedTokens[_from][tokenIndex] = lastTokenId;\r\n            ownedTokensIndex[lastTokenId] = tokenIndex;\r\n        }\r\n\r\n        // resize ownedTokens array (automatically deletes the last array entry)\r\n        ownedTokens[_from].length--;\r\n\r\n        // transfer token\r\n        tokenIdToTokenOwner[_tokenId].tokenOwner = _to;\r\n        \r\n        // add token to the new owner's list of owned tokens\r\n        ownedTokensIndex[_tokenId] = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external {\r\n        address tokenOwner = tokenIdToTokenOwner[_tokenId].tokenOwner;\r\n        require(tokenOwner != address(0));\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender]);\r\n\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] = _approved;\r\n        emit Approval(rootOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address)  {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        return rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        require(_operator != address(0));\r\n        tokenOwnerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool)  {\r\n        require(_owner != address(0));\r\n        require(_operator != address(0));\r\n        return tokenOwnerToOperators[_owner][_operator];\r\n    }\r\n\r\n    function _tokenOwnerOf(uint256 _tokenId) internal view returns (address tokenOwner, uint256 parentTokenId, bool isParent) {\r\n        tokenOwner = tokenIdToTokenOwner[_tokenId].tokenOwner;\r\n        require(tokenOwner != address(0));\r\n        parentTokenId = tokenIdToTokenOwner[_tokenId].parentTokenId;\r\n        if (parentTokenId > 0) {\r\n            isParent = true;\r\n            parentTokenId--;\r\n        }\r\n        else {\r\n            isParent = false;\r\n        }\r\n        return (tokenOwner, parentTokenId, isParent);\r\n    }\r\n\r\n    \r\n    function tokenOwnerOf(uint256 _tokenId) external view returns (bytes32 tokenOwner, uint256 parentTokenId, bool isParent) {\r\n        address tokenOwnerAddress = tokenIdToTokenOwner[_tokenId].tokenOwner;\r\n        require(tokenOwnerAddress != address(0));\r\n        parentTokenId = tokenIdToTokenOwner[_tokenId].parentTokenId;\r\n        if (parentTokenId > 0) {\r\n            isParent = true;\r\n            parentTokenId--;\r\n        }\r\n        else {\r\n            isParent = false;\r\n        }\r\n        return (ERC998_MAGIC_VALUE << 224 | bytes32(tokenOwnerAddress), parentTokenId, isParent);\r\n    }\r\n\r\n    // Use Cases handled:\r\n    // Case 1: Token owner is this contract and no parent tokenId.\r\n    // Case 2: Token owner is this contract and token\r\n    // Case 3: Token owner is top-down composable\r\n    // Case 4: Token owner is an unknown contract\r\n    // Case 5: Token owner is a user\r\n    // Case 6: Token owner is a bottom-up composable\r\n    // Case 7: Token owner is ERC721 token owned by top-down token\r\n    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n    // Case 9: Token owner is ERC721 token owned by user\r\n    function rootOwnerOf(uint256 _tokenId) public view returns (bytes32 rootOwner) {\r\n        address rootOwnerAddress = tokenIdToTokenOwner[_tokenId].tokenOwner;\r\n        require(rootOwnerAddress != address(0));\r\n        uint256 parentTokenId = tokenIdToTokenOwner[_tokenId].parentTokenId;\r\n        bool isParent = parentTokenId > 0;\r\n        if (isParent) {\r\n            parentTokenId--;\r\n        }\r\n\r\n        if((rootOwnerAddress == address(this))) {\r\n            do {\r\n                if(isParent == false) {\r\n                    // Case 1: Token owner is this contract and no token.\r\n                    // This case should not happen.\r\n                    return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n                }\r\n                else {\r\n                    // Case 2: Token owner is this contract and token\r\n                    (rootOwnerAddress, parentTokenId, isParent) = _tokenOwnerOf(parentTokenId);\r\n                }\r\n            } while(rootOwnerAddress == address(this));\r\n            _tokenId = parentTokenId;\r\n        }\r\n\r\n        bytes memory calldata;\r\n        bool callSuccess;\r\n\r\n        if (isParent == false) {\r\n\r\n            // success if this token is owned by a top-down token\r\n            // 0xed81cdda == rootOwnerOfChild(address, uint256)\r\n            calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if(callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 3: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // Case 4: Token owner is an unknown contract\r\n                // Or\r\n                // Case 5: Token owner is a user\r\n                return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n            }\r\n        }\r\n        else {\r\n\r\n            // 0x43a61a8e == rootOwnerOf(uint256)\r\n            calldata = abi.encodeWithSelector(0x43a61a8e, parentTokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 6: Token owner is a bottom-up composable\r\n                // Or\r\n                // Case 2: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // token owner is ERC721\r\n                address childContract = rootOwnerAddress;\r\n                //0x6352211e == \"ownerOf(uint256)\"\r\n                calldata = abi.encodeWithSelector(0x6352211e, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwnerAddress := mload(calldata)\r\n                    }\r\n                }\r\n                require(callSuccess);\r\n\r\n                // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n                calldata = abi.encodeWithSelector(0xed81cdda, childContract, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwner := mload(calldata)\r\n                    }\r\n                }\r\n                if(callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                    // Case 7: Token owner is ERC721 token owned by top-down token\r\n                    return rootOwner;\r\n                }\r\n                else {\r\n                    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n                    // Or\r\n                    // Case 9: Token owner is ERC721 token owned by user\r\n                    return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // List of all Land Tokens assigned to an address.\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        return ownedTokens[_owner];\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // ERC721MetadataImpl\r\n    //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string) {\r\n        require (exists(_tokenId));\r\n        return _appendUintToString(tokenURIBase, _tokenId);\r\n    }\r\n\r\n    function name() external view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    function symbol() external view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    function _appendUintToString(string inStr, uint v) private pure returns (string str) {\r\n        uint maxlength = 100;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n            uint remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = byte(48 + remainder);\r\n        }\r\n        bytes memory inStrb = bytes(inStr);\r\n        bytes memory s = new bytes(inStrb.length + i);\r\n        uint j;\r\n        for (j = 0; j < inStrb.length; j++) {\r\n            s[j] = inStrb[j];\r\n        }\r\n        for (j = 0; j < i; j++) {\r\n            s[j + inStrb.length] = reversed[i - 1 - j];\r\n        }\r\n        str = string(s);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // ERC721EnumerableImpl\r\n    //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        return _tokenId < tokenCount;\r\n    }\r\n \r\n    function totalSupply() external view returns (uint256) {\r\n        return tokenCount;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _tokenOwner, uint256 _index) external view returns (uint256 tokenId) {\r\n        require(_index < ownedTokens[_tokenOwner].length);\r\n        return ownedTokens[_tokenOwner][_index];\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view returns (uint256 tokenId) {\r\n        require(_index < tokenCount);\r\n        return _index;\r\n    }\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require (_to != address(0));\r\n        require (tokenIdToTokenOwner[_tokenId].tokenOwner == address(0));\r\n        tokenIdToTokenOwner[_tokenId].tokenOwner = _to;\r\n        ownedTokensIndex[_tokenId] = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        tokenCount++;\r\n\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // ERC998 Bottom-Up implementation (extenstion of ERC-721)\r\n    //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n\r\n    function _removeChild(address _fromContract, uint256 _fromTokenId, uint256 _tokenId) internal {\r\n        uint256 lastChildTokenIndex = parentToChildTokenIds[_fromContract][_fromTokenId].length - 1;\r\n        uint256 lastChildTokenId = parentToChildTokenIds[_fromContract][_fromTokenId][lastChildTokenIndex];\r\n\r\n        if (_tokenId != lastChildTokenId) {\r\n            uint256 currentChildTokenIndex = tokenIdToChildTokenIdsIndex[_tokenId];\r\n            parentToChildTokenIds[_fromContract][_fromTokenId][currentChildTokenIndex] = lastChildTokenId;\r\n            tokenIdToChildTokenIdsIndex[lastChildTokenId] = currentChildTokenIndex;\r\n        }\r\n        parentToChildTokenIds[_fromContract][_fromTokenId].length--;\r\n    }\r\n\r\n    function _transferChild(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId) internal {\r\n        tokenIdToTokenOwner[_tokenId].parentTokenId = _toTokenId.add(1);\r\n        uint256 index = parentToChildTokenIds[_toContract][_toTokenId].length;\r\n        parentToChildTokenIds[_toContract][_toTokenId].push(_tokenId);\r\n        tokenIdToChildTokenIdsIndex[_tokenId] = index;\r\n\r\n        _transferFrom(_from, _toContract, _tokenId);\r\n        \r\n        require(ERC721(_toContract).ownerOf(_toTokenId) != address(0));\r\n        emit TransferToParent(_toContract, _toTokenId, _tokenId);\r\n    }\r\n\r\n    function _removeFromToken(address _fromContract, uint256 _fromTokenId, address _to, uint256 _tokenId) internal {\r\n        require(_fromContract != address(0));\r\n        require(_to != address(0));\r\n        require(tokenIdToTokenOwner[_tokenId].tokenOwner == _fromContract);\r\n        uint256 parentTokenId = tokenIdToTokenOwner[_tokenId].parentTokenId;\r\n        require(parentTokenId != 0);\r\n        require(parentTokenId - 1 == _fromTokenId);\r\n\r\n        // authenticate\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] || approvedAddress == msg.sender);\r\n\r\n        // clear approval\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n            emit Approval(rootOwner, address(0), _tokenId);\r\n        }\r\n\r\n        tokenIdToTokenOwner[_tokenId].parentTokenId = 0;\r\n\r\n        _removeChild(_fromContract, _fromTokenId, _tokenId);\r\n        emit TransferFromParent(_fromContract, _fromTokenId, _tokenId);\r\n    }\r\n\r\n    function transferFromParent(address _fromContract, uint256 _fromTokenId, address _to, uint256 _tokenId, bytes _data) public {\r\n        _removeFromToken(_fromContract, _fromTokenId, _to, _tokenId);\r\n        delete tokenIdToChildTokenIdsIndex[_tokenId];\r\n        _transferFrom(_fromContract, _to, _tokenId);\r\n        require(_checkAndCallSafeTransfer(_fromContract, _to, _tokenId, _data));\r\n    }\r\n\r\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) public {\r\n        _transferFromOwnerCheck(_from, _toContract, _tokenId);\r\n        _transferChild(_from, _toContract, _toTokenId, _tokenId);\r\n    }\r\n\r\n    function transferAsChild(address _fromContract, uint256 _fromTokenId, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external {\r\n        _removeFromToken(_fromContract, _fromTokenId, _toContract, _tokenId);\r\n        _transferChild(_fromContract, _toContract, _toTokenId, _tokenId);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // ERC998 Bottom-Up Enumerable Implementation\r\n    //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n\r\n    function totalChildTokens(address _parentContract, uint256 _parentTokenId) public view returns (uint256) {\r\n        return parentToChildTokenIds[_parentContract][_parentTokenId].length;\r\n    }\r\n\r\n    function childTokenByIndex(address _parentContract, uint256 _parentTokenId, uint256 _index) public view returns (uint256) {\r\n        require(parentToChildTokenIds[_parentContract][_parentTokenId].length > _index);\r\n        return parentToChildTokenIds[_parentContract][_parentTokenId][_index];\r\n    }\r\n}\r\n\r\n\r\ncontract CryptoRomeControl {\r\n\r\n    // Emited when contract is upgraded or ownership changed\r\n    event ContractUpgrade(address newContract);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Has control of (most) contract elements\r\n    address public ownerPrimary;\r\n    address public ownerSecondary;\r\n\r\n    // Address of owner wallet to transfer funds\r\n    address public ownerWallet;\r\n    address public cryptoRomeWallet;\r\n\r\n    // Contracts that need access for gameplay\r\n    // (state = 1 means access is active, state = 0 means disabled)\r\n    mapping(address => uint8) public otherOperators;\r\n\r\n    // Improvement contract is the only authorized address that can modify \r\n    // existing land data (ex. when player purchases a land improvement). No one else can\r\n    // modify land - even owners of this contract\r\n    address public improvementContract;\r\n\r\n    // Tracks if contract is paused or not. If paused, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    constructor() public {\r\n        ownerPrimary = msg.sender;\r\n        ownerSecondary = msg.sender;\r\n        ownerWallet = msg.sender;\r\n        cryptoRomeWallet = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require (msg.sender == ownerPrimary || msg.sender == ownerSecondary);\r\n        _;\r\n    }\r\n\r\n    modifier anyOperator() {\r\n        require (\r\n            msg.sender == ownerPrimary ||\r\n            msg.sender == ownerSecondary ||\r\n            otherOperators[msg.sender] == 1\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOtherOperators() {\r\n        require (otherOperators[msg.sender] == 1);\r\n        _;\r\n    }\r\n\r\n    modifier onlyImprovementContract() {\r\n        require (msg.sender == improvementContract);\r\n        _;\r\n    }\r\n\r\n    function setPrimaryOwner(address _newOwner) external onlyOwner {\r\n        require (_newOwner != address(0));\r\n        emit OwnershipTransferred(ownerPrimary, _newOwner);\r\n        ownerPrimary = _newOwner;\r\n    }\r\n\r\n    function setSecondaryOwner(address _newOwner) external onlyOwner {\r\n        require (_newOwner != address(0));\r\n        emit OwnershipTransferred(ownerSecondary, _newOwner);\r\n        ownerSecondary = _newOwner;\r\n    }\r\n\r\n    function setOtherOperator(address _newOperator, uint8 _state) external onlyOwner {\r\n        require (_newOperator != address(0));\r\n        otherOperators[_newOperator] = _state;\r\n    }\r\n\r\n    function setImprovementContract(address _improvementContract) external onlyOwner {\r\n        require (_improvementContract != address(0));\r\n        emit OwnershipTransferred(improvementContract, _improvementContract);\r\n        improvementContract = _improvementContract;\r\n    }\r\n\r\n    function transferOwnerWalletOwnership(address newWalletAddress) onlyOwner external {\r\n        require(newWalletAddress != address(0));\r\n        ownerWallet = newWalletAddress;\r\n    }\r\n\r\n    function transferCryptoRomeWalletOwnership(address newWalletAddress) onlyOwner external {\r\n        require(newWalletAddress != address(0));\r\n        cryptoRomeWallet = newWalletAddress;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n    }\r\n\r\n    function withdrawBalance() public onlyOwner {\r\n        ownerWallet.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\ncontract CryptoRomeLandComposableNFT is ERC998ERC721BottomUpToken, CryptoRomeControl {\r\n    using SafeMath for uint256;\r\n\r\n    // Set in case the contract needs to be updated\r\n    address public newContractAddress;\r\n\r\n    struct LandInfo {\r\n        uint256 landType;  // 0-4  unit, plot, village, town, city (unit unused)\r\n        uint256 landImprovements; \r\n        uint256 askingPrice;\r\n    }\r\n\r\n    mapping(uint256 => LandInfo) internal tokenIdToLand;\r\n\r\n    // for sale state of all tokens. tokens map to bits. 0 = not for sale; 1 = for sale\r\n    // 256 token states per index of this array\r\n    uint256[] internal allLandForSaleState;\r\n\r\n    // landType => land count\r\n    mapping(uint256 => uint256) internal landTypeToCount;\r\n\r\n    // total number of villages in existence is 50000 (no more can be created)\r\n    uint256 constant internal MAX_VILLAGES = 50000;\r\n\r\n    constructor () public {\r\n        paused = true;\r\n        name_ = \"CryptoRome-Land-NFT\";\r\n        symbol_ = \"CRLAND\";\r\n    }\r\n\r\n    function isCryptoRomeLandComposableNFT() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function getLandTypeCount(uint256 _landType) public view returns (uint256) {\r\n        return landTypeToCount[_landType];\r\n    }\r\n\r\n    function setTokenURI(string _tokenURI) external anyOperator {\r\n        tokenURIBase = _tokenURI;\r\n    }\r\n\r\n    function setNewAddress(address _v2Address) external onlyOwner {\r\n        require (_v2Address != address(0));\r\n        newContractAddress = _v2Address;\r\n        emit ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    // Get Land\r\n    //   Token Owner: Address of the token owner\r\n    //   Parent Token Id: If parentTokenId is > 0, then this land\r\n    //      token is owned by another token (i.e. it is attached bottom-up).\r\n    //      parentTokenId is the id of the owner token, and tokenOwner\r\n    //      address (the first parameter) is the ERC721 contract address of the  \r\n    //      parent token. If parentTokenId == 0, then this land token is owned\r\n    //      by a user address.\r\n    //   Land Types: village=1, town=2, city=3\r\n    //   Land Improvements: improvements and upgrades\r\n    //      to each land NFT are coded into a single uint256 value\r\n    //   Asking Price (in wei): 0 if land is not for sale\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    function getLand(uint256 _tokenId) external view\r\n        returns (\r\n            address tokenOwner,\r\n            uint256 parentTokenId,\r\n            uint256 landType,\r\n            uint256 landImprovements,\r\n            uint256 askingPrice\r\n        ) {\r\n        TokenOwner storage owner = tokenIdToTokenOwner[_tokenId];\r\n        LandInfo storage land = tokenIdToLand[_tokenId];\r\n\r\n        parentTokenId = owner.parentTokenId;\r\n        if (parentTokenId > 0) {\r\n            parentTokenId--;\r\n        }\r\n        tokenOwner = owner.tokenOwner;\r\n        parentTokenId = owner.parentTokenId;\r\n        landType = land.landType;\r\n        landImprovements = land.landImprovements;\r\n        askingPrice = land.askingPrice;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    // Create Land NFT\r\n    //   Land Types: village=1, town=2, city=3\r\n    //   Land Improvements: improvements and upgrades\r\n    //      to each land NFT are the coded into a uint256 value\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    function _createLand (address _tokenOwner, uint256 _landType, uint256 _landImprovements) internal returns (uint256 tokenId) {\r\n        require(_tokenOwner != address(0));\r\n        require(landTypeToCount[1] < MAX_VILLAGES);\r\n        tokenId = tokenCount;\r\n\r\n        LandInfo memory land = LandInfo({\r\n            landType: _landType,  // 1-3  village, town, city\r\n            landImprovements: _landImprovements,\r\n            askingPrice: 0\r\n        });\r\n        \r\n        // map new tokenId to the newly created land      \r\n        tokenIdToLand[tokenId] = land;\r\n        landTypeToCount[_landType]++;\r\n\r\n        if (tokenId % 256 == 0) {\r\n            // create new land sale state entry in storage\r\n            allLandForSaleState.push(0);\r\n        }\r\n\r\n        _mint(_tokenOwner, tokenId);\r\n\r\n        return tokenId;\r\n    }\r\n    \r\n    function createLand (address _tokenOwner, uint256 _landType, uint256 _landImprovements) external anyOperator whenNotPaused returns (uint256 tokenId) {\r\n        return _createLand (_tokenOwner, _landType, _landImprovements);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    // Land Improvement Data\r\n    //   This uint256 land \"dna\" value describes all improvements and upgrades \r\n    //   to a piece of land. After land token distribution, only the Improvement\r\n    //   Contract can ever update or modify the land improvement data of a piece\r\n    //   of land (contract owner cannot modify land).\r\n    //\r\n    // For villages, improvementData is a uint256 value containing village\r\n    // improvement data with the following slot bit mapping\r\n    //     0-31:     slot 1 improvement info\r\n    //     32-63:    slot 2 improvement info\r\n    //     64-95:    slot 3 improvement info\r\n    //     96-127:   slot 4 improvement info\r\n    //     128-159:  slot 5 improvement info\r\n    //     160-191:  slot 6 improvement info\r\n    //     192-255:  reserved for additional land information\r\n    //\r\n    // Each 32 bit slot in the above structure has the following bit mapping\r\n    //     0-7:      improvement type (index to global list of possible types)\r\n    //     8-14:     upgrade type 1 - level 0-99  (0 for no upgrade present)\r\n    //     15-21:    upgrade type 2 - level 0-99  (0 for no upgrade present)\r\n    //     22:       upgrade type 3 - 1 if upgrade present, 0 if not (no leveling)\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    function getLandImprovementData(uint256 _tokenId) external view returns (uint256) {\r\n        return tokenIdToLand[_tokenId].landImprovements;\r\n    }\r\n\r\n    function updateLandImprovementData(uint256 _tokenId, uint256 _newLandImprovementData) external whenNotPaused onlyImprovementContract {\r\n        require(_tokenId <= tokenCount);\r\n        tokenIdToLand[_tokenId].landImprovements = _newLandImprovementData;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    // Land Compose/Decompose functions\r\n    //   Towns are composed of 3 Villages\r\n    //   Cities are composed of 3 Towns\r\n    /////////////////////////////////////////////////////////////////////////////\r\n\r\n    // Attach three child land tokens onto a parent land token (ex. 3 villages onto a town).\r\n    // This function is called when the parent does not exist yet, so create parent land token first\r\n    // Ownership of the child lands transfers from the existing owner (sender) to the parent land token\r\n    function composeNewLand(uint256 _landType, uint256 _childLand1, uint256 _childLand2, uint256 _childLand3) external whenNotPaused returns(uint256) {\r\n        uint256 parentTokenId = _createLand(msg.sender, _landType, 0);\r\n        return composeLand(parentTokenId, _childLand1, _childLand2, _childLand3);\r\n    }\r\n\r\n    // Attach three child land tokens onto a parent land token (ex. 3 villages into a town).\r\n    // All three children and an existing parent need to be passed into this function.\r\n    // Ownership of the child lands transfers from the existing owner (sender) to the parent land token\r\n    function composeLand(uint256 _parentLandId, uint256 _childLand1, uint256 _childLand2, uint256 _childLand3) public whenNotPaused returns(uint256) {\r\n        require (tokenIdToLand[_parentLandId].landType == 2 || tokenIdToLand[_parentLandId].landType == 3);\r\n        uint256 validChildLandType = tokenIdToLand[_parentLandId].landType.sub(1);\r\n        require(tokenIdToLand[_childLand1].landType == validChildLandType &&\r\n                tokenIdToLand[_childLand2].landType == validChildLandType &&\r\n                tokenIdToLand[_childLand3].landType == validChildLandType);\r\n\r\n        // transfer ownership of child land tokens to parent land token\r\n        transferToParent(tokenIdToTokenOwner[_childLand1].tokenOwner, address(this), _parentLandId, _childLand1, \"\");\r\n        transferToParent(tokenIdToTokenOwner[_childLand2].tokenOwner, address(this), _parentLandId, _childLand2, \"\");\r\n        transferToParent(tokenIdToTokenOwner[_childLand3].tokenOwner, address(this), _parentLandId, _childLand3, \"\");\r\n\r\n        // if this contract is owner of the parent land token, transfer ownership to msg.sender\r\n        if (tokenIdToTokenOwner[_parentLandId].tokenOwner == address(this)) {\r\n            _transferFrom(address(this), msg.sender, _parentLandId);\r\n        }\r\n\r\n        return _parentLandId;\r\n    }\r\n\r\n    // Decompose a parent land back to it's attached child land token components (ex. a town into 3 villages).\r\n    // The existing owner of the parent land becomes the owner of the three child tokens\r\n    // This contract takes over ownership of the parent land token (for later reuse)\r\n    // Loop to remove and transfer all land tokens in case other land tokens are attached.\r\n    function decomposeLand(uint256 _tokenId) external whenNotPaused {\r\n        uint256 numChildren = totalChildTokens(address(this), _tokenId);\r\n        require (numChildren > 0);\r\n\r\n        // it is lower gas cost to remove children starting from the end of the array\r\n        for (uint256 numChild = numChildren; numChild > 0; numChild--) {\r\n            uint256 childTokenId = childTokenByIndex(address(this), _tokenId, numChild-1);\r\n\r\n            // transfer ownership of underlying lands to msg.sender\r\n            transferFromParent(address(this), _tokenId, msg.sender, childTokenId, \"\");\r\n        }\r\n\r\n        // transfer ownership of parent land back to this contract owner for reuse\r\n        _transferFrom(msg.sender, address(this), _tokenId);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    // Sale functions\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    function _updateSaleData(uint256 _tokenId, uint256 _askingPrice) internal {\r\n        tokenIdToLand[_tokenId].askingPrice = _askingPrice;\r\n        if (_askingPrice > 0) {\r\n            // Item is for sale - set bit\r\n            allLandForSaleState[_tokenId.div(256)] = allLandForSaleState[_tokenId.div(256)] | (1 << (_tokenId % 256));\r\n        } else {\r\n            // Item is no longer for sale - clear bit\r\n            allLandForSaleState[_tokenId.div(256)] = allLandForSaleState[_tokenId.div(256)] & ~(1 << (_tokenId % 256));\r\n        }\r\n    }\r\n\r\n    function sellLand(uint256 _tokenId, uint256 _askingPrice) public whenNotPaused {\r\n        require(tokenIdToTokenOwner[_tokenId].tokenOwner == msg.sender);\r\n        require(tokenIdToTokenOwner[_tokenId].parentTokenId == 0);\r\n        require(_askingPrice > 0);\r\n        // Put the land token on the market\r\n        _updateSaleData(_tokenId, _askingPrice);\r\n    }\r\n\r\n    function cancelLandSale(uint256 _tokenId) public whenNotPaused {\r\n        require(tokenIdToTokenOwner[_tokenId].tokenOwner == msg.sender);\r\n        // Take the land token off the market\r\n        _updateSaleData(_tokenId, 0);\r\n    }\r\n\r\n    function purchaseLand(uint256 _tokenId) public whenNotPaused payable {\r\n        uint256 price = tokenIdToLand[_tokenId].askingPrice;\r\n        require(price <= msg.value);\r\n\r\n        // Take the land token off the market\r\n        _updateSaleData(_tokenId, 0);\r\n\r\n        // Marketplace fee\r\n        uint256 marketFee = computeFee(price);\r\n        uint256 sellerProceeds = msg.value.sub(marketFee);\r\n        cryptoRomeWallet.transfer(marketFee);\r\n\r\n        // Return excess payment to sender\r\n        uint256 excessPayment = msg.value.sub(price);\r\n        msg.sender.transfer(excessPayment);\r\n\r\n        // Transfer proceeds to seller. Sale was removed above before this transfer()\r\n        // to guard against reentrancy attacks\r\n        tokenIdToTokenOwner[_tokenId].tokenOwner.transfer(sellerProceeds);\r\n        // Transfer token to buyer\r\n        _transferFrom(tokenIdToTokenOwner[_tokenId].tokenOwner, msg.sender, _tokenId);\r\n    }\r\n\r\n    function getAllForSaleStatus() external view returns(uint256[]) {\r\n        // return uint256[] bitmap values up to max tokenId (for ease of querying from UI for marketplace)\r\n        //   index 0 of the uint256 holds first 256 land token status; index 1 is next 256 land tokens, etc\r\n        //   value of 1 = For Sale; 0 = Not for Sale\r\n        return allLandForSaleState;\r\n    }\r\n\r\n    function computeFee(uint256 amount) internal pure returns(uint256) {\r\n        // 3% marketplace fee, most of which will be distributed to the Caesar and Senators of CryptoRome\r\n        return amount.mul(3).div(100);\r\n    }\r\n}\r\n\r\ncontract CryptoRomeLandDistribution is CryptoRomeControl {\r\n    using SafeMath for uint256;\r\n\r\n    // Set in case the contract needs to be updated\r\n    address public newContractAddress;\r\n\r\n    CryptoRomeLandComposableNFT public cryptoRomeLandNFTContract;\r\n    ImprovementGeneration public improvementGenContract;\r\n    uint256 public villageInventoryPrice;\r\n    uint256 public numImprovementsPerVillage;\r\n\r\n    uint256 constant public LOWEST_VILLAGE_INVENTORY_PRICE = 100000000000000000; // 0.1 ETH\r\n\r\n    constructor (address _cryptoRomeLandNFTContractAddress, address _improvementGenContractAddress) public {\r\n        require (_cryptoRomeLandNFTContractAddress != address(0));\r\n        require (_improvementGenContractAddress != address(0));\r\n\r\n        paused = true;\r\n\r\n        cryptoRomeLandNFTContract = CryptoRomeLandComposableNFT(_cryptoRomeLandNFTContractAddress);\r\n        improvementGenContract = ImprovementGeneration(_improvementGenContractAddress);\r\n\r\n        villageInventoryPrice = LOWEST_VILLAGE_INVENTORY_PRICE;\r\n        numImprovementsPerVillage = 3;\r\n    }\r\n\r\n    function setNewAddress(address _v2Address) external onlyOwner {\r\n        require (_v2Address != address(0));\r\n        newContractAddress = _v2Address;\r\n        emit ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    function setCryptoRomeLandNFTContract(address _cryptoRomeLandNFTContract) external onlyOwner {\r\n        require (_cryptoRomeLandNFTContract != address(0));\r\n        cryptoRomeLandNFTContract = CryptoRomeLandComposableNFT(_cryptoRomeLandNFTContract);\r\n    }\r\n\r\n    function setImprovementGenContract(address _improvementGenContractAddress) external onlyOwner {\r\n        require (_improvementGenContractAddress != address(0));\r\n        improvementGenContract = ImprovementGeneration(_improvementGenContractAddress);\r\n    }\r\n\r\n    function setVillageInventoryPrice(uint256 _price) external onlyOwner {\r\n        require(_price >= LOWEST_VILLAGE_INVENTORY_PRICE);\r\n        villageInventoryPrice = _price;\r\n    }\r\n\r\n    function setNumImprovementsPerVillage(uint256 _numImprovements) external onlyOwner {\r\n        require(_numImprovements <= 6);\r\n        numImprovementsPerVillage = _numImprovements;\r\n    }\r\n\r\n    function purchaseFromVillageInventory(uint256 _num) external whenNotPaused payable {\r\n        uint256 price = villageInventoryPrice.mul(_num);\r\n        require (msg.value >= price);\r\n        require (_num > 0 && _num <= 50);\r\n\r\n        // Marketplace fee\r\n        uint256 marketFee = computeFee(price);\r\n        cryptoRomeWallet.transfer(marketFee);\r\n\r\n        // Return excess payment to sender\r\n        uint256 excessPayment = msg.value.sub(price);\r\n        msg.sender.transfer(excessPayment);\r\n\r\n        for (uint256 i = 0; i < _num; i++) {\r\n            // create a new village w/ random improvements and transfer the NFT to caller\r\n            _createVillageWithImprovementsFromInv(msg.sender);\r\n        }\r\n    }\r\n\r\n    function computeFee(uint256 amount) internal pure returns(uint256) {\r\n        // 3% marketplace fee, most of which will be distributed to the Caesar and Senators of CryptoRome\r\n        return amount.mul(3).div(100);\r\n    }\r\n\r\n    function batchIssueLand(address _toAddress, uint256[] _landType) external onlyOwner {\r\n        require (_toAddress != address(0));\r\n        require (_landType.length > 0);\r\n\r\n        for (uint256 i = 0; i < _landType.length; i++) {\r\n            issueLand(_toAddress, _landType[i]);\r\n        }\r\n    }\r\n\r\n    function batchIssueVillages(address _toAddress, uint256 _num) external onlyOwner {\r\n        require (_toAddress != address(0));\r\n        require (_num > 0);\r\n\r\n        for (uint256 i = 0; i < _num; i++) {\r\n            _createVillageWithImprovements(_toAddress);\r\n        }\r\n    }\r\n\r\n    function issueLand(address _toAddress, uint256 _landType) public onlyOwner returns (uint256) {\r\n        require (_toAddress != address(0));\r\n\r\n        return _createLandWithImprovements(_toAddress, _landType);\r\n    }\r\n\r\n    function batchCreateLand(uint256[] _landType) external onlyOwner {\r\n        require (_landType.length > 0);\r\n\r\n        for (uint256 i = 0; i < _landType.length; i++) {\r\n            // land created is owned by this contract for staging purposes\r\n            // (must later use transferTo or batchTransferTo)\r\n            _createLandWithImprovements(address(this), _landType[i]);\r\n        }\r\n    }\r\n\r\n    function batchCreateVillages(uint256 _num) external onlyOwner {\r\n        require (_num > 0);\r\n\r\n        for (uint256 i = 0; i < _num; i++) {\r\n            // land created is owned by this contract for staging purposes\r\n            // (must later use transferTo or batchTransferTo)\r\n            _createVillageWithImprovements(address(this));\r\n        }\r\n    }\r\n\r\n    function createLand(uint256 _landType) external onlyOwner {\r\n        // land created is owned by this contract for staging purposes\r\n        // (must later use transferTo or batchTransferTo)\r\n        _createLandWithImprovements(address(this), _landType);\r\n    }\r\n\r\n    function batchTransferTo(uint256[] _tokenIds, address _to) external onlyOwner {\r\n        require (_tokenIds.length > 0);\r\n        require (_to != address(0));\r\n\r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n            // transfers staged land out of this contract to the owners\r\n            cryptoRomeLandNFTContract.transferFrom(address(this), _to, _tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    function transferTo(uint256 _tokenId, address _to) external onlyOwner {\r\n        require (_to != address(0));\r\n\r\n        // transfers staged land out of this contract to the owners\r\n        cryptoRomeLandNFTContract.transferFrom(address(this), _to, _tokenId);\r\n    }\r\n\r\n    function issueVillageWithImprovementsForPromo(address _toAddress, uint256 numImprovements) external onlyOwner returns (uint256) {\r\n        uint256 landImprovements = improvementGenContract.genInitialResourcesForVillage(numImprovements, false);\r\n        return cryptoRomeLandNFTContract.createLand(_toAddress, 1, landImprovements);\r\n    }\r\n\r\n    function _createVillageWithImprovementsFromInv(address _toAddress) internal returns (uint256) {\r\n        uint256 landImprovements = improvementGenContract.genInitialResourcesForVillage(numImprovementsPerVillage, true);\r\n        return cryptoRomeLandNFTContract.createLand(_toAddress, 1, landImprovements);\r\n    }\r\n\r\n    function _createVillageWithImprovements(address _toAddress) internal returns (uint256) {\r\n        uint256 landImprovements = improvementGenContract.genInitialResourcesForVillage(3, false);\r\n        return cryptoRomeLandNFTContract.createLand(_toAddress, 1, landImprovements);\r\n    }\r\n\r\n    function _createLandWithImprovements(address _toAddress, uint256 _landType) internal returns (uint256) {\r\n        require (_landType > 0 && _landType < 4);\r\n\r\n        if (_landType == 1) {\r\n            return _createVillageWithImprovements(_toAddress);\r\n        } else if (_landType == 2) {\r\n            uint256 village1TokenId = _createLandWithImprovements(address(this), 1);\r\n            uint256 village2TokenId = _createLandWithImprovements(address(this), 1);\r\n            uint256 village3TokenId = _createLandWithImprovements(address(this), 1);\r\n            uint256 townTokenId = cryptoRomeLandNFTContract.createLand(_toAddress, 2, 0);\r\n            cryptoRomeLandNFTContract.composeLand(townTokenId, village1TokenId, village2TokenId, village3TokenId);\r\n            return townTokenId;\r\n        } else if (_landType == 3) {\r\n            uint256 town1TokenId = _createLandWithImprovements(address(this), 2);\r\n            uint256 town2TokenId = _createLandWithImprovements(address(this), 2);\r\n            uint256 town3TokenId = _createLandWithImprovements(address(this), 2);\r\n            uint256 cityTokenId = cryptoRomeLandNFTContract.createLand(_toAddress, 3, 0);\r\n            cryptoRomeLandNFTContract.composeLand(cityTokenId, town1TokenId, town2TokenId, town3TokenId);\r\n            return cityTokenId;\r\n        }\r\n    }\r\n}\r\n\r\ninterface RandomNumGeneration {\r\n    function getRandomNumber(uint256 seed) external returns (uint256);\r\n}\r\n\r\ncontract ImprovementGeneration is CryptoRomeControl {\r\n    using SafeMath for uint256;\r\n    \r\n    // Set in case the contract needs to be updated\r\n    address public newContractAddress;\r\n\r\n    RandomNumGeneration public randomNumberSource; \r\n    uint256 public rarityValueMax;\r\n    uint256 public latestPseudoRandomNumber;\r\n    uint8 public numResourceImprovements;\r\n\r\n    mapping(uint8 => uint256) private improvementIndexToRarityValue;\r\n\r\n    constructor () public {\r\n        // Starting Improvements\r\n        // improvement => rarity value (lower number = higher rarity) \r\n        improvementIndexToRarityValue[1] = 256;  // Wheat\r\n        improvementIndexToRarityValue[2] = 256;  // Wood\r\n        improvementIndexToRarityValue[3] = 128;  // Grapes\r\n        improvementIndexToRarityValue[4] = 128;  // Stone\r\n        improvementIndexToRarityValue[5] = 64;   // Clay\r\n        improvementIndexToRarityValue[6] = 64;   // Fish\r\n        improvementIndexToRarityValue[7] = 32;   // Horse\r\n        improvementIndexToRarityValue[8] = 16;   // Iron\r\n        improvementIndexToRarityValue[9] = 8;    // Marble\r\n        // etc --> More can be added in the future\r\n\r\n        // max resource improvement types is 63\r\n        numResourceImprovements = 9;\r\n        rarityValueMax = 952;\r\n    }\r\n\r\n    function setNewAddress(address _v2Address) external onlyOwner {\r\n        require (_v2Address != address(0));\r\n        newContractAddress = _v2Address;\r\n        emit ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    function setRandomNumGenerationContract(address _randomNumberGenAddress) external onlyOwner {\r\n        require (_randomNumberGenAddress != address(0));\r\n        randomNumberSource = RandomNumGeneration(_randomNumberGenAddress);\r\n    }\r\n\r\n    function genInitialResourcesForVillage(uint256 numImprovements, bool useRandomInput) external anyOperator returns(uint256) {\r\n        require(numImprovements <= 6);\r\n        uint256 landImprovements;\r\n\r\n        // each improvement takes up one village slot (max 6 slots)\r\n        for (uint256 i = 0; i < numImprovements; i++) {\r\n            uint8 newImprovement = generateImprovement(useRandomInput);\r\n            // each slot is a 32 bit section in the 256 bit landImprovement value\r\n            landImprovements |= uint256(newImprovement) << (32*i);\r\n        }\r\n        \r\n        return landImprovements;\r\n    }\r\n\r\n    function generateImprovement(bool useRandomSource) public anyOperator returns (uint8 newImprovement) {     \r\n        // seed does not need to be anything super fancy for initial improvement generation for villages...\r\n        // players will not be performing that operation, so this should be random enough\r\n        uint256 seed = latestPseudoRandomNumber.add(now);\r\n        if (useRandomSource) {\r\n            // for cases where players are generating land (i.e. after initial distribution of villages), there\r\n            // will need to be a better source of randomness\r\n            seed = randomNumberSource.getRandomNumber(seed);\r\n        }\r\n        \r\n        latestPseudoRandomNumber = addmod(uint256(blockhash(block.number-1)), seed, rarityValueMax);\r\n        \r\n        // do lookup for the improvement\r\n        newImprovement = lookupImprovementTypeByRarity(latestPseudoRandomNumber);\r\n    }\r\n\r\n    function lookupImprovementTypeByRarity(uint256 rarityNum) public view returns (uint8 improvementType) {\r\n        uint256 rarityIndexValue;\r\n        for (uint8 i = 1; i <= numResourceImprovements; i++) {\r\n            rarityIndexValue += improvementIndexToRarityValue[i];\r\n            if (rarityNum < rarityIndexValue) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function addNewResourceImprovementType(uint256 rarityValue) external onlyOwner {\r\n        require(rarityValue > 0);\r\n        require(numResourceImprovements < 63);\r\n\r\n        numResourceImprovements++;\r\n        rarityValueMax += rarityValue;\r\n        improvementIndexToRarityValue[numResourceImprovements] = rarityValue;\r\n    }\r\n\r\n    function updateImprovementRarityValue(uint256 rarityValue, uint8 improvementIndex) external onlyOwner {\r\n        require(rarityValue > 0);\r\n        require(improvementIndex <= numResourceImprovements);\r\n\r\n        rarityValueMax -= improvementIndexToRarityValue[improvementIndex];\r\n        rarityValueMax += rarityValue;\r\n        improvementIndexToRarityValue[improvementIndex] = rarityValue;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_parentContract\",\"type\":\"address\"},{\"name\":\"_parentTokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"childTokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWalletAddress\",\"type\":\"address\"}],\"name\":\"transferCryptoRomeWalletOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_landType\",\"type\":\"uint256\"},{\"name\":\"_landImprovements\",\"type\":\"uint256\"}],\"name\":\"createLand\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllForSaleStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptoRomeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"rootOwnerOf\",\"outputs\":[{\"name\":\"rootOwner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setPrimaryOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromContract\",\"type\":\"address\"},{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFromParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landType\",\"type\":\"uint256\"},{\"name\":\"_childLand1\",\"type\":\"uint256\"},{\"name\":\"_childLand2\",\"type\":\"uint256\"},{\"name\":\"_childLand3\",\"type\":\"uint256\"}],\"name\":\"composeNewLand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"purchaseLand\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_parentContract\",\"type\":\"address\"},{\"name\":\"_parentTokenId\",\"type\":\"uint256\"}],\"name\":\"totalChildTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenOwnerOf\",\"outputs\":[{\"name\":\"tokenOwner\",\"type\":\"bytes32\"},{\"name\":\"parentTokenId\",\"type\":\"uint256\"},{\"name\":\"isParent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"decomposeLand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerPrimary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_askingPrice\",\"type\":\"uint256\"}],\"name\":\"sellLand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landType\",\"type\":\"uint256\"}],\"name\":\"getLandTypeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLandImprovementData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromContract\",\"type\":\"address\"},{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAsChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentLandId\",\"type\":\"uint256\"},{\"name\":\"_childLand1\",\"type\":\"uint256\"},{\"name\":\"_childLand2\",\"type\":\"uint256\"},{\"name\":\"_childLand3\",\"type\":\"uint256\"}],\"name\":\"composeLand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerSecondary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWalletAddress\",\"type\":\"address\"}],\"name\":\"transferOwnerWalletOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCryptoRomeLandComposableNFT\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setSecondaryOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"improvementContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOperator\",\"type\":\"address\"},{\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setOtherOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_improvementContract\",\"type\":\"address\"}],\"name\":\"setImprovementContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newLandImprovementData\",\"type\":\"uint256\"}],\"name\":\"updateLandImprovementData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelLandSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLand\",\"outputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"parentTokenId\",\"type\":\"uint256\"},{\"name\":\"landType\",\"type\":\"uint256\"},{\"name\":\"landImprovements\",\"type\":\"uint256\"},{\"name\":\"askingPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferToParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_toContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"TransferToParent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_fromContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"TransferFromParent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"CryptoRomeLandComposableNFT","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3bac0f675bcdf51c3197b6eda1a5774c29cb9df158ccff4398ebc9bf256d9990"}]}