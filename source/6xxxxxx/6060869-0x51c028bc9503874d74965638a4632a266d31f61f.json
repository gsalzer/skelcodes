{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\npragma experimental \"v0.5.0\";\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary AddressExtension {\r\n\r\n  function isValid(address _address) internal pure returns (bool) {\r\n    return 0 != _address;\r\n  }\r\n\r\n  function isAccount(address _address) internal view returns (bool result) {\r\n    assembly {\r\n      result := iszero(extcodesize(_address))\r\n    }\r\n  }\r\n\r\n  function toBytes(address _address) internal pure returns (bytes b) {\r\n   assembly {\r\n      let m := mload(0x40)\r\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\r\n      mstore(0x40, add(m, 52))\r\n      b := m\r\n    }\r\n  }\r\n}\r\n\r\nlibrary Math {\r\n\r\n  struct Fraction {\r\n    uint256 numerator;\r\n    uint256 denominator;\r\n  }\r\n\r\n  function isPositive(Fraction memory fraction) internal pure returns (bool) {\r\n    return fraction.numerator > 0 && fraction.denominator > 0;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    r = a * b;\r\n    require((a == 0) || (r / a == b));\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    r = a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    require((r = a - b) <= a);\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    require((r = a + b) >= a);\r\n  }\r\n\r\n  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n    return x <= y ? x : y;\r\n  }\r\n\r\n  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n    return x >= y ? x : y;\r\n  }\r\n\r\n  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\r\n    r = value * m;\r\n    if (r / value == m) {\r\n      r /= d;\r\n    } else {\r\n      r = mul(value / d, m);\r\n    }\r\n  }\r\n\r\n  function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\r\n    r = value * m;\r\n    if (r / value == m) {\r\n      if (r % d == 0) {\r\n        r /= d;\r\n      } else {\r\n        r = (r / d) + 1;\r\n      }\r\n    } else {\r\n      r = mul(value / d, m);\r\n      if (value % d != 0) {\r\n        r += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDiv(x, f.numerator, f.denominator);\r\n  }\r\n\r\n  function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDivCeil(x, f.numerator, f.denominator);\r\n  }\r\n\r\n  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDiv(x, f.denominator, f.numerator);\r\n  }\r\n\r\n  function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDivCeil(x, f.denominator, f.numerator);\r\n  }\r\n\r\n  function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\r\n    return Math.Fraction({\r\n      numerator: mul(x.numerator, y.numerator),\r\n      denominator: mul(x.denominator, y.denominator)\r\n    });\r\n  }\r\n}\r\n\r\ncontract FsTKAuthority {\r\n\r\n  function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);\r\n  function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);\r\n  function validate() public pure returns (bytes4);\r\n}\r\n\r\ncontract Authorizable {\r\n\r\n  event SetFsTKAuthority(FsTKAuthority indexed _address);\r\n\r\n  modifier onlyFsTKAuthorized {\r\n    require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\r\n    _;\r\n  }\r\n  modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {\r\n    require(fstkAuthority.isApproved(hash, approveTime, approveToken));\r\n    _;\r\n  }\r\n\r\n  FsTKAuthority internal fstkAuthority;\r\n\r\n  constructor(FsTKAuthority _fstkAuthority) internal {\r\n    fstkAuthority = _fstkAuthority;\r\n  }\r\n\r\n  function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\r\n    require(_fstkAuthority.validate() == _fstkAuthority.validate.selector);\r\n    emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);\r\n  }\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function balanceOf(address owner) public view returns (uint256);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract SecureERC20 is ERC20 {\r\n\r\n  event SetERC20ApproveChecking(bool approveChecking);\r\n\r\n  function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);\r\n  function increaseAllowance(address spender, uint256 value) public returns (bool);\r\n  function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);\r\n  function setERC20ApproveChecking(bool approveChecking) public;\r\n}\r\n\r\ncontract FsTKToken {\r\n\r\n  enum DelegateMode { PublicMsgSender, PublicTxOrigin, PrivateMsgSender, PrivateTxOrigin }\r\n\r\n  event Consume(address indexed from, uint256 value, bytes32 challenge);\r\n  event IncreaseNonce(address indexed from, uint256 nonce);\r\n  event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);\r\n  event TerminateDirectDebit(address indexed debtor, address indexed receiver);\r\n  event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);\r\n\r\n  event SetMetadata(string metadata);\r\n  event SetLiquid(bool liquidity);\r\n  event SetDelegate(bool isDelegateEnable);\r\n  event SetDirectDebit(bool isDirectDebitEnable);\r\n\r\n  struct DirectDebitInfo {\r\n    uint256 amount;\r\n    uint256 startTime;\r\n    uint256 interval;\r\n  }\r\n  struct DirectDebit {\r\n    DirectDebitInfo info;\r\n    uint256 epoch;\r\n  }\r\n  struct Instrument {\r\n    uint256 allowance;\r\n    DirectDebit directDebit;\r\n  }\r\n  struct Account {\r\n    uint256 balance;\r\n    uint256 nonce;\r\n    mapping (address => Instrument) instruments;\r\n  }\r\n\r\n  function spendableAllowance(address owner, address spender) public view returns (uint256);\r\n  function transfer(uint256[] data) public returns (bool);\r\n  function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);\r\n\r\n  function nonceOf(address owner) public view returns (uint256);\r\n  function increaseNonce() public returns (bool);\r\n  function delegateTransferAndCall(\r\n    uint256 nonce,\r\n    uint256 fee,\r\n    uint256 gasAmount,\r\n    address to,\r\n    uint256 value,\r\n    bytes data,\r\n    DelegateMode mode,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) public returns (bool);\r\n\r\n  function directDebit(address debtor, address receiver) public view returns (DirectDebit);\r\n  function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);\r\n  function terminateDirectDebit(address receiver) public returns (bool);\r\n  function withdrawDirectDebit(address debtor) public returns (bool);\r\n  function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool);\r\n}\r\n\r\ncontract ERC20Like is SecureERC20, FsTKToken {\r\n  using AddressExtension for address;\r\n  using Math for uint256;\r\n\r\n  modifier liquid {\r\n    require(isLiquid);\r\n     _;\r\n  }\r\n  modifier canUseDirectDebit {\r\n    require(isDirectDebitEnable);\r\n     _;\r\n  }\r\n  modifier canDelegate {\r\n    require(isDelegateEnable);\r\n     _;\r\n  }\r\n\r\n  bool public erc20ApproveChecking;\r\n  bool public isLiquid = true;\r\n  bool public isDelegateEnable;\r\n  bool public isDirectDebitEnable;\r\n  string public metadata;\r\n  mapping(address => Account) internal accounts;\r\n\r\n  constructor(string _metadata) public {\r\n    metadata = _metadata;\r\n  }\r\n\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return accounts[owner].balance;\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint256) {\r\n    return accounts[owner].instruments[spender].allowance;\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public liquid returns (bool) {\r\n    Account storage senderAccount = accounts[msg.sender];\r\n\r\n    senderAccount.balance = senderAccount.balance.sub(value);\r\n    accounts[to].balance += value;\r\n\r\n    emit Transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {\r\n    Account storage fromAccount = accounts[from];\r\n    Instrument storage senderInstrument = fromAccount.instruments[msg.sender];\r\n\r\n    fromAccount.balance = fromAccount.balance.sub(value);\r\n    senderInstrument.allowance = senderInstrument.allowance.sub(value);\r\n    accounts[to].balance += value;\r\n\r\n    emit Transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\r\n    if (erc20ApproveChecking) {\r\n      require((value == 0) || (spenderInstrument.allowance == 0));\r\n    }\r\n\r\n    emit Approval(\r\n      msg.sender,\r\n      spender,\r\n      spenderInstrument.allowance = value\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function setERC20ApproveChecking(bool approveChecking) public {\r\n    emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);\r\n  }\r\n\r\n  function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {\r\n    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\r\n    require(spenderInstrument.allowance == expectedValue);\r\n\r\n    emit Approval(\r\n      msg.sender,\r\n      spender,\r\n      spenderInstrument.allowance = newValue\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 value) public returns (bool) {\r\n    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\r\n\r\n    emit Approval(\r\n      msg.sender,\r\n      spender,\r\n      spenderInstrument.allowance = spenderInstrument.allowance.add(value)\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {\r\n    Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\r\n\r\n    uint256 currentValue = spenderInstrument.allowance;\r\n    uint256 newValue;\r\n    if (strict) {\r\n      newValue = currentValue.sub(value);\r\n    } else if (value < currentValue) {\r\n      newValue = currentValue - value;\r\n    }\r\n\r\n    emit Approval(\r\n      msg.sender,\r\n      spender,\r\n      spenderInstrument.allowance = newValue\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function setMetadata0(string _metadata) internal {\r\n    emit SetMetadata(metadata = _metadata);\r\n  }\r\n\r\n  function setLiquid0(bool liquidity) internal {\r\n    emit SetLiquid(isLiquid = liquidity);\r\n  }\r\n\r\n  function setDelegate(bool delegate) public {\r\n    emit SetDelegate(isDelegateEnable = delegate);\r\n  }\r\n\r\n  function setDirectDebit(bool directDebit) public {\r\n    emit SetDirectDebit(isDirectDebitEnable = directDebit);\r\n  }\r\n\r\n  function spendableAllowance(address owner, address spender) public view returns (uint256) {\r\n    Account storage ownerAccount = accounts[owner];\r\n    return Math.min(\r\n      ownerAccount.instruments[spender].allowance,\r\n      ownerAccount.balance\r\n    );\r\n  }\r\n\r\n  function transfer(uint256[] data) public liquid returns (bool) {\r\n    Account storage senderAccount = accounts[msg.sender];\r\n    uint256 totalValue;\r\n\r\n    for (uint256 i = 0; i < data.length; i++) {\r\n      address receiver = address(data[i] >> 96);\r\n      uint256 value = data[i] & 0xffffffffffffffffffffffff;\r\n\r\n      totalValue = totalValue.add(value);\r\n      accounts[receiver].balance += value;\r\n\r\n      emit Transfer(msg.sender, receiver, value);\r\n    }\r\n\r\n    senderAccount.balance = senderAccount.balance.sub(totalValue);\r\n\r\n    return true;\r\n  }\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes data\r\n  )\r\n    public\r\n    payable\r\n    liquid\r\n    returns (bool)\r\n  {\r\n    require(\r\n      to != address(this) &&\r\n      data.length >= 68 &&\r\n      transfer(to, value)\r\n    );\r\n    assembly {\r\n        mstore(add(data, 36), value)\r\n        mstore(add(data, 68), caller)\r\n    }\r\n    require(to.call.value(msg.value)(data));\r\n    return true;\r\n  }\r\n\r\n  function nonceOf(address owner) public view returns (uint256) {\r\n    return accounts[owner].nonce;\r\n  }\r\n\r\n  function increaseNonce() public returns (bool) {\r\n    emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1);\r\n  }\r\n\r\n  function delegateTransferAndCall(\r\n    uint256 nonce,\r\n    uint256 fee,\r\n    uint256 gasAmount,\r\n    address to,\r\n    uint256 value,\r\n    bytes data,\r\n    DelegateMode mode,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  )\r\n    public\r\n    liquid\r\n    canDelegate\r\n    returns (bool)\r\n  {\r\n    require(to != address(this));\r\n    address signer;\r\n    address relayer;\r\n    if (mode == DelegateMode.PublicMsgSender) {\r\n      signer = ecrecover(\r\n        keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))),\r\n        v,\r\n        r,\r\n        s\r\n      );\r\n      relayer = msg.sender;\r\n    } else if (mode == DelegateMode.PublicTxOrigin) {\r\n      signer = ecrecover(\r\n        keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))),\r\n        v,\r\n        r,\r\n        s\r\n      );\r\n      relayer = tx.origin;\r\n    } else if (mode == DelegateMode.PrivateMsgSender) {\r\n      signer = ecrecover(\r\n        keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, msg.sender)),\r\n        v,\r\n        r,\r\n        s\r\n      );\r\n      relayer = msg.sender;\r\n    } else if (mode == DelegateMode.PrivateTxOrigin) {\r\n      signer = ecrecover(\r\n        keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, tx.origin)),\r\n        v,\r\n        r,\r\n        s\r\n      );\r\n      relayer = tx.origin;\r\n    } else {\r\n      revert();\r\n    }\r\n\r\n    Account storage signerAccount = accounts[signer];\r\n    require(nonce == signerAccount.nonce);\r\n    emit IncreaseNonce(signer, signerAccount.nonce += 1);\r\n\r\n    signerAccount.balance = signerAccount.balance.sub(value.add(fee));\r\n    accounts[to].balance += value;\r\n    if (fee != 0) {\r\n      accounts[relayer].balance += fee;\r\n      emit Transfer(signer, relayer, fee);\r\n    }\r\n\r\n    if (!to.isAccount() && data.length >= 68) {\r\n      assembly {\r\n        mstore(add(data, 36), value)\r\n        mstore(add(data, 68), signer)\r\n      }\r\n      if (to.call.gas(gasAmount)(data)) {\r\n        emit Transfer(signer, to, value);\r\n      } else {\r\n        signerAccount.balance += value;\r\n        accounts[to].balance -= value;\r\n      }\r\n    } else {\r\n      emit Transfer(signer, to, value);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function directDebit(address debtor, address receiver) public view returns (DirectDebit) {\r\n    return accounts[debtor].instruments[receiver].directDebit;\r\n  }\r\n\r\n  function setupDirectDebit(\r\n    address receiver,\r\n    DirectDebitInfo info\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({\r\n      info: info,\r\n      epoch: 0\r\n    });\r\n\r\n    emit SetupDirectDebit(msg.sender, receiver, info);\r\n    return true;\r\n  }\r\n\r\n  function terminateDirectDebit(address receiver) public returns (bool) {\r\n    delete accounts[msg.sender].instruments[receiver].directDebit;\r\n\r\n    emit TerminateDirectDebit(msg.sender, receiver);\r\n    return true;\r\n  }\r\n\r\n  function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\r\n    Account storage debtorAccount = accounts[debtor];\r\n    DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\r\n    uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\r\n    uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\r\n    require(amount > 0);\r\n    debtorAccount.balance = debtorAccount.balance.sub(amount);\r\n    accounts[msg.sender].balance += amount;\r\n    debit.epoch = epoch;\r\n\r\n    emit Transfer(debtor, msg.sender, amount);\r\n    return true;\r\n  }\r\n\r\n  function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\r\n    Account storage receiverAccount = accounts[msg.sender];\r\n    result = true;\r\n    uint256 total;\r\n\r\n    for (uint256 i = 0; i < debtors.length; i++) {\r\n      address debtor = debtors[i];\r\n      Account storage debtorAccount = accounts[debtor];\r\n      DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\r\n      uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\r\n      uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\r\n      require(amount > 0);\r\n      uint256 debtorBalance = debtorAccount.balance;\r\n\r\n      if (amount > debtorBalance) {\r\n        if (strict) {\r\n          revert();\r\n        }\r\n        result = false;\r\n        emit WithdrawDirectDebitFailure(debtor, msg.sender);\r\n      } else {\r\n        debtorAccount.balance = debtorBalance - amount;\r\n        total += amount;\r\n        debit.epoch = epoch;\r\n\r\n        emit Transfer(debtor, msg.sender, amount);\r\n      }\r\n    }\r\n\r\n    receiverAccount.balance += total;\r\n  }\r\n}\r\n\r\ncontract FsTKAllocation {\r\n  function initialize(uint256 _vestedAmount) public;\r\n}\r\n\r\ncontract FunderSmartToken is Authorizable, ERC20Like {\r\n\r\n  string public constant name = \"Funder Smart Token\";\r\n  string public constant symbol = \"FST\";\r\n  uint256 public constant totalSupply = 330000000 ether;\r\n  uint8 public constant decimals = 18;\r\n\r\n  constructor(\r\n    FsTKAuthority _fstkAuthority,\r\n    string _metadata,\r\n    address coldWallet,\r\n    FsTKAllocation allocation\r\n  )\r\n    Authorizable(_fstkAuthority)\r\n    ERC20Like(_metadata)\r\n    public\r\n  {\r\n    uint256 vestedAmount = totalSupply / 12;\r\n    accounts[allocation].balance = vestedAmount;\r\n    emit Transfer(address(0), allocation, vestedAmount);\r\n    allocation.initialize(vestedAmount);\r\n\r\n    uint256 releaseAmount = totalSupply - vestedAmount;\r\n    accounts[coldWallet].balance = releaseAmount;\r\n\r\n    emit Transfer(address(0), coldWallet, releaseAmount);\r\n  }\r\n\r\n  function setMetadata(string infoUrl) public onlyFsTKAuthorized {\r\n    setMetadata0(infoUrl);\r\n  }\r\n\r\n  function setLiquid(bool liquidity) public onlyFsTKAuthorized {\r\n    setLiquid0(liquidity);\r\n  }\r\n\r\n  function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized {\r\n    super.setERC20ApproveChecking(approveChecking);\r\n  }\r\n\r\n  function setDelegate(bool delegate) public onlyFsTKAuthorized {\r\n    super.setDelegate(delegate);\r\n  }\r\n\r\n  function setDirectDebit(bool directDebit) public onlyFsTKAuthorized {\r\n    super.setDirectDebit(directDebit);\r\n  }\r\n\r\n  function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {\r\n    erc20.transfer(to, value);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"terminateDirectDebit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approveChecking\",\"type\":\"bool\"}],\"name\":\"setERC20ApproveChecking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"bool\"}],\"name\":\"setDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"strict\",\"type\":\"bool\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"debtor\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"directDebit\",\"outputs\":[{\"components\":[{\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"info\",\"type\":\"tuple\"},{\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"liquidity\",\"type\":\"bool\"}],\"name\":\"setLiquid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"expectedValue\",\"type\":\"uint256\"},{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDelegateEnable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLiquid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"spendableAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fstkAuthority\",\"type\":\"address\"}],\"name\":\"setFsTKAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"debtors\",\"type\":\"address[]\"},{\"name\":\"strict\",\"type\":\"bool\"}],\"name\":\"withdrawDirectDebit\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"directDebit\",\"type\":\"bool\"}],\"name\":\"setDirectDebit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"setupDirectDebit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"gasAmount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"mode\",\"type\":\"uint8\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateTransferAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDirectDebitEnable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"debtor\",\"type\":\"address\"}],\"name\":\"withdrawDirectDebit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"increaseNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20ApproveChecking\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fstkAuthority\",\"type\":\"address\"},{\"name\":\"_metadata\",\"type\":\"string\"},{\"name\":\"coldWallet\",\"type\":\"address\"},{\"name\":\"allocation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challenge\",\"type\":\"bytes32\"}],\"name\":\"Consume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"IncreaseNonce\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"SetupDirectDebit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"TerminateDirectDebit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"WithdrawDirectDebitFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"SetMetadata\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"liquidity\",\"type\":\"bool\"}],\"name\":\"SetLiquid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isDelegateEnable\",\"type\":\"bool\"}],\"name\":\"SetDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isDirectDebitEnable\",\"type\":\"bool\"}],\"name\":\"SetDirectDebit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"approveChecking\",\"type\":\"bool\"}],\"name\":\"SetERC20ApproveChecking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"SetFsTKAuthority\",\"type\":\"event\"}]","ContractName":"FunderSmartToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"330000000","ConstructorArguments":"000000000000000000000000bab2ffe40c73e2983030e5e23fb32cc0f30916590000000000000000000000000000000000000000000000000000000000000080000000000000000000000000684564950fdafedad73a79c9074aed1b85428feb00000000000000000000000042e54856ac383a86b404ab9fdbfc9224e5527b2f00000000000000000000000000000000000000000000000000000000000000632f697066732f7a4275724b394462446671524e397a7355486d685739315a4a627364384b64746a796e5258615061366a315346716e5154726579746d677a6b7945616347725356566d59615a5734506837477577616b53597345556b567a67485547560000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":""}]}