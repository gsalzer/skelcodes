{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/lib/ownership/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n       require(newOwner != address(0));\r\n       emit OwnershipTransferred(owner, newOwner);\r\n       owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/lifecycle/Destructible.sol\r\n\r\ncontract Destructible is Ownable {\r\n\tfunction selfDestruct() public onlyOwner {\r\n\t\tselfdestruct(owner);\r\n\t}\r\n}\r\n\r\n// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\r\n\r\ncontract ZapCoordinatorInterface is Ownable {\r\n\tfunction addImmutableContract(string contractName, address newAddress) external;\r\n\tfunction updateContract(string contractName, address newAddress) external;\r\n\tfunction getContractName(uint index) public view returns (string);\r\n\tfunction getContract(string contractName) public view returns (address);\r\n\tfunction updateAllDependencies() external;\r\n}\r\n\r\n// File: contracts/lib/ownership/Upgradable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Upgradable {\r\n\r\n\taddress coordinatorAddr;\r\n\tZapCoordinatorInterface coordinator;\r\n\r\n\tconstructor(address c) public{\r\n\t\tcoordinatorAddr = c;\r\n\t\tcoordinator = ZapCoordinatorInterface(c);\r\n\t}\r\n\r\n    function updateDependencies() external coordinatorOnly {\r\n       _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal;\r\n\r\n    modifier coordinatorOnly() {\r\n    \trequire(msg.sender == coordinatorAddr, \"Error: Coordinator Only Function\");\r\n    \t_;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ERC20.sol\r\n\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/platform/database/DatabaseInterface.sol\r\n\r\ncontract DatabaseInterface is Ownable {\r\n\tfunction setStorageContract(address _storageContract, bool _allowed) public;\r\n\t/*** Bytes32 ***/\r\n\tfunction getBytes32(bytes32 key) external view returns(bytes32);\r\n\tfunction setBytes32(bytes32 key, bytes32 value) external;\r\n\t/*** Number **/\r\n\tfunction getNumber(bytes32 key) external view returns(uint256);\r\n\tfunction setNumber(bytes32 key, uint256 value) external;\r\n\t/*** Bytes ***/\r\n\tfunction getBytes(bytes32 key) external view returns(bytes);\r\n\tfunction setBytes(bytes32 key, bytes value) external;\r\n\t/*** String ***/\r\n\tfunction getString(bytes32 key) external view returns(string);\r\n\tfunction setString(bytes32 key, string value) external;\r\n\t/*** Bytes Array ***/\r\n\tfunction getBytesArray(bytes32 key) external view returns (bytes32[]);\r\n\tfunction getBytesArrayIndex(bytes32 key, uint256 index) external view returns (bytes32);\r\n\tfunction getBytesArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushBytesArray(bytes32 key, bytes32 value) external;\r\n\tfunction setBytesArrayIndex(bytes32 key, uint256 index, bytes32 value) external;\r\n\tfunction setBytesArray(bytes32 key, bytes32[] value) external;\r\n\t/*** Int Array ***/\r\n\tfunction getIntArray(bytes32 key) external view returns (int[]);\r\n\tfunction getIntArrayIndex(bytes32 key, uint256 index) external view returns (int);\r\n\tfunction getIntArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushIntArray(bytes32 key, int value) external;\r\n\tfunction setIntArrayIndex(bytes32 key, uint256 index, int value) external;\r\n\tfunction setIntArray(bytes32 key, int[] value) external;\r\n\t/*** Address Array ***/\r\n\tfunction getAddressArray(bytes32 key) external view returns (address[]);\r\n\tfunction getAddressArrayIndex(bytes32 key, uint256 index) external view returns (address);\r\n\tfunction getAddressArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushAddressArray(bytes32 key, address value) external;\r\n\tfunction setAddressArrayIndex(bytes32 key, uint256 index, address value) external;\r\n\tfunction setAddressArray(bytes32 key, address[] value) external;\r\n}\r\n\r\n// File: contracts/platform/bondage/currentCost/CurrentCostInterface.sol\r\n\r\ncontract CurrentCostInterface {    \r\n    function _currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function _dotLimit(address, bytes32) public view returns (uint256);\r\n    function _costOfNDots(address, bytes32, uint256, uint256) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/bondage/BondageInterface.sol\r\n\r\ncontract BondageInterface {\r\n    function bond(address, bytes32, uint256) external returns(uint256);\r\n    function unbond(address, bytes32, uint256) external returns (uint256);\r\n    function delegateBond(address, address, bytes32, uint256) external returns(uint256);\r\n    function escrowDots(address, address, bytes32, uint256) external returns (bool);\r\n    function releaseDots(address, address, bytes32, uint256) external returns (bool);\r\n    function returnDots(address, address, bytes32, uint256) external returns (bool success);\r\n    function calcZapForDots(address, bytes32, uint256) external view returns (uint256);\r\n    function currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function getDotsIssued(address, bytes32) public view returns (uint256);\r\n    function getBoundDots(address, address, bytes32) public view returns (uint256);\r\n    function getZapBound(address, bytes32) public view returns (uint256);\r\n    function dotLimit( address, bytes32) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/bondage/Bondage.sol\r\n\r\ncontract Bondage is Destructible, BondageInterface, Upgradable {\r\n    DatabaseInterface public db;\r\n\r\n    event Bound(address indexed holder, address indexed oracle, bytes32 indexed endpoint, uint256 numZap, uint256 numDots);\r\n    event Unbound(address indexed holder, address indexed oracle, bytes32 indexed endpoint, uint256 numDots);\r\n    event Escrowed(address indexed holder, address indexed oracle, bytes32 indexed endpoint, uint256 numDots);\r\n    event Released(address indexed holder, address indexed oracle, bytes32 indexed endpoint, uint256 numDots);\r\n    event Returned(address indexed holder, address indexed oracle, bytes32 indexed endpoint, uint256 numDots);\r\n\r\n\r\n    CurrentCostInterface currentCost;\r\n    ERC20 token;\r\n\r\n    address public arbiterAddress;\r\n    address public dispatchAddress;\r\n\r\n    // For restricting dot escrow/transfer method calls to Dispatch and Arbiter\r\n    modifier operatorOnly() {\r\n        require(msg.sender == arbiterAddress || msg.sender == dispatchAddress, \"Error: Operator Only Error\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Initialize Storage, Token, anc CurrentCost Contracts\r\n    constructor(address c) Upgradable(c) public {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        address databaseAddress = coordinator.getContract(\"DATABASE\");\r\n        db = DatabaseInterface(databaseAddress);\r\n        arbiterAddress = coordinator.getContract(\"ARBITER\");\r\n        dispatchAddress = coordinator.getContract(\"DISPATCH\");\r\n        token = ERC20(coordinator.getContract(\"ZAP_TOKEN\")); \r\n        currentCost = CurrentCostInterface(coordinator.getContract(\"CURRENT_COST\")); \r\n    }\r\n\r\n    /// @dev will bond to an oracle\r\n    /// @return total ZAP bound to oracle\r\n    function bond(address oracleAddress, bytes32 endpoint, uint256 numDots) external returns (uint256 bound) {\r\n        bound = _bond(msg.sender, oracleAddress, endpoint, numDots);\r\n        emit Bound(msg.sender, oracleAddress, endpoint, bound, numDots);\r\n    }\r\n\r\n    /// @return total ZAP unbound from oracle\r\n    function unbond(address oracleAddress, bytes32 endpoint, uint256 numDots) external returns (uint256 unbound) {\r\n        unbound = _unbond(msg.sender, oracleAddress, endpoint, numDots);\r\n        emit Unbound(msg.sender, oracleAddress, endpoint, numDots);\r\n    }        \r\n\r\n    /// @dev will bond to an oracle on behalf of some holder\r\n    /// @return total ZAP bound to oracle\r\n    function delegateBond(address holderAddress, address oracleAddress, bytes32 endpoint, uint256 numDots) external returns (uint256 boundZap) {\r\n        boundZap = _bond(holderAddress, oracleAddress, endpoint, numDots);\r\n        emit Bound(holderAddress, oracleAddress, endpoint, boundZap, numDots);\r\n    }\r\n\r\n    /// @dev Move numDots dots from provider-requester to bondage according to \r\n    /// data-provider address, holder address, and endpoint specifier (ala 'smart_contract')\r\n    /// Called only by Dispatch or Arbiter Contracts\r\n    function escrowDots(        \r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    )\r\n        external\r\n        operatorOnly        \r\n        returns (bool success)\r\n    {\r\n        uint256 boundDots = getBoundDots(holderAddress, oracleAddress, endpoint);\r\n        require(numDots <= boundDots, \"Error: Not enough dots bound\");\r\n        updateEscrow(holderAddress, oracleAddress, endpoint, numDots, \"add\");\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, \"sub\");\r\n        emit Escrowed(holderAddress, oracleAddress, endpoint, numDots);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer N dots from fromAddress to destAddress. \r\n    /// Called only by Disptach or Arbiter Contracts\r\n    /// In smart contract endpoint, occurs per satisfied request. \r\n    /// In socket endpoint called on termination of subscription.\r\n    function releaseDots(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    )\r\n        external\r\n        operatorOnly \r\n        returns (bool success)\r\n    {\r\n        uint256 numEscrowed = getNumEscrow(holderAddress, oracleAddress, endpoint);\r\n        require(numDots <= numEscrowed, \"Error: Not enough dots Escrowed\");\r\n        updateEscrow(holderAddress, oracleAddress, endpoint, numDots, \"sub\");\r\n        updateBondValue(oracleAddress, oracleAddress, endpoint, numDots, \"add\");\r\n        emit Released(holderAddress, oracleAddress, endpoint, numDots);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer N dots from destAddress to fromAddress. \r\n    /// Called only by Disptach or Arbiter Contracts\r\n    /// In smart contract endpoint, occurs per satisfied request. \r\n    /// In socket endpoint called on termination of subscription.\r\n    function returnDots(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    )\r\n        external\r\n        operatorOnly \r\n        returns (bool success)\r\n    {\r\n        uint256 numEscrowed = getNumEscrow(holderAddress, oracleAddress, endpoint);\r\n        require(numDots <= numEscrowed, \"Error: Not enough dots escrowed\");\r\n        updateEscrow(holderAddress, oracleAddress, endpoint, numDots, \"sub\");\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, \"add\");\r\n        emit Returned(holderAddress, oracleAddress, endpoint, numDots);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev Calculate quantity of tokens required for specified amount of dots\r\n    /// for endpoint defined by endpoint and data provider defined by oracleAddress\r\n    function calcZapForDots(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots       \r\n    ) \r\n        external\r\n        view\r\n        returns (uint256 numZap)\r\n    {\r\n        uint256 issued = getDotsIssued(oracleAddress, endpoint);\r\n        return currentCost._costOfNDots(oracleAddress, endpoint, issued + 1, numDots - 1);\r\n    }\r\n\r\n    /// @dev Get the current cost of a dot.\r\n    /// @param endpoint specifier\r\n    /// @param oracleAddress data-provider\r\n    /// @param totalBound current number of dots\r\n    function currentCostOfDot(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 totalBound\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 cost)\r\n    {\r\n        return currentCost._currentCostOfDot(oracleAddress, endpoint, totalBound);\r\n    }\r\n\r\n    /// @dev Get issuance limit of dots \r\n    /// @param endpoint specifier\r\n    /// @param oracleAddress data-provider\r\n    function dotLimit(\r\n        address oracleAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 limit)\r\n    {\r\n        return currentCost._dotLimit(oracleAddress, endpoint);\r\n    }\r\n\r\n\r\n    /// @return total ZAP held by contract\r\n    function getZapBound(address oracleAddress, bytes32 endpoint) public view returns (uint256) {\r\n        return getNumZap(oracleAddress, endpoint);\r\n    }\r\n\r\n    function _bond(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots        \r\n    )\r\n        private\r\n        returns (uint256) \r\n    {   \r\n\r\n        address broker = getEndpointBroker(oracleAddress, endpoint);\r\n\r\n        if( broker != address(0)){\r\n            require(msg.sender == broker, \"Error: Only the broker has access to this function\");\r\n        }\r\n\r\n        // This also checks if oracle is registered w/an initialized curve\r\n        uint256 issued = getDotsIssued(oracleAddress, endpoint);\r\n        require(issued + numDots <= dotLimit(oracleAddress, endpoint), \"Error: Dot limit exceeded\");\r\n        \r\n        uint256 numZap = currentCost._costOfNDots(oracleAddress, endpoint, issued + 1, numDots - 1);\r\n\r\n        // User must have approved contract to transfer working ZAP\r\n        require(token.transferFrom(msg.sender, this, numZap), \"Error: User must have approved contract to transfer ZAP\");\r\n\r\n        if (!isProviderInitialized(holderAddress, oracleAddress)) {            \r\n            setProviderInitialized(holderAddress, oracleAddress);\r\n            addHolderOracle(holderAddress, oracleAddress);\r\n        }\r\n\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, \"add\");        \r\n        updateTotalIssued(oracleAddress, endpoint, numDots, \"add\");\r\n        updateTotalBound(oracleAddress, endpoint, numZap, \"add\");\r\n\r\n        return numZap;\r\n    }\r\n\r\n    function _unbond(        \r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    )\r\n        private\r\n        returns (uint256 numZap)\r\n    {\r\n        address broker = getEndpointBroker(oracleAddress, endpoint);\r\n\r\n        if( broker != address(0)){\r\n            require(msg.sender == broker, \"Error: Only the broker has access to this function\");\r\n        }\r\n\r\n        // Make sure the user has enough to bond with some additional sanity checks\r\n        uint256 amountBound = getBoundDots(holderAddress, oracleAddress, endpoint);\r\n        require(amountBound >= numDots, \"Error: Not enough dots bonded\");\r\n        require(numDots > 0, \"Error: Dots to unbond must be more than zero\");\r\n\r\n        // Get the value of the dots\r\n        uint256 issued = getDotsIssued(oracleAddress, endpoint);\r\n        numZap = currentCost._costOfNDots(oracleAddress, endpoint, issued + 1 - numDots, numDots - 1);\r\n\r\n        // Update the storage values\r\n        updateTotalBound(oracleAddress, endpoint, numZap, \"sub\");\r\n        updateTotalIssued(oracleAddress, endpoint, numDots, \"sub\");\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, \"sub\");\r\n\r\n        // Do the transfer\r\n        require(token.transfer(msg.sender, numZap), \"Error: Transfer failed\");\r\n\r\n        return numZap;\r\n    }\r\n\r\n    /**** Get Methods ****/\r\n    function isProviderInitialized(address holderAddress, address oracleAddress) public view returns (bool) {\r\n        return db.getNumber(keccak256(abi.encodePacked('holders', holderAddress, 'initialized', oracleAddress))) == 1 ? true : false;\r\n    }\r\n\r\n    /// @dev get broker address for endpoint\r\n    function getEndpointBroker(address oracleAddress, bytes32 endpoint) public view returns (address) {\r\n        return address(db.getBytes32(keccak256(abi.encodePacked('oracles', oracleAddress, endpoint, 'broker'))));\r\n    }\r\n\r\n    function getNumEscrow(address holderAddress, address oracleAddress, bytes32 endpoint) public view returns (uint256) {\r\n        return db.getNumber(keccak256(abi.encodePacked('escrow', holderAddress, oracleAddress, endpoint)));\r\n    }\r\n\r\n    function getNumZap(address oracleAddress, bytes32 endpoint) public view returns (uint256) {\r\n        return db.getNumber(keccak256(abi.encodePacked('totalBound', oracleAddress, endpoint)));\r\n    }\r\n\r\n    function getDotsIssued(address oracleAddress, bytes32 endpoint) public view returns (uint256) {\r\n        return db.getNumber(keccak256(abi.encodePacked('totalIssued', oracleAddress, endpoint)));\r\n    }\r\n\r\n    function getBoundDots(address holderAddress, address oracleAddress, bytes32 endpoint) public view returns (uint256) {\r\n        return db.getNumber(keccak256(abi.encodePacked('holders', holderAddress, 'bonds', oracleAddress, endpoint)));\r\n    }\r\n\r\n    function getIndexSize(address holderAddress) external view returns (uint256) {\r\n        return db.getAddressArrayLength(keccak256(abi.encodePacked('holders', holderAddress, 'oracleList')));\r\n    }\r\n\r\n    function getOracleAddress(address holderAddress, uint256 index) public view returns (address) {\r\n        return db.getAddressArrayIndex(keccak256(abi.encodePacked('holders', holderAddress, 'oracleList')), index);\r\n    }\r\n\r\n    /**** Set Methods ****/\r\n    function addHolderOracle(address holderAddress, address oracleAddress) internal {\r\n        db.pushAddressArray(keccak256(abi.encodePacked('holders', holderAddress, 'oracleList')), oracleAddress);\r\n    }\r\n\r\n    function setProviderInitialized(address holderAddress, address oracleAddress) internal {\r\n        db.setNumber(keccak256(abi.encodePacked('holders', holderAddress, 'initialized', oracleAddress)), 1);\r\n    }\r\n\r\n    function updateEscrow(address holderAddress, address oracleAddress, bytes32 endpoint, uint256 numDots, bytes32 op) internal {\r\n        uint256 newEscrow = db.getNumber(keccak256(abi.encodePacked('escrow', holderAddress, oracleAddress, endpoint)));\r\n\r\n        if ( op == \"sub\" ) {\r\n            newEscrow -= numDots;\r\n        } else if ( op == \"add\" ) {\r\n            newEscrow += numDots;\r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n\r\n        db.setNumber(keccak256(abi.encodePacked('escrow', holderAddress, oracleAddress, endpoint)), newEscrow);\r\n    }\r\n\r\n    function updateBondValue(address holderAddress, address oracleAddress, bytes32 endpoint, uint256 numDots, bytes32 op) internal {\r\n        uint256 bondValue = db.getNumber(keccak256(abi.encodePacked('holders', holderAddress, 'bonds', oracleAddress, endpoint)));\r\n        \r\n        if (op == \"sub\") {\r\n            bondValue -= numDots;\r\n        } else if (op == \"add\") {\r\n            bondValue += numDots;\r\n        }\r\n\r\n        db.setNumber(keccak256(abi.encodePacked('holders', holderAddress, 'bonds', oracleAddress, endpoint)), bondValue);\r\n    }\r\n\r\n    function updateTotalBound(address oracleAddress, bytes32 endpoint, uint256 numZap, bytes32 op) internal {\r\n        uint256 totalBound = db.getNumber(keccak256(abi.encodePacked('totalBound', oracleAddress, endpoint)));\r\n        \r\n        if (op == \"sub\"){\r\n            totalBound -= numZap;\r\n        } else if (op == \"add\") {\r\n            totalBound += numZap;\r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n        \r\n        db.setNumber(keccak256(abi.encodePacked('totalBound', oracleAddress, endpoint)), totalBound);\r\n    }\r\n\r\n    function updateTotalIssued(address oracleAddress, bytes32 endpoint, uint256 numDots, bytes32 op) internal {\r\n        uint256 totalIssued = db.getNumber(keccak256(abi.encodePacked('totalIssued', oracleAddress, endpoint)));\r\n        \r\n        if (op == \"sub\"){\r\n            totalIssued -= numDots;\r\n        } else if (op == \"add\") {\r\n            totalIssued += numDots;\r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n    \r\n        db.setNumber(keccak256(abi.encodePacked('totalIssued', oracleAddress, endpoint)), totalIssued);\r\n    }\r\n}\r\n\r\n    /*************************************** STORAGE ****************************************\r\n    * 'holders', holderAddress, 'initialized', oracleAddress => {uint256} 1 -> provider-subscriber initialized, 0 -> not initialized \r\n    * 'holders', holderAddress, 'bonds', oracleAddress, endpoint => {uint256} number of dots this address has bound to this endpoint\r\n    * 'oracles', oracleAddress, endpoint, 'broker' => {address} address of endpoint broker, 0 if none\r\n    * 'escrow', holderAddress, oracleAddress, endpoint => {uint256} amount of Zap that have been escrowed\r\n    * 'totalBound', oracleAddress, endpoint => {uint256} amount of Zap bound to this endpoint\r\n    * 'totalIssued', oracleAddress, endpoint => {uint256} number of dots issued by this endpoint\r\n    * 'holders', holderAddress, 'oracleList' => {address[]} array of oracle addresses associated with this holder\r\n    ****************************************************************************************/","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"}],\"name\":\"isProviderInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"escrowDots\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getZapBound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getDotsIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"dotLimit\",\"outputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"releaseDots\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getNumZap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"db\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbiterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getNumEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"bond\",\"outputs\":[{\"name\":\"bound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getEndpointBroker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"unbond\",\"outputs\":[{\"name\":\"unbound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"calcZapForDots\",\"outputs\":[{\"name\":\"numZap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getBoundDots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"delegateBond\",\"outputs\":[{\"name\":\"boundZap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"totalBound\",\"type\":\"uint256\"}],\"name\":\"currentCostOfDot\",\"outputs\":[{\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"}],\"name\":\"getIndexSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dispatchAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holderAddress\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"returnDots\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"c\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"numZap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"Bound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"Unbound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"Escrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"Returned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Bondage","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b007eca49763f31edff95623ed6c23c8c1924a16","Library":"","SwarmSource":"bzzr://b93702e84f4615a49bbd0d5daeffdf8358273acc7dd8ff627d67f43d552a1e8d"}]}