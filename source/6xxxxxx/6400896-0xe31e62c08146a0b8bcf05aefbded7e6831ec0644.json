{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * Safe unsigned safe math.\r\n *\r\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\n *\r\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\r\n *\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\n *\r\n */\r\nlibrary SafeMathLibExt {\r\n\r\n    function times(uint a, uint b) public pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function divides(uint a, uint b) public pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function minus(uint a, uint b) public pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function plus(uint a, uint b) public pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Ownable {\r\n    bool public halted;\r\n\r\n    modifier stopInEmergency {\r\n        if (halted) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier stopNonOwnersInEmergency {\r\n        if (halted && msg.sender != owner) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        if (!halted) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // called by the owner on emergency, triggers stopped state\r\n    function halt() external onlyOwner {\r\n        halted = true;\r\n    }\r\n\r\n    // called by the owner on end of emergency, returns to normal state\r\n    function unhalt() external onlyOwner onlyInEmergency {\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Interface for defining crowdsale pricing.\r\n */\r\ncontract PricingStrategy {\r\n\r\n    address public tier;\r\n\r\n    /** Interface declaration. */\r\n    function isPricingStrategy() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Self check if all references are correctly set.\r\n    *\r\n    * Checks that pricing strategy matches crowdsale parameters.\r\n    */\r\n    function isSane() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Pricing tells if this is a presale purchase or not.  \r\n      @return False by default, true if a presale purchaser\r\n    */\r\n    function isPresalePurchase() public pure returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /* How many weis one token costs */\r\n    function updateRate(uint oneTokenInCents) public;\r\n\r\n    /**\r\n    * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\n    *\r\n    *\r\n    * @param value - What is the value of the transaction send in as wei\r\n    * @param tokensSold - how much tokens have been sold this far\r\n    * @param decimals - how many decimal units the token has\r\n    * @return Amount of tokens the investor receives\r\n    */\r\n    function calculatePrice(uint value, uint tokensSold, uint decimals) public view returns (uint tokenAmount);\r\n\r\n    function oneTokenInWei(uint tokensSold, uint decimals) public view returns (uint);\r\n}\r\n\r\n/**\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\n *\r\n * - Allocate tokens for founders, bounties and community\r\n * - Make tokens transferable\r\n * - etc.\r\n */\r\ncontract FinalizeAgent {\r\n\r\n    bool public reservedTokensAreDistributed = false;\r\n\r\n    function isFinalizeAgent() public pure returns(bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Return true if we can run finalizeCrowdsale() properly.\r\n    *\r\n    * This is a safety check function that doesn't allow crowdsale to begin\r\n    * unless the finalizer has been set up properly.\r\n    */\r\n    function isSane() public view returns (bool);\r\n\r\n    function distributeReservedTokens(uint reservedTokensDistributionBatch) public;\r\n\r\n    /** Called once by crowdsale finalize() if the sale was success. */\r\n    function finalizeCrowdsale() public;\r\n    \r\n    /**\r\n    * Allow to (re)set Token.\r\n    */\r\n    function setCrowdsaleTokenExtv1(address _token) public;\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * A token that defines fractional units as decimals.\r\n */\r\ncontract FractionalERC20Ext is ERC20 {\r\n    uint public decimals;\r\n    uint public minCap;\r\n}\r\n\r\ncontract Allocatable is Ownable {\r\n\r\n  /** List of agents that are allowed to allocate new tokens */\r\n    mapping (address => bool) public allocateAgents;\r\n\r\n    event AllocateAgentChanged(address addr, bool state  );\r\n\r\n  /**\r\n   * Owner can allow a crowdsale contract to allocate new tokens.\r\n   */\r\n    function setAllocateAgent(address addr, bool state) public onlyOwner  \r\n    {\r\n        allocateAgents[addr] = state;\r\n        emit AllocateAgentChanged(addr, state);\r\n    }\r\n\r\n    modifier onlyAllocateAgent() {\r\n        //Only crowdsale contracts are allowed to allocate new tokens\r\n        require(allocateAgents[msg.sender]);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * Contract to enforce Token Vesting\r\n */\r\ncontract TokenVesting is Allocatable {\r\n\r\n    using SafeMathLibExt for uint;\r\n\r\n    address public crowdSaleTokenAddress;\r\n\r\n    /** keep track of total tokens yet to be released, \r\n     * this should be less than or equal to UTIX tokens held by this contract. \r\n     */\r\n    uint256 public totalUnreleasedTokens;\r\n\r\n    // default vesting parameters\r\n    uint256 private startAt = 0;\r\n    uint256 private cliff = 1;\r\n    uint256 private duration = 4; \r\n    uint256 private step = 300; //15778463;  //2592000;\r\n    bool private changeFreezed = false;\r\n\r\n    struct VestingSchedule {\r\n        uint256 startAt;\r\n        uint256 cliff;\r\n        uint256 duration;\r\n        uint256 step;\r\n        uint256 amount;\r\n        uint256 amountReleased;\r\n        bool changeFreezed;\r\n    }\r\n\r\n    mapping (address => VestingSchedule) public vestingMap;\r\n\r\n    event VestedTokensReleased(address _adr, uint256 _amount);\r\n    \r\n    constructor(address _tokenAddress) public {\r\n        \r\n        crowdSaleTokenAddress = _tokenAddress;\r\n    }\r\n\r\n    /** Modifier to check if changes to vesting is freezed  */\r\n    modifier changesToVestingFreezed(address _adr) {\r\n        require(vestingMap[_adr].changeFreezed);\r\n        _;\r\n    }\r\n\r\n    /** Modifier to check if changes to vesting is not freezed yet  */\r\n    modifier changesToVestingNotFreezed(address adr) {\r\n        require(!vestingMap[adr].changeFreezed); // if vesting not set then also changeFreezed will be false\r\n        _;\r\n    }\r\n\r\n    /** Function to set default vesting schedule parameters. */\r\n    function setDefaultVestingParameters(\r\n        uint256 _startAt, uint256 _cliff, uint256 _duration,\r\n        uint256 _step, bool _changeFreezed) public onlyAllocateAgent {\r\n\r\n        // data validation\r\n        require(_step != 0);\r\n        require(_duration != 0);\r\n        require(_cliff <= _duration);\r\n\r\n        startAt = _startAt;\r\n        cliff = _cliff;\r\n        duration = _duration; \r\n        step = _step;\r\n        changeFreezed = _changeFreezed;\r\n\r\n    }\r\n\r\n    /** Function to set vesting with default schedule. */\r\n    function setVestingWithDefaultSchedule(address _adr, uint256 _amount) \r\n    public \r\n    changesToVestingNotFreezed(_adr) onlyAllocateAgent {\r\n       \r\n        setVesting(_adr, startAt, cliff, duration, step, _amount, changeFreezed);\r\n    }    \r\n\r\n    /** Function to set/update vesting schedule. PS - Amount cannot be changed once set */\r\n    function setVesting(\r\n        address _adr,\r\n        uint256 _startAt,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _step,\r\n        uint256 _amount,\r\n        bool _changeFreezed) \r\n    public changesToVestingNotFreezed(_adr) onlyAllocateAgent {\r\n\r\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\r\n\r\n        // data validation\r\n        require(_step != 0);\r\n        require(_amount != 0 || vestingSchedule.amount > 0);\r\n        require(_duration != 0);\r\n        require(_cliff <= _duration);\r\n\r\n        //if startAt is zero, set current time as start time.\r\n        if (_startAt == 0) \r\n            _startAt = block.timestamp;\r\n\r\n        vestingSchedule.startAt = _startAt;\r\n        vestingSchedule.cliff = _cliff;\r\n        vestingSchedule.duration = _duration;\r\n        vestingSchedule.step = _step;\r\n\r\n        // special processing for first time vesting setting\r\n        if (vestingSchedule.amount == 0) {\r\n            // check if enough tokens are held by this contract\r\n            ERC20 token = ERC20(crowdSaleTokenAddress);\r\n            require(token.balanceOf(this) >= totalUnreleasedTokens.plus(_amount));\r\n            totalUnreleasedTokens = totalUnreleasedTokens.plus(_amount);\r\n            vestingSchedule.amount = _amount; \r\n        }\r\n\r\n        vestingSchedule.amountReleased = 0;\r\n        vestingSchedule.changeFreezed = _changeFreezed;\r\n    }\r\n\r\n    function isVestingSet(address adr) public view returns (bool isSet) {\r\n        return vestingMap[adr].amount != 0;\r\n    }\r\n\r\n    function freezeChangesToVesting(address _adr) public changesToVestingNotFreezed(_adr) onlyAllocateAgent {\r\n        require(isVestingSet(_adr)); // first check if vesting is set\r\n        vestingMap[_adr].changeFreezed = true;\r\n    }\r\n\r\n    /** Release tokens as per vesting schedule, called by contributor  */\r\n    function releaseMyVestedTokens() public changesToVestingFreezed(msg.sender) {\r\n        releaseVestedTokens(msg.sender);\r\n    }\r\n\r\n    /** Release tokens as per vesting schedule, called by anyone  */\r\n    function releaseVestedTokens(address _adr) public changesToVestingFreezed(_adr) {\r\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\r\n        \r\n        // check if all tokens are not vested\r\n        require(vestingSchedule.amount.minus(vestingSchedule.amountReleased) > 0);\r\n        \r\n        // calculate total vested tokens till now\r\n        uint256 totalTime = block.timestamp - vestingSchedule.startAt;\r\n        uint256 totalSteps = totalTime / vestingSchedule.step;\r\n\r\n        // check if cliff is passed\r\n        require(vestingSchedule.cliff <= totalSteps);\r\n\r\n        uint256 tokensPerStep = vestingSchedule.amount / vestingSchedule.duration;\r\n        // check if amount is divisble by duration\r\n        if (tokensPerStep * vestingSchedule.duration != vestingSchedule.amount) tokensPerStep++;\r\n\r\n        uint256 totalReleasableAmount = tokensPerStep.times(totalSteps);\r\n\r\n        // handle the case if user has not claimed even after vesting period is over or amount was not divisible\r\n        if (totalReleasableAmount > vestingSchedule.amount) totalReleasableAmount = vestingSchedule.amount;\r\n\r\n        uint256 amountToRelease = totalReleasableAmount.minus(vestingSchedule.amountReleased);\r\n        vestingSchedule.amountReleased = vestingSchedule.amountReleased.plus(amountToRelease);\r\n\r\n        // transfer vested tokens\r\n        ERC20 token = ERC20(crowdSaleTokenAddress);\r\n        token.transfer(_adr, amountToRelease);\r\n        // decrement overall unreleased token count\r\n        totalUnreleasedTokens = totalUnreleasedTokens.minus(amountToRelease);\r\n        emit VestedTokensReleased(_adr, amountToRelease);\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set Token.\r\n    */\r\n    function setCrowdsaleTokenExtv1(address _token) public onlyAllocateAgent {       \r\n        crowdSaleTokenAddress = _token;\r\n    }\r\n}\r\n\r\n/**\r\n * Abstract base contract for token sales.\r\n *\r\n * Handle\r\n * - start and end dates\r\n * - accepting investments\r\n * - minimum funding goal and refund\r\n * - various statistics during the crowdfund\r\n * - different pricing strategies\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\n *\r\n */\r\ncontract CrowdsaleExt is Allocatable, Haltable {\r\n\r\n    /* Max investment count when we are still allowed to change the multisig address */\r\n    uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\r\n\r\n    using SafeMathLibExt for uint;\r\n\r\n    /* The token we are selling */\r\n    FractionalERC20Ext public token;\r\n\r\n    /* How we are going to price our offering */\r\n    PricingStrategy public pricingStrategy;\r\n\r\n    /* Post-success callback */\r\n    FinalizeAgent public finalizeAgent;\r\n\r\n    TokenVesting public tokenVesting;\r\n\r\n    /* name of the crowdsale tier */\r\n    string public name;\r\n\r\n    /* tokens will be transfered from this address */\r\n    address public multisigWallet;\r\n\r\n    /* if the funding goal is not reached, investors may withdraw their funds */\r\n    uint public minimumFundingGoal;\r\n\r\n    /* the UNIX timestamp start date of the crowdsale */\r\n    uint public startsAt;\r\n\r\n    /* the UNIX timestamp end date of the crowdsale */\r\n    uint public endsAt;\r\n\r\n    /* the number of tokens already sold through this contract*/\r\n    uint public tokensSold = 0;\r\n\r\n    /* How many wei of funding we have raised */\r\n    uint public weiRaised = 0;\r\n\r\n    /* How many distinct addresses have invested */\r\n    uint public investorCount = 0;\r\n\r\n    /* Has this crowdsale been finalized */\r\n    bool public finalized;\r\n\r\n    bool public isWhiteListed;\r\n\r\n      /* Token Vesting Contract */\r\n    address public tokenVestingAddress;\r\n\r\n    address[] public joinedCrowdsales;\r\n    uint8 public joinedCrowdsalesLen = 0;\r\n    uint8 public joinedCrowdsalesLenMax = 50;\r\n\r\n    struct JoinedCrowdsaleStatus {\r\n        bool isJoined;\r\n        uint8 position;\r\n    }\r\n\r\n    mapping (address => JoinedCrowdsaleStatus) public joinedCrowdsaleState;\r\n\r\n    /** How much ETH each address has invested to this crowdsale */\r\n    mapping (address => uint256) public investedAmountOf;\r\n\r\n    /** How much tokens this crowdsale has credited for each investor address */\r\n    mapping (address => uint256) public tokenAmountOf;\r\n\r\n    struct WhiteListData {\r\n        bool status;\r\n        uint minCap;\r\n        uint maxCap;\r\n    }\r\n\r\n    //is crowdsale updatable\r\n    bool public isUpdatable;\r\n\r\n    /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\r\n    mapping (address => WhiteListData) public earlyParticipantWhitelist;\r\n\r\n    /** List of whitelisted addresses */\r\n    address[] public whitelistedParticipants;\r\n\r\n    /** This is for manul testing for the interaction from owner wallet. \r\n    You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\r\n    uint public ownerTestValue;\r\n\r\n    /** State machine\r\n    *\r\n    * - Preparing: All contract initialization calls and variables have not been set yet\r\n    * - Prefunding: We have not passed start time yet\r\n    * - Funding: Active crowdsale\r\n    * - Success: Minimum funding goal reached\r\n    * - Failure: Minimum funding goal not reached before ending time\r\n    * - Finalized: The finalized has been called and succesfully executed\r\n    */\r\n    enum State { Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized }\r\n\r\n    // A new investment was made\r\n    event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\n\r\n    // Address early participation whitelist status changed\r\n    event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\r\n    event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\r\n\r\n    // Crowdsale start time has been changed\r\n    event StartsAtChanged(uint newStartsAt);\r\n\r\n    // Crowdsale end time has been changed\r\n    event EndsAtChanged(uint newEndsAt);\r\n\r\n    constructor(string _name, address _token, PricingStrategy _pricingStrategy, \r\n    address _multisigWallet, uint _start, uint _end, \r\n    uint _minimumFundingGoal, bool _isUpdatable, \r\n    bool _isWhiteListed, address _tokenVestingAddress) public {\r\n\r\n        owner = msg.sender;\r\n\r\n        name = _name;\r\n\r\n        tokenVestingAddress = _tokenVestingAddress;\r\n\r\n        token = FractionalERC20Ext(_token);\r\n\r\n        setPricingStrategy(_pricingStrategy);\r\n\r\n        multisigWallet = _multisigWallet;\r\n        if (multisigWallet == 0) {\r\n            revert();\r\n        }\r\n\r\n        if (_start == 0) {\r\n            revert();\r\n        }\r\n\r\n        startsAt = _start;\r\n\r\n        if (_end == 0) {\r\n            revert();\r\n        }\r\n\r\n        endsAt = _end;\r\n\r\n        // Don't mess the dates\r\n        if (startsAt >= endsAt) {\r\n            revert();\r\n        }\r\n\r\n        // Minimum funding goal can be zero\r\n        minimumFundingGoal = _minimumFundingGoal;\r\n\r\n        isUpdatable = _isUpdatable;\r\n\r\n        isWhiteListed = _isWhiteListed;\r\n    }\r\n\r\n    /**\r\n    * Don't expect to just send in money and get tokens.\r\n    */\r\n    function() external payable {\r\n        buy();\r\n    }\r\n\r\n    /**\r\n    * The basic entry point to participate the crowdsale process.\r\n    *\r\n    * Pay for funding, get invested tokens back in the sender address.\r\n    */\r\n    function buy() public payable {\r\n        invest(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * Allow anonymous contributions to this crowdsale.\r\n    */\r\n    function invest(address addr) public payable {\r\n        investInternal(addr, 0);\r\n    }\r\n\r\n    /**\r\n    * Make an investment.\r\n    *\r\n    * Crowdsale must be running for one to invest.\r\n    * We must have not pressed the emergency brake.\r\n    *\r\n    * @param receiver The Ethereum address who receives the tokens\r\n    * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\n    *\r\n    */\r\n    function investInternal(address receiver, uint128 customerId) private stopInEmergency {\r\n\r\n        // Determine if it's a good time to accept investment from this participant\r\n        if (getState() == State.PreFunding) {\r\n            // Are we whitelisted for early deposit\r\n            revert();\r\n        } else if (getState() == State.Funding) {\r\n            // Retail participants can only come in when the crowdsale is running\r\n            // pass\r\n            if (isWhiteListed) {\r\n                if (!earlyParticipantWhitelist[receiver].status) {\r\n                    revert();\r\n                }\r\n            }\r\n        } else {\r\n            // Unwanted state\r\n            revert();\r\n        }\r\n\r\n        uint weiAmount = msg.value;\r\n\r\n        // Account presale sales separately, so that they do not count against pricing tranches\r\n        uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, tokensSold, token.decimals());\r\n\r\n        if (tokenAmount == 0) {\r\n          // Dust transaction\r\n            revert();\r\n        }\r\n\r\n        if (isWhiteListed) {\r\n            if (weiAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\r\n              // weiAmount < minCap for investor\r\n                revert();\r\n            }\r\n\r\n            // Check that we did not bust the investor's cap\r\n            if (isBreakingInvestorCap(receiver, weiAmount)) {\r\n                revert();\r\n            }\r\n\r\n            updateInheritedEarlyParticipantWhitelist(receiver, weiAmount);\r\n        } else {\r\n            if (weiAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        if (investedAmountOf[receiver] == 0) {\r\n          // A new investor\r\n            investorCount++;\r\n        }\r\n\r\n        // Update investor\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\n\r\n        // Update totals\r\n        weiRaised = weiRaised.plus(weiAmount);\r\n        tokensSold = tokensSold.plus(tokenAmount);\r\n\r\n        // Check that we did not bust the cap\r\n        if (isBreakingCap(tokensSold)) {\r\n            revert();\r\n        }\r\n\r\n        assignTokens(receiver, tokenAmount);\r\n\r\n        // Pocket the money\r\n        if (!multisigWallet.send(weiAmount)) revert();\r\n\r\n        // Tell us invest was success\r\n        emit Invested(receiver, weiAmount, tokenAmount, customerId);\r\n    }\r\n\r\n    /**\r\n    * allocate tokens for the early investors.\r\n    *\r\n    * Preallocated tokens have been sold before the actual crowdsale opens.\r\n    * This function mints the tokens and moves the crowdsale needle.\r\n    *\r\n    * Investor count is not handled; it is assumed this goes for multiple investors\r\n    * and the token distribution happens outside the smart contract flow.\r\n    *\r\n    * No money is exchanged, as the crowdsale team already have received the payment.\r\n    *\r\n    * param weiPrice Price of a single full token in wei\r\n    *\r\n    */\r\n    function allocate(address receiver, uint256 tokenAmount, uint128 customerId, uint256 lockedTokenAmount) public onlyAllocateAgent {\r\n\r\n      // cannot lock more than total tokens\r\n        require(lockedTokenAmount <= tokenAmount);\r\n        uint weiPrice = pricingStrategy.oneTokenInWei(tokensSold, token.decimals());\r\n        // This can be also 0, we give out tokens for free\r\n        uint256 weiAmount = (weiPrice * tokenAmount)/10**uint256(token.decimals());         \r\n\r\n        weiRaised = weiRaised.plus(weiAmount);\r\n        tokensSold = tokensSold.plus(tokenAmount);\r\n\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\n\r\n        // assign locked token to Vesting contract\r\n        if (lockedTokenAmount > 0) {\r\n            tokenVesting = TokenVesting(tokenVestingAddress);\r\n            // to prevent minting of tokens which will be useless as vesting amount cannot be updated\r\n            require(!tokenVesting.isVestingSet(receiver));\r\n            assignTokens(tokenVestingAddress, lockedTokenAmount);\r\n            // set vesting with default schedule\r\n            tokenVesting.setVestingWithDefaultSchedule(receiver, lockedTokenAmount); \r\n        }\r\n\r\n        // assign remaining tokens to contributor\r\n        if (tokenAmount - lockedTokenAmount > 0) {\r\n            assignTokens(receiver, tokenAmount - lockedTokenAmount);\r\n        }\r\n\r\n        // Tell us invest was success\r\n        emit Invested(receiver, weiAmount, tokenAmount, customerId);\r\n    }\r\n\r\n    //\r\n    // Modifiers\r\n    //\r\n    /** Modified allowing execution only if the crowdsale is currently running.  */\r\n\r\n    modifier inState(State state) {\r\n        if (getState() != state) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    function distributeReservedTokens(uint reservedTokensDistributionBatch) \r\n    public inState(State.Success) onlyOwner stopInEmergency {\r\n      // Already finalized\r\n        if (finalized) {\r\n            revert();\r\n        }\r\n\r\n        // Finalizing is optional. We only call it if we are given a finalizing agent.\r\n        if (address(finalizeAgent) != address(0)) {\r\n            finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\r\n        }\r\n    }\r\n\r\n    function areReservedTokensDistributed() public view returns (bool) {\r\n        return finalizeAgent.reservedTokensAreDistributed();\r\n    }\r\n\r\n    function canDistributeReservedTokens() public view returns(bool) {\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        if ((lastTierCntrct.getState() == State.Success) &&\r\n        !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed())\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Finalize a succcesful crowdsale.\r\n    *\r\n    * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\n    */\r\n    function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n\r\n      // Already finalized\r\n        if (finalized) {\r\n            revert();\r\n        }\r\n\r\n      // Finalizing is optional. We only call it if we are given a finalizing agent.\r\n        if (address(finalizeAgent) != address(0)) {\r\n            finalizeAgent.finalizeCrowdsale();\r\n        }\r\n\r\n        finalized = true;\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set finalize agent.\r\n    *\r\n    * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\n    */\r\n    function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\r\n        assert(address(addr) != address(0));\r\n        assert(address(finalizeAgent) == address(0));\r\n        finalizeAgent = addr;\r\n\r\n        // Don't allow setting bad agent\r\n        if (!finalizeAgent.isFinalizeAgent()) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Allow addresses to do early participation.\r\n    */\r\n    function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\r\n        if (!isWhiteListed) revert();\r\n        assert(addr != address(0));\r\n        assert(maxCap > 0);\r\n        assert(minCap <= maxCap);\r\n        assert(now <= endsAt);\r\n\r\n        if (!isAddressWhitelisted(addr)) {\r\n            whitelistedParticipants.push(addr);\r\n            emit Whitelisted(addr, status, minCap, maxCap);\r\n        } else {\r\n            emit WhitelistItemChanged(addr, status, minCap, maxCap);\r\n        }\r\n\r\n        earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\r\n    }\r\n\r\n    function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) \r\n    public onlyOwner {\r\n        if (!isWhiteListed) revert();\r\n        assert(now <= endsAt);\r\n        assert(addrs.length == statuses.length);\r\n        assert(statuses.length == minCaps.length);\r\n        assert(minCaps.length == maxCaps.length);\r\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\r\n            setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\r\n        }\r\n    }\r\n\r\n    function updateEarlyParticipantWhitelist(address addr, uint weiAmount) public {\r\n        if (!isWhiteListed) revert();\r\n        assert(addr != address(0));\r\n        assert(now <= endsAt);\r\n        assert(isTierJoined(msg.sender));\r\n        if (weiAmount < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) revert();\r\n        //if (addr != msg.sender && contractAddr != msg.sender) throw;\r\n        uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\r\n        newMaxCap = newMaxCap.minus(weiAmount);\r\n        earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\r\n    }\r\n\r\n    function updateInheritedEarlyParticipantWhitelist(address reciever, uint weiAmount) private {\r\n        if (!isWhiteListed) revert();\r\n        if (weiAmount < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) revert();\r\n\r\n        uint8 tierPosition = getTierPosition(this);\r\n\r\n        for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\r\n            CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n            crowdsale.updateEarlyParticipantWhitelist(reciever, weiAmount);\r\n        }\r\n    }\r\n\r\n    function isAddressWhitelisted(address addr) public view returns(bool) {\r\n        for (uint i = 0; i < whitelistedParticipants.length; i++) {\r\n            if (whitelistedParticipants[i] == addr) {\r\n                return true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function whitelistedParticipantsLength() public view returns (uint) {\r\n        return whitelistedParticipants.length;\r\n    }\r\n\r\n    function isTierJoined(address addr) public view returns(bool) {\r\n        return joinedCrowdsaleState[addr].isJoined;\r\n    }\r\n\r\n    function getTierPosition(address addr) public view returns(uint8) {\r\n        return joinedCrowdsaleState[addr].position;\r\n    }\r\n\r\n    function getLastTier() public view returns(address) {\r\n        if (joinedCrowdsalesLen > 0)\r\n            return joinedCrowdsales[joinedCrowdsalesLen - 1];\r\n        else\r\n            return address(0);\r\n    }\r\n\r\n    function setJoinedCrowdsales(address addr) private onlyOwner {\r\n        assert(addr != address(0));\r\n        assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\r\n        assert(!isTierJoined(addr));\r\n        joinedCrowdsales.push(addr);\r\n        joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\r\n            isJoined: true,\r\n            position: joinedCrowdsalesLen\r\n        });\r\n        joinedCrowdsalesLen++;\r\n    }\r\n\r\n    function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\r\n        assert(addrs.length > 0);\r\n        assert(joinedCrowdsalesLen == 0);\r\n        assert(addrs.length <= joinedCrowdsalesLenMax);\r\n        for (uint8 iter = 0; iter < addrs.length; iter++) {\r\n            setJoinedCrowdsales(addrs[iter]);\r\n        }\r\n    }\r\n\r\n    function setStartsAt(uint time) public onlyOwner {\r\n        assert(!finalized);\r\n        assert(isUpdatable);\r\n        assert(now <= time); // Don't change past\r\n        assert(time <= endsAt);\r\n        assert(now <= startsAt);\r\n\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        if (lastTierCntrct.finalized()) revert();\r\n\r\n        uint8 tierPosition = getTierPosition(this);\r\n\r\n        //start time should be greater then end time of previous tiers\r\n        for (uint8 j = 0; j < tierPosition; j++) {\r\n            CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n            assert(time >= crowdsale.endsAt());\r\n        }\r\n\r\n        startsAt = time;\r\n        emit StartsAtChanged(startsAt);\r\n    }\r\n\r\n    /**\r\n    * Allow crowdsale owner to close early or extend the crowdsale.\r\n    *\r\n    * This is useful e.g. for a manual soft cap implementation:\r\n    * - after X amount is reached determine manual closing\r\n    *\r\n    * This may put the crowdsale to an invalid state,\r\n    * but we trust owners know what they are doing.\r\n    *\r\n    */\r\n    function setEndsAt(uint time) public onlyOwner {\r\n        assert(!finalized);\r\n        assert(isUpdatable);\r\n        assert(now <= time);// Don't change past\r\n        assert(startsAt <= time);\r\n        assert(now <= endsAt);\r\n\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        if (lastTierCntrct.finalized()) revert();\r\n\r\n\r\n        uint8 tierPosition = getTierPosition(this);\r\n\r\n        for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\r\n            CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n            assert(time <= crowdsale.startsAt());\r\n        }\r\n\r\n        endsAt = time;\r\n        emit EndsAtChanged(endsAt);\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set pricing strategy.\r\n    *\r\n    * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\n    */\r\n    function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\r\n        assert(address(_pricingStrategy) != address(0));\r\n        assert(address(pricingStrategy) == address(0));\r\n        pricingStrategy = _pricingStrategy;\r\n\r\n        // Don't allow setting bad agent\r\n        if (!pricingStrategy.isPricingStrategy()) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set Token.\r\n    * @param _token upgraded token address\r\n    */\r\n    function setCrowdsaleTokenExtv1(address _token) public onlyOwner {\r\n        assert(_token != address(0));\r\n        token = FractionalERC20Ext(_token);\r\n        \r\n        if (address(finalizeAgent) != address(0)) {\r\n            finalizeAgent.setCrowdsaleTokenExtv1(_token);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Allow to change the team multisig address in the case of emergency.\r\n    *\r\n    * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\r\n    * (we have done only few test transactions). After the crowdsale is going\r\n    * then multisig address stays locked for the safety reasons.\r\n    */\r\n    function setMultisig(address addr) public onlyOwner {\r\n\r\n      // Change\r\n        if (investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\r\n            revert();\r\n        }\r\n\r\n        multisigWallet = addr;\r\n    }\r\n\r\n    /**\r\n    * @return true if the crowdsale has raised enough money to be a successful.\r\n    */\r\n    function isMinimumGoalReached() public view returns (bool reached) {\r\n        return weiRaised >= minimumFundingGoal;\r\n    }\r\n\r\n    /**\r\n    * Check if the contract relationship looks good.\r\n    */\r\n    function isFinalizerSane() public view returns (bool sane) {\r\n        return finalizeAgent.isSane();\r\n    }\r\n\r\n    /**\r\n    * Check if the contract relationship looks good.\r\n    */\r\n    function isPricingSane() public view returns (bool sane) {\r\n        return pricingStrategy.isSane();\r\n    }\r\n\r\n    /**\r\n    * Crowdfund state machine management.\r\n    *\r\n    * We make it a function and do not assign the result to a variable, \r\n    * so there is no chance of the variable being stale.\r\n    */\r\n    function getState() public view returns (State) {\r\n        if(finalized) return State.Finalized;\r\n        else if (address(finalizeAgent) == 0) return State.Preparing;\r\n        else if (!finalizeAgent.isSane()) return State.Preparing;\r\n        else if (!pricingStrategy.isSane()) return State.Preparing;\r\n        else if (block.timestamp < startsAt) return State.PreFunding;\r\n        else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\n        else if (isMinimumGoalReached()) return State.Success;\r\n        else return State.Failure;\r\n    }\r\n\r\n    /** Interface marker. */\r\n    function isCrowdsale() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Abstract functions\r\n    //\r\n\r\n    /**\r\n    * Check if the current invested breaks our cap rules.\r\n    *\r\n    *\r\n    * The child contract must define their own cap setting rules.\r\n    * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\n    * Called from invest().\r\n    *  \r\n    * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\n    *\r\n    * @return true if taking this investment would break our cap rules\r\n    */\r\n    function isBreakingCap(uint tokensSoldTotal) public view returns (bool limitBroken);\r\n\r\n    function isBreakingInvestorCap(address receiver, uint tokenAmount) public view returns (bool limitBroken);\r\n\r\n    /**\r\n    * Check if the current crowdsale is full and we can no longer sell any tokens.\r\n    */\r\n    function isCrowdsaleFull() public view returns (bool);\r\n\r\n    /**\r\n    * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\n    */\r\n    function assignTokens(address receiver, uint tokenAmount) private;\r\n}\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20 {\r\n\r\n    using SafeMathLibExt for uint;\r\n    /* Token supply got increased and a new owner received these tokens */\r\n    event Minted(address receiver, uint amount);\r\n\r\n    /* Actual balances of token holders */\r\n    mapping(address => uint) public balances;\r\n\r\n    /* approve() allowances */\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n\r\n    /* Interface declaration */\r\n    function isToken() public pure returns (bool weAre) {\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].minus(_value);\r\n        balances[_to] = balances[_to].plus(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_to] = balances[_to].plus(_value);\r\n        balances[_from] = balances[_from].minus(_value);\r\n        allowed[_from][msg.sender] = _allowance.minus(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n */\r\ncontract MintableTokenExt is StandardToken, Ownable {\r\n\r\n    using SafeMathLibExt for uint;\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    /** List of agents that are allowed to create new tokens */\r\n    mapping (address => bool) public mintAgents;\r\n\r\n    event MintingAgentChanged(address addr, bool state  );\r\n\r\n    /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.\r\n    * For example, for reserved tokens in percents 2.54%\r\n    * inPercentageUnit = 254\r\n    * inPercentageDecimals = 2\r\n    */\r\n    struct ReservedTokensData {\r\n        uint inTokens;\r\n        uint inPercentageUnit;\r\n        uint inPercentageDecimals;\r\n        bool isReserved;\r\n        bool isDistributed;\r\n        bool isVested;\r\n    }\r\n\r\n    mapping (address => ReservedTokensData) public reservedTokensList;\r\n    address[] public reservedTokensDestinations;\r\n    uint public reservedTokensDestinationsLen = 0;\r\n    bool private reservedTokensDestinationsAreSet = false;\r\n\r\n    modifier onlyMintAgent() {\r\n        // Only crowdsale contracts are allowed to mint new tokens\r\n        if (!mintAgents[msg.sender]) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /** Make sure we are not done yet. */\r\n    modifier canMint() {\r\n        if (mintingFinished) revert();\r\n        _;\r\n    }\r\n\r\n    function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\r\n        ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\r\n        reservedTokensData.isDistributed = true;\r\n    }\r\n\r\n    function isAddressReserved(address addr) public view returns (bool isReserved) {\r\n        return reservedTokensList[addr].isReserved;\r\n    }\r\n\r\n    function areTokensDistributedForAddress(address addr) public view returns (bool isDistributed) {\r\n        return reservedTokensList[addr].isDistributed;\r\n    }\r\n\r\n    function getReservedTokens(address addr) public view returns (uint inTokens) {\r\n        return reservedTokensList[addr].inTokens;\r\n    }\r\n\r\n    function getReservedPercentageUnit(address addr) public view returns (uint inPercentageUnit) {\r\n        return reservedTokensList[addr].inPercentageUnit;\r\n    }\r\n\r\n    function getReservedPercentageDecimals(address addr) public view returns (uint inPercentageDecimals) {\r\n        return reservedTokensList[addr].inPercentageDecimals;\r\n    }\r\n\r\n    function getReservedIsVested(address addr) public view returns (bool isVested) {\r\n        return reservedTokensList[addr].isVested;\r\n    }\r\n\r\n    function setReservedTokensListMultiple(\r\n        address[] addrs, \r\n        uint[] inTokens, \r\n        uint[] inPercentageUnit, \r\n        uint[] inPercentageDecimals,\r\n        bool[] isVested\r\n        ) public canMint onlyOwner {\r\n        assert(!reservedTokensDestinationsAreSet);\r\n        assert(addrs.length == inTokens.length);\r\n        assert(inTokens.length == inPercentageUnit.length);\r\n        assert(inPercentageUnit.length == inPercentageDecimals.length);\r\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\r\n            if (addrs[iterator] != address(0)) {\r\n                setReservedTokensList(\r\n                    addrs[iterator],\r\n                    inTokens[iterator],\r\n                    inPercentageUnit[iterator],\r\n                    inPercentageDecimals[iterator],\r\n                    isVested[iterator]\r\n                    );\r\n            }\r\n        }\r\n        reservedTokensDestinationsAreSet = true;\r\n    }\r\n\r\n    /**\r\n    * Create new tokens and allocate them to an address..\r\n    *\r\n    * Only callably by a crowdsale contract (mint agent).\r\n    */\r\n    function mint(address receiver, uint amount) public onlyMintAgent canMint {\r\n        totalSupply = totalSupply.plus(amount);\r\n        balances[receiver] = balances[receiver].plus(amount);\r\n\r\n        // This will make the mint transaction apper in EtherScan.io\r\n        // We can remove this after there is a standardized minting event\r\n        emit Transfer(0, receiver, amount);\r\n    }\r\n\r\n    /**\r\n    * Owner can allow a crowdsale contract to mint new tokens.\r\n    */\r\n    function setMintAgent(address addr, bool state) public onlyOwner canMint {\r\n        mintAgents[addr] = state;\r\n        emit MintingAgentChanged(addr, state);\r\n    }\r\n\r\n    function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals,bool isVested) \r\n    private canMint onlyOwner {\r\n        assert(addr != address(0));\r\n        if (!isAddressReserved(addr)) {\r\n            reservedTokensDestinations.push(addr);\r\n            reservedTokensDestinationsLen++;\r\n        }\r\n\r\n        reservedTokensList[addr] = ReservedTokensData({\r\n            inTokens: inTokens,\r\n            inPercentageUnit: inPercentageUnit,\r\n            inPercentageDecimals: inPercentageDecimals,\r\n            isReserved: true,\r\n            isDistributed: false,\r\n            isVested:isVested\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * ICO crowdsale contract that is capped by amout of tokens.\r\n *\r\n * - Tokens are dynamically created during the crowdsale\r\n *\r\n *\r\n */\r\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\r\n\r\n    /* Maximum amount of tokens this crowdsale can sell. */\r\n    uint public maximumSellableTokens;\r\n\r\n    constructor(\r\n        string _name,\r\n        address _token,\r\n        PricingStrategy _pricingStrategy,\r\n        address _multisigWallet,\r\n        uint _start, uint _end,\r\n        uint _minimumFundingGoal,\r\n        uint _maximumSellableTokens,\r\n        bool _isUpdatable,\r\n        bool _isWhiteListed,\r\n        address _tokenVestingAddress\r\n    ) public CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end,\r\n    _minimumFundingGoal, _isUpdatable, _isWhiteListed, _tokenVestingAddress) {\r\n        maximumSellableTokens = _maximumSellableTokens;\r\n    }\r\n\r\n    // Crowdsale maximumSellableTokens has been changed\r\n    event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\r\n\r\n    /**\r\n    * Called from invest() to confirm if the curret investment does not break our cap rule.\r\n    */\r\n    function isBreakingCap(uint tokensSoldTotal) public view returns (bool limitBroken) {\r\n        return tokensSoldTotal > maximumSellableTokens;\r\n    }\r\n\r\n    function isBreakingInvestorCap(address addr, uint weiAmount) public view returns (bool limitBroken) {\r\n        assert(isWhiteListed);\r\n        uint maxCap = earlyParticipantWhitelist[addr].maxCap;\r\n        return (investedAmountOf[addr].plus(weiAmount)) > maxCap;\r\n    }\r\n\r\n    function isCrowdsaleFull() public view returns (bool) {\r\n        return tokensSold >= maximumSellableTokens;\r\n    }\r\n\r\n    function setMaximumSellableTokens(uint tokens) public onlyOwner {\r\n        assert(!finalized);\r\n        assert(isUpdatable);\r\n        assert(now <= startsAt);\r\n\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        assert(!lastTierCntrct.finalized());\r\n\r\n        maximumSellableTokens = tokens;\r\n        emit MaximumSellableTokensChanged(maximumSellableTokens);\r\n    }\r\n\r\n    function updateRate(uint oneTokenInCents) public onlyOwner {\r\n        assert(!finalized);\r\n        assert(isUpdatable);\r\n        assert(now <= startsAt);\r\n\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        assert(!lastTierCntrct.finalized());\r\n\r\n        pricingStrategy.updateRate(oneTokenInCents);\r\n    }\r\n\r\n    /**\r\n    * Dynamically create tokens and assign them to the investor.\r\n    */\r\n    function assignTokens(address receiver, uint tokenAmount) private {\r\n        MintableTokenExt mintableToken = MintableTokenExt(token);\r\n        mintableToken.mint(receiver, tokenAmount);\r\n    }    \r\n}\r\n\r\n/**\r\n * ICO crowdsale contract that is capped by amout of tokens.\r\n *\r\n * - Tokens are dynamically created during the crowdsale\r\n *\r\n *\r\n */\r\ncontract MintedTokenCappedCrowdsaleExtv1 is MintedTokenCappedCrowdsaleExt {\r\n\r\n    address[] public investedAmountOfAddresses;\r\n    MintedTokenCappedCrowdsaleExt public mintedTokenCappedCrowdsaleExt;\r\n\r\n    constructor(\r\n        string _name,\r\n        address _token,\r\n        PricingStrategy _pricingStrategy,\r\n        address _multisigWallet,\r\n        uint _start, uint _end,\r\n        uint _minimumFundingGoal,\r\n        uint _maximumSellableTokens,\r\n        bool _isUpdatable,\r\n        bool _isWhiteListed,\r\n        address _tokenVestingAddress,\r\n        MintedTokenCappedCrowdsaleExt _oldMintedTokenCappedCrowdsaleExtAddress\r\n    ) public MintedTokenCappedCrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end,\r\n    _minimumFundingGoal, _maximumSellableTokens, _isUpdatable, _isWhiteListed, _tokenVestingAddress) {\r\n        \r\n        mintedTokenCappedCrowdsaleExt = _oldMintedTokenCappedCrowdsaleExtAddress;\r\n        tokensSold = mintedTokenCappedCrowdsaleExt.tokensSold();\r\n        weiRaised = mintedTokenCappedCrowdsaleExt.weiRaised();\r\n        investorCount = mintedTokenCappedCrowdsaleExt.investorCount();        \r\n\r\n        \r\n        for (uint i = 0; i < mintedTokenCappedCrowdsaleExt.whitelistedParticipantsLength(); i++) {\r\n            address whitelistAddress = mintedTokenCappedCrowdsaleExt.whitelistedParticipants(i);\r\n\r\n            //whitelistedParticipants.push(whitelistAddress);\r\n\r\n            uint256 tokenAmount = mintedTokenCappedCrowdsaleExt.tokenAmountOf(whitelistAddress);\r\n            if (tokenAmount != 0){               \r\n                tokenAmountOf[whitelistAddress] = tokenAmount;               \r\n            }\r\n\r\n            uint256 investedAmount = mintedTokenCappedCrowdsaleExt.investedAmountOf(whitelistAddress);\r\n            if (investedAmount != 0){\r\n                investedAmountOf[whitelistAddress] = investedAmount;               \r\n            }\r\n\r\n            //setEarlyParticipantWhitelist(whitelistAddress, true, 1000000000000000000, 1000000000000000000000);\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ownerTestValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"isBreakingInvestorCap\",\"outputs\":[{\"name\":\"limitBroken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"updateJoinedCrowdsalesMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPricingSane\",\"outputs\":[{\"name\":\"sane\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isUpdatable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAddressWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFinalizeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistedParticipantsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isTierJoined\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"areReservedTokensDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setAllocateAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocateAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setMaximumSellableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumSellableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintedTokenCappedCrowdsaleExt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricingStrategy\",\"type\":\"address\"}],\"name\":\"setPricingStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oneTokenInCents\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setEndsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinimumGoalReached\",\"outputs\":[{\"name\":\"reached\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joinedCrowdsalesLenMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"},{\"name\":\"minCap\",\"type\":\"uint256\"},{\"name\":\"maxCap\",\"type\":\"uint256\"}],\"name\":\"setEarlyParticipantWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investedAmountOfAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalizerSane\",\"outputs\":[{\"name\":\"sane\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getTierPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"statuses\",\"type\":\"bool[]\"},{\"name\":\"minCaps\",\"type\":\"uint256[]\"},{\"name\":\"maxCaps\",\"type\":\"uint256[]\"}],\"name\":\"setEarlyParticipantWhitelistMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenVestingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canDistributeReservedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"joinedCrowdsales\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setStartsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"updateEarlyParticipantWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastTier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"joinedCrowdsaleState\",\"outputs\":[{\"name\":\"isJoined\",\"type\":\"bool\"},{\"name\":\"position\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyParticipantWhitelist\",\"outputs\":[{\"name\":\"status\",\"type\":\"bool\"},{\"name\":\"minCap\",\"type\":\"uint256\"},{\"name\":\"maxCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reservedTokensDistributionBatch\",\"type\":\"uint256\"}],\"name\":\"distributeReservedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsaleFull\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokensSoldTotal\",\"type\":\"uint256\"}],\"name\":\"isBreakingCap\",\"outputs\":[{\"name\":\"limitBroken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistedParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"customerId\",\"type\":\"uint128\"},{\"name\":\"lockedTokenAmount\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joinedCrowdsalesLen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWhiteListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setCrowdsaleTokenExtv1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMultisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_pricingStrategy\",\"type\":\"address\"},{\"name\":\"_multisigWallet\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_minimumFundingGoal\",\"type\":\"uint256\"},{\"name\":\"_maximumSellableTokens\",\"type\":\"uint256\"},{\"name\":\"_isUpdatable\",\"type\":\"bool\"},{\"name\":\"_isWhiteListed\",\"type\":\"bool\"},{\"name\":\"_tokenVestingAddress\",\"type\":\"address\"},{\"name\":\"_oldMintedTokenCappedCrowdsaleExtAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMaximumSellableTokens\",\"type\":\"uint256\"}],\"name\":\"MaximumSellableTokensChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerId\",\"type\":\"uint128\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"minCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxCap\",\"type\":\"uint256\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"minCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxCap\",\"type\":\"uint256\"}],\"name\":\"WhitelistItemChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newStartsAt\",\"type\":\"uint256\"}],\"name\":\"StartsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newEndsAt\",\"type\":\"uint256\"}],\"name\":\"EndsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"AllocateAgentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MintedTokenCappedCrowdsaleExtv1","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001800000000000000000000000003b1ad2987a6dc21678ef80973c2da0d94079651d00000000000000000000000010bcf90dd31c64a06f7514c806d999751205f55e000000000000000000000000f9c3c1a10787761269274d34ac9c1d7bd06ed11a000000000000000000000000000000000000000000000000000000005bab094b000000000000000000000000000000000000000000000000000000005c56340b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000094e47b8d6817153400000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000627058c1d8438ae33edb07ef4c7d8c0de95ccba20000000000000000000000000d5548d159805467f4252bb2eb464623a2ae3028000000000000000000000000000000000000000000000000000000000000000e557469782043726f776473616c65000000000000000000000000000000000000","Library":"SafeMathLibExt:8a0128980df4f35bb7515275d9e1cb869159a6c2","SwarmSource":"bzzr://4ae41a2952e8f1a0f758694afd60638ce4db97b9e4e7874b845d8b979efb3cdd"}]}