{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n\r\nlibrary SafeMath16 {\r\n\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint16 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        uint16 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint16 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint32 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint32 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeConvert {\r\n\r\n    function toUint8(uint256 _value) internal pure returns (uint8) {\r\n        assert(_value <= 255);\r\n        return uint8(_value);\r\n    }\r\n\r\n    function toUint16(uint256 _value) internal pure returns (uint16) {\r\n        assert(_value <= 2**16 - 1);\r\n        return uint16(_value);\r\n    }\r\n\r\n    function toUint32(uint256 _value) internal pure returns (uint32) {\r\n        assert(_value <= 2**32 - 1);\r\n        return uint32(_value);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\ncontract ERC721Token {\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n}\r\n\r\ncontract DragonCoreHelper {\r\n    function calculateCurrent(uint256, uint32, uint32) external pure returns (uint32, uint8) {}\r\n    function calculateHealthAndMana(uint32, uint32, uint32, uint32) external pure returns (uint32, uint32) {}\r\n    function getSpecialBattleSkillDragonType(uint8[11], uint256) external pure returns (uint8) {}\r\n    function calculateSpecialPeacefulSkill(uint8, uint32[5], uint32[5]) external pure returns (uint32, uint32) {}\r\n    function calculateCoolness(uint256[4]) external pure returns (uint32) {}\r\n    function calculateSkills(uint256[4]) external pure returns (uint32, uint32, uint32, uint32, uint32) {}\r\n    function calculateExperience(uint8, uint256, uint16, uint256) external pure returns (uint8, uint256, uint16) {}\r\n    function checkAndConvertName(string) external pure returns(bytes32, bytes32) {}\r\n    function upgradeGenes(uint256[4], uint16[10], uint16) external pure returns (uint256[4], uint16) {}\r\n}\r\n\r\ncontract DragonParams {\r\n    function dnaPoints(uint8) external pure returns (uint16) {}\r\n}\r\n\r\ncontract DragonModel {\r\n\r\n    struct HealthAndMana {\r\n        uint256 timestamp; \r\n        uint32 remainingHealth;\r\n        uint32 remainingMana; \r\n        uint32 maxHealth;\r\n        uint32 maxMana;\r\n    }\r\n\r\n    struct Level {\r\n        uint8 level;\r\n        uint8 experience;\r\n        uint16 dnaPoints;\r\n    }\r\n\r\n    struct Battles {\r\n        uint16 wins;\r\n        uint16 defeats;\r\n    }\r\n\r\n    struct Skills {\r\n        uint32 attack;\r\n        uint32 defense;\r\n        uint32 stamina;\r\n        uint32 speed;\r\n        uint32 intelligence;\r\n    }\r\n\r\n}\r\n\r\ncontract DragonStorage is DragonModel, ERC721Token {\r\n    mapping (bytes32 => bool) public existingNames;\r\n    mapping (uint256 => bytes32) public names;\r\n    mapping (uint256 => HealthAndMana) public healthAndMana;\r\n    mapping (uint256 => Battles) public battles;\r\n    mapping (uint256 => Skills) public skills;\r\n    mapping (uint256 => Level) public levels;\r\n    mapping (uint256 => uint8) public specialPeacefulSkills;\r\n    mapping (uint256 => mapping (uint8 => uint32)) public buffs;\r\n\r\n    function getGenome(uint256) external pure returns (uint256[4]) {}\r\n\r\n    function push(address, uint16, uint256[4], uint256[2], uint8[11]) public returns (uint256) {}\r\n    function setName(uint256, bytes32, bytes32) external {}\r\n    function setTactics(uint256, uint8, uint8) external {}\r\n    function setWins(uint256, uint16) external {}\r\n    function setDefeats(uint256, uint16) external {}\r\n    function setMaxHealthAndMana(uint256, uint32, uint32) external {}\r\n    function setRemainingHealthAndMana(uint256, uint32, uint32) external {}\r\n    function resetHealthAndManaTimestamp(uint256) external {}\r\n    function setSkills(uint256, uint32, uint32, uint32, uint32, uint32) external {}\r\n    function setLevel(uint256, uint8, uint8, uint16) external {}\r\n    function setCoolness(uint256, uint32) external {}\r\n    function setGenome(uint256, uint256[4]) external {}\r\n    function setSpecialAttack(uint256, uint8) external {}\r\n    function setSpecialDefense(uint256, uint8) external {}\r\n    function setSpecialPeacefulSkill(uint256, uint8) external {}\r\n    function setBuff(uint256, uint8, uint32) external {}\r\n}\r\n\r\ncontract Random {\r\n    function random(uint256) external pure returns (uint256) {}\r\n    function randomOfBlock(uint256, uint256) external pure returns (uint256) {}\r\n}\r\n\r\n\r\n\r\n\r\n//////////////CONTRACT//////////////\r\n\r\n\r\n\r\n\r\ncontract DragonBase is Upgradable {\r\n    using SafeMath32 for uint32;\r\n    using SafeMath256 for uint256;\r\n    using SafeConvert for uint32;\r\n    using SafeConvert for uint256;\r\n\r\n    DragonStorage _storage_;\r\n    DragonParams params;\r\n    DragonCoreHelper helper;\r\n    Random random;\r\n\r\n    function _identifySpecialBattleSkills(\r\n        uint256 _id,\r\n        uint8[11] _dragonTypes\r\n    ) internal {\r\n        uint256 _randomSeed = random.random(10000); // generate 4-digit number in range [0, 9999]\r\n        uint256 _attackRandom = _randomSeed % 100; // 2-digit number (last 2 digits)\r\n        uint256 _defenseRandom = _randomSeed / 100; // 2-digit number (first 2 digits)\r\n\r\n        // we have 100 variations of random number but genes only 40, so we calculate random [0..39]\r\n        _attackRandom = _attackRandom.mul(4).div(10);\r\n        _defenseRandom = _defenseRandom.mul(4).div(10);\r\n\r\n        uint8 _attackType = helper.getSpecialBattleSkillDragonType(_dragonTypes, _attackRandom);\r\n        uint8 _defenseType = helper.getSpecialBattleSkillDragonType(_dragonTypes, _defenseRandom);\r\n\r\n        _storage_.setSpecialAttack(_id, _attackType);\r\n        _storage_.setSpecialDefense(_id, _defenseType);\r\n    }\r\n\r\n    function _setSkillsAndHealthAndMana(uint256 _id, uint256[4] _genome, uint8[11] _dragonTypes) internal {\r\n        (\r\n            uint32 _attack,\r\n            uint32 _defense,\r\n            uint32 _stamina,\r\n            uint32 _speed,\r\n            uint32 _intelligence\r\n        ) = helper.calculateSkills(_genome);\r\n\r\n        _storage_.setSkills(_id, _attack, _defense, _stamina, _speed, _intelligence);\r\n\r\n        _identifySpecialBattleSkills(_id, _dragonTypes);\r\n\r\n        (\r\n            uint32 _health,\r\n            uint32 _mana\r\n        ) = helper.calculateHealthAndMana(_stamina, _intelligence, 0, 0);\r\n        _storage_.setMaxHealthAndMana(_id, _health, _mana);\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        super.setInternalDependencies(_newDependencies);\r\n\r\n        _storage_ = DragonStorage(_newDependencies[0]);\r\n        params = DragonParams(_newDependencies[1]);\r\n        helper = DragonCoreHelper(_newDependencies[2]);\r\n        random = Random(_newDependencies[3]);\r\n    }\r\n}\r\n\r\ncontract DragonCore is DragonBase {\r\n    using SafeMath16 for uint16;\r\n\r\n    uint8 constant MAX_LEVEL = 10; // max dragon level\r\n\r\n    uint8 constant MAX_TACTICS_PERCENTAGE = 80;\r\n    uint8 constant MIN_TACTICS_PERCENTAGE = 20;\r\n\r\n    uint8 constant MAX_GENE_LVL = 99; // max dragon gene level\r\n\r\n    uint8 constant NUMBER_OF_SPECIAL_PEACEFUL_SKILL_CLASSES = 8; // first is empty skill\r\n\r\n    // does dragon have enough DNA points for breeding?\r\n    function isBreedingAllowed(uint8 _level, uint16 _dnaPoints) public view returns (bool) {\r\n        return _level > 0 && _dnaPoints >= params.dnaPoints(_level);\r\n    }\r\n\r\n    function _checkIfEnoughPoints(bool _isEnough) internal pure {\r\n        require(_isEnough, \"not enough points\");\r\n    }\r\n\r\n    function _validateSpecialPeacefulSkillClass(uint8 _class) internal pure {\r\n        require(_class > 0 && _class < NUMBER_OF_SPECIAL_PEACEFUL_SKILL_CLASSES, \"wrong class of special peaceful skill\");\r\n    }\r\n\r\n    function _checkIfSpecialPeacefulSkillAvailable(bool _isAvailable) internal pure {\r\n        require(_isAvailable, \"special peaceful skill selection is not available\");\r\n    }\r\n\r\n    function _getBuff(uint256 _id, uint8 _class) internal view returns (uint32) {\r\n        return _storage_.buffs(_id, _class);\r\n    }\r\n\r\n    function _getAllBuffs(uint256 _id) internal view returns (uint32[5]) {\r\n        return [\r\n            _getBuff(_id, 1),\r\n            _getBuff(_id, 2),\r\n            _getBuff(_id, 3),\r\n            _getBuff(_id, 4),\r\n            _getBuff(_id, 5)\r\n        ];\r\n    }\r\n\r\n    // GETTERS\r\n\r\n    function calculateMaxHealthAndManaWithBuffs(uint256 _id) public view returns (\r\n        uint32 maxHealth,\r\n        uint32 maxMana\r\n    ) {\r\n        (, , uint32 _stamina, , uint32 _intelligence) = _storage_.skills(_id);\r\n\r\n        (\r\n            maxHealth,\r\n            maxMana\r\n        ) = helper.calculateHealthAndMana(\r\n            _stamina,\r\n            _intelligence,\r\n            _getBuff(_id, 3), // stamina buff\r\n            _getBuff(_id, 5) // intelligence buff\r\n        );\r\n    }\r\n\r\n    function getCurrentHealthAndMana(uint256 _id) public view returns (\r\n        uint32 health,\r\n        uint32 mana,\r\n        uint8 healthPercentage,\r\n        uint8 manaPercentage\r\n    ) {\r\n        (\r\n            uint256 _timestamp,\r\n            uint32 _remainingHealth,\r\n            uint32 _remainingMana,\r\n            uint32 _maxHealth,\r\n            uint32 _maxMana\r\n        ) = _storage_.healthAndMana(_id);\r\n\r\n        (_maxHealth, _maxMana) = calculateMaxHealthAndManaWithBuffs(_id);\r\n\r\n        uint256 _pastTime = now.sub(_timestamp); // solium-disable-line security/no-block-members\r\n        (health, healthPercentage) = helper.calculateCurrent(_pastTime, _maxHealth, _remainingHealth);\r\n        (mana, manaPercentage) = helper.calculateCurrent(_pastTime, _maxMana, _remainingMana);\r\n    }\r\n\r\n    // SETTERS\r\n\r\n    function setRemainingHealthAndMana(\r\n        uint256 _id,\r\n        uint32 _remainingHealth,\r\n        uint32 _remainingMana\r\n    ) external onlyController {\r\n        _storage_.setRemainingHealthAndMana(_id, _remainingHealth, _remainingMana);\r\n    }\r\n\r\n    function increaseExperience(uint256 _id, uint256 _factor) external onlyController {\r\n        (\r\n            uint8 _level,\r\n            uint256 _experience,\r\n            uint16 _dnaPoints\r\n        ) = _storage_.levels(_id);\r\n        uint8 _currentLevel = _level;\r\n        if (_level < MAX_LEVEL) {\r\n            (_level, _experience, _dnaPoints) = helper.calculateExperience(_level, _experience, _dnaPoints, _factor);\r\n            if (_level > _currentLevel) {\r\n                // restore hp and mana if level up\r\n                _storage_.resetHealthAndManaTimestamp(_id);\r\n            }\r\n            if (_level == MAX_LEVEL) {\r\n                _experience = 0;\r\n            }\r\n            _storage_.setLevel(_id, _level, _experience.toUint8(), _dnaPoints);\r\n        }\r\n    }\r\n\r\n    function payDNAPointsForBreeding(uint256 _id) external onlyController {\r\n        (\r\n            uint8 _level,\r\n            uint8 _experience,\r\n            uint16 _dnaPoints\r\n        ) = _storage_.levels(_id);\r\n\r\n        _checkIfEnoughPoints(isBreedingAllowed(_level, _dnaPoints));\r\n        _dnaPoints = _dnaPoints.sub(params.dnaPoints(_level));\r\n\r\n        _storage_.setLevel(_id, _level, _experience, _dnaPoints);\r\n    }\r\n\r\n    function upgradeGenes(uint256 _id, uint16[10] _dnaPoints) external onlyController {\r\n        (\r\n            uint8 _level,\r\n            uint8 _experience,\r\n            uint16 _availableDNAPoints\r\n        ) = _storage_.levels(_id);\r\n\r\n        uint16 _sum;\r\n        uint256[4] memory _newComposedGenome;\r\n        (\r\n            _newComposedGenome,\r\n            _sum\r\n        ) = helper.upgradeGenes(\r\n            _storage_.getGenome(_id),\r\n            _dnaPoints,\r\n            _availableDNAPoints\r\n        );\r\n\r\n        require(_sum > 0, \"DNA points were not used\");\r\n\r\n        _availableDNAPoints = _availableDNAPoints.sub(_sum);\r\n        // save data\r\n        _storage_.setLevel(_id, _level, _experience, _availableDNAPoints);\r\n        _storage_.setGenome(_id, _newComposedGenome);\r\n        _storage_.setCoolness(_id, helper.calculateCoolness(_newComposedGenome));\r\n        // recalculate skills\r\n        _saveSkills(_id, _newComposedGenome);\r\n    }\r\n\r\n    function _saveSkills(uint256 _id, uint256[4] _genome) internal {\r\n        (\r\n            uint32 _attack,\r\n            uint32 _defense,\r\n            uint32 _stamina,\r\n            uint32 _speed,\r\n            uint32 _intelligence\r\n        ) = helper.calculateSkills(_genome);\r\n        (\r\n            uint32 _health,\r\n            uint32 _mana\r\n        ) = helper.calculateHealthAndMana(_stamina, _intelligence, 0, 0); // without buffs\r\n\r\n        _storage_.setMaxHealthAndMana(_id, _health, _mana);\r\n        _storage_.setSkills(_id, _attack, _defense, _stamina, _speed, _intelligence);\r\n    }\r\n\r\n    function increaseWins(uint256 _id) external onlyController {\r\n        (uint16 _wins, ) = _storage_.battles(_id);\r\n        _storage_.setWins(_id, _wins.add(1));\r\n    }\r\n\r\n    function increaseDefeats(uint256 _id) external onlyController {\r\n        (, uint16 _defeats) = _storage_.battles(_id);\r\n        _storage_.setDefeats(_id, _defeats.add(1));\r\n    }\r\n\r\n    function setTactics(uint256 _id, uint8 _melee, uint8 _attack) external onlyController {\r\n        require(\r\n            _melee >= MIN_TACTICS_PERCENTAGE &&\r\n            _melee <= MAX_TACTICS_PERCENTAGE &&\r\n            _attack >= MIN_TACTICS_PERCENTAGE &&\r\n            _attack <= MAX_TACTICS_PERCENTAGE,\r\n            \"tactics value must be between 20 and 80\"\r\n        );\r\n        _storage_.setTactics(_id, _melee, _attack);\r\n    }\r\n\r\n    function calculateSpecialPeacefulSkill(uint256 _id) public view returns (\r\n        uint8 class,\r\n        uint32 cost,\r\n        uint32 effect\r\n    ) {\r\n        class = _storage_.specialPeacefulSkills(_id);\r\n        if (class == 0) return;\r\n        (\r\n            uint32 _attack,\r\n            uint32 _defense,\r\n            uint32 _stamina,\r\n            uint32 _speed,\r\n            uint32 _intelligence\r\n        ) = _storage_.skills(_id);\r\n\r\n        (\r\n            cost,\r\n            effect\r\n        ) = helper.calculateSpecialPeacefulSkill(\r\n            class,\r\n            [_attack, _defense, _stamina, _speed, _intelligence],\r\n            _getAllBuffs(_id)\r\n        );\r\n    }\r\n\r\n    function setSpecialPeacefulSkill(uint256 _id, uint8 _class) external onlyController {\r\n        (uint8 _level, , ) = _storage_.levels(_id);\r\n        uint8 _currentClass = _storage_.specialPeacefulSkills(_id);\r\n\r\n        _checkIfSpecialPeacefulSkillAvailable(_level == MAX_LEVEL);\r\n        _validateSpecialPeacefulSkillClass(_class);\r\n        _checkIfSpecialPeacefulSkillAvailable(_currentClass == 0);\r\n\r\n        _storage_.setSpecialPeacefulSkill(_id, _class);\r\n    }\r\n\r\n    function _getBuffIndexBySpecialPeacefulSkillClass(\r\n        uint8 _class\r\n    ) internal pure returns (uint8) {\r\n        uint8[8] memory _buffsIndexes = [0, 1, 2, 3, 4, 5, 3, 5]; // 0 item - no such class\r\n        return _buffsIndexes[_class];\r\n    }\r\n\r\n    // _id - dragon, which will use the skill\r\n    // _target - dragon, on which the skill will be used\r\n    // _sender - owner of the first dragon\r\n    function useSpecialPeacefulSkill(address _sender, uint256 _id, uint256 _target) external onlyController {\r\n        (\r\n            uint8 _class,\r\n            uint32 _cost,\r\n            uint32 _effect\r\n        ) = calculateSpecialPeacefulSkill(_id);\r\n        (\r\n            uint32 _health,\r\n            uint32 _mana, ,\r\n        ) = getCurrentHealthAndMana(_id);\r\n\r\n        _validateSpecialPeacefulSkillClass(_class);\r\n        // enough mana\r\n        _checkIfEnoughPoints(_mana >= _cost);\r\n\r\n        // subtract cost of special peaceful skill\r\n        _storage_.setRemainingHealthAndMana(_id, _health, _mana.sub(_cost));\r\n        // reset intelligence buff of the first dragon\r\n        _storage_.setBuff(_id, 5, 0);\r\n        // reset active skill buff of the first dragon\r\n        uint8 _buffIndexOfActiveSkill = _getBuffIndexBySpecialPeacefulSkillClass(_class);\r\n        _storage_.setBuff(_id, _buffIndexOfActiveSkill, 0);\r\n\r\n        if (_class == 6 || _class == 7) { // health/mana restoration\r\n            (\r\n                uint32 _targetHealth,\r\n                uint32 _targetMana, ,\r\n            ) = getCurrentHealthAndMana(_target);\r\n            if (_class == 6) _targetHealth = _targetHealth.add(_effect); // restore health\r\n            if (_class == 7) _targetMana = _targetMana.add(_effect); // restore mana\r\n            // save restored health/mana\r\n            _storage_.setRemainingHealthAndMana(\r\n                _target,\r\n                _targetHealth,\r\n                _targetMana\r\n            );\r\n        } else { // another special peaceful skills\r\n            if (_storage_.ownerOf(_target) != _sender) { // to prevert lower effect buffing\r\n                require(_getBuff(_target, _class) < _effect, \"you can't buff alien dragon by lower effect\");\r\n            }\r\n            _storage_.setBuff(_target, _class, _effect);\r\n        }\r\n    }\r\n\r\n    function setBuff(uint256 _id, uint8 _class, uint32 _effect) external onlyController {\r\n        _storage_.setBuff(_id, _class, _effect);\r\n    }\r\n\r\n    function createDragon(\r\n        address _sender,\r\n        uint16 _generation,\r\n        uint256[2] _parents,\r\n        uint256[4] _genome,\r\n        uint8[11] _dragonTypes\r\n    ) external onlyController returns (uint256 newDragonId) {\r\n        newDragonId = _storage_.push(_sender, _generation, _genome, _parents, _dragonTypes);\r\n        uint32 _coolness = helper.calculateCoolness(_genome);\r\n        _storage_.setCoolness(newDragonId, _coolness);\r\n        _storage_.setTactics(newDragonId, 50, 50);\r\n        _setSkillsAndHealthAndMana(newDragonId, _genome, _dragonTypes);\r\n    }\r\n\r\n    function setName(\r\n        uint256 _id,\r\n        string _name\r\n    ) external onlyController returns (bytes32) {\r\n        (\r\n            bytes32 _initial, // initial name that converted to bytes32\r\n            bytes32 _lowercase // name to lowercase\r\n        ) = helper.checkAndConvertName(_name);\r\n        require(!_storage_.existingNames(_lowercase), \"name exists\");\r\n        require(_storage_.names(_id) == 0x0, \"dragon already has a name\");\r\n        _storage_.setName(_id, _initial, _lowercase);\r\n        return _initial;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_generation\",\"type\":\"uint16\"},{\"name\":\"_parents\",\"type\":\"uint256[2]\"},{\"name\":\"_genome\",\"type\":\"uint256[4]\"},{\"name\":\"_dragonTypes\",\"type\":\"uint8[11]\"}],\"name\":\"createDragon\",\"outputs\":[{\"name\":\"newDragonId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"uint256\"}],\"name\":\"useSpecialPeacefulSkill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"increaseDefeats\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_factor\",\"type\":\"uint256\"}],\"name\":\"increaseExperience\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_class\",\"type\":\"uint8\"}],\"name\":\"setSpecialPeacefulSkill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_melee\",\"type\":\"uint8\"},{\"name\":\"_attack\",\"type\":\"uint8\"}],\"name\":\"setTactics\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"calculateSpecialPeacefulSkill\",\"outputs\":[{\"name\":\"class\",\"type\":\"uint8\"},{\"name\":\"cost\",\"type\":\"uint32\"},{\"name\":\"effect\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_dnaPoints\",\"type\":\"uint16\"}],\"name\":\"isBreedingAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_remainingHealth\",\"type\":\"uint32\"},{\"name\":\"_remainingMana\",\"type\":\"uint32\"}],\"name\":\"setRemainingHealthAndMana\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCurrentHealthAndMana\",\"outputs\":[{\"name\":\"health\",\"type\":\"uint32\"},{\"name\":\"mana\",\"type\":\"uint32\"},{\"name\":\"healthPercentage\",\"type\":\"uint8\"},{\"name\":\"manaPercentage\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_dnaPoints\",\"type\":\"uint16[10]\"}],\"name\":\"upgradeGenes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"calculateMaxHealthAndManaWithBuffs\",\"outputs\":[{\"name\":\"maxHealth\",\"type\":\"uint32\"},{\"name\":\"maxMana\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"payDNAPointsForBreeding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_class\",\"type\":\"uint8\"},{\"name\":\"_effect\",\"type\":\"uint32\"}],\"name\":\"setBuff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"increaseWins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonCore","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://100aec4b59174cec13bd8265d1f4ccec625744395df1cc6601e22638abce3bf3"}]}