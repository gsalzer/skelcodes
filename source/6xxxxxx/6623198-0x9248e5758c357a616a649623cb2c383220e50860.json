{"status":"1","message":"OK","result":[{"SourceCode":"contract PoolOwnersInterface {\r\n    bool public distributionActive;\r\n    function sendOwnership(address _receiver, uint256 _amount) public;\r\n    function sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) public;\r\n    function getOwnerTokens(address _owner) public returns (uint);\r\n}\r\n\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Sender not authorised.\");\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n    @title ItMap, a solidity iterable map\r\n    @dev Credit to: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1\r\n */\r\nlibrary itmap {\r\n    struct entry {\r\n        // Equal to the index of the key of this item in keys, plus 1.\r\n        uint keyIndex;\r\n        uint value;\r\n    }\r\n\r\n    struct itmap {\r\n        mapping(uint => entry) data;\r\n        uint[] keys;\r\n    }\r\n\r\n    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {\r\n        entry storage e = self.data[key];\r\n        e.value = value;\r\n        if (e.keyIndex > 0) {\r\n            return true;\r\n        } else {\r\n            e.keyIndex = ++self.keys.length;\r\n            self.keys[e.keyIndex - 1] = key;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(itmap storage self, uint key) internal returns (bool success) {\r\n        entry storage e = self.data[key];\r\n\r\n        if (e.keyIndex == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (e.keyIndex < self.keys.length) {\r\n            // Move an existing element into the vacated key slot.\r\n            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\r\n            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\r\n        }\r\n\r\n        self.keys.length -= 1;\r\n        delete self.data[key];\r\n        return true;\r\n    }\r\n\r\n    function contains(itmap storage self, uint key) internal view returns (bool exists) {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function size(itmap storage self) internal view returns (uint) {\r\n        return self.keys.length;\r\n    }\r\n\r\n    function get(itmap storage self, uint key) internal view returns (uint) {\r\n        return self.data[key].value;\r\n    }\r\n\r\n    function getKey(itmap storage self, uint idx) internal view returns (uint) {\r\n        return self.keys[idx];\r\n    }\r\n}\r\n\r\n/**\r\n    @title OwnersExchange\r\n    @dev Allow for trustless exchange of LP owners tokens\r\n */\r\ncontract OwnersExchange is Ownable {\r\n\r\n    using SafeMath for uint;\r\n    using itmap for itmap.itmap;\r\n\r\n    enum ORDER_TYPE {\r\n        NULL, BUY, SELL\r\n    }\r\n    uint public orderCount;\r\n    uint public fee;\r\n    uint public lockedFees;\r\n    uint public totalFees;\r\n    mapping(uint => uint) public feeBalances;\r\n    address[] public addressRegistry; \r\n    mapping(address => uint) public addressIndex;\r\n\r\n    itmap.itmap orderBook;\r\n\r\n    PoolOwnersInterface public poolOwners;\r\n    ERC20 public feeToken;\r\n\r\n    event NewOrder(ORDER_TYPE indexed orderType, address indexed sender, uint price, uint amount);\r\n    event OrderRemoved(ORDER_TYPE indexed orderType, address indexed sender, uint price, uint amount);\r\n    event OrderFilled(ORDER_TYPE indexed orderType, address indexed sender, address receiver, uint price, uint amount);\r\n\r\n    /**\r\n        @dev Initialise the contract\r\n        @param _poolOwners Set the address of the PoolOwners contract used in this DEX\r\n     */\r\n    constructor(address _poolOwners, address _feeToken) public {\r\n        require(_poolOwners != address(0), \"_poolOwners needs to be set\");\r\n        poolOwners = PoolOwnersInterface(_poolOwners);\r\n        feeToken = ERC20(_feeToken);\r\n        addressRegistry.push(address(0));\r\n        orderCount = 1;\r\n    }\r\n\r\n    /**\r\n        @dev Register an address to a uint allowing packing in orders\r\n        @param _address The address to register\r\n     */\r\n    function addressRegister(address _address) private returns (uint) {\r\n        if (addressIndex[_address] != 0) {\r\n            return addressIndex[_address];\r\n        } else {\r\n            require(addressRegistry.length < 1 << 32, \"Registered addresses hit maximum\");\r\n            addressIndex[_address] = addressRegistry.length;\r\n            addressRegistry.push(_address);\r\n            return addressRegistry.length - 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev ERC677 Reciever for fee token transfer (Always expected to be LINK)\r\n        @param _sender The address of the sender of the token\r\n        @param _value The amount of token received\r\n        @param _data Extra data, not needed in this use-case\r\n     */\r\n    function onTokenTransfer(address _sender, uint256 _value, bytes _data) public {\r\n        require(msg.sender == address(feeToken), \"Sender needs to be the fee token\");\r\n        uint index = addressRegister(_sender);\r\n        feeBalances[index] = feeBalances[index].add(_value);\r\n        totalFees = totalFees.add(_value);\r\n    }\r\n\r\n    /**\r\n        @dev Allow users to withdraw any tokens used for fees\r\n        @param _value The amount wanting to be withdrawn\r\n     */\r\n    function withdrawFeeToken(uint256 _value) public {\r\n        uint index = addressRegister(msg.sender);\r\n        require(feeBalances[index] >= _value, \"You're withdrawing more than your balance\");\r\n        feeBalances[index] = feeBalances[index].sub(_value);\r\n        totalFees = totalFees.sub(_value);\r\n        if (feeBalances[index] == 0) {\r\n            delete feeBalances[index];\r\n        }\r\n        feeToken.transfer(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n        @dev Set the fee percentage\r\n        @param _fee The percentage of fees to be taken in LINK\r\n     */\r\n    function setFee(uint _fee) public onlyOwner {\r\n        require(_fee <= 500 finney, \"Fees can't be more than 50%\");\r\n        fee = _fee;\r\n    }\r\n\r\n    /**\r\n        @dev Returns the fee cost based on a price & amount\r\n        @param _price The price of the order\r\n        @param _amount The amount requested\r\n     */\r\n    function feeForOrder(uint _price, uint _amount) public view returns (uint) {\r\n        return _price\r\n            .mul(_amount)\r\n            .div(1 ether)\r\n            .mul(fee)\r\n            .div(1 ether);\r\n    }\r\n\r\n    /**\r\n        @dev Returns the ETH cost of an order\r\n        @param _price The price of the order\r\n        @param _amount The amount requested\r\n     */\r\n    function costOfOrder(uint _price, uint _amount) public pure returns (uint) {\r\n        return _price.mul(_amount).div(1 ether);\r\n    }\r\n\r\n    /**\r\n        @dev Create a new sell order\r\n        @param _price The price of the order per 1 ether of token\r\n        @param _amount The amount of tokens being sent\r\n     */\r\n    function addSellOrder(uint _price, uint _amount) public {\r\n        require(is111bit(_price) && is111bit(_amount), \"Price or amount exceeds 111 bits\");\r\n\r\n        require(_price > 0, \"Price needs to be greater than 0\");\r\n        require(_amount > 0, \"Amount needs to be greater than 0\");\r\n\r\n        uint orderFee = feeForOrder(_price, _amount);\r\n        uint index = addressRegister(msg.sender);\r\n        if (orderFee > 0) {\r\n            require(feeBalances[index] >= orderFee, \"You do not have enough deposited for fees\");\r\n            feeBalances[index] = feeBalances[index].sub(orderFee);\r\n            feeBalances[0] = feeBalances[0].add(orderFee);\r\n            lockedFees = lockedFees.add(orderFee);\r\n        }\r\n        poolOwners.sendOwnershipFrom(msg.sender, this, _amount);\r\n\r\n        require(\r\n            !orderBook.insert(orderCount, (((uint(ORDER_TYPE.SELL) << 32 | index) << 111 | _price) << 111) | _amount), \r\n            \"Map replacement detected\"\r\n        );\r\n        orderCount += 1;\r\n    \r\n        emit NewOrder(ORDER_TYPE.SELL, msg.sender, _price, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev Add a new buy order, ETH sent needs to equal: (price * amount) / 18\r\n        @param _price The price of the buy order per 1 ether of LP token\r\n        @param _amount The amount of tokens wanting to be purchased\r\n     */\r\n    function addBuyOrder(uint _price, uint _amount) public payable {\r\n        require(is111bit(_price) && is111bit(_amount), \"Price or amount exceeds 111 bits\");\r\n\r\n        require(_price > 0, \"Price needs to be greater than 0\");\r\n        require(_amount > 0, \"Amount needs to be greater than 0\");\r\n\r\n        uint orderFee = feeForOrder(_price, _amount);\r\n        uint index = addressRegister(msg.sender);\r\n        if (orderFee > 0) {\r\n            require(feeBalances[index] >= orderFee, \"You do not have enough deposited for fees\");\r\n            feeBalances[index] = feeBalances[index].sub(orderFee);\r\n            feeBalances[0] = feeBalances[0].add(orderFee);\r\n            lockedFees = lockedFees.add(orderFee);\r\n        }\r\n\r\n        uint cost = _price.mul(_amount).div(1 ether);\r\n        require(_price.mul(_amount) == cost.mul(1 ether), \"The price and amount of this order is too small\");\r\n        require(msg.value == cost, \"ETH sent needs to equal the cost\");\r\n\r\n        require(\r\n            !orderBook.insert(orderCount, (((uint(ORDER_TYPE.BUY) << 32 | index) << 111 | _price) << 111) | _amount), \r\n            \"Map replacement detected\"\r\n        );\r\n        orderCount += 1;\r\n    \r\n        emit NewOrder(ORDER_TYPE.BUY, msg.sender, _price, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev Remove a buy order and refund ETH back to the sender\r\n        @param _key The key of the order in the book\r\n     */\r\n    function removeBuyOrder(uint _key) public {\r\n        uint order = orderBook.get(_key);\r\n        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\r\n        require(orderType == ORDER_TYPE.BUY, \"This is not a buy order\");\r\n        uint index = addressIndex[msg.sender];\r\n        require(index == (order << 2) >> 224, \"You are not the sender of this order\");\r\n\r\n        uint price = (order << 34) >> 145;\r\n        uint amount = (order << 145) >> 145;\r\n        require(orderBook.remove(_key), \"Map remove failed\");\r\n\r\n        uint orderFee = feeForOrder(price, amount);\r\n        feeBalances[index] = feeBalances[index].add(orderFee);\r\n        feeBalances[0] = feeBalances[0].sub(orderFee);\r\n        lockedFees = lockedFees.sub(orderFee);\r\n\r\n        uint cost = price.mul(amount).div(1 ether);\r\n        msg.sender.transfer(cost);\r\n\r\n        emit OrderRemoved(orderType, msg.sender, price, amount);\r\n    }\r\n\r\n    /**\r\n        @dev Remove a sell order and refund the LP tokens back to the sender\r\n        @param _key The key of the order in the book\r\n     */\r\n    function removeSellOrder(uint _key) public {\r\n        uint order = orderBook.get(_key);\r\n        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\r\n        require(orderType == ORDER_TYPE.SELL, \"This is not a sell order\");\r\n        uint index = addressIndex[msg.sender];\r\n        require(index == (order << 2) >> 224, \"You are not the sender of this order\");\r\n\r\n        uint price = (order << 34) >> 145;\r\n        uint amount = (order << 145) >> 145;\r\n        require(orderBook.remove(_key), \"Map remove failed\");\r\n\r\n        uint orderFee = feeForOrder(price, amount);\r\n        feeBalances[index] = feeBalances[index].add(orderFee);\r\n        feeBalances[0] = feeBalances[0].sub(orderFee);\r\n        lockedFees = lockedFees.sub(orderFee);\r\n\r\n        poolOwners.sendOwnership(msg.sender, amount);\r\n\r\n        emit OrderRemoved(orderType, msg.sender, price, amount);\r\n    }\r\n\r\n    /**\r\n        @dev Fill a sell order in the order book\r\n        @dev Orders have to be filled in whole amounts\r\n        @param _key Key of the order as per orderbook\r\n     */\r\n    function fillSellOrder(uint _key) public payable {\r\n        uint order = orderBook.get(_key);\r\n        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\r\n        require(orderType == ORDER_TYPE.SELL, \"This is not a sell order\");\r\n        uint index = addressRegister(msg.sender);\r\n        require(index != (order << 2) >> 224, \"You cannot fill your own order\");\r\n\r\n        uint price = (order << 34) >> 145;\r\n        uint amount = (order << 145) >> 145;\r\n\r\n        uint orderFee = feeForOrder(price, amount);\r\n        require(feeBalances[index] >= orderFee, \"You do not have enough deposited fees to fill this order\");\r\n\r\n        uint cost = price.mul(amount).div(1 ether);\r\n        require(msg.value == cost, \"ETH sent needs to equal the cost\");\r\n\r\n        require(orderBook.remove(_key), \"Map remove failed\");\r\n\r\n        addressRegistry[(order << 2) >> 224].transfer(msg.value);\r\n        poolOwners.sendOwnership(msg.sender, amount);\r\n\r\n        if (orderFee > 0) {\r\n            feeBalances[index] = feeBalances[index].sub(orderFee);\r\n            feeBalances[0] = feeBalances[0].add(orderFee);\r\n            lockedFees = lockedFees.sub(orderFee);\r\n        }\r\n\r\n        emit OrderFilled(orderType, addressRegistry[(order << 2) >> 224], msg.sender, price, amount);\r\n    }\r\n\r\n    /**\r\n        @dev Fill a buy order in the order book\r\n        @dev Orders have to be filled in whole amounts\r\n        @param _key Key of the order, which is the buyers address\r\n     */\r\n    function fillBuyOrder(uint _key) public {\r\n        uint order = orderBook.get(_key);\r\n        ORDER_TYPE orderType = ORDER_TYPE(order >> 254);\r\n        require(orderType == ORDER_TYPE.BUY, \"This is not a buy order\");\r\n        uint index = addressRegister(msg.sender);\r\n        require(index != (order << 2) >> 224, \"You cannot fill your own order\");\r\n\r\n        uint price = (order << 34) >> 145;\r\n        uint amount = (order << 145) >> 145;\r\n\r\n        uint orderFee = feeForOrder(price, amount);\r\n        require(feeBalances[index] >= orderFee, \"You do not have enough deposited fees to fill this order\");\r\n\r\n        uint cost = price.mul(amount).div(1 ether);\r\n        \r\n        require(orderBook.remove(_key), \"Map remove failed\");\r\n\r\n        msg.sender.transfer(cost);\r\n        poolOwners.sendOwnershipFrom(msg.sender, addressRegistry[(order << 2) >> 224], amount);\r\n\r\n        if (orderFee > 0) {\r\n            feeBalances[index] = feeBalances[index].sub(orderFee);\r\n            feeBalances[0] = feeBalances[0].add(orderFee);\r\n            lockedFees = lockedFees.sub(orderFee);\r\n        }\r\n\r\n        emit OrderFilled(orderType, addressRegistry[(order << 2) >> 224], msg.sender, price, amount);\r\n    }\r\n\r\n    /**\r\n        @dev Send tokens earned via fees back to PoolOwners to be re-distributed\r\n     */\r\n    function withdrawFeesToPoolOwners() public {\r\n        uint feeBalance = feeBalances[0];\r\n        require(feeBalance > lockedFees, \"Contract doesn't have a withdrawable fee balance\");\r\n        feeBalances[0] = lockedFees;\r\n        uint amount = feeBalance.sub(lockedFees);\r\n        totalFees = totalFees.sub(amount);\r\n        feeToken.transfer(poolOwners, amount);\r\n    }\r\n\r\n    /**\r\n        @dev Send any fee token earned via PoolOwners distribution back to be re-distributed\r\n     */\r\n    function withdrawDistributedToPoolOwners() public {\r\n        uint balance = feeToken.balanceOf(this).sub(totalFees);\r\n        require(balance > 0, \"There is no distributed fee token balance in the contract\");\r\n        feeToken.transfer(poolOwners, balance);\r\n    }\r\n\r\n    /**\r\n        @dev Get a single order by its key\r\n        @param _key The key of the order as per the book\r\n     */\r\n    function getOrder(uint _key) public view returns (ORDER_TYPE, address, uint, uint) {\r\n        uint order = orderBook.get(_key);\r\n        return (\r\n            ORDER_TYPE(order >> 254), \r\n            addressRegistry[(order << 2) >> 224], \r\n            (order << 34) >> 145, \r\n            (order << 145) >> 145\r\n        );\r\n    }\r\n\r\n    /**\r\n        @dev Get a batch of 10 orders by a given array of keys\r\n        @dev ID's has to be equal or less than 10 in length, or an empty response is given\r\n        @param _start The starting index in the order book to return from\r\n     */\r\n    function getOrders(uint _start) public view returns (\r\n        uint[10] keys,\r\n        address[10] addresses, \r\n        ORDER_TYPE[10] orderTypes, \r\n        uint[10] prices, \r\n        uint[10] amounts\r\n    ) {\r\n        for (uint i = 0; i < 10; i++) {\r\n            if (orderBook.size() == _start + i) {\r\n                break;\r\n            }\r\n            uint key = orderBook.getKey(_start + i);\r\n            keys[i] = key;\r\n            uint order = orderBook.get(key);\r\n            addresses[i] = addressRegistry[(order << 2) >> 224];\r\n            orderTypes[i] = ORDER_TYPE(order >> 254);\r\n            prices[i] = (order << 34) >> 145;\r\n            amounts[i] = (order << 145) >> 145;\r\n        }\r\n        return (keys, addresses, orderTypes, prices, amounts);\r\n    }\r\n\r\n    /**\r\n        @dev Get an orderbook key from the orderbook index\r\n        @param _i The index to fetch the key for\r\n     */\r\n    function getOrderBookKey(uint _i) public view returns (uint key) {\r\n        if (_i < orderBook.size()) {\r\n            key = orderBook.getKey(_i);\r\n        } else {\r\n            key = 0;\r\n        }\r\n        return key;\r\n    }\r\n\r\n    /**\r\n        @dev Get orderbook keys in batches of 10\r\n        @param _start The start of the index for the batch\r\n     */\r\n    function getOrderBookKeys(uint _start) public view returns (uint[10] keys) {\r\n        for (uint i = 0; i < 10; i++) {\r\n            if (i + _start < orderBook.size()) {\r\n                keys[i] = orderBook.getKey(_start + i);\r\n            } else {\r\n                keys[i] = 0;\r\n            }\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    /**\r\n        @dev Get the orderbook size to allow for batch fetching of keys\r\n     */\r\n    function getOrderBookSize() public view returns (uint) {\r\n        return orderBook.size();\r\n    }\r\n\r\n    /**\r\n        @dev Verify that the number being passed fits into 111 bits for packing\r\n        @param _val The value to check\r\n     */\r\n    function is111bit(uint _val) private pure returns (bool) {\r\n        return (_val < 1 << 111);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"removeSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"getOrders\",\"outputs\":[{\"name\":\"keys\",\"type\":\"uint256[10]\"},{\"name\":\"addresses\",\"type\":\"address[10]\"},{\"name\":\"orderTypes\",\"type\":\"uint8[10]\"},{\"name\":\"prices\",\"type\":\"uint256[10]\"},{\"name\":\"amounts\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"feeForOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrderBookSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getOrderBookKey\",\"outputs\":[{\"name\":\"key\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"costOfOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDistributedToPoolOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFeesToPoolOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"fillBuyOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addBuyOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"fillSellOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawFeeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"removeBuyOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"getOrderBookKeys\",\"outputs\":[{\"name\":\"keys\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_poolOwners\",\"type\":\"address\"},{\"name\":\"_feeToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OrderRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OrderFilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OwnersExchange","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a038b9b36f22485ff0d4e48842d4a1905054e856000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca","Library":"","SwarmSource":"bzzr://00ffa4d28e4e5a08283070ab57e9dddfcca749b10e9fee9878fc349bdc40f84c"}]}