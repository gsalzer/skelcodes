{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/**\r\n * @title -FoMo-3D v0.7.1\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//     _    _  _ _|_ _  .\r\n//    (/_\\/(/_| | | _\\  .\r\n//==============================================================================\r\ncontract F3Devents {\r\n}\r\n\r\n//==============================================================================\r\n//   _ _  _ _|_ _ _  __|_   _ _ _|_    _   .\r\n//  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  .\r\n//====================================|=========================================\r\n\r\ncontract modularLong is F3Devents, Ownable {}\r\n\r\ncontract F3DPRO is modularLong {\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n    using F3DKeysCalcLong for uint256;\r\n\r\n    otherFoMo3D private otherF3D_;\r\n    //P3D分红，暂时不设置，表示无\r\n    DiviesInterface constant private Divies= DiviesInterface(0x0);\r\n    //基金钱包 注册费用也发送到这里\r\n    address constant private myWallet = 0xD979E48Dcb35Ebf096812Df53Afb3EEDADE21496;\r\n    //代币钱包\r\n    address constant private tokenWallet = 0x13E8618b19993D10fEFBEfe8918E45B0A53ccd28;\r\n    //最后大奖池的基金钱包\r\n    /* address constant private myWallet1 = 0xD979E48Dcb35Ebf096812Df53Afb3EEDADE21496; */\r\n    //技术钱包\r\n    address constant private devWallet = 0x9fD04609909Fd0C9717B235a2D25d5e8E9C1058C;\r\n    //大玩家钱包分成的钱包\r\n    address constant private bigWallet = 0x1a4D01e631Eac50b2640D8ADE9873d56bAf841d0;\r\n    //注册费用专用钱包，注册费用发送到这里\r\n    /* address constant private smallWallet = 0xD979E48Dcb35Ebf096812Df53Afb3EEDADE21496; */\r\n    //最后赢家的钱包\r\n    address constant private lastWallet = 0x883d0d727C72740BD2dA9a964E8273af7bDC9B0B;\r\n    //倒数2-20名赢家的钱包\r\n    address constant private lastWallet1 = 0x84F0ad9A94dC6fd614c980Fc84dab234b474CE13;\r\n    //推荐奖拿不到的部分\r\n    address constant private extraWallet = 0xf811B1e061B6221Ec58cd9D069FC2fF0Bf5f4225;\r\n\r\n    address constant private backWallet = 0x9Caed3d542260373153fC7e44474cf8359e6cFFC;\r\n    //super wallets\r\n    /* address[] private superWallets2 = [0xAD81260195048D1CafDe04856994d60c14E2188d,0xd0A7bb524cD1a270330B86708f153681E06e6877,0x018EA24948e650f1a1b384eC29C39278362d72cc];\r\n    address[] private superWallets3 = [0x488441BC31F5cCD92F6333CBc74AA68bFfFAc21C,0xb7Eba9DA458935257694d493cAb5F662AE08C17E,0x28E7168bcf0e3871e3F8C950a4582Bb692139943,0x0b1Fc83f411F43716510C1B87DBDDfd4443AAfd4,0xd4DCe2705991f77103e919CA986247Fb9A046CC5,0x21841dDcd720596Ae9Dbd6eDbDaCB05AcD5A8417,0x9c14c3a3c6B27467203f8d3939Fdbb71f3519eB5,0xcd96B3bc4e2eb3cA56183ec4CdA3bCCE40c53078,0x923B9E49dd0B78739CA87bFBBA149B9E1cf00882,0xA5727E469Df4212e03816449b4606b6534f86f6b]; */\r\n\r\n\r\n    //玩家数据\r\n    PlayerBookInterface private PlayerBook;// = PlayerBookInterface(0x9d9e290c54ed9dce97a31b90c430955f259a2e82);\r\n\r\n    function setPlayerBook(address _address) external onlyOwner {\r\n        PlayerBookInterface pBook = PlayerBookInterface(_address);\r\n        // Set the new contract address\r\n        PlayerBook = pBook;\r\n    }\r\n    //==============================================================================\r\n    //     _ _  _  |`. _     _ _ |_ | _  _  .\r\n    //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\r\n    //=================_|===========================================================\r\n\r\n    string constant public name = \"F3DPRO\";\r\n    string constant public symbol = \"F3P\";\r\n    uint256 private rndExtra_ = 15 seconds;                     // length of the very first ICO，相当于是延时多少秒倒计时正式开始\r\n    uint256 private rndGap_ = 24 hours;                         //回合之间的休息时间，投资会进入零钱而不是立刻开始\r\n    bool private    affNeedName_ = true;                        //是否需要注册名字才能获得推广链,， 暂时不能false，会导致空用户获得推广奖励\r\n    uint256 constant private rndInit_ = 8 hours;                // round timer starts at this, 回合起始倒计时\r\n    uint256 constant private rndInc_ = 60 seconds;              // every full key purchased adds this much to the timer\r\n    uint256 constant private rndMax_ = rndInit_;                // max length a round timer can be\r\n\r\n    uint256 constant private keyPriceStart_ = 150 szabo;//key的起始价,如果需要改动，两个地方都要改，math那里 0.015ETH\r\n\r\n    uint256 constant private keyPriceStep_   = 1 wei;       //key价格上涨阶梯\r\n    //推荐奖⼀代7% 二至⼗代2%\r\n    uint256[] public affsRate_ = [280,80,80,80,80,80,80,80,80,80];           //Multi levels of AFF's award, /1000\r\n\r\n    // uint256 private realRndMax_ = rndMax_;               //实际的最大倒计时\r\n    // uint256 constant private keysToReduceMaxTime_ = 10000;//10000个key减少最大倒计时\r\n    // uint256 constant private reduceMaxTimeStep_ = 0 seconds;//一次减少最大倒计时的数量\r\n    // uint256 constant private minMaxTime_ = 2 hours;//最大倒计时的最低限度\r\n\r\n    uint256 constant private comFee_ = 1;                       //基金分成\r\n    uint256 constant private devFee_ = 2;                      //技术分成\r\n    uint256 constant private affFee_ = 25;                       //aff rewards for invite friends, if has not aff then to com\r\n    uint256 constant private airdropFee_ = 1;                   //airdrop rewards\r\n    uint256 constant private bigPlayerFee_ = 10;                //大玩家分红\r\n    uint256 constant private smallPlayerFee_ = 0;               //小玩家分红\r\n    uint256 constant private feesTotal_ = comFee_ + devFee_ + affFee_ + airdropFee_ + smallPlayerFee_ + bigPlayerFee_;\r\n\r\n\r\n    uint256 constant private minInvestWinner_ = 500 finney;//获得最后奖池的最小投资额度,0.5ETH\r\n    uint256 constant private comFee1_ = 5;                      //大奖池里基金分成比例\r\n    uint256 constant private winnerFee_ =  45;                   //最后一名奖励\r\n    uint256 constant private winnerFee1_ = 30;                   //2-20名奖励\r\n    uint256 constant private winnerFee2_ = 15;                   //21-300名奖励\r\n    /* uint256 constant private winnerFee3_ = 10;                   //151-500名奖励 */\r\n\r\n    uint256 constant private bigAirdrop_ = 75;                    //big airdrop\r\n    uint256 constant private midAirdrop_ = 50;                    //mid airdrop\r\n    uint256 constant private smallAirdrop_ = 25;                    //small airdrop\r\n\r\n    //10倍出局，3倍给ETH，1倍给代币，6倍复投\r\n    //提币会不会影响复投\r\n    uint256 constant private maxEarningRate_ = 500;                //最大获利倍数，百分比\r\n    uint256 constant private keysLeftRate_ = 0;                  //达到最大获利倍数后，剩余多大比例的keys留下继续分红, 相对于maxEarningRate_的比例\r\n    uint256 constant private keysToToken_ = 200;                   //1倍给代币AGK\r\n    uint256 constant public  tokenPrice_ = 1 szabo;          //AGK的价格:0.000001ETH\r\n    uint256 constant private keysCostTotal_ = keysLeftRate_ + keysToToken_;\r\n\r\n    uint256 public registerVIPFee_ = 10 ether; // Register group fee, 1.0ETH\r\n    uint256 public constant vipMinEth_ = 10 ether; //小玩家最小直推业绩，10Eth，才能参与分红\r\n    mapping (uint256 => uint256) public vipIDs_; // all the vip player id\r\n    uint256 public vipPlayersCount_;\r\n\r\n    //==============================================================================\r\n    //     _| _ _|_ _    _ _ _|_    _   .\r\n    //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes)\r\n    //=============================|================================================\r\n    uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot\r\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n    //****************\r\n    // PLAYER DATA\r\n    //****************\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => F3Ddatasets.Player) public plyr_;   // (pID => data) player data\r\n    mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own)\r\n    //****************\r\n    // ROUND DATA\r\n    //****************\r\n    mapping (uint256 => F3Ddatasets.Round) public round_;   // (rID => data) round data\r\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id\r\n    mapping (uint256 => mapping(uint256 => F3Ddatasets.Aff)) public plyrAffs_;//(pID => index => Aff) the player's affs\r\n    mapping (uint256 => mapping(uint256 => F3Ddatasets.Invest)) public rndInvests_; //(rID => index => Invest) invest sequence by round id\r\n    mapping (uint256 => uint256) public rndInvestsCount_;                   //(rID => count)total invest count by round id\r\n\r\n    //****************\r\n    // TEAM FEE DATA\r\n    //****************\r\n    mapping (uint256 => F3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team\r\n    mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team\r\n    //==============================================================================\r\n    //     _ _  _  __|_ _    __|_ _  _  .\r\n    //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n    //==============================================================================\r\n    constructor()\r\n    public\r\n    {\r\n        // Team allocation structures\r\n        // 0 = whales\r\n        // 1 = bears\r\n        // 2 = sneks\r\n        // 3 = bulls\r\n        // Team allocation percentages\r\n        // (F3D, P3D) + (Pot , Referrals, Community)\r\n        // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot.\r\n        fees_[0] = F3Ddatasets.TeamFee(46,0);   //15% to pot, 6% to aff, 6% to com, 6% to dev, 1% to air drop pot\r\n        fees_[1] = F3Ddatasets.TeamFee(46,0);   //15% to pot, 6% to aff, 6% to com, 6% to dev, 1% to air drop pot\r\n        fees_[2] = F3Ddatasets.TeamFee(46,0);  //15% to pot, 6% to aff, 6% to com, 6% to dev, 1% to air drop pot\r\n        fees_[3] = F3Ddatasets.TeamFee(46,0);   //15% to pot, 6% to aff, 6% to com, 6% to dev, 1% to air drop pot\r\n\r\n        // how to split up the final pot based on which team was picked\r\n        // (F3D, P3D)\r\n        potSplit_[0] = F3Ddatasets.PotSplit(0,0);  //77% to winner, 5% to next round, 4% to com\r\n        potSplit_[1] = F3Ddatasets.PotSplit(0,0);   //77% to winner, 5% to next round, 4% to com\r\n        potSplit_[2] = F3Ddatasets.PotSplit(0,0);  //77% to winner, 5% to next round, 4% to com\r\n        potSplit_[3] = F3Ddatasets.PotSplit(0,0);  //77% to winner, 5% to next round, 4% to com\r\n    }\r\n    //==============================================================================\r\n    //     _ _  _  _|. |`. _  _ _  .\r\n    //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n    //==============================================================================\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has\r\n     * been activated.\r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not ready yet.  check ?eta in discord\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d\r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;\r\n    }\r\n\r\n    //==============================================================================\r\n    //     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n    //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n    //====|=========================================================================\r\n    /**\r\n     * @dev emergency buy uses last stored affiliate ID and team snek\r\n     */\r\n    function()\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        // buy core\r\n        buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev converts all incoming ethereum to keys.\r\n     * -functionhash- 0x8f38f309 (using ID for affiliate)\r\n     * -functionhash- 0x98a0871d (using address for affiliate)\r\n     * -functionhash- 0xa65b37a1 (using name for affiliate)\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     * @param _team what team is the player playing for?\r\n     */\r\n    function buyXid(uint256 _affCode, uint256 _team)\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == 0 || _affCode == _pID)\r\n        {\r\n            // use last stored affiliate code\r\n            _affCode = plyr_[_pID].laff;\r\n\r\n            // if affiliate code was given & its not the same as previously stored\r\n        } else if (_affCode != plyr_[_pID].laff) {\r\n            // update last affiliate\r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n\r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n\r\n        // buy core\r\n        buyCore(_pID, _affCode, _team, _eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev essentially the same as buy, but instead of you sending ether\r\n     * from your wallet, it uses your unwithdrawn earnings.\r\n     * -functionhash- 0x349cdcac (using ID for affiliate)\r\n     * -functionhash- 0x82bfc739 (using address for affiliate)\r\n     * -functionhash- 0x079ce327 (using name for affiliate)\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     * @param _team what team is the player playing for?\r\n     * @param _eth amount of earnings to use (remainder returned to gen vault)\r\n     */\r\n    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(_eth)\r\n    public\r\n    {\r\n        // set up our tx event data\r\n        F3Ddatasets.EventReturns memory _eventData_;\r\n\r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == 0 || _affCode == _pID)\r\n        {\r\n            // use last stored affiliate code\r\n            _affCode = plyr_[_pID].laff;\r\n\r\n            // if affiliate code was given & its not the same as previously stored\r\n        } else if (_affCode != plyr_[_pID].laff) {\r\n            // update last affiliate\r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n\r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n\r\n        // reload core\r\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraws all of your earnings.\r\n     * -functionhash- 0x3ccfd60b\r\n     */\r\n    function withdraw()\r\n    isActivated()\r\n    isHuman()\r\n    public\r\n    {\r\n        if(msg.sender == owner) {\r\n            backWallet.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        uint _amount;\r\n        uint _tokenEth;\r\n\r\n\r\n        // set up our tx event data\r\n        F3Ddatasets.EventReturns memory _eventData_;\r\n\r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // end the round (distributes pot)\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID, true);\r\n\r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n\r\n            //agk\r\n            if(plyr_[_pID].agk > 0 && (plyr_[_pID].agk > plyr_[_pID].usedAgk)){\r\n                 _amount = plyr_[_pID].agk.sub(plyr_[_pID].usedAgk);\r\n                plyr_[_pID].usedAgk = plyr_[_pID].agk;\r\n                 _tokenEth = _amount.mul(tokenPrice_) ;\r\n                if(_tokenEth > 0)\r\n                    tokenWallet.transfer(_tokenEth);\r\n            }\r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            // fire withdraw and distribute event\r\n            // emit F3Devents.onWithdrawAndDistribute\r\n            // (\r\n            //     msg.sender,\r\n            //     plyr_[_pID].name,\r\n            //     _eth,\r\n            //     _eventData_.compressedData,\r\n            //     _eventData_.compressedIDs,\r\n            //     _eventData_.winnerAddr,\r\n            //     _eventData_.winnerName,\r\n            //     _eventData_.amountWon,\r\n            //     _eventData_.newPot,\r\n            //     _eventData_.P3DAmount,\r\n            //     _eventData_.genAmount\r\n            // );\r\n\r\n            // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID, true);\r\n\r\n            //agk\r\n            if(plyr_[_pID].agk > 0 && (plyr_[_pID].agk > plyr_[_pID].usedAgk)){\r\n                 _amount = plyr_[_pID].agk.sub(plyr_[_pID].usedAgk);\r\n                plyr_[_pID].usedAgk = plyr_[_pID].agk;\r\n                 _tokenEth = _amount.mul(tokenPrice_) ;\r\n                if(_tokenEth > 0)\r\n                    tokenWallet.transfer(_tokenEth);\r\n            }\r\n\r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n\r\n            // fire withdraw event\r\n            // emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev use these to register names.  they are just wrappers that will send the\r\n     * registration requests to the PlayerBook contract.  So registering here is the\r\n     * same as registering there.  UI will always display the last name you registered.\r\n     * but you will still own all previously registered names to use as affiliate\r\n     * links.\r\n     * - must pay a registration fee.\r\n     * - name must be unique\r\n     * - names will be converted to lowercase\r\n     * - name cannot start or end with a space\r\n     * - cannot have more than 1 space in a row\r\n     * - cannot be only numbers\r\n     * - cannot start with 0x\r\n     * - name must be at least 1 char\r\n     * - max length of 32 characters long\r\n     * - allowed characters: a-z, 0-9, and space\r\n     * -functionhash- 0x921dec21 (using ID for affiliate)\r\n     * -functionhash- 0x3ddd4698 (using address for affiliate)\r\n     * -functionhash- 0x685ffd83 (using name for affiliate)\r\n     * @param _nameString players desired name\r\n     * @param _affCode affiliate ID, address, or name of who referred you\r\n     * @param _all set to true if you want this to push your info to all games\r\n     * (this might cost a lot of gas)\r\n     */\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all)\r\n    isHuman()\r\n    public\r\n    payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\r\n        // fire event\r\n        // emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    /***\r\n        Rigister group aff for 1 eth\r\n    */\r\n    function registerVIP()\r\n    isHuman()\r\n    public\r\n    payable\r\n    {\r\n        require (msg.value >= registerVIPFee_, \"Your eth is not enough to be group aff\");\r\n        // set up our tx event data and determine if player is new or not\r\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        //is vip already\r\n        if(plyr_[_pID].vip) {\r\n            revert();\r\n        }\r\n\r\n        //give myWallet the eth\r\n        myWallet.transfer(msg.value);\r\n\r\n        //save the info\r\n        plyr_[_pID].vip = true;\r\n        vipIDs_[vipPlayersCount_] = _pID;\r\n        vipPlayersCount_++;\r\n    }\r\n\r\n    function adminRegisterVIP(uint256 _pID)\r\n    onlyOwner\r\n    public{\r\n        plyr_[_pID].vip = true;\r\n        vipIDs_[vipPlayersCount_] = _pID;\r\n        vipPlayersCount_++;\r\n    }\r\n\r\n    function getAllPlayersInfo(uint256 _maxID) external view returns(uint256[], address[]){\r\n        uint256 counter = PlayerBook.getPlayerCount();\r\n        uint256[] memory resultArray = new uint256[](counter - _maxID + 1);\r\n        address[] memory resultArray1 = new address[](counter - _maxID + 1);\r\n        for(uint256 j = _maxID; j <= counter; j++){\r\n            resultArray[j - _maxID] = PlayerBook.getPlayerLAff(j);\r\n            resultArray1[j - _maxID] = PlayerBook.getPlayerAddr(j);\r\n        }\r\n        return (resultArray, resultArray1);\r\n    }\r\n    //==============================================================================\r\n    //     _  _ _|__|_ _  _ _  .\r\n    //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n    //=====_|=======================================================================\r\n    /**\r\n     * @dev return the price buyer will pay for next 1 individual key.\r\n     * -functionhash- 0x018a25e8\r\n     * @return price for next key bought (in wei format)\r\n     */\r\n    function getBuyPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // are we in a round?\r\n        if (isRoundActive())\r\n            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( keyPriceStart_ ); // init\r\n    }\r\n\r\n    /**\r\n        is round in active?\r\n    */\r\n    function isRoundActive()\r\n    public\r\n    view\r\n    returns(bool)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab time\r\n        uint256 _now = now;\r\n        //过了休息时间，并且没有超过终止时间或超过了终止时间没有人购买，都算是激活\r\n        return _now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0));\r\n    }\r\n\r\n    /**\r\n      Round over but not distribute\r\n    */\r\n    function isRoundEnd()\r\n    public\r\n    view\r\n    returns(bool)\r\n    {\r\n        return now > round_[rID_].end && round_[rID_].ended == false && round_[rID_].plyr != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node\r\n     * provider\r\n     * -functionhash- 0xc7e284b8\r\n     * @return time left in seconds\r\n     */\r\n    function getTimeLeft()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        if (_now < round_[_rID].end)\r\n            if (_now > round_[_rID].strt + rndGap_)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].strt + rndGap_).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n\r\n    /**\r\n     * @dev returns player earnings per vaults\r\n     * -functionhash- 0x63066434\r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n     */\r\n    function getPlayerVaults(uint256 _pID)\r\n    public\r\n    view\r\n    returns(uint256 ,uint256, uint256, uint256, uint256)\r\n    {\r\n        uint256 _ppt = 0;\r\n        //如果此轮结束但尚未触发分配，则分红得加上大奖池pot中的分红\r\n        if (now > round_[rID_].end && round_[rID_].ended == false && round_[rID_].plyr != 0) {\r\n            _ppt = ((((round_[rID_].pot).mul(potSplit_[round_[rID_].team].gen)) / 100).mul(1000000000000000000));\r\n            _ppt = _ppt / (round_[rID_].keys);\r\n        }\r\n\r\n        uint256[] memory _earnings = calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd, 0, 0, _ppt);\r\n        // uint256 _keysOff = plyrRnds_[_pID][plyr_[_pID].lrnd].keysOff;\r\n        // uint256 _ethOff = plyrRnds_[_pID][plyr_[_pID].lrnd].ethOff;\r\n\r\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\r\n        //倒计时结束后，需要buy或者withdraw才能触发endround过程\r\n        if (_ppt > 0 && round_[rID_].plyr == _pID)\r\n        {\r\n            _ppt = ((round_[rID_].pot).mul(winnerFee_)) / 100;\r\n        } else {\r\n            _ppt = 0;\r\n        }\r\n\r\n        return\r\n            (\r\n            plyr_[_pID].win.add(_ppt),\r\n            (plyr_[_pID].gen).add(_earnings[0]),\r\n            // plyr_[_pID].aff,\r\n            plyrRnds_[_pID][plyr_[_pID].lrnd].keysOff.add(_earnings[1]),\r\n            // _ethOff.add(_earnings[2]),\r\n            plyr_[_pID].agk.add(_earnings[4]/tokenPrice_), //token数量\r\n            plyr_[_pID].reEth.add(_earnings[5])//复投的eth\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev returns all current round info needed for front end\r\n     * -functionhash- 0x747dff42\r\n     * @return eth invested during ICO phase\r\n     * @return round id\r\n     * @return total keys for round\r\n     * @return time round ends\r\n     * @return time round started\r\n     * @return current pot\r\n     * @return current team ID & player ID in lead\r\n     * @return current player in leads address\r\n     * @return current player in leads name\r\n     * @return whales eth in for round\r\n     * @return bears eth in for round\r\n     * @return sneks eth in for round\r\n     * @return bulls eth in for round\r\n     * @return airdrop tracker # & airdrop pot\r\n     */\r\n    function getCurrentRoundInfo()\r\n    public\r\n    view\r\n    returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        return\r\n        (\r\n        round_[_rID].ico,               //0\r\n        _rID,                           //1\r\n        round_[_rID].keys,              //2\r\n        round_[_rID].end,               //3\r\n        round_[_rID].strt,              //4\r\n        round_[_rID].pot,               //5\r\n        (round_[_rID].team + (round_[_rID].plyr * 10)),     //6\r\n        plyr_[round_[_rID].plyr].addr,  //7\r\n        plyr_[round_[_rID].plyr].name,  //8\r\n        rndTmEth_[_rID][0],             //9\r\n        rndTmEth_[_rID][1],             //10\r\n        rndTmEth_[_rID][2],             //11\r\n        rndTmEth_[_rID][3],             //12\r\n        airDropTracker_ + (airDropPot_ * 1000)             //13\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address.  if no address is given, it will\r\n     * use msg.sender\r\n     * -functionhash- 0xee0b5d8b\r\n     * @param _addr address of the player you want to lookup\r\n     * @return player ID\r\n     * @return player name\r\n     * @return keys owned (current round)\r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n\t * @return player round eth\r\n     */\r\n    function getPlayerInfoByAddress(address _addr)\r\n    public\r\n    view\r\n    returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256)\r\n    {\r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        if(_pID == 0) {\r\n            _pID = PlayerBook.pIDxAddr_(_addr);\r\n        }\r\n\r\n        uint256[] memory _earnings = calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd, 0, 0, 0);\r\n\r\n        return\r\n        (\r\n        _pID,                               //0\r\n        //plyr_[_pID].name,\r\n        PlayerBook.getPlayerName(_pID),     //1\r\n        plyrRnds_[_pID][rID_].keys,         //2\r\n        plyr_[_pID].win,                    //3\r\n        (plyr_[_pID].gen).add(_earnings[0]),//4\r\n        plyr_[_pID].aff,                    //5\r\n        plyrRnds_[_pID][rID_].eth,          //6\r\n        //plyr_[_pID].laff\r\n        PlayerBook.getPlayerLAff(_pID),     //7\r\n        plyr_[_pID].affCount,               //8\r\n        plyr_[_pID].vip,                    //9\r\n        plyr_[_pID].smallEth                //10\r\n        );\r\n    }\r\n\r\n    //==============================================================================\r\n    //     _ _  _ _   | _  _ . _  .\r\n    //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine)\r\n    //=====================_|=======================================================\r\n    /**\r\n     * @dev logic runs whenever a buy order is executed.  determines how to handle\r\n     * incoming eth depending on if we are in an active round or not\r\n     */\r\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\r\n    private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // if round is active\r\n        if (isRoundActive())\r\n        {\r\n            // call core\r\n            core(_rID, _pID, msg.value, _affID, _team, _eventData_, true);\r\n\r\n            // if round is not active\r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false)\r\n            {\r\n                // end the round (distributes pot) & start new round\r\n                round_[_rID].ended = true;\r\n                _eventData_ = endRound(_eventData_);\r\n\r\n                // build event data\r\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n                // fire buy and distribute event\r\n                // emit F3Devents.onBuyAndDistribute\r\n                // (\r\n                //     msg.sender,\r\n                //     plyr_[_pID].name,\r\n                //     msg.value,\r\n                //     _eventData_.compressedData,\r\n                //     _eventData_.compressedIDs,\r\n                //     _eventData_.winnerAddr,\r\n                //     _eventData_.winnerName,\r\n                //     _eventData_.amountWon,\r\n                //     _eventData_.newPot,\r\n                //     _eventData_.P3DAmount,\r\n                //     _eventData_.genAmount\r\n                // );\r\n            }\r\n\r\n            // put eth in players vault\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev logic runs whenever a reload order is executed.  determines how to handle\r\n     * incoming eth depending on if we are in an active round or not\r\n     */\r\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)\r\n    private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // if round is active\r\n        if (isRoundActive())\r\n        {\r\n            // get earnings from all vaults and return unused to gen vault\r\n            // because we use a custom safemath library.  this will throw if player\r\n            // tried to spend more eth than they have.\r\n            plyr_[_pID].gen = withdrawEarnings(_pID, false).sub(_eth);\r\n\r\n            // call core\r\n            core(_rID, _pID, _eth, _affID, _team, _eventData_, true);\r\n\r\n            // if round is not active and end round needs to be ran\r\n        } else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n            // end the round (distributes pot) & start new round\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            // fire buy and distribute event\r\n            // emit F3Devents.onReLoadAndDistribute\r\n            // (\r\n            //     msg.sender,\r\n            //     plyr_[_pID].name,\r\n            //     _eventData_.compressedData,\r\n            //     _eventData_.compressedIDs,\r\n            //     _eventData_.winnerAddr,\r\n            //     _eventData_.winnerName,\r\n            //     _eventData_.amountWon,\r\n            //     _eventData_.newPot,\r\n            //     _eventData_.P3DAmount,\r\n            //     _eventData_.genAmount\r\n            // );\r\n        }\r\n    }\r\n\r\n    function validateInvest(uint256 _rID, uint256 _pID, uint256 _eth)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        //100个投资以下，最多不超过1eth，多余的进余额\r\n        //100个及以上，最多不超过20eth，多余的进余额\r\n        if (rndInvestsCount_[_rID] < 100)\r\n        {\r\n            if(_eth > 1 ether) {\r\n                uint256 _refund = _eth.sub(1 ether);\r\n                plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n                _eth = _eth.sub(_refund);\r\n            }\r\n        } else {\r\n            if(_eth > 20 ether) {\r\n                _refund = _eth.sub(20 ether);\r\n                plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n                _eth = _eth.sub(_refund);\r\n            }\r\n        }\r\n        return _eth;\r\n    }\r\n\r\n    /**\r\n     * @dev this is the core logic for any buy/reload that happens while a round\r\n     * is live.\r\n     */\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_, bool _realBuy)\r\n    private\r\n    returns (bool)\r\n    {\r\n        require(buyable_ == true, \"can not buy!\");\r\n\r\n        // if player is new to round\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_);\r\n\r\n        // early round eth limiter\r\n        _eth = validateInvest(_rID, _pID, _eth);\r\n\r\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\r\n        if (_eth > 1000000000)\r\n        {\r\n            // mint the new keys\r\n            uint256 _keys = (round_[_rID].eth).keysRec(_eth);\r\n\r\n            // if they bought at least 1 whole key\r\n            if (_keys >= 1000000000000000000)\r\n            {\r\n                //real eth cost\r\n                uint256 _realEth = _eth.mul((_keys / 1000000000000000000).mul(1000000000000000000)) / _keys;\r\n                //make sure the keys is uint\r\n                _keys = (_keys / 1000000000000000000).mul(1000000000000000000);\r\n                //the dust to player's vault\r\n                plyr_[_pID].gen = (_eth.sub(_realEth)).add(plyr_[_pID].gen);\r\n                //real eth cost\r\n                _eth = _realEth;\r\n\r\n                if(_realBuy) {\r\n                    // set new leaders\r\n                    if (round_[_rID].plyr != _pID)\r\n                        round_[_rID].plyr = _pID;\r\n                    if (round_[_rID].team != _team)\r\n                        round_[_rID].team = _team;\r\n                    updateTimer(_keys, _rID);\r\n                }\r\n\r\n                // set the new leader bool to true\r\n                _eventData_.compressedData = _eventData_.compressedData + 100;\r\n            } else {\r\n                //give back the money to player's vault\r\n                plyr_[_pID].gen = _eth.add(plyr_[_pID].gen);\r\n                //You should buy at most one key one time\r\n                return false;\r\n            }\r\n\r\n            // manage airdrops > 0.1ETH\r\n            if (_eth >= 100000000000000000)\r\n            {\r\n                // gib muni\r\n                uint256 _prize = 0;\r\n                //draw card\r\n                airDropTracker_++;\r\n                if (airdrop() == true)\r\n                {\r\n                    if (_eth >= 10000000000000000000)\r\n                    {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(bigAirdrop_)) / 100;\r\n                        // let event know a tier 3 prize was won\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(midAirdrop_)) / 100;\r\n                        // let event know a tier 2 prize was won\r\n                        _eventData_.compressedData += 200000000000000000000000000000000;\r\n                    } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(smallAirdrop_)) / 100;\r\n                        // let event know a tier 3 prize was won\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }\r\n                    // set airdrop happened bool to true\r\n                    _eventData_.compressedData += 10000000000000000000000000000000;\r\n                    // let event know how much was won\r\n                    _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\r\n\r\n                    // reset air drop tracker\r\n                    airDropTracker_ = 0;\r\n                }\r\n\r\n                if(_prize > 0) {\r\n                    plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                    // adjust airDropPot\r\n                    airDropPot_ = (airDropPot_).sub(_prize);\r\n                }\r\n            }\r\n\r\n            // store the air drop tracker number (number of buys since last airdrop)\r\n            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\r\n\r\n            //record the invest information\r\n            rndInvests_[_rID][rndInvestsCount_[_rID]].pid = _pID;\r\n            rndInvests_[_rID][rndInvestsCount_[_rID]].eth = _eth;\r\n            rndInvests_[_rID][rndInvestsCount_[_rID]].kid = round_[_rID].keys / 1000000000000000000;\r\n            rndInvests_[_rID][rndInvestsCount_[_rID]].keys = _keys / 1000000000000000000;\r\n            rndInvestsCount_[_rID]++;\r\n\r\n            // update player\r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n\r\n            // update round\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\r\n\r\n            // distribute eth\r\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\r\n\r\n            // call end tx function to fire end tx event.\r\n            endTx(_pID, _team, _eth, _keys, _eventData_);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    //==============================================================================\r\n    //     _ _ | _   | _ _|_ _  _ _  .\r\n    //    (_(_||(_|_||(_| | (_)| _\\  .\r\n    //==============================================================================\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\r\n     * @return earnings in wei format\r\n     */\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast, uint256 _subKeys, uint256 _subEth, uint256 _ppt)\r\n    private\r\n    view\r\n    returns(uint256[])\r\n    {\r\n        uint256[] memory result = new uint256[](6);\r\n\r\n        //实际可计算分红的keys数量，总数减去出局的keys数量\r\n        uint256 _realKeys = ((plyrRnds_[_pID][_rIDlast].keys).sub(plyrRnds_[_pID][_rIDlast].keysOff)).sub(_subKeys);\r\n        uint256 _investedEth = ((plyrRnds_[_pID][_rIDlast].eth).sub(plyrRnds_[_pID][_rIDlast].ethOff)).sub(_subEth);\r\n\r\n        //玩家拥有的key价值 = 当前keys分红单价 * 实际可分红的keys数量\r\n        uint256 _totalEarning = (((round_[_rIDlast].mask.add(_ppt))).mul(_realKeys)) / (1000000000000000000);\r\n        _totalEarning = _totalEarning.sub(plyrRnds_[_pID][_rIDlast].mask);\r\n\r\n        //记录总收益\r\n        result[3] = _totalEarning;\r\n        //已经计算过的收益，需要累计计算\r\n        result[0] = plyrRnds_[_pID][_rIDlast].genOff;\r\n\r\n        //是否到最大获利倍数\r\n        if(_investedEth > 0 && (_totalEarning.add(result[0])).mul(100) / _investedEth >= maxEarningRate_) {\r\n            //最多6倍(减去已计算的收益)\r\n            _totalEarning = (_investedEth.mul(maxEarningRate_) / 100).sub(result[0]);\r\n            //所有keys锁定\r\n            result[1] = _realKeys;//.mul(100 - keysLeftRate_.mul(100) / maxEarningRate_) / 100;//出局的key数量(去掉留下复投的keys, 简单点，实际情况是留下的keys稍多)\r\n            result[2] = _investedEth;//.mul(100 - keysLeftRate_.mul(100) / maxEarningRate_) / 100;//出局的eth数量\r\n        }\r\n        //可提取的eth收益\r\n        result[0] = _totalEarning.mul(100 - keysCostTotal_.mul(100) / maxEarningRate_) / 100;\r\n        //送等值token的eth\r\n        result[4] = (_totalEarning.mul(keysToToken_) / maxEarningRate_);\r\n        //准备复投的eth\r\n        result[5] = (_totalEarning.mul(keysLeftRate_) / maxEarningRate_);\r\n        //出局的收益，转移到pot中 = 总收益减 - 提取的eth - token的eth - 复投的eth\r\n        result[3] = result[3].sub(result[0]).sub(result[4]).sub(result[5]);\r\n\r\n        return( result );\r\n    }\r\n\r\n    /**\r\n     * @dev returns the amount of keys you would get given an amount of eth.\r\n     * -functionhash- 0xce89c80c\r\n     * @param _rID round ID you want price for\r\n     * @param _eth amount of eth sent in\r\n     * @return keys received\r\n     */\r\n    function calcKeysReceived(uint256 _rID, uint256 _eth)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        // are we in a round?\r\n        if (isRoundActive())\r\n            return ( (round_[_rID].eth).keysRec(_eth) );\r\n        else // rounds over.  need keys for new round\r\n            return ( (_eth).keys() );\r\n    }\r\n\r\n    /**\r\n     * @dev returns current eth price for X keys.\r\n     * -functionhash- 0xcf808000\r\n     * @param _keys number of keys desired (in 18 decimal format)\r\n     * @return amount of eth needed to send\r\n     */\r\n    function iWantXKeys(uint256 _keys)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // are we in a round?\r\n        if (isRoundActive())\r\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n    //==============================================================================\r\n    //    _|_ _  _ | _  .\r\n    //     | (_)(_)|_\\  .\r\n    //==============================================================================\r\n    /**\r\n\t * @dev receives name/player info from names contract\r\n     */\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\r\n    external\r\n    {\r\n        require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\r\n        if (pIDxAddr_[_addr] != _pID)\r\n            pIDxAddr_[_addr] = _pID;\r\n        if (pIDxName_[_name] != _pID)\r\n            pIDxName_[_name] = _pID;\r\n        if (plyr_[_pID].addr != _addr)\r\n            plyr_[_pID].addr = _addr;\r\n        if (plyr_[_pID].name != _name)\r\n            plyr_[_pID].name = _name;\r\n        if (plyr_[_pID].laff != _laff)\r\n            plyr_[_pID].laff = _laff;\r\n        if (plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev receives entire player name list\r\n     */\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name)\r\n    external\r\n    {\r\n        require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\r\n        if(plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev gets existing or registers new pID.  use this when a player may be new\r\n     * @return pID\r\n     */\r\n    function determinePID(F3Ddatasets.EventReturns memory _eventData_)\r\n    private\r\n    returns (F3Ddatasets.EventReturns)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        // if player is new to this version of fomo3d\r\n        if (_pID == 0)\r\n        {\r\n            // grab their player ID, name and last aff ID, from player names contract\r\n            _pID = PlayerBook.getPlayerID(msg.sender);\r\n            bytes32 _name = PlayerBook.getPlayerName(_pID);\r\n            uint256 _laff = PlayerBook.getPlayerLAff(_pID);\r\n\r\n            // set up player account\r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n\r\n            if (_name != \"\")\r\n            {\r\n                pIDxName_[_name] = _pID;\r\n                plyr_[_pID].name = _name;\r\n                plyrNames_[_pID][_name] = true;\r\n            }\r\n\r\n            if (_laff != 0 && _laff != _pID)\r\n                plyr_[_pID].laff = _laff;\r\n\r\n            // set the new player bool to true\r\n            _eventData_.compressedData = _eventData_.compressedData + 1;\r\n        }\r\n        return (_eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev checks to make sure user picked a valid team.  if not sets team\r\n     * to default (sneks)\r\n     */\r\n    function verifyTeam(uint256 _team)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        if (_team < 0 || _team > 3)\r\n            return(2);\r\n        else\r\n            return(_team);\r\n    }\r\n\r\n    /**\r\n     * @dev decides if round end needs to be run & new round started.  and if\r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n    function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)\r\n    private\r\n    returns (F3Ddatasets.EventReturns)\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd, 0, 0);\r\n\r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n\r\n        // set the joined round bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev ends the round. manages paying out winner/splitting up pot\r\n     */\r\n    function endRound(F3Ddatasets.EventReturns memory _eventData_)\r\n    private\r\n    returns (F3Ddatasets.EventReturns)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab our winning player and team id's\r\n        uint256 _winPID = _winPID = round_[_rID].plyr;\r\n        uint256 _winTID = round_[_rID].team;\r\n\r\n        // grab our pot amount\r\n        uint256 _pot = round_[_rID].pot;\r\n\r\n        //去掉agk对应的eth\r\n        //给token钱包\r\n//         if(round_[rID_].agk > 0) tokenWallet.transfer(round_[rID_].agk);\r\n\r\n        // calculate our winner share, community rewards, gen share,\r\n        // p3d share, and amount reserved for next pot\r\n        uint256 _win = (_pot.mul(winnerFee_)) / 100;//45%最后一名\r\n        uint256 _com = (_pot.mul(comFee1_)) / 100; //5%给基金\r\n        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;//0\r\n        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;//0\r\n        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\r\n\r\n        // calculate ppt for round mask\r\n        // uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        // uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\r\n        // if (_dust > 0)\r\n        // {\r\n        //     _gen = _gen.sub(_dust);\r\n        //     _res = _res.add(_dust);\r\n        // }\r\n\r\n        // pay last winner, 45%\r\n        lastWallet.transfer(_win);\r\n        //2-20 winners, 20%\r\n        lastWallet1.transfer(_pot.mul(winnerFee1_) / 100);\r\n        _res = _res.sub(_pot.mul(winnerFee1_) / 100);\r\n        //21-300 winners, 15%\r\n       _res = _res.sub(calcLastWinners(_rID, _pot.mul(winnerFee2_) / 100, 20, 300));\r\n        /* _res = _res.sub(_pot.mul(winnerFee2_) / 100);\r\n        for(_winTID = 0; _winTID < superWallets2.length; _winTID++) {\r\n            superWallets2[_winTID].transfer((_pot.mul(winnerFee2_) / 100)/superWallets2.length);\r\n        } */\r\n\r\n        //把1%拿出来分给刘总和我的9个钱包\r\n        /* for(_winTID = 0; _winTID < superWallets3.length; _winTID++) {\r\n            superWallets3[_winTID].transfer((_pot.mul(1) / 100)/superWallets3.length);\r\n        }\r\n        //151-500 winners, 10%,superWallets3\r\n        _res = _res.sub(calcLastWinners(_rID, _pot.mul(winnerFee3_ - 2) / 100, 10, 360)); */\r\n\r\n        //give 1% to the specail player, just me\r\n        /* plyr_[1].win = (_pot.mul(2) / 100).add(plyr_[1].win); */\r\n        /* _res = _res.sub(_pot.mul(3) / 100); */\r\n\r\n        // distribute gen portion to key holders\r\n        // round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\r\n        // send share for p3d to divies.sol\r\n        if (_p3d > 0) {\r\n            if(address(Divies) != address(0)) {\r\n                Divies.deposit.value(_p3d)();\r\n            } else {\r\n                _com = _com.add(_p3d);\r\n                _p3d = 0;\r\n            }\r\n        }\r\n\r\n        //to team1\r\n        myWallet.transfer(_com);\r\n\r\n        // prepare event data\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = plyr_[_winPID].name;\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.P3DAmount = _p3d;\r\n        _eventData_.newPot = _res;\r\n\r\n        // _com = round_[_rID].rePot;\r\n\r\n        // start next round\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndInit_).add(rndGap_);\r\n        round_[_rID].pot = _res;\r\n        // round_[_rID].rePot = _com;\r\n        return(_eventData_);\r\n    }\r\n\r\n    //倒数_start-_end名的奖励\r\n    function calcLastWinners(uint256 _rID, uint256 _eth, uint256 _start, uint256 _end)\r\n    private\r\n    returns(uint256) {\r\n        uint256 _count = 0;\r\n        uint256 _total = 0;\r\n        uint256[] memory _pIDs = new uint256[](350);\r\n        //TODO, 这里的逻辑有问题，必须找完全部玩家才能确定\r\n        for(uint256 i = _start; i < rndInvestsCount_[_rID]; i++) {\r\n            if(rndInvestsCount_[_rID] < i + 1) break;\r\n            F3Ddatasets.Invest memory _invest = rndInvests_[_rID][rndInvestsCount_[_rID] - 1 - i];\r\n            //大于0.5eth才有获奖资格\r\n            if(_invest.eth >= minInvestWinner_) {\r\n                _pIDs[_count] = _invest.pid;\r\n                _count++;\r\n                if(_count >= _end - _start) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if(_count > 0) {\r\n             for(i = 0; i < _count; i++) {\r\n                 if(_pIDs[i] > 0) {\r\n                    plyr_[_pIDs[i]].win = (_eth / _count).add(plyr_[_pIDs[i]].win);\r\n                    _total = _total.add(_eth / _count);\r\n                 }\r\n             }\r\n        } else {\r\n            //没有则给基金会\r\n            myWallet.transfer(_eth);\r\n            _total = _eth;\r\n        }\r\n        return _total;\r\n    }\r\n\r\n    /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast, uint256 _subKeys, uint256 _subEth)\r\n    private\r\n    {\r\n        uint256[] memory _earnings = calcUnMaskedEarnings(_pID, _rIDlast, _subKeys, _subEth, 0);\r\n        //可提取eth\r\n        if (_earnings[0] > 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pID].gen = _earnings[0].add(plyr_[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n//            plyrRnds_[_pID][_rIDlast].mask = _earnings[0].add(plyrRnds_[_pID][_rIDlast].mask);\r\n        }\r\n        //出局的keys\r\n        if(_earnings[1] > 0) {\r\n            plyrRnds_[_pID][_rIDlast].keysOff = _earnings[1].add(plyrRnds_[_pID][_rIDlast].keysOff);\r\n            //keys都出局了，mask清零\r\n            plyrRnds_[_pID][_rIDlast].mask = 0;\r\n            //已计算的分红清零\r\n            plyrRnds_[_pID][_rIDlast].genOff = 0;\r\n        } else {\r\n            //只有在没出局的情况下，才将成本进行累加\r\n            //在没有复投的情况下，keysLeftRate_为0，不能用此参数计算，改为提币参数计算\r\n            /* uint256 _totalEth = _earnings[5].mul( maxEarningRate_)/keysLeftRate_; */\r\n            uint256 _totalEth = _earnings[4].mul( maxEarningRate_ /keysToToken_);\r\n            plyrRnds_[_pID][_rIDlast].mask = _totalEth.add(plyrRnds_[_pID][_rIDlast].mask);\r\n            //已计算的分红累计\r\n            plyrRnds_[_pID][_rIDlast].genOff = _totalEth.add(plyrRnds_[_pID][_rIDlast].genOff);\r\n        }\r\n        //锁定的keys对应的eth成本\r\n        if(_earnings[2] > 0) {\r\n            plyrRnds_[_pID][_rIDlast].ethOff = _earnings[2].add(plyrRnds_[_pID][_rIDlast].ethOff);\r\n        }\r\n        //多余收益进大奖池\r\n        if(_earnings[3] > 0) {\r\n            round_[rID_].pot = _earnings[3].add(round_[rID_].pot);\r\n        }\r\n        //送agk token\r\n        if(_earnings[4] > 0) {\r\n            plyr_[_pID].agk = plyr_[_pID].agk.add(_earnings[4] / tokenPrice_);\r\n            round_[rID_].agk = round_[rID_].agk.add(_earnings[4]);\r\n        }\r\n        //复投的eth和池子更新\r\n        if(_earnings[5] > 0) {\r\n            plyr_[_pID].reEth = plyr_[_pID].reEth.add(_earnings[5]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev updates round timer based on number of whole keys bought.\r\n     */\r\n    function updateTimer(uint256 _keys, uint256 _rID)\r\n    private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        //当前总key数，每10000个keys减少倒计时60秒，最低不少于2小时\r\n        // uint256 _totalKeys = _keys.add(round_[_rID].keys);\r\n        // uint256 _times10k = _totalKeys / keysToReduceMaxTime_.mul(1000000000000000000);\r\n        // realRndMax_ = rndMax_.sub(_times10k.mul(reduceMaxTimeStep_));\r\n        // if(realRndMax_ < minMaxTime_) realRndMax_ = minMaxTime_;\r\n\r\n        // calculate time based on number of keys bought\r\n        uint256 _newTime;\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n\r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n\r\n    /**\r\n     * @dev generates a random number between 0-99 and checks to see if thats\r\n     * resulted in an airdrop win\r\n     * @return do we have a winner?\r\n     */\r\n    function airdrop()\r\n    private\r\n    view\r\n    returns(bool)\r\n    {\r\n        uint256 rnd = randInt(0, 1000, 81);\r\n\r\n        return rnd < airDropTracker_;\r\n    }\r\n    /**\r\n       random int\r\n    */\r\n    function randInt(uint256 _start, uint256 _end, uint256 _nonce)\r\n    private\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _range = _end.sub(_start);\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n                (block.timestamp).add\r\n                (block.difficulty).add\r\n                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n                (block.gaslimit).add\r\n                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n                (block.number),\r\n                    _nonce\r\n            )));\r\n        return (_start + seed - ((seed / _range) * _range));\r\n    }\r\n    //小玩家收益，注册了vip，并且直推业绩达到10ETH\r\n    /* function checkSmallPlayers(uint256 _rID, uint256 _pID, uint256 _eth)\r\n    private\r\n    returns(uint256)\r\n    {\r\n        //give 1% to the specail player, just me\r\n        plyr_[1].smallEth = (_eth.mul(1)/100).add(plyr_[1].smallEth);\r\n        uint256 award = _eth.mul(smallPlayerFee_ - 1)/100;\r\n\r\n        uint256 n = 0;\r\n        for(uint256 i = 0; i < vipPlayersCount_; i++) {\r\n            //直推10eth的条件\r\n            if(plyrRnds_[vipIDs_[i]][_rID].affEth0 >= vipMinEth_) {\r\n                n++;\r\n            }\r\n        }\r\n\r\n        if(n > 0) {\r\n            for(i = 0; i < vipPlayersCount_; i++) {\r\n                if(plyrRnds_[vipIDs_[i]][_rID].affEth0 >= vipMinEth_) {\r\n                    plyr_[vipIDs_[i]].smallEth = (award/n).add(plyr_[vipIDs_[i]].smallEth);\r\n                }\r\n            }\r\n            return 0;\r\n        } else {\r\n            return award;\r\n        }\r\n    }\r\n    */\r\n    /**\r\n     * @dev distributes eth based on fees to com, aff, and p3d\r\n     */\r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\r\n    private\r\n    returns(F3Ddatasets.EventReturns)\r\n    {\r\n        //基金的钱包\r\n        uint256 _com = _eth.mul(comFee_) / 100;\r\n        uint256 _p3d;\r\n\r\n        //技术的钱包\r\n        uint256 _long = _eth.mul(devFee_) / 100;\r\n        devWallet.transfer(_long);\r\n        /* //小玩家收入分配\r\n        _long = checkSmallPlayers(_rID, _pID, _eth);\r\n        //未分配则给基金\r\n        if(_long > 0) {\r\n            _com = _com.add(_long); */\r\n        /* } */\r\n\r\n        //大玩家钱包\r\n        bigWallet.transfer(_eth.mul(bigPlayerFee_)/100);\r\n        _p3d = checkAffs(_eth, _affID, _pID, _rID);\r\n        //发送到额外钱包，就是推荐拿不到的部分\r\n        extraWallet.transfer(_p3d);\r\n        _p3d = 0;\r\n        // pay out p3d\r\n        _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\r\n        if (_p3d > 0)\r\n        {\r\n            if(address(Divies) != address(0)) {\r\n                // deposit to divies.sol contract\r\n                Divies.deposit.value(_p3d)();\r\n            } else {\r\n                _com = _com.add(_p3d);\r\n                _p3d = 0;\r\n            }\r\n            // set up event data\r\n            _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);\r\n        }\r\n\r\n        //to team\r\n        myWallet.transfer(_com);\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n    /**\r\n       Check all the linked Affs\r\n       //todo 有效玩家方式，推荐取不走转到基金\r\n    */\r\n    function checkAffs(uint256 _eth, uint256 _affID, uint256 _pID, uint256 _rID)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        // distribute share to affiliate\r\n        uint256 _aff = _eth.mul(affFee_) / 100;\r\n        uint256 _affTotal = 0;\r\n//        if(_eth >= vipMinEth_) {\r\n//          plyrRnds_[_affID][_rID].inviteCounter ++;\r\n//        }\r\n        for(uint8 i = 0; i < affsRate_.length; i++) {\r\n            if (_affID != _pID && (!affNeedName_ || plyr_[_affID].name != '')) {\r\n                //记录推广的总业绩\r\n                plyrRnds_[_affID][_rID].affEth = plyrRnds_[_affID][_rID].affEth.add(_eth);\r\n                //记录直推的总业绩\r\n                if(i == 0) {\r\n                    plyrRnds_[_affID][_rID].affEth0 = plyrRnds_[_affID][_rID].affEth0.add(_eth);\r\n                }\r\n                uint limit = (10 ether) * i;\r\n                uint256 _affi = _aff.mul(affsRate_[i]) / 1000;\r\n                if(_affi > 0 && limit <= plyrRnds_[_affID][_rID].affEth0) {\r\n                    //record the aff\r\n                    plyrAffs_[_affID][plyr_[_affID].affCount].level = i;\r\n                    plyrAffs_[_affID][plyr_[_affID].affCount].pid = _pID;\r\n                    plyrAffs_[_affID][plyr_[_affID].affCount].eth = _affi;\r\n                    plyr_[_affID].affCount++;\r\n                    //Multi aff awards\r\n                    plyr_[_affID].aff = _affi.add(plyr_[_affID].aff);\r\n                    //emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\r\n                    _affTotal = _affTotal.add(_affi);\r\n                }\r\n\r\n                //Next aff\r\n                _pID = _affID;\r\n                _affID = plyr_[_pID].laff;\r\n\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        _aff = _aff.sub(_affTotal);\r\n        return _aff;\r\n    }\r\n\r\n    function potSwap()\r\n    external\r\n    payable\r\n    {\r\n        // setup local rID\r\n        //uint256 _rID = rID_ + 1;\r\n\r\n        //round_[_rID].pot = round_[_rID].pot.add(msg.value);\r\n        // emit F3Devents.onPotSwapDeposit(_rID, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev distributes eth based on fees to gen and pot\r\n     */\r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\r\n    private\r\n    returns(F3Ddatasets.EventReturns)\r\n    {\r\n        // calculate gen share\r\n        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\r\n\r\n        // toss 1% into airdrop pot\r\n        uint256 _air = (_eth.mul(airdropFee_) / 100);\r\n        airDropPot_ = airDropPot_.add(_air);\r\n\r\n        // update eth balance (eth = eth - (com share + pot swap share + aff share + p3d share + airdrop pot share))\r\n        uint256 _pot = _eth.sub(((_eth.mul(feesTotal_)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\r\n\r\n        // calculate pot\r\n        _pot = _pot.sub(_gen);\r\n\r\n        // distribute gen share (thats what updateMasks() does) and adjust\r\n        // balances for dust.\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys, _eth);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n\r\n        // add eth to pot\r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n\r\n        // set up event data\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n\r\n        return(_eventData_);\r\n    }\r\n    /**\r\n     * @dev updates masks for round and player when keys are bought\r\n     * @return dust left over\r\n     */\r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys, uint256 _eth)\r\n    private\r\n    returns(uint256)\r\n    {\r\n        uint256 _oldKeyValue = round_[_rID].mask;\r\n        // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        round_[_rID].mask = _ppt.add(_oldKeyValue);\r\n\r\n        //更新收益，计算可能的收益溢出\r\n        updateGenVault(_pID, plyr_[_pID].lrnd, _keys, _eth);\r\n\r\n        // calculate player earning from their own buy (only based on the keys\r\n        // they just bought).  & update player earnings mask\r\n//        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n//        _pearn = ((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn);\r\n//        plyrRnds_[_pID][_rID].mask = (_pearn).add(plyrRnds_[_pID][_rID].mask);\r\n\r\n        plyrRnds_[_pID][_rID].mask = (_oldKeyValue.mul(_keys) / (1000000000000000000)).add(plyrRnds_[_pID][_rID].mask);\r\n\r\n        // calculate & return dust\r\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\r\n    }\r\n\r\n    /**\r\n     * @dev adds up unmasked earnings, & vault earnings, sets them all to 0\r\n     * @return earnings in wei format\r\n     */\r\n    function withdrawEarnings(uint256 _pID, bool _reBuy)\r\n    private\r\n    returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateGenVault(_pID, plyr_[_pID].lrnd, 0, 0);\r\n\r\n        // from vaults\r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff).add(plyr_[_pID].smallEth);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n            plyr_[_pID].smallEth = 0;\r\n        }\r\n\r\n        //复投\r\n        if(_reBuy && plyr_[_pID].reEth > 0) {\r\n            // set up our tx event data\r\n            F3Ddatasets.EventReturns memory _eventData_;\r\n            //购买\r\n            if(core(rID_, _pID, plyr_[_pID].reEth, plyr_[_pID].laff, 0, _eventData_, false)) {\r\n                //清空\r\n                plyr_[_pID].reEth = 0;\r\n            }\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n\r\n    /**\r\n     * @dev prepares compression data and fires event for buy or reload tx's\r\n     */\r\n    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\r\n    private view\r\n    {\r\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\r\n\r\n        // emit F3Devents.onEndTx\r\n        // (\r\n        //     _eventData_.compressedData,\r\n        //     _eventData_.compressedIDs,\r\n        //     plyr_[_pID].name,\r\n        //     msg.sender,\r\n        //     _eth,\r\n        //     _keys,\r\n        //     _eventData_.winnerAddr,\r\n        //     _eventData_.winnerName,\r\n        //     _eventData_.amountWon,\r\n        //     _eventData_.newPot,\r\n        //     _eventData_.P3DAmount,\r\n        //     _eventData_.genAmount,\r\n        //     _eventData_.potAmount,\r\n        //     airDropPot_\r\n        // );\r\n    }\r\n    //==============================================================================\r\n    //    (~ _  _    _._|_    .\r\n    //    _)(/_(_|_|| | | \\/  .\r\n    //====================/=========================================================\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs\r\n     * have time to set things up on the web end                            **/\r\n    bool public activated_ = false;\r\n    function activate()\r\n    onlyOwner\r\n    public\r\n    {\r\n        // make sure that its been linked.\r\n        //        require(address(otherF3D_) != address(0), \"must link to other FoMo3D first\");\r\n\r\n        // can only be ran once\r\n        require(activated_ == false, \"fomo3d already activated\");\r\n\r\n        // activate the contract\r\n        activated_ = true;\r\n\r\n        // lets start first round\r\n        rID_ = 1;\r\n        round_[1].strt = now + rndExtra_ - rndGap_;\r\n        round_[1].end = now + rndInit_ + rndExtra_;\r\n    }\r\n    bool public buyable_ = true;\r\n    function enableBuy(bool _b)\r\n    onlyOwner\r\n    public\r\n    {\r\n        if(buyable_ != _b) {\r\n            buyable_ = _b;\r\n        }\r\n    }\r\n\r\n    function setOtherFomo(address _otherF3D)\r\n    onlyOwner\r\n    public\r\n    {\r\n        // make sure that it HASNT yet been linked.\r\n        require(address(otherF3D_) == address(0), \"silly dev, you already did that\");\r\n\r\n        // set up other fomo3d (fast or long) for pot swap\r\n        otherF3D_ = otherFoMo3D(_otherF3D);\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary F3Ddatasets {\r\n    //compressedData key\r\n    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]\r\n    // 0 - new player (bool)\r\n    // 1 - joined round (bool)\r\n    // 2 - new  leader (bool)\r\n    // 3-5 - air drop tracker (uint 0-999)\r\n    // 6-16 - round end time\r\n    // 17 - winnerTeam\r\n    // 18 - 28 timestamp\r\n    // 29 - team\r\n    // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)\r\n    // 31 - airdrop happened bool\r\n    // 32 - airdrop tier\r\n    // 33 - airdrop amount won\r\n    //compressedIDs key\r\n    // [77-52][51-26][25-0]\r\n    // 0-25 - pID\r\n    // 26-51 - winPID\r\n    // 52-77 - rID\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 P3DAmount;          // amount distributed to p3d\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 smallEth;//小玩家收益\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n        uint256 agk;   // AGK token awarded\r\n        uint256 usedAgk;        //agk transfered\r\n        uint256 affCount;// the count of aff award\r\n        uint256 reEth; //需要复投的eth\r\n        bool vip; //是否vip小玩家\r\n\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 keysOff;// keys kicked off\r\n        uint256 ethOff; //  eth kicked off\r\n        uint256 mask;   // player mask\r\n        uint256 ico;    // ICO phase investment\r\n        uint256 genOff; //当前已经累计的收益\r\n        uint256 affEth;  //获得的所有推荐的投资额度\r\n        uint256 affEth0; //获得直推的总额\r\n//        uint256 inviteCounter;      //有效的下线数量，用来计算推荐收益用，一次性投资10个ETH才算有效用户\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n        // uint256 rePot;  // 复投池\r\n        uint256 agk;    //总共增加了多少agk，要换成eth给钱包\r\n    }\r\n    struct TeamFee {\r\n        uint256 gen;    // % of buy in thats paid to key holders of current round\r\n        uint256 p3d;    // % of buy in thats paid to p3d holders\r\n    }\r\n    struct PotSplit {\r\n        uint256 gen;    // % of pot thats paid to key holders of current round\r\n        uint256 p3d;    // % of pot thats paid to p3d holders\r\n    }\r\n    struct Aff {\r\n        uint256 level;//the aff level: 0, 1 or 2\r\n        uint256 pid;  //the player id trigger the aff award\r\n        uint256 eth;  //the award of eth\r\n    }\r\n    struct Invest {\r\n        uint256 pid;   //player id\r\n        uint256 eth;   //eth invested\r\n        uint256 kid;   //key id start\r\n        uint256 keys;  //keys got\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  |  _      _ _ | _  .\r\n//  |<(/_\\/  (_(_||(_  .\r\n//=======/======================================================================\r\nlibrary F3DKeysCalcLong {\r\n    using SafeMath for *;\r\n    uint256 constant private keyPriceStart_ = 150 szabo;//key的起始价,如果需要改动，两个地方都要改，math那里\r\n    uint256 constant private keyPriceStep_   = 1 wei;       //key价格上涨阶梯\r\n    /**\r\n     * @dev calculates number of keys received given X eth\r\n     * @param _curEth current amount of eth in contract\r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n\r\n    /**\r\n       当前keys数量为_curKeys，购买_sellKeys所需的eth\r\n     * @dev calculates amount of eth received if you sold X keys\r\n     * @param _curKeys current amount of keys that exist\r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n        解二次方程: eth总值 = n * 起始价 +  n*n*递增价/2\r\n        _eth对应的key数量 = (开根号(起始价*起始价 + 2*递增价*_eth) - 起始价) / 递增价\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth)\r\n    internal\r\n    pure\r\n    returns(uint256)\r\n    {\r\n        return ((((keyPriceStart_).sq()).add((keyPriceStep_).mul(2).mul(_eth))).sqrt().sub(keyPriceStart_)).mul(1000000000000000000) / (keyPriceStep_);\r\n    }\r\n\r\n    /**\r\n       _keys数量的key对应的 eth总值 = n * 起始价 +  n*n*递增价/2 + n*递增价/2\r\n       按照原版 eth总值 = n * 起始价 +  n*n*递增价/2 少了一部分\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\"\r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys)\r\n    public\r\n    pure\r\n    returns(uint256)\r\n    {\r\n        uint256 n = _keys / (1000000000000000000);\r\n        //correct\r\n        // return n.mul(keyPriceStart_).add((n.sq().mul(keyPriceStep_)) / (2)).add(n.mul(keyPriceStep_) / (2));\r\n        //original\r\n        return n.mul(keyPriceStart_).add((n.sq().mul(keyPriceStep_)) / (2));\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  . _ _|_ _  _ |` _  _ _  _  .\r\n//  || | | (/_| ~|~(_|(_(/__\\  .\r\n//==============================================================================\r\ninterface otherFoMo3D {\r\n    function potSwap() external payable;\r\n}\r\n\r\ninterface DiviesInterface {\r\n    function deposit() external payable;\r\n}\r\n\r\ninterface JIincForwarderInterface {\r\n    function deposit() external payable returns(bool);\r\n    function status() external view returns(address, address, bool);\r\n    function startMigration(address _newCorpBank) external returns(bool);\r\n    function cancelMigration() external returns(bool);\r\n    function finishMigration() external returns(bool);\r\n    function setup(address _firstCorpBank) external;\r\n}\r\n\r\ninterface PlayerBookInterface {\r\n    function pIDxAddr_(address _addr) external view returns (uint256);\r\n    function getPlayerCount() external view returns (uint256);\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}\r\n\r\n/**\r\n* @title -Name Filter- v0.1.9\r\n*/\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.\r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x\r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n    internal\r\n    pure\r\n    returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n\r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n\r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                // OR lowercase a-z\r\n                (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                // or 0-9\r\n                (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr\r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n    internal\r\n    pure\r\n    returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vipMinEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndInvestsCount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrAffs_\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"icoGen\",\"type\":\"uint256\"},{\"name\":\"icoAvg\",\"type\":\"uint256\"},{\"name\":\"agk\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"p3d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndInvests_\",\"outputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"kid\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"affsRate_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_b\",\"type\":\"bool\"}],\"name\":\"enableBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRoundEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRoundActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vipIDs_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"receivePlayerNameList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerVIP\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"keysOff\",\"type\":\"uint256\"},{\"name\":\"ethOff\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"genOff\",\"type\":\"uint256\"},{\"name\":\"affEth\",\"type\":\"uint256\"},{\"name\":\"affEth0\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registerVIPFee_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_otherF3D\",\"type\":\"address\"}],\"name\":\"setOtherFomo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"adminRegisterVIP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_maxID\",\"type\":\"uint256\"}],\"name\":\"getAllPlayersInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potSplit_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"p3d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"smallEth\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"agk\",\"type\":\"uint256\"},{\"name\":\"usedAgk\",\"type\":\"uint256\"},{\"name\":\"affCount\",\"type\":\"uint256\"},{\"name\":\"reEth\",\"type\":\"uint256\"},{\"name\":\"vip\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"potSwap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyable_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPlayerBook\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vipPlayersCount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"F3DPRO","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"F3DKeysCalcLong:E5D27310E787fb063AB99e878587309D5852c9f3","SwarmSource":"bzzr://eac333bf867711a592c3c546acb34252bcfabfd61fb88d47e0c2c78be36c632f"}]}