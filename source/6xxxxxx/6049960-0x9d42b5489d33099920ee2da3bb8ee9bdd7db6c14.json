{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract F3Devents {\r\n  event Winner(address winner, uint256 pool, address revealer);\r\n  event Buy(address buyer, uint256 keys, uint256 cost);\r\n  event Sell(address from, uint256 price, uint256 count);\r\n  event Bought(address buyer, address from, uint256 amount, uint256 price);\r\n}\r\n\r\ncontract F3d is F3Devents {\r\n  using SafeMath for *;\r\n\r\n  \r\n  uint256 public a;    // key price parameter                    15825000\r\n  uint256 public b;    // key price parameter                    749999139625000\r\n\r\n  uint256 public ta;   // percentage goes to pool                37.5\r\n  uint256 public tb;   // percentage goes to split               38.5\r\n  uint256 public tc;   // percentage goes to ref1                15\r\n  uint256 public td;   // percentage goes to ref2                5\r\n  uint256 public te;   // percentage goes to owner               4\r\n\r\n  uint256 public wa;   // percentage of pool goes to winner      50\r\n  uint256 public wb;   // percentage of pool goes to next pool   16.6\r\n  uint256 public wc;   // percentage of pool goes to finalizer   0.5\r\n  uint256 public wd;   // percentage of pool goes to owner       2.6\r\n  uint256 public we;   // percentage of pool goes to split       30.3\r\n\r\n  uint256 public maxTimeRemain;                     //           4 * 60 * 60\r\n  uint256 public timeGap;                           //           5 * 60\r\n  \r\n  uint256 public soldKeys;                          //           0\r\n\r\n  uint256 public decimals = 1000000;\r\n  \r\n  bool public pause;\r\n  address public owner;\r\n  address public admin;\r\n\r\n  PlayerStatus[] public players;\r\n  mapping(address => uint256) public playerIds;\r\n  mapping(uint256 => Round) public rounds;\r\n  mapping(uint256 => mapping (uint256 => PlayerRound)) public playerRoundData;\r\n  uint256 public currentRound;\r\n  \r\n  struct PlayerStatus {\r\n    address addr;          //player addr\r\n    uint256 wallet;        //get from spread\r\n    uint256 affiliate;     //get from reference\r\n    uint256 win;           //get from winning\r\n    uint256 lrnd;          //last round played\r\n    uint256 referer;       //who introduced this player\r\n  }\r\n  \r\n  struct PlayerRound {\r\n      uint256 eth;         //eth player added to this round\r\n      uint256 keys;        //keys player bought in this round\r\n      uint256 mask;        //player mask in this round\r\n  }\r\n  \r\n  struct Round {\r\n      uint256 eth;         //eth to this round\r\n      uint256 keys;        //keys sold in this round\r\n      uint256 mask;        //mask of this round\r\n      address winner;      //winner of this round\r\n      uint256 pool;        //the amount of pool when ends\r\n      uint256 endTime;     //the end time\r\n  }\r\n  \r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused() {\r\n    require(!pause);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n      require(msg.sender == admin);\r\n      _;\r\n  }\r\n  \r\n  function setPause(bool _pause) onlyAdmin public {\r\n    pause = _pause;\r\n  }\r\n\r\n  constructor(uint256 _a, uint256 _b, \r\n  uint256 _ta, uint256 _tb, uint256 _tc, uint256 _td, uint256 _te,\r\n  uint256 _wa, uint256 _wb, uint256 _wc, uint256 _wd, uint256 _we,\r\n  uint256 _maxTimeRemain, uint256 _gap, address _owner) public {\r\n    a = _a;\r\n    b = _b;\r\n\r\n    ta = _ta;\r\n    tb = _tb;\r\n    tc = _tc;\r\n    td = _td;\r\n    te = _te;\r\n    \r\n    wa = _wa;\r\n    wb = _wb;\r\n    wc = _wc;\r\n    wd = _wd;\r\n    we = _we;\r\n    \r\n    // split less than 100%\r\n    require(ta.add(tb).add(tc).add(td).add(te) == 1000);\r\n    require(wa.add(wb).add(wc).add(wd).add(we) == 1000);\r\n\r\n    owner = _owner;\r\n\r\n    // start from first round\r\n    currentRound = 1;\r\n    rounds[currentRound] = Round(0, 0, 0, owner, 0, block.timestamp.add(_maxTimeRemain));\r\n    maxTimeRemain = _maxTimeRemain;\r\n    timeGap = _gap;\r\n    \r\n    admin = msg.sender;\r\n    // the first player is the owner\r\n    players.push(PlayerStatus(\r\n        owner,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0));\r\n  }\r\n\r\n  // return the price for nth key  n = keys / decimals\r\n  function Price(uint256 n) public view returns (uint256) {\r\n    return n.mul(a).add(b);\r\n  }\r\n\r\n  function updatePlayer(uint256 _pID) private {\r\n      if(players[_pID].lrnd != 0) {\r\n          updateWallet(_pID, players[_pID].lrnd);\r\n      }\r\n      players[_pID].lrnd = currentRound;\r\n  }\r\n  \r\n  function updateWallet(uint256 _pID, uint256 _round) private {\r\n      uint256 earnings = calculateMasked(_pID, _round);\r\n      if (earnings > 0) {\r\n          players[_pID].wallet = earnings.add(players[_pID].wallet);\r\n          playerRoundData[_pID][_round].mask = earnings.add(playerRoundData[_pID][_round].mask);\r\n      }\r\n  }\r\n  \r\n  function profit() public view returns (uint256) {\r\n      uint256 id = playerIds[msg.sender];\r\n      if (id == 0 && msg.sender != owner) {\r\n          return 0;\r\n      }\r\n      PlayerStatus memory player = players[id];\r\n      \r\n      return player.wallet.add(player.affiliate).add(player.win).add(calculateMasked(id, player.lrnd));\r\n  }\r\n  \r\n  function calculateMasked(uint256 _pID, uint256 _round) private view returns (uint256) {\r\n      PlayerRound memory roundData = playerRoundData[_pID][_round];\r\n      return rounds[_round].mask.mul(roundData.keys).sub(roundData.mask);\r\n  }\r\n  \r\n  function registerUserIfNeeded(uint256 ref) public {\r\n      if (msg.sender != owner) {\r\n          if (playerIds[msg.sender] == 0) {\r\n              playerIds[msg.sender] = players.length;\r\n              if (ref >= players.length) {\r\n                  ref = 0;\r\n              }\r\n              \r\n              players.push(PlayerStatus(\r\n                  msg.sender,\r\n                  0,\r\n                  0,\r\n                  0,\r\n                  0,\r\n                  ref));\r\n          }\r\n      }\r\n  }\r\n  \r\n  // anyone can finalize a round\r\n  function finalize(uint256 ref) public {\r\n      Round storage lastOne = rounds[currentRound];\r\n      // round must be finished\r\n      require(block.timestamp > lastOne.endTime);\r\n      \r\n      // register the user if necessary\r\n      registerUserIfNeeded(ref);\r\n\r\n      // new round has started\r\n      currentRound = currentRound.add(1);\r\n      Round storage _round = rounds[currentRound];\r\n      _round.endTime = block.timestamp.add(maxTimeRemain);\r\n      _round.winner = owner;            \r\n      // save the round data\r\n      uint256 money = lastOne.pool;\r\n      \r\n      if (money == 0) {\r\n          // nothing happend in last round\r\n          return;\r\n      }\r\n      // to pool\r\n      _round.pool = money.mul(wb) / 1000;\r\n\r\n      // to winner\r\n      uint256 toWinner = money.mul(wa) / 1000;\r\n      players[playerIds[lastOne.winner]].win = toWinner.add(players[playerIds[lastOne.winner]].win);\r\n      \r\n      // to revealer\r\n      uint256 toRevealer = money.mul(wc) / 1000;\r\n      uint256 revealId = playerIds[msg.sender];\r\n      \r\n      // self reveal, no awards\r\n      if (msg.sender == lastOne.winner) {\r\n          revealId = 0;\r\n      }\r\n      \r\n      players[revealId].win = players[revealId].win.add(toRevealer);\r\n      \r\n      uint256 toOwner = money.mul(wd) / 1000;\r\n      players[0].win = players[0].win.add(toOwner);\r\n      \r\n      uint256 split = money.sub(_round.pool).sub(toWinner).sub(toRevealer).sub(toOwner);\r\n      \r\n      if (lastOne.keys != 0) {\r\n          lastOne.mask = lastOne.mask.add(split / lastOne.keys);\r\n          // gather the dust\r\n          players[0].wallet = players[0].wallet.add(split.sub((split/lastOne.keys) * lastOne.keys));\r\n      } else {\r\n          // last round no one bought any keys, sad\r\n          // put the split into next round\r\n          _round.pool = split.add(_round.pool);\r\n      }\r\n  }\r\n  \r\n  function price(uint256 key) public view returns (uint256) {\r\n      return a.mul(key).add(b);\r\n  }\r\n  \r\n  function ethForKey(uint256 _keys) public view returns (uint256) {\r\n      Round memory current = rounds[currentRound];\r\n      uint256 c_key = (current.keys / decimals);\r\n      \r\n      // in (a, a + 1], we use price(a + 1)\r\n      if (c_key.mul(decimals) != current.keys) {\r\n          c_key = c_key.add(1);\r\n      }\r\n      \r\n      uint256 _price = price(c_key);\r\n      uint256 remainKeys = c_key.mul(decimals).sub(current.keys);\r\n\r\n      if (remainKeys >= _keys) {\r\n          return _price.mul(_keys) / decimals;\r\n      } \r\n      \r\n      uint256 costEth = _price.mul(_keys) / decimals;\r\n      _keys = _keys.sub(remainKeys);\r\n      \r\n      while(_keys >= decimals) {\r\n          c_key = c_key.add(1);\r\n          _price = price(c_key);\r\n          costEth = costEth.add(_price);\r\n          _keys = _keys.sub(decimals);\r\n      }\r\n    \r\n      c_key = c_key.add(1);\r\n      _price = price(c_key);\r\n\r\n      costEth = costEth.add(_price.mul(_keys) / decimals);\r\n      return costEth;\r\n  }\r\n\r\n  // the keys that one could buy at a stage using _eth\r\n  function keys(uint256 _eth) public view returns (uint256) {\r\n      Round memory current = rounds[currentRound];\r\n      \r\n      uint256 c_key = (current.keys / decimals).add(1);\r\n      uint256 _price = price(c_key);\r\n      uint256 remainKeys = c_key.mul(decimals).sub(current.keys);\r\n      uint256 remain =remainKeys.mul(_price) / decimals;\r\n      \r\n      if (remain >= _eth) {\r\n          return _eth.mul(decimals) / _price;\r\n      }\r\n      uint256 boughtKeys = remainKeys;\r\n      _eth = _eth.sub(remain);\r\n      while(true) {\r\n          c_key = c_key.add(1);\r\n          _price = price(c_key);\r\n          if (_price <= _eth) {\r\n              // buy a whole unit\r\n              boughtKeys = boughtKeys.add(decimals);\r\n              _eth = _eth.sub(_price);\r\n          } else {\r\n              boughtKeys = boughtKeys.add(_eth.mul(decimals) / _price);\r\n              break;\r\n          }\r\n      }\r\n      return boughtKeys;\r\n  }\r\n  \r\n  // _pID spent _eth to buy keys in _round\r\n  function core(uint256 _round, uint256 _pID, uint256 _eth) internal {\r\n      Round memory current = rounds[currentRound];\r\n\r\n      // new to this round\r\n      if (playerRoundData[_pID][_round].keys == 0) {\r\n          updatePlayer(_pID);\r\n      }\r\n      \r\n      if (block.timestamp > current.endTime) {\r\n          //we need to do finalzing\r\n          finalize(players[_pID].referer);\r\n          \r\n          //new round generated, we need to update the user status to the new round \r\n          updatePlayer(_pID);\r\n      }\r\n      \r\n      // retrive the current round obj again, in case it changed\r\n      Round storage current_now = rounds[currentRound];\r\n      \r\n      // calculate the keys that he could buy\r\n      uint256 _keys = keys(_eth);\r\n      \r\n      if (_keys <= 0) {\r\n          // put the eth to the sender\r\n          // sorry, you're bumped\r\n          players[_pID].wallet = _eth.add(players[_pID].wallet);\r\n          return;\r\n      }\r\n\r\n      if (_keys >= decimals) {\r\n          // buy at least one key to be the winner \r\n          current_now.winner = players[_pID].addr;\r\n          current_now.endTime = current_now.endTime.add(timeGap);\r\n          if (current_now.endTime.sub(block.timestamp) > maxTimeRemain) {\r\n              current_now.endTime = block.timestamp.add(maxTimeRemain);\r\n          }\r\n      }\r\n      \r\n      //now we do the money distribute\r\n      uint256 toOwner = _eth.sub(_eth.mul(ta) / 1000);\r\n      toOwner = toOwner.sub(_eth.mul(tb) / 1000);\r\n      toOwner = toOwner.sub(_eth.mul(tc) / 1000);\r\n      toOwner = toOwner.sub(_eth.mul(td) / 1000);\r\n      \r\n      // to pool\r\n      current_now.pool = (_eth.mul(ta) / 1000).add(current_now.pool);\r\n      \r\n      if (current_now.keys == 0) {\r\n          // current no keys to split, send to owner\r\n          toOwner = toOwner.add((_eth.mul(tb) / 1000));\r\n          players[0].wallet = toOwner.add(players[0].wallet);\r\n      } else {\r\n          current_now.mask = current_now.mask.add((_eth.mul(tb) / 1000) / current_now.keys);\r\n          // dust to owner;\r\n          // since the _eth will > 0, so the division is ok\r\n          uint256 dust = (_eth.mul(tb) / 1000).sub( _eth.mul(tb) / 1000 / current_now.keys * current_now.keys );\r\n          players[0].wallet = toOwner.add(dust).add(players[0].wallet);\r\n      }\r\n      // the split doesnt include keys that the user just bought\r\n      playerRoundData[_pID][currentRound].keys = _keys.add(playerRoundData[_pID][currentRound].keys);\r\n      current_now.keys = _keys.add(current_now.keys);\r\n      current_now.eth = _eth.add(current_now.eth);\r\n\r\n      // for the new keys, remove the user's free earnings\r\n      playerRoundData[_pID][currentRound].mask = current_now.mask.mul(_keys).add(playerRoundData[_pID][currentRound].mask);\r\n      \r\n      // to ref 1, 2\r\n      uint256 referer1 = players[_pID].referer;\r\n      uint256 referer2 = players[referer1].referer;\r\n      players[referer1].affiliate = (_eth.mul(tc) / 1000).add(players[referer1].affiliate);\r\n      players[referer2].affiliate = (_eth.mul(td) / 1000).add(players[referer2].affiliate);\r\n  }\r\n  \r\n  // calculate the keys that the user can buy with specified amount of eth\r\n  // return the eth left\r\n  function BuyKeys(uint256 ref) payable whenNotPaused public {\r\n      registerUserIfNeeded(ref);\r\n      core(currentRound, playerIds[msg.sender], msg.value);\r\n  }\r\n\r\n  function ReloadKeys(uint256 value, uint256 ref) whenNotPaused public {\r\n      registerUserIfNeeded(ref);\r\n      players[playerIds[msg.sender]].wallet = retrieveEarnings().sub(value);\r\n      core(currentRound, playerIds[msg.sender], value);\r\n  }\r\n  \r\n  function retrieveEarnings() internal returns (uint256) {\r\n      uint256 id = playerIds[msg.sender];\r\n      updatePlayer(id);\r\n      PlayerStatus storage player = players[id];\r\n      \r\n      uint256 earnings = player.wallet.add(player.affiliate).add(player.win);\r\n      \r\n      if (earnings == 0) {\r\n          return;\r\n      }\r\n      \r\n      player.wallet = 0;\r\n      player.affiliate = 0;\r\n      player.win = 0;\r\n      return earnings;\r\n  }\r\n  \r\n  // withdrawal all the earning of the game\r\n  function withdrawal(uint256 ref) whenNotPaused public {\r\n      registerUserIfNeeded(ref);\r\n      \r\n      uint256 earnings = retrieveEarnings();\r\n      if (earnings == 0) {\r\n          return;\r\n      }\r\n      msg.sender.transfer(earnings);\r\n  }\r\n\r\n  function playerCount() public view returns (uint256) {\r\n      return players.length;\r\n  }\r\n  \r\n  function register(uint256 ref) public whenNotPaused {\r\n    registerUserIfNeeded(ref);\r\n  }\r\n  \r\n  function remainTime() public view returns (uint256) {\r\n      if (rounds[currentRound].endTime <= block.timestamp) {\r\n          return 0;\r\n      } else {\r\n          return rounds[currentRound].endTime - block.timestamp;\r\n      }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"keys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"a\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerRoundData\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"te\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"ReloadKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"registerUserIfNeeded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ta\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"b\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"Price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"we\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wa\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"pool\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"BuyKeys\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"td\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTimeRemain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeGap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"ethForKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"uint256\"},{\"name\":\"affiliate\",\"type\":\"uint256\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"referer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_a\",\"type\":\"uint256\"},{\"name\":\"_b\",\"type\":\"uint256\"},{\"name\":\"_ta\",\"type\":\"uint256\"},{\"name\":\"_tb\",\"type\":\"uint256\"},{\"name\":\"_tc\",\"type\":\"uint256\"},{\"name\":\"_td\",\"type\":\"uint256\"},{\"name\":\"_te\",\"type\":\"uint256\"},{\"name\":\"_wa\",\"type\":\"uint256\"},{\"name\":\"_wb\",\"type\":\"uint256\"},{\"name\":\"_wc\",\"type\":\"uint256\"},{\"name\":\"_wd\",\"type\":\"uint256\"},{\"name\":\"_we\",\"type\":\"uint256\"},{\"name\":\"_maxTimeRemain\",\"type\":\"uint256\"},{\"name\":\"_gap\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"revealer\",\"type\":\"address\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"keys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"}]","ContractName":"F3d","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000f178680000000000000000000000000000000000000000000000000002aa1ec84c98280000000000000000000000000000000000000000000000000000000000000177000000000000000000000000000000000000000000000000000000000000018100000000000000000000000000000000000000000000000000000000000000960000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000a60000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000012f0000000000000000000000000000000000000000000000000000000000000708000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000d3c34ad4663bc8d4690f339352ee49c025cdb96d","Library":"","SwarmSource":"bzzr://7c246376d6714cb5c673f6c49193f5cfa18bcec5ac2d1554951c872d25954ec3"}]}