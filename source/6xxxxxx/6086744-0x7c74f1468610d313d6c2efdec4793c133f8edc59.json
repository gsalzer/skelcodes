{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ninterface ERC777TokensOperator {\r\n  function madeOperatorForTokens(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    bytes userData,\r\n    bytes operatorData\r\n  ) public;\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface ERC20Token {\r\n    function name() public constant returns (string); //solium-disable-line no-constant\r\n    function symbol() public constant returns (string); //solium-disable-line no-constant\r\n    function decimals() public constant returns (uint8); //solium-disable-line no-constant\r\n    function totalSupply() public constant returns (uint256); //solium-disable-line no-constant\r\n    function balanceOf(address owner) public constant returns (uint256); //solium-disable-line no-constant\r\n    function transfer(address to, uint256 amount) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\r\n    function approve(address spender, uint256 amount) public returns (bool);\r\n    function allowance(address owner, address spender) public constant returns (uint256); //solium-disable-line no-constant\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\ncontract ERC820Registry {\r\n  function getManager(address addr) public view returns(address);\r\n  function setManager(address addr, address newManager) public;\r\n  function getInterfaceImplementer(address addr, bytes32 iHash) public view returns (address);\r\n  function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\r\n}\r\n\r\ncontract UnstructuredOwnable {\r\n  /**\r\n   * @dev Event to show ownership has been transferred\r\n   * @param previousOwner representing the address of the previous owner\r\n   * @param newOwner representing the address of the new owner\r\n   */\r\n  event OwnershipTransferred(address previousOwner, address newOwner);\r\n  event OwnerSet(address newOwner);\r\n\r\n  // Owner of the contract\r\n  address private _owner;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev The constructor sets the original owner of the contract to the sender account.\r\n   */\r\n  constructor () public {\r\n    setOwner(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells the address of the owner\r\n   * @return the address of the owner\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets a new owner address\r\n   */\r\n  function setOwner(address newOwner) internal {\r\n    _owner = newOwner;\r\n    emit OwnerSet(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner(), newOwner);\r\n    setOwner(newOwner);\r\n  }\r\n}\r\n\r\ncontract Pausable is UnstructuredOwnable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ninterface Lockable {\r\n    function lockAndDistributeTokens(\r\n      address _tokenHolder, \r\n      uint256 _amount, \r\n      uint256 _percentageToLock, \r\n      uint256 _unlockTime\r\n    ) public;\r\n    function getAmountOfUnlockedTokens(address tokenOwner) public returns(uint);\r\n\r\n    event LockedTokens(address indexed tokenHolder, uint256 amountToLock, uint256 unlockTime);\r\n}\r\n\r\ninterface ERC777Token {\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function totalSupply() public view returns (uint256);\r\n    function granularity() public view returns (uint256);\r\n    function balanceOf(address owner) public view returns (uint256);\r\n\r\n    function send(address to, uint256 amount) public;\r\n    function send(address to, uint256 amount, bytes userData) public;\r\n\r\n    function authorizeOperator(address operator) public;\r\n    function revokeOperator(address operator) public;\r\n    function isOperatorFor(address operator, address tokenHolder) public view returns (bool);\r\n    function operatorSend(\r\n      address from, \r\n      address to, \r\n      uint256 amount, \r\n      bytes userData, \r\n      bytes operatorData\r\n    ) public;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes userData,\r\n        bytes operatorData\r\n    );\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes userData, bytes operatorData);\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\ninterface ERC777TokensSender {\r\n  function tokensToSend(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint amount,\r\n    bytes userData,\r\n    bytes operatorData\r\n  ) public;\r\n}\r\n\r\ncontract ERC820Implementer {\r\n  ERC820Registry internal erc820Registry = ERC820Registry(0x991a1bcb077599290d7305493c9A630c20f8b798);\r\n  //ERC820Implementer public erc820Registry;\r\n  function setIntrospectionRegistry(address _erc820Registry) internal {\r\n    erc820Registry = ERC820Registry(_erc820Registry);\r\n  }\r\n\r\n  function getIntrospectionRegistry() public view returns(address) {\r\n    return erc820Registry;\r\n  }\r\n\r\n  function setInterfaceImplementation(string ifaceLabel, address impl) internal {\r\n    bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\r\n    erc820Registry.setInterfaceImplementer(this, ifaceHash, impl);\r\n  }\r\n\r\n  function interfaceAddr(address addr, string ifaceLabel) internal view returns(address) {\r\n    bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\r\n    return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\r\n  }\r\n\r\n  function delegateManagement(address newManager) internal {\r\n    erc820Registry.setManager(this, newManager);\r\n  }\r\n}\r\n\r\ncontract Basic777 is Pausable, ERC20Token, ERC777Token, Lockable, ERC820Implementer {\r\n  using SafeMath for uint256;\r\n  \r\n  string private mName;\r\n  string private mSymbol;\r\n  uint256 private mGranularity;\r\n  uint256 private mTotalSupply;\r\n  bool private _initialized;\r\n  \r\n  bool private mErc20compatible;\r\n  \r\n  mapping(address => uint) private mBalances;\r\n  mapping(address => lockedTokens) private mLockedBalances;\r\n  mapping(address => mapping(address => bool)) private mAuthorized;\r\n  mapping(address => mapping(address => uint256)) private mAllowed;\r\n  \r\n  struct lockedTokens {\r\n    uint amount;\r\n    uint256 timeLockedUntil;\r\n  }\r\n  \r\n  /* -- Constructor -- */\r\n  constructor () public { }\r\n  \r\n  /* -- Initializer -- */\r\n  //\r\n  /// @notice Constructor to create a ReferenceToken\r\n  /// @param _name Name of the new token\r\n  /// @param _symbol Symbol of the new token.\r\n  /// @param _granularity Minimum transferable chunk.\r\n  function initialize (\r\n    string _name,\r\n    string _symbol,\r\n    uint256 _granularity,\r\n    address _eip820RegistryAddr,\r\n    address _owner\r\n  )  public {\r\n    require(!_initialized, \"This contract has already been initialized. You can only do this once.\");\r\n    mName = _name;\r\n    mSymbol = _symbol;\r\n    mErc20compatible = true;\r\n    setOwner(_owner);\r\n    require(_granularity >= 1, \"The granularity must be >= 1\");\r\n    mGranularity = _granularity;\r\n    setIntrospectionRegistry(_eip820RegistryAddr);\r\n    setInterfaceImplementation(\"ERC20Token\", this);\r\n    setInterfaceImplementation(\"ERC777Token\", this);\r\n    setInterfaceImplementation(\"Lockable\", this);\r\n    setInterfaceImplementation(\"Pausable\", this);\r\n    _initialized = true;\r\n  }\r\n\r\n  function initialized() public  view returns(bool) {\r\n    return _initialized;\r\n  }\r\n  \r\n  function getIntrospectionRegistry() public view returns(address){\r\n    return address(erc820Registry);\r\n  }\r\n  \r\n  /* -- ERC777 Interface Implementation -- */\r\n  //\r\n  /// @return the name of the token\r\n  function name() public constant returns (string) { return mName; } //solium-disable-line no-constant\r\n  \r\n  /// @return the symbol of the token\r\n  function symbol() public constant returns (string) { return mSymbol; } //solium-disable-line no-constant\r\n  \r\n  /// @return the granularity of the token\r\n  function granularity() public view returns (uint256) { return mGranularity; }\r\n  \r\n  /// @return the total supply of the token\r\n  function totalSupply() public constant returns (uint256) { return mTotalSupply; } //solium-disable-line no-constant\r\n  \r\n  /// @notice Return the account balance of some account\r\n  /// @param _tokenHolder Address for which the balance is returned\r\n  /// @return the balance of `_tokenAddress`.\r\n  function balanceOf(address _tokenHolder) public constant returns (uint256) { //solium-disable-line no-constant\r\n    return mBalances[_tokenHolder]; \r\n  }\r\n  \r\n  /// @notice Send `_amount` of tokens to address `_to`\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  function send(address _to, uint256 _amount) public whenNotPaused {\r\n    doSend(\r\n      msg.sender, \r\n      _to, \r\n      _amount, \r\n      \"\", \r\n      msg.sender, \r\n      \"\", \r\n      true\r\n    );\r\n  }\r\n  \r\n  /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  function send(address _to, uint256 _amount, bytes _userData) public whenNotPaused {\r\n    doSend(\r\n      msg.sender, \r\n      _to, \r\n      _amount, \r\n      _userData, \r\n      msg.sender, \r\n      \"\", \r\n      true\r\n    );\r\n  }\r\n  \r\n  /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\r\n  /// @param _operator The operator that wants to be Authorized\r\n  function authorizeOperator(address _operator) public whenNotPaused {\r\n    require(_operator != msg.sender, \"You cannot authorize yourself as an operator\");\r\n    mAuthorized[_operator][msg.sender] = true;\r\n    emit AuthorizedOperator(_operator, msg.sender);\r\n  }\r\n  \r\n  /// @notice extended 777 approveAndCall and erc20 approve functionality that gives an allowance and calls the new operator.\r\n  ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\r\n  /// @param _operator The address of the account able to transfer the tokens\r\n  /// @param _amount The number of tokens to be approved for transfer\r\n  /// @dev to revoke the operator of SOME allowance simply call it again as it will overwrite its previous allowance.\r\n  /// @return `true`, if the approve can't be done, it should fail.\r\n  function approveAndCall(address _operator, uint256 _amount, bytes _operatorData) public whenNotPaused returns (bool success) {\r\n    uint balanceAvailable = getAmountOfUnlockedTokens(msg.sender);\r\n    require(balanceAvailable >= _amount, \"The amount of unlocked tokens must be >= the amount sent\");\r\n    mAllowed[msg.sender][_operator] = _amount;\r\n    callOperator(\r\n      _operator, \r\n      msg.sender, \r\n      _operator, \r\n      _amount, \r\n      \"0x0\", \r\n      _operatorData, \r\n      true\r\n    );\r\n    emit Approval(msg.sender, _operator, _amount);\r\n    return true;\r\n  }\r\n  \r\n  /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\r\n  /// @param _operator The operator that wants to be Revoked\r\n  function revokeOperator(address _operator) public whenNotPaused {\r\n    require(_operator != msg.sender, \"You cannot authorize yourself as an operator\");\r\n    mAuthorized[_operator][msg.sender] = false;\r\n    emit RevokedOperator(_operator, msg.sender);\r\n  }\r\n  \r\n  /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\r\n  /// @param _operator address to check if it has the right to manage the tokens\r\n  /// @param _tokenHolder address which holds the tokens to be managed\r\n  /// @return `true` if `_operator` is authorized for `_tokenHolder`\r\n  function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\r\n    return _operator == _tokenHolder || mAuthorized[_operator][_tokenHolder];\r\n  }\r\n  \r\n  /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  /// @param _userData Data generated by the user to be sent to the recipient\r\n  /// @param _operatorData Data generated by the operator to be sent to the recipient\r\n  function operatorSend(\r\n    address _from, \r\n    address _to, \r\n    uint256 _amount, \r\n    bytes _userData, \r\n    bytes _operatorData\r\n  ) public whenNotPaused {\r\n    require(isOperatorFor(msg.sender, _from), \"Only an approved operator can use operatorSend\");\r\n    doSend(\r\n      _from, \r\n      _to, \r\n      _amount, \r\n      _userData, \r\n      msg.sender, \r\n      _operatorData, \r\n      true\r\n    );\r\n  }\r\n  \r\n  /* -- Mint And Burn Functions (not part of the ERC777 standard, only the Events/tokensReceived are) -- */\r\n  //\r\n  /// @notice Generates `_amount` tokens to be assigned to `_tokenHolder`\r\n  ///  Sample mint function to showcase the use of the `Minted` event and the logic to notify the recipient.\r\n  /// @param _tokenHolder The address that will be assigned the new tokens\r\n  /// @param _amount The quantity of tokens generated\r\n  /// @param _operatorData Data that will be passed to the recipient as a first transfer\r\n  function mint(address _tokenHolder, uint256 _amount, bytes _operatorData) public onlyOwner {\r\n    requireMultiple(_amount);\r\n    mTotalSupply = mTotalSupply.add(_amount);\r\n    mBalances[_tokenHolder] = mBalances[_tokenHolder].add(_amount);\r\n    \r\n    callRecipient(\r\n      msg.sender, \r\n      0x0, \r\n      _tokenHolder, \r\n      _amount, \r\n      \"\", \r\n      _operatorData, \r\n      true\r\n    );\r\n    \r\n    emit Minted(\r\n      msg.sender, \r\n      _tokenHolder, \r\n      _amount, \r\n      _operatorData\r\n    );\r\n    if (mErc20compatible) { \r\n      emit Transfer(0x0, _tokenHolder, _amount); \r\n    }\r\n  }\r\n\r\n  function burn(uint256 _amount, bytes _holderData) public whenNotPaused {\r\n    doBurn(\r\n      msg.sender, \r\n      msg.sender, \r\n      _amount, \r\n      _holderData, \r\n      \"\"\r\n    );\r\n  }\r\n\r\n  function operatorBurn(\r\n    address _tokenHolder, \r\n    uint256 _amount, \r\n    bytes _holderData, \r\n    bytes _operatorData\r\n  ) public whenNotPaused {\r\n    require(isOperatorFor(msg.sender, _tokenHolder), \"Only and approved operator can use operatorBurn\");\r\n    doBurn(\r\n      msg.sender, \r\n      _tokenHolder, \r\n      _amount, \r\n      _holderData, \r\n      _operatorData\r\n    );\r\n  }\r\n\r\n  /// @notice Helper function actually performing the burning of tokens.\r\n  /// @param _operator The address performing the burn\r\n  /// @param _tokenHolder The address holding the tokens being burn\r\n  /// @param _amount The number of tokens to be burnt\r\n  /// @param _holderData Data generated by the token holder\r\n  /// @param _operatorData Data generated by the operator\r\n  function doBurn(\r\n    address _operator, \r\n    address _tokenHolder, \r\n    uint256 _amount, \r\n    bytes _holderData, \r\n    bytes _operatorData\r\n  ) internal whenNotPaused {\r\n    requireMultiple(_amount);\r\n    uint balanceAvailable = getAmountOfUnlockedTokens(_tokenHolder);\r\n    require(\r\n      balanceAvailable >= _amount, \r\n      \"You can only burn tokens when you have a balance grater than or equal to the amount specified\"\r\n    );\r\n\r\n    mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\r\n    mTotalSupply = mTotalSupply.sub(_amount);\r\n    \r\n    callSender(\r\n      _operator, \r\n      _tokenHolder, \r\n      0x0, \r\n      _amount, \r\n      _holderData, \r\n      _operatorData\r\n    );\r\n    \r\n    emit Burned(\r\n      _operator, \r\n      _tokenHolder, \r\n      _amount, \r\n      _holderData, \r\n      _operatorData\r\n    );\r\n  }\r\n  \r\n  /* -- ERC20 Compatible Methods -- */\r\n  //\r\n  /// @notice This modifier is applied to erc20 obsolete methods that are\r\n  ///  implemented only to maintain backwards compatibility. When the erc20\r\n  ///  compatibility is disabled, this methods will fail.\r\n  modifier erc20 () {\r\n    require(mErc20compatible, \"You can only use this function when the 'ERC20Token' interface is enabled\");\r\n    _;\r\n  }\r\n  \r\n  /// @notice Disables the ERC20 interface. This function can only be called\r\n  ///  by the owner.\r\n  function disableERC20() public onlyOwner {\r\n    mErc20compatible = false;\r\n    setInterfaceImplementation(\"ERC20Token\", 0x0);\r\n  }\r\n  \r\n  /// @notice Re enables the ERC20 interface. This function can only be called\r\n  ///  by the owner.\r\n  function enableERC20() public onlyOwner {\r\n    mErc20compatible = true;\r\n    setInterfaceImplementation(\"ERC20Token\", this);\r\n  }\r\n  \r\n  /// @notice For Backwards compatibility\r\n  /// @return The decimls of the token. Forced to 18 in ERC777.\r\n  function decimals() public erc20 view returns (uint8) { return uint8(18); } //solium-disable-line no-constant\r\n  \r\n  /// @notice ERC20 backwards compatible transfer.\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be transferred\r\n  /// @return `true`, if the transfer can't be done, it should fail.\r\n  function transfer(address _to, uint256 _amount) public whenNotPaused erc20 returns (bool success) {\r\n    doSend(\r\n      msg.sender, \r\n      _to, \r\n      _amount, \r\n      \"\", \r\n      msg.sender, \r\n      \"\", \r\n      false\r\n    );\r\n    return true;\r\n  }\r\n  \r\n  /// @notice ERC20 backwards compatible transferFrom.\r\n  /// @param _from The address holding the tokens being transferred\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be transferred\r\n  /// @return `true`, if the transfer can't be done, it should fail.\r\n  function transferFrom(address _from, address _to, uint256 _amount) public whenNotPaused erc20 returns (bool success) {\r\n    uint balanceAvailable = getAmountOfUnlockedTokens(_from);\r\n    require(\r\n      balanceAvailable >= _amount, \r\n      \"You can only use transferFrom when you specify an amount of tokens >= the '_from' address's amount of unlocked tokens\"\r\n    );\r\n    require(\r\n      _amount <= mAllowed[_from][msg.sender],\r\n      \"You can only use transferFrom with an amount less than or equal to the current 'mAllowed' allowance.\"\r\n    );\r\n    \r\n    // Cannot be after doSend because of tokensReceived re-entry\r\n    mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\r\n    doSend(\r\n      _from, \r\n      _to, \r\n      _amount, \r\n      \"\", \r\n      msg.sender, \r\n      \"\", \r\n      false\r\n    );\r\n    return true;\r\n  }\r\n  \r\n  /// @notice ERC20 backwards compatible approve.\r\n  ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _amount The number of tokens to be approved for transfer\r\n  /// @return `true`, if the approve can't be done, it should fail.\r\n  function approve(address _spender, uint256 _amount) public whenNotPaused erc20 returns (bool success) {\r\n    uint balanceAvailable = getAmountOfUnlockedTokens(msg.sender);\r\n    require(\r\n      balanceAvailable >= _amount, \r\n      \"You can only approve an amount >= the amount of tokens currently unlocked for this account\"\r\n    );\r\n    mAllowed[msg.sender][_spender] = _amount;\r\n    emit Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n  \r\n  /// @notice ERC20 backwards compatible allowance.\r\n  ///  This function makes it easy to read the `allowed[]` map\r\n  /// @param _owner The address of the account that owns the token\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n  ///  to spend\r\n  function allowance(address _owner, address _spender) public erc20 constant returns (uint256 remaining) { //solium-disable-line no-constant\r\n    return mAllowed[_owner][_spender];\r\n  }\r\n  \r\n  /* -- Helper Functions -- */\r\n  //\r\n  /// @notice Internal function that ensures `_amount` is multiple of the granularity\r\n  /// @param _amount The quantity that want's to be checked\r\n  function requireMultiple(uint256 _amount) internal view {\r\n    require(\r\n      _amount.div(mGranularity).mul(mGranularity) == _amount, \r\n      \"You can only use tokens using the granularity currently set.\"\r\n    );\r\n  }\r\n  \r\n  /// @notice Check whether an address is a regular address or not.\r\n  /// @param _addr Address of the contract that has to be checked\r\n  /// @return `true` if `_addr` is a regular address (not a contract)\r\n  function isRegularAddress(address _addr) internal view returns(bool) {\r\n    if (_addr == 0) { \r\n      return false; \r\n    }\r\n    uint size;\r\n    assembly { size := extcodesize(_addr) } //solium-disable-line security/no-inline-assembly\r\n    return size == 0;\r\n  }\r\n  \r\n  /// @notice Helper function actually performing the sending of tokens.\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  /// @param _userData Data generated by the user to be passed to the recipient\r\n  /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n  /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n  ///  implementing `erc777_tokenHolder`.\r\n  ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n  ///  functions SHOULD set this parameter to `false`.\r\n  function doSend(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    address _operator,\r\n    bytes _operatorData,\r\n    bool _preventLocking\r\n  ) private whenNotPaused {\r\n    requireMultiple(_amount);\r\n    uint balanceAvailable = getAmountOfUnlockedTokens(_from);\r\n    \r\n    callSender(\r\n      _operator, \r\n      _from, \r\n      _to, \r\n      _amount, \r\n      _userData, \r\n      _operatorData\r\n    );\r\n    \r\n    require(\r\n      _to != address(0), \r\n      \"You cannot invoke doSend with a the burn address (0x0) as the recipient 'to' address\"\r\n    );          // forbid sending to 0x0 (=burning)\r\n    require(\r\n      balanceAvailable >= _amount, \r\n      \"You can only invoke doSend when the 'from' address has an unlocked balance >= the '_amount' sent\"\r\n    ); // ensure enough funds\r\n    \r\n    mBalances[_from] = mBalances[_from].sub(_amount);\r\n    mBalances[_to] = mBalances[_to].add(_amount);\r\n    \r\n    callRecipient(\r\n      _operator, \r\n      _from, \r\n      _to, \r\n      _amount, \r\n      _userData, \r\n      _operatorData, \r\n      _preventLocking\r\n    );\r\n    \r\n    emit Sent(\r\n      _operator, \r\n      _from, \r\n      _to, \r\n      _amount, \r\n      _userData, \r\n      _operatorData\r\n    );\r\n    if (mErc20compatible) { \r\n      emit Transfer(_from, _to, _amount); \r\n    }\r\n  }\r\n  \r\n  /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\r\n  ///  May throw according to `_preventLocking`\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  /// @param _userData Data generated by the user to be passed to the recipient\r\n  /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n  /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n  ///  implementing `ERC777TokensRecipient`.\r\n  ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n  ///  functions SHOULD set this parameter to `false`.\r\n  function callRecipient(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    bytes _operatorData,\r\n    bool _preventLocking\r\n  ) private {\r\n    address recipientImplementation = interfaceAddr(_to, \"ERC777TokensRecipient\");\r\n    if (recipientImplementation != 0) {\r\n      ERC777TokensRecipient(recipientImplementation).tokensReceived(\r\n        _operator, \r\n        _from, \r\n        _to, \r\n        _amount, \r\n        _userData, \r\n        _operatorData\r\n      );\r\n    } else if (_preventLocking) {\r\n      require(\r\n        isRegularAddress(_to),\r\n        \"When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface\"\r\n      );\r\n    }\r\n  }\r\n  \r\n  /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\r\n  ///  May throw according to `_preventLocking`\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The amount of tokens to be sent\r\n  /// @param _userData Data generated by the user to be passed to the recipient\r\n  /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n  ///  implementing `ERC777TokensSender`.\r\n  ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n  ///  functions SHOULD set this parameter to `false`.\r\n  function callSender(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    bytes _operatorData\r\n  ) private whenNotPaused {\r\n    address senderImplementation = interfaceAddr(_from, \"ERC777TokensSender\");\r\n    if (senderImplementation != 0) {\r\n      ERC777TokensSender(senderImplementation).tokensToSend(\r\n        _operator, \r\n        _from, \r\n        _to, \r\n        _amount, \r\n        _userData, \r\n        _operatorData\r\n      );\r\n    }\r\n  }\r\n  \r\n  /// @notice Helper function that checks for IEIP777TokensOperator on the recipient and calls it.\r\n  ///  May throw according to `_preventLocking`\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of tokens to be sent\r\n  /// @param _userData Data generated by the user to be passed to the recipient\r\n  /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n  /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n  ///  implementing `IEIP777TokensOperator`\r\n  ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n  ///  functions SHOULD set this parameter to `false`.\r\n  function callOperator(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bytes _userData,\r\n    bytes _operatorData,\r\n    bool _preventLocking\r\n  ) private {\r\n    address recipientImplementation = interfaceAddr(_to, \"ERC777TokensOperator\");\r\n    if (recipientImplementation != 0) {\r\n      ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(\r\n        _operator, \r\n        _from, \r\n        _to, \r\n        _value, \r\n        _userData, \r\n        _operatorData\r\n      );\r\n    } else if (_preventLocking) {\r\n      require(\r\n        isRegularAddress(_to),\r\n        \"When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface\"\r\n      );\r\n    }\r\n  }\r\n  \r\n  /// @notice locks a percentage of tokens for a specified time period and then grants ownership to the specified owner\r\n  /// @param _tokenHolder The address to give the tokens to\r\n  /// @param _amount The amount of tokens to give the holder (the immediate amount including the amount to lock)\r\n  /// @param _percentageToLock the percentage of the distributed tokens to lock\r\n  /// @param _unlockTime the block.timestamp to unlock the tokens at\r\n  function lockAndDistributeTokens(\r\n    address _tokenHolder, \r\n    uint256 _amount, \r\n    uint256 _percentageToLock, \r\n    uint256 _unlockTime\r\n  ) public onlyOwner {\r\n    requireMultiple(_amount);\r\n    require(\r\n      _percentageToLock <= 100 && \r\n      _percentageToLock > 0, \r\n      \"You can only lock a percentage between 0 and 100.\"\r\n    );\r\n    require(\r\n      mLockedBalances[_tokenHolder].amount == 0, \r\n      \"You can only lock one amount of tokens for a given address. It is currently indicating that there are already locked tokens for this address.\"\r\n    );\r\n    uint256 amountToLock = _amount.mul(_percentageToLock).div(100);\r\n    mBalances[msg.sender] = mBalances[msg.sender].sub(_amount);\r\n    mBalances[_tokenHolder] = mBalances[_tokenHolder].add(_amount);\r\n    mLockedBalances[_tokenHolder] = lockedTokens({\r\n      amount: amountToLock,\r\n      timeLockedUntil: _unlockTime\r\n    });\r\n    \r\n    callRecipient(\r\n      msg.sender, \r\n      0x0, \r\n      _tokenHolder, \r\n      _amount, \r\n      \"\", \r\n      \"\", \r\n      true\r\n    );\r\n\r\n    emit LockedTokens(_tokenHolder, amountToLock, _unlockTime);\r\n    \r\n    if (mErc20compatible) { \r\n      emit Transfer(0x0, _tokenHolder, _amount); \r\n    }\r\n  }\r\n  \r\n  /// @notice Helper function that returns the amount of tokens aof an owner minus the amount currently locked\r\n  /// @param _tokenOwner The address holding the tokens\r\n  function getAmountOfUnlockedTokens(address _tokenOwner) public returns(uint) {\r\n    uint balanceAvailable = mBalances[_tokenOwner];\r\n    if (\r\n      mLockedBalances[_tokenOwner].amount != 0 && \r\n      mLockedBalances[_tokenOwner].timeLockedUntil > block.timestamp //solium-disable-line security/no-block-members\r\n    ){\r\n      balanceAvailable = balanceAvailable.sub(mLockedBalances[_tokenOwner].amount);\r\n    } else if (\r\n      mLockedBalances[_tokenOwner].amount != 0 && \r\n      mLockedBalances[_tokenOwner].timeLockedUntil < block.timestamp //solium-disable-line security/no-block-members\r\n    ) {\r\n      mLockedBalances[_tokenOwner] = lockedTokens({\r\n        amount: 0,\r\n        timeLockedUntil: 0\r\n      }); //todo wrtie test to check if cleared\r\n    }\r\n    return balanceAvailable;\r\n  }\r\n}\r\n\r\ncontract KPXV0_1_0 is Basic777 {\r\n  constructor() public Basic777() { }\r\n}\r\n\r\ninterface ERC777TokensRecipient {\r\n  function tokensReceived(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint amount,\r\n    bytes userData,\r\n    bytes operatorData\r\n  ) public;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIntrospectionRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_granularity\",\"type\":\"uint256\"},{\"name\":\"_eip820RegistryAddr\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"getAmountOfUnlockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"send\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_holderData\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_percentageToLock\",\"type\":\"uint256\"},{\"name\":\"_unlockTime\",\"type\":\"uint256\"}],\"name\":\"lockAndDistributeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_holderData\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountToLock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"LockedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"}]","ContractName":"KPXV0_1_0","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://159bc940e1af3c27e590fb8e7ab9e509c0c35ad1406865608430a11a0c659347"}]}