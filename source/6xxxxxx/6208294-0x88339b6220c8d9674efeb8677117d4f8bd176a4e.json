{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Cryptopixel {\r\n\r\n    // Name of token\r\n    string constant public name = \"CryptoPixel\";\r\n    // Symbol of Cryptopixel token\r\n  \tstring constant public symbol = \"CPX\";\r\n\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /////////////////////////\r\n    // Variables\r\n    /////////////////////////\r\n    // Total number of stored artworks\r\n    uint256 public totalSupply;\r\n    // Group of artwork - 52 is limit\r\n    address[limitChrt] internal artworkGroup;\r\n    // Number of total artworks\r\n    uint constant private limitChrt = 52;\r\n    // This is address of artwork creator\r\n    address constant private creatorAddr = 0x174B3C5f95c9F27Da6758C8Ca941b8FFbD01d330;\r\n\r\n    \r\n    // Basic references\r\n    mapping(uint => address) internal tokenIdToOwner;\r\n    mapping(address => uint[]) internal listOfOwnerTokens;\r\n    mapping(uint => string) internal referencedMetadata;\r\n    \r\n    // Events\r\n    event Minted(address indexed _to, uint256 indexed _tokenId);\r\n\r\n    // Modifier\r\n    modifier onlyNonexistentToken(uint _tokenId) {\r\n        require(tokenIdToOwner[_tokenId] == address(0));\r\n        _;\r\n    }\r\n\r\n\r\n    /////////////////////////\r\n    // Viewer Functions\r\n    /////////////////////////\r\n    // Get and returns the address currently marked as the owner of _tokenID. \r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner)\r\n    {\r\n        return tokenIdToOwner[_tokenId];\r\n    }\r\n    \r\n    // Get and return the total supply of token held by this contract. \r\n    function totalSupply() public view returns (uint256 _totalSupply)\r\n    {\r\n        return totalSupply;\r\n    }\r\n    \r\n    //Get and return the balance of token held by _owner. \r\n    function balanceOf(address _owner) public view returns (uint _balance)\r\n    {\r\n        return listOfOwnerTokens[_owner].length;\r\n    }\r\n\r\n    // Get and returns a metadata of _tokenId\r\n    function tokenMetadata(uint _tokenId) public view returns (string _metadata)\r\n    {\r\n        return referencedMetadata[_tokenId];\r\n    }\r\n    \r\n    // Retrive artworkGroup\r\n    function getArtworkGroup() public view returns (address[limitChrt]) {\r\n        return artworkGroup;\r\n    }\r\n    \r\n    \r\n    /////////////////////////\r\n    // Update Functions\r\n    /////////////////////////\r\n    /**\r\n     * @dev Public function to mint a new token with metadata\r\n     * @dev Reverts if the given token ID already exists\r\n     * @param _owner The address that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender(creator)\r\n     * @param _metadata string of meta data, IPFS hash\r\n     */\r\n    function mintWithMetadata(address _owner, uint256 _tokenId, string _metadata) public onlyNonexistentToken (_tokenId)\r\n    {\r\n        require(totalSupply < limitChrt);\r\n        require(creatorAddr == _owner);\r\n        \r\n        _setTokenOwner(_tokenId, _owner);\r\n        _addTokenToOwnersList(_owner, _tokenId);\r\n        _insertTokenMetadata(_tokenId, _metadata);\r\n\r\n        artworkGroup[_tokenId] = _owner;\r\n        totalSupply = totalSupply.add(1);\r\n        emit Minted(_owner, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Public function to add created token id in group\r\n     * @param _owner The address that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender(creator)\r\n     * @return _tokenId uint256 ID of the token \r\n     */\r\n    function group(address _owner, uint _tokenId) public returns (uint) {\r\n        require(_tokenId >= 0 && _tokenId <= limitChrt);\r\n        artworkGroup[_tokenId] = _owner;    \r\n        return _tokenId;\r\n    }\r\n\r\n    \r\n    /////////////////////////\r\n    // Internal, helper functions\r\n    /////////////////////////\r\n    function _setTokenOwner(uint _tokenId, address _owner) internal\r\n    {\r\n        tokenIdToOwner[_tokenId] = _owner;\r\n    }\r\n\r\n    function _addTokenToOwnersList(address _owner, uint _tokenId) internal\r\n    {\r\n        listOfOwnerTokens[_owner].push(_tokenId);\r\n    }\r\n\r\n    function _insertTokenMetadata(uint _tokenId, string _metadata) internal\r\n    {\r\n        referencedMetadata[_tokenId] = _metadata;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"group\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"mintWithMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"_metadata\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getArtworkGroup\",\"outputs\":[{\"name\":\"\",\"type\":\"address[52]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"}]","ContractName":"Cryptopixel","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2bb333ea74720518a43f0693e497dd5424b0560e8ea25a374801646e04620028"}]}