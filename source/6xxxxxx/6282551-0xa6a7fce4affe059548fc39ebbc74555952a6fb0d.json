{"status":"1","message":"OK","result":[{"SourceCode":"{\"Administratable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./Ownable.sol\\u0027;\\n\\ncontract Administratable is Ownable {\\n  mapping (address =\\u003e bool) admins;\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == owner || admins[msg.sender]);\\n    _;\\n  }\\n  \\n  function addAdmin(address _adminAddr) onlyAdmin public returns (bool success) {\\n    admins[_adminAddr] = true;\\n    emit AdminAdded(_adminAddr, msg.sender);\\n    return true;\\n  }\\n\\n  function revokeAdmin(address _adminAddr) onlyAdmin public returns (bool success) {\\n    require(msg.sender != _adminAddr);\\n    admins[_adminAddr] = false;\\n    emit AdminRevoked(_adminAddr, msg.sender);\\n    return true;\\n  }\\n  \\n  event AdminAdded(address indexed _admin, address indexed _by);\\n  event AdminRevoked(address indexed _admin, address indexed _by);\\n}\\n\"},\"BasicToken.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\nimport \\\"./ERC20Basic.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n  using SafeMath for uint256;\\n\\n  mapping(address =\\u003e uint256) balances;\\n\\n  uint256 totalSupply_;\\n\\n  /**\\n  * @dev total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return totalSupply_;\\n  }\\n\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[msg.sender]);\\n\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    return balances[_owner];\\n  }\\n\\n}\\n\"},\"DividendToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./Administratable.sol\\u0027;\\nimport \\u0027./Pausable.sol\\u0027;\\nimport \\u0027./StandardToken.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract DividendToken is StandardToken, Pausable, Administratable {\\n  using SafeMath for uint256;\\n\\n  uint256 public period = 0;\\n  uint256 public buyBackTime;\\n  bool public ended = false;\\n  \\n  mapping (uint256 =\\u003e uint256) public dividends;\\n  mapping (uint256 =\\u003e uint256) public dividendDates;\\n  uint256 public buyBackTotal;\\n  mapping (address =\\u003e bool) public boughtBack;\\n  \\n  mapping (address =\\u003e mapping (uint256 =\\u003e uint256)) internal holdings;\\n  mapping (address =\\u003e uint256) internal last;\\n  mapping (address =\\u003e uint256) public claimedTo;\\n  mapping (address =\\u003e bool) beenDivLocked;\\n  mapping (address =\\u003e uint256[]) divLocks;\\n\\n  mapping(uint256 =\\u003e uint256) totalAt;\\n\\n  modifier canBuyBack() {\\n    require(now \\u003e buyBackTime);\\n    _;\\n  }\\n\\n  modifier onlyLive() {\\n    require(!ended);\\n    _;\\n  }\\n\\n  function updateHoldings(address _holder) internal returns (bool success) {\\n    uint256 lastPeriod = last[_holder];\\n    uint256 lastAmount = holdings[_holder][lastPeriod];\\n    if(lastAmount != 0) {\\n      for (uint i = lastPeriod + 1; i \\u003c= period; i++) {\\n        holdings[_holder][i] = lastAmount;\\n      }\\n    }\\n    last[_holder] = period;\\n    return true;\\n  }\\n\\n  function updateHoldingsTo(address _holder, uint256 _to) public onlyAdmin returns (bool success){\\n    require(_to \\u003e last[_holder]);\\n    require(_to \\u003c= period);\\n    uint256 lastPeriod = last[_holder];\\n    uint256 lastAmount = holdings[_holder][lastPeriod];\\n    if(lastAmount != 0) {\\n      for (uint i = lastPeriod + 1; i \\u003c= _to; i++) {\\n        holdings[_holder][i] = lastAmount;\\n      }\\n    }\\n    last[_holder] = _to;\\n    return true;\\n  }\\n  \\n  function lockedAt(address _address, uint256 _period) public view returns (bool) {\\n    if(!beenDivLocked[_address]) {\\n      return false;\\n    }\\n    bool locked = false;\\n    for(uint i = 0; i \\u003c divLocks[_address].length; i++) {\\n      if(divLocks[_address][i] \\u003e _period) {\\n        break;\\n      } \\n      locked = !locked;\\n    }\\n    return locked;\\n  }\\n\\n  function addLock(address _locked) onlyOwner public returns (bool success) {\\n    require(!lockedAt(_locked, period));\\n    if (last[_locked] \\u003c period) {\\n      updateHoldings(_locked);\\n    }\\n    totalAt[period] = totalAt[period].sub(balanceOf(_locked));\\n    beenDivLocked[_locked] = true;\\n    divLocks[_locked].push(period);\\n    emit Locked(_locked, period);\\n    return true;\\n  }\\n\\n  function revokeLock(address _unlocked) onlyOwner public returns (bool success) {\\n    require(lockedAt(_unlocked, period));\\n    if (last[_unlocked] \\u003c period) {\\n      updateHoldings(_unlocked);\\n    }\\n    totalAt[period] = totalAt[period].add(balanceOf(_unlocked));\\n    divLocks[_unlocked].push(period);\\n    emit Unlocked(_unlocked, period);\\n    return true;\\n  }\\n\\n  function balanceOf(address _owner) public view returns (uint256 balance) {\\n    if(ended) {\\n      return 0;\\n    }\\n    return holdings[_owner][last[_owner]];\\n  }\\n\\n  function transfer(address _to, uint256 _value) onlyLive whenNotPaused public returns (bool) {\\n    require(_to != address(0));\\n    uint256 senderLastPeriod = last[msg.sender];\\n    require(_value \\u003c= holdings[msg.sender][senderLastPeriod]);\\n\\n    if (senderLastPeriod \\u003c period) {\\n      updateHoldings(msg.sender);\\n    }\\n\\n    if (last[_to] \\u003c period) {\\n      updateHoldings(_to);\\n    }\\n\\n    holdings[msg.sender][period] = holdings[msg.sender][period].sub(_value);\\n    holdings[_to][period] = holdings[_to][period].add(_value);\\n    bool fromLocked = lockedAt(msg.sender, period);\\n    bool toLocked = lockedAt(_to, period);\\n    if(fromLocked \\u0026\\u0026 !toLocked) {\\n      totalAt[period] = totalAt[period].add(_value);\\n    } else if(!fromLocked \\u0026\\u0026 toLocked) {\\n      totalAt[period] = totalAt[period].sub(_value);\\n    }\\n    emit Transfer(msg.sender, _to, _value);\\n\\n    return true;\\n  }\\n\\n  function transferFrom(address _from, address _to, uint256 _value) onlyLive whenNotPaused public returns (bool) {\\n    require(_to != address(0));\\n    uint256 senderLastPeriod = last[_from];\\n    require(_value \\u003c= holdings[_from][senderLastPeriod]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n     if (senderLastPeriod \\u003c period) {\\n       updateHoldings(_from);\\n    }\\n\\n    if (last[_to] \\u003c period) {\\n      updateHoldings(_to);\\n    }\\n\\n    holdings[_from][period] = holdings[_from][period].sub(_value);\\n    holdings[_to][period] = holdings[_to][period].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    bool fromLocked = lockedAt(_from, period);\\n    bool toLocked = lockedAt(_to, period);\\n    if(fromLocked \\u0026\\u0026 !toLocked) {\\n      totalAt[period] = totalAt[period].add(_value);\\n    } else if(!fromLocked \\u0026\\u0026 toLocked) {\\n      totalAt[period] = totalAt[period].sub(_value);\\n    }\\n    emit Transfer(_from, _to, _value);\\n\\n    return true;\\n  }\\n\\n  function () public onlyAdmin onlyLive payable {\\n    payIn();\\n  }\\n\\n  function payIn() public onlyLive onlyAdmin payable returns (bool) {\\n    dividends[period] = msg.value;\\n    dividendDates[period] = now;\\n    period = period.add(1);\\n    totalAt[period] = totalAt[period.sub(1)];\\n    emit Paid(msg.sender, period.sub(1), msg.value);\\n    return true;\\n  }\\n  \\n  function claimDividends() whenNotPaused public returns (uint256 amount) {\\n    require(claimedTo[msg.sender] \\u003c period);\\n    uint256 total = 0;\\n    if (last[msg.sender] \\u003c period) {\\n      updateHoldings(msg.sender);\\n    }\\n    for (uint i = claimedTo[msg.sender]; i \\u003c period; i++) {\\n      if (holdings[msg.sender][i] \\u003e 0 \\u0026\\u0026 !lockedAt(msg.sender, i)) {\\n        uint256 multiplier = dividends[i].mul(holdings[msg.sender][i]);\\n        total += multiplier.div(totalAt[i]);\\n      }\\n    }\\n    claimedTo[msg.sender] = period;\\n    if(total \\u003e 0) {\\n      msg.sender.transfer(total);\\n      emit Claimed(msg.sender, i, total);\\n    }\\n    return total;\\n  }\\n\\n  function claimDividendsFor(address _address) onlyAdmin public returns (uint256 amount) {\\n    require(claimedTo[_address] \\u003c period);\\n    uint256 total = 0;\\n    if (last[_address] \\u003c period) {\\n      updateHoldings(_address);\\n    }\\n    for (uint i = claimedTo[_address]; i \\u003c period; i++) {\\n      if (holdings[_address][i] \\u003e 0 \\u0026\\u0026 !lockedAt(_address, i)) {\\n        uint256 multiplier = dividends[i].mul(holdings[_address][i]);\\n        total += multiplier.div(totalAt[i]);\\n      }\\n    }\\n    claimedTo[_address] = period;\\n    if(total \\u003e 0) {\\n      _address.transfer(total);\\n      emit Claimed(_address, i, total);\\n    }\\n    return total;\\n  }\\n  \\n  function outstandingFor(address _address) public view returns (uint256 amount) {\\n    uint256 total = 0;\\n    uint256 holds = 0;\\n    for (uint i = claimedTo[_address]; i \\u003c period; i++) {\\n      if(last[_address] \\u003c i) {\\n        holds = holdings[_address][last[_address]];\\n      } else {\\n        holds = holdings[_address][i];\\n      }\\n      if (holds \\u003e 0 \\u0026\\u0026 !lockedAt(_address, i)) {\\n        uint256 multiplier = dividends[i].mul(holds);\\n        uint256 owed = multiplier.div(totalAt[i]);\\n        total += owed;\\n      }\\n    }\\n    return total;\\n  }\\n\\n  function outstanding() public view returns (uint256 amount) {\\n    uint256 total = 0;\\n    uint256 holds = 0;\\n    for (uint i = claimedTo[msg.sender]; i \\u003c period; i++) {\\n       if(last[msg.sender] \\u003c i) {\\n        holds = holdings[msg.sender][last[msg.sender]];\\n      } else {\\n        holds = holdings[msg.sender][i];\\n      }\\n      if (holds \\u003e 0 \\u0026\\u0026 !lockedAt(msg.sender, i)) {\\n        uint256 multiplier = dividends[i].mul(holds);\\n        uint256 owed = multiplier.div(totalAt[i]);\\n        total += owed;\\n      }      \\n    }\\n    return total;\\n  }\\n  \\n  function buyBack() public onlyAdmin onlyLive canBuyBack payable returns (bool) {\\n    buyBackTotal = msg.value;\\n    period += 1;\\n    emit Paid(msg.sender, period - 1, msg.value);\\n    ended = true;\\n  }\\n\\n  function claimBuyBack() public returns (bool) {\\n    require(ended);\\n    require(!boughtBack[msg.sender]);\\n    if (last[msg.sender] \\u003c period) {\\n      updateHoldings(msg.sender);\\n    }\\n    uint256 multiplier = buyBackTotal.mul(holdings[msg.sender][period]);    \\n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\\n    boughtBack[msg.sender] = true;\\n    msg.sender.transfer(owed);\\n  }\\n\\n  function claimBuyBackFor(address _address) onlyAdmin public returns (bool) {\\n    require(ended);\\n    require(!boughtBack[_address]);\\n    if (last[_address] \\u003c period) {\\n      updateHoldings(_address);\\n    }\\n    uint256 multiplier = buyBackTotal.mul(holdings[_address][period]);    \\n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\\n    boughtBack[_address] = true;\\n    _address.transfer(owed);\\n  }\\n\\n  function dividendDateHistory() public view returns (uint256[]) {\\n    uint256[] memory dates = new uint[](period);\\n    for(uint i = 0; i \\u003c period; i++) {\\n      dates[i] = dividendDates[i];\\n    }\\n    return dates;\\n  }\\n\\n  function dividendHistory() public view returns (uint256[]) {\\n    uint256[] memory divs = new uint[](period);\\n    for(uint i = 0; i \\u003c period; i++) {\\n      divs[i] = dividends[i];\\n    }\\n    return divs;\\n  }\\n\\n  function dividendHistoryFor(address _address) public view returns (uint256[]) {\\n    uint256[] memory divs = new uint[](period);\\n    for(uint i = 0; i \\u003c period; i++) {\\n      uint256 multiplier;\\n      if(last[_address] \\u003c i) {\\n        multiplier = dividends[i].mul(holdings[_address][i]);\\n      } else {\\n        multiplier = dividends[i].mul(holdings[_address][last[_address]]);\\n      }\\n      if(lockedAt(_address, i)) {\\n        divs[i] = 0;\\n      } else {\\n        divs[i] = multiplier.div(totalAt[i]);\\n      }\\n    }\\n    return divs;\\n  }\\n\\n  event Paid(address indexed _sender, uint256 indexed _period, uint256 amount);\\n\\n  event Claimed(address indexed _recipient, uint256 indexed _period, uint256 _amount);\\n\\n  event Locked(address indexed _locked, uint256 indexed _at);\\n\\n  event Unlocked(address indexed _unlocked, uint256 indexed _at);\\n}\\n\"},\"DividendTokenStore.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./Pausable.sol\\u0027;\\n\\ncontract DividendTokenStore is Pausable {\\n\\n  function totalSupply() public view returns (uint256);\\n\\n  function addLock(address _locked) public returns (bool);\\n\\n  function revokeLock(address _unlocked) public returns (bool);\\n  \\n  function balanceOf(address _owner) public view returns (uint256);\\n\\n  function transfer(address _from, address _to, uint256 _value) public returns (bool);\\n  \\n  function () public payable {\\n    payIn();\\n  }\\n\\n  function payIn() public payable returns (bool);\\n  \\n  function claimDividends() public returns (uint256);\\n  \\n  function claimDividendsFor(address _address) public returns (uint256);\\n    \\n  function buyBack() public payable returns (bool);\\n\\n  function claimBuyBack() public returns (bool);\\n\\n  function claimBuyBackFor(address _address) public returns (bool);\\n\\n  function mint(address _to, uint256 _amount) public returns (bool);\\n  \\n  event Paid(address indexed _sender, uint256 indexed _period, uint256 amount);\\n\\n  event Claimed(address indexed _recipient, uint256 indexed _period, uint256 _amount);\\n\\n  event Locked(address indexed _locked, uint256 indexed _at);\\n\\n  event Unlocked(address indexed _unlocked, uint256 indexed _at);\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender)\\n    public view returns (uint256);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    public returns (bool);\\n\\n  function approve(address spender, uint256 value) public returns (bool);\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  function totalSupply() public view returns (uint256);\\n  function balanceOf(address who) public view returns (uint256);\\n  function transfer(address to, uint256 value) public returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"MoriaToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./DividendTokenStore.sol\\u0027;\\nimport \\u0027./Administratable.sol\\u0027;\\nimport \\u0027./StandardToken.sol\\u0027;\\n\\ncontract MoriaToken is StandardToken, Administratable {\\n  \\n  string public constant name = \\\"MoriaToken\\\";\\n  string public constant symbol = \\\"MOR\\\";\\n  uint8 public constant decimals = 18;\\n\\n  DividendTokenStore public store;\\n  bool public canDestroy = true;\\n  bool public minting = true;\\n\\n  modifier isDestroyable() {\\n    require(canDestroy);\\n    _;\\n  }\\n\\n  modifier canMint() {\\n    require(minting);\\n    _;\\n  }\\n\\n  constructor() public {\\n  }\\n\\n  function () public payable {\\n    require(store.payIn.value(msg.value)());\\n  }\\n\\n  function totalSupply() public view returns (uint256) {\\n    return store.totalSupply();\\n  }\\n\\n  function balanceOf(address _owner) public view returns (uint256 balance) {\\n    return store.balanceOf(_owner);\\n  }\\n\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\n    store.transfer(msg.sender, _to, _value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n    store.transfer(_from, _to, _value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    emit Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  function pause() public onlyOwner {\\n    store.pause();\\n  }\\n\\n  function unpause() public onlyOwner {\\n    store.unpause();\\n  }\\n\\n  function addLock(address _address) onlyAdmin public returns (bool) {\\n    return store.addLock(_address);\\n  }\\n\\n  function revokeLock(address _address) onlyAdmin public returns (bool) {\\n    return store.revokeLock(_address);\\n  }\\n\\n  function claimDividends() public returns (uint256 amount) {\\n    return store.claimDividendsFor(msg.sender);\\n  }\\n\\n  function claimDividendsFor(address _address) public onlyAdmin returns (uint256 amount) {\\n    return store.claimDividendsFor(_address);\\n  }\\n\\n  function buyBack() public onlyAdmin payable returns (bool) {\\n    require(store.buyBack.value(msg.value)());\\n    return true;\\n  }\\n\\n  function claimBuyBack() public returns (bool) {\\n    return claimBuyBackFor(msg.sender);\\n  }\\n\\n  function claimBuyBackFor(address _address) public onlyAdmin returns (bool) {\\n    return claimBuyBackFor(_address);\\n  }\\n \\n  // admin\\n\\n  function mint(address _from, address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\\n    store.mint(_to, _amount);\\n    emit Transfer(_from, _to, _amount);\\n  }\\n\\n  function endMinting() public onlyOwner canMint returns (bool) {\\n    minting = false;\\n  }\\n\\n  function upgradeEvent(address _from, address _to) public onlyAdmin {\\n    emit Transfer(_from, _to,  store.balanceOf(_to));\\n  }\\n\\n  function changeStore(DividendTokenStore _store) public onlyOwner returns (bool) {\\n    store = _store;\\n    emit StoreChanged(address(store));\\n    return true;\\n  }\\n\\n  function transferStoreOwnership() public onlyOwner {\\n    store.transferOwnership(owner);\\n  }\\n\\n  function destroyToken() public onlyOwner isDestroyable {\\n    transferStoreOwnership();\\n    selfdestruct(owner);\\n  }\\n\\n  function disableSelfDestruct() public onlyOwner isDestroyable {\\n    canDestroy = false;\\n  } \\n\\n  event StoreChanged(address indexed _newStore);\\n  \\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address _newOwner) public onlyOwner {\\n    _transferOwnership(_newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address _newOwner) internal {\\n    require(_newOwner != address(0));\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable {\\n  event Pause();\\n  event Unpause();\\n\\n  bool public paused = false;\\n\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() onlyOwner whenNotPaused public {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() onlyOwner whenPaused public {\\n    paused = false;\\n    emit Unpause();\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"StandardDividendTokenStore.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./DividendTokenStore.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract StandardDividendTokenStore is DividendTokenStore {\\n  using SafeMath for uint256;\\n\\n  uint256 public period = 0;\\n  uint256 public buyBackTime;\\n  bool public ended = false;\\n  \\n  mapping (uint256 =\\u003e uint256) public dividends;\\n  mapping (uint256 =\\u003e uint256) public dividendDates;\\n  uint256 public buyBackTotal;\\n  mapping (address =\\u003e bool) public boughtBack;\\n  \\n  mapping (address =\\u003e mapping (uint256 =\\u003e uint256)) public holdings;\\n  mapping (address =\\u003e uint256) public last;\\n  mapping (address =\\u003e uint256) public claimedTo;\\n  mapping (address =\\u003e bool) beenDivLocked;\\n  mapping (address =\\u003e uint256[]) divLocks;\\n\\n  mapping(uint256 =\\u003e uint256) totalAt;\\n  uint256 public totalSupply_ = 0;\\n\\n  modifier canBuyBack() {\\n    require(now \\u003e buyBackTime);\\n    _;\\n  }\\n\\n  modifier onlyLive() {\\n    require(!ended);\\n    _;\\n  }\\n\\n  constructor(uint256 _buyBackTime) public {\\n    buyBackTime = _buyBackTime;\\n  }\\n\\n  function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {\\n    require(period == 0);\\n    holdings[_to][0] = holdings[_to][0].add(_amount);\\n    totalAt[0] = totalAt[0].add(_amount);\\n    totalSupply_ = totalAt[0];\\n    return true;\\n  }\\n\\n  function totalSupply() public view returns (uint256) {\\n    return totalSupply_;\\n  }\\n\\n  function updateHoldings(address _holder) internal returns (bool success) {\\n    uint256 lastPeriod = last[_holder];\\n    uint256 lastAmount = holdings[_holder][lastPeriod];\\n    if(lastAmount != 0) {\\n      for (uint i = lastPeriod + 1; i \\u003c= period; i++) {\\n        holdings[_holder][i] = lastAmount;\\n      }\\n    }\\n    last[_holder] = period;\\n    return true;\\n  }\\n\\n  function updateHoldingsTo(address _holder, uint256 _to) public whenNotPaused returns (bool success){\\n    require(_to \\u003e last[_holder]);\\n    require(_to \\u003c= period);\\n    uint256 lastPeriod = last[_holder];\\n    uint256 lastAmount = holdings[_holder][lastPeriod];\\n    if(lastAmount != 0) {\\n      for (uint i = lastPeriod + 1; i \\u003c= _to; i++) {\\n        holdings[_holder][i] = lastAmount;\\n      }\\n    }\\n    last[_holder] = _to;\\n    return true;\\n  }\\n  \\n  function lockedAt(address _address, uint256 _period) public view returns (bool) {\\n    if(!beenDivLocked[_address]) {\\n      return false;\\n    }\\n    bool locked = false;\\n    for(uint i = 0; i \\u003c divLocks[_address].length; i++) {\\n      if(divLocks[_address][i] \\u003e _period) {\\n        break;\\n      } \\n      locked = !locked;\\n    }\\n    return locked;\\n  }\\n\\n  function addLock(address _locked) onlyOwner public returns (bool success) {\\n    require(!lockedAt(_locked, period));\\n    if (last[_locked] \\u003c period) {\\n      updateHoldings(_locked);\\n    }\\n    totalAt[period] = totalAt[period].sub(balanceOf(_locked));\\n    beenDivLocked[_locked] = true;\\n    divLocks[_locked].push(period);\\n    emit Locked(_locked, period);\\n    return true;\\n  }\\n\\n  function revokeLock(address _unlocked) onlyOwner public returns (bool success) {\\n    require(lockedAt(_unlocked, period));\\n    if (last[_unlocked] \\u003c period) {\\n      updateHoldings(_unlocked);\\n    }\\n    totalAt[period] = totalAt[period].add(balanceOf(_unlocked));\\n    divLocks[_unlocked].push(period);\\n    emit Unlocked(_unlocked, period);\\n    return true;\\n  }\\n\\n  function balanceOf(address _owner) public view returns (uint256 balance) {\\n    if(ended) {\\n      return 0;\\n    }\\n    return holdings[_owner][last[_owner]];\\n  }\\n\\n  function transfer(address _from, address _to, uint256 _value) onlyLive onlyOwner whenNotPaused public returns (bool) {\\n    require(_to != address(0));\\n    uint256 senderLastPeriod = last[_from];\\n    require(_value \\u003c= holdings[_from][senderLastPeriod]);\\n\\n    if (senderLastPeriod \\u003c period) {\\n      updateHoldings(_from);\\n    }\\n\\n    if (last[_to] \\u003c period) {\\n      updateHoldings(_to);\\n    }\\n\\n    holdings[_from][period] = holdings[_from][period].sub(_value);\\n    holdings[_to][period] = holdings[_to][period].add(_value);\\n    bool fromLocked = lockedAt(_from, period);\\n    bool toLocked = lockedAt(_to, period);\\n    if(fromLocked \\u0026\\u0026 !toLocked) {\\n      totalAt[period] = totalAt[period].add(_value);\\n    } else if(!fromLocked \\u0026\\u0026 toLocked) {\\n      totalAt[period] = totalAt[period].sub(_value);\\n    }\\n\\n    return true;\\n  }\\n\\n  function () public payable {\\n    payIn();\\n  }\\n\\n  function payIn() public payable onlyLive onlyOwner whenNotPaused returns (bool) {\\n    dividends[period] = msg.value;\\n    dividendDates[period] = now;\\n    period = period.add(1);\\n    totalAt[period] = totalAt[period.sub(1)];\\n    emit Paid(msg.sender, period.sub(1), msg.value);\\n    return true;\\n  }\\n  \\n  function claimDividends() whenNotPaused public returns (uint256 amount) {\\n    require(claimedTo[msg.sender] \\u003c period);\\n    uint256 total = 0;\\n    if (last[msg.sender] \\u003c period) {\\n      updateHoldings(msg.sender);\\n    }\\n    for (uint i = claimedTo[msg.sender]; i \\u003c period; i++) {\\n      if (holdings[msg.sender][i] \\u003e 0 \\u0026\\u0026 !lockedAt(msg.sender, i)) {\\n        uint256 multiplier = dividends[i].mul(holdings[msg.sender][i]);\\n        total += multiplier.div(totalAt[i]);\\n      }\\n    }\\n    claimedTo[msg.sender] = period;\\n    if(total \\u003e 0) {\\n      msg.sender.transfer(total);\\n      emit Claimed(msg.sender, i, total);\\n    }\\n    return total;\\n  }\\n\\n  function claimDividendsFor(address _address) onlyOwner public returns (uint256 amount) {\\n    require(claimedTo[_address] \\u003c period);\\n    uint256 total = 0;\\n    if (last[_address] \\u003c period) {\\n      updateHoldings(_address);\\n    }\\n    for (uint i = claimedTo[_address]; i \\u003c period; i++) {\\n      if (holdings[_address][i] \\u003e 0 \\u0026\\u0026 !lockedAt(_address, i)) {\\n        uint256 multiplier = dividends[i].mul(holdings[_address][i]);\\n        total += multiplier.div(totalAt[i]);\\n      }\\n    }\\n    claimedTo[_address] = period;\\n    if(total \\u003e 0) {\\n      _address.transfer(total);\\n      emit Claimed(_address, i, total);\\n    }\\n    return total;\\n  }\\n  \\n  function outstandingFor(address _address) public view returns (uint256 amount) {\\n    uint256 total = 0;\\n    uint256 holds = 0;\\n    for (uint i = claimedTo[_address]; i \\u003c period; i++) {\\n      if(last[_address] \\u003c i) {\\n        holds = holdings[_address][last[_address]];\\n      } else {\\n        holds = holdings[_address][i];\\n      }\\n      if (holds \\u003e 0 \\u0026\\u0026 !lockedAt(_address, i)) {\\n        uint256 multiplier = dividends[i].mul(holds);\\n        uint256 owed = multiplier.div(totalAt[i]);\\n        total += owed;\\n      }\\n    }\\n    return total;\\n  }\\n\\n  function outstanding() public view returns (uint256 amount) {\\n    uint256 total = 0;\\n    uint256 holds = 0;\\n    for (uint i = claimedTo[msg.sender]; i \\u003c period; i++) {\\n       if(last[msg.sender] \\u003c i) {\\n        holds = holdings[msg.sender][last[msg.sender]];\\n      } else {\\n        holds = holdings[msg.sender][i];\\n      }\\n      if (holds \\u003e 0 \\u0026\\u0026 !lockedAt(msg.sender, i)) {\\n        uint256 multiplier = dividends[i].mul(holds);\\n        uint256 owed = multiplier.div(totalAt[i]);\\n        total += owed;\\n      }      \\n    }\\n    return total;\\n  }\\n  \\n  function buyBack() public onlyOwner onlyLive canBuyBack payable returns (bool) {\\n    buyBackTotal = msg.value;\\n    period += 1;\\n    emit Paid(msg.sender, period - 1, msg.value);\\n    ended = true;\\n  }\\n\\n  function claimBuyBack() public returns (bool) {\\n    require(ended);\\n    require(!boughtBack[msg.sender]);\\n    if (last[msg.sender] \\u003c period) {\\n      updateHoldings(msg.sender);\\n    }\\n    uint256 multiplier = buyBackTotal.mul(holdings[msg.sender][period]);    \\n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\\n    boughtBack[msg.sender] = true;\\n    msg.sender.transfer(owed);\\n  }\\n\\n  function claimBuyBackFor(address _address) onlyOwner public returns (bool) {\\n    require(ended);\\n    require(!boughtBack[_address]);\\n    if (last[_address] \\u003c period) {\\n      updateHoldings(_address);\\n    }\\n    uint256 multiplier = buyBackTotal.mul(holdings[_address][period]);    \\n    uint256 owed = multiplier.div(totalAt[period.sub(1)]);\\n    boughtBack[_address] = true;\\n    _address.transfer(owed);\\n  }\\n\\n  function dividendDateHistory() public view returns (uint256[]) {\\n    uint256[] memory dates = new uint[](period);\\n    for(uint i = 0; i \\u003c period; i++) {\\n      dates[i] = dividendDates[i];\\n    }\\n    return dates;\\n  }\\n\\n  function dividendHistory() public view returns (uint256[]) {\\n    uint256[] memory divs = new uint[](period);\\n    for(uint i = 0; i \\u003c period; i++) {\\n      divs[i] = dividends[i];\\n    }\\n    return divs;\\n  }\\n\\n  function dividendHistoryFor(address _address) public view returns (uint256[]) {\\n    uint256[] memory divs = new uint[](period);\\n    for(uint i = 0; i \\u003c period; i++) {\\n      uint256 multiplier;\\n      if(last[_address] \\u003c i) {\\n        multiplier = dividends[i].mul(holdings[_address][i]);\\n      } else {\\n        multiplier = dividends[i].mul(holdings[_address][last[_address]]);\\n      }\\n      if(lockedAt(_address, i)) {\\n        divs[i] = 0;\\n      } else {\\n        divs[i] = multiplier.div(totalAt[i]);\\n      }\\n    }\\n    return divs;\\n  }\\n\\n  event Paid(address indexed _sender, uint256 indexed _period, uint256 amount);\\n\\n  event Claimed(address indexed _recipient, uint256 indexed _period, uint256 _amount);\\n\\n  event Locked(address indexed _locked, uint256 indexed _at);\\n\\n  event Unlocked(address indexed _unlocked, uint256 indexed _at);\\n}\\n\"},\"StandardToken.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./BasicToken.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * @dev https://github.com/ethereum/EIPs/issues/20\\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint256 the amount of tokens to be transferred\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    emit Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   *\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\n   */\\n  function allowance(\\n    address _owner,\\n    address _spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  /**\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\n   *\\n   * approve should be called when allowed[_spender] == 0. To increment\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _addedValue The amount of tokens to increase the allowance by.\\n   */\\n  function increaseApproval(\\n    address _spender,\\n    uint _addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    allowed[msg.sender][_spender] = (\\n      allowed[msg.sender][_spender].add(_addedValue));\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n   *\\n   * approve should be called when allowed[_spender] == 0. To decrement\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n   */\\n  function decreaseApproval(\\n    address _spender,\\n    uint _subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    uint oldValue = allowed[msg.sender][_spender];\\n    if (_subtractedValue \\u003e oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"transferStoreOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimBuyBack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminAddr\",\"type\":\"address\"}],\"name\":\"revokeAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimDividends\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"upgradeEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminAddr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"claimDividendsFor\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"store\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyBack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"revokeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canDestroy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_store\",\"type\":\"address\"}],\"name\":\"changeStore\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"claimBuyBackFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newStore\",\"type\":\"address\"}],\"name\":\"StoreChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"}],\"name\":\"AdminRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MoriaToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://14c3d6935a6afa2003b7aeead208a88fc95aa5cabe806f38d2cf2ca229cc7d1e"}]}