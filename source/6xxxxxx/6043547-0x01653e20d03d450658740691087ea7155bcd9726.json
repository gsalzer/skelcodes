{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface F3DexternalSettingsInterface {\r\n    function getFastGap() external returns(uint256);\r\n    function getLongGap() external returns(uint256);\r\n    function getFastExtra() external returns(uint256);\r\n    function getLongExtra() external returns(uint256);\r\n}\r\n\r\ninterface FundForwarderInterface {\r\n    function deposit() external payable returns(bool);\r\n    function status() external view returns(address, address, bool);\r\n    function startMigration(address _newCorpBank) external returns(bool);\r\n    function cancelMigration() external returns(bool);\r\n    function finishMigration() external returns(bool);\r\n    function setup(address _firstCorpBank) external;\r\n}\r\n\r\ninterface FundInterfaceForForwarder {\r\n    function deposit(address _addr) external payable returns (bool);\r\n    function migrationReceiver_setup() external returns (bool);\r\n}\r\n\r\ninterface HourglassInterface {\r\n    function() payable external;\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function sell(uint256 _amountOfTokens) external;\r\n    function reinvest() external;\r\n    function withdraw() external;\r\n    function exit() external;\r\n    function dividendsOf(address _playerAddress) external view returns(uint256);\r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n    function stakingRequirement() external view returns(uint256);\r\n}\r\n\r\ninterface otherFoMo3D {\r\n    function potSwap() external payable;\r\n}\r\n\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}\r\n\r\ninterface PlayerBookReceiverInterface {\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external;\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name) external;\r\n}\r\n\r\n\r\ninterface TeamInterface {\r\n    function requiredSignatures() external view returns(uint256);\r\n    function requiredDevSignatures() external view returns(uint256);\r\n    function adminCount() external view returns(uint256);\r\n    function devCount() external view returns(uint256);\r\n    function adminName(address _who) external view returns(bytes32);\r\n    function isAdmin(address _who) external view returns(bool);\r\n    function isDev(address _who) external view returns(bool);\r\n}\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary F3Ddatasets {\r\n    //compressedData key\r\n    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]\r\n        // 0 - new player (bool)\r\n        // 1 - joined round (bool)\r\n        // 2 - new  leader (bool)\r\n        // 3-5 - air drop tracker (uint 0-999)\r\n        // 6-16 - round end time\r\n        // 17 - winnerTeam\r\n        // 18 - 28 timestamp \r\n        // 29 - team\r\n        // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)\r\n        // 31 - airdrop happened bool\r\n        // 32 - airdrop tier \r\n        // 33 - airdrop amount won\r\n    //compressedIDs key\r\n    // [77-52][51-26][25-0]\r\n        // 0-25 - pID \r\n        // 26-51 - winPID\r\n        // 52-77 - rID\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 P3DAmount;          // amount distributed to p3d\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask \r\n        uint256 ico;    // ICO phase investment\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead， 幸运儿\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran  这个开关值得研究下\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n    }\r\n    \r\n    struct TeamFee {\r\n        uint256 gen;    // % of buy in thats paid to key holders of current round\r\n        uint256 p3d;    // % of buy in thats paid to p3d holders\r\n    }\r\n    struct PotSplit {\r\n        uint256 gen;    // % of pot thats paid to key holders of current round\r\n        uint256 p3d;    // % of pot thats paid to p3d holders\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n/** @title -MSFun- v0.2.4\r\n *  \r\n *         ┌──────────────────────────────────────────────────────────────────────┐\r\n *         │ MSFun, is an importable library that gives your contract the ability │\r\n *         │ add multiSig requirement to functions.                               │\r\n *         └──────────────────────────────────────────────────────────────────────┘\r\n *                                ┌────────────────────┐\r\n *                                │ Setup Instructions │\r\n *                                └────────────────────┘\r\n * (Step 1) import the library into your contract\r\n * \r\n *    import \"./MSFun.sol\";\r\n *\r\n * (Step 2) set up the signature data for msFun\r\n * \r\n *     MSFun.Data private msData;\r\n *                                ┌────────────────────┐\r\n *                                │ Usage Instructions │\r\n *                                └────────────────────┘\r\n * at the beginning of a function\r\n * \r\n *     function functionName() \r\n *     {\r\n *         if (MSFun.multiSig(msData, required signatures, \"functionName\") == true)\r\n *         {\r\n *             MSFun.deleteProposal(msData, \"functionName\");\r\n * \r\n *             // put function body here \r\n *         }\r\n *     }\r\n *                           ┌────────────────────────────────┐\r\n *                           │ Optional Wrappers For TeamJust │\r\n *                           └────────────────────────────────┘\r\n * multiSig wrapper function (cuts down on inputs, improves readability)\r\n * this wrapper is HIGHLY recommended\r\n * \r\n *     function multiSig(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredSignatures(), _whatFunction));}\r\n *     function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredDevSignatures(), _whatFunction));}\r\n *\r\n * wrapper for delete proposal (makes code cleaner)\r\n *     \r\n *     function deleteProposal(bytes32 _whatFunction) private {MSFun.deleteProposal(msData, _whatFunction);}\r\n *                             ┌────────────────────────────┐\r\n *                             │ Utility & Vanity Functions │\r\n *                             └────────────────────────────┘\r\n * delete any proposal is highly recommended.  without it, if an admin calls a multiSig\r\n * function, with argument inputs that the other admins do not agree upon, the function\r\n * can never be executed until the undesirable arguments are approved.\r\n * \r\n *     function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n * \r\n * for viewing who has signed a proposal & proposal data\r\n *     \r\n *     function checkData(bytes32 _whatFunction) onlyAdmins() public view returns(bytes32, uint256) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n *\r\n * lets you check address of up to 3 signers (address)\r\n * \r\n *     function checkSignersByAddress(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(address, address, address) {return(MSFun.checkSigner(msData, _whatFunction, _signerA), MSFun.checkSigner(msData, _whatFunction, _signerB), MSFun.checkSigner(msData, _whatFunction, _signerC));}\r\n *\r\n * same as above but will return names in string format.\r\n *\r\n *     function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(bytes32, bytes32, bytes32) {return(TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n *                             ┌──────────────────────────┐\r\n *                             │ Functions In Depth Guide │\r\n *                             └──────────────────────────┘\r\n * In the following examples, the Data is the proposal set for this library.  And\r\n * the bytes32 is the name of the function.\r\n *\r\n * MSFun.multiSig(Data, uint256, bytes32) - Manages creating/updating multiSig \r\n *      proposal for the function being called.  The uint256 is the required \r\n *      number of signatures needed before the multiSig will return true.  \r\n *      Upon first call, multiSig will create a proposal and store the arguments \r\n *      passed with the function call as msgData.  Any admins trying to sign the \r\n *      function call will need to send the same argument values. Once required\r\n *      number of signatures is reached this will return a bool of true.\r\n * \r\n * MSFun.deleteProposal(Data, bytes32) - once multiSig unlocks the function body,\r\n *      you will want to delete the proposal data.  This does that.\r\n *\r\n * MSFun.checkMsgData(Data, bytes32) - checks the message data for any given proposal \r\n * \r\n * MSFun.checkCount(Data, bytes32) - checks the number of admins that have signed\r\n *      the proposal \r\n * \r\n * MSFun.checkSigners(data, bytes32, uint256) - checks the address of a given signer.\r\n *      the uint256, is the log number of the signer (ie 1st signer, 2nd signer)\r\n */\r\n\r\nlibrary MSFun {\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DATA SETS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // contact data setup\r\n    struct Data \r\n    {\r\n        mapping (bytes32 => ProposalData) proposal_;  \r\n    }\r\n    struct ProposalData \r\n    {\r\n        // a hash of msg.data \r\n        bytes32 msgData;\r\n        // number of signers\r\n        uint256 count;\r\n        // tracking of wither admins have signed\r\n        mapping (address => bool) admin;\r\n        // list of admins who have signed\r\n        mapping (uint256 => address) log;\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MULTI SIG FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function multiSig(Data storage self, uint256 _requiredSignatures, bytes32 _whatFunction)\r\n        internal\r\n        returns(bool) \r\n    {\r\n        // our proposal key will be a hash of our function name + our contracts address \r\n        // by adding our contracts address to this, we prevent anyone trying to circumvent\r\n        // the proposal's security via external calls.\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        \r\n        // this is just done to make the code more readable.  grabs the signature count\r\n        uint256 _currentCount = self.proposal_[_whatProposal].count;\r\n        \r\n        // store the address of the person sending the function call.  we use msg.sender \r\n        // here as a layer of security.  in case someone imports our contract and tries to \r\n        // circumvent function arguments.  still though, our contract that imports this\r\n        // library and calls multisig, needs to use onlyAdmin modifiers or anyone who\r\n        // calls the function will be a signer. \r\n        address _whichAdmin = msg.sender;\r\n        \r\n        // prepare our msg data.  by storing this we are able to verify that all admins\r\n        // are approving the same argument input to be executed for the function.  we hash \r\n        // it and store in bytes32 so its size is known and comparable\r\n        bytes32 _msgData = keccak256(msg.data);\r\n        \r\n        // check to see if this is a new execution of this proposal or not\r\n        if (_currentCount == 0)\r\n        {\r\n            // if it is, lets record the original signers data\r\n            self.proposal_[_whatProposal].msgData = _msgData;\r\n            \r\n            // record original senders signature\r\n            self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n            \r\n            // update log (used to delete records later, and easy way to view signers)\r\n            // also useful if the calling function wants to give something to a \r\n            // specific signer.  \r\n            self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n            \r\n            // track number of signatures\r\n            self.proposal_[_whatProposal].count += 1;  \r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.  we put this here in case the required signatures\r\n            // is set to 1.\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }            \r\n        // if its not the first execution, lets make sure the msgData matches\r\n        } else if (self.proposal_[_whatProposal].msgData == _msgData) {\r\n            // msgData is a match\r\n            // make sure admin hasnt already signed\r\n            if (self.proposal_[_whatProposal].admin[_whichAdmin] == false) \r\n            {\r\n                // record their signature\r\n                self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n                \r\n                // update log (used to delete records later, and easy way to view signers)\r\n                self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n                \r\n                // track number of signatures\r\n                self.proposal_[_whatProposal].count += 1;  \r\n            }\r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.\r\n            // we put this here for a few reasons.  (1) in normal operation, if \r\n            // that last recorded signature got us to our required signatures.  we \r\n            // need to return bool of true.  (2) if we have a situation where the \r\n            // required number of signatures was adjusted to at or lower than our current \r\n            // signature count, by putting this here, an admin who has already signed,\r\n            // can call the function again to make it return a true bool.  but only if\r\n            // they submit the correct msg data\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    // deletes proposal signature data after successfully executing a multiSig function\r\n    function deleteProposal(Data storage self, bytes32 _whatFunction)\r\n        internal\r\n    {\r\n        //done for readability sake\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        address _whichAdmin;\r\n        \r\n        //delete the admins votes & log.   i know for loops are terrible.  but we have to do this \r\n        //for our data stored in mappings.  simply deleting the proposal itself wouldn't accomplish this.\r\n        for (uint256 i=0; i < self.proposal_[_whatProposal].count; i++) {\r\n            _whichAdmin = self.proposal_[_whatProposal].log[i];\r\n            delete self.proposal_[_whatProposal].admin[_whichAdmin];\r\n            delete self.proposal_[_whatProposal].log[i];\r\n        }\r\n        //delete the rest of the data in the record\r\n        delete self.proposal_[_whatProposal];\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // HELPER FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n    function whatProposal(bytes32 _whatFunction)\r\n        private\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return(keccak256(abi.encodePacked(_whatFunction,this)));\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // VANITY FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // returns a hashed version of msg.data sent by original signer for any given function\r\n    function checkMsgData (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (bytes32 msg_data)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].msgData);\r\n    }\r\n    \r\n    // returns number of signers for any given function\r\n    function checkCount (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (uint256 signature_count)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].count);\r\n    }\r\n    \r\n    // returns address of an admin who signed for any given function\r\n    function checkSigner (Data storage self, bytes32 _whatFunction, uint256 _signer)\r\n        internal\r\n        view\r\n        returns (address signer)\r\n    {\r\n        require(_signer > 0, \"MSFun checkSigner failed - 0 not allowed\");\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].log[_signer - 1]);\r\n    }\r\n}\r\n\r\n\r\n//==============================================================================\r\n//  |  _      _ _ | _  .\r\n//  |<(/_\\/  (_(_||(_  .\r\n//=======/======================================================================\r\nlibrary F3DKeysCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\nlibrary UintCompressor {\r\n    using SafeMath for *;\r\n    \r\n    function insert(uint256 _var, uint256 _include, uint256 _start, uint256 _end)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // check conditions \r\n        require(_end < 77 && _start < 77, \"start/end must be less than 77\");\r\n        require(_end >= _start, \"end must be >= start\");\r\n        \r\n        // format our start/end points\r\n        _end = exponent(_end).mul(10);\r\n        _start = exponent(_start);\r\n        \r\n        // check that the include data fits into its segment \r\n        require(_include < (_end / _start));\r\n        \r\n        // build middle\r\n        if (_include > 0)\r\n            _include = _include.mul(_start);\r\n        \r\n        return((_var.sub((_var / _start).mul(_start))).add(_include).add((_var / _end).mul(_end)));\r\n    }\r\n    \r\n    function extract(uint256 _input, uint256 _start, uint256 _end)\r\n\t    internal\r\n\t    pure\r\n\t    returns(uint256)\r\n    {\r\n        // check conditions\r\n        require(_end < 77 && _start < 77, \"start/end must be less than 77\");\r\n        require(_end >= _start, \"end must be >= start\");\r\n        \r\n        // format our start/end points\r\n        _end = exponent(_end).mul(10);\r\n        _start = exponent(_start);\r\n        \r\n        // return requested section\r\n        return((((_input / _start).mul(_start)).sub((_input / _end).mul(_end))) / _start);\r\n    }\r\n    \r\n    function exponent(uint256 _position)\r\n        private\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return((10).pwr(_position));\r\n    }\r\n}\r\n\r\ncontract F3Devents {\r\n    // fired whenever a player registers a name\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired at end of buy or reload\r\n    event onEndTx\r\n    (\r\n        uint256 compressedData,     \r\n        uint256 compressedIDs,      \r\n        bytes32 playerName,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount,\r\n        uint256 potAmount,\r\n        uint256 airDropPot\r\n    );\r\n    \r\n\t// fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a withdraw forces end round to be ran\r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // (fomo3d long only) fired whenever a player tries a buy after round timer \r\n    // hit zero, and causes end round to be ran.\r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethIn,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // (fomo3d long only) fired whenever a player tries a reload after round timer \r\n    // hit zero, and causes end round to be ran.\r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // fired whenever an affiliate is paid\r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // received pot swap deposit\r\n    event onPotSwapDeposit\r\n    (\r\n        uint256 roundID,\r\n        uint256 amountAddedToPot\r\n    );\r\n}\r\n\r\n\r\ncontract FundForwarder {\r\n    string public name = \"FundForwarder\";\r\n    FundInterfaceForForwarder private currentCorpBank_;\r\n    address private newCorpBank_;\r\n    bool needsBank_ = true;\r\n    \r\n    constructor() \r\n        public\r\n    {\r\n        //constructor does nothing.\r\n    }\r\n    \r\n    function()\r\n        public\r\n        payable\r\n    {\r\n        // done so that if any one tries to dump eth into this contract, we can\r\n        // just forward it to corp bank.\r\n        currentCorpBank_.deposit.value(address(this).balance)(address(currentCorpBank_));\r\n    }\r\n    \r\n    function deposit()\r\n        public \r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(msg.value > 0, \"Forwarder Deposit failed - zero deposits not allowed\");\r\n        require(needsBank_ == false, \"Forwarder Deposit failed - no registered bank\");\r\n        //wallet.transfer(toFund);\r\n        if (currentCorpBank_.deposit.value(msg.value)(msg.sender) == true)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n//==============================================================================\r\n//     _ _ . _  _ _ _|_. _  _   .\r\n//    | | ||(_|| (_| | |(_)| |  .\r\n//===========_|=================================================================    \r\n    function status()\r\n        public\r\n        view\r\n        returns(address, address, bool)\r\n    {\r\n        return(address(currentCorpBank_), address(newCorpBank_), needsBank_);\r\n    }\r\n\r\n    function startMigration(address _newCorpBank)\r\n        external\r\n        returns(bool)\r\n    {\r\n        // make sure this is coming from current corp bank\r\n        require(msg.sender == address(currentCorpBank_), \"Forwarder startMigration failed - msg.sender must be current corp bank\");\r\n        \r\n        // communicate with the new corp bank and make sure it has the forwarder \r\n        // registered \r\n        if(FundInterfaceForForwarder(_newCorpBank).migrationReceiver_setup() == true)\r\n        {\r\n            // save our new corp bank address\r\n            newCorpBank_ = _newCorpBank;\r\n            return (true);\r\n        } else \r\n            return (false);\r\n    }\r\n    \r\n    function cancelMigration()\r\n        external\r\n        returns(bool)\r\n    {\r\n        // make sure this is coming from the current corp bank (also lets us know \r\n        // that current corp bank has not been killed)\r\n        require(msg.sender == address(currentCorpBank_), \"Forwarder cancelMigration failed - msg.sender must be current corp bank\");\r\n        \r\n        // erase stored new corp bank address;\r\n        newCorpBank_ = address(0x0);\r\n        \r\n        return (true);\r\n    }\r\n    \r\n    function finishMigration()\r\n        external\r\n        returns(bool)\r\n    {\r\n        // make sure its coming from new corp bank\r\n        require(msg.sender == newCorpBank_, \"Forwarder finishMigration failed - msg.sender must be new corp bank\");\r\n\r\n        // update corp bank address        \r\n        currentCorpBank_ = (FundInterfaceForForwarder(newCorpBank_));\r\n        \r\n        // erase new corp bank address\r\n        newCorpBank_ = address(0x0);\r\n        \r\n        return (true);\r\n    }\r\n//==============================================================================\r\n//    . _ ._|_. _ |   _ _ _|_    _   .\r\n//    || || | |(_||  _\\(/_ | |_||_)  .  (this only runs once ever)\r\n//==============================|===============================================\r\n    function setup(address _firstCorpBank)\r\n        external\r\n    {\r\n        require(needsBank_ == true, \"Forwarder setup failed - corp bank already registered\");\r\n        currentCorpBank_ = FundInterfaceForForwarder(_firstCorpBank);\r\n        needsBank_ = false;\r\n    }\r\n}\r\n\r\ncontract ModularLong is F3Devents {}\r\n\r\n\r\ncontract PlayerBook {\r\n    using NameFilter for string;\r\n    using SafeMath for uint256;\r\n\r\n    address constant private DEV_1_ADDRESS = 0x7a9E13E044CB905957eA465488DabD5F5D34E2C4;\r\n    bytes32  constant private DEV_1_NAME = \"master\";\r\n\r\n    \r\n    FundForwarderInterface constant private FundForwarderConst = FundForwarderInterface(0x5095072aEE46a39D0b3753184514ead86405780f);\r\n    TeamInterface constant private TeamJust = TeamInterface(0xf72848D3426d8dB71e52FAc6Df29585649bb7CBD);\r\n    \r\n    MSFun.Data private msData;\r\n\r\n    function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredDevSignatures(), _whatFunction));}\r\n    function deleteProposal(bytes32 _whatFunction) private {MSFun.deleteProposal(msData, _whatFunction);}\r\n    function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n    function checkData(bytes32 _whatFunction) onlyDevs() public view returns(bytes32, uint256) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n    function checkSignersByAddress(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyDevs() public view returns(address, address, address) {return(MSFun.checkSigner(msData, _whatFunction, _signerA), MSFun.checkSigner(msData, _whatFunction, _signerB), MSFun.checkSigner(msData, _whatFunction, _signerC));}\r\n    function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyDevs() public view returns(bytes32, bytes32, bytes32) {return(TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .\r\n//=============================|================================================    \r\n    uint256 public registrationFee_ = 10 finney;            // price to register a name\r\n\r\n    // game 需要实现PlayerBookReceiverInterface的接口\r\n    mapping(uint256 => PlayerBookReceiverInterface) public games_;  // mapping of our game interfaces for sending your account info to games\r\n    mapping(address => bytes32) public gameNames_;          // lookup a games name\r\n    mapping(address => uint256) public gameIDs_;            // lokup a games ID\r\n    uint256 public gID_;        // total number of games\r\n    uint256 public pID_;        // total number of players\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => Player) public plyr_;               // (pID => data) player data\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amoungst any name you own)\r\n    mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; // (pID => nameNum => name) list of names a player owns\r\n    struct Player {\r\n        address addr;\r\n        bytes32 name;\r\n        uint256 laff;\r\n        uint256 names;\r\n    }\r\n//==============================================================================\r\n//     _ _  _  __|_ _    __|_ _  _  .\r\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n//==============================================================================    \r\n    constructor()\r\n        public\r\n    {\r\n        // premine the dev names (sorry not sorry)\r\n        // No keys are purchased with this method, it's simply locking our addresses,\r\n        // PID's and names for referral codes.\r\n        plyr_[1].addr = DEV_1_ADDRESS;\r\n        plyr_[1].name = DEV_1_NAME;\r\n        plyr_[1].names = 1;\r\n        pIDxAddr_[DEV_1_ADDRESS] = 1;\r\n        pIDxName_[DEV_1_NAME] = 1;\r\n        plyrNames_[1][DEV_1_NAME] = true;\r\n        plyrNameList_[1][1] = DEV_1_NAME;\r\n        \r\n        pID_ = 1;\r\n    }\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================    \r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDevs() \r\n    {\r\n        require(TeamJust.isDev(msg.sender) == true, \"msg sender is not a dev\");\r\n        _;\r\n    }\r\n    \r\n    modifier isRegisteredGame()\r\n    {\r\n        require(gameIDs_[msg.sender] != 0);\r\n        _;\r\n    }\r\n//==============================================================================\r\n//     _    _  _ _|_ _  .\r\n//    (/_\\/(/_| | | _\\  .\r\n//==============================================================================    \r\n    // fired whenever a player registers a name\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n//==============================================================================\r\n//     _  _ _|__|_ _  _ _  .\r\n//    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n//=====_|=======================================================================\r\n    function checkIfNameValid(string _nameStr)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        bytes32 _name = _nameStr.nameFilter();\r\n        if (pIDxName_[_name] == 0)\r\n            return (true);\r\n        else \r\n            return (false);\r\n    }\r\n//==============================================================================\r\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n//====|=========================================================================    \r\n    /**\r\n     * @dev registers a name.  UI will always display the last name you registered.\r\n     * but you will still own all previously registered names to use as affiliate \r\n     * links.\r\n     * - must pay a registration fee.\r\n     * - name must be unique\r\n     * - names will be converted to lowercase\r\n     * - name cannot start or end with a space \r\n     * - cannot have more than 1 space in a row\r\n     * - cannot be only numbers\r\n     * - cannot start with 0x \r\n     * - name must be at least 1 char\r\n     * - max length of 32 characters long\r\n     * - allowed characters: a-z, 0-9, and space\r\n     * -functionhash- 0x921dec21 (using ID for affiliate)\r\n     * -functionhash- 0x3ddd4698 (using address for affiliate)\r\n     * -functionhash- 0x685ffd83 (using name for affiliate)\r\n     * @param _nameString players desired name\r\n     * @param _affCode affiliate ID, address, or name of who refered you\r\n     * @param _all set to true if you want this to push your info to all games \r\n     * (this might cost a lot of gas)\r\n     */\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable \r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        \r\n        // set up address \r\n        address _addr = msg.sender;\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the \r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        if (_affCode != 0 && _affCode != plyr_[_pID].laff && _affCode != _pID) \r\n        {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        } else if (_affCode == _pID) {\r\n            _affCode = 0;\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affCode, _name, _isNewPlayer, _all);\r\n    }\r\n    \r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable \r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        \r\n        // set up address \r\n        address _addr = msg.sender;\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != address(0) && _affCode != _addr)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n    }\r\n    \r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable \r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        \r\n        // set up address \r\n        address _addr = msg.sender;\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != \"\" && _affCode != _name)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n    }\r\n    \r\n    /**\r\n     * @dev players, if you registered a profile, before a game was released, or\r\n     * set the all bool to false when you registered, use this function to push\r\n     * your profile to a single game.  also, if you've  updated your name, you\r\n     * can use this to push your name to games of your choosing.\r\n     * -functionhash- 0x81c5b206\r\n     * @param _gameID game id \r\n     */\r\n    function addMeToGame(uint256 _gameID)\r\n        isHuman()\r\n        public\r\n    {\r\n        require(_gameID <= gID_, \"silly player, that game doesn't exist yet\");\r\n        address _addr = msg.sender;\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        require(_pID != 0, \"hey there buddy, you dont even have an account\");\r\n        uint256 _totalNames = plyr_[_pID].names;\r\n        \r\n        // add players profile and most recent name\r\n        games_[_gameID].receivePlayerInfo(_pID, _addr, plyr_[_pID].name, plyr_[_pID].laff);\r\n        \r\n        // add list of all names\r\n        if (_totalNames > 1)\r\n            for (uint256 ii = 1; ii <= _totalNames; ii++)\r\n                games_[_gameID].receivePlayerNameList(_pID, plyrNameList_[_pID][ii]);\r\n    }\r\n    \r\n    /**\r\n     * @dev players, use this to push your player profile to all registered games.\r\n     * -functionhash- 0x0c6940ea\r\n     */\r\n    function addMeToAllGames()\r\n        isHuman()\r\n        public\r\n    {\r\n        address _addr = msg.sender;\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        require(_pID != 0, \"hey there buddy, you dont even have an account\");\r\n        uint256 _laff = plyr_[_pID].laff;\r\n        uint256 _totalNames = plyr_[_pID].names;\r\n        bytes32 _name = plyr_[_pID].name;\r\n        \r\n        for (uint256 i = 1; i <= gID_; i++)\r\n        {\r\n            games_[i].receivePlayerInfo(_pID, _addr, _name, _laff);\r\n            if (_totalNames > 1)\r\n                for (uint256 ii = 1; ii <= _totalNames; ii++)\r\n                    games_[i].receivePlayerNameList(_pID, plyrNameList_[_pID][ii]);\r\n        }\r\n                \r\n    }\r\n    \r\n    /**\r\n     * @dev players use this to change back to one of your old names.  tip, you'll\r\n     * still need to push that info to existing games.\r\n     * -functionhash- 0xb9291296\r\n     * @param _nameString the name you want to use \r\n     */\r\n    function useMyOldName(string _nameString)\r\n        isHuman()\r\n        public \r\n    {\r\n        // filter name, and get pID\r\n        bytes32 _name = _nameString.nameFilter();\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // make sure they own the name \r\n        require(plyrNames_[_pID][_name] == true, \"umm... thats not a name you own\");\r\n        \r\n        // update their current name \r\n        plyr_[_pID].name = _name;\r\n    }\r\n    \r\n//==============================================================================\r\n//     _ _  _ _   | _  _ . _  .\r\n//    (_(_)| (/_  |(_)(_||(_  . \r\n//=====================_|=======================================================    \r\n    function registerNameCore(uint256 _pID, address _addr, uint256 _affID, bytes32 _name, bool _isNewPlayer, bool _all)\r\n        private\r\n    {\r\n        // if names already has been used, require that current msg sender owns the name\r\n        if (pIDxName_[_name] != 0)\r\n            require(plyrNames_[_pID][_name] == true, \"sorry that names already taken\");\r\n        \r\n        // add name to player profile, registry, and name book\r\n        plyr_[_pID].name = _name;\r\n        pIDxName_[_name] = _pID;\r\n        if (plyrNames_[_pID][_name] == false)\r\n        {\r\n            plyrNames_[_pID][_name] = true;\r\n            plyr_[_pID].names++;\r\n            plyrNameList_[_pID][plyr_[_pID].names] = _name;\r\n        }\r\n        \r\n        // registration fee goes directly to community rewards\r\n        FundForwarderConst.deposit.value(address(this).balance)();\r\n        \r\n        // push player info to games\r\n        if (_all == true)\r\n            for (uint256 i = 1; i <= gID_; i++)\r\n                games_[i].receivePlayerInfo(_pID, _addr, _name, _affID);\r\n        \r\n        // fire event\r\n        emit onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, msg.value, now);\r\n    }\r\n//==============================================================================\r\n//    _|_ _  _ | _  .\r\n//     | (_)(_)|_\\  .\r\n//==============================================================================    \r\n    function determinePID(address _addr)\r\n        private\r\n        returns (bool)\r\n    {\r\n        if (pIDxAddr_[_addr] == 0)\r\n        {\r\n            pID_++;\r\n            pIDxAddr_[_addr] = pID_;\r\n            plyr_[pID_].addr = _addr;\r\n            \r\n            // set the new player bool to true\r\n            return (true);\r\n        } else {\r\n            return (false);\r\n        }\r\n    }\r\n//==============================================================================\r\n//   _   _|_ _  _ _  _ |   _ _ || _  .\r\n//  (/_>< | (/_| | |(_||  (_(_|||_\\  .\r\n//==============================================================================\r\n    function getPlayerID(address _addr)\r\n        isRegisteredGame()\r\n        external\r\n        returns (uint256)\r\n    {\r\n        determinePID(_addr);\r\n        return (pIDxAddr_[_addr]);\r\n    }\r\n    function getPlayerName(uint256 _pID)\r\n        external\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return (plyr_[_pID].name);\r\n    }\r\n    function getPlayerLAff(uint256 _pID)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (plyr_[_pID].laff);\r\n    }\r\n    function getPlayerAddr(uint256 _pID)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return (plyr_[_pID].addr);\r\n    }\r\n    function getNameFee()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return(registrationFee_);\r\n    }\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all)\r\n        isRegisteredGame()\r\n        external\r\n        payable\r\n        returns(bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the \r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        uint256 _affID = _affCode;\r\n        if (_affID != 0 && _affID != plyr_[_pID].laff && _affID != _pID) \r\n        {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affID;\r\n        } else if (_affID == _pID) {\r\n            _affID = 0;\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n        \r\n        return(_isNewPlayer, _affID);\r\n    }\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all)\r\n        isRegisteredGame()\r\n        external\r\n        payable\r\n        returns(bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != address(0) && _affCode != _addr)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n        \r\n        return(_isNewPlayer, _affID);\r\n    }\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all)\r\n        isRegisteredGame()\r\n        external\r\n        payable\r\n        returns(bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != \"\" && _affCode != _name)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n        \r\n        return(_isNewPlayer, _affID);\r\n    }\r\n    \r\n//==============================================================================\r\n//   _ _ _|_    _   .\r\n//  _\\(/_ | |_||_)  .\r\n//=============|================================================================\r\n    function addGame(address _gameAddress, string _gameNameStr)\r\n        onlyDevs()\r\n        public\r\n    {\r\n        require(gameIDs_[_gameAddress] == 0, \"derp, that games already been registered\");\r\n        \r\n        if (multiSigDev(\"addGame\") == true)\r\n        {\r\n            deleteProposal(\"addGame\");\r\n            gID_++;\r\n            bytes32 _name = _gameNameStr.nameFilter();\r\n            gameIDs_[_gameAddress] = gID_;\r\n            gameNames_[_gameAddress] = _name;\r\n            games_[gID_] = PlayerBookReceiverInterface(_gameAddress);\r\n        \r\n            games_[gID_].receivePlayerInfo(1, plyr_[1].addr, plyr_[1].name, 0);\r\n            games_[gID_].receivePlayerInfo(2, plyr_[2].addr, plyr_[2].name, 0);\r\n            games_[gID_].receivePlayerInfo(3, plyr_[3].addr, plyr_[3].name, 0);\r\n            games_[gID_].receivePlayerInfo(4, plyr_[4].addr, plyr_[4].name, 0);\r\n        }\r\n    }\r\n    \r\n    function setRegistrationFee(uint256 _fee)\r\n        onlyDevs()\r\n        public\r\n    {\r\n        if (multiSigDev(\"setRegistrationFee\") == true)\r\n        {deleteProposal(\"setRegistrationFee\");\r\n            registrationFee_ = _fee;\r\n        }\r\n    }\r\n        \r\n}\r\n\r\ncontract Team {\r\n\r\n    // set dev1\r\n    address constant private DEV_1_ADDRESS = 0x7a9E13E044CB905957eA465488DabD5F5D34E2C4;\r\n    bytes32  constant private DEV_1_NAME = \"master\";\r\n\r\n\r\n    FundForwarderInterface private FundForwarderTeam = FundForwarderInterface(0x0);\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // SET UP MSFun (note, check signers by name is modified from MSFun sdk)\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    MSFun.Data private msData;\r\n    function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n    function checkData(bytes32 _whatFunction) onlyAdmins() public view returns(bytes32 message_data, uint256 signature_count) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n    function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(bytes32, bytes32, bytes32) {return(this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DATA SETUP\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    struct Admin {\r\n        bool isAdmin;\r\n        bool isDev;\r\n        bytes32 name;\r\n    }\r\n    mapping (address => Admin) admins_;\r\n    \r\n    uint256 adminCount_;\r\n    uint256 devCount_;\r\n    uint256 requiredSignatures_;\r\n    uint256 requiredDevSignatures_;\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // CONSTRUCTOR\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    constructor()\r\n        public\r\n    {\r\n    \r\n        admins_[DEV_1_ADDRESS] = Admin(true, true, DEV_1_NAME);\r\n        \r\n        adminCount_ = 1;\r\n        devCount_ = 1;\r\n        requiredSignatures_ = 1;\r\n        requiredDevSignatures_ = 1;\r\n    }\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // FALLBACK, SETUP, AND FORWARD\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // there should never be a balance in this contract.  but if someone\r\n    // does stupidly send eth here for some reason.  we can forward it \r\n    // to jekyll island\r\n    function ()\r\n        public\r\n        payable\r\n    {\r\n        FundForwarderTeam.deposit.value(address(this).balance)();\r\n    }\r\n    \r\n    function setup(address _addr)\r\n        onlyDevs()\r\n        public\r\n    {\r\n        require( address(FundForwarderTeam) == address(0) );\r\n        FundForwarderTeam = FundForwarderInterface(_addr);\r\n    }    \r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MODIFIERS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    modifier onlyDevs()\r\n    {\r\n        require(admins_[msg.sender].isDev == true, \"onlyDevs failed - msg.sender is not a dev\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyAdmins()\r\n    {\r\n        require(admins_[msg.sender].isAdmin == true, \"onlyAdmins failed - msg.sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DEV ONLY FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    /**\r\n    * @dev DEV - use this to add admins.  this is a dev only function.\r\n    * @param _who - address of the admin you wish to add\r\n    * @param _name - admins name\r\n    * @param _isDev - is this admin also a dev?\r\n    */\r\n    function addAdmin(address _who, bytes32 _name, bool _isDev)\r\n        public\r\n        onlyDevs()\r\n    {\r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"addAdmin\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"addAdmin\");\r\n            \r\n            // must check this so we dont mess up admin count by adding someone\r\n            // who is already an admin\r\n            if (admins_[_who].isAdmin == false) \r\n            { \r\n                \r\n                // set admins flag to true in admin mapping\r\n                admins_[_who].isAdmin = true;\r\n        \r\n                // adjust admin count and required signatures\r\n                adminCount_ += 1;\r\n                requiredSignatures_ += 1;\r\n            }\r\n            \r\n            // are we setting them as a dev?\r\n            // by putting this outside the above if statement, we can upgrade existing\r\n            // admins to devs.\r\n            if (_isDev == true) \r\n            {\r\n                // bestow the honored dev status\r\n                admins_[_who].isDev = _isDev;\r\n                \r\n                // increase dev count and required dev signatures\r\n                devCount_ += 1;\r\n                requiredDevSignatures_ += 1;\r\n            }\r\n        }\r\n        \r\n        // by putting this outside the above multisig, we can allow easy name changes\r\n        // without having to bother with multisig.  this will still create a proposal though\r\n        // so use the deleteAnyProposal to delete it if you want to\r\n        admins_[_who].name = _name;\r\n    }\r\n\r\n    /**\r\n    * @dev DEV - use this to remove admins. this is a dev only function.\r\n    * -requirements: never less than 1 admin\r\n    *                never less than 1 dev\r\n    *                never less admins than required signatures\r\n    *                never less devs than required dev signatures\r\n    * @param _who - address of the admin you wish to remove\r\n    */\r\n    function removeAdmin(address _who)\r\n        public\r\n        onlyDevs()\r\n    {\r\n        // we can put our requires outside the multisig, this will prevent\r\n        // creating a proposal that would never pass checks anyway.\r\n        require(adminCount_ > 1, \"removeAdmin failed - cannot have less than 2 admins\");\r\n        require(adminCount_ >= requiredSignatures_, \"removeAdmin failed - cannot have less admins than number of required signatures\");\r\n        if (admins_[_who].isDev == true)\r\n        {\r\n            require(devCount_ > 1, \"removeAdmin failed - cannot have less than 2 devs\");\r\n            require(devCount_ >= requiredDevSignatures_, \"removeAdmin failed - cannot have less devs than number of required dev signatures\");\r\n        }\r\n        \r\n        // checks passed\r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"removeAdmin\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"removeAdmin\");\r\n            \r\n            // must check this so we dont mess up admin count by removing someone\r\n            // who wasnt an admin to start with\r\n            if (admins_[_who].isAdmin == true) {  \r\n                \r\n                //set admins flag to false in admin mapping\r\n                admins_[_who].isAdmin = false;\r\n                \r\n                //adjust admin count and required signatures\r\n                adminCount_ -= 1;\r\n                if (requiredSignatures_ > 1) \r\n                {\r\n                    requiredSignatures_ -= 1;\r\n                }\r\n            }\r\n            \r\n            // were they also a dev?\r\n            if (admins_[_who].isDev == true) {\r\n                \r\n                //set dev flag to false\r\n                admins_[_who].isDev = false;\r\n                \r\n                //adjust dev count and required dev signatures\r\n                devCount_ -= 1;\r\n                if (requiredDevSignatures_ > 1) \r\n                {\r\n                    requiredDevSignatures_ -= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev DEV - change the number of required signatures.  must be between\r\n    * 1 and the number of admins.  this is a dev only function\r\n    * @param _howMany - desired number of required signatures\r\n    */\r\n    function changeRequiredSignatures(uint256 _howMany)\r\n        public\r\n        onlyDevs()\r\n    {  \r\n        // make sure its between 1 and number of admins\r\n        require(_howMany > 0 && _howMany <= adminCount_, \"changeRequiredSignatures failed - must be between 1 and number of admins\");\r\n        \r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"changeRequiredSignatures\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"changeRequiredSignatures\");\r\n            \r\n            // store new setting.\r\n            requiredSignatures_ = _howMany;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev DEV - change the number of required dev signatures.  must be between\r\n    * 1 and the number of devs.  this is a dev only function\r\n    * @param _howMany - desired number of required dev signatures\r\n    */\r\n    function changeRequiredDevSignatures(uint256 _howMany)\r\n        public\r\n        onlyDevs()\r\n    {  \r\n        // make sure its between 1 and number of admins\r\n        require(_howMany > 0 && _howMany <= devCount_, \"changeRequiredDevSignatures failed - must be between 1 and number of devs\");\r\n        \r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"changeRequiredDevSignatures\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"changeRequiredDevSignatures\");\r\n            \r\n            // store new setting.\r\n            requiredDevSignatures_ = _howMany;\r\n        }\r\n    }\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // EXTERNAL FUNCTIONS \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function requiredSignatures() external view returns(uint256) {return(requiredSignatures_);}\r\n    function requiredDevSignatures() external view returns(uint256) {return(requiredDevSignatures_);}\r\n    function adminCount() external view returns(uint256) {return(adminCount_);}\r\n    function devCount() external view returns(uint256) {return(devCount_);}\r\n    function adminName(address _who) external view returns(bytes32) {return(admins_[_who].name);}\r\n    function isAdmin(address _who) external view returns(bool) {return(admins_[_who].isAdmin);}\r\n    function isDev(address _who) external view returns(bool) {return(admins_[_who].isDev);}\r\n}\r\n\r\n\r\ncontract FoMo3DlongUnlimited is ModularLong {\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n    using F3DKeysCalcLong for uint256;\r\n\r\n    address constant private DEV_1_ADDRESS = 0x7a9E13E044CB905957eA465488DabD5F5D34E2C4;\r\n\t\r\n    otherFoMo3D private otherF3D_;\r\n    FundForwarderInterface constant private FundForwarderMain = FundForwarderInterface(0x5095072aEE46a39D0b3753184514ead86405780f);\r\n    PlayerBookInterface constant private PlayerBookMain = PlayerBookInterface(0xf72848D3426d8dB71e52FAc6Df29585649bb7CBD);\r\n    \r\n    bool public activated_ = false;\r\n//==============================================================================\r\n//     _ _  _  |`. _     _ _ |_ | _  _  .\r\n//    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\r\n//=================_|===========================================================\r\n    string constant public name = \"Fomo3D Long Unlimited\";\r\n    string constant public symbol = \"F3DLong\";\r\n    uint256 private rndExtra_ =  10 minutes; //extSettings.getLongExtra();     // length of the very first ICO \r\n    uint256 private rndGap_ =   10 minutes; //extSettings.getLongGap();         // length of ICO phase, set to 1 year for EOS.\r\n    uint256 constant private rndInit_ = 1 hours;                // round timer starts at this\r\n    uint256 constant private rndInc_ = 0 seconds;              // every full key purchased adds this much to the timer\r\n    uint256 constant private rndMax_ = 2 hours;                // max length a round timer can be\r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes)\r\n//=============================|================================================\r\n    uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot\r\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n//****************\r\n// PLAYER DATA \r\n//****************\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => F3Ddatasets.Player) public plyr_;   // (pID => data) player data\r\n    mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\r\n    //一个用户可以有多个名字\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own)\r\n//****************\r\n// ROUND DATA \r\n//****************\r\n    mapping (uint256 => F3Ddatasets.Round) public round_;   // (rID => data) round data\r\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id\r\n// ****************\r\n// TEAM FEE DATA , Team的费用分配数据\r\n// ****************\r\n    mapping (uint256 => F3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team\r\n    mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team\r\n//==============================================================================\r\n//     _ _  _  __|_ _    __|_ _  _  .\r\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n//==============================================================================\r\n    constructor()\r\n        public\r\n    {        \r\n        //Team allocation structures\r\n        // 0 = whales\r\n        // 1 = bears\r\n        // 2 = sneks\r\n        // 3 = bulls\r\n\r\n\t\t//Team allocation percentages\r\n        // (F3D, P3D) + (Pot , Referrals, Community)\r\n        //     Referrals / Community rewards are mathematically designed to come from the winner's share of the pot.\r\n        fees_[0] = F3Ddatasets.TeamFee(36,0);   //50% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\r\n        fees_[1] = F3Ddatasets.TeamFee(43,0);   //43% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\r\n        fees_[2] = F3Ddatasets.TeamFee(66,0);  //20% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\r\n        fees_[3] = F3Ddatasets.TeamFee(51,0);   //35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot\r\n        \r\n        // how to split up the final pot based on which team was picked\r\n        // (F3D, P3D)\r\n        potSplit_[0] = F3Ddatasets.PotSplit(25,0);  //48% to winner, 25% to next round, 2% to com\r\n        potSplit_[1] = F3Ddatasets.PotSplit(25,0);   //48% to winner, 25% to next round, 2% to com\r\n        potSplit_[2] = F3Ddatasets.PotSplit(40,0);  //48% to winner, 10% to next round, 2% to com\r\n        potSplit_[3] = F3Ddatasets.PotSplit(40,0);  //48% to winner, 10% to next round, 2% to com\r\n    }\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has \r\n     * been activated. \r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); \r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n    \r\n//==============================================================================\r\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n//====|=========================================================================\r\n    /**\r\n     * @dev emergency buy uses last stored affiliate ID and team snek\r\n     */\r\n    function()\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n            \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        // todo: 如果去为空怎么办？\r\n        \r\n        // buy core \r\n        buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev converts all incoming ethereum to keys.\r\n     * -functionhash- 0x8f38f309 (using ID for affiliate)\r\n     * -functionhash- 0x98a0871d (using address for affiliate)\r\n     * -functionhash- 0xa65b37a1 (using name for affiliate)\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     * @param _team what team is the player playing for?\r\n     */\r\n    function buyXid(uint256 _affCode, uint256 _team)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == 0 || _affCode == _pID)\r\n        {\r\n            // use last stored affiliate code \r\n            _affCode = plyr_[_pID].laff;\r\n            \r\n        // if affiliate code was given & its not the same as previously stored \r\n        } else if (_affCode != plyr_[_pID].laff) {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // buy core \r\n        buyCore(_pID, _affCode, _team, _eventData_);\r\n    }\r\n    \r\n    function buyXaddr(address _affCode, uint256 _team)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // buy core \r\n        buyCore(_pID, _affID, _team, _eventData_);\r\n    }\r\n    \r\n    function buyXname(bytes32 _affCode, uint256 _team)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given\r\n        } else {\r\n            // get affiliate ID from aff Code\r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored\r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // buy core \r\n        buyCore(_pID, _affID, _team, _eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev essentially the same as buy, but instead of you sending ether \r\n     * from your wallet, it uses your unwithdrawn earnings.\r\n     * -functionhash- 0x349cdcac (using ID for affiliate)\r\n     * -functionhash- 0x82bfc739 (using address for affiliate)\r\n     * -functionhash- 0x079ce327 (using name for affiliate)\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     * @param _team what team is the player playing for?\r\n     * @param _eth amount of earnings to use (remainder returned to gen vault)\r\n     */\r\n    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        public\r\n    {\r\n        // set up our tx event data\r\n        F3Ddatasets.EventReturns memory _eventData_;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == 0 || _affCode == _pID)\r\n        {\r\n            // use last stored affiliate code \r\n            _affCode = plyr_[_pID].laff;\r\n            \r\n        // if affiliate code was given & its not the same as previously stored \r\n        } else if (_affCode != plyr_[_pID].laff) {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n\r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n\r\n        // reload core\r\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\r\n    }\r\n    \r\n    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        public\r\n    {\r\n        // set up our tx event data\r\n        F3Ddatasets.EventReturns memory _eventData_;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // reload core\r\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\r\n    }\r\n    \r\n    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        public\r\n    {\r\n        // set up our tx event data\r\n        F3Ddatasets.EventReturns memory _eventData_;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given\r\n        } else {\r\n            // get affiliate ID from aff Code\r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored\r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // reload core\r\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraws all of your earnings.\r\n     * -functionhash- 0x3ccfd60b\r\n     */\r\n    function withdraw()\r\n        isActivated()\r\n        isHuman()\r\n        public\r\n    {\r\n        // setup local rID \r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        \r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // set up our tx event data\r\n            F3Ddatasets.EventReturns memory _eventData_;\r\n            \r\n            // end the round (distributes pot)\r\n\t\t\tround_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n            \r\n\t\t\t// get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);    \r\n            \r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n            \r\n            // fire withdraw and distribute event\r\n            emit F3Devents.onWithdrawAndDistribute\r\n            (\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eth, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.P3DAmount, \r\n                _eventData_.genAmount\r\n            );\r\n            \r\n        // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n            \r\n            // fire withdraw event\r\n            emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev use these to register names.  they are just wrappers that will send the\r\n     * registration requests to the PlayerBook contract.  So registering here is the \r\n     * same as registering there.  UI will always display the last name you registered.\r\n     * but you will still own all previously registered names to use as affiliate \r\n     * links.\r\n     * - must pay a registration fee.\r\n     * - name must be unique\r\n     * - names will be converted to lowercase\r\n     * - name cannot start or end with a space \r\n     * - cannot have more than 1 space in a row\r\n     * - cannot be only numbers\r\n     * - cannot start with 0x \r\n     * - name must be at least 1 char\r\n     * - max length of 32 characters long\r\n     * - allowed characters: a-z, 0-9, and space\r\n     * -functionhash- 0x921dec21 (using ID for affiliate)\r\n     * -functionhash- 0x3ddd4698 (using address for affiliate)\r\n     * -functionhash- 0x685ffd83 (using name for affiliate)\r\n     * @param _nameString players desired name\r\n     * @param _affCode affiliate ID, address, or name of who referred you\r\n     * @param _all set to true if you want this to push your info to all games \r\n     * (this might cost a lot of gas)\r\n     */\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBookMain.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    \r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBookMain.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    \r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBookMain.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n//==============================================================================\r\n//     _  _ _|__|_ _  _ _  .\r\n//    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n//=====_|=======================================================================\r\n    /**\r\n     * @dev return the price buyer will pay for next 1 individual key.\r\n     * -functionhash- 0x018a25e8\r\n     * @return price for next key bought (in wei format)\r\n     */\r\n    function getBuyPrice()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {  \r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( 75000000000000 ); // init\r\n    }\r\n    \r\n    /**\r\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node \r\n     * provider\r\n     * -functionhash- 0xc7e284b8\r\n     * @return time left in seconds\r\n     */\r\n    function getTimeLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        if (_now < round_[_rID].end)\r\n            if (_now > round_[_rID].strt + rndGap_)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].strt + rndGap_).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev returns player earnings per vaults \r\n     * -functionhash- 0x63066434\r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n     */\r\n    function getPlayerVaults(uint256 _pID)\r\n        public\r\n        view\r\n        returns(uint256 ,uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\r\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // if player is winner \r\n            if (round_[_rID].plyr == _pID)\r\n            {\r\n                return\r\n                (\r\n                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                return\r\n                (\r\n                    plyr_[_pID].win,\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            return\r\n            (\r\n                plyr_[_pID].win,\r\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n                plyr_[_pID].aff\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * solidity hates stack limits.  this lets us avoid that hate \r\n     */\r\n    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );\r\n    }\r\n    \r\n    /**\r\n     * @dev returns all current round info needed for front end\r\n     * -functionhash- 0x747dff42\r\n     * @return eth invested during ICO phase\r\n     * @return round id \r\n     * @return total keys for round \r\n     * @return time round ends\r\n     * @return time round started\r\n     * @return current pot \r\n     * @return current team ID & player ID in lead \r\n     * @return current player in leads address \r\n     * @return current player in leads name\r\n     * @return whales eth in for round\r\n     * @return bears eth in for round\r\n     * @return sneks eth in for round\r\n     * @return bulls eth in for round\r\n     * @return airdrop tracker # & airdrop pot\r\n     */\r\n    function getCurrentRoundInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        return\r\n        (\r\n            round_[_rID].ico,               //0\r\n            _rID,                           //1\r\n            round_[_rID].keys,              //2\r\n            round_[_rID].end,               //3\r\n            round_[_rID].strt,              //4\r\n            round_[_rID].pot,               //5\r\n            (round_[_rID].team + (round_[_rID].plyr * 10)),     //6\r\n            plyr_[round_[_rID].plyr].addr,  //7\r\n            plyr_[round_[_rID].plyr].name,  //8\r\n            rndTmEth_[_rID][0],             //9\r\n            rndTmEth_[_rID][1],             //10\r\n            rndTmEth_[_rID][2],             //11\r\n            rndTmEth_[_rID][3],             //12\r\n            airDropTracker_ + (airDropPot_ * 1000)              //13\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address.  if no address is given, it will \r\n     * use msg.sender \r\n     * -functionhash- 0xee0b5d8b\r\n     * @param _addr address of the player you want to lookup \r\n     * @return player ID \r\n     * @return player name\r\n     * @return keys owned (current round)\r\n     * @return winnings vault\r\n     * @return general vault \r\n     * @return affiliate vault \r\n\t * @return player round eth\r\n     */\r\n    function getPlayerInfoByAddress(address _addr)\r\n        public \r\n        view \r\n        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        return\r\n        (\r\n            _pID,                               //0\r\n            plyr_[_pID].name,                   //1\r\n            plyrRnds_[_pID][_rID].keys,         //2\r\n            plyr_[_pID].win,                    //3\r\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4\r\n            plyr_[_pID].aff,                    //5\r\n            plyrRnds_[_pID][_rID].eth           //6\r\n        );\r\n    }\r\n\r\n//==============================================================================\r\n//     _ _  _ _   | _  _ . _  .\r\n//    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine)\r\n//=====================_|=======================================================\r\n    /**\r\n     * @dev logic runs whenever a buy order is executed.  determines how to handle \r\n     * incoming eth depending on if we are in an active round or not\r\n     */\r\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            // call core \r\n            core(_rID, _pID, msg.value, _affID, _team, _eventData_);\r\n        \r\n        // if round is not active     \r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false) \r\n            {\r\n                // end the round (distributes pot) & start new round\r\n\t\t\t    round_[_rID].ended = true;\r\n                _eventData_ = endRound(_eventData_);\r\n                \r\n                // build event data\r\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                \r\n                // fire buy and distribute event \r\n                emit F3Devents.onBuyAndDistribute\r\n                (\r\n                    msg.sender, \r\n                    plyr_[_pID].name, \r\n                    msg.value, \r\n                    _eventData_.compressedData, \r\n                    _eventData_.compressedIDs, \r\n                    _eventData_.winnerAddr, \r\n                    _eventData_.winnerName, \r\n                    _eventData_.amountWon, \r\n                    _eventData_.newPot, \r\n                    _eventData_.P3DAmount, \r\n                    _eventData_.genAmount\r\n                );\r\n            }\r\n            \r\n            // put eth in players vault \r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev logic runs whenever a reload order is executed.  determines how to handle \r\n     * incoming eth depending on if we are in an active round or not \r\n     */\r\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            // get earnings from all vaults and return unused to gen vault\r\n            // because we use a custom safemath library.  this will throw if player \r\n            // tried to spend more eth than they have.\r\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\r\n            \r\n            // call core \r\n            core(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n        \r\n        // if round is not active and end round needs to be ran   \r\n        } else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n            // end the round (distributes pot) & start new round\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n                \r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                \r\n            // fire buy and distribute event \r\n            emit F3Devents.onReLoadAndDistribute\r\n            (\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.P3DAmount, \r\n                _eventData_.genAmount\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev this is the core logic for any buy/reload that happens while a round \r\n     * is live.\r\n     */\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // if player is new to round\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_);\r\n        \r\n        // early round eth limiter \r\n        if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\r\n        {\r\n            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\r\n            uint256 _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n            _eth = _availableLimit;\r\n        }\r\n        \r\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\r\n        if (_eth > 1000000000) \r\n        {\r\n            \r\n            // mint the new keys\r\n            uint256 _keys = (round_[_rID].eth).keysRec(_eth);\r\n            \r\n            // if they bought at least 1 whole key\r\n            if (_keys >= 1000000000000000000)\r\n            {\r\n                updateTimer(_keys, _rID);\r\n\r\n                // set new leaders\r\n                if (round_[_rID].plyr != _pID)\r\n                    round_[_rID].plyr = _pID;  \r\n                if (round_[_rID].team != _team)\r\n                    round_[_rID].team = _team; \r\n                \r\n                // set the new leader bool to true\r\n                _eventData_.compressedData = _eventData_.compressedData + 100;\r\n            }\r\n            \r\n            // manage airdrops\r\n            if (_eth >= 100000000000000000)\r\n            {\r\n                airDropTracker_++;\r\n                if (airdrop() == true)\r\n                {\r\n                    // gib muni\r\n                    uint256 _prize;\r\n                    if (_eth >= 10000000000000000000)\r\n                    {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(75)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                        \r\n                        // let event know a tier 3 prize was won \r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(50)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                        \r\n                        // let event know a tier 2 prize was won \r\n                        _eventData_.compressedData += 200000000000000000000000000000000;\r\n                    } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(25)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                        \r\n                        // let event know a tier 3 prize was won \r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }\r\n                    // set airdrop happened bool to true\r\n                    _eventData_.compressedData += 10000000000000000000000000000000;\r\n                    // let event know how much was won \r\n                    _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\r\n                    \r\n                    // reset air drop tracker\r\n                    airDropTracker_ = 0;\r\n                }\r\n            }\r\n    \r\n            // store the air drop tracker number (number of buys since last airdrop)\r\n            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\r\n            \r\n            // update player \r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n            \r\n            // update round\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\r\n    \r\n            // distribute eth, 分钱\r\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\r\n            \r\n            // call end tx function to fire end tx event.\r\n            endTx(_pID, _team, _eth, _keys, _eventData_);\r\n        }\r\n    }\r\n//==============================================================================\r\n//     _ _ | _   | _ _|_ _  _ _  .\r\n//    (_(_||(_|_||(_| | (_)| _\\  .\r\n//==============================================================================\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\r\n     * @return earnings in wei format\r\n     */\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns the amount of keys you would get given an amount of eth. \r\n     * -functionhash- 0xce89c80c\r\n     * @param _rID round ID you want price for\r\n     * @param _eth amount of eth sent in \r\n     * @return keys received \r\n     */\r\n    function calcKeysReceived(uint256 _rID, uint256 _eth)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].eth).keysRec(_eth) );\r\n        else // rounds over.  need keys for new round\r\n            return ( (_eth).keys() );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns current eth price for X keys.  \r\n     * -functionhash- 0xcf808000\r\n     * @param _keys number of keys desired (in 18 decimal format)\r\n     * @return amount of eth needed to send\r\n     */\r\n    function iWantXKeys(uint256 _keys)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n//==============================================================================\r\n//    _|_ _  _ | _  .\r\n//     | (_)(_)|_\\  .\r\n//==============================================================================\r\n    /**\r\n\t * @dev receives name/player info from names contract \r\n     */\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\r\n        external\r\n    {\r\n        require (msg.sender == address(PlayerBookMain), \"your not playerNames contract... hmmm..\");\r\n        if (pIDxAddr_[_addr] != _pID)\r\n            pIDxAddr_[_addr] = _pID;\r\n        if (pIDxName_[_name] != _pID)\r\n            pIDxName_[_name] = _pID;\r\n        if (plyr_[_pID].addr != _addr)\r\n            plyr_[_pID].addr = _addr;\r\n        if (plyr_[_pID].name != _name)\r\n            plyr_[_pID].name = _name;\r\n        if (plyr_[_pID].laff != _laff)\r\n            plyr_[_pID].laff = _laff;\r\n        if (plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n    \r\n    /**\r\n     * @dev receives entire player name list \r\n     */\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name)\r\n        external\r\n    {\r\n        require (msg.sender == address(PlayerBookMain), \"your not playerNames contract... hmmm..\");\r\n        if(plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }   \r\n        \r\n    /**\r\n     * @dev gets existing or registers new pID.  use this when a player may be new\r\n     * @return pID \r\n     */\r\n    function determinePID(F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (F3Ddatasets.EventReturns)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        // if player is new to this version of fomo3d\r\n        if (_pID == 0)\r\n        {\r\n            // grab their player ID, name and last aff ID, from player names contract \r\n            _pID = PlayerBookMain.getPlayerID(msg.sender);\r\n            bytes32 _name = PlayerBookMain.getPlayerName(_pID);\r\n            uint256 _laff = PlayerBookMain.getPlayerLAff(_pID);\r\n            \r\n            // set up player account \r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n            \r\n            if (_name != \"\")\r\n            {\r\n                pIDxName_[_name] = _pID;\r\n                plyr_[_pID].name = _name;\r\n                plyrNames_[_pID][_name] = true;\r\n            }\r\n            \r\n            if (_laff != 0 && _laff != _pID)\r\n                plyr_[_pID].laff = _laff;\r\n            \r\n            // set the new player bool to true\r\n            _eventData_.compressedData = _eventData_.compressedData + 1;\r\n        } \r\n        return (_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev checks to make sure user picked a valid team.  if not sets team \r\n     * to default (sneks)\r\n     */\r\n    function verifyTeam(uint256 _team)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_team < 0 || _team > 3)\r\n            return(2);\r\n        else\r\n            return(_team);\r\n    }\r\n    \r\n    /**\r\n     * @dev decides if round end needs to be run & new round started.  and if \r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n    function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (F3Ddatasets.EventReturns)\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n            \r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n            \r\n        // set the joined round bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev ends the round. manages paying out winner/splitting up pot\r\n     */\r\n    function endRound(F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (F3Ddatasets.EventReturns)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab our winning player and team id's\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        uint256 _winTID = round_[_rID].team;\r\n        \r\n        // grab our pot amount\r\n        uint256 _pot = round_[_rID].pot;\r\n        \r\n        // calculate our winner share, community rewards, gen share, \r\n        // p3d share, and amount reserved for next pot \r\n        uint256 _win = (_pot.mul(48)) / 100;\r\n        uint256 _com = (_pot / 50);\r\n        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\r\n        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\r\n        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\r\n        \r\n        // calculate ppt for round mask\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\r\n        if (_dust > 0)\r\n        {\r\n            _gen = _gen.sub(_dust);\r\n            _res = _res.add(_dust);\r\n        }\r\n        \r\n        // pay our winner\r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n        \r\n        // community rewards\r\n        if (!address(FundForwarderMain).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\r\n        {\r\n            // This ensures Team Just cannot influence the outcome of FoMo3D with\r\n            // bank migrations by breaking outgoing transactions.\r\n            // Something we would never do. But that's not the point.\r\n            // We spent 2000$ in eth re-deploying just to patch this, we hold the \r\n            // highest belief that everything we create should be trustless.\r\n            // Team JUST, The name you shouldn't have to trust.\r\n            _p3d = _p3d.add(_com);\r\n            _com = 0;\r\n        }\r\n        \r\n        // distribute gen portion to key holders\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n        \r\n        // send share for p3d to divies\r\n        if (_p3d > 0){\r\n            //     Divies.deposit.value(_p3d)();\r\n            FundForwarderMain.deposit.value(_p3d)();\r\n        }\r\n            \r\n        // prepare event data\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = plyr_[_winPID].name;\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.P3DAmount = _p3d;\r\n        _eventData_.newPot = _res;\r\n        \r\n        // start next round\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndInit_).add(rndGap_);\r\n        round_[_rID].pot = _res;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev updates round timer based on number of whole keys bought.\r\n     */\r\n    function updateTimer(uint256 _keys, uint256 _rID)\r\n        private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // calculate time based on number of keys bought\r\n        uint256 _newTime;\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n        \r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n    \r\n    /**\r\n     * @dev generates a random number between 0-99 and checks to see if thats\r\n     * resulted in an airdrop win\r\n     * @return do we have a winner?\r\n     */\r\n    function airdrop()\r\n        private \r\n        view \r\n        returns(bool)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n\r\n    /**\r\n     * @dev distributes eth based on fees to com, aff, and p3d\r\n     */\r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns(F3Ddatasets.EventReturns)\r\n    {\r\n        // pay 2% out to community rewards\r\n        uint256 _com = _eth / 50;\r\n        uint256 _p3d;\r\n        if (!address(FundForwarderMain).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\r\n        {\r\n            // This ensures Team Just cannot influence the outcome of FoMo3D with\r\n            // bank migrations by breaking outgoing transactions.\r\n            // Something we would never do. But that's not the point.\r\n            // We spent 2000$ in eth re-deploying just to patch this, we hold the \r\n            // highest belief that everything we create should be trustless.\r\n            // Team JUST, The name you shouldn't have to trust.\r\n            _p3d = _com;\r\n            _com = 0;\r\n        }\r\n        \r\n        // pay 1% out to FoMo3D short\r\n        uint256 _long = _eth / 100;\r\n        otherF3D_.potSwap.value(_long)();\r\n        \r\n        // distribute share to affiliate\r\n        uint256 _aff = _eth / 10;\r\n        \r\n        // decide what to do with affiliate share of fees\r\n        // affiliate must not be self, and must have a name registered\r\n        if (_affID != _pID && plyr_[_affID].name != '') {\r\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\r\n        } else {\r\n            _p3d = _aff;\r\n        }\r\n        \r\n        // pay out p3d\r\n        _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\r\n        if (_p3d > 0)\r\n        {\r\n            // deposit to divies contract\r\n            // todo: 干掉\r\n            // Divies.deposit.value(_p3d)();\r\n            FundForwarderMain.deposit.value(_p3d)();\r\n            // set up event data\r\n            _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);\r\n        }\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    function potSwap()\r\n        external\r\n        payable\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_ + 1;\r\n        \r\n        round_[_rID].pot = round_[_rID].pot.add(msg.value);\r\n        emit F3Devents.onPotSwapDeposit(_rID, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev distributes eth based on fees to gen and pot\r\n     */\r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns(F3Ddatasets.EventReturns)\r\n    {\r\n        // calculate gen share\r\n        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\r\n        \r\n        // toss 1% into airdrop pot \r\n        uint256 _air = (_eth / 100);\r\n        airDropPot_ = airDropPot_.add(_air);\r\n        \r\n        // update eth balance (eth = eth - (com share + pot swap share + aff share + p3d share + airdrop pot share))\r\n        _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\r\n        \r\n        // calculate pot \r\n        uint256 _pot = _eth.sub(_gen);\r\n        \r\n        // distribute gen share (thats what updateMasks() does) and adjust\r\n        // balances for dust.\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n        \r\n        // add eth to pot\r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n        \r\n        // set up event data\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n        \r\n        return(_eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev updates masks for round and player when keys are bought\r\n     * @return dust left over \r\n     */\r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        /* MASKING NOTES\r\n            earnings masks are a tricky thing for people to wrap their minds around.\r\n            the basic thing to understand here.  is were going to have a global\r\n            tracker based on profit per share for each round, that increases in\r\n            relevant proportion to the increase in share supply.\r\n            \r\n            the player will have an additional mask that basically says \"based\r\n            on the rounds mask, my shares, and how much i've already withdrawn,\r\n            how much is still owed to me?\"\r\n        */\r\n        \r\n        // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n            \r\n        // calculate player earning from their own buy (only based on the keys\r\n        // they just bought).  & update player earnings mask\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n        \r\n        // calculate & return dust\r\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\r\n    }\r\n    \r\n    /**\r\n     * @dev adds up unmasked earnings, & vault earnings, sets them all to 0\r\n     * @return earnings in wei format\r\n     */\r\n    function withdrawEarnings(uint256 _pID)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        // from vaults \r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n    \r\n    /**\r\n     * @dev prepares compression data and fires event for buy or reload tx's\r\n     */\r\n    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\r\n        \r\n        emit F3Devents.onEndTx\r\n        (\r\n            _eventData_.compressedData,\r\n            _eventData_.compressedIDs,\r\n            plyr_[_pID].name,\r\n            msg.sender,\r\n            _eth,\r\n            _keys,\r\n            _eventData_.winnerAddr,\r\n            _eventData_.winnerName,\r\n            _eventData_.amountWon,\r\n            _eventData_.newPot,\r\n            _eventData_.P3DAmount,\r\n            _eventData_.genAmount,\r\n            _eventData_.potAmount,\r\n            airDropPot_\r\n        );\r\n    }\r\n//==============================================================================\r\n//    (~ _  _    _._|_    .\r\n//    _)(/_(_|_|| | | \\/  .\r\n//====================/=========================================================\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs \r\n     * have time to set things up on the web end                            **/\r\n    \r\n    function activate()\r\n        public\r\n    {\r\n        // only team just can activate \r\n        require(\r\n            msg.sender == DEV_1_ADDRESS, \"only team just can activate\"\r\n        );\r\n\r\n\t\t// make sure that its been linked.\r\n        require(address(otherF3D_) != address(0), \"must link to other FoMo3D first\");\r\n        \r\n        // can only be ran once\r\n        require(activated_ == false, \"fomo3d already activated\");\r\n        \r\n        // activate the contract \r\n        activated_ = true;\r\n        \r\n        // lets start first round\r\n\t\trID_ = 1;\r\n        round_[1].strt = now + rndExtra_ - rndGap_;\r\n        round_[1].end = now + rndInit_ + rndExtra_;\r\n    }\r\n    function setOtherFomo(address _otherF3D)\r\n        public\r\n    {\r\n        // only team just can activate \r\n        require(\r\n            msg.sender == DEV_1_ADDRESS, \"only team just can set\"\r\n        );\r\n\r\n        // make sure that it HASNT yet been linked.\r\n        require(address(otherF3D_) == address(0), \"silly dev, you already did that\");\r\n        \r\n        // set up other fomo3d (fast or long) for pot swap\r\n        otherF3D_ = otherFoMo3D(_otherF3D);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"icoGen\",\"type\":\"uint256\"},{\"name\":\"icoAvg\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"p3d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXaddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"receivePlayerNameList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_otherF3D\",\"type\":\"address\"}],\"name\":\"setOtherFomo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potSplit_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"p3d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"potSwap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"airDropPot\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountAddedToPot\",\"type\":\"uint256\"}],\"name\":\"onPotSwapDeposit\",\"type\":\"event\"}]","ContractName":"FoMo3DlongUnlimited","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://11f667d0fce04e21c2826cc8bfe27fea6b7009b61a566b61c580aa624eadc34a"}]}