{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n        return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Currency exchange rate contract\r\n */\r\ncontract CurrencyExchangeRate is Ownable {\r\n\r\n    struct Currency {\r\n        uint256 exRateToEther; // Exchange rate: currency to Ether\r\n        uint8 exRateDecimals;  // Exchange rate decimals\r\n    }\r\n\r\n    Currency[] public currencies;\r\n\r\n    event CurrencyExchangeRateAdded(\r\n        address indexed setter, uint256 index, uint256 rate, uint256 decimals\r\n    );\r\n\r\n    event CurrencyExchangeRateSet(\r\n        address indexed setter, uint256 index, uint256 rate, uint256 decimals\r\n    );\r\n\r\n    constructor() public {\r\n        // Add Ether to index 0\r\n        currencies.push(\r\n            Currency ({\r\n                exRateToEther: 1,\r\n                exRateDecimals: 0\r\n            })\r\n        );\r\n        // Add USD to index 1\r\n        currencies.push(\r\n            Currency ({\r\n                exRateToEther: 30000,\r\n                exRateDecimals: 2\r\n            })\r\n        );\r\n    }\r\n\r\n    function addCurrencyExchangeRate(\r\n        uint256 _exRateToEther, \r\n        uint8 _exRateDecimals\r\n    ) external onlyOwner {\r\n        emit CurrencyExchangeRateAdded(\r\n            msg.sender, currencies.length, _exRateToEther, _exRateDecimals);\r\n        currencies.push(\r\n            Currency ({\r\n                exRateToEther: _exRateToEther,\r\n                exRateDecimals: _exRateDecimals\r\n            })\r\n        );\r\n    }\r\n\r\n    function setCurrencyExchangeRate(\r\n        uint256 _currencyIndex,\r\n        uint256 _exRateToEther, \r\n        uint8 _exRateDecimals\r\n    ) external onlyOwner {\r\n        emit CurrencyExchangeRateSet(\r\n            msg.sender, _currencyIndex, _exRateToEther, _exRateDecimals);\r\n        currencies[_currencyIndex].exRateToEther = _exRateToEther;\r\n        currencies[_currencyIndex].exRateDecimals = _exRateDecimals;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title KYC contract interface\r\n */\r\ncontract KYC {\r\n    \r\n    /**\r\n     * Get KYC expiration timestamp in second.\r\n     *\r\n     * @param _who Account address\r\n     * @return KYC expiration timestamp in second\r\n     */\r\n    function expireOf(address _who) external view returns (uint256);\r\n\r\n    /**\r\n     * Get KYC level.\r\n     * Level is ranging from 0 (lowest, no KYC) to 255 (highest, toughest).\r\n     *\r\n     * @param _who Account address\r\n     * @return KYC level\r\n     */\r\n    function kycLevelOf(address _who) external view returns (uint8);\r\n\r\n    /**\r\n     * Get encoded nationalities (country list).\r\n     * The uint256 is represented by 256 bits (0 or 1).\r\n     * Every bit can represent a country.\r\n     * For each listed country, set the corresponding bit to 1.\r\n     * To do so, up to 256 countries can be encoded in an uint256 variable.\r\n     * Further, if country blacklist of an ICO was encoded by the same way,\r\n     * it is able to use bitwise AND to check whether the investor can invest\r\n     * the ICO by the crowdsale.\r\n     *\r\n     * @param _who Account address\r\n     * @return Encoded nationalities\r\n     */\r\n    function nationalitiesOf(address _who) external view returns (uint256);\r\n\r\n    /**\r\n     * Set KYC status to specific account address.\r\n     *\r\n     * @param _who Account address\r\n     * @param _expiresAt Expire timestamp in seconds\r\n     * @param _level KYC level\r\n     * @param _nationalities Encoded nationalities\r\n     */\r\n    function setKYC(\r\n        address _who, uint256 _expiresAt, uint8 _level, uint256 _nationalities) \r\n        external;\r\n\r\n    event KYCSet (\r\n        address indexed _setter,\r\n        address indexed _who,\r\n        uint256 _expiresAt,\r\n        uint8 _level,\r\n        uint256 _nationalities\r\n    );\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\ncontract EtherVault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    enum State { Active, Refunding, Closed }\r\n\r\n    address public wallet;\r\n    State public state;\r\n\r\n    event Closed(address indexed commissionWallet, uint256 commission);\r\n    event RefundsEnabled();\r\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n    constructor(address _wallet) public {\r\n        require(\r\n            _wallet != address(0),\r\n            \"Failed to create Ether vault due to wallet address is 0x0.\"\r\n        );\r\n        wallet = _wallet;\r\n        state = State.Active;\r\n    }\r\n\r\n    function deposit() public onlyOwner payable {\r\n        require(\r\n            state == State.Active,\r\n            \"Failed to deposit Ether due to state is not Active.\"\r\n        );\r\n    }\r\n\r\n    function close(address _commissionWallet, uint256 _commission) public onlyOwner {\r\n        require(\r\n            state == State.Active,\r\n            \"Failed to close due to state is not Active.\"\r\n        );\r\n        state = State.Closed;\r\n        emit Closed(_commissionWallet, _commission);\r\n        _commissionWallet.transfer(address(this).balance.mul(_commission).div(100));\r\n        wallet.transfer(address(this).balance);\r\n    }\r\n\r\n    function enableRefunds() public onlyOwner {\r\n        require(\r\n            state == State.Active,\r\n            \"Failed to enable refunds due to state is not Active.\"\r\n        );\r\n        emit RefundsEnabled();\r\n        state = State.Refunding;        \r\n    }\r\n\r\n    function refund(address investor, uint256 depositedValue) public onlyOwner {\r\n        require(\r\n            state == State.Refunding,\r\n            \"Failed to refund due to state is not Refunding.\"\r\n        );\r\n        emit Refunded(investor, depositedValue);\r\n        investor.transfer(depositedValue);        \r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ICO Rocket Fuel contract for FirstMile/LastMile service.\r\n */\r\ncontract IcoRocketFuel is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // Crowdsale current state\r\n    enum States {Ready, Active, Paused, Refunding, Closed}\r\n    States public state = States.Ready;\r\n\r\n    // Token for crowdsale (Token contract).\r\n    // Replace 0x0 by deployed ERC20 token address.\r\n    ERC20 public token = ERC20(0x0e27b0ca1f890d37737dd5cde9de22431255f524);\r\n\r\n    // Crowdsale owner (ICO team).\r\n    // Replace 0x0 by wallet address of ICO team.\r\n    address public crowdsaleOwner = 0xf75589cac3b23f24de65fe5a3cd07966728071a3;\r\n\r\n    // When crowdsale is closed, commissions will transfer to this wallet.\r\n    // Replace 0x0 by commission wallet address of platform.\r\n    address public commissionWallet = 0xf75589cac3b23f24de65fe5a3cd07966728071a3;\r\n\r\n    // Base exchange rate (1 invested currency = N tokens) and its decimals.\r\n    // Ex. to present base exchange rate = 0.01 (= 1 / (10^2))\r\n    //     baseExRate = 1; baseExRateDecimals = 2 \r\n    //     (1 / (10^2)) equal to (baseExRate / (10^baseExRateDecimals))\r\n    uint256 public baseExRate = 20;    \r\n    uint8 public baseExRateDecimals = 0;\r\n\r\n    // External exchange rate contract and currency index.\r\n    // Use exRate.currencies(currency) to get tuple.\r\n    // tuple = (Exchange rate to Ether, Exchange rate decimal)\r\n    // Replace 0x0 by address of deployed CurrencyExchangeRate contract.\r\n    CurrencyExchangeRate public exRate = CurrencyExchangeRate(0x44802e3d6fb67bd8ee7b24033ee04b1290692fd9);\r\n    // Supported currency\r\n    // 0: Ether\r\n    // 1: USD\r\n    uint256 public currency = 1;\r\n\r\n    // Total raised in specified currency.\r\n    uint256 public raised = 0;\r\n    // Hard cap in specified currency.\r\n    uint256 public cap = 25000000 * (10**18);\r\n    // Soft cap in specified currency.\r\n    uint256 public goal = 0;\r\n    // Minimum investment in specified currency.\r\n    uint256 public minInvest = 50000 * (10**18);\r\n    \r\n    // Crowdsale closing time in second.\r\n    uint256 public closingTime = 1548979200;\r\n    // Whether allow early closure\r\n    bool public earlyClosure = true;\r\n\r\n    // Commission percentage. Set to 10 means 10% \r\n    uint8 public commission = 10;\r\n\r\n    // When KYC is required, check KYC result with this contract.\r\n    // The value is initiated by constructor.\r\n    // The value is not allowed to change after contract deployment.\r\n    // Replace 0x0 by address of deployed KYC contract.\r\n    KYC public kyc = KYC(0x8df3064451f840285993e2a4cfc0ec56b267d288);\r\n\r\n    // Get encoded country blacklist.\r\n    // The uint256 is represented by 256 bits (0 or 1).\r\n    // Every bit can represent a country.\r\n    // For the country listed in the blacklist, set the corresponding bit to 1.\r\n    // To do so, up to 256 countries can be encoded in an uint256 variable.\r\n    // Further, if nationalities of an investor were encoded by the same way,\r\n    // it is able to use bitwise AND to check whether the investor can invest\r\n    // the ICO by the crowdsale.\r\n    // Keypasco: Natural persons from Singapore and United States cannot invest.\r\n    uint256 public countryBlacklist = 27606985387965724171868518586879082855975017189942647717541493312847872;\r\n\r\n    // Get required KYC level of the crowdsale.\r\n    // KYC level = 0 (default): Crowdsale does not require KYC.\r\n    // KYC level > 0: Crowdsale requires centain level of KYC.\r\n    // KYC level ranges from 0 (no KYC) to 255 (toughest).\r\n    uint8 public kycLevel = 100;\r\n\r\n    // Whether legal person can skip country check.\r\n    // True: can skip; False: cannot skip.  \r\n    bool public legalPersonSkipsCountryCheck = true;\r\n\r\n    // Use deposits[buyer] to get deposited Wei for buying the token.\r\n    // The buyer is the buyer address.\r\n    mapping(address => uint256) public deposits;\r\n    // Ether vault entrusts invested Wei.\r\n    EtherVault public vault;\r\n    \r\n    // Investment in specified currency.\r\n    // Use invests[buyer] to get current investments.\r\n    mapping(address => uint256) public invests;\r\n    // Token units can be claimed by buyer.\r\n    // Use tokenUnits[buyer] to get current bought token units.\r\n    mapping(address => uint256) public tokenUnits;\r\n    // Total token units for performing the deal.\r\n    // Sum of all buyers' bought token units will equal to this value.\r\n    uint256 public totalTokenUnits = 0;\r\n\r\n    // Bonus tiers which will be initiated in constructor.\r\n    struct BonusTier {\r\n        uint256 investSize; // Invest in specified currency\r\n        uint256 bonus;      // Bonus in percentage\r\n    }\r\n    // Bonus levels initiated by constructor.\r\n    BonusTier[] public bonusTiers;\r\n\r\n    event StateSet(\r\n        address indexed setter, \r\n        States oldState, \r\n        States newState\r\n    );\r\n\r\n    event CrowdsaleStarted(\r\n        address indexed icoTeam\r\n    );\r\n\r\n    event TokenBought(\r\n        address indexed buyer, \r\n        uint256 valueWei, \r\n        uint256 valueCurrency\r\n    );\r\n\r\n    event TokensRefunded(\r\n        address indexed beneficiary,\r\n        uint256 valueTokenUnit\r\n    );\r\n\r\n    event Finalized(\r\n        address indexed icoTeam\r\n    );\r\n\r\n    event SurplusTokensRefunded(\r\n        address indexed beneficiary,\r\n        uint256 valueTokenUnit\r\n    );\r\n\r\n    event CrowdsaleStopped(\r\n        address indexed owner\r\n    );\r\n\r\n    event TokenClaimed(\r\n        address indexed beneficiary,\r\n        uint256 valueTokenUnit\r\n    );\r\n\r\n    event RefundClaimed(\r\n        address indexed beneficiary,\r\n        uint256 valueWei\r\n    );\r\n\r\n    modifier onlyCrowdsaleOwner() {\r\n        require(\r\n            msg.sender == crowdsaleOwner,\r\n            \"Failed to call function due to permission denied.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier inState(States _state) {\r\n        require(\r\n            state == _state,\r\n            \"Failed to call function due to crowdsale is not in right state.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        // Must push higher bonus first.\r\n        bonusTiers.push(\r\n            BonusTier({\r\n                investSize: 400000 * (10**18),\r\n                bonus: 50\r\n            })\r\n        );\r\n        bonusTiers.push(\r\n            BonusTier({\r\n                investSize: 200000 * (10**18),\r\n                bonus: 40\r\n            })\r\n        );\r\n        bonusTiers.push(\r\n            BonusTier({\r\n                investSize: 100000 * (10**18),\r\n                bonus: 30\r\n            })\r\n        );\r\n        bonusTiers.push(\r\n            BonusTier({\r\n                investSize: 50000 * (10**18),\r\n                bonus: 20\r\n            })\r\n        );\r\n    }\r\n\r\n    function setAddress(\r\n        address _token,\r\n        address _crowdsaleOwner,\r\n        address _commissionWallet,\r\n        address _exRate,\r\n        address _kyc\r\n    ) external onlyOwner inState(States.Ready){\r\n        token = ERC20(_token);\r\n        crowdsaleOwner = _crowdsaleOwner;\r\n        commissionWallet = _commissionWallet;\r\n        exRate = CurrencyExchangeRate(_exRate);\r\n        kyc = KYC(_kyc);\r\n    }\r\n\r\n    function setSpecialOffer(\r\n        uint256 _currency,\r\n        uint256 _cap,\r\n        uint256 _goal,\r\n        uint256 _minInvest,\r\n        uint256 _closingTime\r\n    ) external onlyOwner inState(States.Ready) {\r\n        currency = _currency;\r\n        cap = _cap;\r\n        goal = _goal;\r\n        minInvest = _minInvest;\r\n        closingTime = _closingTime;\r\n    }\r\n\r\n    function setInvestRestriction(\r\n        uint256 _countryBlacklist,\r\n        uint8 _kycLevel,\r\n        bool _legalPersonSkipsCountryCheck\r\n    ) external onlyOwner inState(States.Ready) {\r\n        countryBlacklist = _countryBlacklist;\r\n        kycLevel = _kycLevel;\r\n        legalPersonSkipsCountryCheck = _legalPersonSkipsCountryCheck;\r\n    }\r\n\r\n    function setState(uint256 _state) external onlyOwner {\r\n        require(\r\n            uint256(state) < uint256(States.Refunding),\r\n            \"Failed to set state due to crowdsale was finalized.\"\r\n        );\r\n        require(\r\n            // Only allow switch state between Active and Paused.\r\n            uint256(States.Active) == _state || uint256(States.Paused) == _state,\r\n            \"Failed to set state due to invalid index.\"\r\n        );\r\n        emit StateSet(msg.sender, state, States(_state));\r\n        state = States(_state);\r\n    }\r\n\r\n    /**\r\n     * Get bonus in token units.\r\n     * @param _investSize Total investment size in specified currency\r\n     * @param _tokenUnits Token units for the investment (without bonus)\r\n     * @return Bonus in token units\r\n     */\r\n    function _getBonus(uint256 _investSize, uint256 _tokenUnits) \r\n        private view returns (uint256) \r\n    {\r\n        for (uint256 _i = 0; _i < bonusTiers.length; _i++) {\r\n            if (_investSize >= bonusTiers[_i].investSize) {\r\n                return _tokenUnits.mul(bonusTiers[_i].bonus).div(100);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Start crowdsale.\r\n     */\r\n    function startCrowdsale()\r\n        external\r\n        onlyCrowdsaleOwner\r\n        inState(States.Ready)\r\n    {\r\n        emit CrowdsaleStarted(msg.sender);\r\n        vault = new EtherVault(msg.sender);\r\n        state = States.Active;\r\n    }\r\n\r\n    /**\r\n     * Buy token.\r\n     */\r\n    function buyToken()\r\n        external\r\n        inState(States.Active)\r\n        payable\r\n    {\r\n        // KYC level = 0 means no KYC can invest.\r\n        // KYC level > 0 means certain level of KYC is required.\r\n        if (kycLevel > 0) {\r\n            require(\r\n                // solium-disable-next-line security/no-block-members\r\n                block.timestamp < kyc.expireOf(msg.sender),\r\n                \"Failed to buy token due to KYC was expired.\"\r\n            );\r\n        }\r\n\r\n        require(\r\n            kycLevel <= kyc.kycLevelOf(msg.sender),\r\n            \"Failed to buy token due to require higher KYC level.\"\r\n        );\r\n\r\n        require(\r\n            countryBlacklist & kyc.nationalitiesOf(msg.sender) == 0 || (\r\n                kyc.kycLevelOf(msg.sender) >= 200 && legalPersonSkipsCountryCheck\r\n            ),\r\n            \"Failed to buy token due to country investment restriction.\"\r\n        );\r\n\r\n        // Get exchange rate of specified currency.\r\n        (uint256 _exRate, uint8 _exRateDecimals) = exRate.currencies(currency);\r\n\r\n        // Convert from Ether to base currency.\r\n        uint256 _investSize = (msg.value)\r\n            .mul(_exRate).div(10**uint256(_exRateDecimals));\r\n\r\n        require(\r\n            _investSize >= minInvest,\r\n            \"Failed to buy token due to less than minimum investment.\"\r\n        );\r\n\r\n        require(\r\n            raised.add(_investSize) <= cap,\r\n            \"Failed to buy token due to exceed cap.\"\r\n        );\r\n\r\n        require(\r\n            // solium-disable-next-line security/no-block-members\r\n            block.timestamp < closingTime,\r\n            \"Failed to buy token due to crowdsale is closed.\"\r\n        );\r\n\r\n        // Update total invested in specified currency.\r\n        invests[msg.sender] = invests[msg.sender].add(_investSize);\r\n        // Update total invested wei.\r\n        deposits[msg.sender] = deposits[msg.sender].add(msg.value);\r\n        // Update total raised in specified currency.    \r\n        raised = raised.add(_investSize);\r\n\r\n        // Log previous token units.\r\n        uint256 _previousTokenUnits = tokenUnits[msg.sender];\r\n\r\n        // Calculate token units by base exchange rate.\r\n        uint256 _tokenUnits = invests[msg.sender]\r\n            .mul(baseExRate)\r\n            .div(10**uint256(baseExRateDecimals));\r\n\r\n        // Calculate bought token units (take bonus into account).\r\n        uint256 _tokenUnitsWithBonus = _tokenUnits.add(\r\n            _getBonus(invests[msg.sender], _tokenUnits));\r\n\r\n        // Update total bought token units.\r\n        tokenUnits[msg.sender] = _tokenUnitsWithBonus;\r\n\r\n        // Update total token units to be issued.\r\n        totalTokenUnits = totalTokenUnits\r\n            .sub(_previousTokenUnits)\r\n            .add(_tokenUnitsWithBonus);\r\n\r\n        emit TokenBought(msg.sender, msg.value, _investSize);\r\n\r\n        // Entrust wei to vault.\r\n        vault.deposit.value(msg.value)();\r\n    }\r\n\r\n    /**\r\n     * Refund token units to wallet address of crowdsale owner.\r\n     */\r\n    function _refundTokens()\r\n        private\r\n        inState(States.Refunding)\r\n    {\r\n        uint256 _value = token.balanceOf(address(this));\r\n        emit TokensRefunded(crowdsaleOwner, _value);\r\n        if (_value > 0) {         \r\n            // Refund all tokens for crowdsale to refund wallet.\r\n            token.transfer(crowdsaleOwner, _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finalize this crowdsale.\r\n     */\r\n    function finalize()\r\n        external\r\n        inState(States.Active)        \r\n        onlyCrowdsaleOwner\r\n    {\r\n        require(\r\n            // solium-disable-next-line security/no-block-members                \r\n            earlyClosure || block.timestamp >= closingTime,                   \r\n            \"Failed to finalize due to crowdsale is opening.\"\r\n        );\r\n\r\n        emit Finalized(msg.sender);\r\n\r\n        if (raised >= goal && token.balanceOf(address(this)) >= totalTokenUnits) {\r\n            // Set state to Closed whiling preventing reentry.\r\n            state = States.Closed;\r\n\r\n            // Refund surplus tokens.\r\n            uint256 _balance = token.balanceOf(address(this));\r\n            uint256 _surplus = _balance.sub(totalTokenUnits);\r\n            emit SurplusTokensRefunded(crowdsaleOwner, _surplus);\r\n            if (_surplus > 0) {\r\n                // Refund surplus tokens to refund wallet.\r\n                token.transfer(crowdsaleOwner, _surplus);\r\n            }\r\n            // Close vault, and transfer commission and raised ether.\r\n            vault.close(commissionWallet, commission);\r\n        } else {\r\n            state = States.Refunding;\r\n            _refundTokens();\r\n            vault.enableRefunds();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop this crowdsale.\r\n     * Only stop suspecious projects.\r\n     */\r\n    function stopCrowdsale()  \r\n        external\r\n        onlyOwner\r\n        inState(States.Paused)\r\n    {\r\n        emit CrowdsaleStopped(msg.sender);\r\n        state = States.Refunding;\r\n        _refundTokens();\r\n        vault.enableRefunds();\r\n    }\r\n\r\n    /**\r\n     * Investors claim bought token units.\r\n     */\r\n    function claimToken()\r\n        external \r\n        inState(States.Closed)\r\n    {\r\n        require(\r\n            tokenUnits[msg.sender] > 0,\r\n            \"Failed to claim token due to token unit is 0.\"\r\n        );\r\n        uint256 _value = tokenUnits[msg.sender];\r\n        tokenUnits[msg.sender] = 0;\r\n        emit TokenClaimed(msg.sender, _value);\r\n        token.transfer(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n     * Investors claim invested Ether refunds.\r\n     */\r\n    function claimRefund()\r\n        external\r\n        inState(States.Refunding)\r\n    {\r\n        require(\r\n            deposits[msg.sender] > 0,\r\n            \"Failed to claim refund due to deposit is 0.\"\r\n        );\r\n\r\n        uint256 _value = deposits[msg.sender];\r\n        deposits[msg.sender] = 0;\r\n        emit RefundClaimed(msg.sender, _value);\r\n        vault.refund(msg.sender, _value);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_crowdsaleOwner\",\"type\":\"address\"},{\"name\":\"_commissionWallet\",\"type\":\"address\"},{\"name\":\"_exRate\",\"type\":\"address\"},{\"name\":\"_kyc\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"legalPersonSkipsCountryCheck\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invests\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exRate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseExRateDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_countryBlacklist\",\"type\":\"uint256\"},{\"name\":\"_kycLevel\",\"type\":\"uint8\"},{\"name\":\"_legalPersonSkipsCountryCheck\",\"type\":\"bool\"}],\"name\":\"setInvestRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kycLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"uint256\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusTiers\",\"outputs\":[{\"name\":\"investSize\",\"type\":\"uint256\"},{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseExRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countryBlacklist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyClosure\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currency\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_minInvest\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"}],\"name\":\"setSpecialOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"icoTeam\",\"type\":\"address\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"valueCurrency\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueTokenUnit\",\"type\":\"uint256\"}],\"name\":\"TokensRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"icoTeam\",\"type\":\"address\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueTokenUnit\",\"type\":\"uint256\"}],\"name\":\"SurplusTokensRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CrowdsaleStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueTokenUnit\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueWei\",\"type\":\"uint256\"}],\"name\":\"RefundClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"IcoRocketFuel","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8a3663544ce80e719b03bd07a49858f8035a36f1c8f07cd3c36a7e198478a7fc"}]}