{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n  /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n  uint private constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n  /// @dev Constant for locked guard state\r\n  uint private constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  uint private reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one `nonReentrant` function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and an `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(reentrancyLock == REENTRANCY_GUARD_FREE);\r\n    reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n    _;\r\n    reentrancyLock = REENTRANCY_GUARD_FREE;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/rbac/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/rbac/RBAC.sol\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * Supports unlimited numbers of roles and addresses.\r\n * See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n * for you to write your own implementation of this interface using Enums or similar.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address _operator, string _role)\r\n    public\r\n    view\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address _operator, string _role)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function addRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function removeRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string _role)\r\n  {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param _roles the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] _roles) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < _roles.length; i++) {\r\n  //         if (hasRole(msg.sender, _roles[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n// File: contracts/token/WToken.sol\r\n\r\ncontract WToken is DetailedERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    mapping(address => uint256) public balances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    mapping (address => mapping (uint256 => uint256)) public vestingBalanceOf;\r\n\r\n    mapping (address => uint[]) vestingTimes;\r\n\r\n    mapping (address => bool) trustedAccounts;\r\n\r\n    event VestingTransfer(address from, address to, uint256 value, uint256 agingTime);\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    constructor(string _name, string _symbol, uint8 _decimals) DetailedERC20(_name, _symbol, _decimals) public {\r\n        trustedAccounts[msg.sender] = true;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        _checkMyVesting(msg.sender);\r\n        require(_to != address(0));\r\n        require(_value <= accountBalance(msg.sender));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function vestingTransfer(address _to, uint256 _value, uint32 _vestingTime) external onlyTrusted(msg.sender) returns (bool) {\r\n        transfer(_to, _value);\r\n\r\n        if (_vestingTime > now) {\r\n            _addToVesting(address(0), _to, _vestingTime, _value);\r\n        }\r\n\r\n        emit VestingTransfer(msg.sender, _to, _value, _vestingTime);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        _checkMyVesting(_from);\r\n\r\n        require(_to != address(0));\r\n        require(_value <= accountBalance(_from));\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function mint(address _to, uint _amount, uint32 _vestingTime) external onlyTrusted(msg.sender) returns (bool) {\r\n        balances[_to] = balances[_to].add(_amount);\r\n        _totalSupply = _totalSupply.add(_amount);\r\n\r\n        if (_vestingTime > now) {\r\n            _addToVesting(address(0), _to, _vestingTime, _amount);\r\n        }\r\n\r\n        emit Transfer(address(0), _to, _amount);\r\n        emit VestingTransfer(address(0), _to, _amount, _vestingTime);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _addToVesting(address _from, address _to, uint256 _vestingTime, uint256 _amount) internal {\r\n        vestingBalanceOf[_to][0] = vestingBalanceOf[_to][0].add(_amount);\r\n\r\n        if(vestingBalanceOf[_to][_vestingTime] == 0)\r\n            vestingTimes[_to].push(_vestingTime);\r\n\r\n        vestingBalanceOf[_to][_vestingTime] = vestingBalanceOf[_to][_vestingTime].add(_amount);\r\n    }\r\n\r\n    /**\r\n      * @dev Burns a specific amount of tokens.\r\n      * @param _value The amount of token to be burned.\r\n      */\r\n    function burn(uint256 _value) public {\r\n        _burn(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _value uint256 The amount of token to be burned\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public {\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n        // this function needs to emit an event with the updated approval.\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        _burn(_from, _value);\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n        _checkMyVesting(_who);\r\n\r\n        require(_value <= accountBalance(_who));\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        emit Burn(_who, _value);\r\n        emit Transfer(_who, address(0), _value);\r\n    }\r\n\r\n    function _checkMyVesting(address _from) internal {\r\n        if (vestingBalanceOf[_from][0] == 0) return;\r\n\r\n        for (uint256 k = 0; k < vestingTimes[_from].length; k++) {\r\n            if (vestingTimes[_from][k] < now) {\r\n                vestingBalanceOf[_from][0] = vestingBalanceOf[_from][0]\r\n                    .sub(vestingBalanceOf[_from][vestingTimes[_from][k]]);\r\n                vestingBalanceOf[_from][vestingTimes[_from][k]] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function accountBalance(address _address) public view returns (uint256 balance) {\r\n        balance = balances[_address];\r\n\r\n        if (vestingBalanceOf[_address][0] == 0) return;\r\n\r\n        for (uint256 k = 0; k < vestingTimes[_address].length; k++) {\r\n            if (vestingTimes[_address][k] >= now) {\r\n                balance = balance.sub(vestingBalanceOf[_address][vestingTimes[_address][k]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addTrustedAccount(address caller) external onlyOwner {\r\n        trustedAccounts[caller] = true;\r\n    }\r\n\r\n    function removeTrustedAccount(address caller) external onlyOwner {\r\n        trustedAccounts[caller] = false;\r\n    }\r\n\r\n    modifier onlyTrusted(address caller) {\r\n        require(trustedAccounts[caller]);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IW12Crowdsale.sol\r\n\r\ninterface IW12Crowdsale {\r\n    function setParameters(uint price) external;\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function setup(\r\n        uint[6][] parametersOfStages,\r\n        uint[] bonusConditionsOfStages,\r\n        uint[4][] parametersOfMilestones,\r\n        uint32[] nameAndDescriptionsOffsetOfMilestones,\r\n        bytes nameAndDescriptionsOfMilestones\r\n    ) external;\r\n\r\n    function getWToken() external view returns(WToken);\r\n\r\n    function getMilestone(uint index) external view returns (uint32, uint, uint32, uint32, bytes, bytes);\r\n\r\n    function getStage(uint index) external view returns (uint32, uint32, uint, uint32, uint[], uint[]);\r\n\r\n    function getCurrentMilestoneIndex() external view returns (uint, bool);\r\n\r\n    function getLastMilestoneIndex() external view returns (uint index, bool found);\r\n\r\n    function milestonesLength() external view returns (uint);\r\n\r\n    function getCurrentStageIndex() external view returns (uint index, bool found);\r\n\r\n    function getSaleVolumeBonus(uint value) external view returns (uint bonus);\r\n\r\n    function isEnded() external view returns (bool);\r\n\r\n    function isSaleActive() external view returns (bool);\r\n\r\n    function () payable external;\r\n\r\n    function buyTokens() payable external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n// File: contracts/interfaces/IW12CrowdsaleFactory.sol\r\n\r\ninterface IW12CrowdsaleFactory {\r\n    function createCrowdsale(\r\n        address tokenAddress,\r\n        address _wTokenAddress,\r\n        uint price,\r\n        address serviceWallet,\r\n        uint serviceFee,\r\n        uint WTokenSaleFeePercent,\r\n        uint trancheFeePercent ,\r\n        address swap,\r\n        address owner\r\n    )\r\n        external returns (IW12Crowdsale);\r\n}\r\n\r\n// File: contracts/libs/Percent.sol\r\n\r\nlibrary Percent {\r\n    using SafeMath for uint;\r\n\r\n    function ADD_EXP() public pure returns (uint) { return 2; }\r\n    function EXP() public pure returns (uint) { return 2 + ADD_EXP(); }\r\n    function MIN() public pure returns (uint) { return 0; }\r\n    function MAX() public pure returns (uint) { return 10 ** EXP(); }\r\n\r\n    function percent(uint _a, uint _b) internal pure returns (uint) {\r\n        require(isPercent(_b));\r\n\r\n        return _a.mul(_b).div(MAX());\r\n    }\r\n\r\n    function isPercent(uint _a) internal pure returns (bool) {\r\n        return _a >= MIN() && _a <= MAX();\r\n    }\r\n\r\n    function toPercent(uint _a) internal pure returns (uint) {\r\n        require(_a <= 100);\r\n\r\n        return _a.mul(10 ** ADD_EXP());\r\n    }\r\n\r\n    function fromPercent(uint _a) internal pure returns (uint) {\r\n        require(isPercent(_a));\r\n\r\n        return _a.div(10 ** ADD_EXP());\r\n    }\r\n}\r\n\r\n// File: contracts/token/exchanger/ITokenExchange.sol\r\n\r\ncontract ITokenExchange {\r\n    function approve(ERC20 token, address spender, uint amount) external returns (bool);\r\n\r\n    function exchange(ERC20 fromToken, uint amount) external;\r\n}\r\n\r\n// File: contracts/token/exchanger/ITokenLedger.sol\r\n\r\ncontract ITokenLedger {\r\n    function addTokenToListing(ERC20 token, WToken wToken) external;\r\n\r\n    function hasPair(ERC20 token1, ERC20 token2) public view returns (bool);\r\n\r\n    function getWTokenByToken(address token) public view returns (WToken wTokenAddress);\r\n\r\n    function getTokenByWToken(address wToken) public view returns (ERC20 tokenAddress);\r\n}\r\n\r\n// File: contracts/token/exchanger/ITokenExchanger.sol\r\n\r\ncontract ITokenExchanger is ITokenExchange, ITokenLedger {}\r\n\r\n// File: contracts/versioning/Versionable.sol\r\n\r\ncontract Versionable {\r\n    uint public version;\r\n\r\n    constructor(uint _version) public {\r\n        version = _version;\r\n    }\r\n}\r\n\r\n// File: contracts/W12Lister.sol\r\n\r\ncontract W12Lister is Versionable, RBAC, Ownable, ReentrancyGuard {\r\n    using SafeMath for uint;\r\n    using Percent for uint;\r\n\r\n    string public ROLE_ADMIN = \"admin\";\r\n\r\n    ITokenExchanger public exchanger;\r\n    IW12CrowdsaleFactory public factory;\r\n    // get token index in approvedTokens list by token address and token owner address\r\n    mapping (address => mapping (address => uint16)) public approvedTokensIndex;\r\n    ListedToken[] public approvedTokens;\r\n    // return owners by token address\r\n    mapping ( address => address[] ) approvedOwnersList;\r\n    uint16 public approvedTokensLength;\r\n    address public serviceWallet;\r\n\r\n    event OwnerWhitelisted(address indexed tokenAddress, address indexed tokenOwner, string name, string symbol);\r\n    event TokenPlaced(address indexed originalTokenAddress, address indexed tokenOwner, uint tokenAmount, address placedTokenAddress);\r\n    event CrowdsaleInitialized(address indexed tokenAddress, address indexed tokenOwner, uint amountForSale);\r\n    event CrowdsaleTokenMinted(address indexed tokenAddress, address indexed tokenOwner, uint amount);\r\n\r\n    struct ListedToken {\r\n        string name;\r\n        string symbol;\r\n        uint8 decimals;\r\n        mapping(address => bool) approvedOwners;\r\n        uint feePercent;\r\n        uint ethFeePercent;\r\n        uint WTokenSaleFeePercent;\r\n        uint trancheFeePercent;\r\n        IW12Crowdsale crowdsaleAddress;\r\n        uint tokensForSaleAmount;\r\n        uint wTokensIssuedAmount;\r\n        address tokenAddress;\r\n    }\r\n\r\n    constructor(\r\n        uint version,\r\n        address _serviceWallet,\r\n        IW12CrowdsaleFactory _factory,\r\n        ITokenExchanger _exchanger\r\n    ) Versionable(version) public {\r\n        require(_serviceWallet != address(0));\r\n        require(_factory != address(0));\r\n        require(_exchanger != address(0));\r\n\r\n        exchanger = _exchanger;\r\n        serviceWallet = _serviceWallet;\r\n        factory = _factory;\r\n        approvedTokens.length++; // zero-index element should never be used\r\n\r\n        addRole(msg.sender, ROLE_ADMIN);\r\n    }\r\n\r\n    function addAdmin(address _operator) public onlyOwner {\r\n        addRole(_operator, ROLE_ADMIN);\r\n    }\r\n\r\n    function removeAdmin(address _operator) public onlyOwner {\r\n        removeRole(_operator, ROLE_ADMIN);\r\n    }\r\n\r\n    function whitelistToken(\r\n        address tokenOwner,\r\n        address tokenAddress,\r\n        string name,\r\n        string symbol,\r\n        uint8 decimals,\r\n        uint feePercent,\r\n        uint ethFeePercent,\r\n        uint WTokenSaleFeePercent,\r\n        uint trancheFeePercent\r\n    )\r\n        external onlyRole(ROLE_ADMIN)\r\n    {\r\n\r\n        require(tokenOwner != address(0));\r\n        require(tokenAddress != address(0));\r\n        require(feePercent.isPercent() && feePercent.fromPercent() < 100);\r\n        require(ethFeePercent.isPercent() && ethFeePercent.fromPercent() < 100);\r\n        require(WTokenSaleFeePercent.isPercent() && WTokenSaleFeePercent.fromPercent() < 100);\r\n        require(trancheFeePercent.isPercent() && trancheFeePercent.fromPercent() < 100);\r\n        require(getApprovedToken(tokenAddress, tokenOwner).tokenAddress != tokenAddress);\r\n        require(!getApprovedToken(tokenAddress, tokenOwner).approvedOwners[tokenOwner]);\r\n\r\n        uint16 index = uint16(approvedTokens.length);\r\n\r\n        approvedTokensIndex[tokenAddress][tokenOwner] = index;\r\n\r\n        approvedTokensLength = uint16(approvedTokens.length++);\r\n\r\n        approvedOwnersList[tokenAddress].push(tokenOwner);\r\n\r\n        approvedTokens[index].approvedOwners[tokenOwner] = true;\r\n        approvedTokens[index].name = name;\r\n        approvedTokens[index].symbol = symbol;\r\n        approvedTokens[index].decimals = decimals;\r\n        approvedTokens[index].feePercent = feePercent;\r\n        approvedTokens[index].ethFeePercent = ethFeePercent;\r\n        approvedTokens[index].WTokenSaleFeePercent = WTokenSaleFeePercent;\r\n        approvedTokens[index].trancheFeePercent = trancheFeePercent;\r\n        approvedTokens[index].tokenAddress = tokenAddress;\r\n\r\n        emit OwnerWhitelisted(tokenAddress, tokenOwner, name, symbol);\r\n    }\r\n\r\n    /**\r\n     * @notice Place token for sale\r\n     * @param tokenAddress Token that will be placed\r\n     * @param amount Token amount to place\r\n     */\r\n    function placeToken(address tokenAddress, uint amount) external nonReentrant {\r\n        require(amount > 0);\r\n        require(tokenAddress != address(0));\r\n        require(getApprovedToken(tokenAddress, msg.sender).tokenAddress == tokenAddress);\r\n        require(getApprovedToken(tokenAddress, msg.sender).approvedOwners[msg.sender]);\r\n\r\n        DetailedERC20 token = DetailedERC20(tokenAddress);\r\n\r\n        require(token.allowance(msg.sender, address(this)) >= amount);\r\n\r\n        ListedToken storage listedToken = getApprovedToken(tokenAddress, msg.sender);\r\n\r\n        require(token.decimals() == listedToken.decimals);\r\n\r\n        uint fee = listedToken.feePercent > 0\r\n            ? amount.percent(listedToken.feePercent)\r\n            : 0;\r\n        uint amountWithoutFee = amount.sub(fee);\r\n\r\n        _secureTokenTransfer(token, exchanger, amountWithoutFee);\r\n        _secureTokenTransfer(token, serviceWallet, fee);\r\n\r\n        listedToken.tokensForSaleAmount = listedToken.tokensForSaleAmount.add(amountWithoutFee);\r\n\r\n        if (exchanger.getWTokenByToken(tokenAddress) == address(0)) {\r\n            WToken wToken = new WToken(listedToken.name, listedToken.symbol, listedToken.decimals);\r\n\r\n            exchanger.addTokenToListing(ERC20(tokenAddress), wToken);\r\n        }\r\n\r\n        emit TokenPlaced(tokenAddress, msg.sender, amountWithoutFee, exchanger.getWTokenByToken(tokenAddress));\r\n    }\r\n\r\n    /**\r\n     * @dev Securely transfer token from sender to account\r\n     */\r\n    function _secureTokenTransfer(ERC20 token, address to, uint value) internal {\r\n        // check for overflow before. we are not sure that the placed token has implemented save math\r\n        uint expectedBalance = token.balanceOf(to).add(value);\r\n\r\n        token.transferFrom(msg.sender, to, value);\r\n\r\n        // check balance to be sure it was filled correctly\r\n        assert(token.balanceOf(to) == expectedBalance);\r\n    }\r\n\r\n    function initCrowdsale(address tokenAddress, uint amountForSale, uint price) external nonReentrant {\r\n        require(getApprovedToken(tokenAddress, msg.sender).approvedOwners[msg.sender] == true);\r\n        require(getApprovedToken(tokenAddress, msg.sender).tokensForSaleAmount >= getApprovedToken(tokenAddress, msg.sender).wTokensIssuedAmount.add(amountForSale));\r\n        require(getApprovedToken(tokenAddress, msg.sender).crowdsaleAddress == address(0));\r\n\r\n        WToken wtoken = exchanger.getWTokenByToken(tokenAddress);\r\n\r\n        IW12Crowdsale crowdsale = factory.createCrowdsale(\r\n            address(tokenAddress),\r\n            address(wtoken),\r\n            price,\r\n            serviceWallet,\r\n            getApprovedToken(tokenAddress, msg.sender).ethFeePercent,\r\n            getApprovedToken(tokenAddress, msg.sender).WTokenSaleFeePercent,\r\n            getApprovedToken(tokenAddress, msg.sender).trancheFeePercent,\r\n            exchanger,\r\n            msg.sender\r\n        );\r\n\r\n        getApprovedToken(tokenAddress, msg.sender).crowdsaleAddress = crowdsale;\r\n        wtoken.addTrustedAccount(crowdsale);\r\n\r\n        if (getApprovedToken(tokenAddress, msg.sender).WTokenSaleFeePercent > 0) {\r\n            exchanger.approve(\r\n                ERC20(tokenAddress),\r\n                address(crowdsale),\r\n                getApprovedToken(tokenAddress, msg.sender).tokensForSaleAmount\r\n                    .percent(getApprovedToken(tokenAddress, msg.sender).WTokenSaleFeePercent)\r\n            );\r\n        }\r\n\r\n        addTokensToCrowdsale(tokenAddress, amountForSale);\r\n\r\n        emit CrowdsaleInitialized(tokenAddress, msg.sender, amountForSale);\r\n    }\r\n\r\n    function addTokensToCrowdsale(address tokenAddress, uint amountForSale) public {\r\n        require(amountForSale > 0);\r\n        require(tokenAddress != address(0));\r\n        require(exchanger.getWTokenByToken(tokenAddress) != address(0));\r\n        require(getApprovedToken(tokenAddress, msg.sender).crowdsaleAddress != address(0));\r\n        require(getApprovedToken(tokenAddress, msg.sender).approvedOwners[msg.sender] == true);\r\n        require(getApprovedToken(tokenAddress, msg.sender).tokensForSaleAmount >= getApprovedToken(tokenAddress, msg.sender).wTokensIssuedAmount.add(amountForSale));\r\n\r\n        WToken token = exchanger.getWTokenByToken(tokenAddress);\r\n        IW12Crowdsale crowdsale = getApprovedToken(tokenAddress, msg.sender).crowdsaleAddress;\r\n\r\n        getApprovedToken(tokenAddress, msg.sender).wTokensIssuedAmount = getApprovedToken(tokenAddress, msg.sender)\r\n            .wTokensIssuedAmount.add(amountForSale);\r\n\r\n        token.mint(crowdsale, amountForSale, 0);\r\n\r\n        emit CrowdsaleTokenMinted(tokenAddress, msg.sender, amountForSale);\r\n    }\r\n\r\n    function getTokenCrowdsale(address tokenAddress, address ownerAddress) view external returns (address) {\r\n        return getApprovedToken(tokenAddress, ownerAddress).crowdsaleAddress;\r\n    }\r\n\r\n    function getTokenOwners(address token) public view returns (address[]) {\r\n        return approvedOwnersList[token];\r\n    }\r\n\r\n    function getExchanger() view external returns (ITokenExchanger) {\r\n        return exchanger;\r\n    }\r\n\r\n    function getApprovedToken(address tokenAddress, address ownerAddress) internal view returns (ListedToken storage result) {\r\n        return approvedTokens[approvedTokensIndex[tokenAddress][ownerAddress]];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amountForSale\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"initCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"feePercent\",\"type\":\"uint256\"},{\"name\":\"ethFeePercent\",\"type\":\"uint256\"},{\"name\":\"WTokenSaleFeePercent\",\"type\":\"uint256\"},{\"name\":\"trancheFeePercent\",\"type\":\"uint256\"},{\"name\":\"crowdsaleAddress\",\"type\":\"address\"},{\"name\":\"tokensForSaleAmount\",\"type\":\"uint256\"},{\"name\":\"wTokensIssuedAmount\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"feePercent\",\"type\":\"uint256\"},{\"name\":\"ethFeePercent\",\"type\":\"uint256\"},{\"name\":\"WTokenSaleFeePercent\",\"type\":\"uint256\"},{\"name\":\"trancheFeePercent\",\"type\":\"uint256\"}],\"name\":\"whitelistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"ownerAddress\",\"type\":\"address\"}],\"name\":\"getTokenCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchanger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchanger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"placeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvedTokensLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amountForSale\",\"type\":\"uint256\"}],\"name\":\"addTokensToCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokensIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"_serviceWallet\",\"type\":\"address\"},{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_exchanger\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"OwnerWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"originalTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"placedTokenAddress\",\"type\":\"address\"}],\"name\":\"TokenPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountForSale\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleTokenMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"}]","ContractName":"W12Lister","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000038274000000000000000000000000246c8e972a0fbdef6896d97a993f8b54dd2a215c000000000000000000000000e1fdf94a363f15ee9bdd711178180d376bd790360000000000000000000000001375144591c8f91daabcd30f64cd7dec6a3c08d4","Library":"","SwarmSource":"bzzr://f10d8b39c34cd3a0bf5b15d31fdf70d66a9508c0c8879f92cb2ee2bb63ebd77b"}]}