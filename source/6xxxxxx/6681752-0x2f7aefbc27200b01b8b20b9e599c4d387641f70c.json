{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: contracts/IAccounting.sol\r\n\r\ninterface IAccounting {\r\n  function contribute(\r\n    address contributor,\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external returns(uint128 deposited, uint128 depositedFees);\r\n\r\n  function withdrawContribution(address contributor) external returns(\r\n    uint128 withdrawn,\r\n    uint128 withdrawnFees\r\n  );\r\n\r\n  function finalize(uint128 amountDisputed) external;\r\n\r\n  function getTotalContribution() external view returns(uint256);\r\n\r\n  function getTotalFeesOffered() external view returns(uint256);\r\n\r\n  function getProjectedFee(uint128 amountDisputed) external view returns(\r\n    uint128 feeNumerator,\r\n    uint128 fundsUsedFromBoundaryBucket\r\n  );\r\n\r\n  function getOwner() external view returns(address);\r\n\r\n  function isFinalized() external view returns(bool);\r\n\r\n  /**\r\n   * Return value is how much REP and dispute tokens the contributor is entitled to.\r\n   *\r\n   * Does not change the state, as accounting is finalized at that moment.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateProceeds(address contributor) external view returns(\r\n    uint128 rep,\r\n    uint128 disputeTokens\r\n  );\r\n\r\n  /**\r\n   * Calculate fee that will be split between contract admin and\r\n   * account that triggered dispute transaction.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateFees() external view returns(uint128);\r\n\r\n  function addFeesOnTop(\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external pure returns(uint128);\r\n}\r\n\r\n// File: contracts/IAccountingFactory.sol\r\n\r\ninterface IAccountingFactory {\r\n  function create(address owner) external returns(IAccounting);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/IDisputer.sol\r\n\r\n/**\r\n * Interface of what the disputer contract should do.\r\n *\r\n * Its main responsibility to interact with Augur. Only minimal glue methods\r\n * are added apart from that in order for crowdsourcer to be able to interact\r\n * with it.\r\n *\r\n * This contract holds the actual crowdsourced REP for dispute, so it doesn't\r\n * need to transfer it from elsewhere at the moment of dispute. It doesn't care\r\n * at all who this REP belongs to, it just spends it for dispute. Accounting\r\n * is done in other contracts.\r\n */\r\ninterface IDisputer {\r\n  /**\r\n   * This function should use as little gas as possible, as it will be called\r\n   * during rush time. Unnecessary operations are postponed for later.\r\n   *\r\n   * Can by called by anyone, but only once.\r\n   */\r\n  function dispute(address feeReceiver) external;\r\n\r\n  // intentionally can be called by anyone, as no user input is used\r\n  function approveManagerToSpendDisputeTokens() external;\r\n\r\n  function getOwner() external view returns(address);\r\n\r\n  function hasDisputed() external view returns(bool);\r\n\r\n  function feeReceiver() external view returns(address);\r\n\r\n  function getREP() external view returns(IERC20);\r\n\r\n  function getDisputeTokenAddress() external view returns(IERC20);\r\n}\r\n\r\n// File: contracts/ICrowdsourcerParent.sol\r\n\r\n/**\r\n * Parent of a crowdsourcer that is passed into it on construction. Used\r\n * to determine destination for fees.\r\n */\r\ninterface ICrowdsourcerParent {\r\n  function getContractFeeReceiver() external view returns(address);\r\n}\r\n\r\n// File: contracts/augur/feeWindow.sol\r\n\r\ninterface FeeWindow {\r\n  function getStartTime() external view returns(uint256);\r\n  function isOver() external view returns(bool);\r\n}\r\n\r\n// File: contracts/augur/universe.sol\r\n\r\ninterface Universe {\r\n  function getDisputeRoundDurationInSeconds() external view returns(uint256);\r\n\r\n  function isForking() external view returns(bool);\r\n\r\n  function isContainerForMarket(address _shadyMarket) external view returns(\r\n    bool\r\n  );\r\n}\r\n\r\n// File: contracts/augur/reportingParticipant.sol\r\n\r\n/**\r\n * This should've been an interface, but interfaces cannot inherit interfaces\r\n */\r\ncontract ReportingParticipant is IERC20 {\r\n  function redeem(address _redeemer) external returns(bool);\r\n  function getStake() external view returns(uint256);\r\n  function getPayoutDistributionHash() external view returns(bytes32);\r\n  function getFeeWindow() external view returns(FeeWindow);\r\n}\r\n\r\n// File: contracts/augur/market.sol\r\n\r\ninterface Market {\r\n  function contribute(\r\n    uint256[] _payoutNumerators,\r\n    bool _invalid,\r\n    uint256 _amount\r\n  ) external returns(bool);\r\n\r\n  function getReputationToken() external view returns(IERC20);\r\n\r\n  function getUniverse() external view returns(Universe);\r\n\r\n  function derivePayoutDistributionHash(\r\n    uint256[] _payoutNumerators,\r\n    bool _invalid\r\n  ) external view returns(bytes32);\r\n\r\n  function getCrowdsourcer(\r\n    bytes32 _payoutDistributionHash\r\n  ) external view returns(ReportingParticipant);\r\n\r\n  function getNumParticipants() external view returns(uint256);\r\n\r\n  function getReportingParticipant(uint256 _index) external view returns(\r\n    ReportingParticipant\r\n  );\r\n\r\n  function isFinalized() external view returns(bool);\r\n\r\n  function getFeeWindow() external view returns(FeeWindow);\r\n\r\n  function getWinningReportingParticipant() external view returns(\r\n    ReportingParticipant\r\n  );\r\n\r\n  function isContainerForReportingParticipant(\r\n    ReportingParticipant _shadyReportingParticipant\r\n  ) external view returns(bool);\r\n}\r\n\r\n// File: contracts/ICrowdsourcer.sol\r\n\r\n/**\r\n * Crowdsourcer for specific market/outcome/round.\r\n */\r\ninterface ICrowdsourcer {\r\n  event ContributionAccepted(\r\n    address contributor,\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  );\r\n\r\n  event ContributionWithdrawn(address contributor, uint128 amount);\r\n\r\n  event CrowdsourcerFinalized(uint128 amountDisputeTokensAcquired);\r\n\r\n  event ProceedsWithdrawn(\r\n    address contributor,\r\n    uint128 disputeTokensAmount,\r\n    uint128 repAmount\r\n  );\r\n\r\n  event FeesWithdrawn(\r\n    address contractAuthor,\r\n    address executor,\r\n    uint128 contractAuthorAmount,\r\n    uint128 executorAmount\r\n  );\r\n\r\n  event Initialized();\r\n\r\n  // initialization stage\r\n  function initialize() external;\r\n\r\n  // pre-dispute stage\r\n  function contribute(uint128 amount, uint128 feeNumerator) external;\r\n\r\n  function withdrawContribution() external;\r\n\r\n  // finalization (after dispute happened)\r\n  function finalize() external;\r\n\r\n  // after finalization\r\n\r\n  // intentionally anyone can call it, since they won't harm contributor\r\n  // by helping them withdraw their proceeds\r\n  function withdrawProceeds(address contributor) external;\r\n\r\n  function withdrawFees() external;\r\n\r\n  function hasDisputed() external view returns(bool);\r\n\r\n  function isInitialized() external view returns(bool);\r\n\r\n  function getParent() external view returns(ICrowdsourcerParent);\r\n\r\n  function getDisputerParams() external view returns(\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  );\r\n\r\n  function getDisputer() external view returns(IDisputer);\r\n\r\n  function getAccounting() external view returns(IAccounting);\r\n\r\n  function getREP() external view returns(IERC20);\r\n\r\n  function getDisputeToken() external view returns(IERC20);\r\n\r\n  function isFinalized() external view returns(bool);\r\n}\r\n\r\n// File: contracts/IDisputerFactory.sol\r\n\r\ninterface IDisputerFactory {\r\n  event DisputerCreated(\r\n    address _owner,\r\n    IDisputer _address,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  );\r\n\r\n  function create(\r\n    address owner,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) external returns(IDisputer);\r\n}\r\n\r\n// File: contracts/DisputerParams.sol\r\n\r\nlibrary DisputerParams {\r\n  struct Params {\r\n    Market market;\r\n    uint256 feeWindowId;\r\n    uint256[] payoutNumerators;\r\n    bool invalid;\r\n  }\r\n}\r\n\r\n// File: contracts/Crowdsourcer.sol\r\n\r\ncontract Crowdsourcer is ICrowdsourcer {\r\n  bool public m_isInitialized = false;\r\n  DisputerParams.Params public m_disputerParams;\r\n  IAccountingFactory public m_accountingFactory;\r\n  IDisputerFactory public m_disputerFactory;\r\n\r\n  IAccounting public m_accounting;\r\n  ICrowdsourcerParent public m_parent;\r\n  IDisputer public m_disputer;\r\n\r\n  mapping(address => bool) public m_proceedsCollected;\r\n  bool public m_feesCollected = false;\r\n\r\n  constructor(\r\n    ICrowdsourcerParent parent,\r\n    IAccountingFactory accountingFactory,\r\n    IDisputerFactory disputerFactory,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) public {\r\n    m_parent = parent;\r\n    m_accountingFactory = accountingFactory;\r\n    m_disputerFactory = disputerFactory;\r\n    m_disputerParams = DisputerParams.Params(\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n  }\r\n\r\n  modifier beforeDisputeOnly() {\r\n    require(!hasDisputed(), \"Method only allowed before dispute\");\r\n    _;\r\n  }\r\n\r\n  modifier requiresInitialization() {\r\n    require(isInitialized(), \"Must call initialize() first\");\r\n    _;\r\n  }\r\n\r\n  modifier requiresFinalization() {\r\n    if (!isFinalized()) {\r\n      finalize();\r\n      assert(isFinalized());\r\n    }\r\n    _;\r\n  }\r\n\r\n  function initialize() external {\r\n    require(!m_isInitialized, \"Already initialized\");\r\n    m_isInitialized = true;\r\n    m_accounting = m_accountingFactory.create(this);\r\n    m_disputer = m_disputerFactory.create(\r\n      this,\r\n      m_disputerParams.market,\r\n      m_disputerParams.feeWindowId,\r\n      m_disputerParams.payoutNumerators,\r\n      m_disputerParams.invalid\r\n    );\r\n    emit Initialized();\r\n  }\r\n\r\n  function contribute(\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external requiresInitialization beforeDisputeOnly {\r\n    uint128 amountWithFees = m_accounting.addFeesOnTop(amount, feeNumerator);\r\n\r\n    IERC20 rep = getREP();\r\n    require(rep.balanceOf(msg.sender) >= amountWithFees, \"Not enough funds\");\r\n    require(\r\n      rep.allowance(msg.sender, this) >= amountWithFees,\r\n      \"Now enough allowance\"\r\n    );\r\n\r\n    // record contribution in accounting (will perform validations)\r\n    uint128 deposited;\r\n    uint128 depositedFees;\r\n    (deposited, depositedFees) = m_accounting.contribute(\r\n      msg.sender,\r\n      amount,\r\n      feeNumerator\r\n    );\r\n\r\n    assert(deposited == amount);\r\n    assert(deposited + depositedFees == amountWithFees);\r\n\r\n    // actually transfer tokens and revert tx if any problem\r\n    assert(rep.transferFrom(msg.sender, m_disputer, deposited));\r\n    assert(rep.transferFrom(msg.sender, this, depositedFees));\r\n\r\n    assertBalancesBeforeDispute();\r\n\r\n    emit ContributionAccepted(msg.sender, amount, feeNumerator);\r\n  }\r\n\r\n  function withdrawContribution(\r\n\r\n  ) external requiresInitialization beforeDisputeOnly {\r\n    IERC20 rep = getREP();\r\n\r\n    // record withdrawal in accounting (will perform validations)\r\n    uint128 withdrawn;\r\n    uint128 withdrawnFees;\r\n    (withdrawn, withdrawnFees) = m_accounting.withdrawContribution(msg.sender);\r\n\r\n    // actually transfer tokens and revert tx if any problem\r\n    assert(rep.transferFrom(m_disputer, msg.sender, withdrawn));\r\n    assert(rep.transfer(msg.sender, withdrawnFees));\r\n\r\n    assertBalancesBeforeDispute();\r\n\r\n    emit ContributionWithdrawn(msg.sender, withdrawn);\r\n  }\r\n\r\n  function withdrawProceeds(address contributor) external requiresFinalization {\r\n    require(\r\n      !m_proceedsCollected[contributor],\r\n      \"Can only collect proceeds once\"\r\n    );\r\n\r\n    // record proceeds have been collected\r\n    m_proceedsCollected[contributor] = true;\r\n\r\n    uint128 refund;\r\n    uint128 proceeds;\r\n\r\n    // calculate how much this contributor is entitled to\r\n    (refund, proceeds) = m_accounting.calculateProceeds(contributor);\r\n\r\n    IERC20 rep = getREP();\r\n    IERC20 disputeTokenAddress = getDisputeToken();\r\n\r\n    // actually deliver the proceeds/refund\r\n    assert(rep.transfer(contributor, refund));\r\n    assert(disputeTokenAddress.transfer(contributor, proceeds));\r\n\r\n    emit ProceedsWithdrawn(contributor, proceeds, refund);\r\n  }\r\n\r\n  function withdrawFees() external requiresFinalization {\r\n    require(!m_feesCollected, \"Can only collect fees once\");\r\n\r\n    m_feesCollected = true;\r\n\r\n    uint128 feesTotal = m_accounting.calculateFees();\r\n    // 10% of fees go to contract author\r\n    uint128 feesForContractAuthor = feesTotal / 10;\r\n    uint128 feesForExecutor = feesTotal - feesForContractAuthor;\r\n\r\n    assert(feesForContractAuthor + feesForExecutor == feesTotal);\r\n\r\n    address contractFeesRecipient = m_parent.getContractFeeReceiver();\r\n    address executorFeesRecipient = m_disputer.feeReceiver();\r\n\r\n    IERC20 rep = getREP();\r\n\r\n    assert(rep.transfer(contractFeesRecipient, feesForContractAuthor));\r\n    assert(rep.transfer(executorFeesRecipient, feesForExecutor));\r\n\r\n    emit FeesWithdrawn(\r\n      contractFeesRecipient,\r\n      executorFeesRecipient,\r\n      feesForContractAuthor,\r\n      feesForExecutor\r\n    );\r\n  }\r\n\r\n  function getParent() external view returns(ICrowdsourcerParent) {\r\n    return m_parent;\r\n  }\r\n\r\n  function getDisputerParams() external view returns(\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) {\r\n    return (m_disputerParams.market, m_disputerParams.feeWindowId, m_disputerParams.payoutNumerators, m_disputerParams.invalid);\r\n  }\r\n\r\n  function getDisputer() external view requiresInitialization returns(\r\n    IDisputer\r\n  ) {\r\n    return m_disputer;\r\n  }\r\n\r\n  function getAccounting() external view requiresInitialization returns(\r\n    IAccounting\r\n  ) {\r\n    return m_accounting;\r\n  }\r\n\r\n  function finalize() public requiresInitialization {\r\n    require(hasDisputed(), \"Can only finalize after dispute\");\r\n    require(!isFinalized(), \"Can only finalize once\");\r\n\r\n    // now that we've disputed we must know dispute token address\r\n    IERC20 disputeTokenAddress = getDisputeToken();\r\n    IERC20 rep = getREP();\r\n\r\n    m_disputer.approveManagerToSpendDisputeTokens();\r\n\r\n    // retrieve all tokens from disputer for proceeds distribution\r\n    // This wouldn't work extremely well if it is called from disputer's\r\n    // dispute() method, but it should only call Augur which we trust.\r\n    assert(rep.transferFrom(m_disputer, this, rep.balanceOf(m_disputer)));\r\n    assert(\r\n      disputeTokenAddress.transferFrom(\r\n        m_disputer,\r\n        this,\r\n        disputeTokenAddress.balanceOf(m_disputer)\r\n      )\r\n    );\r\n\r\n    uint256 amountDisputed = disputeTokenAddress.balanceOf(this);\r\n    uint128 amountDisputed128 = uint128(amountDisputed);\r\n\r\n    // REP has only so many tokens\r\n    assert(amountDisputed128 == amountDisputed);\r\n\r\n    m_accounting.finalize(amountDisputed128);\r\n\r\n    assert(isFinalized());\r\n\r\n    emit CrowdsourcerFinalized(amountDisputed128);\r\n  }\r\n\r\n  function isInitialized() public view returns(bool) {\r\n    return m_isInitialized;\r\n  }\r\n\r\n  function getREP() public view requiresInitialization returns(IERC20) {\r\n    return m_disputer.getREP();\r\n  }\r\n\r\n  function getDisputeToken() public view requiresInitialization returns(\r\n    IERC20\r\n  ) {\r\n    return m_disputer.getDisputeTokenAddress();\r\n  }\r\n\r\n  function hasDisputed() public view requiresInitialization returns(bool) {\r\n    return m_disputer.hasDisputed();\r\n  }\r\n\r\n  function isFinalized() public view requiresInitialization returns(bool) {\r\n    return m_accounting.isFinalized();\r\n  }\r\n\r\n  function assertBalancesBeforeDispute() internal view {\r\n    IERC20 rep = getREP();\r\n    assert(rep.balanceOf(m_disputer) >= m_accounting.getTotalContribution());\r\n    assert(rep.balanceOf(this) >= m_accounting.getTotalFeesOffered());\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"m_parent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_accounting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_accountingFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccounting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputerParams\",\"outputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"m_proceedsCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"withdrawProceeds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getREP\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"feeNumerator\",\"type\":\"uint128\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_disputerFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_disputer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_disputerParams\",\"outputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_feesCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasDisputed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"parent\",\"type\":\"address\"},{\"name\":\"accountingFactory\",\"type\":\"address\"},{\"name\":\"disputerFactory\",\"type\":\"address\"},{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"feeNumerator\",\"type\":\"uint128\"}],\"name\":\"ContributionAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"ContributionWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amountDisputeTokensAcquired\",\"type\":\"uint128\"}],\"name\":\"CrowdsourcerFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"disputeTokensAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"repAmount\",\"type\":\"uint128\"}],\"name\":\"ProceedsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractAuthor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contractAuthorAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"executorAmount\",\"type\":\"uint128\"}],\"name\":\"FeesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"}]","ContractName":"Crowdsourcer","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030dddd46a281c431638be6228a7fee20b1bedbf1000000000000000000000000eea0720d1d28dfb7b583d1d886668dc81367b2590000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://a47537033bdcc06c5cccc052f955683c24e8c1d6de26ff999423d923c6c4610a"}]}