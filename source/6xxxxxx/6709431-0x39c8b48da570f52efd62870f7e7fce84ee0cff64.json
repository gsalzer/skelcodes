{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts\\abstract\\Pool\\IRoleModel.sol\r\n\r\ncontract IRoleModel {\r\n  /**\r\n  * @dev RL_DEFAULT is role of basic account for example: investor\r\n  */\r\n  uint8 constant RL_DEFAULT = 0x00;\r\n  \r\n  /**\r\n  * @dev RL_POOL_MANAGER is role of person who will initialize pooling contract by asking admin to create it\r\n  * this person will find ICO and investors\r\n  */\r\n  uint8 constant RL_POOL_MANAGER = 0x01;\r\n  \r\n  /**\r\n  * @dev RL_ICO_MANAGER is role of person who have access to ICO contract as owner or tokenholder\r\n  */\r\n  uint8 constant RL_ICO_MANAGER = 0x02;\r\n  \r\n  /**\r\n  * @dev RL_ADMIN is role of person who create contract (BANKEX admin)\r\n  */\r\n  uint8 constant RL_ADMIN = 0x04;\r\n  \r\n  /**\r\n  * @dev RL_PAYBOT is like admin but without some capabilities that RL_ADMIN has\r\n  */\r\n  uint8 constant RL_PAYBOT = 0x08;\r\n\r\n  function getRole_() view internal returns(uint8);\r\n  function getRole_(address _for) view internal returns(uint8);\r\n  function getRoleAddress_(uint8 _for) view internal returns(address);\r\n  \r\n}\r\n\r\n// File: contracts\\abstract\\Pool\\IStateModel.sol\r\n\r\ncontract IStateModel {\r\n  /**\r\n  * @dev ST_DEFAULT state of contract when pooling manager didn't start raising\r\n  * it is an initialization state\r\n  */\r\n  uint8 constant ST_DEFAULT = 0x00;\r\n  \r\n  /**\r\n  * @dev ST_RAISING state of contract when contract is collecting ETH for ICO manager\r\n  */\r\n  uint8 constant ST_RAISING = 0x01;\r\n  \r\n  /**\r\n  * @dev ST_WAIT_FOR_ICO state of contract when contract is waiting for tokens from ICO manager\r\n  */\r\n  uint8 constant ST_WAIT_FOR_ICO = 0x02;\r\n  \r\n  /**\r\n  * @dev ST_MONEY_BACK state of contract when contract return all ETH back to investors\r\n  * it is unusual situation that occurred only if there are some problems\r\n  */\r\n  uint8 constant ST_MONEY_BACK = 0x04;\r\n  \r\n  /**\r\n  * @dev ST_TOKEN_DISTRIBUTION state of contract when contract return all tokens to investors\r\n  * if investor have some ETH that are not taken by ICO manager\r\n  * it is possible to take this ETH back too\r\n  */\r\n  uint8 constant ST_TOKEN_DISTRIBUTION = 0x08;\r\n  \r\n  /**\r\n  * @dev ST_FUND_DEPRECATED state of contract when all functions of contract will not work\r\n  * they will work only for Admin\r\n  * state means that contract lifecycle is ended\r\n  */\r\n  uint8 constant ST_FUND_DEPRECATED = 0x10;\r\n  \r\n  /**\r\n  * @dev TST_DEFAULT time state of contract when contract is waiting to be triggered by pool manager\r\n  */\r\n  uint8 constant TST_DEFAULT = 0x00;\r\n  \r\n  /**\r\n  * @dev TST_RAISING time state of contract when contract is collecting ETH for ICO manager\r\n  */\r\n  uint8 constant TST_RAISING = 0x01;\r\n  \r\n  /**\r\n  * @dev TST_WAIT_FOR_ICO time state of contract when contract is waiting for tokens from ICO manager\r\n  */\r\n  uint8 constant TST_WAIT_FOR_ICO = 0x02;\r\n  \r\n  /**\r\n  * @dev TST_TOKEN_DISTRIBUTION time state of contract when contract return all tokens to investors\r\n  */\r\n  uint8 constant TST_TOKEN_DISTRIBUTION = 0x08;\r\n  \r\n  /**\r\n  * @dev TST_FUND_DEPRECATED time state of contract when all functions of contract will not work\r\n  * they will work only for Admin\r\n  * state means that contract lifecycle is ended\r\n  */\r\n  uint8 constant TST_FUND_DEPRECATED = 0x10;\r\n  \r\n  /**\r\n  * @dev RST_NOT_COLLECTED state of contract when amount ETH is less than minimal amount to buy tokens\r\n  */\r\n  uint8 constant RST_NOT_COLLECTED = 0x01;\r\n  \r\n  /**\r\n  * @dev RST_COLLECTED state of contract when amount ETH is more than minimal amount to buy tokens\r\n  */\r\n  uint8 constant RST_COLLECTED = 0x02;\r\n  \r\n  /**\r\n  * @dev RST_FULL state of contract when amount ETH is more than maximal amount to buy tokens\r\n  */\r\n  uint8 constant RST_FULL = 0x04;\r\n\r\n  function getState_() internal view returns (uint8);\r\n  function getShareRemaining_() internal view returns(uint);\r\n}\r\n\r\n// File: contracts\\abstract\\Pool\\RoleModel.sol\r\n\r\ncontract RoleModel is IRoleModel{\r\n  mapping (address => uint8) internal role_;\r\n  mapping (uint8 => address) internal roleAddress_;\r\n  \r\n  function setRole_(uint8 _for, address _afor) internal returns(bool) {\r\n    require((role_[_afor] == 0) && (roleAddress_[_for] == address(0)));\r\n    role_[_afor] = _for;\r\n    roleAddress_[_for] = _afor;\r\n  }\r\n\r\n  function getRole_() view internal returns(uint8) {\r\n    return role_[msg.sender];\r\n  }\r\n\r\n  function getRole_(address _for) view internal returns(uint8) {\r\n    return role_[_for];\r\n  }\r\n\r\n  function getRoleAddress_(uint8 _for) view internal returns(address) {\r\n    return roleAddress_[_for];\r\n  }\r\n  \r\n  /**\r\n  * @dev It returns role in pooling of account address that you sent via param\r\n  * @param _targetAddress is an address of account to return account's role\r\n  * @return role of account (0 if RL_DEFAULT, 1 if RL_POOL_MANAGER, 2 if RL_ICO_MANAGER, 4 if RL_ADMIN, 8 if RL_PAYBOT)\r\n  */\r\n  function getRole(address _targetAddress) external view returns(uint8){\r\n    return role_[_targetAddress];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts\\abstract\\TimeMachine\\ITimeMachine.sol\r\n\r\ncontract ITimeMachine {\r\n  function getTimestamp_() internal view returns (uint);\r\n}\r\n\r\n// File: contracts\\abstract\\Pool\\IShareStore.sol\r\n\r\ncontract IShareStore {\r\n  function getTotalShare_() internal view returns(uint);\r\n  \r\n  /**\r\n  * @dev event which is triggered every time when somebody send ETH during raising period\r\n  * @param addr is an address of account who sent ETH\r\n  * @param value is a sum in ETH which account sent to pooling contract\r\n  */\r\n  event BuyShare(address indexed addr, uint value);\r\n  \r\n  /**\r\n  * @dev event which is triggered every time when somebody will return it's ETH back during money back period\r\n  * @param addr is an address of account. Pooling contract send ETH to this address\r\n  * @param value is a sum in ETH which was sent from pooling\r\n  */\r\n  event RefundShare(address indexed addr, uint value);\r\n  \r\n  /**\r\n  * @dev event which is triggered every time when stakeholder get ETH from contract\r\n  * @param role is a role of stakeholder (for example: 4 is RL_ADMIN)\r\n  * @param addr is an address of account. Pooling contract send ETH to this address\r\n  * @param value is a sum in ETH which was sent from pooling\r\n  */\r\n  event ReleaseEtherToStakeholder(uint8 indexed role, address indexed addr, uint value);\r\n  \r\n  /**\r\n  * @dev event which is triggered when ICO manager show that value amount of tokens were approved to this contract\r\n  * @param addr is an address of account who trigger function (ICO manager)\r\n  * @param value is a sum in tokens which ICO manager approve to this contract\r\n  */\r\n  event AcceptTokenFromICO(address indexed addr, uint value);\r\n  \r\n  /**\r\n  * @dev event which is triggered every time when somebody will return it's ETH back during token distribution period\r\n  * @param addr is an address of account. Pooling contract send ETH to this address\r\n  * @param value is a sum in ETH which was sent from pooling\r\n  */\r\n  event ReleaseEther(address indexed addr, uint value);\r\n  \r\n  /**\r\n  * @dev event which is triggered every time when somebody will return it's tokens back during token distribution period\r\n  * @param addr is an address of account. Pooling contract send tokens to this address\r\n  * @param value is a sum in tokens which was sent from pooling\r\n  */\r\n  event ReleaseToken(address indexed addr, uint value);\r\n\r\n}\r\n\r\n// File: contracts\\libs\\math\\SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts\\abstract\\Pool\\StateModel.sol\r\n\r\ncontract StateModel is IRoleModel, IShareStore, IStateModel, ITimeMachine {\r\n  using SafeMath for uint;\r\n  /**\r\n   * @dev time to start accepting ETH from investors\r\n   */\r\n  uint public launchTimestamp;\r\n\r\n  /**\r\n   * @dev time to raise ETH for ICO\r\n   */\r\n  uint public raisingPeriod;\r\n\r\n  /**\r\n   * @dev time to wait tokens from ICO manager\r\n   */\r\n  uint public icoPeriod;\r\n\r\n  /**\r\n   * @dev time to distribute tokens and remaining ETH to investors\r\n   */\r\n  uint public distributionPeriod;\r\n\r\n  /**\r\n   * @dev minimal collected fund in ETH\r\n   */\r\n  uint public minimalFundSize;\r\n  \r\n  /**\r\n   * @dev maximal collected fund in ETH\r\n   */\r\n  uint public maximalFundSize;\r\n  \r\n  uint8 internal initialState_;\r\n\r\n  function getShareRemaining_() internal view returns(uint)\r\n  {\r\n    return maximalFundSize.sub(getTotalShare_());\r\n  }\r\n \r\n  function getTimeState_() internal view returns (uint8) {\r\n    uint _launchTimestamp = launchTimestamp;\r\n    uint _relativeTimestamp = getTimestamp_() - _launchTimestamp;\r\n    if (_launchTimestamp == 0)\r\n      return TST_DEFAULT;\r\n    if (_relativeTimestamp < raisingPeriod)\r\n      return TST_RAISING;\r\n    if (_relativeTimestamp < icoPeriod)\r\n      return TST_WAIT_FOR_ICO;\r\n    if (_relativeTimestamp < distributionPeriod)\r\n      return TST_TOKEN_DISTRIBUTION;\r\n    return TST_FUND_DEPRECATED;\r\n  }\r\n\r\n  function getRaisingState_() internal view returns(uint8) {\r\n    uint _totalEther = getTotalShare_();\r\n    if (_totalEther < minimalFundSize) \r\n      return RST_NOT_COLLECTED;\r\n    if (_totalEther < maximalFundSize)\r\n      return RST_COLLECTED;\r\n    return RST_FULL;\r\n  }\r\n\r\n  function getState_() internal view returns (uint8) {\r\n    uint _initialState = initialState_;\r\n    uint _timeState = getTimeState_();\r\n    uint _raisingState = getRaisingState_();\r\n    return getState_(_initialState, _timeState, _raisingState);\r\n  }\r\n  \r\n  function getState_(uint _initialState, uint _timeState, uint _raisingState) private pure returns (uint8) {\r\n    if (_initialState == ST_DEFAULT) return ST_DEFAULT;\r\n\r\n    if (_initialState == ST_RAISING) {\r\n      if (_timeState == TST_RAISING) {\r\n        if (_raisingState == RST_FULL) {\r\n          return ST_WAIT_FOR_ICO;\r\n        }\r\n        return ST_RAISING;\r\n      }\r\n      if (_raisingState == RST_NOT_COLLECTED && (_timeState == TST_WAIT_FOR_ICO || _timeState == TST_TOKEN_DISTRIBUTION)) {\r\n        return ST_MONEY_BACK;\r\n      }\r\n      if (_timeState == TST_WAIT_FOR_ICO) {\r\n        return ST_WAIT_FOR_ICO;\r\n      }\r\n      if (_timeState == TST_TOKEN_DISTRIBUTION) {\r\n        return ST_TOKEN_DISTRIBUTION;\r\n      }\r\n      return ST_FUND_DEPRECATED;\r\n    }\r\n\r\n    if (_initialState == ST_WAIT_FOR_ICO) {\r\n      if (_timeState == TST_RAISING || _timeState == TST_WAIT_FOR_ICO) {\r\n        return ST_WAIT_FOR_ICO;\r\n      }\r\n      if (_timeState == TST_TOKEN_DISTRIBUTION) {\r\n        return ST_TOKEN_DISTRIBUTION;\r\n      }\r\n      return ST_FUND_DEPRECATED;\r\n    }\r\n\r\n    if (_initialState == ST_MONEY_BACK) {\r\n      if (_timeState == TST_RAISING || _timeState == TST_WAIT_FOR_ICO || _timeState == TST_TOKEN_DISTRIBUTION) {\r\n        return ST_MONEY_BACK;\r\n      }\r\n      return ST_FUND_DEPRECATED;\r\n    }\r\n    \r\n    if (_initialState == ST_TOKEN_DISTRIBUTION) {\r\n      if (_timeState == TST_RAISING || _timeState == TST_WAIT_FOR_ICO || _timeState == TST_TOKEN_DISTRIBUTION) {\r\n        return ST_TOKEN_DISTRIBUTION;\r\n      }\r\n      return ST_FUND_DEPRECATED;\r\n    }\r\n\r\n    return ST_FUND_DEPRECATED;\r\n  }\r\n  \r\n  function setState_(uint _stateNew) internal returns (bool) {\r\n    uint _initialState = initialState_;\r\n    uint _timeState = getTimeState_();\r\n    uint _raisingState = getRaisingState_();\r\n    uint8 _state = getState_(_initialState, _timeState, _raisingState);\r\n    uint8 _role = getRole_();\r\n\r\n    if (_stateNew == ST_RAISING) {\r\n      if ((_role == RL_POOL_MANAGER) && (_state == ST_DEFAULT)) {\r\n        launchTimestamp = getTimestamp_();\r\n        initialState_ = ST_RAISING;\r\n        return true;\r\n      }\r\n      revert();\r\n    }\r\n\r\n    if (_stateNew == ST_WAIT_FOR_ICO) {\r\n      if ((_role == RL_POOL_MANAGER || _role == RL_ICO_MANAGER) && (_raisingState == RST_COLLECTED)) {\r\n        initialState_ = ST_WAIT_FOR_ICO;\r\n        return true;\r\n      }\r\n      revert();\r\n    }\r\n\r\n    if (_stateNew == ST_MONEY_BACK) {\r\n      if ((_role == RL_POOL_MANAGER || _role == RL_ADMIN || _role == RL_PAYBOT) && (_state == ST_RAISING)) {\r\n        initialState_ = ST_MONEY_BACK;\r\n        return true;\r\n      }\r\n      revert();\r\n    }\r\n\r\n    if (_stateNew == ST_TOKEN_DISTRIBUTION) {\r\n      if ((_role == RL_POOL_MANAGER || _role == RL_ADMIN || _role == RL_ICO_MANAGER || _role == RL_PAYBOT) && (_state == ST_WAIT_FOR_ICO)) {\r\n        initialState_ = ST_TOKEN_DISTRIBUTION;\r\n        return true;\r\n      }\r\n      revert();\r\n    }\r\n\r\n    revert();\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Returns state of pooling (for example: raising)\r\n  * @return state (0 if ST_DEFAULT, 1 if ST_RAISING, 2 if ST_WAIT_FOR_ICO, 4 if ST_MONEY_BACK, 8 if ST_TOKEN_DISTRIBUTION, 10 if ST_FUND_DEPRECATED)\r\n  */\r\n  function getState() external view returns(uint8) {\r\n    return getState_();\r\n  }\r\n  \r\n  /**\r\n  * @dev Allow to set state by stakeholders\r\n  * @return result of operation, true if success\r\n  */\r\n  function setState(uint newState) external returns(bool) {\r\n    return setState_(newState);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts\\libs\\token\\ERC20\\IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20{\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address who) external view returns (uint);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  \r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// File: contracts\\abstract\\Pool\\ShareStore.sol\r\n\r\ncontract ShareStore is IRoleModel, IShareStore, IStateModel {\r\n  \r\n  using SafeMath for uint;\r\n  \r\n  /**\r\n  * @dev minimal amount of ETH in wei which is allowed to become investor\r\n  */\r\n  uint public minimalDeposit;\r\n  \r\n  /**\r\n  * @dev address of ERC20 token of ICO\r\n  */\r\n  address public tokenAddress;\r\n  \r\n  /**\r\n  * @dev investors balance which they have if they sent ETH during RAISING state\r\n  */\r\n  mapping (address=>uint) public share;\r\n  \r\n  /**\r\n  * @dev total amount of ETH collected from investors  in wei\r\n  */\r\n  uint public totalShare;\r\n  \r\n  /**\r\n  * @dev total amount of tokens collected from ERC20 contract\r\n  */\r\n  uint public totalToken;\r\n  \r\n  /**\r\n  * @dev total amount of ETH which stake holder can get\r\n  */\r\n  mapping (uint8=>uint) public stakeholderShare;\r\n  mapping (address=>uint) internal etherReleased_;\r\n  mapping (address=>uint) internal tokenReleased_;\r\n  mapping (uint8=>uint) internal stakeholderEtherReleased_;\r\n  uint constant DECIMAL_MULTIPLIER = 1e18;\r\n\r\n  /**\r\n  * @dev price of one token in ethers\r\n  */\r\n  uint public tokenPrice;\r\n  \r\n  /**\r\n  * @dev payable function which does:\r\n  * If current state = ST_RASING - allows to send ETH for future tokens\r\n  * If current state = ST_MONEY_BACK - will send back all ETH that msg.sender has on balance\r\n  * If current state = ST_TOKEN_DISTRIBUTION - will reurn all ETH and Tokens that msg.sender has on balance\r\n  * in case of ST_MONEY_BACK or ST_TOKEN_DISTRIBUTION all ETH sum will be sent back (sum to trigger this function)\r\n  */\r\n  function () public payable {\r\n    uint8 _state = getState_();\r\n    if (_state == ST_RAISING){\r\n      buyShare_(_state);\r\n      return;\r\n    }\r\n    \r\n    if (_state == ST_MONEY_BACK) {\r\n      refundShare_(msg.sender, share[msg.sender]);\r\n      if(msg.value > 0)\r\n        msg.sender.transfer(msg.value);\r\n      return;\r\n    }\r\n    \r\n    if (_state == ST_TOKEN_DISTRIBUTION) {\r\n      releaseEther_(msg.sender, getBalanceEtherOf_(msg.sender));\r\n      releaseToken_(msg.sender, getBalanceTokenOf_(msg.sender));\r\n      if(msg.value > 0)\r\n        msg.sender.transfer(msg.value);\r\n      return;\r\n    }\r\n    revert();\r\n  }\r\n  \r\n  \r\n  /**\r\n  * @dev Allow to buy part of tokens if current state is RAISING\r\n  * @return result of operation, true if success\r\n  */\r\n  function buyShare() external payable returns(bool) {\r\n    return buyShare_(getState_());\r\n  }\r\n  \r\n  /**\r\n  * @dev Allow (Important) ICO manager to say that _value amount of tokens is approved from ERC20 contract to this contract\r\n  * @param _value amount of tokens that ICO manager approve from it's ERC20 contract to this contract\r\n  * @return result of operation, true if success\r\n  */\r\n  function acceptTokenFromICO(uint _value) external returns(bool) {\r\n    return acceptTokenFromICO_(_value);\r\n  }\r\n  \r\n  /**\r\n  * @dev Returns amount of ETH that stake holder (for example: ICO manager) can release from this contract\r\n  * @param _for role of stakeholder (for example: 2)\r\n  * @return amount of ETH in wei\r\n  */\r\n  function getStakeholderBalanceOf(uint8 _for) external view returns(uint) {\r\n    return getStakeholderBalanceOf_(_for);\r\n  }\r\n  \r\n  /**\r\n  * @dev Returns amount of ETH that person can release from this contract\r\n  * @param _for address of person\r\n  * @return amount of ETH in wei\r\n  */\r\n  function getBalanceEtherOf(address _for) external view returns(uint) {\r\n    return getBalanceEtherOf_(_for);\r\n  }\r\n  \r\n  /**\r\n  * @dev Returns amount of tokens that person can release from this contract\r\n  * @param _for address of person\r\n  * @return amount of tokens\r\n  */\r\n  function getBalanceTokenOf(address _for) external view returns(uint) {\r\n    return getBalanceTokenOf_(_for);\r\n  }\r\n  \r\n  /**\r\n  * @dev Release amount of ETH to msg.sender (must be stakeholder)\r\n  * @param _value amount of ETH in wei\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseEtherToStakeholder(uint _value) external returns(bool) {\r\n    uint8 _state = getState_();\r\n    uint8 _for = getRole_();\r\n    require(!((_for == RL_ICO_MANAGER) && ((_state != ST_WAIT_FOR_ICO) || (tokenPrice > 0))));\r\n    return releaseEtherToStakeholder_(_state, _for, _value);\r\n  }\r\n  \r\n  /**\r\n  * @dev Release amount of ETH to stakeholder by admin or paybot\r\n  * @param _for stakeholder role (for example: 2)\r\n  * @param _value amount of ETH in wei\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseEtherToStakeholderForce(uint8 _for, uint _value) external returns(bool) {\r\n    uint8 _role = getRole_();\r\n    require((_role==RL_ADMIN) || (_role==RL_PAYBOT));\r\n    uint8 _state = getState_();\r\n    require(!((_for == RL_ICO_MANAGER) && ((_state != ST_WAIT_FOR_ICO) || (tokenPrice > 0))));\r\n    return releaseEtherToStakeholder_(_state, _for, _value);\r\n  }\r\n  \r\n  /**\r\n  * @dev Release amount of ETH to msg.sender\r\n  * @param _value amount of ETH in wei\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseEther(uint _value) external returns(bool) {\r\n    uint8 _state = getState_();\r\n    require(_state == ST_TOKEN_DISTRIBUTION);\r\n    return releaseEther_(msg.sender, _value);\r\n  }\r\n  \r\n  /**\r\n  * @dev Release amount of ETH to person by admin or paybot\r\n  * @param _for address of person\r\n  * @param _value amount of ETH in wei\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseEtherForce(address _for, uint _value) external returns(bool) {\r\n    uint8 _role = getRole_();\r\n    uint8 _state = getState_();\r\n    require(_state == ST_TOKEN_DISTRIBUTION);\r\n    require((_role==RL_ADMIN) || (_role==RL_PAYBOT));\r\n    return releaseEther_(_for, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Release amount of ETH to person by admin or paybot\r\n  * @param _for addresses of persons\r\n  * @param _value amounts of ETH in wei\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseEtherForceMulti(address[] _for, uint[] _value) external returns(bool) {\r\n    uint _sz = _for.length;\r\n    require(_value.length == _sz);\r\n    uint8 _role = getRole_();\r\n    uint8 _state = getState_();\r\n    require(_state == ST_TOKEN_DISTRIBUTION);\r\n    require((_role==RL_ADMIN) || (_role==RL_PAYBOT));\r\n    for (uint i = 0; i < _sz; i++){\r\n      require(releaseEther_(_for[i], _value[i]));\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Release amount of tokens to msg.sender\r\n  * @param _value amount of tokens\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseToken(uint _value) external returns(bool) {\r\n    uint8 _state = getState_();\r\n    require(_state == ST_TOKEN_DISTRIBUTION);\r\n    return releaseToken_(msg.sender, _value);\r\n  }\r\n  \r\n  /**\r\n  * @dev Release amount of tokens to person by admin or paybot\r\n  * @param _for address of person\r\n  * @param _value amount of tokens\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseTokenForce(address _for, uint _value) external returns(bool) {\r\n    uint8 _role = getRole_();\r\n    uint8 _state = getState_();\r\n    require(_state == ST_TOKEN_DISTRIBUTION);\r\n    require((_role==RL_ADMIN) || (_role==RL_PAYBOT));\r\n    return releaseToken_(_for, _value);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Release amount of tokens to person by admin or paybot\r\n  * @param _for addresses of persons\r\n  * @param _value amounts of tokens\r\n  * @return result of operation, true if success\r\n  */\r\n  function releaseTokenForceMulti(address[] _for, uint[] _value) external returns(bool) {\r\n    uint _sz = _for.length;\r\n    require(_value.length == _sz);\r\n    uint8 _role = getRole_();\r\n    uint8 _state = getState_();\r\n    require(_state == ST_TOKEN_DISTRIBUTION);\r\n    require((_role==RL_ADMIN) || (_role==RL_PAYBOT));\r\n    for(uint i = 0; i < _sz; i++){\r\n      require(releaseToken_(_for[i], _value[i]));\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Allow to return ETH back to msg.sender if state Money back\r\n  * @param _value amount of ETH in wei\r\n  * @return result of operation, true if success\r\n  */\r\n  function refundShare(uint _value) external returns(bool) {\r\n    uint8 _state = getState_();\r\n    require (_state == ST_MONEY_BACK);\r\n    return refundShare_(msg.sender, _value);\r\n  }\r\n  \r\n  /**\r\n  * @dev Allow to return ETH back to person by admin or paybot if state Money back\r\n  * @param _for address of person\r\n  * @param _value amount of ETH in wei\r\n  * @return result of operation, true if success\r\n  */\r\n  function refundShareForce(address _for, uint _value) external returns(bool) {\r\n    uint8 _state = getState_();\r\n    uint8 _role = getRole_();\r\n    require(_role == RL_ADMIN || _role == RL_PAYBOT);\r\n    require (_state == ST_MONEY_BACK || _state == ST_RAISING);\r\n    return refundShare_(_for, _value);\r\n  }\r\n  \r\n  /**\r\n  * @dev Allow to use functions of other contract from this contract\r\n  * @param _to address of contract to call\r\n  * @param _value amount of ETH in wei\r\n  * @param _data contract function call in bytes type\r\n  * @return result of operation, true if success\r\n  */\r\n  function execute(address _to, uint _value, bytes _data) external returns (bool) {\r\n    require (getRole_()==RL_ADMIN);\r\n    require (getState_()==ST_FUND_DEPRECATED);\r\n    /* solium-disable-next-line */\r\n    return _to.call.value(_value)(_data);\r\n  }\r\n  \r\n  function getTotalShare_() internal view returns(uint){\r\n    return totalShare;\r\n  }\r\n\r\n  function getEtherCollected_() internal view returns(uint){\r\n    return totalShare;\r\n  }\r\n\r\n  function buyShare_(uint8 _state) internal returns(bool) {\r\n    require(_state == ST_RAISING);\r\n    require(msg.value >= minimalDeposit);\r\n    uint _shareRemaining = getShareRemaining_();\r\n    uint _shareAccept = (msg.value <= _shareRemaining) ? msg.value : _shareRemaining;\r\n\r\n    share[msg.sender] = share[msg.sender].add(_shareAccept);\r\n    totalShare = totalShare.add(_shareAccept);\r\n    emit BuyShare(msg.sender, _shareAccept);\r\n    if (msg.value!=_shareAccept) {\r\n      msg.sender.transfer(msg.value.sub(_shareAccept));\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function acceptTokenFromICO_(uint _value) internal returns(bool) {\r\n    uint8 _state = getState_();\r\n    uint8 _for = getRole_();\r\n    require(_state == ST_WAIT_FOR_ICO);\r\n    require(_for == RL_ICO_MANAGER);\r\n    \r\n    totalToken = totalToken.add(_value);\r\n    emit AcceptTokenFromICO(msg.sender, _value);\r\n    require(IERC20(tokenAddress).transferFrom(msg.sender, this, _value));\r\n    if (tokenPrice > 0) {\r\n      releaseEtherToStakeholder_(_state, _for, _value.mul(tokenPrice).div(DECIMAL_MULTIPLIER));\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function getStakeholderBalanceOf_(uint8 _for) internal view returns (uint) {\r\n    if (_for == RL_ICO_MANAGER) {\r\n      return getEtherCollected_().mul(stakeholderShare[_for]).div(DECIMAL_MULTIPLIER).sub(stakeholderEtherReleased_[_for]);\r\n    }\r\n\r\n    if ((_for == RL_POOL_MANAGER) || (_for == RL_ADMIN)) {\r\n      return stakeholderEtherReleased_[RL_ICO_MANAGER].mul(stakeholderShare[_for]).div(stakeholderShare[RL_ICO_MANAGER]);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  function releaseEtherToStakeholder_(uint8 _state, uint8 _for, uint _value) internal returns (bool) {\r\n    require(_for != RL_DEFAULT);\r\n    require(_for != RL_PAYBOT);\r\n    require(!((_for == RL_ICO_MANAGER) && (_state != ST_WAIT_FOR_ICO)));\r\n    uint _balance = getStakeholderBalanceOf_(_for);\r\n    address _afor = getRoleAddress_(_for);\r\n    require(_balance >= _value);\r\n    stakeholderEtherReleased_[_for] = stakeholderEtherReleased_[_for].add(_value);\r\n    emit ReleaseEtherToStakeholder(_for, _afor, _value);\r\n    _afor.transfer(_value);\r\n    return true;\r\n  }\r\n\r\n  function getBalanceEtherOf_(address _for) internal view returns (uint) {\r\n    uint _stakeholderTotalEtherReserved = stakeholderEtherReleased_[RL_ICO_MANAGER]\r\n    .mul(DECIMAL_MULTIPLIER).div(stakeholderShare[RL_ICO_MANAGER]);\r\n    uint _restEther = getEtherCollected_().sub(_stakeholderTotalEtherReserved);\r\n    return _restEther.mul(share[_for]).div(totalShare).sub(etherReleased_[_for]);\r\n  }\r\n\r\n  function getBalanceTokenOf_(address _for) internal view returns (uint) {\r\n    return totalToken.mul(share[_for]).div(totalShare).sub(tokenReleased_[_for]);\r\n  }\r\n\r\n  function releaseEther_(address _for, uint _value) internal returns (bool) {\r\n    uint _balance = getBalanceEtherOf_(_for);\r\n    require(_balance >= _value);\r\n    etherReleased_[_for] = etherReleased_[_for].add(_value);\r\n    emit ReleaseEther(_for, _value);\r\n    _for.transfer(_value);\r\n    return true;\r\n  }\r\n\r\n  function releaseToken_( address _for, uint _value) internal returns (bool) {\r\n    uint _balance = getBalanceTokenOf_(_for);\r\n    require(_balance >= _value);\r\n    tokenReleased_[_for] = tokenReleased_[_for].add(_value);\r\n    emit ReleaseToken(_for, _value);\r\n    require(IERC20(tokenAddress).transfer(_for, _value));\r\n    return true;\r\n  }\r\n\r\n  function refundShare_(address _for, uint _value) internal returns(bool) {\r\n    uint _balance = share[_for];\r\n    require(_balance >= _value);\r\n    share[_for] = _balance.sub(_value);\r\n    totalShare = totalShare.sub(_value);\r\n    emit RefundShare(_for, _value);\r\n    _for.transfer(_value);\r\n    return true;\r\n  }\r\n  \r\n}\r\n\r\n// File: contracts\\abstract\\Pool\\Pool.sol\r\n\r\ncontract Pool is ShareStore, StateModel, RoleModel {\r\n}\r\n\r\n// File: contracts\\abstract\\TimeMachine\\TimeMachineP.sol\r\n\r\n/**\r\n* @dev TimeMachine implementation for production\r\n*/\r\ncontract TimeMachineP {\r\n  \r\n  /**\r\n  * @dev get current real timestamp\r\n  * @return current real timestamp\r\n  */\r\n  function getTimestamp_() internal view returns(uint) {\r\n    return block.timestamp;\r\n  }\r\n}\r\n\r\n// File: contracts\\production\\poolProd\\PoolProd.sol\r\n\r\ncontract PoolProd is Pool, TimeMachineP {\r\n  uint constant DECIMAL_MULTIPLIER = 1e18;\r\n  \r\n\r\n  constructor() public {\r\n    uint day = 86400;\r\n    raisingPeriod = day*30;\r\n    icoPeriod = day*60;\r\n    distributionPeriod = day*90;\r\n\r\n    minimalFundSize = 0.1e18;\r\n    maximalFundSize = 10e18;\r\n\r\n    minimalDeposit = 0.01e18;\r\n\r\n    stakeholderShare[RL_ADMIN] = 0.02e18;\r\n    stakeholderShare[RL_POOL_MANAGER] = 0.01e18;\r\n    stakeholderShare[RL_ICO_MANAGER] = DECIMAL_MULTIPLIER - 0.02e18 - 0.01e18;\r\n\r\n    setRole_(RL_ADMIN, 0xa4280AEF10BE355d6777d97758cb6fC6c5C3779C);\r\n    setRole_(RL_POOL_MANAGER, 0x91b4DABf4f2562E714DBd84B6D4a4efd7e1a97a8);\r\n    setRole_(RL_ICO_MANAGER, 0x79Cd7826636cb299059272f4324a5866496807Ef);\r\n    setRole_(RL_PAYBOT, 0x3Fae7A405A45025E5Fb0AD09e225C4168bF916D4);\r\n\r\n    tokenAddress = 0x45245bc59219eeaAF6cD3f382e078A461FF9De7B;\r\n    tokenPrice = 5000000000000000;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"share\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"refundShare\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"releaseTokenForceMulti\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_for\",\"type\":\"uint8\"}],\"name\":\"getStakeholderBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"uint8\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"releaseEtherToStakeholderForce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"getBalanceEtherOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_targetAddress\",\"type\":\"address\"}],\"name\":\"getRole\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"refundShareForce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyShare\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"launchTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"releaseEtherForce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximalFundSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newState\",\"type\":\"uint256\"}],\"name\":\"setState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raisingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"releaseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"releaseEtherToStakeholder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stakeholderShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"releaseEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"getBalanceTokenOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"releaseTokenForce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalFundSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"acceptTokenFromICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"releaseEtherForceMulti\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BuyShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RefundShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"role\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReleaseEtherToStakeholder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AcceptTokenFromICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReleaseEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReleaseToken\",\"type\":\"event\"}]","ContractName":"PoolProd","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2ad6e09ce51961f3a8960d377e2f72a9c9c57c36f684952d7c6f9970fb7f9af4"}]}