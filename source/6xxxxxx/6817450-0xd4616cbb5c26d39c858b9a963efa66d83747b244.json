{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n// File: contracts\\lib\\BMEvents.sol\r\n\r\n/// @title Events used in FomoSport\r\ncontract BMEvents {\r\n\r\n    event onGameCreated(\r\n        uint256 indexed gameID,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onGameActivated(\r\n        uint256 indexed gameID,\r\n        uint256 startTime,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onGamePaused(\r\n        uint256 indexed gameID,\r\n        bool paused,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onChangeCloseTime(\r\n        uint256 indexed gameID,\r\n        uint256 closeTimestamp,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onPurchase(\r\n        uint256 indexed gameID,\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 teamID,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onWithdraw(\r\n        uint256 indexed gameID,\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onGameEnded(\r\n        uint256 indexed gameID,\r\n        uint256 winningTeamID,\r\n        string comment,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onGameCancelled(\r\n        uint256 indexed gameID,\r\n        string comment,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onFundCleared(\r\n        uint256 indexed gameID,\r\n        uint256 fundCleared,\r\n        uint256 timestamp\r\n    );\r\n}\r\n\r\n// File: contracts\\lib\\SafeMath.sol\r\n\r\n/// @title SafeMath v0.1.9\r\n/// @dev Math operations with safety checks that throw on error\r\n/// change notes: original SafeMath library from OpenZeppelin modified by Inventor\r\n/// - added sqrt\r\n/// - added sq\r\n/// - added pwr \r\n/// - changed asserts to requires with error log outputs\r\n/// - removed div, its useless\r\nlibrary SafeMath {\r\n    \r\n    /// @dev Multiplies two numbers, throws on overflow.\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n\r\n    /// @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n\r\n    /// @dev Adds two numbers, throws on overflow.\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n\r\n    /// @dev gives square root of given x.\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x, 1)) / 2);\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = ((add((x / z), z)) / 2);\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev gives square. multiplies x by x\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n\r\n    /// @dev x to the power of y \r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x == 0) {\r\n            return (0);\r\n        } else if (y == 0) {\r\n            return (1);\r\n        } else {\r\n            uint256 z = x;\r\n            for (uint256 i = 1; i < y; i++) {\r\n                z = mul(z,x);\r\n            }\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\lib\\BMKeyCalc.sol\r\n\r\n// key calculation\r\nlibrary BMKeyCalc {\r\n    using SafeMath for *;\r\n    \r\n    /// @dev calculates number of keys received given X eth \r\n    /// @param _curEth current amount of eth in contract \r\n    /// @param _newEth eth being spent\r\n    /// @return amount of ticket purchased\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n\r\n\r\n    /// @dev calculates amount of eth received if you sold X keys \r\n    /// @param _curKeys current amount of keys that exist \r\n    /// @param _sellKeys amount of keys you wish to sell\r\n    /// @return amount of eth received\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /// @dev calculates how many keys would exist with given an amount of eth\r\n    /// @param _eth eth \"in contract\"\r\n    /// @return number of keys that would exist\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(3125000000000000000000000000)).add(562498828125610351562500000000000000000000000000000000000000000000)).sqrt()).sub(749999218750000000000000000000000)) / (1562500000);\r\n    }\r\n    \r\n    /// @dev calculates how much eth would be in contract given a number of keys\r\n    /// @param _keys number of keys \"in contract\" \r\n    /// @return eth that would exists\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((781250000).mul(_keys.sq()).add(((1499998437500000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n// File: contracts\\lib\\BMDatasets.sol\r\n\r\n// datasets\r\nlibrary BMDatasets {\r\n\r\n    struct Game {\r\n        string name;                     // game name\r\n        uint256 numberOfTeams;           // number of teams\r\n        uint256 gameStartTime;           // game start time (> 0 means activated)\r\n\r\n        bool paused;                     // game paused\r\n        bool ended;                      // game ended\r\n        bool canceled;                   // game canceled\r\n        uint256 winnerTeam;              // winner team        \r\n        uint256 withdrawDeadline;        // deadline for withdraw fund\r\n        string gameEndComment;           // comment for game ending or canceling\r\n        uint256 closeTime;               // betting close time\r\n    }\r\n\r\n    struct GameStatus {\r\n        uint256 totalEth;                // total eth invested\r\n        uint256 totalWithdrawn;          // total withdrawn by players\r\n        uint256 winningVaultInst;        // current \"instant\" winning vault\r\n        uint256 winningVaultFinal;       // current \"final\" winning vault        \r\n        bool fundCleared;                // fund already cleared\r\n    }\r\n\r\n    struct Team {\r\n        bytes32 name;       // team name\r\n        uint256 keys;       // number of keys\r\n        uint256 eth;        // total eth for the team\r\n        uint256 mask;       // mask of this team\r\n        uint256 dust;       // dust for winning vault\r\n    }\r\n\r\n    struct Player {\r\n        uint256 eth;        // total eth for the game\r\n        bool withdrawn;     // winnings already withdrawn\r\n    }\r\n\r\n    struct PlayerTeam {\r\n        uint256 keys;       // number of keys\r\n        uint256 eth;        // total eth for the team\r\n        uint256 mask;       // mask for this team\r\n    }\r\n}\r\n\r\n// File: contracts\\lib\\Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public dev;\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the dev.\r\n    */\r\n    modifier onlyDev() {\r\n        require(msg.sender == dev, \"only dev\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner or dev.\r\n    */\r\n    modifier onlyDevOrOwner() {\r\n        require(msg.sender == owner || msg.sender == dev, \"only owner or dev\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to set a new dev address.\r\n    * @param newDev The new dev address.\r\n    */\r\n    function setDev(address newDev) onlyOwner public {\r\n        if (newDev != address(0)) {\r\n            dev = newDev;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\interface\\BMForwarderInterface.sol\r\n\r\ninterface BMForwarderInterface {\r\n    function deposit() external payable;\r\n}\r\n\r\n// File: contracts\\interface\\BMPlayerBookInterface.sol\r\n\r\ninterface BMPlayerBookInterface {\r\n    function pIDxAddr_(address _addr) external returns (uint256);\r\n    function pIDxName_(bytes32 _name) external returns (uint256);\r\n\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function setPlayerLAff(uint256 _pID, uint256 _lAff) external;\r\n    function getPlayerAffT2(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getPlayerHasAff(uint256 _pID) external view returns (bool);\r\n    function getNameFee() external view returns (uint256);\r\n    function getAffiliateFee() external view returns (uint256);\r\n    function depositAffiliate(uint256 _pID) external payable;\r\n}\r\n\r\n// File: contracts\\BMSport.sol\r\n\r\n/// @title A raffle system for sports betting, designed with FOMO elements\r\n/// @notice This contract manages multiple games. Owner(s) can create games and\r\n/// assign winning team for each game. Players can withdraw their winnings before\r\n/// the deadline set by the owner(s). If there's no winning team, the owner(s)\r\n/// can also cancel a game so the players get back their bettings (minus fees).\r\n/// @dev The address of the forwarder, player book, and owner(s) are hardcoded.\r\n/// Check 'TODO' before deploy.\r\ncontract BMSport is BMEvents, Ownable {\r\n    using BMKeyCalc for *;\r\n    using SafeMath for *;\r\n\r\n    // TODO: check address!!\r\n    BMForwarderInterface  private Banker_Address;\r\n    BMPlayerBookInterface private BMBook;\r\n\r\n    string constant public name_ = \"BMSport\";\r\n    uint256 public gameIDIndex_;\r\n    \r\n    // (gameID => gameData)\r\n    mapping(uint256 => BMDatasets.Game) public game_;\r\n\r\n    // (gameID => gameStatus)\r\n    mapping(uint256 => BMDatasets.GameStatus) public gameStatus_;\r\n\r\n    // (gameID => (teamID => teamData))\r\n    mapping(uint256 => mapping(uint256 => BMDatasets.Team)) public teams_;\r\n\r\n    // (playerID => (gameID => playerData))\r\n    mapping(uint256 => mapping(uint256 => BMDatasets.Player)) public players_;\r\n\r\n    // (playerID => (gameID => (teamID => playerTeamData)))\r\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => BMDatasets.PlayerTeam))) public playerTeams_;\r\n\r\n\r\n    constructor(BMPlayerBookInterface book_addr) public {\r\n        require(book_addr != address(0), \"need a playerbook address\");\r\n        BMBook = book_addr;\r\n        gameIDIndex_ = 1;\r\n    }\r\n\r\n\r\n    /// @notice Create a game. Only owner(s) can call this function.\r\n    /// Emits \"onGameCreated\" event.\r\n    /// @param _name Name of the new game.\r\n    /// @param _teamNames Array consisting names of all teams in the game.\r\n    /// The size of the array indicates the number of teams in this game.\r\n    /// @return Game ID of the newly created game.\r\n    function createGame(string _name, bytes32[] _teamNames)\r\n        external\r\n        isHuman()\r\n        onlyDevOrOwner()\r\n        returns(uint256)\r\n    {\r\n        uint256 _gameID = gameIDIndex_;\r\n        gameIDIndex_++;\r\n\r\n        // initialize game\r\n        game_[_gameID].name = _name;\r\n\r\n        // initialize each team\r\n        uint256 _nt = _teamNames.length;\r\n        require(_nt > 0, \"number of teams must be larger than 0\");\r\n\r\n        game_[_gameID].numberOfTeams = _nt;\r\n        for (uint256 i = 0; i < _nt; i++) {\r\n            teams_[_gameID][i] = BMDatasets.Team(_teamNames[i], 0, 0, 0, 0);\r\n        }\r\n\r\n        emit onGameCreated(_gameID, now);\r\n\r\n        return _gameID;\r\n    }\r\n\r\n\r\n    /// @notice Activate a game. Only owner(s) can do this.\r\n    /// Players can start buying keys after start time.\r\n    /// Emits \"onGameActivated\" event.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _startTime Timestamp of the start time.\r\n    function activate(uint256 _gameID, uint256 _startTime)\r\n        external\r\n        isHuman()\r\n        onlyDevOrOwner()\r\n    {\r\n        require(_gameID < gameIDIndex_, \"incorrect game id\");\r\n        require(game_[_gameID].gameStartTime == 0, \"already activated\");\r\n        \r\n        // TODO: do some initialization\r\n        game_[_gameID].gameStartTime = _startTime;\r\n\r\n        emit onGameActivated(_gameID, _startTime, now);\r\n    }\r\n\r\n\r\n    /// @notice Buy keys for each team.\r\n    /// Emits \"onPurchase\" for each team with a purchase.\r\n    /// @param _gameID Game ID of the game to buy tickets.\r\n    /// @param _teamEth Array consisting amount of ETH for each team to buy tickets.\r\n    /// The size of the array must be the same as the number of teams.\r\n    /// The paid ETH along with this function call must be the same as the sum of all\r\n    /// ETH in this array.\r\n    /// @param _affCode Affiliate code used for this transaction. Use 0 if no affiliate\r\n    /// code is used.\r\n    function buysXid(uint256 _gameID, uint256[] memory _teamEth)\r\n        public\r\n        payable\r\n        isActivated(_gameID)\r\n        isOngoing(_gameID)\r\n        isNotPaused(_gameID)\r\n        isNotClosed(_gameID)\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n    {\r\n        // fetch player id\r\n        uint256 _pID = BMBook.getPlayerID(msg.sender);\r\n        \r\n        // purchase keys for each team\r\n        buysCore(_gameID, _pID, _teamEth);\r\n    }\r\n\r\n\r\n    /// @notice Pause a game. Only owner(s) can do this.\r\n    /// Players can't buy tickets if a game is paused.\r\n    /// Emits \"onGamePaused\" event.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _paused \"true\" to pause this game, \"false\" to unpause.\r\n    function pauseGame(uint256 _gameID, bool _paused)\r\n        external\r\n        isActivated(_gameID)\r\n        isOngoing(_gameID)\r\n        onlyDevOrOwner()\r\n    {\r\n        game_[_gameID].paused = _paused;\r\n\r\n        emit onGamePaused(_gameID, _paused, now);\r\n    }\r\n\r\n\r\n    /// @notice Set a closing time for betting. Only owner(s) can do this.\r\n    /// Players can't buy tickets for this game once the closing time is passed.\r\n    /// Emits \"onChangeCloseTime\" event.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _closeTime Timestamp of the closing time.\r\n    function setCloseTime(uint256 _gameID, uint256 _closeTime)\r\n        external\r\n        isActivated(_gameID)\r\n        isOngoing(_gameID)\r\n        onlyDevOrOwner()\r\n    {\r\n        game_[_gameID].closeTime = _closeTime;\r\n\r\n        emit onChangeCloseTime(_gameID, _closeTime, now);\r\n    }\r\n\r\n\r\n    /// @notice Select a winning team. Only owner(s) can do this.\r\n    /// Players can't no longer buy tickets for this game once a winning team is selected.\r\n    /// Players who bought tickets for the winning team are able to withdraw winnings.\r\n    /// Emits \"onGameEnded\" event.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _team Team ID of the winning team.\r\n    /// @param _comment A closing comment to describe the conclusion of the game.\r\n    /// @param _deadline Timestamp of the withdraw deadline of the game\r\n    function settleGame(uint256 _gameID, uint256 _team, string _comment, uint256 _deadline)\r\n        external\r\n        isActivated(_gameID)\r\n        isOngoing(_gameID)\r\n        isValidTeam(_gameID, _team)\r\n        onlyDevOrOwner()\r\n    {\r\n        // TODO: check deadline limit\r\n        require(_deadline >= now + 86400, \"deadline must be more than one day later.\");\r\n\r\n        game_[_gameID].ended = true;\r\n        game_[_gameID].winnerTeam = _team;\r\n        game_[_gameID].gameEndComment = _comment;\r\n        game_[_gameID].withdrawDeadline = _deadline;\r\n\r\n        if (teams_[_gameID][_team].keys == 0) {\r\n            // no one bought winning keys, send pot to community\r\n            uint256 _totalPot = (gameStatus_[_gameID].winningVaultInst).add(gameStatus_[_gameID].winningVaultFinal);\r\n            gameStatus_[_gameID].totalWithdrawn = _totalPot;\r\n            if (_totalPot > 0) {\r\n                Banker_Address.deposit.value(_totalPot)();\r\n            }\r\n        }\r\n\r\n        emit BMEvents.onGameEnded(_gameID, _team, _comment, now);\r\n    }\r\n\r\n\r\n    /// @notice Cancel a game. Only owner(s) can do this.\r\n    /// Players can't no longer buy tickets for this game once a winning team is selected.\r\n    /// Players who bought tickets can get back 95% of the ETH paid.\r\n    /// Emits \"onGameCancelled\" event.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _comment A closing comment to describe the conclusion of the game.\r\n    /// @param _deadline Timestamp of the withdraw deadline of the game\r\n    function cancelGame(uint256 _gameID, string _comment, uint256 _deadline)\r\n        external\r\n        isActivated(_gameID)\r\n        isOngoing(_gameID)\r\n        onlyDevOrOwner()\r\n    {\r\n        // TODO: check deadline limit\r\n        require(_deadline >= now + 86400, \"deadline must be more than one day later.\");\r\n\r\n        game_[_gameID].ended = true;\r\n        game_[_gameID].canceled = true;\r\n        game_[_gameID].gameEndComment = _comment;\r\n        game_[_gameID].withdrawDeadline = _deadline;\r\n\r\n        emit BMEvents.onGameCancelled(_gameID, _comment, now);\r\n    }\r\n\r\n\r\n    /// @notice Withdraw winnings. Only available after a game is ended\r\n    /// (winning team selected or game canceled).\r\n    /// Emits \"onWithdraw\" event.\r\n    /// @param _gameID Game ID of the game.\r\n    function withdraw(uint256 _gameID)\r\n        external\r\n        isHuman()\r\n        isActivated(_gameID)\r\n        isEnded(_gameID)\r\n    {\r\n        require(now < game_[_gameID].withdrawDeadline, \"withdraw deadline already passed\");\r\n        require(gameStatus_[_gameID].fundCleared == false, \"fund already cleared\");\r\n\r\n        uint256 _pID = BMBook.pIDxAddr_(msg.sender);\r\n\r\n        require(_pID != 0, \"player has not played this game\");\r\n        require(players_[_pID][_gameID].withdrawn == false, \"player already cashed out\");\r\n\r\n        players_[_pID][_gameID].withdrawn = true;\r\n\r\n        if (game_[_gameID].canceled) {\r\n            // game is canceled\r\n            // withdraw 95% of the original payments\r\n            uint256 _totalInvestment = players_[_pID][_gameID].eth.mul(95) / 100;\r\n            if (_totalInvestment > 0) {\r\n                // send to player\r\n                BMBook.getPlayerAddr(_pID).transfer(_totalInvestment);\r\n                gameStatus_[_gameID].totalWithdrawn = _totalInvestment.add(gameStatus_[_gameID].totalWithdrawn);\r\n            }\r\n\r\n            emit BMEvents.onWithdraw(_gameID, _pID, msg.sender, BMBook.getPlayerName(_pID), _totalInvestment, now);\r\n        } else {\r\n            uint256 _totalWinnings = getPlayerInstWinning(_gameID, _pID, game_[_gameID].winnerTeam).add(getPlayerPotWinning(_gameID, _pID, game_[_gameID].winnerTeam));\r\n            if (_totalWinnings > 0) {\r\n                // send to player\r\n                BMBook.getPlayerAddr(_pID).transfer(_totalWinnings);\r\n                gameStatus_[_gameID].totalWithdrawn = _totalWinnings.add(gameStatus_[_gameID].totalWithdrawn);\r\n            }\r\n\r\n            emit BMEvents.onWithdraw(_gameID, _pID, msg.sender, BMBook.getPlayerName(_pID), _totalWinnings, now);\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Clear funds of a game. Only owner(s) can do this, after withdraw deadline\r\n    /// is passed.\r\n    /// Emits \"onFundCleared\" event.\r\n    /// @param _gameID Game ID of the game.\r\n    function clearFund(uint256 _gameID)\r\n        external\r\n        isHuman()\r\n        isEnded(_gameID)\r\n        onlyDevOrOwner()\r\n    {\r\n        require(now >= game_[_gameID].withdrawDeadline, \"withdraw deadline not passed yet\");\r\n        require(gameStatus_[_gameID].fundCleared == false, \"fund already cleared\");\r\n\r\n        gameStatus_[_gameID].fundCleared = true;\r\n\r\n        // send remaining fund to community\r\n        uint256 _totalPot = (gameStatus_[_gameID].winningVaultInst).add(gameStatus_[_gameID].winningVaultFinal);\r\n        uint256 _amount = _totalPot.sub(gameStatus_[_gameID].totalWithdrawn);\r\n        if (_amount > 0) {\r\n            Banker_Address.deposit.value(_amount)();\r\n        }\r\n\r\n        emit onFundCleared(_gameID, _amount, now);\r\n    }\r\n\r\n\r\n    /// @notice Get a player's current instant pot winnings.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _pID Player ID of the player.\r\n    /// @param _team Team ID of the team.\r\n    /// @return Instant pot winnings of the player for this game and this team.\r\n    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team)\r\n        public\r\n        view\r\n        isActivated(_gameID)\r\n        isValidTeam(_gameID, _team)\r\n        returns(uint256)\r\n    {\r\n        return ((((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));\r\n    }\r\n\r\n\r\n    /// @notice Get a player's current final pot winnings.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _pID Player ID of the player.\r\n    /// @param _team Team ID of the team.\r\n    /// @return Final pot winnings of the player for this game and this team.\r\n    function getPlayerPotWinning(uint256 _gameID, uint256 _pID, uint256 _team)\r\n        public\r\n        view\r\n        isActivated(_gameID)\r\n        isValidTeam(_gameID, _team)\r\n        returns(uint256)\r\n    {\r\n        if (teams_[_gameID][_team].keys > 0) {\r\n            return gameStatus_[_gameID].winningVaultFinal.mul(playerTeams_[_pID][_gameID][_team].keys) / teams_[_gameID][_team].keys;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Get current game status.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @return (number of teams, names, keys, eth, current key price for 1 key)\r\n    function getGameStatus(uint256 _gameID)\r\n        public\r\n        view\r\n        isActivated(_gameID)\r\n        returns(uint256, bytes32[] memory, uint256[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n        uint256 _nt = game_[_gameID].numberOfTeams;\r\n        bytes32[] memory _names = new bytes32[](_nt);\r\n        uint256[] memory _keys = new uint256[](_nt);\r\n        uint256[] memory _eth = new uint256[](_nt);\r\n        uint256[] memory _keyPrice = new uint256[](_nt);\r\n        uint256 i;\r\n\r\n        for (i = 0; i < _nt; i++) {\r\n            _names[i] = teams_[_gameID][i].name;\r\n            _keys[i] = teams_[_gameID][i].keys;\r\n            _eth[i] = teams_[_gameID][i].eth;\r\n            _keyPrice[i] = getBuyPrice(_gameID, i, 1000000000000000000);\r\n        }\r\n\r\n        return (_nt, _names, _keys, _eth, _keyPrice);\r\n    }\r\n\r\n\r\n    /// @notice Get player status of a game.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _pID Player ID of the player.\r\n    /// @return (name, eth for each team, keys for each team, inst win for each team, pot win for each team)\r\n    function getPlayerStatus(uint256 _gameID, uint256 _pID)\r\n        public\r\n        view\r\n        isActivated(_gameID)\r\n        returns(bytes32, uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n        uint256 _nt = game_[_gameID].numberOfTeams;\r\n        uint256[] memory _eth = new uint256[](_nt);\r\n        uint256[] memory _keys = new uint256[](_nt);\r\n        uint256[] memory _instWin = new uint256[](_nt);\r\n        uint256[] memory _potWin = new uint256[](_nt);\r\n        uint256 i;\r\n\r\n        for (i = 0; i < _nt; i++) {\r\n            _eth[i] = playerTeams_[_pID][_gameID][i].eth;\r\n            _keys[i] = playerTeams_[_pID][_gameID][i].keys;\r\n            _instWin[i] = getPlayerInstWinning(_gameID, _pID, i);\r\n            _potWin[i] = getPlayerPotWinning(_gameID, _pID, i);\r\n        }\r\n        \r\n        return (BMBook.getPlayerName(_pID), _eth, _keys, _instWin, _potWin);\r\n    }\r\n\r\n\r\n    /// @notice Get the price buyer have to pay for next keys.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _team Team ID of the team.\r\n    /// @param _keys Number of keys (in wei).\r\n    /// @return Price for the number of keys to buy (in wei).\r\n    function getBuyPrice(uint256 _gameID, uint256 _team, uint256 _keys)\r\n        public \r\n        view\r\n        isActivated(_gameID)\r\n        isValidTeam(_gameID, _team)\r\n        returns(uint256)\r\n    {                  \r\n        return ((teams_[_gameID][_team].keys.add(_keys)).ethRec(_keys));\r\n    }\r\n\r\n\r\n    /// @notice Get the prices buyer have to pay for next keys for all teams.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _keys Array of number of keys (in wei) for all teams.\r\n    /// @return (total eth, array of prices in wei).\r\n    function getBuyPrices(uint256 _gameID, uint256[] memory _keys)\r\n        public\r\n        view\r\n        isActivated(_gameID)\r\n        returns(uint256, uint256[])\r\n    {\r\n        uint256 _totalEth = 0;\r\n        uint256 _nt = game_[_gameID].numberOfTeams;\r\n        uint256[] memory _eth = new uint256[](_nt);\r\n        uint256 i;\r\n\r\n        require(_nt == _keys.length, \"Incorrect number of teams\");\r\n\r\n        for (i = 0; i < _nt; i++) {\r\n            if (_keys[i] > 0) {\r\n                _eth[i] = getBuyPrice(_gameID, i, _keys[i]);\r\n                _totalEth = _totalEth.add(_eth[i]);\r\n            }\r\n        }\r\n\r\n        return (_totalEth, _eth);\r\n    }\r\n    \r\n\r\n    /// @notice Get the number of keys can be bought with an amount of ETH.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _team Team ID of the team.\r\n    /// @param _eth Amount of ETH in wei.\r\n    /// @return Number of keys can be bought (in wei).\r\n    function getKeysfromETH(uint256 _gameID, uint256 _team, uint256 _eth)\r\n        public \r\n        view\r\n        isActivated(_gameID)\r\n        isValidTeam(_gameID, _team)\r\n        returns(uint256)\r\n    {                  \r\n        return (teams_[_gameID][_team].eth).keysRec(_eth);\r\n    }\r\n\r\n\r\n    /// @notice Get all numbers of keys can be bought with amounts of ETH.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _eths Array of amounts of ETH in wei.\r\n    /// @return (total keys, array of number of keys in wei).\r\n    function getKeysFromETHs(uint256 _gameID, uint256[] memory _eths)\r\n        public\r\n        view\r\n        isActivated(_gameID)\r\n        returns(uint256, uint256[])\r\n    {\r\n        uint256 _totalKeys = 0;\r\n        uint256 _nt = game_[_gameID].numberOfTeams;\r\n        uint256[] memory _keys = new uint256[](_nt);\r\n        uint256 i;\r\n\r\n        require(_nt == _eths.length, \"Incorrect number of teams\");\r\n\r\n        for (i = 0; i < _nt; i++) {\r\n            if (_eths[i] > 0) {\r\n                _keys[i] = getKeysfromETH(_gameID, i, _eths[i]);\r\n                _totalKeys = _totalKeys.add(_keys[i]);\r\n            }\r\n        }\r\n\r\n        return (_totalKeys, _keys);\r\n    }\r\n\r\n    /// @dev Buy keys for all teams.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _pID Player ID of the player.\r\n    /// @param _teamEth Array of eth paid for each team.\r\n    function buysCore(uint256 _gameID, uint256 _pID, uint256[] memory _teamEth)\r\n        private\r\n    {\r\n        uint256 _nt = game_[_gameID].numberOfTeams;\r\n        uint256[] memory _keys = new uint256[](_nt);\r\n        bytes32 _name = BMBook.getPlayerName(_pID);\r\n        uint256 _totalEth = 0;\r\n        uint256 i;\r\n\r\n        require(_teamEth.length == _nt, \"Number of teams is not correct\");\r\n\r\n        // for all teams...\r\n        for (i = 0; i < _nt; i++) {\r\n            if (_teamEth[i] > 0) {\r\n                // compute total eth\r\n                _totalEth = _totalEth.add(_teamEth[i]);\r\n\r\n                // compute number of keys to buy\r\n                _keys[i] = (teams_[_gameID][i].eth).keysRec(_teamEth[i]);\r\n\r\n                // update player data\r\n                playerTeams_[_pID][_gameID][i].eth = _teamEth[i].add(playerTeams_[_pID][_gameID][i].eth);\r\n                playerTeams_[_pID][_gameID][i].keys = _keys[i].add(playerTeams_[_pID][_gameID][i].keys);\r\n\r\n                // update team data\r\n                teams_[_gameID][i].eth = _teamEth[i].add(teams_[_gameID][i].eth);\r\n                teams_[_gameID][i].keys = _keys[i].add(teams_[_gameID][i].keys);\r\n\r\n                emit BMEvents.onPurchase(_gameID, _pID, msg.sender, _name, i, _teamEth[i], _keys[i], now);\r\n            }\r\n        }\r\n\r\n        // check assigned ETH for each team is the same as msg.value\r\n        require(_totalEth == msg.value, \"Total ETH is not the same as msg.value\");        \r\n            \r\n        // update game data and player data\r\n        gameStatus_[_gameID].totalEth = _totalEth.add(gameStatus_[_gameID].totalEth);\r\n        players_[_pID][_gameID].eth = _totalEth.add(players_[_pID][_gameID].eth);\r\n\r\n        distributeAll(_gameID, _pID, _totalEth, _keys);\r\n    }\r\n\r\n\r\n    /// @dev Distribute paid ETH to different pots.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _pID Player ID of the player.\r\n    /// @param _totalEth Total ETH paid.\r\n    /// @param _keys Array of keys bought for each team.\r\n    function distributeAll(uint256 _gameID, uint256 _pID, uint256 _totalEth, uint256[] memory _keys)\r\n        private\r\n    {\r\n        // community 5%\r\n        uint256 _com = _totalEth / 20;\r\n\r\n        // instant pot (15%)\r\n        uint256 _instPot = _totalEth.mul(15) / 100;\r\n\r\n        // winning pot (80%)\r\n        uint256 _pot = _totalEth.mul(80) / 100;\r\n\r\n        // Send community to forwarder\r\n\r\n        Banker_Address.deposit.value(_com)();\r\n\r\n        gameStatus_[_gameID].winningVaultInst = _instPot.add(gameStatus_[_gameID].winningVaultInst);\r\n        gameStatus_[_gameID].winningVaultFinal = _pot.add(gameStatus_[_gameID].winningVaultFinal);\r\n\r\n        // update masks for instant winning vault\r\n        uint256 _nt = _keys.length;\r\n        for (uint256 i = 0; i < _nt; i++) {\r\n            uint256 _newPot = _instPot.add(teams_[_gameID][i].dust);\r\n            uint256 _dust = updateMasks(_gameID, _pID, i, _newPot, _keys[i]);\r\n            teams_[_gameID][i].dust = _dust;\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev Updates masks for instant pot.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _pID Player ID of the player.\r\n    /// @param _team Team ID of the team.\r\n    /// @param _gen Amount of ETH to be added into instant pot.\r\n    /// @param _keys Number of keys bought.\r\n    /// @return Dust left over.\r\n    function updateMasks(uint256 _gameID, uint256 _pID, uint256 _team, uint256 _gen, uint256 _keys)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        /* MASKING NOTES\r\n            earnings masks are a tricky thing for people to wrap their minds around.\r\n            the basic thing to understand here.  is were going to have a global\r\n            tracker based on profit per share for each round, that increases in\r\n            relevant proportion to the increase in share supply.\r\n            \r\n            the player will have an additional mask that basically says \"based\r\n            on the rounds mask, my shares, and how much i've already withdrawn,\r\n            how much is still owed to me?\"\r\n        */\r\n        \r\n        // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n        if (teams_[_gameID][_team].keys > 0) {\r\n            uint256 _ppt = (_gen.mul(1000000000000000000)) / (teams_[_gameID][_team].keys);\r\n            teams_[_gameID][_team].mask = _ppt.add(teams_[_gameID][_team].mask);\r\n\r\n            updatePlayerMask(_gameID, _pID, _team, _ppt, _keys);\r\n\r\n            // calculate & return dust\r\n            return(_gen.sub((_ppt.mul(teams_[_gameID][_team].keys)) / (1000000000000000000)));\r\n        } else {\r\n            return _gen;\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev Updates masks for the player.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _pID Player ID of the player.\r\n    /// @param _team Team ID of the team.\r\n    /// @param _ppt Amount of unit ETH.\r\n    /// @param _keys Number of keys bought.\r\n    /// @return Dust left over.\r\n    function updatePlayerMask(uint256 _gameID, uint256 _pID, uint256 _team, uint256 _ppt, uint256 _keys)\r\n        private\r\n    {\r\n        if (_keys > 0) {\r\n            // calculate player earning from their own buy (only based on the keys\r\n            // they just bought).  & update player earnings mask\r\n            uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n            playerTeams_[_pID][_gameID][_team].mask = (((teams_[_gameID][_team].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(playerTeams_[_pID][_gameID][_team].mask);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer Banker_Address to a new banker.\r\n    * @param banker The address to transfer Banker_Address to.\r\n    */\r\n    function transferBanker(BMForwarderInterface banker) \r\n    public\r\n    onlyOwner()\r\n    {\r\n        if (banker != address(0)) {\r\n            Banker_Address = banker;\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev Check if a game is activated.\r\n    /// @param _gameID Game ID of the game.\r\n    modifier isActivated(uint256 _gameID) {\r\n        require(game_[_gameID].gameStartTime > 0, \"Not activated yet\");\r\n        require(game_[_gameID].gameStartTime <= now, \"game not started yet\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Check if a game is not paused.\r\n    /// @param _gameID Game ID of the game.\r\n    modifier isNotPaused(uint256 _gameID) {\r\n        require(game_[_gameID].paused == false, \"game is paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Check if a game is not closed.\r\n    /// @param _gameID Game ID of the game.\r\n    modifier isNotClosed(uint256 _gameID) {\r\n        require(game_[_gameID].closeTime == 0 || game_[_gameID].closeTime > now, \"game is closed\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Check if a game is not settled.\r\n    /// @param _gameID Game ID of the game.\r\n    modifier isOngoing(uint256 _gameID) {\r\n        require(game_[_gameID].ended == false, \"game is ended\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Check if a game is settled.\r\n    /// @param _gameID Game ID of the game.\r\n    modifier isEnded(uint256 _gameID) {\r\n        require(game_[_gameID].ended == true, \"game is not ended\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Check if caller is not a smart contract.\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        require (_addr == tx.origin, \"Human only\");\r\n\r\n        uint256 _codeLength;\r\n        assembly { _codeLength := extcodesize(_addr) }\r\n        require(_codeLength == 0, \"Human only\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Check if purchase is within limits.\r\n    /// (between 0.000000001 ETH and 100000 ETH)\r\n    /// @param _eth Amount of ETH\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"too little money\");\r\n        require(_eth <= 100000000000000000000000, \"too much money\");\r\n        _;    \r\n    }\r\n\r\n\r\n    /// @dev Check if team ID is valid.\r\n    /// @param _gameID Game ID of the game.\r\n    /// @param _team Team ID of the team.\r\n    modifier isValidTeam(uint256 _gameID, uint256 _team) {\r\n        require(_team < game_[_gameID].numberOfTeams, \"there is no such team\");\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256[]\"}],\"name\":\"getBuyPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"getGameStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"getKeysfromETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"banker\",\"type\":\"address\"}],\"name\":\"transferBanker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameIDIndex_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"clearFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_comment\",\"type\":\"string\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"cancelGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_closeTime\",\"type\":\"uint256\"}],\"name\":\"setCloseTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"getPlayerInstWinning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_teamEth\",\"type\":\"uint256[]\"}],\"name\":\"buysXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"game_\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"numberOfTeams\",\"type\":\"uint256\"},{\"name\":\"gameStartTime\",\"type\":\"uint256\"},{\"name\":\"paused\",\"type\":\"bool\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"canceled\",\"type\":\"bool\"},{\"name\":\"winnerTeam\",\"type\":\"uint256\"},{\"name\":\"withdrawDeadline\",\"type\":\"uint256\"},{\"name\":\"gameEndComment\",\"type\":\"string\"},{\"name\":\"closeTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"getPlayerPotWinning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"setDev\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name_\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameStatus_\",\"outputs\":[{\"name\":\"totalEth\",\"type\":\"uint256\"},{\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"name\":\"winningVaultInst\",\"type\":\"uint256\"},{\"name\":\"winningVaultFinal\",\"type\":\"uint256\"},{\"name\":\"fundCleared\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_comment\",\"type\":\"string\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"settleGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_eths\",\"type\":\"uint256[]\"}],\"name\":\"getKeysFromETHs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_teamNames\",\"type\":\"bytes32[]\"}],\"name\":\"createGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teams_\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"dust\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerTeams_\",\"outputs\":[{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"book_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onGameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onGameActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paused\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onGamePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closeTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onChangeCloseTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"teamID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winningTeamID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onGameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onGameCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundCleared\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onFundCleared\",\"type\":\"event\"}]","ContractName":"BMSport","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000464c5b42df3f51ae4af0c12527f92db0899373d7","Library":"","SwarmSource":"bzzr://fcbd4e19d6e490db47bba38d5eacc7e69fae07da0ae4c5f07e0c9458f143c16a"}]}