{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract BasicAccessControl {\r\n    address public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = false;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) public onlyOwner {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) public onlyOwner {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n\r\n    function RemoveModerator(address _oldModerator) public onlyOwner {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }\r\n\r\n    function UpdateMaintaining(bool _isMaintaining) public onlyOwner {\r\n        isMaintaining = _isMaintaining;\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract EtheremonDataBase {\r\n    uint64 public totalMonster;\r\n    uint32 public totalClass;\r\n\r\n    // write\r\n    function addElementToArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint8 _value) external returns(uint);\r\n    function addMonsterObj(uint32 _classId, address _trainer, string _name) external returns(uint64);\r\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) external;\r\n\r\n    // read\r\n    function getElementInArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint _index) external constant returns(uint8);\r\n    function getMonsterClass(uint32 _classId) external constant returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\r\n    function getMonsterObj(uint64 _objId) external constant returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\r\n}\r\n\r\ncontract EtheremonEnum {\r\n    enum ResultCode {\r\n        SUCCESS,\r\n        ERROR_CLASS_NOT_FOUND,\r\n        ERROR_LOW_BALANCE,\r\n        ERROR_SEND_FAIL,\r\n        ERROR_NOT_TRAINER,\r\n        ERROR_NOT_ENOUGH_MONEY,\r\n        ERROR_INVALID_AMOUNT\r\n    }\r\n\r\n    enum ArrayType {\r\n        CLASS_TYPE,\r\n        STAT_STEP,\r\n        STAT_START,\r\n        STAT_BASE,\r\n        OBJ_SKILL\r\n    }\r\n\r\n    enum PropertyType {\r\n        ANCESTOR,\r\n        XFACTOR\r\n    }\r\n}\r\n\r\ninterface EtheremonMonsterNFTInterface {\r\n   function triggerTransferEvent(address _from, address _to, uint _tokenId) external;\r\n   function getMonsterCP(uint64 _monsterId) constant external returns(uint cp);\r\n}\r\n\r\ncontract EtheremonWorldNFT is BasicAccessControl {\r\n    uint8 constant public STAT_COUNT = 6;\r\n    uint8 constant public STAT_MAX = 32;\r\n\r\n    struct MonsterClassAcc {\r\n        uint32 classId;\r\n        uint256 price;\r\n        uint256 returnPrice;\r\n        uint32 total;\r\n        bool catchable;\r\n    }\r\n\r\n    struct MonsterObjAcc {\r\n        uint64 monsterId;\r\n        uint32 classId;\r\n        address trainer;\r\n        string name;\r\n        uint32 exp;\r\n        uint32 createIndex;\r\n        uint32 lastClaimIndex;\r\n        uint createTime;\r\n    }\r\n\r\n    address public dataContract;\r\n    address public monsterNFT;\r\n\r\n    mapping(uint32 => bool) public classWhitelist;\r\n    mapping(address => bool) public addressWhitelist;\r\n\r\n    uint public gapFactor = 5;\r\n    uint public priceIncreasingRatio = 1000;\r\n\r\n    function setContract(address _dataContract, address _monsterNFT) external onlyModerators {\r\n        dataContract = _dataContract;\r\n        monsterNFT = _monsterNFT;\r\n    }\r\n\r\n    function setConfig(uint _gapFactor, uint _priceIncreasingRatio) external onlyModerators {\r\n        gapFactor = _gapFactor;\r\n        priceIncreasingRatio = _priceIncreasingRatio;\r\n    }\r\n\r\n    function setClassWhitelist(uint32 _classId, bool _status) external onlyModerators {\r\n        classWhitelist[_classId] = _status;\r\n    }\r\n\r\n    function setAddressWhitelist(address _smartcontract, bool _status) external onlyModerators {\r\n        addressWhitelist[_smartcontract] = _status;\r\n    }\r\n\r\n    function mintMonster(uint32 _classId, address _trainer, string _name) external onlyModerators returns(uint) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        // add monster\r\n        uint64 objId = data.addMonsterObj(_classId, _trainer, _name);\r\n        uint8 value;\r\n        uint seed = getRandom(_trainer, block.number-1, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i += 1) {\r\n            seed /= 100;\r\n            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n\r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(address(0), _trainer, objId);\r\n        return objId;\r\n    }\r\n\r\n    function burnMonster(uint64 _tokenId) external onlyModerators {\r\n        // need to check condition before calling this function\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_tokenId);\r\n        require(obj.trainer != address(0));\r\n        data.removeMonsterIdMapping(obj.trainer, _tokenId);\r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(obj.trainer, address(0), _tokenId);\r\n    }\r\n\r\n    function catchMonsterNFT(uint32 _classId, string _name) external isActive payable {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        if (class.classId == 0 || class.catchable == false) {\r\n            revert();\r\n        }\r\n\r\n        uint price = class.price;\r\n        if (class.total > 0)\r\n            price += class.price*(class.total-1)/priceIncreasingRatio;\r\n        if (msg.value < price) {\r\n            revert();\r\n        }\r\n\r\n        // add new monster\r\n        uint64 objId = data.addMonsterObj(_classId, msg.sender, _name);\r\n        uint8 value;\r\n        uint seed = getRandom(msg.sender, block.number-1, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i += 1) {\r\n            seed /= 100;\r\n            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n\r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(address(0), msg.sender, objId);\r\n        // refund extra\r\n        if (msg.value > price) {\r\n            msg.sender.transfer((msg.value - price));\r\n        }\r\n    }\r\n\r\n    // for whitelist contracts, no refund extra\r\n    function catchMonster(address _player, uint32 _classId, string _name) external isActive payable returns(uint tokenId) {\r\n        if (addressWhitelist[msg.sender] == false) {\r\n            revert();\r\n        }\r\n\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        if (class.classId == 0) {\r\n            revert();\r\n        }\r\n\r\n        if (class.catchable == false && classWhitelist[_classId] == false) {\r\n            revert();\r\n        }\r\n\r\n        uint price = class.price;\r\n        if (class.total > gapFactor) {\r\n            price += class.price*(class.total - gapFactor)/priceIncreasingRatio;\r\n        }\r\n        if (msg.value < price) {\r\n            revert();\r\n        }\r\n\r\n        // add new monster\r\n        uint64 objId = data.addMonsterObj(_classId, _player, _name);\r\n        uint8 value;\r\n        uint seed = getRandom(_player, block.number-1, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i += 1) {\r\n            seed /= 100;\r\n            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n\r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(address(0), _player, objId);\r\n        return objId;\r\n    }\r\n\r\n    function getMonsterClassBasic(uint32 _classId) external constant returns(uint256, uint256, uint256, bool) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        return (class.price, class.returnPrice, class.total, class.catchable);\r\n    }\r\n\r\n    function getPrice(uint32 _classId) external constant returns(bool catchable, uint price) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n\r\n        price = class.price;\r\n        if (class.total > 0)\r\n            price += class.price*(class.total-1)/priceIncreasingRatio;\r\n\r\n        if (class.catchable == false) {\r\n            return (classWhitelist[_classId], price);\r\n        } else {\r\n            return (true, price);\r\n        }\r\n    }\r\n\r\n    // public api\r\n    function getRandom(address _player, uint _block, uint _count) public view returns(uint) {\r\n        return uint(keccak256(abi.encodePacked(blockhash(_block), _player, _count)));\r\n    }\r\n\r\n    function withdrawEther(address _sendTo, uint _amount) public onlyOwner {\r\n        if (_amount > address(this).balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }\r\n}\r\n\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\ncontract Utils2 is Utils {\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\r\n\r\n        if (decimals[token] == 0) {\r\n            setDecimals(token);\r\n        }\r\n\r\n        return decimals[token];\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n}\r\n\r\ninterface WrapEtheremonInterface {\r\n    /// @notice Can only be called by operators\r\n    /// @dev Sets the KyberNetwork address\r\n    /// @param _KyberNetwork KyberNetwork contract address\r\n    function setKyberNetwork(address _KyberNetwork) public;\r\n\r\n    /// @dev Get the ETH price of the Etheremon monster and if it is catchable\r\n    /// @param _etheremon EtheremonWorldNFT address\r\n    /// @param _classId Class ID of monster\r\n    /// @param _payPrice Price of monster passed from Etheremon server\r\n    /// @return catchable, monsterInETH\r\n    function getMonsterPriceInETH(\r\n        EtheremonWorldNFT _etheremon,\r\n        uint32 _classId,\r\n        uint _payPrice\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            bool catchable,\r\n            uint monsterInETH\r\n        );\r\n\r\n    /// @dev Get the rates of the Etheremon monster\r\n    /// @param _kyberProxy KyberNetworkProxyInterface address\r\n    /// @param token ERC20 token address\r\n    /// @param monsterInETH Price of the monster in ETH\r\n    /// @return expectedRate, slippageRate\r\n    function getMonsterRates(\r\n        KyberNetworkProxyInterface _kyberProxy,\r\n        ERC20 token,\r\n        uint monsterInETH\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint expectedRate,\r\n            uint slippageRate\r\n        );\r\n\r\n    /// @dev Get the token price and rates of the Etheremon monster\r\n    /// @param token ERC20 token address\r\n    /// @param expectedRate Expected rate of ETH to token\r\n    /// @param monsterInETH Price of the monster in ETH\r\n    /// @return monsterInTokens\r\n    function getMonsterPriceInTokens(\r\n        ERC20 token,\r\n        uint expectedRate,\r\n        uint monsterInETH\r\n    )\r\n        public\r\n        view\r\n        returns (uint monsterInTokens);\r\n\r\n    /// @dev Acquires the monster from Etheremon using tokens\r\n    /// @param _kyberProxy KyberNetworkProxyInterface address\r\n    /// @param _etheremon EtheremonWorldNFT address\r\n    /// @param _classId Class ID of monster\r\n    /// @param _name Name of the monster\r\n    /// @param token ERC20 token address\r\n    /// @param tokenQty Amount of tokens to be transferred by user\r\n    /// @param maxDestQty Actual amount of ETH needed to purchase the monster\r\n    /// @param minRate The minimum rate or slippage rate.\r\n    /// @param walletId Wallet ID where Kyber referral fees will be sent to\r\n    /// @return monsterId\r\n    function catchMonster(\r\n        KyberNetworkProxyInterface _kyberProxy,\r\n        EtheremonWorldNFT _etheremon,\r\n        uint32 _classId,\r\n        string _name,\r\n        ERC20 token,\r\n        uint tokenQty,\r\n        uint maxDestQty,\r\n        uint minRate,\r\n        address walletId\r\n    )\r\n        public\r\n        returns (uint monsterId);\r\n}\r\n\r\ncontract WrapEtheremonPermissions {\r\n    event TransferAdmin(address newAdmin);\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    address public admin;\r\n    address[] public operatorsGroup;\r\n    mapping(address=>bool) internal operators;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    constructor () public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdmin(newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]);\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract WrapEtheremon is WrapEtheremonInterface, WrapEtheremonPermissions, Utils2 {\r\n    event SwapTokenChange(uint startTokenBalance, uint change);\r\n    event CaughtWithToken(address indexed sender, uint monsterId, ERC20 token, uint amount);\r\n    event ETHReceived(address indexed sender, uint amount);\r\n\r\n    address public KyberNetwork;\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    /// @dev Contract contstructor\r\n    /// @param _KyberNetwork KyberNetwork main contract address\r\n    constructor (address _KyberNetwork) public {\r\n        KyberNetwork = _KyberNetwork;\r\n    }\r\n\r\n    /// @dev Return the ETH to user that was taken back by the network\r\n    function() public payable {\r\n        // Only receive ETH from KyberNetwork main contract\r\n        require(msg.sender == KyberNetwork);\r\n        emit ETHReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Can only be called by operators\r\n    /// @dev Sets the KyberNetwork address\r\n    /// @param _KyberNetwork KyberNetwork contract address\r\n    function setKyberNetwork(address _KyberNetwork) public onlyOperator {\r\n      KyberNetwork = _KyberNetwork;\r\n    }\r\n\r\n    /// @dev Get the ETH price of the Etheremon monster and if it is catchable\r\n    /// @param _etheremon EtheremonWorldNFT address\r\n    /// @param _classId Class ID of monster\r\n    /// @param _payPrice Price of monster passed from Etheremon server\r\n    /// @return catchable, monsterInETH\r\n    function getMonsterPriceInETH(\r\n        EtheremonWorldNFT _etheremon,\r\n        uint32 _classId,\r\n        uint _payPrice\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            bool catchable,\r\n            uint monsterInETH\r\n        )\r\n    {\r\n        // Get monster details from Etheremon contract\r\n        (catchable, monsterInETH) = _etheremon.getPrice(_classId);\r\n\r\n        // Get the highest price from contract pricing or offchain pricing\r\n        monsterInETH = max(monsterInETH, _payPrice);\r\n\r\n        return (catchable, monsterInETH);\r\n    }\r\n\r\n    /// @dev Get the rates of the Etheremon monster\r\n    /// @param _kyberProxy KyberNetworkProxyInterface address\r\n    /// @param token ERC20 token address\r\n    /// @param monsterInETH Price of the monster in ETH\r\n    /// @return expectedRate, slippageRate\r\n    function getMonsterRates(\r\n        KyberNetworkProxyInterface _kyberProxy,\r\n        ERC20 token,\r\n        uint monsterInETH\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint expectedRate,\r\n            uint slippageRate\r\n        )\r\n    {\r\n        // Get the expected and slippage rates of the token to ETH\r\n        (expectedRate, slippageRate) = _kyberProxy.getExpectedRate(token, ETH_TOKEN_ADDRESS, monsterInETH);\r\n\r\n        return (expectedRate, slippageRate);\r\n    }\r\n\r\n    /// @dev Get the token price and rates of the Etheremon monster\r\n    /// @param token ERC20 token address\r\n    /// @param expectedRate Expected rate of ETH to token\r\n    /// @param monsterInETH Price of the monster in ETH\r\n    /// @return monsterInTokens\r\n    function getMonsterPriceInTokens(\r\n        ERC20 token,\r\n        uint expectedRate,\r\n        uint monsterInETH\r\n    )\r\n        public\r\n        view\r\n        returns (uint monsterInTokens)\r\n    {\r\n        // If expectedRate is 0, return 0 for monster price in tokens\r\n        if (expectedRate == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Calculate monster price in tokens\r\n        monsterInTokens = calcSrcAmount(ETH_TOKEN_ADDRESS, token, monsterInETH, expectedRate);\r\n\r\n        return monsterInTokens;\r\n    }\r\n\r\n    /// @dev Acquires the monster from Etheremon using tokens\r\n    /// @param _kyberProxy KyberNetworkProxyInterface address\r\n    /// @param _etheremon EtheremonWorldNFT address\r\n    /// @param _classId Class ID of monster\r\n    /// @param _name Name of the monster\r\n    /// @param token ERC20 token address\r\n    /// @param tokenQty Amount of tokens to be transferred by user\r\n    /// @param maxDestQty Actual amount of ETH needed to purchase the monster\r\n    /// @param minRate The minimum rate or slippage rate.\r\n    /// @param walletId Wallet ID where Kyber referral fees will be sent to\r\n    /// @return monsterId\r\n    function catchMonster(\r\n        KyberNetworkProxyInterface _kyberProxy,\r\n        EtheremonWorldNFT _etheremon,\r\n        uint32 _classId,\r\n        string _name,\r\n        ERC20 token,\r\n        uint tokenQty,\r\n        uint maxDestQty,\r\n        uint minRate,\r\n        address walletId\r\n    )\r\n        public\r\n        returns (uint monsterId)\r\n    {\r\n        // Check that the player has transferred the token to this contract\r\n        require(token.transferFrom(msg.sender, this, tokenQty));\r\n\r\n        // Get the starting token balance of the player's wallet\r\n        uint startTokenBalance = token.balanceOf(this);\r\n\r\n        // Mitigate ERC20 Approve front-running attack, by initially setting\r\n        // allowance to 0\r\n        require(token.approve(_kyberProxy, 0));\r\n\r\n        // Verify that the token balance has not decreased from front-running\r\n        require(token.balanceOf(this) == startTokenBalance);\r\n\r\n        // Once verified, set the token allowance to tokenQty\r\n        require(token.approve(_kyberProxy, tokenQty));\r\n\r\n        // Swap player's token to ETH to send to Etheremon payments contract\r\n        uint userETH = _kyberProxy.tradeWithHint(\r\n            token,\r\n            tokenQty,\r\n            ETH_TOKEN_ADDRESS,\r\n            address(this),\r\n            maxDestQty,\r\n            minRate,\r\n            walletId,\r\n            \"\"\r\n        );\r\n\r\n        // Acquire the monster and send to player\r\n        monsterId = _etheremon.catchMonster.value(userETH)(msg.sender, _classId, _name);\r\n\r\n        // Log event that monster was caught using tokens\r\n        emit CaughtWithToken(msg.sender, monsterId, token, tokenQty);\r\n\r\n        // Return change to player if any\r\n        calcPlayerChange(token, startTokenBalance);\r\n\r\n        return monsterId;\r\n    }\r\n\r\n    /// @dev Calculates token change and returns to player\r\n    /// @param token ERC20 token address\r\n    /// @param startTokenBalance Starting token balance of the player's wallet\r\n    function calcPlayerChange(ERC20 token, uint startTokenBalance) private {\r\n        // Calculate change of player\r\n        uint change = token.balanceOf(this);\r\n\r\n        // Send back change if change is > 0\r\n        if (change > 0) {\r\n            // Log the exchange event\r\n            emit SwapTokenChange(startTokenBalance, change);\r\n\r\n            // Transfer change back to player\r\n            token.transfer(msg.sender, change);\r\n        }\r\n    }\r\n\r\n    /// @dev Gets the max between two uint params\r\n    /// @param a Param A\r\n    /// @param b Param B\r\n    /// @return result\r\n    function max(uint a, uint b) private pure returns (uint result) {\r\n        return a > b ? a : b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_kyberProxy\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"monsterInETH\",\"type\":\"uint256\"}],\"name\":\"getMonsterRates\",\"outputs\":[{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_KyberNetwork\",\"type\":\"address\"}],\"name\":\"setKyberNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"monsterInETH\",\"type\":\"uint256\"}],\"name\":\"getMonsterPriceInTokens\",\"outputs\":[{\"name\":\"monsterInTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_etheremon\",\"type\":\"address\"},{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_payPrice\",\"type\":\"uint256\"}],\"name\":\"getMonsterPriceInETH\",\"outputs\":[{\"name\":\"catchable\",\"type\":\"bool\"},{\"name\":\"monsterInETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KyberNetwork\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kyberProxy\",\"type\":\"address\"},{\"name\":\"_etheremon\",\"type\":\"address\"},{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokenQty\",\"type\":\"uint256\"},{\"name\":\"maxDestQty\",\"type\":\"uint256\"},{\"name\":\"minRate\",\"type\":\"uint256\"},{\"name\":\"walletId\",\"type\":\"address\"}],\"name\":\"catchMonster\",\"outputs\":[{\"name\":\"monsterId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorsGroup\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_KyberNetwork\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"change\",\"type\":\"uint256\"}],\"name\":\"SwapTokenChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"monsterId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CaughtWithToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"WrapEtheremon","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a5e367443a0284a7713f7678ad8f31763c5566a913d91b8ffa7b0d1852261bb0"}]}