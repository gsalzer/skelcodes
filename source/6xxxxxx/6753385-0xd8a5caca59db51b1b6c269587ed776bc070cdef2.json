{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Ownable {\r\n    \r\n    address public owner = 0x0;\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n     modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract CryptoSoulPresale is Ownable{\r\n    struct DataBase{\r\n        uint256 deposit;\r\n        uint256 soulValue;\r\n    }\r\n    \r\n    mapping(address => DataBase) wallets;\r\n    \r\n    uint32 public usersCount = 0;\r\n    uint32 public depositsCount = 0;\r\n    \r\n    uint256 public constant soulCap = 50000000;\r\n    \r\n    uint256 public collectedFunds = 0;\r\n    uint256 public distributedTokens = 0;\r\n    \r\n    uint256 internal soulReward0 = 34000;\r\n    uint256 internal soulReward1 = 40000;\r\n    uint256 internal soulReward2 = 50000;\r\n    \r\n    uint256 public minDeposit = 0.1 ether;\r\n    uint256 internal ethPriceLvl0 = 2.99 ether;\r\n    uint256 internal ethPriceLvl1 = 9.99 ether;\r\n    \r\n    function() external payable{\r\n        require(msg.value >= minDeposit &&\r\n        distributedTokens < soulCap);\r\n        uint256 ethValue = msg.value;\r\n        uint256 soulValue = getSoulByEth(ethValue);     \r\n        uint256 totalSoulValue = distributedTokens + soulValue;\r\n        if (totalSoulValue > soulCap){\r\n            soulValue = soulCap - distributedTokens;\r\n            ethValue = getResidualEtherAmount(ethValue, soulValue);\r\n            uint256 etherNickel = msg.value - ethValue;\r\n            msg.sender.transfer(etherNickel);\r\n        }\r\n        owner.transfer(ethValue);\r\n        depositsCount++;\r\n        countUser(msg.sender);\r\n        wallets[msg.sender].deposit += ethValue;\r\n        wallets[msg.sender].soulValue += soulValue;\r\n        collectedFunds += ethValue;\r\n        distributedTokens += soulValue;\r\n    }\r\n  \r\n  function getDepositValue(address _owner) public view returns(uint256){\r\n      return wallets[_owner].deposit;\r\n  }\r\n  \r\n  function balanceOf(address _owner) public view returns(uint256){\r\n      return wallets[_owner].soulValue;\r\n  }\r\n  \r\n  function getResidualEtherAmount(uint256 _ethValue, uint256 _soulResidual) internal view returns(uint256){\r\n      return _soulResidual * 10 ** 18 / getRewardLevel(_ethValue);\r\n  }\r\n  \r\n   function getSoulByEth(uint256 _ethValue) internal view returns(uint256){\r\n       return (_ethValue * getRewardLevel(_ethValue)) / 10 ** 18;\r\n   }\r\n   \r\n   function getRewardLevel(uint256 _ethValue) internal view returns(uint256){\r\n        if (_ethValue <= ethPriceLvl0){\r\n           return soulReward0;\r\n       } else if (_ethValue > ethPriceLvl0 && _ethValue <= ethPriceLvl1){\r\n           return soulReward1;\r\n       } else if (_ethValue > ethPriceLvl1){\r\n           return soulReward2;\r\n       }\r\n   }\r\n   \r\n   function countUser(address _owner) internal{\r\n       if (wallets[_owner].deposit == 0){\r\n           usersCount++;\r\n       }\r\n   }\r\n   \r\n   function changeSoulReward(uint8 _level, uint256 _value) public onlyOwner{\r\n       require(_level >= 0 && _level <= 2);\r\n       if(_level == 0){\r\n           soulReward0 = _value;\r\n       }else if(_level == 1){\r\n           soulReward1 = _value;\r\n       }else{\r\n           soulReward2 = _value;\r\n       }\r\n   }\r\n   \r\n   function changeMinDeposit(uint256 _value) public onlyOwner{\r\n       minDeposit = _value;\r\n   }\r\n   \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getDepositValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeMinDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeSoulReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soulCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"CryptoSoulPresale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f0da6a6cd5619c006d1ecd4ef96edeaa3cb6fc01f454d1b7a5eedb83b90afd7e"}]}