{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*\r\n*__/\\\\\\\\\\\\\\\\\\\\\\\\\\__________________________________________________/\\\\\\\\\\\\\\\\\\\\\\\\\\______________________________________________\r\n* _\\/\\\\\\/////////\\\\\\_______________________________________________\\/\\\\\\/////////\\\\\\_______________________________/\\\\\\_________\r\n*  _\\/\\\\\\_______\\/\\\\\\__/\\\\\\___/\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\_____/\\\\\\__/\\\\\\_\\/\\\\\\_______\\/\\\\\\______________________________\\/\\\\\\_________\r\n*   _\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\///___/\\\\\\////\\\\\\__/\\\\\\////\\\\\\___\\//\\\\\\/\\\\\\__\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\___/\\\\\\\\\\\\\\\\\\_____/\\\\/\\\\\\\\\\\\___\\/\\\\\\\\\\\\\\\\____\r\n*    _\\/\\\\\\/////////_____/\\\\\\_\\//\\\\\\\\\\\\\\\\\\_\\//\\\\\\\\\\\\\\\\\\____\\//\\\\\\\\\\___\\/\\\\\\/////////\\\\\\_\\////////\\\\\\___\\/\\\\\\////\\\\\\__\\/\\\\\\////\\\\\\__\r\n*     _\\/\\\\\\_____________\\/\\\\\\__\\///////\\\\\\__\\///////\\\\\\_____\\//\\\\\\____\\/\\\\\\_______\\/\\\\\\___/\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\__\\//\\\\\\_\\/\\\\\\\\\\\\\\\\/___\r\n*      _\\/\\\\\\_____________\\/\\\\\\__/\\\\_____\\\\\\__/\\\\_____\\\\\\__/\\\\_/\\\\\\_____\\/\\\\\\_______\\/\\\\\\__/\\\\\\/////\\\\\\__\\/\\\\\\___\\/\\\\\\_\\/\\\\\\///\\\\\\___\r\n*       _\\/\\\\\\_____________\\/\\\\\\_\\//\\\\\\\\\\\\\\\\__\\//\\\\\\\\\\\\\\\\__\\//\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\//\\\\\\\\\\\\\\\\/\\\\_\\/\\\\\\___\\/\\\\\\_\\/\\\\\\_\\///\\\\\\_\r\n*        _\\///______________\\///___\\////////____\\////////____\\////________\\/////////////_____\\////////\\//__\\///____\\///__\\///____\\///__\r\n*/\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyThisOwner(address _owner) {\r\n        require(owner == _owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Betting {\r\n\r\n    uint8 public constant betsCount = 28;\r\n    uint8 public constant betKillCount = 2;\r\n    struct Bet {\r\n        uint256 minSum;     // min value eth for choose this bet\r\n        uint256 cooldown;   // time for reset timer\r\n    }\r\n\r\n    Bet[] public bets;\r\n\r\n    constructor() public {\r\n        bets.push(Bet(0.01 ether, 86400));  // 24 hour\r\n        bets.push(Bet(0.02 ether, 82800));  // 23 hour\r\n        bets.push(Bet(0.03 ether, 79200));  // 22 hour\r\n        bets.push(Bet(0.04 ether, 75600));  // 21 hour\r\n        bets.push(Bet(0.05 ether, 72000));  // 20 hour\r\n        bets.push(Bet(0.06 ether, 68400));  // 19 hour\r\n        bets.push(Bet(0.07 ether, 64800));  // 18 hour\r\n        bets.push(Bet(0.08 ether, 61200));  // 17 hour\r\n        bets.push(Bet(0.09 ether, 57600));  // 16 hour\r\n        bets.push(Bet(0.1 ether, 54000));   // 15 hour\r\n        bets.push(Bet(0.11 ether, 50400));  // 14 hour\r\n        bets.push(Bet(0.12 ether, 46800));  // 13 hour\r\n        bets.push(Bet(0.13 ether, 43200));  // 12 hour\r\n        bets.push(Bet(0.14 ether, 39600));  // 11 hour\r\n        bets.push(Bet(0.15 ether, 36000));  // 10 hour\r\n        bets.push(Bet(0.16 ether, 32400));  // 9 hour\r\n        bets.push(Bet(0.17 ether, 28800));  // 8 hour\r\n        bets.push(Bet(0.18 ether, 25200));  // 7 hour\r\n        bets.push(Bet(0.19 ether, 21600));  // 6 hour\r\n        bets.push(Bet(0.2 ether, 18000));   // 5 hour\r\n        bets.push(Bet(0.21 ether, 14400));  // 4 hour\r\n        bets.push(Bet(0.22 ether, 10800));  // 3 hour\r\n        bets.push(Bet(0.25 ether, 7200));   // 2 hour\r\n        bets.push(Bet(0.5 ether, 3600));    // 1 hour\r\n        bets.push(Bet(1 ether, 2400));      // 40 min\r\n        bets.push(Bet(5 ether, 1200));      // 20 min\r\n        bets.push(Bet(10 ether, 600));      // 10 min\r\n        bets.push(Bet(50 ether, 300));      // 5 min\r\n    }\r\n\r\n    function getBet(uint256 _betIndex) public view returns(uint256, uint256) {\r\n        Bet memory bet = bets[_betIndex];\r\n        return (bet.minSum, bet.cooldown);\r\n    }\r\n\r\n    function getBetIndex(uint256 _sum) public view returns(uint256) {\r\n        for (uint256 i = betsCount - 1; i >= 0; i--) {\r\n            if (_sum >= bets[i].minSum) return i;\r\n        }\r\n\r\n        revert('Bet not found');\r\n    }\r\n\r\n    function getMinBetIndexForKill(uint256 _index) public view returns(uint256) {\r\n        if (_index < betKillCount) return 0;\r\n\r\n        return _index - betKillCount;\r\n    }\r\n\r\n}\r\n\r\ncontract PiggyBank is Ownable, Betting {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event NewRound(uint256 _roundId, uint256 _endTime);\r\n    event CloseRound(uint256 _roundId);\r\n    event UpdateRound(uint256 _roundId, uint256 _sum, address _winner, uint256 _endTime, uint256 _cap);\r\n    event PayWinCap(uint256 _roundId, address _winner, uint256 _cap);\r\n\r\n    struct Round {\r\n        uint256 endTime;\r\n        uint256 cap;\r\n        uint256 lastBetIndex;\r\n        uint256 countBets;\r\n        address winner;\r\n        bool isPaid;\r\n    }\r\n\r\n    Round[] public rounds;\r\n    uint256 public currentRound;\r\n    uint256 public constant defaultRoundTime = 86400;   // 24 hours\r\n    uint256 public constant freeBetsCount = 5;\r\n    uint256 public constant ownerDistribution = 15;     // 15%\r\n    uint256 public constant referrerDistribution = 5;   // 5%\r\n    mapping (address => address) public playerToReferrer;\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    function getRoundInfo(uint256 _roundId) public view returns(uint256, uint256, uint256, address) {\r\n        Round memory round = rounds[_roundId];\r\n        return (round.endTime, round.cap, round.lastBetIndex, round.winner);\r\n    }\r\n\r\n    function payWinCap(uint256 _roundId) {\r\n        require(rounds[_roundId].endTime < now, 'Round is not closed');\r\n        require(rounds[_roundId].isPaid == false, 'Round is paid');\r\n\r\n        rounds[_roundId].isPaid = true;\r\n        rounds[_roundId].winner.transfer(rounds[_roundId].cap);\r\n\r\n        emit PayWinCap(_roundId, rounds[_roundId].winner, rounds[_roundId].cap);\r\n    }\r\n\r\n    function _startNewRoundIfNeeded() private {\r\n        if (rounds.length > currentRound) return;\r\n\r\n        uint256 roundId = rounds.push(Round(now + defaultRoundTime, 0, 0, 0, 0x0, false)) - 1;\r\n        emit NewRound(roundId, now);\r\n    }\r\n\r\n    function _closeRoundIfNeeded() private {\r\n        if (rounds.length <= currentRound) return;\r\n        if (now <= rounds[currentRound].endTime) return;\r\n\r\n        currentRound = currentRound.add(1);\r\n        emit CloseRound(currentRound - 1);\r\n    }\r\n\r\n    function depositRef(address _referrer) payable public {\r\n        uint256 betIndex = getBetIndex(msg.value);\r\n        // close if needed\r\n        _closeRoundIfNeeded();\r\n\r\n        // for new rounds\r\n        _startNewRoundIfNeeded();\r\n\r\n        require(betIndex >= getMinBetIndexForKill(rounds[currentRound].lastBetIndex), \"More bet value required\");\r\n        Bet storage bet = bets[betIndex];\r\n\r\n        // work with actual\r\n        rounds[currentRound].countBets++;\r\n        rounds[currentRound].lastBetIndex = betIndex;\r\n        rounds[currentRound].endTime = now.add(bet.cooldown);\r\n        rounds[currentRound].winner = msg.sender;\r\n\r\n        // distribution\r\n        uint256 ownerPercent = 0;\r\n        uint256 referrerPercent = 0;\r\n        if (rounds[currentRound].countBets > freeBetsCount) {\r\n            ownerPercent = ownerDistribution;\r\n            if (playerToReferrer[msg.sender] == 0x0 && _referrer != 0x0 && _referrer != msg.sender) playerToReferrer[msg.sender] = _referrer;\r\n            if (playerToReferrer[msg.sender] != 0x0) referrerPercent = referrerDistribution;\r\n        }\r\n\r\n        ownerPercent = ownerPercent.sub(referrerPercent);\r\n        if (ownerPercent > 0) owner.transfer(msg.value * ownerPercent / 100);\r\n        if (referrerPercent > 0 && playerToReferrer[msg.sender] != 0x0) playerToReferrer[msg.sender].transfer(msg.value * referrerPercent / 100);\r\n\r\n        rounds[currentRound].cap = rounds[currentRound].cap.add(msg.value * (100 - (ownerPercent + referrerPercent)) / 100);\r\n\r\n        emit UpdateRound(currentRound, msg.value * (100 - (ownerPercent + referrerPercent)) / 100, rounds[currentRound].winner, rounds[currentRound].endTime, rounds[currentRound].cap);\r\n    }\r\n\r\n    function deposit() payable public {\r\n        depositRef(0x0);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_betIndex\",\"type\":\"uint256\"}],\"name\":\"getBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"minSum\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultRoundTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sum\",\"type\":\"uint256\"}],\"name\":\"getBetIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betKillCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"lastBetIndex\",\"type\":\"uint256\"},{\"name\":\"countBets\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"isPaid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositRef\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerToReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getMinBetIndexForKill\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"payWinCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freeBetsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"CloseRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_sum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"UpdateRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"PayWinCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PiggyBank","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d02bbbed4c7011400b61c9f20e5ba72dec1adb95f7475e06a1b37b7cc776d525"}]}