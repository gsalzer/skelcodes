{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface ConflictResolutionInterface {\r\n    function minHouseStake(uint activeGames) external pure returns(uint);\r\n\r\n    function maxBalance() external pure returns(int);\r\n\r\n    function conflictEndFine() external pure returns(int);\r\n\r\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) external pure returns(bool);\r\n\r\n    function endGameConflict(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed\r\n    )\r\n        external\r\n        view\r\n        returns(int);\r\n\r\n    function serverForceGameEnd(\r\n        uint8 gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        external\r\n        view\r\n        returns(int);\r\n\r\n    function userForceGameEnd(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        external\r\n        view\r\n        returns(int);\r\n}\r\n\r\ncontract ConflictResolution is ConflictResolutionInterface {\r\n    using SafeCast for int;\r\n    using SafeCast for uint;\r\n    using SafeMath for int;\r\n    using SafeMath for uint;\r\n\r\n    uint public constant DICE_RANGE = 100;\r\n    uint public constant HOUSE_EDGE = 150;\r\n    uint public constant HOUSE_EDGE_DIVISOR = 10000;\r\n\r\n    uint public constant SERVER_TIMEOUT = 6 hours;\r\n    uint public constant USER_TIMEOUT = 6 hours;\r\n\r\n    uint8 public constant DICE_LOWER = 1; ///< @dev dice game lower number wins\r\n    uint8 public constant DICE_HIGHER = 2; ///< @dev dice game higher number wins\r\n\r\n    uint public constant MIN_BET_VALUE = 1e13; /// min 0.00001 ether bet\r\n    uint public constant MIN_BANKROLL = 15e18;\r\n\r\n    int public constant NOT_ENDED_FINE = 1e15; /// 0.001 ether\r\n\r\n    int public constant CONFLICT_END_FINE = 1e15; /// 0.001 ether\r\n\r\n    uint public constant PROBABILITY_DIVISOR = 10000;\r\n\r\n    int public constant MAX_BALANCE = int(MIN_BANKROLL / 2);\r\n\r\n    modifier onlyValidBet(uint8 _gameType, uint _betNum, uint _betValue) {\r\n        require(isValidBet(_gameType, _betNum, _betValue), \"inv bet\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidBalance(int _balance, uint _gameStake) {\r\n        require(-_gameStake.castToInt() <= _balance && _balance <= MAX_BALANCE, \"inv balance\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Calc max bet we allow\r\n     * We definitely do not allow bets greater than kelly criterion would allow.\r\n     * => The max bet is limited to the max profit of houseEdge * bankroll.\r\n     * => maxBet = houseEdge / (1/p * (1 - houseEdge) - 1) * bankroll, with p is win probability.\r\n     * The max bet can be further restricted on backend.\r\n     * @param _winProbability winProbability.\r\n     * @return max allowed bet.\r\n     */\r\n    function maxBet(uint _winProbability) public pure returns(uint) {\r\n        assert(0 < _winProbability && _winProbability < PROBABILITY_DIVISOR);\r\n\r\n        uint tmp1 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE_DIVISOR).div(_winProbability);\r\n        uint tmp2 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE).div(_winProbability);\r\n\r\n        uint enumerator = HOUSE_EDGE.mul(MIN_BANKROLL);\r\n        uint denominator = tmp1.sub(tmp2).sub(HOUSE_EDGE_DIVISOR);\r\n        uint maxBetVal = enumerator.div(denominator);\r\n\r\n        return maxBetVal.add(5e14).div(1e15).mul(1e15); // round to multiple of 0.001 Ether\r\n    }\r\n\r\n    /**\r\n     * @dev Check if bet is valid.\r\n     * @param _gameType Game type.\r\n     * @param _betNum Number of bet.\r\n     * @param _betValue Value of bet.\r\n     * @return True if bet is valid false otherwise.\r\n     */\r\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) public pure returns(bool) {\r\n        bool validMinBetValue = MIN_BET_VALUE <= _betValue;\r\n        bool validGame = false;\r\n\r\n        if (_gameType == DICE_LOWER) {\r\n            validGame = _betNum > 0 && _betNum < DICE_RANGE - 1;\r\n            validGame = validGame && _betValue <= maxBet(_betNum * PROBABILITY_DIVISOR / DICE_RANGE);\r\n        } else if (_gameType == DICE_HIGHER) {\r\n            validGame = _betNum > 0 && _betNum < DICE_RANGE - 1;\r\n            validGame = validGame && _betValue <= maxBet((DICE_RANGE - _betNum - 1) * PROBABILITY_DIVISOR / DICE_RANGE);\r\n        } else {\r\n            validGame = false;\r\n        }\r\n\r\n        return validMinBetValue && validGame;\r\n    }\r\n\r\n    /**\r\n     * @return Conflict end fine.\r\n     */\r\n    function conflictEndFine() public pure returns(int) {\r\n        return CONFLICT_END_FINE;\r\n    }\r\n\r\n    /**\r\n     * @return Max balance.\r\n     */\r\n    function maxBalance() public pure returns(int) {\r\n        return MAX_BALANCE;\r\n    }\r\n\r\n    /**\r\n     * Calculate minimum needed house stake.\r\n     */\r\n    function minHouseStake(uint activeGames) public pure returns(uint) {\r\n        return  MathUtil.min(activeGames, 1) * MIN_BANKROLL;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates game result and returns new balance.\r\n     * @param _gameType Type of game.\r\n     * @param _betNum Bet number.\r\n     * @param _betValue Value of bet.\r\n     * @param _balance Current balance.\r\n     * @param _serverSeed Server's seed of current round.\r\n     * @param _userSeed User's seed of current round.\r\n     * @return New game session balance.\r\n     */\r\n    function endGameConflict(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed\r\n    )\r\n        public\r\n        view\r\n        onlyValidBet(_gameType, _betNum, _betValue)\r\n        onlyValidBalance(_balance, _stake)\r\n        returns(int)\r\n    {\r\n        require(_serverSeed != 0 && _userSeed != 0, \"inv seeds\");\r\n\r\n        int newBalance =  processBet(_gameType, _betNum, _betValue, _balance, _serverSeed, _userSeed);\r\n\r\n        // user need to pay a fee when conflict ended.\r\n        // this ensures a malicious, rich user can not just generate game sessions and then wait\r\n        // for us to end the game session and then confirm the session status, so\r\n        // we would have to pay a high gas fee without profit.\r\n        newBalance = newBalance.sub(CONFLICT_END_FINE);\r\n\r\n        // do not allow balance below user stake\r\n        int stake = _stake.castToInt();\r\n        if (newBalance < -stake) {\r\n            newBalance = -stake;\r\n        }\r\n\r\n        return newBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Force end of game if user does not respond. Only possible after a time period.\r\n     * to give the user a chance to respond.\r\n     * @param _gameType Game type.\r\n     * @param _betNum Bet number.\r\n     * @param _betValue Bet value.\r\n     * @param _balance Current balance.\r\n     * @param _stake User stake.\r\n     * @param _endInitiatedTime Time server initiated end.\r\n     * @return New game session balance.\r\n     */\r\n    function serverForceGameEnd(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        public\r\n        view\r\n        onlyValidBalance(_balance, _stake)\r\n        returns(int)\r\n    {\r\n        require(_endInitiatedTime + SERVER_TIMEOUT <= block.timestamp, \"too low timeout\");\r\n        require(isValidBet(_gameType, _betNum, _betValue)\r\n                || (_gameType == 0 && _betNum == 0 && _betValue == 0 && _balance == 0), \"inv bet\");\r\n\r\n\r\n        // assume user has lost\r\n        int newBalance = _balance.sub(_betValue.castToInt());\r\n\r\n        // penalize user as he didn't end game\r\n        newBalance = newBalance.sub(NOT_ENDED_FINE);\r\n\r\n        // do not allow balance below user stake\r\n        int stake = _stake.castToInt();\r\n        if (newBalance < -stake) {\r\n            newBalance = -stake;\r\n        }\r\n\r\n        return newBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Force end of game if server does not respond. Only possible after a time period\r\n     * to give the server a chance to respond.\r\n     * @param _gameType Game type.\r\n     * @param _betNum Bet number.\r\n     * @param _betValue Value of bet.\r\n     * @param _balance Current balance.\r\n     * @param _endInitiatedTime Time server initiated end.\r\n     * @return New game session balance.\r\n     */\r\n    function userForceGameEnd(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint  _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        public\r\n        view\r\n        onlyValidBalance(_balance, _stake)\r\n        returns(int)\r\n    {\r\n        require(_endInitiatedTime + USER_TIMEOUT <= block.timestamp, \"too low timeout\");\r\n        require(isValidBet(_gameType, _betNum, _betValue)\r\n            || (_gameType == 0 && _betNum == 0 && _betValue == 0 && _balance == 0), \"inv bet\");\r\n\r\n        int profit = 0;\r\n        if (_gameType == 0 && _betNum == 0 && _betValue == 0 && _balance == 0) {\r\n            // user cancelled game without playing\r\n            profit = 0;\r\n        } else {\r\n            profit = calculateProfit(_gameType, _betNum, _betValue); // safe to cast as ranges are limited\r\n        }\r\n\r\n        // penalize server as it didn't end game\r\n        profit = profit.add(NOT_ENDED_FINE);\r\n\r\n        return _balance.add(profit);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate new balance after executing bet.\r\n     * @param _gameType game type.\r\n     * @param _betNum Bet Number.\r\n     * @param _betValue Value of bet.\r\n     * @param _balance Current balance.\r\n     * @param _serverSeed Server's seed\r\n     * @param _userSeed User's seed\r\n     * return new balance.\r\n     */\r\n    function processBet(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed\r\n    )\r\n        public\r\n        pure\r\n        returns (int)\r\n    {\r\n        bool won = hasUserWon(_gameType, _betNum, _serverSeed, _userSeed);\r\n        if (!won) {\r\n            return _balance.sub(_betValue.castToInt());\r\n        } else {\r\n            int profit = calculateProfit(_gameType, _betNum, _betValue);\r\n            return _balance.add(profit);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate user profit.\r\n     * @param _gameType type of game.\r\n     * @param _betNum bet numbe.\r\n     * @param _betValue bet value.\r\n     * return profit of user\r\n     */\r\n    function calculateProfit(uint8 _gameType, uint _betNum, uint _betValue) private pure returns(int) {\r\n        uint betValueInGwei = _betValue / 1e9; // convert to gwei\r\n        int res = 0;\r\n\r\n        if (_gameType == DICE_LOWER) {\r\n            res = calculateProfitGameType1(_betNum, betValueInGwei);\r\n        } else if (_gameType == DICE_HIGHER) {\r\n            res = calculateProfitGameType2(_betNum, betValueInGwei);\r\n        } else {\r\n            assert(false);\r\n        }\r\n        return res.mul(1e9); // convert to wei\r\n    }\r\n\r\n    /**\r\n     * Calculate user profit from total won.\r\n     * @param _totalWon user winning in gwei.\r\n     * @return user profit in gwei.\r\n     */\r\n    function calcProfitFromTotalWon(uint _totalWon, uint _betValue) private pure returns(int) {\r\n        uint houseEdgeValue = _totalWon.mul(HOUSE_EDGE).div(HOUSE_EDGE_DIVISOR);\r\n\r\n        return _totalWon.castToInt().sub(houseEdgeValue.castToInt()).sub(_betValue.castToInt());\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate user profit if user has won for game type 1 (dice lower wins).\r\n     * @param _betNum Bet number of user.\r\n     * @param _betValue Value of bet in gwei.\r\n     * @return Users' profit.\r\n     */\r\n    function calculateProfitGameType1(uint _betNum, uint _betValue) private pure returns(int) {\r\n        assert(_betNum > 0 && _betNum < DICE_RANGE);\r\n\r\n        uint totalWon = _betValue.mul(DICE_RANGE).div(_betNum);\r\n        return calcProfitFromTotalWon(totalWon, _betValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate user profit if user has won for game type 2 (dice lower wins).\r\n     * @param _betNum Bet number of user.\r\n     * @param _betValue Value of bet in gwei.\r\n     * @return Users' profit.\r\n     */\r\n    function calculateProfitGameType2(uint _betNum, uint _betValue) private pure returns(int) {\r\n        assert(_betNum >= 0 && _betNum < DICE_RANGE - 1);\r\n\r\n        // safe as ranges are fixed\r\n        uint totalWon = _betValue.mul(DICE_RANGE).div(DICE_RANGE.sub(_betNum).sub(1));\r\n        return calcProfitFromTotalWon(totalWon, _betValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if user hash won or lost.\r\n     * @return true if user has won.\r\n     */\r\n    function hasUserWon(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed\r\n    )\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        bytes32 combinedHash = keccak256(abi.encodePacked(_serverSeed, _userSeed));\r\n        uint randNum = uint(combinedHash);\r\n\r\n        if (_gameType == 1) {\r\n            return calculateWinnerGameType1(randNum, _betNum);\r\n        } else if (_gameType == 2) {\r\n            return calculateWinnerGameType2(randNum, _betNum);\r\n        } else {\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate winner of game type 1 (roll lower).\r\n     * @param _randomNum 256 bit random number.\r\n     * @param _betNum Bet number.\r\n     * @return True if user has won false if he lost.\r\n     */\r\n    function calculateWinnerGameType1(uint _randomNum, uint _betNum) private pure returns(bool) {\r\n        assert(_betNum > 0 && _betNum < DICE_RANGE);\r\n\r\n        uint resultNum = _randomNum % DICE_RANGE; // bias is negligible\r\n        return resultNum < _betNum;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate winner of game type 2 (roll higher).\r\n     * @param _randomNum 256 bit random number.\r\n     * @param _betNum Bet number.\r\n     * @return True if user has won false if he lost.\r\n     */\r\n    function calculateWinnerGameType2(uint _randomNum, uint _betNum) private pure returns(bool) {\r\n        assert(_betNum >= 0 && _betNum < DICE_RANGE - 1);\r\n\r\n        uint resultNum = _randomNum % DICE_RANGE; // bias is negligible\r\n        return resultNum > _betNum;\r\n    }\r\n}\r\n\r\nlibrary MathUtil {\r\n    /**\r\n     * @dev Returns the absolute value of _val.\r\n     * @param _val value\r\n     * @return The absolute value of _val.\r\n     */\r\n    function abs(int _val) internal pure returns(uint) {\r\n        if (_val < 0) {\r\n            return uint(-_val);\r\n        } else {\r\n            return uint(_val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate maximum.\r\n     */\r\n    function max(uint _val1, uint _val2) internal pure returns(uint) {\r\n        return _val1 >= _val2 ? _val1 : _val2;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate minimum.\r\n     */\r\n    function min(uint _val1, uint _val2) internal pure returns(uint) {\r\n        return _val1 <= _val2 ? _val1 : _val2;\r\n    }\r\n}\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * Cast unsigned a to signed a.\r\n     */\r\n    function castToInt(uint a) internal pure returns(int) {\r\n        assert(a < (1 << 255));\r\n        return int(a);\r\n    }\r\n\r\n    /**\r\n     * Cast signed a to unsigned a.\r\n     */\r\n    function castToUint(int a) internal pure returns(uint) {\r\n        assert(a >= 0);\r\n        return uint(a);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, throws on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        int256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers, truncating the quotient.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // Overflow only happens when the smallest negative int is multiplied by -1.\r\n        int256 INT256_MIN = int256((uint256(1) << 255));\r\n        assert(a != INT256_MIN || b != - 1);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, throws on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        assert((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, throws on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        assert((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"isValidBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_stake\",\"type\":\"uint256\"},{\"name\":\"_endInitiatedTime\",\"type\":\"uint256\"}],\"name\":\"userForceGameEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"hasUserWon\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_winProbability\",\"type\":\"uint256\"}],\"name\":\"maxBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_stake\",\"type\":\"uint256\"},{\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"endGameConflict\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DICE_RANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONFLICT_END_FINE\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"activeGames\",\"type\":\"uint256\"}],\"name\":\"minHouseStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_stake\",\"type\":\"uint256\"},{\"name\":\"_endInitiatedTime\",\"type\":\"uint256\"}],\"name\":\"serverForceGameEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NOT_ENDED_FINE\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"processBet\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BANKROLL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DICE_HIGHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DICE_LOWER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USER_TIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SERVER_TIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BALANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROBABILITY_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conflictEndFine\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ConflictResolution","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6be29ce413f4b33e06b7583626a22836d37cc00c37edc3c262aa8a9c47158a05"}]}