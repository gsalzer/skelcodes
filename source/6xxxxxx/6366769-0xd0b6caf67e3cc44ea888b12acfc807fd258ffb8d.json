{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20Interface - Standard ERC20 Interface Definition\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n// Based on the final ERC20 specification at:\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n\r\n   event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n   function name() public view returns (string);\r\n   function symbol() public view returns (string);\r\n   function decimals() public view returns (uint8);\r\n   function totalSupply() public view returns (uint256);\r\n\r\n   function balanceOf(address _owner) public view returns (uint256 balance);\r\n   function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n   function transfer(address _to, uint256 _value) public returns (bool success);\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n   function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Math - General Math Utility Library\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary Math {\r\n\r\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      uint256 r = a + b;\r\n\r\n      require(r >= a);\r\n\r\n      return r;\r\n   }\r\n\r\n\r\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      require(a >= b);\r\n\r\n      return a - b;\r\n   }\r\n\r\n\r\n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      if (a == 0) {\r\n         return 0;\r\n      }\r\n\r\n      uint256 r = a * b;\r\n\r\n      require(r / a == b);\r\n\r\n      return r;\r\n   }\r\n\r\n\r\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      return a / b;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned - Ownership model with 2 phase transfers\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// Implements a simple ownership model with 2-phase transfer.\r\ncontract Owned {\r\n\r\n   address public owner;\r\n   address public proposedOwner;\r\n\r\n   event OwnershipTransferInitiated(address indexed _proposedOwner);\r\n   event OwnershipTransferCompleted(address indexed _newOwner);\r\n\r\n\r\n   constructor() public\r\n   {\r\n      owner = msg.sender;\r\n   }\r\n\r\n\r\n   modifier onlyOwner() {\r\n      require(isOwner(msg.sender) == true);\r\n      _;\r\n   }\r\n\r\n\r\n   function isOwner(address _address) public view returns (bool) {\r\n      return (_address == owner);\r\n   }\r\n\r\n\r\n   function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool) {\r\n      require(_proposedOwner != address(0));\r\n      require(_proposedOwner != address(this));\r\n      require(_proposedOwner != owner);\r\n\r\n      proposedOwner = _proposedOwner;\r\n\r\n      emit OwnershipTransferInitiated(proposedOwner);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   function completeOwnershipTransfer() public returns (bool) {\r\n      require(msg.sender == proposedOwner);\r\n\r\n      owner = msg.sender;\r\n      proposedOwner = address(0);\r\n\r\n      emit OwnershipTransferCompleted(owner);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Finalizable - Basic implementation of the finalization pattern\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract Finalizable is Owned() {\r\n\r\n   bool public finalized;\r\n\r\n   event Finalized();\r\n\r\n\r\n   constructor() public\r\n   {\r\n      finalized = false;\r\n   }\r\n\r\n\r\n   function finalize() public onlyOwner returns (bool) {\r\n      require(!finalized);\r\n\r\n      finalized = true;\r\n\r\n      emit Finalized();\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// OpsManaged - Implements an Owner and Ops Permission Model\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n//\r\n// Implements a security model with owner and ops.\r\n//\r\ncontract OpsManaged is Owned() {\r\n\r\n   address public opsAddress;\r\n\r\n   event OpsAddressUpdated(address indexed _newAddress);\r\n\r\n\r\n   constructor() public\r\n   {\r\n   }\r\n\r\n\r\n   modifier onlyOwnerOrOps() {\r\n      require(isOwnerOrOps(msg.sender));\r\n      _;\r\n   }\r\n\r\n\r\n   function isOps(address _address) public view returns (bool) {\r\n      return (opsAddress != address(0) && _address == opsAddress);\r\n   }\r\n\r\n\r\n   function isOwnerOrOps(address _address) public view returns (bool) {\r\n      return (isOwner(_address) || isOps(_address));\r\n   }\r\n\r\n\r\n   function setOpsAddress(address _newOpsAddress) public onlyOwner returns (bool) {\r\n      require(_newOpsAddress != owner);\r\n      require(_newOpsAddress != address(this));\r\n\r\n      opsAddress = _newOpsAddress;\r\n\r\n      emit OpsAddressUpdated(opsAddress);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20Token - Standard ERC20 Implementation\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract ERC20Token is ERC20Interface {\r\n\r\n   using Math for uint256;\r\n\r\n   string  private tokenName;\r\n   string  private tokenSymbol;\r\n   uint8   private tokenDecimals;\r\n   uint256 internal tokenTotalSupply;\r\n\r\n   mapping(address => uint256) internal balances;\r\n   mapping(address => mapping (address => uint256)) allowed;\r\n\r\n\r\n   constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address _initialTokenHolder) public {\r\n      tokenName = _name;\r\n      tokenSymbol = _symbol;\r\n      tokenDecimals = _decimals;\r\n      tokenTotalSupply = _totalSupply;\r\n\r\n      // The initial balance of tokens is assigned to the given token holder address.\r\n      balances[_initialTokenHolder] = _totalSupply;\r\n\r\n      // Per EIP20, the constructor should fire a Transfer event if tokens are assigned to an account.\r\n      emit Transfer(0x0, _initialTokenHolder, _totalSupply);\r\n   }\r\n\r\n\r\n   function name() public view returns (string) {\r\n      return tokenName;\r\n   }\r\n\r\n\r\n   function symbol() public view returns (string) {\r\n      return tokenSymbol;\r\n   }\r\n\r\n\r\n   function decimals() public view returns (uint8) {\r\n      return tokenDecimals;\r\n   }\r\n\r\n\r\n   function totalSupply() public view returns (uint256) {\r\n      return tokenTotalSupply;\r\n   }\r\n\r\n\r\n   function balanceOf(address _owner) public view returns (uint256 balance) {\r\n      return balances[_owner];\r\n   }\r\n\r\n\r\n   function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n   }\r\n\r\n\r\n   function transfer(address _to, uint256 _value) public returns (bool success) {\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      balances[_to] = balances[_to].add(_value);\r\n\r\n      emit Transfer(msg.sender, _to, _value);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n      balances[_from] = balances[_from].sub(_value);\r\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n      balances[_to] = balances[_to].add(_value);\r\n\r\n      emit Transfer(_from, _to, _value);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   function approve(address _spender, uint256 _value) public returns (bool success) {\r\n      allowed[msg.sender][_spender] = _value;\r\n\r\n      emit Approval(msg.sender, _spender, _value);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// FinalizableToken - Extension to ERC20Token with ops and finalization\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n//\r\n// ERC20 token with the following additions:\r\n//    1. Owner/Ops Ownership\r\n//    2. Finalization\r\n//\r\ncontract FinalizableToken is ERC20Token, OpsManaged, Finalizable {\r\n\r\n   using Math for uint256;\r\n\r\n\r\n   // The constructor will assign the initial token supply to the owner (msg.sender).\r\n   constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public\r\n      ERC20Token(_name, _symbol, _decimals, _totalSupply, msg.sender)\r\n      OpsManaged()\r\n      Finalizable()\r\n   {\r\n   }\r\n\r\n\r\n   function transfer(address _to, uint256 _value) public returns (bool success) {\r\n      validateTransfer(msg.sender, _to);\r\n\r\n      return super.transfer(_to, _value);\r\n   }\r\n\r\n\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n      validateTransfer(msg.sender, _to);\r\n\r\n      return super.transferFrom(_from, _to, _value);\r\n   }\r\n\r\n\r\n   function validateTransfer(address _sender, address _to) private view {\r\n      // Once the token is finalized, everybody can transfer tokens.\r\n      if (finalized) {\r\n         return;\r\n      }\r\n\r\n      if (isOwner(_to)) {\r\n         return;\r\n      }\r\n\r\n      // Before the token is finalized, only owner and ops are allowed to initiate transfers.\r\n      // This allows them to move tokens while the sale is still ongoing for example.\r\n      require(isOwnerOrOps(_sender));\r\n   }\r\n}\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// FlexibleTokenSale - Token Sale Contract\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract FlexibleTokenSale is Finalizable, OpsManaged {\r\n\r\n   using Math for uint256;\r\n\r\n   //\r\n   // Lifecycle\r\n   //\r\n   uint256 public startTime;\r\n   uint256 public endTime;\r\n   bool public suspended;\r\n\r\n   //\r\n   // Pricing\r\n   //\r\n   uint256 public tokensPerKEther;\r\n   uint256 public bonus;\r\n   uint256 public maxTokensPerAccount;\r\n   uint256 public contributionMin;\r\n   uint256 public tokenConversionFactor;\r\n\r\n   //\r\n   // Wallets\r\n   //\r\n   address public walletAddress;\r\n\r\n   //\r\n   // Token\r\n   //\r\n   FinalizableToken public token;\r\n\r\n   //\r\n   // Counters\r\n   //\r\n   uint256 public totalTokensSold;\r\n   uint256 public totalEtherCollected;\r\n\r\n\r\n   //\r\n   // Events\r\n   //\r\n   event Initialized();\r\n   event TokensPerKEtherUpdated(uint256 _newValue);\r\n   event MaxTokensPerAccountUpdated(uint256 _newMax);\r\n   event BonusUpdated(uint256 _newValue);\r\n   event SaleWindowUpdated(uint256 _startTime, uint256 _endTime);\r\n   event WalletAddressUpdated(address _newAddress);\r\n   event SaleSuspended();\r\n   event SaleResumed();\r\n   event TokensPurchased(address _beneficiary, uint256 _cost, uint256 _tokens);\r\n   event TokensReclaimed(uint256 _amount);\r\n\r\n\r\n   constructor(uint256 _startTime, uint256 _endTime, address _walletAddress) public\r\n      OpsManaged()\r\n   {\r\n      require(_endTime > _startTime);\r\n\r\n      require(_walletAddress != address(0));\r\n      require(_walletAddress != address(this));\r\n\r\n      walletAddress = _walletAddress;\r\n\r\n      finalized = false;\r\n      suspended = false;\r\n\r\n      startTime = _startTime;\r\n      endTime   = _endTime;\r\n\r\n      // Use some defaults config values. Classes deriving from FlexibleTokenSale\r\n      // should set their own defaults\r\n      tokensPerKEther     = 100000;\r\n      bonus               = 0;\r\n      maxTokensPerAccount = 0;\r\n      contributionMin     = 0.1 ether;\r\n\r\n      totalTokensSold     = 0;\r\n      totalEtherCollected = 0;\r\n   }\r\n\r\n\r\n   function currentTime() public constant returns (uint256) {\r\n      return now;\r\n   }\r\n\r\n\r\n   // Initialize should be called by the owner as part of the deployment + setup phase.\r\n   // It will associate the sale contract with the token contract and perform basic checks.\r\n   function initialize(FinalizableToken _token) external onlyOwner returns(bool) {\r\n      require(address(token) == address(0));\r\n      require(address(_token) != address(0));\r\n      require(address(_token) != address(this));\r\n      require(address(_token) != address(walletAddress));\r\n      require(isOwnerOrOps(address(_token)) == false);\r\n\r\n      token = _token;\r\n\r\n      // This factor is used when converting cost <-> tokens.\r\n      // 18 is because of the ETH -> Wei conversion.\r\n      // 3 because prices are in K ETH instead of just ETH.\r\n      // 4 because bonuses are expressed as 0 - 10000 for 0.00% - 100.00% (with 2 decimals).\r\n      tokenConversionFactor = 10**(uint256(18).sub(_token.decimals()).add(3).add(4));\r\n      require(tokenConversionFactor > 0);\r\n\r\n      emit Initialized();\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   //\r\n   // Owner Configuation\r\n   //\r\n\r\n   // Allows the owner to change the wallet address which is used for collecting\r\n   // ether received during the token sale.\r\n   function setWalletAddress(address _walletAddress) external onlyOwner returns(bool) {\r\n      require(_walletAddress != address(0));\r\n      require(_walletAddress != address(this));\r\n      require(_walletAddress != address(token));\r\n      require(isOwnerOrOps(_walletAddress) == false);\r\n\r\n      walletAddress = _walletAddress;\r\n\r\n      emit WalletAddressUpdated(_walletAddress);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to set an optional limit on the amount of tokens that can be purchased\r\n   // by a contributor. It can also be set to 0 to remove limit.\r\n   function setMaxTokensPerAccount(uint256 _maxTokens) external onlyOwner returns(bool) {\r\n\r\n      maxTokensPerAccount = _maxTokens;\r\n\r\n      emit MaxTokensPerAccountUpdated(_maxTokens);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to specify the conversion rate for ETH -> tokens.\r\n   // For example, passing 1,000,000 would mean that 1 ETH would purchase 1000 tokens.\r\n   function setTokensPerKEther(uint256 _tokensPerKEther) external onlyOwner returns(bool) {\r\n      require(_tokensPerKEther > 0);\r\n\r\n      tokensPerKEther = _tokensPerKEther;\r\n\r\n      emit TokensPerKEtherUpdated(_tokensPerKEther);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to set a bonus to apply to all purchases.\r\n   // For example, setting it to 2000 means that instead of receiving 200 tokens,\r\n   // for a given price, contributors would receive 240 tokens (20.00% bonus).\r\n   function setBonus(uint256 _bonus) external onlyOwner returns(bool) {\r\n      require(_bonus <= 10000);\r\n\r\n      bonus = _bonus;\r\n\r\n      emit BonusUpdated(_bonus);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to set a sale window which will allow the sale (aka buyTokens) to\r\n   // receive contributions between _startTime and _endTime. Once _endTime is reached,\r\n   // the sale contract will automatically stop accepting incoming contributions.\r\n   function setSaleWindow(uint256 _startTime, uint256 _endTime) external onlyOwner returns(bool) {\r\n      require(_startTime > 0);\r\n      require(_endTime > _startTime);\r\n\r\n      startTime = _startTime;\r\n      endTime   = _endTime;\r\n\r\n      emit SaleWindowUpdated(_startTime, _endTime);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to suspend the sale until it is manually resumed at a later time.\r\n   function suspend() external onlyOwner returns(bool) {\r\n      if (suspended == true) {\r\n          return false;\r\n      }\r\n\r\n      suspended = true;\r\n\r\n      emit SaleSuspended();\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to resume the sale.\r\n   function resume() external onlyOwner returns(bool) {\r\n      if (suspended == false) {\r\n          return false;\r\n      }\r\n\r\n      suspended = false;\r\n\r\n      emit SaleResumed();\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   //\r\n   // Contributions\r\n   //\r\n\r\n   // Default payable function which can be used to purchase tokens.\r\n   function () payable public {\r\n      buyTokens(msg.sender);\r\n   }\r\n\r\n\r\n   // Allows the caller to purchase tokens for a specific beneficiary (proxy purchase).\r\n   function buyTokens(address _beneficiary) public payable returns (uint256) {\r\n      return buyTokensInternal(_beneficiary, bonus);\r\n   }\r\n\r\n\r\n   function buyTokensInternal(address _beneficiary, uint256 _bonus) internal returns (uint256) {\r\n      require(!finalized);\r\n      require(!suspended);\r\n      require(currentTime() >= startTime);\r\n      require(currentTime() <= endTime);\r\n      require(msg.value >= contributionMin);\r\n      require(_beneficiary != address(0));\r\n      require(_beneficiary != address(this));\r\n      require(_beneficiary != address(token));\r\n\r\n      // We don't want to allow the wallet collecting ETH to\r\n      // directly be used to purchase tokens.\r\n      require(msg.sender != address(walletAddress));\r\n\r\n      // Check how many tokens are still available for sale.\r\n      uint256 saleBalance = token.balanceOf(address(this));\r\n      require(saleBalance > 0);\r\n\r\n      // Calculate how many tokens the contributor could purchase based on ETH received.\r\n      uint256 tokens = msg.value.mul(tokensPerKEther).mul(_bonus.add(10000)).div(tokenConversionFactor);\r\n      require(tokens > 0);\r\n\r\n      uint256 cost = msg.value;\r\n      uint256 refund = 0;\r\n\r\n      // Calculate what is the maximum amount of tokens that the contributor\r\n      // should be allowed to purchase\r\n      uint256 maxTokens = saleBalance;\r\n\r\n      if (maxTokensPerAccount > 0) {\r\n         // There is a maximum amount of tokens per account in place.\r\n         // Check if the user already hit that limit.\r\n         uint256 userBalance = getUserTokenBalance(_beneficiary);\r\n         require(userBalance < maxTokensPerAccount);\r\n\r\n         uint256 quotaBalance = maxTokensPerAccount.sub(userBalance);\r\n\r\n         if (quotaBalance < saleBalance) {\r\n            maxTokens = quotaBalance;\r\n         }\r\n      }\r\n\r\n      require(maxTokens > 0);\r\n\r\n      if (tokens > maxTokens) {\r\n         // The contributor sent more ETH than allowed to purchase.\r\n         // Limit the amount of tokens that they can purchase in this transaction.\r\n         tokens = maxTokens;\r\n\r\n         // Calculate the actual cost for that new amount of tokens.\r\n         cost = tokens.mul(tokenConversionFactor).div(tokensPerKEther.mul(_bonus.add(10000)));\r\n\r\n         if (msg.value > cost) {\r\n            // If the contributor sent more ETH than needed to buy the tokens,\r\n            // the balance should be refunded.\r\n            refund = msg.value.sub(cost);\r\n         }\r\n      }\r\n\r\n      // This is the actual amount of ETH that can be sent to the wallet.\r\n      uint256 contribution = msg.value.sub(refund);\r\n      walletAddress.transfer(contribution);\r\n\r\n      // Update our stats counters.\r\n      totalTokensSold     = totalTokensSold.add(tokens);\r\n      totalEtherCollected = totalEtherCollected.add(contribution);\r\n\r\n      // Transfer tokens to the beneficiary.\r\n      require(token.transfer(_beneficiary, tokens));\r\n\r\n      // Issue a refund for the excess ETH, as needed.\r\n      if (refund > 0) {\r\n         msg.sender.transfer(refund);\r\n      }\r\n\r\n      emit TokensPurchased(_beneficiary, cost, tokens);\r\n\r\n      return tokens;\r\n   }\r\n\r\n\r\n   // Returns the number of tokens that the user has purchased. Will be checked against the\r\n   // maximum allowed. Can be overriden in a sub class to change the calculations.\r\n   function getUserTokenBalance(address _beneficiary) internal view returns (uint256) {\r\n      return token.balanceOf(_beneficiary);\r\n   }\r\n\r\n\r\n   // Allows the owner to take back the tokens that are assigned to the sale contract.\r\n   function reclaimTokens() external onlyOwner returns (bool) {\r\n      uint256 tokens = token.balanceOf(address(this));\r\n\r\n      if (tokens == 0) {\r\n         return false;\r\n      }\r\n\r\n      address tokenOwner = token.owner();\r\n      require(tokenOwner != address(0));\r\n\r\n      require(token.transfer(tokenOwner, tokens));\r\n\r\n      emit TokensReclaimed(tokens);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// CaspianTokenConfig - Token Contract Configuration\r\n//\r\n// Copyright (c) 2018 Caspian, Limited (TM).\r\n// http://www.caspian.tech/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract CaspianTokenConfig {\r\n\r\n    string  public constant TOKEN_SYMBOL      = \"CSP\";\r\n    string  public constant TOKEN_NAME        = \"Caspian Token\";\r\n    uint8   public constant TOKEN_DECIMALS    = 18;\r\n\r\n    uint256 public constant DECIMALSFACTOR    = 10**uint256(TOKEN_DECIMALS);\r\n    uint256 public constant TOKEN_TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;\r\n}\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// CaspianTokenSaleConfig - Token Sale Configuration\r\n//\r\n// Copyright (c) 2018 Caspian, Limited (TM).\r\n// http://www.caspian.tech/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract CaspianTokenSaleConfig is CaspianTokenConfig {\r\n\r\n    //\r\n    // Time\r\n    //\r\n    uint256 public constant INITIAL_STARTTIME    = 1538553600; // 2018-10-03, 08:00:00 UTC\r\n    uint256 public constant INITIAL_ENDTIME      = 1538726400; // 2018-10-05, 08:00:00 UTC\r\n\r\n\r\n    //\r\n    // Purchases\r\n    //\r\n\r\n    // Minimum amount of ETH that can be used for purchase.\r\n    uint256 public constant CONTRIBUTION_MIN     = 0.5 ether;\r\n\r\n    // Price of tokens, based on the 1 ETH = 4000 CSP conversion ratio.\r\n    uint256 public constant TOKENS_PER_KETHER    = 4000000;\r\n\r\n    // Amount of bonus applied to the sale. 2000 = 20.00% bonus, 750 = 7.50% bonus, 0 = no bonus.\r\n    uint256 public constant BONUS                = 0;\r\n\r\n    // Maximum amount of tokens that can be purchased for each account. 0 for no maximum.\r\n    uint256 public constant TOKENS_ACCOUNT_MAX   = 400000 * DECIMALSFACTOR; // 100 ETH Max\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// CaspianTokenSale - Token Sale Contract\r\n//\r\n// Copyright (c) 2018 Caspian, Limited (TM).\r\n// http://www.caspian.tech/\r\n//\r\n// Based on code from Enuma Technologies.\r\n// Copyright (c) 2017 Enuma Technologies Limited.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract CaspianTokenSale is FlexibleTokenSale, CaspianTokenSaleConfig {\r\n\r\n   //\r\n   // Whitelist\r\n   //\r\n   uint8 public currentPhase;\r\n\r\n   mapping(address => uint8) public whitelist;\r\n\r\n\r\n   //\r\n   // Events\r\n   //\r\n   event WhitelistUpdated(address indexed _account, uint8 _phase);\r\n\r\n\r\n   constructor(address wallet) public\r\n      FlexibleTokenSale(INITIAL_STARTTIME, INITIAL_ENDTIME, wallet)\r\n   {\r\n      tokensPerKEther     = TOKENS_PER_KETHER;\r\n      bonus               = BONUS;\r\n      maxTokensPerAccount = TOKENS_ACCOUNT_MAX;\r\n      contributionMin     = CONTRIBUTION_MIN;\r\n      currentPhase        = 1;\r\n   }\r\n\r\n\r\n   // Allows the owner or ops to add/remove people from the whitelist.\r\n   function updateWhitelist(address _address, uint8 _phase) external onlyOwnerOrOps returns (bool) {\r\n      return updateWhitelistInternal(_address, _phase);\r\n   }\r\n\r\n\r\n   function updateWhitelistInternal(address _address, uint8 _phase) internal returns (bool) {\r\n      require(_address != address(0));\r\n      require(_address != address(this));\r\n      require(_address != walletAddress);\r\n      require(_phase <= 1);\r\n\r\n      whitelist[_address] = _phase;\r\n\r\n      emit WhitelistUpdated(_address, _phase);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner or ops to add/remove people from the whitelist, in batches.\r\n   function updateWhitelistBatch(address[] _addresses, uint8 _phase) external onlyOwnerOrOps returns (bool) {\r\n      require(_addresses.length > 0);\r\n\r\n      for (uint256 i = 0; i < _addresses.length; i++) {\r\n         require(updateWhitelistInternal(_addresses[i], _phase));\r\n      }\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // This is an extension to the buyToken function in FlexibleTokenSale which also takes\r\n   // care of checking contributors against the whitelist. Since buyTokens supports proxy payments\r\n   // we check that both the sender and the beneficiary have been whitelisted.\r\n   function buyTokensInternal(address _beneficiary, uint256 _bonus) internal returns (uint256) {\r\n      require(whitelist[msg.sender] >= currentPhase);\r\n      require(whitelist[_beneficiary] >= currentPhase);\r\n\r\n      return super.buyTokensInternal(_beneficiary, _bonus);\r\n   }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"setBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensPerKEther\",\"type\":\"uint256\"}],\"name\":\"setTokensPerKEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_ENDTIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"updateWhitelistBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"updateWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenConversionFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_ACCOUNT_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_STARTTIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setSaleWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"suspended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOpsAddress\",\"type\":\"address\"}],\"name\":\"setOpsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_TOTALSUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALSFACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokensPerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerKEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"setWalletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwnerOrOps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRIBUTION_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"initiateOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suspend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"completeOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxTokens\",\"type\":\"uint256\"}],\"name\":\"setMaxTokensPerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_PER_KETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"WhitelistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"TokensPerKEtherUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newMax\",\"type\":\"uint256\"}],\"name\":\"MaxTokensPerAccountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"BonusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"SaleWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"WalletAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_cost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"OpsAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferCompleted\",\"type\":\"event\"}]","ContractName":"CaspianTokenSale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009ca9e0139f5558ba9b4a5e71990cd62a4457196b","Library":"","SwarmSource":"bzzr://52e03b652d73656d9e6a3ddb89bcf2c522ae5ef54dc8a30f622dd91dd2d04fb2"}]}