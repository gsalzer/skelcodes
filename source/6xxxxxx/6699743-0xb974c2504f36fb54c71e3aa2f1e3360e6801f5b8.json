{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n/**\r\n* @dev Multiplies two numbers, reverts on overflow.\r\n*/\r\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n// benefit is lost if 'b' is also tested.\r\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\nuint256 c = a * b;\r\nrequire(c / a == b);\r\nreturn c;\r\n}\r\n/**\r\n* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n*/\r\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b > 0); // Solidity only automatically asserts when dividing by 0\r\nuint256 c = a / b;\r\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\nreturn c;\r\n}\r\n/**\r\n* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n*/\r\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\nreturn c;\r\n}\r\n/**\r\n* @dev Adds two numbers, reverts on overflow.\r\n*/\r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a);\r\nreturn c;\r\n}\r\n/**\r\n* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n* reverts when dividing by zero.\r\n*/\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b != 0);\r\nreturn a % b;\r\n}\r\n}\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \\\"user permissions\\\".\r\n*/\r\ncontract Ownable {\r\naddress private _owner;\r\nevent OwnershipTransferred(\r\naddress indexed previousOwner,\r\naddress indexed newOwner\r\n);\r\n/**\r\n* @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n* account.\r\n*/\r\nconstructor() internal {\r\n_owner = msg.sender;\r\nemit OwnershipTransferred(address(0), _owner);\r\n}\r\n/**\r\n* @return the address of the owner.\r\n*/\r\nfunction owner() public view returns(address) {\r\nreturn _owner;\r\n}\r\n/**\r\n* @dev Throws if called by any account other than the owner.\r\n*/\r\nmodifier onlyOwner() {\r\nrequire(isOwner());\r\n_;\r\n}\r\n/**\r\n* @return true if `msg.sender` is the owner of the contract.\r\n*/\r\nfunction isOwner() public view returns(bool) {\r\nreturn msg.sender == _owner;\r\n}\r\n/**\r\n* @dev Allows the current owner to relinquish control of the contract.\r\n* @notice Renouncing to ownership will leave the contract without an owner.\r\n* It will not be possible to call the functions with the `onlyOwner`\r\n* modifier anymore.\r\n*/\r\nfunction renounceOwnership() public onlyOwner {\r\nemit OwnershipTransferred(_owner, address(0));\r\n_owner = address(0);\r\n}\r\n/**\r\n* @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n* @param newOwner The address to transfer ownership to.\r\n*/\r\nfunction transferOwnership(address newOwner) public onlyOwner {\r\n_transferOwnership(newOwner);\r\n}\r\n/**\r\n* @dev Transfers control of the contract to a newOwner.\r\n* @param newOwner The address to transfer ownership to.\r\n*/\r\nfunction _transferOwnership(address newOwner) internal {\r\nrequire(newOwner != address(0));\r\nemit OwnershipTransferred(_owner, newOwner);\r\n_owner = newOwner;\r\n}\r\n}\r\n/**\r\n* @title ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/20\r\n*/\r\ninterface IERC20 {\r\nfunction totalSupply() external view returns (uint256);\r\nfunction balanceOf(address who) external view returns (uint256);\r\nfunction allowance(address owner, address spender)\r\nexternal view returns (uint256);\r\nfunction transfer(address to, uint256 value) external returns (bool);\r\nfunction approve(address spender, uint256 value)\r\nexternal returns (bool);\r\nfunction transferFrom(address from, address to, uint256 value)\r\nexternal returns (bool);\r\nevent Transfer(\r\naddress indexed from,\r\naddress indexed to,\r\nuint256 value\r\n);\r\nevent Approval(\r\naddress indexed owner,\r\naddress indexed spender,\r\nuint256 value\r\n);\r\n}\r\n/**\r\n* @title Standard ERC20 token\r\n*\r\n* @dev Implementation of the basic standard token.\r\n* https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n* \r\n*/\r\ncontract Uptherium is IERC20, Ownable {\r\n\r\nusing SafeMath for uint256;\r\nmapping (address => uint256) private _balances;\r\nmapping (address => mapping (address => uint256)) private _allowed;\r\n\r\nmapping (address => bool) public allowedAddresses;\r\n\r\nuint256 private _totalSupply;\r\nstring private _name = \"Uptherium\";\r\nstring private _symbol = \"UPZT\";\r\nuint8 private _decimals = 18;\r\nbool private _poolsSetted;\r\nbool private _burningAllowed;\r\n\r\nevent Burn(address indexed owner,\r\nuint256 value\r\n);\r\n\r\nmodifier checkTransfer() {\r\nrequire(allowedAddresses[msg.sender] == true);\r\n_;\r\n}\r\nconstructor() public {\r\n_poolsSetted = false;\r\n_burningAllowed = false;\r\nallowedAddresses[msg.sender] = true;\r\n\r\n}\r\n\r\n/**\r\n* @dev Function for adding address to the whitelist.\r\n*/\r\nfunction addAddress(address newAddress) public onlyOwner {\r\nallowedAddresses[newAddress] = true;\r\n}\r\n\r\n/**\r\n* @dev Function for removing address from whitelist.\r\n*/\r\nfunction removeAddress(address oldAddress) public onlyOwner {\r\nallowedAddresses[oldAddress] = false;\r\n}\r\n\r\n/**\r\n* @dev Function for initial token minting.\r\n*/\r\nfunction initialMint(address icoPool, address bountyPool, address teamPool, uint256 icoValue, uint256 bountyValue, uint256 teamValue) public onlyOwner {\r\nrequire(!_poolsSetted);\r\n_mint(icoPool, icoValue);\r\n_mint(bountyPool, bountyValue);\r\n_mint(teamPool, teamValue);\r\n_poolsSetted = true;\r\n}\r\n\r\n/**\r\n* @return the name of the token.\r\n*/\r\nfunction name() public view returns(string) {\r\nreturn _name;\r\n}\r\n/**\r\n* @return the symbol of the token.\r\n*/\r\nfunction symbol() public view returns(string) {\r\nreturn _symbol;\r\n}\r\n/**\r\n* @return the number of decimals of the token.\r\n*/\r\nfunction decimals() public view returns(uint8) {\r\nreturn _decimals;\r\n}\r\n/**\r\n* @dev Total number of tokens in existence\r\n*/\r\nfunction totalSupply() public view returns (uint256) {\r\nreturn _totalSupply;\r\n}\r\n/**\r\n* @dev Gets the balance of the specified address.\r\n* @param owner The address to query the balance of.\r\n* @return An uint256 representing the amount owned by the passed address.\r\n*/\r\nfunction balanceOf(address owner) public view returns (uint256) {\r\nreturn _balances[owner];\r\n}\r\n/**\r\n* @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n* @param owner address The address which owns the funds.\r\n* @param spender address The address which will spend the funds.\r\n* @return A uint256 specifying the amount of tokens still available for the spender.\r\n*/\r\nfunction allowance(\r\naddress owner,\r\naddress spender\r\n)\r\npublic\r\nview\r\nreturns (uint256)\r\n{\r\nreturn _allowed[owner][spender];\r\n}\r\n/**\r\n* @dev Transfer token for a specified address\r\n* @param to The address to transfer to.\r\n* @param value The amount to be transferred.\r\n*/\r\nfunction transfer(address to, uint256 value) public checkTransfer returns (bool) {\r\n_transfer(msg.sender, to, value);\r\nreturn true;\r\n}\r\n/**\r\n* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n* @param spender The address which will spend the funds.\r\n* @param value The amount of tokens to be spent.\r\n*/\r\nfunction approve(address spender, uint256 value) public returns (bool) {\r\nrequire(spender != address(0));\r\n_allowed[msg.sender][spender] = value;\r\nemit Approval(msg.sender, spender, value);\r\nreturn true;\r\n}\r\n/**\r\n* @dev Transfer tokens from one address to another\r\n* @param from address The address which you want to send tokens from\r\n* @param to address The address which you want to transfer to\r\n* @param value uint256 the amount of tokens to be transferred\r\n*/\r\nfunction transferFrom(address from, address to, uint256 value) public checkTransfer returns (bool) {\r\n_allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n_transfer(from, to, value);\r\nreturn true;\r\n}\r\n/**\r\n* @dev Increase the amount of tokens that an owner allowed to a spender.\r\n* approve should be called when allowed_[_spender] == 0. To increment\r\n* allowed value is better to use this function to avoid 2 calls (and wait until\r\n* the first transaction is mined)\r\n* From MonolithDAO Token.sol\r\n* @param spender The address which will spend the funds.\r\n* @param addedValue The amount of tokens to increase the allowance by.\r\n*/\r\nfunction increaseAllowance(\r\naddress spender,\r\nuint256 addedValue\r\n)\r\npublic\r\nreturns (bool)\r\n{\r\nrequire(spender != address(0));\r\n_allowed[msg.sender][spender] = (\r\n_allowed[msg.sender][spender].add(addedValue));\r\nemit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\nreturn true;\r\n}\r\n/**\r\n* @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n* approve should be called when allowed_[_spender] == 0. To decrement\r\n* allowed value is better to use this function to avoid 2 calls (and wait until\r\n* the first transaction is mined)\r\n* From MonolithDAO Token.sol\r\n* @param spender The address which will spend the funds.\r\n* @param subtractedValue The amount of tokens to decrease the allowance by.\r\n*/\r\nfunction decreaseAllowance(\r\naddress spender,\r\nuint256 subtractedValue\r\n)\r\npublic\r\nreturns (bool)\r\n{\r\nrequire(spender != address(0));\r\n_allowed[msg.sender][spender] = (\r\n_allowed[msg.sender][spender].sub(subtractedValue));\r\nemit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\nreturn true;\r\n}\r\n/**\r\n* @dev Transfer token for a specified addresses\r\n* @param from The address to transfer from.\r\n* @param to The address to transfer to.\r\n* @param value The amount to be transferred.\r\n*/\r\nfunction _transfer(address from, address to, uint256 value) internal {\r\nrequire(to != address(0));\r\n_balances[from] = _balances[from].sub(value);\r\n_balances[to] = _balances[to].add(value);\r\nemit Transfer(from, to, value);\r\n}\r\n/**\r\n* @dev Internal function that mints an amount of the token and assigns it to\r\n* an account. This encapsulates the modification of balances such that the\r\n* proper events are emitted.\r\n* @param account The account that will receive the created tokens.\r\n* @param value The amount that will be created.\r\n*/\r\nfunction _mint(address account, uint256 value) internal {\r\nrequire(account != address(0));\r\n_totalSupply = _totalSupply.add(value);\r\n_balances[account] = _balances[account].add(value);\r\nemit Transfer(address(0), account, value);\r\n}\r\n\r\n/**\r\n* @dev Public function that allows burning an amount of the token.\r\n*/\r\nfunction allowBurning() public onlyOwner returns(bool) {\r\n_burningAllowed = true;\r\nreturn _burningAllowed;\r\n}\r\n\r\n/**\r\n* @dev Public function that burns an amount of the token and assigns it to\r\n* an account. This encapsulates the modification of balances such that the\r\n* proper events are emitted.\r\n* @param value The amount that will be burned.\r\n*/\r\nfunction burn(uint256 value) public {\r\nrequire(_burningAllowed);  \r\nrequire(msg.sender != address(0));\r\nrequire(_balances[msg.sender] >= value);\r\n_totalSupply = _totalSupply.sub(value);\r\n_balances[msg.sender] = _balances[msg.sender].sub(value);\r\nemit Burn(address(msg.sender), value);\r\n}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"addAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"removeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowBurning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"icoPool\",\"type\":\"address\"},{\"name\":\"bountyPool\",\"type\":\"address\"},{\"name\":\"teamPool\",\"type\":\"address\"},{\"name\":\"icoValue\",\"type\":\"uint256\"},{\"name\":\"bountyValue\",\"type\":\"uint256\"},{\"name\":\"teamValue\",\"type\":\"uint256\"}],\"name\":\"initialMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Uptherium","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://67a50942df04e987c8bf3cb28027bd75a39f3054654365fb1191af845d6beda3"}]}