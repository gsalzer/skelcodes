{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) public\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SimpleToken\r\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\r\n * Note they can later distribute these tokens as they wish using `transfer` and other\r\n * `StandardToken` functions.\r\n */\r\ncontract OpportyToken is StandardToken {\r\n\r\n  string public constant name = \"OpportyToken\";\r\n  string public constant symbol = \"OPP\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\r\n\r\n  /**\r\n   * @dev Contructor that gives msg.sender all of existing tokens.\r\n   */\r\n  function OpportyToken() public {\r\n    totalSupply = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Escrow is Ownable {\r\n  // status of the project\r\n  enum Status { NEW, PAYED, WORKDONE, CLAIMED, CLOSED }\r\n\r\n  // status of the current work\r\n  enum WorkStatus {NEW, STARTED, FULLYDONE, PARTIALLYDONE }\r\n\r\n  // token address\r\n  address tokenHolder = 0x08990456DC3020C93593DF3CaE79E27935dd69b9;\r\n\r\n  // execute funciton only by token holders\r\n  modifier onlyShareholders {\r\n      require (token.balanceOf(msg.sender) > 0);\r\n      _;\r\n  }\r\n\r\n  // transaction only after deadline\r\n  modifier afterDeadline(uint idProject)\r\n  {\r\n    Project storage project = projects[idProject];\r\n    require (now > project.deadline) ;\r\n    _;\r\n  }\r\n\r\n  // transaction can be executed  by project client\r\n  modifier onlyClient(uint idProject) {\r\n    Project storage project = projects[idProject];\r\n\r\n    require (project.client == msg.sender);\r\n    _;\r\n  }\r\n\r\n  // transaction can be executed only by performer\r\n  modifier onlyPerformer(uint idProject) {\r\n    Project storage project = projects[idProject];\r\n    require (project.performer == msg.sender);\r\n    _;\r\n  }\r\n\r\n  // project in Opporty system\r\n  // TODO: decrease size of struct\r\n  struct Project {\r\n    uint id;\r\n    string  name;\r\n    address client;\r\n    address performer;\r\n    uint deadline;\r\n    uint sum;\r\n    Status status;\r\n    string report;\r\n    WorkStatus wstatus;\r\n    uint votingDeadline;\r\n    uint numberOfVotes;\r\n    uint totalVotesNeeded;\r\n    bool withdrawed;\r\n    Vote[] votes;\r\n    mapping (address => bool) voted;\r\n  }\r\n  // one vote - one element of struct\r\n  struct Vote {\r\n      bool inSupport;\r\n      address voter;\r\n  }\r\n  // event - project was added\r\n  event ProjectAdded(uint idExternal, uint projectID, address performer, string name, uint sum);\r\n  // event - fund was transferred\r\n  event FundTransfered(address recipient, uint amount);\r\n  // work was done\r\n  event WorkDone(uint projectId, address performer, WorkStatus status, string link);\r\n  // already voted\r\n  event Voted(uint projectID, bool position, address voter);\r\n  // status of project changed\r\n  event ChangedProjectStatus(uint projectID, Status status);\r\n\r\n  event log(string val);\r\n  event loga(address addr);\r\n  event logi(uint i);\r\n\r\n  // token for payments\r\n  OpportyToken token;\r\n\r\n  // all projects\r\n  Project[] projects;\r\n\r\n\r\n  // number or projects\r\n  uint public numProjects;\r\n\r\n  function Escrow(address tokenUsed) public\r\n  {\r\n    token = OpportyToken(tokenUsed);\r\n  }\r\n\r\n  function getNumberOfProjects() public constant  returns(uint)\r\n  {\r\n    return numProjects;\r\n  }\r\n\r\n  // Add a project to blockchain\r\n  // idExternal - id in opporty\r\n  // name\r\n  // performer\r\n  // duration\r\n  // sum\r\n  function addProject(uint idExternal, string name, address performer, uint durationInMinutes, uint sum) public\r\n     returns (uint projectId)\r\n  {\r\n    projectId = projects.length++;\r\n    Project storage p = projects[projectId];\r\n    p.id = idExternal;\r\n    p.name = name;\r\n    p.client = msg.sender;\r\n    p.performer = performer;\r\n    p.deadline = now + durationInMinutes * 1 minutes;\r\n    p.sum = sum * 1 ether;\r\n    p.status = Status.NEW;\r\n\r\n    ProjectAdded(idExternal, projectId, performer, name, sum);\r\n    return projectId;\r\n  }\r\n\r\n  function getProjectReport(uint idProject) public constant returns (string t) {\r\n    Project storage p = projects[idProject];\r\n    return p.report;\r\n  }\r\n\r\n  function getJudgeVoted(uint idProject, address judge) public constant returns (bool voted) {\r\n    Project storage p = projects[idProject];\r\n    if (p.voted[judge])\r\n      return true;\r\n       else\r\n      return false;\r\n  }\r\n\r\n  // get status of project\r\n  function getStatus(uint idProject) public constant returns (uint t) {\r\n    Project storage p = projects[idProject];\r\n    return uint(p.status);\r\n  }\r\n\r\n  // is deadline\r\n  function isDeadline(uint idProject) public constant returns (bool f) {\r\n      Project storage p = projects[idProject];\r\n\r\n      if (now >= p.deadline) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n  }\r\n  // pay for project by client\r\n  function payFor(uint idProject) payable onlyClient(idProject) public returns (bool) {\r\n    Project storage project = projects[idProject];\r\n\r\n    uint price = project.sum;\r\n\r\n    require (project.status == Status.NEW);\r\n    if (msg.value >= price) {\r\n      project.status = Status.PAYED;\r\n      FundTransfered(this, msg.value);\r\n      ChangedProjectStatus(idProject, Status.PAYED);\r\n      return true;\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n  // pay by project in tokens\r\n  function payByTokens(uint idProject) onlyClient(idProject) onlyShareholders public {\r\n    Project storage project = projects[idProject];\r\n    require (project.sum <= token.balanceOf(project.client));\r\n    require (token.transferFrom(project.client, tokenHolder, project.sum));\r\n\r\n    ChangedProjectStatus(idProject, Status.PAYED);\r\n  }\r\n  // change status of project - done\r\n  // and provide report\r\n  function workDone(uint idProject, string report, WorkStatus status) onlyPerformer(idProject) afterDeadline(idProject) public {\r\n    Project storage project = projects[idProject];\r\n    require (project.status == Status.PAYED);\r\n\r\n    project.status = Status.WORKDONE;\r\n    project.report = report;\r\n    project.wstatus = status;\r\n\r\n    WorkDone(idProject, project.performer, project.wstatus, project.report);\r\n    ChangedProjectStatus(idProject, Status.WORKDONE);\r\n  }\r\n  // work is done - execured by client\r\n  function acceptWork(uint idProject) onlyClient(idProject) afterDeadline(idProject) public {\r\n    Project storage project = projects[idProject];\r\n    require (project.status == Status.WORKDONE);\r\n    project.status = Status.CLOSED;\r\n    ChangedProjectStatus(idProject, Status.CLOSED);\r\n  }\r\n  // claim - project was undone (?)\r\n  // numberOfVoters\r\n  // debatePeriod - time for voting\r\n  function claimWork(uint idProject, uint numberOfVoters, uint debatePeriod) afterDeadline(idProject) public {\r\n    Project storage project = projects[idProject];\r\n    require (project.status == Status.WORKDONE);\r\n    project.status = Status.CLAIMED;\r\n    project.votingDeadline = now + debatePeriod * 1 minutes;\r\n    project.totalVotesNeeded = numberOfVoters;\r\n    ChangedProjectStatus(idProject, Status.CLAIMED);\r\n  }\r\n\r\n  // voting process\r\n  function vote(uint idProject, bool supportsProject) public\r\n        returns (uint voteID)\r\n  {\r\n        Project storage p = projects[idProject];\r\n        require(p.voted[msg.sender] != true);\r\n        require(p.status == Status.CLAIMED);\r\n        require(p.numberOfVotes < p.totalVotesNeeded);\r\n        require(now >= p.votingDeadline );\r\n\r\n        voteID = p.votes.length++;\r\n        p.votes[voteID] = Vote({inSupport: supportsProject, voter: msg.sender});\r\n        p.voted[msg.sender] = true;\r\n        p.numberOfVotes = voteID + 1;\r\n        Voted(idProject,  supportsProject, msg.sender);\r\n        return voteID;\r\n  }\r\n\r\n  // safeWithdrawal - get money by performer / return money for client\r\n  function safeWithdrawal(uint idProject) afterDeadline(idProject) public\r\n  {\r\n      Project storage p = projects[idProject];\r\n\r\n      // if status closed and was not withdrawed\r\n      require(p.status == Status.CLAIMED || p.status == Status.CLOSED && !p.withdrawed);\r\n\r\n      // if project closed\r\n      if (p.status == Status.CLOSED) {\r\n\r\n        if (msg.sender == p.performer && !p.withdrawed && msg.sender.send(p.sum) ) {\r\n          FundTransfered(msg.sender, p.sum);\r\n          p.withdrawed = true;\r\n        } else {\r\n          revert();\r\n        }\r\n      } else {\r\n        // claim\r\n        uint yea = 0;\r\n        uint nay = 0;\r\n        // calculating votes\r\n        for (uint i = 0; i <  p.votes.length; ++i) {\r\n            Vote storage v = p.votes[i];\r\n\r\n            if (v.inSupport) {\r\n                yea += 1;\r\n            } else {\r\n                nay += 1;\r\n            }\r\n        }\r\n        // если уже время голосования закончилось\r\n        if (now >= p.votingDeadline) {\r\n         if (msg.sender == p.performer && p.numberOfVotes >= p.totalVotesNeeded ) {\r\n            if (yea>nay && !p.withdrawed && msg.sender.send(p.sum)) {\r\n              FundTransfered(msg.sender, p.sum);\r\n              p.withdrawed = true;\r\n              p.status = Status.CLOSED;\r\n              ChangedProjectStatus(idProject, Status.CLOSED);\r\n            }\r\n          }\r\n\r\n          if (msg.sender == p.client) {\r\n            if (nay>=yea && !p.withdrawed &&  msg.sender.send(p.sum)) {\r\n              FundTransfered(msg.sender, p.sum);\r\n              p.withdrawed = true;\r\n              p.status = Status.CLOSED;\r\n              // меняем статус проекта\r\n              ChangedProjectStatus(idProject, Status.CLOSED);\r\n            }\r\n          }\r\n        } else {\r\n          revert();\r\n        }\r\n      }\r\n  }\r\n\r\n  // get tokens\r\n  function safeWithdrawalTokens(uint idProject) afterDeadline(idProject) public\r\n  {\r\n    Project storage p = projects[idProject];\r\n    require(p.status == Status.CLAIMED || p.status == Status.CLOSED && !p.withdrawed);\r\n\r\n    if (p.status == Status.CLOSED) {\r\n\r\n      if (msg.sender == p.performer && token.transfer(p.performer, p.sum) && !p.withdrawed) {\r\n        FundTransfered(msg.sender, p.sum);\r\n        p.withdrawed = true;\r\n      } else {\r\n        revert();\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"payByTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfProjects\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"},{\"name\":\"numberOfVoters\",\"type\":\"uint256\"},{\"name\":\"debatePeriod\",\"type\":\"uint256\"}],\"name\":\"claimWork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProjects\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"getStatus\",\"outputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"},{\"name\":\"judge\",\"type\":\"address\"}],\"name\":\"getJudgeVoted\",\"outputs\":[{\"name\":\"voted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"getProjectReport\",\"outputs\":[{\"name\":\"t\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"acceptWork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"},{\"name\":\"report\",\"type\":\"string\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"workDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"isDeadline\",\"outputs\":[{\"name\":\"f\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"payFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"},{\"name\":\"supportsProject\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"voteID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idExternal\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"performer\",\"type\":\"address\"},{\"name\":\"durationInMinutes\",\"type\":\"uint256\"},{\"name\":\"sum\",\"type\":\"uint256\"}],\"name\":\"addProject\",\"outputs\":[{\"name\":\"projectId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint256\"}],\"name\":\"safeWithdrawalTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenUsed\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"idExternal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"projectID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"performer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"sum\",\"type\":\"uint256\"}],\"name\":\"ProjectAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"performer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"link\",\"type\":\"string\"}],\"name\":\"WorkDone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"projectID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"projectID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"ChangedProjectStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"loga\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"logi\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Escrow","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008ef7c0cf8fe68076446803bb9035bd2a3a5e1581","Library":"","SwarmSource":"bzzr://ca3038d823a0d39fe516dc22a83a3781d19e3be0482c02a2391c2cc36ef36f2e"}]}