{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract VerityToken {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ValidationNodeLock {\r\n  address public owner;\r\n  address public tokenAddress;\r\n  bool public allFundsCanBeUnlocked = false;\r\n  uint public lastLockingTime;\r\n  // 30_000 evt tokens minimal investment\r\n  uint public nodePrice = 30000 * 10**18;\r\n\r\n  uint public lockedUntil;\r\n  mapping(address => mapping(string => uint)) lockingData;\r\n\r\n  event Withdrawn(address indexed withdrawer, uint indexed withdrawnAmount);\r\n  event FundsLocked(\r\n    address indexed user,\r\n    uint indexed lockedAmount,\r\n    uint indexed validationNodes\r\n  );\r\n  event AllFundsCanBeUnlocked(\r\n    uint indexed triggeredTimestamp,\r\n    bool indexed canAllFundsBeUnlocked\r\n  );\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier lastLockingTimeIsInTheFuture(uint _lastLockingTime) {\r\n    require(now < _lastLockingTime);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOnceLockingPeriodIsOver() {\r\n    require(now >= lockedUntil || allFundsCanBeUnlocked);\r\n    _;\r\n  }\r\n\r\n  modifier checkUsersTokenBalance(uint _fundsToTransfer) {\r\n    require(\r\n      _fundsToTransfer <= VerityToken(tokenAddress).balanceOf(msg.sender)\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier checkValidLockingTime() {\r\n    require(now <= lastLockingTime);\r\n    _;\r\n  }\r\n\r\n  modifier checkValidLockingArguments(uint _tokens, uint _nodes) {\r\n    require(_tokens >= nodePrice && _nodes >= 1);\r\n    _;\r\n  }\r\n\r\n  modifier checkValidLockingAmount(uint _tokens, uint _nodes) {\r\n    require(_tokens == (_nodes * nodePrice));\r\n    _;\r\n  }\r\n\r\n  modifier lockedUntilIsInTheFuture(uint _lockedUntil) {\r\n    require(now < _lockedUntil);\r\n    _;\r\n  }\r\n\r\n  modifier lastLockingTimeIsBeforeLockedUntil(\r\n    uint _lastLockingTime,\r\n    uint _lockedUntil\r\n  )\r\n  {\r\n    require(_lastLockingTime < _lockedUntil);\r\n    _;\r\n  }\r\n\r\n  modifier checkLockIsNotTerminated() {\r\n    require(allFundsCanBeUnlocked == false);\r\n    _;\r\n  }\r\n\r\n  constructor(address _tokenAddress, uint _lastLockingTime, uint _lockedUntil)\r\n    public\r\n    lastLockingTimeIsInTheFuture(_lastLockingTime)\r\n    lockedUntilIsInTheFuture(_lockedUntil)\r\n    lastLockingTimeIsBeforeLockedUntil(_lastLockingTime, _lockedUntil)\r\n  {\r\n    owner = msg.sender;\r\n    tokenAddress = _tokenAddress;\r\n    lastLockingTime = _lastLockingTime;\r\n    lockedUntil = _lockedUntil;\r\n  }\r\n\r\n  function lockFunds(uint _tokens, uint _nodes)\r\n    public\r\n    checkValidLockingTime()\r\n    checkLockIsNotTerminated()\r\n    checkUsersTokenBalance(_tokens)\r\n    checkValidLockingArguments(_tokens, _nodes)\r\n    checkValidLockingAmount(_tokens, _nodes)\r\n  {\r\n    require(\r\n      VerityToken(tokenAddress).transferFrom(msg.sender, address(this), _tokens)\r\n    );\r\n\r\n    lockingData[msg.sender][\"amount\"] += _tokens;\r\n    lockingData[msg.sender][\"nodes\"] += _nodes;\r\n\r\n    emit FundsLocked(\r\n      msg.sender,\r\n      _tokens,\r\n      _nodes\r\n    );\r\n  }\r\n\r\n  function withdrawFunds()\r\n    public\r\n    onlyOnceLockingPeriodIsOver()\r\n  {\r\n    uint amountToBeTransferred = lockingData[msg.sender][\"amount\"];\r\n    lockingData[msg.sender][\"amount\"] = 0;\r\n    VerityToken(tokenAddress).transfer(msg.sender, amountToBeTransferred);\r\n\r\n    emit Withdrawn(\r\n      msg.sender,\r\n      amountToBeTransferred\r\n    );\r\n  }\r\n\r\n  function terminateTokenLock() public onlyOwner() {\r\n    allFundsCanBeUnlocked = true;\r\n\r\n    emit AllFundsCanBeUnlocked(\r\n      now,\r\n      allFundsCanBeUnlocked\r\n    );\r\n  }\r\n\r\n  function getUserData(address _user) public view returns (uint[2]) {\r\n    return [lockingData[_user][\"amount\"], lockingData[_user][\"nodes\"]];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_nodes\",\"type\":\"uint256\"}],\"name\":\"lockFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastLockingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminateTokenLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allFundsCanBeUnlocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nodePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_lastLockingTime\",\"type\":\"uint256\"},{\"name\":\"_lockedUntil\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"validationNodes\",\"type\":\"uint256\"}],\"name\":\"FundsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"triggeredTimestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"canAllFundsBeUnlocked\",\"type\":\"bool\"}],\"name\":\"AllFundsCanBeUnlocked\",\"type\":\"event\"}]","ContractName":"ValidationNodeLock","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007ba8a5d59b21390a70b2ba968a183712e12a049c000000000000000000000000000000000000000000000000000000005b892dc0000000000000000000000000000000000000000000000000000000005c14ecc0","Library":"","SwarmSource":"bzzr://282a0fa7ca9fbbc5666af72cc8c04419695721519547bba0374b9ddd274821e4"}]}