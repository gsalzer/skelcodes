{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        uint256 c = _a / _b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\ncontract Wallet is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    LotteryData public lotteryData;\r\n\r\n    uint256 public minPaymnent = 10**16;\r\n\r\n    function setMinPayment(uint256 value) public onlyOwner {\r\n        minPaymnent = value;\r\n    }\r\n\r\n    constructor() public {\r\n        lotteryData = LotteryData(msg.sender);\r\n    }\r\n\r\n    function() payable external {\r\n        require(msg.value >= minPaymnent);\r\n        lotteryData.participate(msg.sender, msg.value);\r\n    }\r\n\r\n    function finishDay() external returns(uint256) {\r\n        require(msg.sender == address(lotteryData));\r\n        uint256 balance = address(this).balance;\r\n        if (balance >= minPaymnent) {\r\n            lotteryData.getFunds.value(balance)();\r\n            return balance;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\ncontract LotteryData is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event Withdrawn(address indexed payee, uint256 weiAmount);\r\n    event Deposited(address indexed payee, uint256 weiAmount);\r\n    event WinnerWallet(address indexed wallet, uint256 bank);\r\n\r\n    Wallet public wallet_0 = new Wallet();\r\n    Wallet public wallet_1 = new Wallet();\r\n    Wallet public wallet_2 = new Wallet();\r\n\r\n    uint256 public finishTime;\r\n    uint256 constant roundTime = 86400;\r\n\r\n    uint internal dilemma;\r\n    uint internal max_participators = 100;\r\n    uint internal participators;\r\n    uint internal randNonce = 19;\r\n    uint internal winner;\r\n    uint internal winner_1;\r\n    uint internal winner_2;\r\n    uint256 internal fund;\r\n    uint256 internal commission;\r\n    uint256 internal totalBetsWithoutCommission;\r\n\r\n    mapping(uint => address) public wallets;\r\n    mapping(address => mapping (address => uint256)) public playersBets;\r\n    mapping(address => mapping (uint => address)) public players;\r\n    mapping(address => uint256) public totalBets;\r\n    mapping(address => uint) public totalPlayers;\r\n    mapping(address => uint256) private _deposits;\r\n\r\n    //monitoring part\r\n    uint public games;\r\n\r\n    struct wins{\r\n        address winner;\r\n        uint256 time;\r\n    }\r\n\r\n    mapping(uint => wins) public gamesLog;\r\n\r\n    constructor() public {\r\n        wallets[0] = address(wallet_0);\r\n        wallets[1] = address(wallet_1);\r\n        wallets[2] = address(wallet_2);\r\n        finishTime = now.add(roundTime);\r\n    }\r\n\r\n    modifier validWallets() {\r\n        require(\r\n            msg.sender == address(wallet_0) ||\r\n            msg.sender == address(wallet_1) ||\r\n            msg.sender == address(wallet_2)\r\n        );\r\n        _;\r\n    }\r\n\r\n    function depositsOf(address payee) public view returns (uint256) {\r\n        return _deposits[payee];\r\n    }\r\n\r\n    function deposit(address payee, uint256 amount) internal {\r\n        _deposits[payee] = _deposits[payee].add(amount);\r\n        emit Deposited(payee, amount);\r\n    }\r\n\r\n    function getFunds() public payable validWallets {}\r\n\r\n    function lastWinner() public view returns(address) {\r\n        return gamesLog[games].winner;\r\n    }\r\n\r\n    function getRandomWallet() internal returns(uint) {\r\n        uint result = uint(keccak256(abi.encodePacked(now, randNonce, blockhash(block.number - 1)))) % 3;\r\n        randNonce = randNonce.add(result.add(2));\r\n        return result;\r\n    }\r\n\r\n    function _fundriser() internal returns(uint256) {\r\n        fund = fund.add(wallet_0.finishDay());\r\n        fund = fund.add(wallet_1.finishDay());\r\n        return fund.add(wallet_2.finishDay());\r\n    }\r\n\r\n    function _randomizer() internal returns(uint) {\r\n        // random choose one of three wallets\r\n        winner = getRandomWallet();\r\n        // check if this address had payments, if no solving it\r\n        if(totalPlayers[wallets[winner]] == 0) {\r\n            dilemma = uint(keccak256(abi.encodePacked(now, winner, blockhash(block.number - 1)))) % 2;\r\n            if(winner == 0) {\r\n                if(dilemma == 1) {\r\n                    winner_1 = 2;\r\n                    winner_2 = 1;\r\n                } else {\r\n                    winner_1 = 1;\r\n                    winner_2 = 2;\r\n                }\r\n            }\r\n            if(winner == 1) {\r\n                if(dilemma == 1) {\r\n                    winner_1 = 2;\r\n                    winner_2 = 0;\r\n                } else {\r\n                    winner_1 = 0;\r\n                    winner_2 = 2;\r\n                }\r\n            }\r\n            if(winner == 2) {\r\n                if(dilemma == 1) {\r\n                    winner_1 = 1;\r\n                    winner_2 = 0;\r\n                } else {\r\n                    winner_1 = 0;\r\n                    winner_2 = 1;\r\n                }\r\n            }\r\n            winner = (totalPlayers[wallets[winner_1]] == 0) ? winner_2 : winner_1;\r\n        }\r\n\r\n        return winner;\r\n    }\r\n\r\n    function _distribute() internal {\r\n        // calculate commission\r\n        commission = fund.mul(15).div(100);\r\n        totalBetsWithoutCommission = fund.sub(commission);\r\n        deposit(owner, commission);\r\n        // calculate and make deposits\r\n        for (uint i = 0; i < totalPlayers[wallets[winner]]; i++) {\r\n            uint percents = playersBets[wallets[winner]][players[wallets[winner]][i]].mul(10000).div(totalBets[wallets[winner]]);\r\n            deposit(players[wallets[winner]][i], totalBetsWithoutCommission.mul(percents).div(10000));\r\n        }\r\n    }\r\n\r\n    function _collector() internal {\r\n        fund = 0;\r\n        participators = 0;\r\n        totalBets[wallets[0]] = 0;\r\n        for (uint j = 0; j < 3; j++) {\r\n            for (uint k = 0; k < totalPlayers[wallets[j]]; k++) {\r\n                playersBets[wallets[j]][players[wallets[j]][k]] = 0;\r\n                players[wallets[j]][k] = address(0x0);\r\n            }\r\n            totalBets[wallets[j]] = 0;\r\n            totalPlayers[wallets[j]] = 0;\r\n        }\r\n    }\r\n\r\n    function _logger(address _winner, uint256 _fund) internal {\r\n        games = games + 1;\r\n        gamesLog[games].winner =_winner;\r\n        gamesLog[games].time = now;\r\n        emit WinnerWallet(_winner, _fund);\r\n    }\r\n\r\n    function participate(address player, uint256 amount) external validWallets {\r\n        if (now >= finishTime || participators >= max_participators) {\r\n            // send all funds to this wallet\r\n            fund = _fundriser();\r\n            // if it has participators\r\n            if(fund > 0) {\r\n                // get winner\r\n                winner = _randomizer();\r\n                // _distribute\r\n                _distribute();\r\n                // clear state\r\n                _collector();\r\n                // log data\r\n                _logger(wallets[winner], fund);\r\n            }\r\n            // update round\r\n            finishTime = finishTime.add(roundTime);\r\n        }\r\n\r\n        if (playersBets[msg.sender][player] == 0) {\r\n            players[msg.sender][totalPlayers[msg.sender]] = player;\r\n            totalPlayers[msg.sender] = totalPlayers[msg.sender].add(1);\r\n            participators = participators.add(1);\r\n        }\r\n        playersBets[msg.sender][player] = playersBets[msg.sender][player].add(amount);\r\n        totalBets[msg.sender] = totalBets[msg.sender].add(amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw accumulated balance for a payee.\r\n    */\r\n    function withdraw() public {\r\n        uint256 payment = _deposits[msg.sender];\r\n        _deposits[msg.sender] = 0;\r\n        msg.sender.transfer(payment);\r\n        emit Withdrawn(msg.sender, payment);\r\n    }\r\n\r\n    function paymentValidator(address _payee, uint256 _amount) internal {\r\n        if(_payee != address(wallet_0) &&\r\n           _payee != address(wallet_1) &&\r\n           _payee != address(wallet_2))\r\n        {\r\n            if(_amount == uint(0)) {\r\n                if(depositsOf(_payee) != uint(0)) {\r\n                    withdraw();\r\n                } else {\r\n                    revert(\"You have zero balance\");\r\n                }\r\n            } else {\r\n                revert(\"You can't do nonzero transaction\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        paymentValidator(msg.sender, msg.value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gamesLog\",\"outputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playersBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"games\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"participate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"depositsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_0\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bank\",\"type\":\"uint256\"}],\"name\":\"WinnerWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LotteryData","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1f82a9083a46e0a669927cd733af6a3ff3395d63992b9960fd2dc949de87cbc3"}]}