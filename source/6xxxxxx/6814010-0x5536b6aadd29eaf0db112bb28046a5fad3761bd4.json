{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard Basic Interface\r\n * @dev Based on openzepplin open source ERC721 examples.\r\n * See (https://github.com/OpenZeppelin/openzeppelin-solidity)\r\n */\r\ncontract ERC721 {\r\n\r\n\t/**\r\n\t * @dev 0x01ffc9a7 === \r\n\t *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n\t */\r\n\tbytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n\r\n\t/**\r\n\t * @dev 0x80ac58cd ===\r\n\t *   bytes4(keccak256('balanceOf(address)')) ^\r\n\t *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n\t *   bytes4(keccak256('approve(address,uint256)')) ^\r\n\t *   bytes4(keccak256('getApproved(uint256)')) ^\r\n\t *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n\t *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n\t *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n\t *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n\t *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n\t */\r\n\tbytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n\r\n\t/**\r\n\t * @dev 0x780e9d63 ===\r\n\t *   bytes4(keccak256('totalSupply()')) ^\r\n\t *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n\t *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n\t */\r\n\tbytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n\r\n\t/**\r\n\t * @dev 0x5b5e139f ===\r\n\t *   bytes4(keccak256('name()')) ^\r\n\t *   bytes4(keccak256('symbol()')) ^\r\n\t *   bytes4(keccak256('tokenURI(uint256)'))\r\n\t */\r\n\tbytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n\r\n\t/** @dev A mapping of interface id to whether or not it is supported */\r\n\tmapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\t/** @dev Token events */\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n\t/** @dev Registers ERC-165, ERC-721, ERC-721 Enumerable and ERC-721 Metadata as supported interfaces */\r\n\tconstructor() public\r\n\t{\r\n\t\tregisterInterface(InterfaceId_ERC165);\r\n\t\tregisterInterface(InterfaceId_ERC721);\r\n\t\tregisterInterface(InterfaceId_ERC721Enumerable);\r\n\t\tregisterInterface(InterfaceId_ERC721Metadata);\r\n\t}\r\n\r\n\t/** @dev Internal function for registering an interface */\r\n\tfunction registerInterface(bytes4 _interfaceId) internal\r\n\t{\r\n\t\trequire(_interfaceId != 0xffffffff);\r\n\t\tsupportedInterfaces[_interfaceId] = true;\r\n\t}\r\n\r\n\t/** @dev ERC-165 interface implementation */\r\n\tfunction supportsInterface(bytes4 _interfaceId) external view returns(bool)\r\n\t{\r\n\t\treturn supportedInterfaces[_interfaceId];\r\n\t}\r\n\r\n\t/** @dev ERC-721 interface */\r\n\tfunction balanceOf(address _owner) public view returns(uint256 _balance);\r\n\tfunction ownerOf(uint256 _tokenId) public view returns(address _owner);\r\n\tfunction approve(address _to, uint256 _tokenId) public;\r\n\tfunction getApproved(uint256 _tokenId) public view returns(address _operator);\r\n\tfunction setApprovalForAll(address _operator, bool _approved) public;\r\n\tfunction isApprovedForAll(address _owner, address _operator) public view returns(bool);\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\r\n\r\n\t/** @dev ERC-721 Enumerable interface */\r\n\tfunction totalSupply() public view returns(uint256 _total);\r\n\tfunction tokenByIndex(uint256 _index) public view returns(uint256 _tokenId);\r\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns(uint256 _tokenId);\r\n\r\n\t/** @dev ERC-721 Metadata interface */\r\n\tfunction name() public view returns(string _name);\r\n\tfunction symbol() public view returns(string _symbol);\r\n\tfunction tokenURI(uint256 _tokenId) public view returns(string);\r\n}\r\n\r\n\r\n/**\r\n * @title PixelCons Core\r\n * @notice The purpose of this contract is to provide a shared ecosystem of minimal pixel art tokens for everyone to use. All users are treated \r\n * equally with the exception of an admin user who only controls the ERC721 metadata function which points to the app website. No fees are \r\n * required to interact with this contract beyond base gas fees. Here are a few notes on the basic workings of the contract:\r\n *    PixelCons [The core ERC721 token of this contract]\r\n *        -Each PixelCon is unique with an ID that encodes all its pixel data\r\n *        -PixelCons can be identified by both TokenIDs and TokenIndexes (index requires fewer bits to store)\r\n *        -A PixelCon can never be destroyed\r\n *        -Total number of PixelCons is limited to 18,446,744,073,709,551,616 (2^64)\r\n *        -A single account can only hold 4,294,967,296 PixelCons (2^32)\r\n *    Collections [Grouping mechanism for associating PixelCons together]\r\n *        -Collections are identified by an index (zero is invalid)\r\n *        -Collections can only be created by a user who both created and currently owns all its PixelCons\r\n *        -Total number of collections is limited to 18,446,744,073,709,551,616 (2^64)\r\n * For more information about PixelCons, please visit (https://pixelcons.io)\r\n * @dev This contract follows the ERC721 token standard with additional functions for creating, grouping, etc.\r\n * See (https://github.com/OpenZeppelin/openzeppelin-solidity)\r\n * @author PixelCons\r\n */\r\ncontract PixelCons is ERC721 {\r\n\r\n\tusing AddressUtils for address;\r\n\r\n\t/** @dev Equal to 'bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))' */\r\n\tbytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t///////////////////////////////////////////////////////////// Structs ///////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/** @dev The main PixelCon struct */\r\n\tstruct PixelCon {\r\n\t\tuint256 tokenId;\r\n\t\t//// ^256bits ////\r\n\t\taddress creator;\r\n\t\tuint64 collectionIndex;\r\n\t\tuint32 dateCreated;\r\n\t}\r\n\r\n\t/** @dev A struct linking a token owner with its token index */\r\n\tstruct TokenLookup {\r\n\t\taddress owner;\r\n\t\tuint64 tokenIndex;\r\n\t\tuint32 ownedIndex;\r\n\t}\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t///////////////////////////////////////////////////////////// Storage ///////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**  @dev The address thats allowed to withdraw volunteered funds sent to this contract */\r\n\taddress internal admin;\r\n\r\n\t/** @dev The URI template for retrieving token metadata */\r\n\tstring internal tokenURITemplate;\r\n\r\n\t////////////////// PixelCon Tokens //////////////////\r\n\r\n\t/** @dev Mapping from token ID to owner/index */\r\n\tmapping(uint256 => TokenLookup) internal tokenLookup;\r\n\r\n\t/**  @dev Mapping from owner to token indexes */\r\n\tmapping(address => uint64[]) internal ownedTokens;\r\n\r\n\t/**  @dev Mapping from creator to token indexes */\r\n\tmapping(address => uint64[]) internal createdTokens;\r\n\r\n\t/** @dev Mapping from token ID to approved address */\r\n\tmapping(uint256 => address) internal tokenApprovals;\r\n\r\n\t/** @dev Mapping from owner to operator approvals */\r\n\tmapping(address => mapping(address => bool)) internal operatorApprovals;\r\n\r\n\t/** @dev An array containing all PixelCons in existence */\r\n\tPixelCon[] internal pixelcons;\r\n\r\n\t/** @dev An array that mirrors 'pixelcons' in terms of indexing, but stores only name data */\r\n\tbytes8[] internal pixelconNames;\r\n\r\n\t////////////////// Collections //////////////////\r\n\r\n\t/** @dev Mapping from collection index to token indexes */\r\n\tmapping(uint64 => uint64[]) internal collectionTokens;\r\n\r\n\t/** @dev An array that mirrors 'collectionTokens' in terms of indexing, but stores only name data */\r\n\tbytes8[] internal collectionNames;\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t///////////////////////////////////////////////////////////// Events ////////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/** @dev PixelCon token events */\r\n\tevent Create(uint256 indexed _tokenId, address indexed _creator, uint64 _tokenIndex, address _to);\r\n\tevent Rename(uint256 indexed _tokenId, bytes8 _newName);\r\n\r\n\t/**  @dev PixelCon collection events */\r\n\tevent CreateCollection(address indexed _creator, uint64 indexed _collectionIndex);\r\n\tevent RenameCollection(uint64 indexed _collectionIndex, bytes8 _newName);\r\n\tevent ClearCollection(uint64 indexed _collectionIndex);\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////// Modifiers ///////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**  @dev Small validators for quick validation of function parameters */\r\n\tmodifier validIndex(uint64 _index) {\r\n\t\trequire(_index != uint64(0), \"Invalid index\");\r\n\t\t_;\r\n\t}\r\n\tmodifier validId(uint256 _id) {\r\n\t\trequire(_id != uint256(0), \"Invalid ID\");\r\n\t\t_;\r\n\t}\r\n\tmodifier validAddress(address _address) {\r\n\t\trequire(_address != address(0), \"Invalid address\");\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t////////////////////////////////////////////////////////// PixelCons Core ///////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**\r\n\t * @notice Contract constructor\r\n\t */\r\n\tconstructor() public\r\n\t{\r\n\t\t//admin defaults to the contract creator\r\n\t\tadmin = msg.sender;\r\n\r\n\t\t//fill zero index pixelcon collection\r\n\t\tcollectionNames.length++;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the current admin\r\n\t * @return The current admin\r\n\t */\r\n\tfunction getAdmin() public view returns(address)\r\n\t{\r\n\t\treturn admin;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Withdraw all volunteered funds to `(_to)`\r\n\t * @param _to Address to withdraw the funds to\r\n\t */\r\n\tfunction adminWithdraw(address _to) public\r\n\t{\r\n\t\trequire(msg.sender == admin, \"Only the admin can call this function\");\r\n\t\t_to.transfer(address(this).balance);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Change the admin to `(_to)`\r\n\t * @param _newAdmin New admin address\r\n\t */\r\n\tfunction adminChange(address _newAdmin) public\r\n\t{\r\n\t\trequire(msg.sender == admin, \"Only the admin can call this function\");\r\n\t\tadmin = _newAdmin;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Change the token URI template\r\n\t * @param _newTokenURITemplate New token URI template\r\n\t */\r\n\tfunction adminSetTokenURITemplate(string _newTokenURITemplate) public\r\n\t{\r\n\t\trequire(msg.sender == admin, \"Only the admin can call this function\");\r\n\t\ttokenURITemplate = _newTokenURITemplate;\r\n\t}\r\n\r\n\t////////////////// PixelCon Tokens //////////////////\r\n\r\n\t/**\r\n\t * @notice Create PixelCon `(_tokenId)`\r\n\t * @dev Throws if the token ID already exists\r\n\t * @param _to Address that will own the PixelCon\r\n\t * @param _tokenId ID of the PixelCon to be creates\r\n\t * @param _name PixelCon name (not required)\r\n\t * @return The index of the new PixelCon\r\n\t */\r\n\tfunction create(address _to, uint256 _tokenId, bytes8 _name) public payable validAddress(_to) validId(_tokenId) returns(uint64)\r\n\t{\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(pixelcons.length < uint256(2 ** 64) - 1, \"Max number of PixelCons has been reached\");\r\n\t\trequire(lookupData.owner == address(0), \"PixelCon already exists\");\r\n\r\n\t\t//get created timestamp (zero as date indicates null)\r\n\t\tuint32 dateCreated = 0;\r\n\t\tif (now < uint256(2 ** 32)) dateCreated = uint32(now);\r\n\r\n\t\t//create PixelCon token and set owner\r\n\t\tuint64 index = uint64(pixelcons.length);\r\n\t\tlookupData.tokenIndex = index;\r\n\t\tpixelcons.length++;\r\n\t\tpixelconNames.length++;\r\n\t\tPixelCon storage pixelcon = pixelcons[index];\r\n\t\tpixelcon.tokenId = _tokenId;\r\n\t\tpixelcon.creator = msg.sender;\r\n\t\tpixelcon.dateCreated = dateCreated;\r\n\t\tpixelconNames[index] = _name;\r\n\t\tuint64[] storage createdList = createdTokens[msg.sender];\r\n\t\tuint createdListIndex = createdList.length;\r\n\t\tcreatedList.length++;\r\n\t\tcreatedList[createdListIndex] = index;\r\n\t\taddTokenTo(_to, _tokenId);\r\n\r\n\t\temit Create(_tokenId, msg.sender, index, _to);\r\n\t\temit Transfer(address(0), _to, _tokenId);\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Rename PixelCon `(_tokenId)`\r\n\t * @dev Throws if the caller is not the owner and creator of the token\r\n\t * @param _tokenId ID of the PixelCon to rename\r\n\t * @param _name New name\r\n\t * @return The index of the PixelCon\r\n\t */\r\n\tfunction rename(uint256 _tokenId, bytes8 _name) public validId(_tokenId) returns(uint64)\r\n\t{\r\n\t\trequire(isCreatorAndOwner(msg.sender, _tokenId), \"Sender is not the creator and owner\");\r\n\r\n\t\t//update name\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\tpixelconNames[lookupData.tokenIndex] = _name;\r\n\r\n\t\temit Rename(_tokenId, _name);\r\n\t\treturn lookupData.tokenIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Check if PixelCon `(_tokenId)` exists\r\n\t * @param _tokenId ID of the PixelCon to query the existence of\r\n\t * @return True if the PixelCon exists\r\n\t */\r\n\tfunction exists(uint256 _tokenId) public view validId(_tokenId) returns(bool)\r\n\t{\r\n\t\taddress owner = tokenLookup[_tokenId].owner;\r\n\t\treturn owner != address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the creator of PixelCon `(_tokenId)`\r\n\t * @dev Throws if PixelCon does not exist\r\n\t * @param _tokenId ID of the PixelCon to query the creator of\r\n\t * @return Creator address for PixelCon\r\n\t */\r\n\tfunction creatorOf(uint256 _tokenId) public view validId(_tokenId) returns(address)\r\n\t{\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(lookupData.owner != address(0), \"PixelCon does not exist\");\r\n\r\n\t\treturn pixelcons[lookupData.tokenIndex].creator;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the total number of PixelCons created by `(_creator)`\r\n\t * @param _creator Address to query the total of\r\n\t * @return Total number of PixelCons created by given address\r\n\t */\r\n\tfunction creatorTotal(address _creator) public view validAddress(_creator) returns(uint256)\r\n\t{\r\n\t\treturn createdTokens[_creator].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Enumerate PixelCon created by `(_creator)`\r\n\t * @dev Throws if index is out of bounds\r\n\t * @param _creator Creator address\r\n\t * @param _index Counter less than `creatorTotal(_creator)`\r\n\t * @return PixelCon ID for the `(_index)`th PixelCon created by `(_creator)`\r\n\t */\r\n\tfunction tokenOfCreatorByIndex(address _creator, uint256 _index) public view validAddress(_creator) returns(uint256)\r\n\t{\r\n\t\trequire(_index < createdTokens[_creator].length, \"Index is out of bounds\");\r\n\t\tPixelCon storage pixelcon = pixelcons[createdTokens[_creator][_index]];\r\n\t\treturn pixelcon.tokenId;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get all details of PixelCon `(_tokenId)`\r\n\t * @dev Throws if PixelCon does not exist\r\n\t * @param _tokenId ID of the PixelCon to get details for\r\n\t * @return PixelCon details\r\n\t */\r\n\tfunction getTokenData(uint256 _tokenId) public view validId(_tokenId)\r\n\treturns(uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated)\r\n\t{\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(lookupData.owner != address(0), \"PixelCon does not exist\");\r\n\r\n\t\tPixelCon storage pixelcon = pixelcons[lookupData.tokenIndex];\r\n\t\treturn (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner,\r\n\t\t\tpixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get all details of PixelCon #`(_tokenIndex)`\r\n\t * @dev Throws if PixelCon does not exist\r\n\t * @param _tokenIndex Index of the PixelCon to get details for\r\n\t * @return PixelCon details\r\n\t */\r\n\tfunction getTokenDataByIndex(uint64 _tokenIndex) public view\r\n\treturns(uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated)\r\n\t{\r\n\t\trequire(_tokenIndex < totalSupply(), \"PixelCon index is out of bounds\");\r\n\r\n\t\tPixelCon storage pixelcon = pixelcons[_tokenIndex];\r\n\t\tTokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];\r\n\t\treturn (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner,\r\n\t\t\tpixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the index of PixelCon `(_tokenId)`\r\n\t * @dev Throws if PixelCon does not exist\r\n\t * @param _tokenId ID of the PixelCon to query the index of\r\n\t * @return Index of the given PixelCon ID\r\n\t */\r\n\tfunction getTokenIndex(uint256 _tokenId) validId(_tokenId) public view returns(uint64)\r\n\t{\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(lookupData.owner != address(0), \"PixelCon does not exist\");\r\n\r\n\t\treturn lookupData.tokenIndex;\r\n\t}\r\n\r\n\t////////////////// Collections //////////////////\r\n\r\n\t/**\r\n\t * @notice Create PixelCon collection\r\n\t * @dev Throws if the message sender is not the owner and creator of the given tokens\r\n\t * @param _tokenIndexes Token indexes to group together into a collection\r\n\t * @param _name Name of the collection\r\n\t * @return Index of the new collection\r\n\t */\r\n\tfunction createCollection(uint64[] _tokenIndexes, bytes8 _name) public returns(uint64)\r\n\t{\r\n\t\trequire(collectionNames.length < uint256(2 ** 64) - 1, \"Max number of collections has been reached\");\r\n\t\trequire(_tokenIndexes.length > 1, \"Collection must contain more than one PixelCon\");\r\n\r\n\t\t//loop through given indexes to add to collection and check additional requirements\r\n\t\tuint64 collectionIndex = uint64(collectionNames.length);\r\n\t\tuint64[] storage collection = collectionTokens[collectionIndex];\r\n\t\tcollection.length = _tokenIndexes.length;\r\n\t\tfor (uint i = 0; i < _tokenIndexes.length; i++) {\r\n\t\t\tuint64 tokenIndex = _tokenIndexes[i];\r\n\t\t\trequire(tokenIndex < totalSupply(), \"PixelCon index is out of bounds\");\r\n\r\n\t\t\tPixelCon storage pixelcon = pixelcons[tokenIndex];\r\n\t\t\trequire(isCreatorAndOwner(msg.sender, pixelcon.tokenId), \"Sender is not the creator and owner of the PixelCons\");\r\n\t\t\trequire(pixelcon.collectionIndex == uint64(0), \"PixelCon is already in a collection\");\r\n\r\n\t\t\tpixelcon.collectionIndex = collectionIndex;\r\n\t\t\tcollection[i] = tokenIndex;\r\n\t\t}\r\n\t\tcollectionNames.length++;\r\n\t\tcollectionNames[collectionIndex] = _name;\r\n\r\n\t\temit CreateCollection(msg.sender, collectionIndex);\r\n\t\treturn collectionIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Rename collection #`(_collectionIndex)`\r\n\t * @dev Throws if the message sender is not the owner and creator of all collection tokens\r\n\t * @param _collectionIndex Index of the collection to rename\r\n\t * @param _name New name\r\n\t * @return Index of the collection\r\n\t */\r\n\tfunction renameCollection(uint64 _collectionIndex, bytes8 _name) validIndex(_collectionIndex) public returns(uint64)\r\n\t{\r\n\t\trequire(_collectionIndex < totalCollections(), \"Collection does not exist\");\r\n\r\n\t\t//loop through the collections token indexes and check additional requirements\r\n\t\tuint64[] storage collection = collectionTokens[_collectionIndex];\r\n\t\trequire(collection.length > 0, \"Collection has been cleared\");\r\n\t\tfor (uint i = 0; i < collection.length; i++) {\r\n\t\t\tPixelCon storage pixelcon = pixelcons[collection[i]];\r\n\t\t\trequire(isCreatorAndOwner(msg.sender, pixelcon.tokenId), \"Sender is not the creator and owner of the PixelCons\");\r\n\t\t}\r\n\r\n\t\t//update\r\n\t\tcollectionNames[_collectionIndex] = _name;\r\n\r\n\t\temit RenameCollection(_collectionIndex, _name);\r\n\t\treturn _collectionIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Clear collection #`(_collectionIndex)`\r\n\t * @dev Throws if the message sender is not the owner and creator of all collection tokens\r\n\t * @param _collectionIndex Index of the collection to clear out\r\n\t * @return Index of the collection\r\n\t */\r\n\tfunction clearCollection(uint64 _collectionIndex) validIndex(_collectionIndex) public returns(uint64)\r\n\t{\r\n\t\trequire(_collectionIndex < totalCollections(), \"Collection does not exist\");\r\n\r\n\t\t//loop through the collections token indexes and check additional requirements while clearing pixelcon collection index\r\n\t\tuint64[] storage collection = collectionTokens[_collectionIndex];\r\n\t\trequire(collection.length > 0, \"Collection is already cleared\");\r\n\t\tfor (uint i = 0; i < collection.length; i++) {\r\n\t\t\tPixelCon storage pixelcon = pixelcons[collection[i]];\r\n\t\t\trequire(isCreatorAndOwner(msg.sender, pixelcon.tokenId), \"Sender is not the creator and owner of the PixelCons\");\r\n\r\n\t\t\tpixelcon.collectionIndex = 0;\r\n\t\t}\r\n\r\n\t\t//clear out collection data\r\n\t\tdelete collectionNames[_collectionIndex];\r\n\t\tdelete collectionTokens[_collectionIndex];\r\n\r\n\t\temit ClearCollection(_collectionIndex);\r\n\t\treturn _collectionIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Check if collection #`(_collectionIndex)` exists\r\n\t * @param _collectionIndex Index of the collection to query the existence of\r\n\t * @return True if collection exists\r\n\t */\r\n\tfunction collectionExists(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(bool)\r\n\t{\r\n\t\treturn _collectionIndex < totalCollections();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Check if collection #`(_collectionIndex)` has been cleared\r\n\t * @dev Throws if the collection index is out of bounds\r\n\t * @param _collectionIndex Index of the collection to query the state of\r\n\t * @return True if collection has been cleared\r\n\t */\r\n\tfunction collectionCleared(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(bool)\r\n\t{\r\n\t\trequire(_collectionIndex < totalCollections(), \"Collection does not exist\");\r\n\t\treturn collectionTokens[_collectionIndex].length == uint256(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the total number of collections\r\n\t * @return Total number of collections\r\n\t */\r\n\tfunction totalCollections() public view returns(uint256)\r\n\t{\r\n\t\treturn collectionNames.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the collection index of PixelCon `(_tokenId)`\r\n\t * @dev Throws if the PixelCon does not exist\r\n\t * @param _tokenId ID of the PixelCon to query the collection of\r\n\t * @return Collection index of given PixelCon\r\n\t */\r\n\tfunction collectionOf(uint256 _tokenId) public view validId(_tokenId) returns(uint256)\r\n\t{\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(lookupData.owner != address(0), \"PixelCon does not exist\");\r\n\r\n\t\treturn pixelcons[tokenLookup[_tokenId].tokenIndex].collectionIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the total number of PixelCons in collection #`(_collectionIndex)`\r\n\t * @dev Throws if the collection does not exist\r\n\t * @param _collectionIndex Collection index to query the total of\r\n\t * @return Total number of PixelCons in the collection\r\n\t */\r\n\tfunction collectionTotal(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(uint256)\r\n\t{\r\n\t\trequire(_collectionIndex < totalCollections(), \"Collection does not exist\");\r\n\t\treturn collectionTokens[_collectionIndex].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the name of collection #`(_collectionIndex)`\r\n\t * @dev Throws if the collection does not exist\r\n\t * @param _collectionIndex Collection index to query the name of\r\n\t * @return Collection name\r\n\t */\r\n\tfunction getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(bytes8)\r\n\t{\r\n\t\trequire(_collectionIndex < totalCollections(), \"Collection does not exist\");\r\n\t\treturn collectionNames[_collectionIndex];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Enumerate PixelCon in collection #`(_collectionIndex)`\r\n\t * @dev Throws if the collection does not exist or index is out of bounds\r\n\t * @param _collectionIndex Collection index\r\n\t * @param _index Counter less than `collectionTotal(_collection)`\r\n\t * @return PixelCon ID for the `(_index)`th PixelCon in collection #`(_collectionIndex)`\r\n\t */\r\n\tfunction tokenOfCollectionByIndex(uint64 _collectionIndex, uint256 _index) public view validIndex(_collectionIndex) returns(uint256)\r\n\t{\r\n\t\trequire(_collectionIndex < totalCollections(), \"Collection does not exist\");\r\n\t\trequire(_index < collectionTokens[_collectionIndex].length, \"Index is out of bounds\");\r\n\t\tPixelCon storage pixelcon = pixelcons[collectionTokens[_collectionIndex][_index]];\r\n\t\treturn pixelcon.tokenId;\r\n\t}\r\n\r\n\t////////////////// Web3 Only //////////////////\r\n\r\n\t/**\r\n\t * @notice Get the indexes of all PixelCons owned by `(_owner)`\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @param _owner Owner address\r\n\t * @return PixelCon indexes\r\n\t */\r\n\tfunction getForOwner(address _owner) public view validAddress(_owner) returns(uint64[])\r\n\t{\r\n\t\treturn ownedTokens[_owner];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the indexes of all PixelCons created by `(_creator)`\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @param _creator Creator address \r\n\t * @return PixelCon indexes\r\n\t */\r\n\tfunction getForCreator(address _creator) public view validAddress(_creator) returns(uint64[])\r\n\t{\r\n\t\treturn createdTokens[_creator];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the indexes of all PixelCons in collection #`(_collectionIndex)`\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @param _collectionIndex Collection index\r\n\t * @return PixelCon indexes\r\n\t */\r\n\tfunction getForCollection(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(uint64[])\r\n\t{\r\n\t\treturn collectionTokens[_collectionIndex];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the basic data for the given PixelCon indexes\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @param _tokenIndexes List of PixelCon indexes\r\n\t * @return All PixelCon basic data\r\n\t */\r\n\tfunction getBasicData(uint64[] _tokenIndexes) public view returns(uint256[], bytes8[], address[], uint64[])\r\n\t{\r\n\t\tuint256[] memory tokenIds = new uint256[](_tokenIndexes.length);\r\n\t\tbytes8[] memory names = new bytes8[](_tokenIndexes.length);\r\n\t\taddress[] memory owners = new address[](_tokenIndexes.length);\r\n\t\tuint64[] memory collectionIdxs = new uint64[](_tokenIndexes.length);\r\n\r\n\t\tfor (uint i = 0; i < _tokenIndexes.length; i++)\t{\r\n\t\t\tuint64 tokenIndex = _tokenIndexes[i];\r\n\t\t\trequire(tokenIndex < totalSupply(), \"PixelCon index is out of bounds\");\r\n\r\n\t\t\ttokenIds[i] = pixelcons[tokenIndex].tokenId;\r\n\t\t\tnames[i] = pixelconNames[tokenIndex];\r\n\t\t\towners[i] = tokenLookup[pixelcons[tokenIndex].tokenId].owner;\r\n\t\t\tcollectionIdxs[i] = pixelcons[tokenIndex].collectionIndex;\r\n\t\t}\r\n\t\treturn (tokenIds, names, owners, collectionIdxs);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the names of all PixelCons\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @return The names of all PixelCons in existence\r\n\t */\r\n\tfunction getAllNames() public view returns(bytes8[])\r\n\t{\r\n\t\treturn pixelconNames;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the names of all PixelCons from index `(_startIndex)` to `(_endIndex)`\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @return The names of the PixelCons in the given range\r\n\t */\r\n\tfunction getNamesInRange(uint64 _startIndex, uint64 _endIndex) public view returns(bytes8[])\r\n\t{\r\n\t\trequire(_startIndex <= totalSupply(), \"Start index is out of bounds\");\r\n\t\trequire(_endIndex <= totalSupply(), \"End index is out of bounds\");\r\n\t\trequire(_startIndex <= _endIndex, \"End index is less than the start index\");\r\n\r\n\t\tuint64 length = _endIndex - _startIndex;\r\n\t\tbytes8[] memory names = new bytes8[](length);\r\n\t\tfor (uint i = 0; i < length; i++)\t{\r\n\t\t\tnames[i] = pixelconNames[_startIndex + i];\r\n\t\t}\r\n\t\treturn names;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get details of collection #`(_collectionIndex)`\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @param _collectionIndex Index of the collection to get the data of\r\n\t * @return Collection name and included PixelCon indexes\r\n\t */\r\n\tfunction getCollectionData(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(bytes8, uint64[])\r\n\t{\r\n\t\trequire(_collectionIndex < totalCollections(), \"Collection does not exist\");\r\n\t\treturn (collectionNames[_collectionIndex], collectionTokens[_collectionIndex]);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the names of all collections\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @return The names of all PixelCon collections in existence\r\n\t */\r\n\tfunction getAllCollectionNames() public view returns(bytes8[])\r\n\t{\r\n\t\treturn collectionNames;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the names of all collections from index `(_startIndex)` to `(_endIndex)`\r\n\t * @dev This function is for web3 calls only, as it returns a dynamic array\r\n\t * @return The names of the collections in the given range\r\n\t */\r\n\tfunction getCollectionNamesInRange(uint64 _startIndex, uint64 _endIndex) public view returns(bytes8[])\r\n\t{\r\n\t\trequire(_startIndex <= totalCollections(), \"Start index is out of bounds\");\r\n\t\trequire(_endIndex <= totalCollections(), \"End index is out of bounds\");\r\n\t\trequire(_startIndex <= _endIndex, \"End index is less than the start index\");\r\n\r\n\t\tuint64 length = _endIndex - _startIndex;\r\n\t\tbytes8[] memory names = new bytes8[](length);\r\n\t\tfor (uint i = 0; i < length; i++)\t{\r\n\t\t\tnames[i] = collectionNames[_startIndex + i];\r\n\t\t}\r\n\t\treturn names;\r\n\t}\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t////////////////////////////////////////////////////// ERC-721 Implementation ///////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**\r\n\t * @notice Get the balance of `(_owner)`\r\n\t * @param _owner Owner address\r\n\t * @return Owner balance\r\n\t */\r\n\tfunction balanceOf(address _owner) public view validAddress(_owner) returns(uint256)\r\n\t{\r\n\t\treturn ownedTokens[_owner].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the owner of PixelCon `(_tokenId)`\r\n\t * @dev Throws if PixelCon does not exist\r\n\t * @param _tokenId ID of the token\r\n\t * @return Owner of the given PixelCon\r\n\t */\r\n\tfunction ownerOf(uint256 _tokenId) public view validId(_tokenId) returns(address)\r\n\t{\r\n\t\taddress owner = tokenLookup[_tokenId].owner;\r\n\t\trequire(owner != address(0), \"PixelCon does not exist\");\r\n\t\treturn owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Approve `(_to)` to transfer PixelCon `(_tokenId)` (zero indicates no approved address)\r\n\t * @dev Throws if not called by the owner or an approved operator\r\n\t * @param _to Address to be approved\r\n\t * @param _tokenId ID of the token to be approved\r\n\t */\r\n\tfunction approve(address _to, uint256 _tokenId) public validId(_tokenId)\r\n\t{\r\n\t\taddress owner = tokenLookup[_tokenId].owner;\r\n\t\trequire(_to != owner, \"Cannot approve PixelCon owner\");\r\n\t\trequire(msg.sender == owner || operatorApprovals[owner][msg.sender], \"Sender does not have permission to approve address\");\r\n\r\n\t\ttokenApprovals[_tokenId] = _to;\r\n\t\temit Approval(owner, _to, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the approved address for PixelCon `(_tokenId)`\r\n\t * @dev Throws if the PixelCon does not exist\r\n\t * @param _tokenId ID of the token\r\n\t * @return Address currently approved for the given PixelCon\r\n\t */\r\n\tfunction getApproved(uint256 _tokenId) public view validId(_tokenId) returns(address)\r\n\t{\r\n\t\taddress owner = tokenLookup[_tokenId].owner;\r\n\t\trequire(owner != address(0), \"PixelCon does not exist\");\r\n\t\treturn tokenApprovals[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Set or unset the approval of operator `(_to)`\r\n\t * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n\t * @param _to Operator address to set the approval\r\n\t * @param _approved Flag for setting approval\r\n\t */\r\n\tfunction setApprovalForAll(address _to, bool _approved) public validAddress(_to)\r\n\t{\r\n\t\trequire(_to != msg.sender, \"Cannot approve self\");\r\n\t\toperatorApprovals[msg.sender][_to] = _approved;\r\n\t\temit ApprovalForAll(msg.sender, _to, _approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get if `(_operator)` is an approved operator for owner `(_owner)`\r\n\t * @param _owner Owner address \r\n\t * @param _operator Operator address\r\n\t * @return True if the given operator is approved by the given owner\r\n\t */\r\n\tfunction isApprovedForAll(address _owner, address _operator) public view validAddress(_owner) validAddress(_operator) returns(bool)\r\n\t{\r\n\t\treturn operatorApprovals[_owner][_operator];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Transfer the ownership of PixelCon `(_tokenId)` to `(_to)` (try to use 'safeTransferFrom' instead)\r\n\t * @dev Throws if the sender is not the owner, approved, or operator\r\n\t * @param _from Current owner\r\n\t * @param _to Address to receive the PixelCon\r\n\t * @param _tokenId ID of the PixelCon to be transferred\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public validAddress(_from) validAddress(_to) validId(_tokenId)\r\n\t{\r\n\t\trequire(isApprovedOrOwner(msg.sender, _tokenId), \"Sender does not have permission to transfer PixelCon\");\r\n\t\tclearApproval(_from, _tokenId);\r\n\t\tremoveTokenFrom(_from, _tokenId);\r\n\t\taddTokenTo(_to, _tokenId);\r\n\r\n\t\temit Transfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Safely transfer the ownership of PixelCon `(_tokenId)` to `(_to)`\r\n\t * @dev Throws if receiver is a contract that does not respond or the sender is not the owner, approved, or operator\r\n\t * @param _from Current owner\r\n\t * @param _to Address to receive the PixelCon\r\n\t * @param _tokenId ID of the PixelCon to be transferred\r\n\t */\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public\r\n\t{\r\n\t\t//requirements are checked in 'transferFrom' function\r\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Safely transfer the ownership of PixelCon `(_tokenId)` to `(_to)`\r\n\t * @dev Throws if receiver is a contract that does not respond or the sender is not the owner, approved, or operator\r\n\t * @param _from Current owner\r\n\t * @param _to Address to receive the PixelCon\r\n\t * @param _tokenId ID of the PixelCon to be transferred\r\n\t * @param _data Data to send along with a safe transfer check\r\n\t */\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public\r\n\t{\r\n\t\t//requirements are checked in 'transferFrom' function\r\n\t\ttransferFrom(_from, _to, _tokenId);\r\n\t\trequire(checkAndCallSafeTransfer(_from, _to, _tokenId, _data), \"Transfer was not safe\");\r\n\t}\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t//////////////////////////////////////////////// ERC-721 Enumeration Implementation /////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**\r\n\t * @notice Get the total number of PixelCons in existence\r\n\t * @return Total number of PixelCons in existence\r\n\t */\r\n\tfunction totalSupply() public view returns(uint256)\r\n\t{\r\n\t\treturn pixelcons.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the ID of PixelCon #`(_tokenIndex)`\r\n\t * @dev Throws if index is out of bounds\r\n\t * @param _tokenIndex Counter less than `totalSupply()`\r\n\t * @return `_tokenIndex`th PixelCon ID\r\n\t */\r\n\tfunction tokenByIndex(uint256 _tokenIndex) public view returns(uint256)\r\n\t{\r\n\t\trequire(_tokenIndex < totalSupply(), \"PixelCon index is out of bounds\");\r\n\t\treturn pixelcons[_tokenIndex].tokenId;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Enumerate PixelCon assigned to owner `(_owner)`\r\n\t * @dev Throws if the index is out of bounds\r\n\t * @param _owner Owner address\r\n\t * @param _index Counter less than `balanceOf(_owner)`\r\n\t * @return PixelCon ID for the `(_index)`th PixelCon in owned by `(_owner)`\r\n\t */\r\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view validAddress(_owner) returns(uint256)\r\n\t{\r\n\t\trequire(_index < ownedTokens[_owner].length, \"Index is out of bounds\");\r\n\t\tPixelCon storage pixelcon = pixelcons[ownedTokens[_owner][_index]];\r\n\t\treturn pixelcon.tokenId;\r\n\t}\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t////////////////////////////////////////////////// ERC-721 Metadata Implementation //////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**\r\n\t * @notice Get the name of this contract token\r\n\t * @return Contract token name\r\n\t */\r\n\tfunction name() public view returns(string)\r\n\t{\r\n\t\treturn \"PixelCons\";\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get the symbol for this contract token\r\n\t * @return Contract token symbol\r\n\t */\r\n\tfunction symbol() public view returns(string)\r\n\t{\r\n\t\treturn \"PXCN\";\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Get a distinct Uniform Resource Identifier (URI) for PixelCon `(_tokenId)`\r\n\t * @dev Throws if the given PixelCon does not exist\r\n\t * @return PixelCon URI\r\n\t */\r\n\tfunction tokenURI(uint256 _tokenId) public view returns(string)\r\n\t{\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(lookupData.owner != address(0), \"PixelCon does not exist\");\r\n\t\tPixelCon storage pixelcon = pixelcons[lookupData.tokenIndex];\r\n\t\tbytes8 pixelconName = pixelconNames[lookupData.tokenIndex];\r\n\r\n\t\t//Available values: <tokenId>, <tokenIndex>, <name>, <owner>, <creator>, <dateCreated>, <collectionIndex>\r\n\r\n\t\t//start with the token URI template and replace in the appropriate values\r\n\t\tstring memory finalTokenURI = tokenURITemplate;\r\n\t\tfinalTokenURI = StringUtils.replace(finalTokenURI, \"<tokenId>\", StringUtils.toHexString(_tokenId, 32));\r\n\t\tfinalTokenURI = StringUtils.replace(finalTokenURI, \"<tokenIndex>\", StringUtils.toHexString(uint256(lookupData.tokenIndex), 8));\r\n\t\tfinalTokenURI = StringUtils.replace(finalTokenURI, \"<name>\", StringUtils.toHexString(uint256(pixelconName), 8));\r\n\t\tfinalTokenURI = StringUtils.replace(finalTokenURI, \"<owner>\", StringUtils.toHexString(uint256(lookupData.owner), 20));\r\n\t\tfinalTokenURI = StringUtils.replace(finalTokenURI, \"<creator>\", StringUtils.toHexString(uint256(pixelcon.creator), 20));\r\n\t\tfinalTokenURI = StringUtils.replace(finalTokenURI, \"<dateCreated>\", StringUtils.toHexString(uint256(pixelcon.dateCreated), 8));\r\n\t\tfinalTokenURI = StringUtils.replace(finalTokenURI, \"<collectionIndex>\", StringUtils.toHexString(uint256(pixelcon.collectionIndex), 8));\r\n\r\n\t\treturn finalTokenURI;\r\n\t}\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t////////////////////////////////////////////////////////////// Utils ////////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**\r\n\t * @notice Check whether the given editor is the current owner and original creator of a given token ID\r\n\t * @param _address Address to check for\r\n\t * @param _tokenId ID of the token to be edited\r\n\t * @return True if the editor is approved for the given token ID, is an operator of the owner, or is the owner of the token\r\n\t */\r\n\tfunction isCreatorAndOwner(address _address, uint256 _tokenId) internal view returns(bool)\r\n\t{\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\taddress owner = lookupData.owner;\r\n\t\taddress creator = pixelcons[lookupData.tokenIndex].creator;\r\n\r\n\t\treturn (_address == owner && _address == creator);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Check whether the given spender can transfer a given token ID\r\n\t * @dev Throws if the PixelCon does not exist\r\n\t * @param _address Address of the spender to query\r\n\t * @param _tokenId ID of the token to be transferred\r\n\t * @return True if the spender is approved for the given token ID, is an operator of the owner, or is the owner of the token\r\n\t */\r\n\tfunction isApprovedOrOwner(address _address, uint256 _tokenId) internal view returns(bool)\r\n\t{\r\n\t\taddress owner = tokenLookup[_tokenId].owner;\r\n\t\trequire(owner != address(0), \"PixelCon does not exist\");\r\n\t\treturn (_address == owner || tokenApprovals[_tokenId] == _address || operatorApprovals[owner][_address]);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Clear current approval of a given token ID\r\n\t * @dev Throws if the given address is not indeed the owner of the token\r\n\t * @param _owner Owner of the token\r\n\t * @param _tokenId ID of the token to be transferred\r\n\t */\r\n\tfunction clearApproval(address _owner, uint256 _tokenId) internal\r\n\t{\r\n\t\trequire(tokenLookup[_tokenId].owner == _owner, \"Incorrect PixelCon owner\");\r\n\t\tif (tokenApprovals[_tokenId] != address(0)) {\r\n\t\t\ttokenApprovals[_tokenId] = address(0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Add a token ID to the list of a given address\r\n\t * @dev Throws if the receiver address has hit ownership limit or the PixelCon already has an owner\r\n\t * @param _to Address representing the new owner of the given token ID\r\n\t * @param _tokenId ID of the token to be added to the tokens list of the given address\r\n\t */\r\n\tfunction addTokenTo(address _to, uint256 _tokenId) internal\r\n\t{\r\n\t\tuint64[] storage ownedList = ownedTokens[_to];\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(ownedList.length < uint256(2 ** 32) - 1, \"Max number of PixelCons per owner has been reached\");\r\n\t\trequire(lookupData.owner == address(0), \"PixelCon already has an owner\");\r\n\t\tlookupData.owner = _to;\r\n\r\n\t\t//update ownedTokens references\r\n\t\tuint ownedListIndex = ownedList.length;\r\n\t\townedList.length++;\r\n\t\tlookupData.ownedIndex = uint32(ownedListIndex);\r\n\t\townedList[ownedListIndex] = lookupData.tokenIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Remove a token ID from the list of a given address\r\n\t * @dev Throws if the given address is not indeed the owner of the token\r\n\t * @param _from Address representing the previous owner of the given token ID\r\n\t * @param _tokenId ID of the token to be removed from the tokens list of the given address\r\n\t */\r\n\tfunction removeTokenFrom(address _from, uint256 _tokenId) internal\r\n\t{\r\n\t\tuint64[] storage ownedList = ownedTokens[_from];\r\n\t\tTokenLookup storage lookupData = tokenLookup[_tokenId];\r\n\t\trequire(lookupData.owner == _from, \"From address is incorrect\");\r\n\t\tlookupData.owner = address(0);\r\n\r\n\t\t//update ownedTokens references\r\n\t\tuint64 replacementTokenIndex = ownedList[ownedList.length - 1];\r\n\t\tdelete ownedList[ownedList.length - 1];\r\n\t\townedList.length--;\r\n\t\tif (lookupData.ownedIndex < ownedList.length) {\r\n\t\t\t//we just removed the last token index in the array, but if this wasn't the one to remove, then swap it with the one to remove \r\n\t\t\townedList[lookupData.ownedIndex] = replacementTokenIndex;\r\n\t\t\ttokenLookup[pixelcons[replacementTokenIndex].tokenId].ownedIndex = lookupData.ownedIndex;\r\n\t\t}\r\n\t\tlookupData.ownedIndex = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Invoke `onERC721Received` on a target address (not executed if the target address is not a contract)\r\n\t * @param _from Address representing the previous owner of the given token ID\r\n\t * @param _to Target address that will receive the tokens\r\n\t * @param _tokenId ID of the token to be transferred\r\n\t * @param _data Optional data to send along with the call\r\n\t * @return True if the call correctly returned the expected value\r\n\t */\r\n\tfunction checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data) internal returns(bool)\r\n\t{\r\n\t\tif (!_to.isContract()) return true;\r\n\r\n\t\tbytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n\t\treturn (retval == ERC721_RECEIVED);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.\r\n * See (https://github.com/OpenZeppelin/openzeppelin-solidity)\r\n */\r\ncontract ERC721Receiver {\r\n\r\n\t/**\r\n\t * @dev Magic value to be returned upon successful reception of an NFT.\r\n\t * Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n\t * which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n\t */\r\n\tbytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\t/**\r\n\t * @notice Handle the receipt of an NFT\r\n\t * @dev The ERC721 smart contract calls this function on the recipient\r\n\t * after a `safetransfer`. This function MAY throw to revert and reject the\r\n\t * transfer. Return of other than the magic value MUST result in the\r\n\t * transaction being reverted.\r\n\t * Note: the contract address is always the message sender.\r\n\t * @param _operator The address which called `safeTransferFrom` function\r\n\t * @param _from The address which previously owned the token\r\n\t * @param _tokenId The NFT identifier which is being transferred\r\n\t * @param _data Additional data with no specified format\r\n\t * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n\t */\r\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title AddressUtils Library\r\n * @dev Utility library of inline functions on addresses.\r\n * See (https://github.com/OpenZeppelin/openzeppelin-solidity)\r\n */\r\nlibrary AddressUtils {\r\n\r\n\t/**\r\n\t * Returns whether the target address is a contract\r\n\t * @dev This function will return false if invoked during the constructor of a contract,\r\n\t * as the code is not actually created until after the constructor finishes.\r\n\t * @param _account address of the account to check\r\n\t * @return whether the target address is a contract\r\n\t */\r\n\tfunction isContract(address _account) internal view returns(bool) \r\n\t{\r\n\t\tuint256 size;\r\n\t\t// XXX Currently there is no better way to check if there is a contract in an address\r\n\t\t// than to check the size of the code at that address.\r\n\t\t// See https://ethereum.stackexchange.com/a/14016/36603\r\n\t\t// for more details about how this works.\r\n\t\t// TODO Check this again before the Serenity release, because all addresses will be\r\n\t\t// contracts then.\r\n\t\tassembly { size := extcodesize(_account) }\r\n\t\treturn size > 0;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title StringUtils Library\r\n * @dev Utility library of inline functions on strings. \r\n * These functions are very expensive and are only intended for web3 calls\r\n * @author PixelCons\r\n */\r\nlibrary StringUtils {\r\n\r\n\t/**\r\n\t * @dev Replaces the given key with the given value in the given string\r\n\t * @param _str String to find and replace in\r\n\t * @param _key Value to search for\r\n\t * @param _value Value to replace key with\r\n\t * @return The replaced string\r\n\t */\r\n\tfunction replace(string _str, string _key, string _value) internal pure returns(string)\r\n\t{\r\n\t\tbytes memory bStr = bytes(_str);\r\n\t\tbytes memory bKey = bytes(_key);\r\n\t\tbytes memory bValue = bytes(_value);\r\n\r\n\t\tuint index = indexOf(bStr, bKey);\r\n\t\tif (index < bStr.length) {\r\n\t\t\tbytes memory rStr = new bytes((bStr.length + bValue.length) - bKey.length);\r\n\r\n\t\t\tuint i;\r\n\t\t\tfor (i = 0; i < index; i++) rStr[i] = bStr[i];\r\n\t\t\tfor (i = 0; i < bValue.length; i++) rStr[index + i] = bValue[i];\r\n\t\t\tfor (i = 0; i < bStr.length - (index + bKey.length); i++) rStr[index + bValue.length + i] = bStr[index + bKey.length + i];\r\n\r\n\t\t\treturn string(rStr);\r\n\t\t}\r\n\t\treturn string(bStr);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts a given number into a string with hex representation\r\n\t * @param _num Number to convert\r\n\t * @param _byteSize Size of the number in bytes\r\n\t * @return The hex representation as string\r\n\t */\r\n\tfunction toHexString(uint256 _num, uint _byteSize) internal pure returns(string)\r\n\t{\r\n\t\tbytes memory s = new bytes(_byteSize * 2 + 2);\r\n\t\ts[0] = 0x30;\r\n\t\ts[1] = 0x78;\r\n\t\tfor (uint i = 0; i < _byteSize; i++) {\r\n\t\t\tbyte b = byte(uint8(_num / (2 ** (8 * (_byteSize - 1 - i)))));\r\n\t\t\tbyte hi = byte(uint8(b) / 16);\r\n\t\t\tbyte lo = byte(uint8(b) - 16 * uint8(hi));\r\n\t\t\ts[2 + 2 * i] = char(hi);\r\n\t\t\ts[3 + 2 * i] = char(lo);\r\n\t\t}\r\n\t\treturn string(s);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Gets the ascii hex character for the given value (0-15)\r\n\t * @param _b Byte to get ascii code for\r\n\t * @return The ascii hex character\r\n\t */\r\n\tfunction char(byte _b) internal pure returns(byte c)\r\n\t{\r\n\t\tif (_b < 10) return byte(uint8(_b) + 0x30);\r\n\t\telse return byte(uint8(_b) + 0x57);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Gets the index of the key string in the given string\r\n\t * @param _str String to search in\r\n\t * @param _key Value to search for\r\n\t * @return The index of the key in the string (string length if not found)\r\n\t */\r\n\tfunction indexOf(bytes _str, bytes _key) internal pure returns(uint)\r\n\t{\r\n\t\tfor (uint i = 0; i < _str.length - (_key.length - 1); i++) {\r\n\t\t\tbool matchFound = true;\r\n\t\t\tfor (uint j = 0; j < _key.length; j++) {\r\n\t\t\t\tif (_str[i + j] != _key[j]) {\r\n\t\t\t\t\tmatchFound = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (matchFound) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn _str.length;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenIndex\",\"type\":\"uint64\"}],\"name\":\"getTokenDataByIndex\",\"outputs\":[{\"name\":\"_tknId\",\"type\":\"uint256\"},{\"name\":\"_tknIdx\",\"type\":\"uint64\"},{\"name\":\"_collectionIdx\",\"type\":\"uint64\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes8\"},{\"name\":\"_dateCreated\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"creatorTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"collectionTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfCollectionByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenIndex\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfCreatorByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"},{\"name\":\"_name\",\"type\":\"bytes8\"}],\"name\":\"renameCollection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getForOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_startIndex\",\"type\":\"uint64\"},{\"name\":\"_endIndex\",\"type\":\"uint64\"}],\"name\":\"getNamesInRange\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"creatorOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_startIndex\",\"type\":\"uint64\"},{\"name\":\"_endIndex\",\"type\":\"uint64\"}],\"name\":\"getCollectionNamesInRange\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollections\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"getCollectionData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"},{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes8\"}],\"name\":\"rename\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"collectionCleared\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"adminChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes8\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"clearCollection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCollectionNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"getForCollection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenData\",\"outputs\":[{\"name\":\"_tknId\",\"type\":\"uint256\"},{\"name\":\"_tknIdx\",\"type\":\"uint64\"},{\"name\":\"_collectionIdx\",\"type\":\"uint64\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes8\"},{\"name\":\"_dateCreated\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenURITemplate\",\"type\":\"string\"}],\"name\":\"adminSetTokenURITemplate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"collectionOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIndexes\",\"type\":\"uint64[]\"},{\"name\":\"_name\",\"type\":\"bytes8\"}],\"name\":\"createCollection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"getForCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"collectionExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenIndexes\",\"type\":\"uint64[]\"}],\"name\":\"getBasicData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bytes8[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"getCollectionName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newName\",\"type\":\"bytes8\"}],\"name\":\"Rename\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"CreateCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_collectionIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_newName\",\"type\":\"bytes8\"}],\"name\":\"RenameCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_collectionIndex\",\"type\":\"uint64\"}],\"name\":\"ClearCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"PixelCons","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://77ffeec90901ca8892dfe29369dbc8502d147fb5bb835c420d9b2b4b96eb2962"}]}