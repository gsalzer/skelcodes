{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"Assertion Failed\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"Assertion Failed\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface AddressRegistry {\r\n    function getAddr(string name) external view returns(address);\r\n}\r\n\r\ninterface MakerCDP {\r\n    function open() external returns (bytes32 cup);\r\n    function join(uint wad) external; // Join PETH\r\n    function exit(uint wad) external; // Exit PETH\r\n    function give(bytes32 cup, address guy) external;\r\n    function lock(bytes32 cup, uint wad) external;\r\n    function free(bytes32 cup, uint wad) external;\r\n    function draw(bytes32 cup, uint wad) external;\r\n    function wipe(bytes32 cup, uint wad) external;\r\n    function per() external view returns (uint ray);\r\n    function lad(bytes32 cup) external view returns (address);\r\n}\r\n\r\ninterface PriceInterface {\r\n    function peek() external view returns (bytes32, bool);\r\n}\r\n\r\ninterface WETHFace {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\ninterface InstaKyber {\r\n    function executeTrade(\r\n        address src,\r\n        address dest,\r\n        uint srcAmt,\r\n        uint minConversionRate,\r\n        uint maxDestAmt\r\n    ) external payable returns (uint destAmt);\r\n\r\n    function getExpectedPrice(\r\n        address src,\r\n        address dest,\r\n        uint srcAmt\r\n    ) external view returns (uint, uint);\r\n}\r\n\r\n\r\ncontract Registry {\r\n\r\n    address public addressRegistry;\r\n    modifier onlyAdmin() {\r\n        require(\r\n            msg.sender == getAddress(\"admin\"),\r\n            \"Permission Denied\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    function getAddress(string name) internal view returns(address) {\r\n        AddressRegistry addrReg = AddressRegistry(addressRegistry);\r\n        return addrReg.getAddr(name);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract GlobalVar is Registry {\r\n\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 blankCDP = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n    address cdpAddr; // cups\r\n    mapping (address => bytes32) cdps; // borrower >>> CDP Bytes\r\n    bool public freezed;\r\n\r\n}\r\n\r\n\r\ncontract IssueLoan is GlobalVar {\r\n\r\n    event LockedETH(address borrower, uint lockETH, uint lockPETH, address lockedBy);\r\n    event LoanedDAI(address borrower, uint loanDAI, address payTo);\r\n    event NewCDP(address borrower, bytes32 cdpBytes);\r\n\r\n    function pethPEReth(uint ethNum) public view returns (uint rPETH) {\r\n        MakerCDP loanMaster = MakerCDP(cdpAddr);\r\n        rPETH = (ethNum.mul(10 ** 27)).div(loanMaster.per());\r\n    }\r\n\r\n    function borrow(uint daiDraw, address beneficiary) public payable {\r\n        if (msg.value > 0) {lockETH(msg.sender);}\r\n        if (daiDraw > 0) {drawDAI(daiDraw, beneficiary);}\r\n    }\r\n\r\n    function lockETH(address borrower) public payable {\r\n        MakerCDP loanMaster = MakerCDP(cdpAddr);\r\n        if (cdps[borrower] == blankCDP) {\r\n            require(msg.sender == borrower, \"Creating CDP for others is not permitted at the moment.\");\r\n            cdps[msg.sender] = loanMaster.open();\r\n            emit NewCDP(msg.sender, cdps[msg.sender]);\r\n        }\r\n        WETHFace wethTkn = WETHFace(getAddress(\"weth\"));\r\n        wethTkn.deposit.value(msg.value)(); // ETH to WETH\r\n        uint pethToLock = pethPEReth(msg.value);\r\n        loanMaster.join(pethToLock); // WETH to PETH\r\n        loanMaster.lock(cdps[borrower], pethToLock); // PETH to CDP\r\n        emit LockedETH(\r\n            borrower, msg.value, pethToLock, msg.sender\r\n        );\r\n    }\r\n\r\n    function drawDAI(uint daiDraw, address beneficiary) public {\r\n        require(!freezed, \"Operation Disabled\");\r\n        MakerCDP loanMaster = MakerCDP(cdpAddr);\r\n        loanMaster.draw(cdps[msg.sender], daiDraw);\r\n        IERC20 daiTkn = IERC20(getAddress(\"dai\"));\r\n        address payTo = msg.sender;\r\n        if (payTo != address(0)) {\r\n            payTo = beneficiary;\r\n        }\r\n        daiTkn.transfer(payTo, daiDraw);\r\n        emit LoanedDAI(msg.sender, daiDraw, payTo);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract RepayLoan is IssueLoan {\r\n\r\n    event WipedDAI(address borrower, uint daiWipe, uint mkrCharged, address wipedBy);\r\n    event UnlockedETH(address borrower, uint ethFree);\r\n\r\n    function repay(uint daiWipe, uint ethFree) public payable {\r\n        if (daiWipe > 0) {wipeDAI(daiWipe, msg.sender);}\r\n        if (ethFree > 0) {unlockETH(ethFree);}\r\n    }\r\n\r\n    function wipeDAI(uint daiWipe, address borrower) public payable {\r\n        address dai = getAddress(\"dai\");\r\n        address mkr = getAddress(\"mkr\");\r\n        address eth = getAddress(\"eth\");\r\n\r\n        IERC20 daiTkn = IERC20(dai);\r\n        IERC20 mkrTkn = IERC20(mkr);\r\n\r\n        uint contractMKR = mkrTkn.balanceOf(address(this)); // contract MKR balance before wiping\r\n        daiTkn.transferFrom(msg.sender, address(this), daiWipe); // get DAI to pay the debt\r\n        MakerCDP loanMaster = MakerCDP(cdpAddr);\r\n        loanMaster.wipe(cdps[borrower], daiWipe); // wipe DAI\r\n        uint mkrCharged = contractMKR - mkrTkn.balanceOf(address(this)); // MKR fee = before wiping bal - after wiping bal\r\n\r\n        // claiming paid MKR back\r\n        if (msg.value > 0) { // Interacting with Kyber to swap ETH with MKR\r\n            swapETHMKR(\r\n                eth, mkr, mkrCharged, msg.value\r\n            );\r\n        } else { // take MKR directly from address\r\n            mkrTkn.transferFrom(msg.sender, address(this), mkrCharged); // user paying MKR fees\r\n        }\r\n\r\n        emit WipedDAI(\r\n            borrower, daiWipe, mkrCharged, msg.sender\r\n        );\r\n    }\r\n\r\n    function unlockETH(uint ethFree) public {\r\n        require(!freezed, \"Operation Disabled\");\r\n        uint pethToUnlock = pethPEReth(ethFree);\r\n        MakerCDP loanMaster = MakerCDP(cdpAddr);\r\n        loanMaster.free(cdps[msg.sender], pethToUnlock); // CDP to PETH\r\n        loanMaster.exit(pethToUnlock); // PETH to WETH\r\n        WETHFace wethTkn = WETHFace(getAddress(\"weth\"));\r\n        wethTkn.withdraw(ethFree); // WETH to ETH\r\n        msg.sender.transfer(ethFree);\r\n        emit UnlockedETH(msg.sender, ethFree);\r\n    }\r\n\r\n    function swapETHMKR(\r\n        address eth,\r\n        address mkr,\r\n        uint mkrCharged,\r\n        uint ethQty\r\n    ) internal \r\n    {\r\n        InstaKyber instak = InstaKyber(getAddress(\"InstaKyber\"));\r\n        uint minRate;\r\n        (, minRate) = instak.getExpectedPrice(eth, mkr, ethQty);\r\n        uint mkrBought = instak.executeTrade.value(ethQty)(\r\n            eth, mkr, ethQty, minRate, mkrCharged\r\n        );\r\n        require(mkrCharged == mkrBought, \"ETH not sufficient to cover the MKR fees.\");\r\n        if (address(this).balance > 0) {\r\n            msg.sender.transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract BorrowTasks is RepayLoan {\r\n\r\n    event TranferCDP(bytes32 cdp, address owner, address nextOwner);\r\n    event CDPClaimed(bytes32 cdp, address owner);\r\n\r\n    function transferCDP(address nextOwner) public {\r\n        require(nextOwner != 0, \"Invalid Address.\");\r\n        MakerCDP loanMaster = MakerCDP(cdpAddr);\r\n        loanMaster.give(cdps[msg.sender], nextOwner);\r\n        cdps[msg.sender] = blankCDP;\r\n        emit TranferCDP(cdps[msg.sender], msg.sender, nextOwner);\r\n    }\r\n\r\n    function claimCDP(uint cdpNum) public {\r\n        bytes32 cdpBytes = bytes32(cdpNum);\r\n        MakerCDP loanMaster = MakerCDP(cdpAddr);\r\n        address cdpOwner = loanMaster.lad(cdpBytes);\r\n        require(cdps[cdpOwner] == blankCDP, \"More than 1 CDP is not allowed.\");\r\n        cdps[cdpOwner] = cdpBytes;\r\n        emit CDPClaimed(cdpBytes, msg.sender);\r\n    }\r\n\r\n    function getETHRate() public view returns (uint) {\r\n        PriceInterface ethRate = PriceInterface(getAddress(\"ethfeed\"));\r\n        bytes32 ethrate;\r\n        (ethrate, ) = ethRate.peek();\r\n        return uint(ethrate);\r\n    }\r\n\r\n    function getCDP(address borrower) public view returns (uint, bytes32) {\r\n        return (uint(cdps[borrower]), cdps[borrower]);\r\n    }\r\n\r\n    function approveERC20() public {\r\n        IERC20 wethTkn = IERC20(getAddress(\"weth\"));\r\n        wethTkn.approve(cdpAddr, 2**256 - 1);\r\n        IERC20 pethTkn = IERC20(getAddress(\"peth\"));\r\n        pethTkn.approve(cdpAddr, 2**256 - 1);\r\n        IERC20 mkrTkn = IERC20(getAddress(\"mkr\"));\r\n        mkrTkn.approve(cdpAddr, 2**256 - 1);\r\n        IERC20 daiTkn = IERC20(getAddress(\"dai\"));\r\n        daiTkn.approve(cdpAddr, 2**256 - 1);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract InstaMaker is BorrowTasks {\r\n\r\n    event MKRCollected(uint amount);\r\n\r\n    constructor(address rAddr) public {\r\n        addressRegistry = rAddr;\r\n        cdpAddr = getAddress(\"cdp\");\r\n        approveERC20();\r\n    }\r\n\r\n    function () public payable {}\r\n\r\n    function freeze(bool stop) public onlyAdmin {\r\n        freezed = stop;\r\n    }\r\n\r\n    // collecting MKR token kept as balance to pay fees\r\n    function collectMKR(uint amount) public onlyAdmin {\r\n        IERC20 mkrTkn = IERC20(getAddress(\"mkr\"));\r\n        mkrTkn.transfer(msg.sender, amount);\r\n        emit MKRCollected(amount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"ethNum\",\"type\":\"uint256\"}],\"name\":\"pethPEReth\",\"outputs\":[{\"name\":\"rPETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"daiWipe\",\"type\":\"uint256\"},{\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"wipeDAI\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"daiDraw\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"daiDraw\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"drawDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getETHRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"lockETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ethFree\",\"type\":\"uint256\"}],\"name\":\"unlockETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"getCDP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stop\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpNum\",\"type\":\"uint256\"}],\"name\":\"claimCDP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nextOwner\",\"type\":\"address\"}],\"name\":\"transferCDP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"daiWipe\",\"type\":\"uint256\"},{\"name\":\"ethFree\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectMKR\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"rAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MKRCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdp\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nextOwner\",\"type\":\"address\"}],\"name\":\"TranferCDP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdp\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CDPClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"daiWipe\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mkrCharged\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wipedBy\",\"type\":\"address\"}],\"name\":\"WipedDAI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethFree\",\"type\":\"uint256\"}],\"name\":\"UnlockedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lockETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockPETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockedBy\",\"type\":\"address\"}],\"name\":\"LockedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"loanDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payTo\",\"type\":\"address\"}],\"name\":\"LoanedDAI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpBytes\",\"type\":\"bytes32\"}],\"name\":\"NewCDP\",\"type\":\"event\"}]","ContractName":"InstaMaker","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e16d035b8e76303237b9660b3c9c94c1a86aab47","Library":"","SwarmSource":"bzzr://894e3ac264276d62f18446dc84c3416b626064df89bcb9a0d6fcd5d4d5c0072b"}]}