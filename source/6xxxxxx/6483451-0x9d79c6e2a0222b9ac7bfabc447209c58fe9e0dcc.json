{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/PeriodUtil.sol\r\n\r\n/**\r\n * @title PeriodUtil\r\n * \r\n * Interface used for Period calculation to allow better automated testing of Fees Contract\r\n *\r\n * (c) Philip Louw / Zero Carbon Project 2018. The MIT Licence.\r\n */\r\ncontract PeriodUtil {\r\n    /**\r\n    * @dev calculates the Period index for the given timestamp\r\n    * @return Period count since EPOCH\r\n    * @param timestamp The time in seconds since EPOCH (blocktime)\r\n    */\r\n    function getPeriodIdx(uint256 timestamp) public pure returns (uint256);\r\n    \r\n    /**\r\n    * @dev Timestamp of the period start\r\n    * @return Time in seconds since EPOCH of the Period Start\r\n    * @param periodIdx Period Index to find the start timestamp of\r\n    */\r\n    function getPeriodStartTimestamp(uint256 periodIdx) public pure returns (uint256);\r\n\r\n    /**\r\n    * @dev Returns the Cycle count of the given Periods. A set of time creates a cycle, eg. If period is weeks the cycle can be years.\r\n    * @return The Cycle Index\r\n    * @param timestamp The time in seconds since EPOCH (blocktime)\r\n    */\r\n    function getPeriodCycle(uint256 timestamp) public pure returns (uint256);\r\n\r\n    /**\r\n    * @dev Amount of Tokens per time unit since the start of the given periodIdx\r\n    * @return Tokens per Time Unit from the given periodIdx start till now\r\n    * @param tokens Total amount of tokens from periodIdx start till now (blocktime)\r\n    * @param periodIdx Period IDX to use for time start\r\n    */\r\n    function getRatePerTimeUnits(uint256 tokens, uint256 periodIdx) public view returns (uint256);\r\n\r\n    /**\r\n    * @dev Amount of time units in each Period, for exampe if units is hour and period is week it will be 168\r\n    * @return Amount of time units per period\r\n    */\r\n    function getUnitsPerPeriod() public pure returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/ERC20Burnable.sol\r\n\r\n/**\r\n * @title BurnableToken\r\n * \r\n * Interface for Basic ERC20 interactions and allowing burning  of tokens\r\n *\r\n * (c) Philip Louw / Zero Carbon Project 2018. The MIT Licence.\r\n */\r\ncontract ERC20Burnable is ERC20Basic {\r\n\r\n    function burn(uint256 _value) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/ZCFees.sol\r\n\r\n/**\r\n * @title ZCFees\r\n * \r\n * Used to process transaction\r\n *\r\n * (c) Philip Louw / Zero Carbon Project 2018. The MIT Licence.\r\n */\r\ncontract ZCFees {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct PaymentHistory {\r\n        // If set \r\n        bool paid;\r\n        // Payment to Fees\r\n        uint256 fees;\r\n        // Payment to Reward\r\n        uint256 reward;\r\n        // End of period token balance\r\n        uint256 endBalance;\r\n    }\r\n\r\n    uint256 public totalRewards;\r\n    uint256 public totalFees;\r\n\r\n    mapping (uint256 => PaymentHistory) payments;\r\n    address public tokenAddress;\r\n    PeriodUtil public periodUtil;\r\n    // Last week that has been executed\r\n    uint256 public lastPeriodExecIdx;\r\n    // Last Year that has been processed\r\n    uint256 public lastPeriodCycleExecIdx;\r\n    // Amount of time in seconds grase processing time\r\n    uint256 grasePeriod;\r\n\r\n    // Wallet for Fees payments\r\n    address public feesWallet;\r\n    // Wallet for Reward payments\r\n    address public rewardWallet;\r\n    \r\n    // Fees 1 : % tokens taken per week\r\n    uint256 internal constant FEES1_PER = 10;\r\n    // Fees 1 : Max token payout per week\r\n    uint256 internal constant FEES1_MAX_AMOUNT = 400000 * (10**18);\r\n    // Fees 2 : % tokens taken per week\r\n    uint256 internal constant FEES2_PER = 10;\r\n    // Fees 2 : Max token payout per week\r\n    uint256 internal constant FEES2_MAX_AMOUNT = 800000 * (10**18);\r\n    // Min Amount of Fees to pay out per week\r\n    uint256 internal constant FEES_TOKEN_MIN_AMOUNT = 24000 * (10**18);\r\n    // Min Percentage Prev Week to pay out per week\r\n    uint256 internal constant FEES_TOKEN_MIN_PERPREV = 95;\r\n    // Rewards Percentage of Period Received\r\n    uint256 internal constant REWARD_PER = 70;\r\n    // % Amount of remaining tokens to burn at end of year\r\n    uint256 internal constant BURN_PER = 25;\r\n    \r\n    /**\r\n     * @param _tokenAdr The Address of the Token\r\n     * @param _periodUtilAdr The Address of the PeriodUtil\r\n     * @param _grasePeriod The time in seconds you allowed to process payments before avg is calculated into next period(s)\r\n     * @param _feesWallet Where the fees are sent in tokens\r\n     * @param _rewardWallet Where the rewards are sent in tokens\r\n     */\r\n    constructor (address _tokenAdr, address _periodUtilAdr, uint256 _grasePeriod, address _feesWallet, address _rewardWallet) public {\r\n        assert(_tokenAdr != address(0));\r\n        assert(_feesWallet != address(0));\r\n        assert(_rewardWallet != address(0));\r\n        assert(_periodUtilAdr != address(0));\r\n        tokenAddress = _tokenAdr;\r\n        feesWallet = _feesWallet;\r\n        rewardWallet = _rewardWallet;\r\n        periodUtil = PeriodUtil(_periodUtilAdr);\r\n\r\n        grasePeriod = _grasePeriod;\r\n        assert(grasePeriod > 0);\r\n        // GrasePeriod must be less than period\r\n        uint256 va1 = periodUtil.getPeriodStartTimestamp(1);\r\n        uint256 va2 = periodUtil.getPeriodStartTimestamp(0);\r\n        assert(grasePeriod < (va1 - va2));\r\n\r\n        // Set the previous period values;\r\n        lastPeriodExecIdx = getWeekIdx() - 1;\r\n        lastPeriodCycleExecIdx = getYearIdx();\r\n        PaymentHistory storage prevPayment = payments[lastPeriodExecIdx];\r\n        prevPayment.fees = 0;\r\n        prevPayment.reward = 0;\r\n        prevPayment.paid = true;\r\n        prevPayment.endBalance = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Call when Fees processing needs to happen. Can only be called by the contract Owner\r\n     */\r\n    function process() public {\r\n        uint256 currPeriodIdx = getWeekIdx();\r\n\r\n        // Has the previous period been calculated?\r\n        if (lastPeriodExecIdx == (currPeriodIdx - 1)) {\r\n            // Nothing to do previous week has Already been processed\r\n            return;\r\n        }\r\n\r\n        if ((currPeriodIdx - lastPeriodExecIdx) == 2) {\r\n            paymentOnTime(currPeriodIdx);\r\n            // End Of Year Payment\r\n            if (lastPeriodCycleExecIdx < getYearIdx()) {\r\n                processEndOfYear(currPeriodIdx - 1);\r\n            }\r\n        }\r\n        else {\r\n            uint256 availableTokens = currentBalance();\r\n            // Missed Full Period! Very Bad!\r\n            PaymentHistory memory lastExecPeriod = payments[lastPeriodExecIdx];\r\n            uint256 tokensReceived = availableTokens.sub(lastExecPeriod.endBalance);\r\n            // Average amount of tokens received per hour till now\r\n            uint256 tokenHourlyRate = periodUtil.getRatePerTimeUnits(tokensReceived, lastPeriodExecIdx + 1);\r\n\r\n            PaymentHistory memory prePeriod;\r\n\r\n            for (uint256 calcPeriodIdx = lastPeriodExecIdx + 1; calcPeriodIdx < currPeriodIdx; calcPeriodIdx++) {\r\n                prePeriod = payments[calcPeriodIdx - 1];\r\n                uint256 periodTokenReceived = periodUtil.getUnitsPerPeriod().mul(tokenHourlyRate);\r\n                makePayments(prePeriod, payments[calcPeriodIdx], periodTokenReceived, prePeriod.endBalance.add(periodTokenReceived), calcPeriodIdx);\r\n\r\n                if (periodUtil.getPeriodCycle(periodUtil.getPeriodStartTimestamp(calcPeriodIdx + 1)) > lastPeriodCycleExecIdx) {\r\n                    processEndOfYear(calcPeriodIdx);\r\n                }\r\n            }\r\n        }\r\n\r\n        assert(payments[currPeriodIdx - 1].paid);\r\n        lastPeriodExecIdx = currPeriodIdx - 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to process end of year Clearance\r\n     * @param yearEndPeriodCycle The Last Period Idx (Week Idx) of the year\r\n     */\r\n    function processEndOfYear(uint256 yearEndPeriodCycle) internal {\r\n        PaymentHistory storage lastYearPeriod = payments[yearEndPeriodCycle];\r\n        uint256 availableTokens = currentBalance();\r\n        uint256 tokensToClear = min256(availableTokens,lastYearPeriod.endBalance);\r\n\r\n        // Burn some of tokens\r\n        uint256 tokensToBurn = tokensToClear.mul(BURN_PER).div(100);\r\n        ERC20Burnable(tokenAddress).burn(tokensToBurn);\r\n\r\n        uint256 tokensToFeesWallet = tokensToClear.sub(tokensToBurn);\r\n        totalFees = totalFees.add(tokensToFeesWallet);\r\n        assert(ERC20Burnable(tokenAddress).transfer(feesWallet, tokensToFeesWallet));\r\n        lastPeriodCycleExecIdx = lastPeriodCycleExecIdx + 1;\r\n        lastYearPeriod.endBalance = 0;\r\n\r\n        emit YearEndClearance(lastPeriodCycleExecIdx, tokensToFeesWallet, tokensToBurn);\r\n    }\r\n\r\n    /**\r\n     * @dev Called when Payments are call within a week of last payment\r\n     * @param currPeriodIdx Current Period Idx (Week)\r\n     */\r\n    function paymentOnTime(uint256 currPeriodIdx) internal {\r\n    \r\n        uint256 availableTokens = currentBalance();\r\n        PaymentHistory memory prePeriod = payments[currPeriodIdx - 2];\r\n\r\n        uint256 tokensRecvInPeriod = availableTokens.sub(prePeriod.endBalance);\r\n\r\n        if (tokensRecvInPeriod <= 0) {\r\n            tokensRecvInPeriod = 0;\r\n        }\r\n        else if ((now - periodUtil.getPeriodStartTimestamp(currPeriodIdx)) > grasePeriod) {\r\n            tokensRecvInPeriod = periodUtil.getRatePerTimeUnits(tokensRecvInPeriod, currPeriodIdx - 1).mul(periodUtil.getUnitsPerPeriod());\r\n            if (tokensRecvInPeriod <= 0) {\r\n                tokensRecvInPeriod = 0;\r\n            }\r\n            assert(availableTokens >= tokensRecvInPeriod);\r\n        }   \r\n\r\n        makePayments(prePeriod, payments[currPeriodIdx - 1], tokensRecvInPeriod, prePeriod.endBalance + tokensRecvInPeriod, currPeriodIdx - 1);\r\n    }\r\n\r\n    /**\r\n    * @dev Process a payment period\r\n    * @param prevPayment Previous periods payment records\r\n    * @param currPayment Current periods payment records to be updated\r\n    * @param tokensRaised Tokens received for the period\r\n    * @param availableTokens Contract available balance including the tokens received for the period\r\n    */\r\n    function makePayments(PaymentHistory memory prevPayment, PaymentHistory storage currPayment, uint256 tokensRaised, uint256 availableTokens, uint256 weekIdx) internal {\r\n\r\n        assert(prevPayment.paid);\r\n        assert(!currPayment.paid);\r\n        assert(availableTokens >= tokensRaised);\r\n\r\n        // Fees 1 Payment\r\n        uint256 fees1Pay = tokensRaised == 0 ? 0 : tokensRaised.mul(FEES1_PER).div(100);\r\n        if (fees1Pay >= FEES1_MAX_AMOUNT) {\r\n            fees1Pay = FEES1_MAX_AMOUNT;\r\n        }\r\n        // Fees 2 Payment\r\n        uint256 fees2Pay = tokensRaised == 0 ? 0 : tokensRaised.mul(FEES2_PER).div(100);\r\n        if (fees2Pay >= FEES2_MAX_AMOUNT) {\r\n            fees2Pay = FEES2_MAX_AMOUNT;\r\n        }\r\n\r\n        uint256 feesPay = fees1Pay.add(fees2Pay);\r\n        if (feesPay >= availableTokens) {\r\n            feesPay = availableTokens;\r\n        } else {\r\n            // Calculates the Min percentage of previous month to pay\r\n            uint256 prevFees95 = prevPayment.fees.mul(FEES_TOKEN_MIN_PERPREV).div(100);\r\n            // Minimum amount of fees that is required\r\n            uint256 minFeesPay = max256(FEES_TOKEN_MIN_AMOUNT, prevFees95);\r\n            feesPay = max256(feesPay, minFeesPay);\r\n            feesPay = min256(feesPay, availableTokens);\r\n        }\r\n\r\n        // Rewards Payout\r\n        uint256 rewardPay = 0;\r\n        if (feesPay < tokensRaised) {\r\n            // There is money left for reward pool\r\n            rewardPay = tokensRaised.mul(REWARD_PER).div(100);\r\n            rewardPay = min256(rewardPay, availableTokens.sub(feesPay));\r\n        }\r\n\r\n        currPayment.fees = feesPay;\r\n        currPayment.reward = rewardPay;\r\n\r\n        totalFees = totalFees.add(feesPay);\r\n        totalRewards = totalRewards.add(rewardPay);\r\n\r\n        assert(ERC20Burnable(tokenAddress).transfer(rewardWallet, rewardPay));\r\n        assert(ERC20Burnable(tokenAddress).transfer(feesWallet, feesPay));\r\n\r\n        currPayment.endBalance = availableTokens - feesPay - rewardPay;\r\n        currPayment.paid = true;\r\n\r\n        emit Payment(weekIdx, rewardPay, feesPay);\r\n    }\r\n\r\n    /**\r\n    * @dev Event when payment was made\r\n    * @param weekIdx Week Idx since EPOCH for payment\r\n    * @param rewardPay Amount of tokens paid to the reward pool\r\n    * @param feesPay Amount of tokens paid in fees\r\n    */\r\n    event Payment(uint256 weekIdx, uint256 rewardPay, uint256 feesPay);\r\n\r\n    /**\r\n    * @dev Event when year end clearance happens\r\n    * @param yearIdx Year the clearance happend for\r\n    * @param feesPay Amount of tokens paid in fees\r\n    * @param burned Amount of tokens burned\r\n    */\r\n    event YearEndClearance(uint256 yearIdx, uint256 feesPay, uint256 burned);\r\n\r\n\r\n    /**\r\n    * @dev Returns the token balance of the Fees contract\r\n    */\r\n    function currentBalance() internal view returns (uint256) {\r\n        return ERC20Burnable(tokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the amount of weeks since EPOCH\r\n    * @return Week count since EPOCH\r\n    */\r\n    function getWeekIdx() public view returns (uint256) {\r\n        return periodUtil.getPeriodIdx(now);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the Year\r\n    */\r\n    function getYearIdx() public view returns (uint256) {\r\n        return periodUtil.getPeriodCycle(now);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns true if the week has been processed and paid out\r\n    * @param weekIdx Weeks since EPOCH\r\n    * @return true if week has been paid out\r\n    */\r\n    function weekProcessed(uint256 weekIdx) public view returns (bool) {\r\n        return payments[weekIdx].paid;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the amounts paid out for the given week\r\n    * @param weekIdx Weeks since EPOCH\r\n    */\r\n    function paymentForWeek(uint256 weekIdx) public view returns (uint256 fees, uint256 reward) {\r\n        PaymentHistory storage history = payments[weekIdx];\r\n        fees = history.fees;\r\n        reward = history.reward;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeekIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weekIdx\",\"type\":\"uint256\"}],\"name\":\"weekProcessed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPeriodCycleExecIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodUtil\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPeriodExecIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"process\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weekIdx\",\"type\":\"uint256\"}],\"name\":\"paymentForWeek\",\"outputs\":[{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getYearIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAdr\",\"type\":\"address\"},{\"name\":\"_periodUtilAdr\",\"type\":\"address\"},{\"name\":\"_grasePeriod\",\"type\":\"uint256\"},{\"name\":\"_feesWallet\",\"type\":\"address\"},{\"name\":\"_rewardWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weekIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardPay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feesPay\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"yearIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feesPay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"burned\",\"type\":\"uint256\"}],\"name\":\"YearEndClearance\",\"type\":\"event\"}]","ContractName":"ZCFees","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006737fe98389ffb356f64ebb726aa1a92390d94fb0000000000000000000000002bcf5193687d9abd60128f4f7307054431d724a10000000000000000000000000000000000000000000000000000000000000e100000000000000000000000008054f4a0bf50f550a02d9d0b7a53f083e689068b000000000000000000000000200dcdd8bf9d8429569281c9c46bd120c53ddba4","Library":"","SwarmSource":"bzzr://003fba9f4df6f5f556fa83e827ea023f7f13569515e6080559604e182d0045be"}]}