{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// Authored by Radek Ostrowski and Maciek Zielinski\r\n// http://startonchain.com\r\n// And Alex George\r\n// https://dexbrokerage.com\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev a to power of b, throws on overflow.\r\n  */\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a ** b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract DexBrokerage is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  address public feeAccount;\r\n  uint256 public makerFee;\r\n  uint256 public takerFee;\r\n  uint256 public inactivityReleasePeriod;\r\n  mapping (address => bool) public approvedCurrencyTokens;\r\n  mapping (address => uint256) public invalidOrder;\r\n  mapping (address => mapping (address => uint256)) public tokens;\r\n  mapping (address => bool) public admins;\r\n  mapping (address => uint256) public lastActiveTransaction;\r\n  mapping (bytes32 => uint256) public orderFills;\r\n  mapping (bytes32 => bool) public withdrawn;\r\n\r\n  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker);\r\n  event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n  event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n  event MakerFeeUpdated(uint256 oldFee, uint256 newFee);\r\n  event TakerFeeUpdated(uint256 oldFee, uint256 newFee);\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == owner || admins[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  constructor(uint256 _makerFee, uint256 _takerFee , address _feeAccount, uint256 _inactivityReleasePeriod) public {\r\n    owner = msg.sender;\r\n    makerFee = _makerFee;\r\n    takerFee = _takerFee;\r\n    feeAccount = _feeAccount;\r\n    inactivityReleasePeriod = _inactivityReleasePeriod;\r\n  }\r\n\r\n  function approveCurrencyTokenAddress(address currencyTokenAddress, bool isApproved) onlyAdmin public {\r\n    approvedCurrencyTokens[currencyTokenAddress] = isApproved;\r\n  }\r\n\r\n  function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin public {\r\n    require(nonce >= invalidOrder[user]);\r\n    invalidOrder[user] = nonce;\r\n  }\r\n\r\n  function setMakerFee(uint256 _makerFee) onlyAdmin public {\r\n    //market maker fee will never be more than 1%\r\n    uint256 oldFee = makerFee;\r\n    if (_makerFee > 10 finney) {\r\n      _makerFee = 10 finney;\r\n    }\r\n    require(makerFee != _makerFee);\r\n    makerFee = _makerFee;\r\n    emit MakerFeeUpdated(oldFee, makerFee);\r\n  }\r\n\r\n  function setTakerFee(uint256 _takerFee) onlyAdmin public {\r\n    //market taker fee will never be more than 2%\r\n    uint256 oldFee = takerFee;\r\n    if (_takerFee > 20 finney) {\r\n      _takerFee = 20 finney;\r\n    }\r\n    require(takerFee != _takerFee);\r\n    takerFee = _takerFee;\r\n    emit TakerFeeUpdated(oldFee, takerFee);\r\n  }\r\n\r\n  function setInactivityReleasePeriod(uint256 expire) onlyAdmin public returns (bool) {\r\n    require(expire <= 50000);\r\n    inactivityReleasePeriod = expire;\r\n    return true;\r\n  }\r\n\r\n  function setAdmin(address admin, bool isAdmin) onlyOwner public {\r\n    admins[admin] = isAdmin;\r\n  }\r\n\r\n  function depositToken(address token, uint256 amount) public {\r\n    receiveTokenDeposit(token, msg.sender, amount);\r\n  }\r\n\r\n  function receiveTokenDeposit(address token, address from, uint256 amount) public {\r\n    tokens[token][from] = tokens[token][from].add(amount);\r\n    lastActiveTransaction[from] = block.number;\r\n    require(ERC20(token).transferFrom(from, address(this), amount));\r\n    emit Deposit(token, from, amount, tokens[token][from]);\r\n  }\r\n\r\n  function deposit() payable public {\r\n    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\r\n  }\r\n\r\n  function withdraw(address token, uint256 amount) public returns (bool) {\r\n    require(block.number.sub(lastActiveTransaction[msg.sender]) >= inactivityReleasePeriod);\r\n    require(tokens[token][msg.sender] >= amount);\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    if (token == address(0)) {\r\n      msg.sender.transfer(amount);\r\n    } else {\r\n      require(ERC20(token).transfer(msg.sender, amount));\r\n    }\r\n    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n    return true;\r\n  }\r\n\r\n  function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 gasCost) onlyAdmin public returns (bool) {\r\n    //gasCost will never be more than 30 finney\r\n    if (gasCost > 30 finney) gasCost = 30 finney;\r\n\r\n    if(token == address(0)){\r\n      require(tokens[address(0)][user] >= gasCost.add(amount));\r\n    } else {\r\n      require(tokens[address(0)][user] >= gasCost);\r\n      require(tokens[token][user] >= amount);\r\n    }\r\n\r\n    bytes32 hash = keccak256(address(this), token, amount, user, nonce);\r\n    require(!withdrawn[hash]);\r\n    withdrawn[hash] = true;\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user);\r\n\r\n    if(token == address(0)){\r\n      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost.add(amount));\r\n      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\r\n      user.transfer(amount);\r\n    } else {\r\n      tokens[token][user] = tokens[token][user].sub(amount);\r\n      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost);\r\n      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\r\n      require(ERC20(token).transfer(user, amount));\r\n    }\r\n    lastActiveTransaction[user] = block.number;\r\n    emit Withdraw(token, user, amount, tokens[token][user]);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address token, address user) view public returns (uint256) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n    /* tradeValues\r\n       [0] amountBuy\r\n       [1] amountSell\r\n       [2] makerNonce\r\n       [3] takerAmountBuy\r\n       [4] takerAmountSell\r\n       [5] takerExpires\r\n       [6] takerNonce\r\n       [7] makerAmountBuy\r\n       [8] makerAmountSell\r\n       [9] makerExpires\r\n       [10] gasCost\r\n     tradeAddressses\r\n       [0] tokenBuy\r\n       [1] tokenSell\r\n       [2] maker\r\n       [3] taker\r\n     */\r\n\r\n\r\n  function trade(uint256[11] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) onlyAdmin public returns (bool) {\r\n    uint256 price = tradeValues[0].mul(1 ether).div(tradeValues[1]);\r\n    require(price >= tradeValues[7].mul(1 ether).div(tradeValues[8]).sub(100000 wei));\r\n    require(price <= tradeValues[4].mul(1 ether).div(tradeValues[3]).add(100000 wei));\r\n    require(block.number < tradeValues[9]);\r\n    require(block.number < tradeValues[5]);\r\n    require(invalidOrder[tradeAddresses[2]] <= tradeValues[2]);\r\n    require(invalidOrder[tradeAddresses[3]] <= tradeValues[6]);\r\n    bytes32 orderHash = keccak256(address(this), tradeAddresses[0], tradeValues[7], tradeAddresses[1], tradeValues[8], tradeValues[9], tradeValues[2], tradeAddresses[2]);\r\n    bytes32 tradeHash = keccak256(address(this), tradeAddresses[1], tradeValues[3], tradeAddresses[0], tradeValues[4], tradeValues[5], tradeValues[6], tradeAddresses[3]);\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]);\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]);\r\n    require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[0]);\r\n    require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= tradeValues[1]);\r\n    if ((tradeAddresses[0] == address(0) || tradeAddresses[1] == address(0)) && tradeValues[10] > 30 finney) tradeValues[10] = 30 finney;\r\n    if ((approvedCurrencyTokens[tradeAddresses[0]] == true || approvedCurrencyTokens[tradeAddresses[1]] == true) && tradeValues[10] > 10 ether) tradeValues[10] = 10 ether;\r\n\r\n    if(tradeAddresses[0] == address(0) || approvedCurrencyTokens[tradeAddresses[0]] == true){\r\n\r\n      require(orderFills[orderHash].add(tradeValues[1]) <= tradeValues[8]);\r\n      require(orderFills[tradeHash].add(tradeValues[1]) <= tradeValues[3]);\r\n\r\n      //tradeAddresses[0] is ether\r\n      uint256 valueInTokens = tradeValues[1];\r\n\r\n      //move tokens\r\n      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInTokens);\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInTokens);\r\n\r\n      //from taker, take ether payment, fee and gasCost\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(takerFee.mul(tradeValues[0]).div(1 ether));\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[10]);\r\n\r\n      //to maker add ether payment, take fee\r\n      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\r\n      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].sub(makerFee.mul(tradeValues[0]).div(1 ether));\r\n\r\n      // take maker fee, taker fee and gasCost\r\n      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(makerFee.mul(tradeValues[0]).div(1 ether));\r\n      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(takerFee.mul(tradeValues[0]).div(1 ether));\r\n      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(tradeValues[10]);\r\n\r\n      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[1]);\r\n      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[1]);\r\n\r\n    } else {\r\n\r\n      require(orderFills[orderHash].add(tradeValues[0]) <= tradeValues[7]);\r\n      require(orderFills[tradeHash].add(tradeValues[0]) <= tradeValues[4]);\r\n\r\n      //tradeAddresses[0] is token\r\n      uint256 valueInEth = tradeValues[1];\r\n\r\n      //move tokens //changed tradeValues to 0\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\r\n      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\r\n\r\n      //from maker, take ether payment and fee\r\n      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInEth);\r\n      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(makerFee.mul(valueInEth).div(1 ether));\r\n\r\n      //add ether payment to taker, take fee, take gasCost\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInEth);\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(takerFee.mul(valueInEth).div(1 ether));\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(tradeValues[10]);\r\n\r\n      //take maker fee, taker fee and gasCost\r\n      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(makerFee.mul(valueInEth).div(1 ether));\r\n      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(takerFee.mul(valueInEth).div(1 ether));\r\n      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(tradeValues[10]);\r\n\r\n      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[0]);\r\n      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[0]);\r\n    }\r\n\r\n    lastActiveTransaction[tradeAddresses[2]] = block.number;\r\n    lastActiveTransaction[tradeAddresses[3]] = block.number;\r\n\r\n    emit Trade(tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeAddresses[2], tradeAddresses[3]);\r\n    return true;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currencyTokenAddress\",\"type\":\"address\"},{\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"approveCurrencyTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"receiveTokenDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invalidOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"invalidateOrdersBefore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_makerFee\",\"type\":\"uint256\"}],\"name\":\"setMakerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeValues\",\"type\":\"uint256[11]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[4]\"},{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedCurrencyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expire\",\"type\":\"uint256\"}],\"name\":\"setInactivityReleasePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_takerFee\",\"type\":\"uint256\"}],\"name\":\"setTakerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inactivityReleasePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_makerFee\",\"type\":\"uint256\"},{\"name\":\"_takerFee\",\"type\":\"uint256\"},{\"name\":\"_feeAccount\",\"type\":\"address\"},{\"name\":\"_inactivityReleasePeriod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenBuy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"MakerFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"TakerFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DexBrokerage","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000038d7ea4c6800000000000000000000000000000000000000000000000000000071afd498d0000000000000000000000000000ac68cfd125d8c47101c86dcc44bcafd06092f7580000000000000000000000000000000000000000000000000000000000004e20","Library":"","SwarmSource":"bzzr://08d43b7bceff4c3bda6099d6bfe95f6f51fadf64d77309ccc487dda94eb6b121"}]}