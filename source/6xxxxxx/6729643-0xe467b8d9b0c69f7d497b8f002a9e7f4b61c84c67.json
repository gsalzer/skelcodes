{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\nlibrary SafeMathExt{\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (b == 0){\r\n      return 1;\r\n    }\r\n    if (b == 1){\r\n      return a;\r\n    }\r\n    uint256 c = a;\r\n    for(uint i = 1; i<b; i++){\r\n      c = mul(c, a);\r\n    }\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function roundUp(uint256 a, uint256 b) public pure returns(uint256){\r\n    // ((a + b - 1) / b) * b\r\n    uint256 c = (mul(div(sub(add(a, b), 1), b), b));\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract BadgeFactoryInterface{\r\n\tfunction _initBadges(address admin_, uint256 badgeBasePrice_, uint256 badgeStartMultiplier_, uint256 badgeStartQuantity_) external;\r\n\tfunction _createNewBadge(address owner_, uint256 price_) external;\r\n\tfunction _setOwner(uint256 badgeID_, address owner_) external;\r\n\tfunction getOwner(uint256 badgeID_) public view returns(address);\r\n\tfunction _increasePrice(uint256 badgeID_) external;\r\n\tfunction getPrice(uint256 badgeID_) public view returns(uint256);\r\n\tfunction _increaseTotalDivis(uint256 badgeID_, uint256 divis_) external;\r\n\tfunction getTotalDivis(uint256 badgeID_) public view returns(uint256);\r\n\tfunction _setBuyTime(uint256 badgeID_, uint32 timeStamp_) external;\r\n\tfunction getBuyTime(uint256 badgeID_) public view returns(uint32);\r\n\tfunction getCreationTime(uint256 badgeID_) public view returns(uint32);\r\n\tfunction getChainLength() public view returns(uint256);\r\n\tfunction getRandomBadge(uint256 max_, uint256 i_) external view returns(uint256);\r\n    function getRandomFactor() external returns(uint256);\r\n}\r\n\r\ncontract TeamAmberInterface{\r\n    function distribute() public payable;\r\n}\r\n\r\ncontract Amber{\r\n\tusing SafeMathExt for uint256;\r\n    /*===============================================================================\r\n    =                      DATA SET                     DATA SET                    =\r\n    ===============================================================================*/\r\n    /*==============================\r\n    =          INTERFACES          =\r\n    ==============================*/\r\n    BadgeFactoryInterface internal _badgeFactory;\r\n    TeamAmberInterface internal _teamAmber;\r\n\r\n    /*==============================\r\n    =          CONSTANTS           =\r\n    ==============================*/\r\n    uint256 internal constant GWEI = 10**9;\r\n    uint256 internal constant FINNEY = 10**15;\r\n    uint256 internal constant ETH = 10**18;\r\n    uint256 internal constant _badgeBasePrice = 25 * FINNEY;\r\n    uint256 internal constant _luckyWinners = 5;\r\n    uint256 internal constant _sharePreviousOwnerRatio = 50;\r\n    uint256 internal constant _shareReferalRatio = 5;\r\n    uint256 internal constant _shareDistributionRatio = 45;\r\n\r\n    /*==============================\r\n    =          VARIABLES           =\r\n    ==============================*/\r\n    address internal _contractOwner;\r\n    address internal _admin;\r\n    uint256 internal _startTime;\r\n    uint256 internal _initCounter;\r\n\r\n    /*==============================\r\n    =            BADGES            =\r\n    ==============================*/\r\n    struct Badge{\r\n        address owner;\r\n        uint256 price;\r\n        uint256 totalDivis;\r\n    }\r\n\r\n    Badge[] private badges;\r\n\r\n    /*==============================\r\n    =        USER MAPPINGS         =\r\n    ==============================*/\r\n    mapping(address => uint256) private _splitProfit;\r\n    mapping(address => uint256) private _flipProfit;\r\n    mapping(address => uint256) private _waypointProfit;\r\n    mapping(address => address) private _referer;\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onContractStart(uint256 startTime_);\r\n    event onRefererSet(address indexed user_, address indexed referer_);\r\n    event onBadgeBuy(uint256 indexed badgeID_, address previousOwner_, address indexed buyer_, address indexed referer_, uint256 price_, uint256 newPrice_);\r\n    event onWithdraw(address indexed receiver_, uint256 splitProfit_, uint256 flipProfit_, uint256 waypointProfit_);\r\n\r\n    /*==============================\r\n    =          MODIFIERS           =\r\n    ==============================*/\r\n    modifier onlyContractOwner(){\r\n    \trequire(msg.sender == _contractOwner, 'Sender is not the contract owner.');\r\n    \t_;\r\n    }\r\n    modifier isNotAContract(){\r\n        require (msg.sender == tx.origin, 'Contracts are not allowed to interact.');\r\n        _;\r\n    }\r\n    modifier isRunning(){\r\n    \trequire(_startTime != 0 && _startTime <= now, 'The contract is not running yet.');\r\n    \t_;\r\n    }\r\n\r\n    /*===============================================================================\r\n    =                       PURE AMBER                       PURE AMBER             =\r\n    ===============================================================================*/\r\n    function isValidBuy(uint256 price_, uint256 msgValue_) public pure returns(bool){\r\n        return (price_ == msgValue_);\r\n    }\r\n\r\n    function refererAllowed(address msgSender_, address currentReferer_, address newReferer_) public pure returns(bool){\r\n        return (addressNotSet(currentReferer_) && isAddress(newReferer_) && isNotSelf(msgSender_, newReferer_));\r\n    }\r\n\r\n    function addressNotSet(address address_) public pure returns(bool){\r\n        return (address_ == 0x0);\r\n    }\r\n\r\n    function isAddress(address address_) public pure returns(bool){\r\n        return (address_ != 0x0);\r\n    }\r\n\r\n    function isNotSelf(address msgSender_, address compare_) public pure returns(bool){\r\n        return (msgSender_ != compare_);\r\n    }\r\n\r\n    function isFirstBadgeEle(uint256 badgeID_) public pure returns(bool){\r\n        return (badgeID_ == 0);\r\n    }\r\n\r\n    function isLastBadgeEle(uint256 badgeID_, uint256 badgeLength_) public pure returns(bool){\r\n        assert(badgeID_ <= SafeMathExt.sub(badgeLength_, 1));\r\n        return (badgeID_ == SafeMathExt.sub(badgeLength_, 1));\r\n    }\r\n\r\n    function calcShare(uint256 msgValue_, uint256 ratio_) public pure returns(uint256){\r\n        assert(ratio_ <= 100 && msgValue_ >= 0);\r\n        return (msgValue_ * ratio_) / 100;\r\n    }\r\n\r\n    /*===============================================================================\r\n    =                     BADGE FACTORY                     BADGE FACTORY           =\r\n    ===============================================================================*/\r\n    function _initBadges(address[] owner_, uint256[] price_, uint256[] totalDivis_) internal{\r\n        for (uint256 i = 0; i < owner_.length; i++) {\r\n            badges.push(Badge(owner_[i], price_[i], totalDivis_[i]));\r\n        }\r\n    }\r\n\r\n    function _createNewBadge(address owner_, uint256 price_) internal{\r\n        badges.push(Badge(owner_, price_, 0));\r\n    }\r\n\r\n    function _setOwner(uint256 badgeID_, address owner_) internal{\r\n        badges[badgeID_].owner = owner_;\r\n    }\r\n\r\n    function getOwner(uint256 badgeID_) public view returns(address){\r\n        return badges[badgeID_].owner;\r\n    }\r\n\r\n    function _increasePrice(uint256 badgeID_) internal{\r\n        uint256 newPrice = (badges[badgeID_].price * _badgeFactory.getRandomFactor()) / 100;\r\n        badges[badgeID_].price = SafeMathExt.roundUp(newPrice, 10000 * GWEI);\r\n    }\r\n\r\n    function getPrice(uint256 badgeID_) public view returns(uint256){\r\n        return badges[badgeID_].price;\r\n    }\r\n\r\n    function _increaseTotalDivis(uint256 badgeID_, uint256 divis_) internal{\r\n        badges[badgeID_].totalDivis += divis_;\r\n    }\r\n\r\n    function getTotalDivis(uint256 badgeID_) public view returns(uint256){\r\n        return badges[badgeID_].totalDivis;\r\n    }\r\n\r\n    function getChainLength() public view returns(uint256){\r\n        return badges.length;\r\n    }\r\n\r\n    /*===============================================================================\r\n    =                       FUNCTIONS                       FUNCTIONS               =\r\n    ===============================================================================*/\r\n    /*==============================\r\n    =           OWNER ONLY         =\r\n    ==============================*/\r\n    constructor(address admin_, address teamAmberAddress_) public{\r\n    \t_contractOwner = msg.sender;\r\n        _admin = admin_;\r\n        _teamAmber = TeamAmberInterface(teamAmberAddress_);\r\n    }\r\n\r\n    function initGame(address badgesFactoryAddress_, address[] owner_, uint256[] price_, uint256[] totalDivis_) external onlyContractOwner{\r\n        require(_startTime == 0);\r\n        assert(owner_.length == price_.length && price_.length == totalDivis_.length);\r\n\r\n        if(_badgeFactory == address(0x0)){\r\n            _badgeFactory = BadgeFactoryInterface(badgesFactoryAddress_);\r\n        }\r\n        _initBadges(owner_, price_, totalDivis_);\r\n    }\r\n\r\n    function initReferrals(address[] refArray_) external onlyContractOwner{\r\n        require(_startTime == 0);\r\n        for (uint256 i = 0; i < refArray_.length; i+=2) {\r\n            _refererUpdate(refArray_[i], refArray_[i+1]);\r\n        }\r\n    }\r\n\r\n    function _startContract(uint256 delay_) external onlyContractOwner{\r\n    \trequire(_startTime == 0);\r\n        _startTime = now + delay_;\r\n\r\n        emit onContractStart(_startTime);\r\n    }\r\n\r\n    /*==============================\r\n    =             BUY              =\r\n    ==============================*/\r\n    //Hex Data: 0x7deb6025\r\n    function buy(uint256 badgeID_, address newReferer_) public payable isNotAContract isRunning{\r\n    \t_refererUpdate(msg.sender, newReferer_);\r\n    \t_buy(badgeID_, newReferer_, msg.sender, msg.value);\r\n    }\r\n\r\n    function _buy(uint256 badgeID_, address newReferer_, address msgSender_, uint256 msgValue_) internal{\r\n        address previousOwner = getOwner(badgeID_);\r\n        require(isNotSelf(msgSender_, getOwner(badgeID_)), 'You can not buy from yourself.');\r\n        require(isValidBuy(getPrice(badgeID_), msgValue_), 'It is not a valid buy.');        \r\n\r\n        _diviSplit(badgeID_, previousOwner, msgSender_, msgValue_);\r\n        _extendBadges(badgeID_, msgSender_, _badgeBasePrice);\r\n        _badgeOwnerChange(badgeID_, msgSender_);\r\n        _increasePrice(badgeID_);\r\n\r\n        emit onBadgeBuy(badgeID_, previousOwner, msgSender_, newReferer_, msgValue_, getPrice(badgeID_));\r\n    }\r\n\r\n    function _refererUpdate(address user_, address newReferer_) internal{\r\n    \tif (refererAllowed(user_, _referer[user_], newReferer_)){\r\n    \t\t_referer[user_] = newReferer_;\r\n    \t\temit onRefererSet(user_, newReferer_);\r\n    \t}\r\n    }\r\n\r\n    /*==============================\r\n    =         BADGE SYSTEM         =\r\n    ==============================*/\r\n    function _extendBadges(uint256 badgeID_, address owner_, uint256 price_) internal{\r\n        if (isLastBadgeEle(badgeID_, getChainLength())){\r\n            _createNewBadge(owner_, price_);\r\n        }\r\n    }\r\n\r\n    function _badgeOwnerChange(uint256 badgeID_, address newOwner_) internal{\r\n        _setOwner(badgeID_, newOwner_);\r\n    }\r\n\r\n    /*==============================\r\n    =          DIVI SPLIT          =\r\n    ==============================*/\r\n    function _diviSplit(uint256 badgeID_, address previousOwner_, address msgSender_, uint256 msgValue_) internal{\r\n    \t_shareToDistribution(badgeID_, msgValue_, _shareDistributionRatio);\r\n        _shareToPreviousOwner(previousOwner_, msgValue_, _sharePreviousOwnerRatio);\r\n    \t_shareToReferer(_referer[msgSender_], msgValue_, _shareReferalRatio);\r\n    }\r\n\r\n    function _shareToDistribution(uint256 badgeID_, uint256 msgValue_, uint256 ratio_) internal{\r\n        uint256 share = calcShare(msgValue_, ratio_) / _luckyWinners;\r\n        uint256 idx;\r\n\r\n        for(uint256 i = 0; i < _luckyWinners; i++){\r\n            idx = _badgeFactory.getRandomBadge(badgeID_, i);\r\n            _increaseTotalDivis(idx, share);\r\n            _splitProfit[getOwner(idx)] += share;\r\n        }\r\n    }\r\n\r\n    function _shareToPreviousOwner(address previousOwner_, uint256 msgValue_, uint256 ratio_) internal{\r\n    \t_flipProfit[previousOwner_] += calcShare(msgValue_, ratio_);\r\n    }\r\n\r\n    function _shareToReferer(address referer_, uint256 msgValue_, uint256 ratio_) internal{\r\n    \tif (addressNotSet(referer_)){\r\n    \t\t_waypointProfit[_admin] += calcShare(msgValue_, ratio_);\r\n    \t} else {\r\n    \t\t_waypointProfit[referer_] += calcShare(msgValue_, ratio_);\r\n    \t}\r\n    }\r\n\r\n    /*==============================\r\n    =           WITHDRAW           =\r\n    ==============================*/\r\n    //Hex Data: 0x853828b6\r\n    function withdrawAll() public isNotAContract{\r\n        uint256 splitProfit = _splitProfit[msg.sender];\r\n        _splitProfit[msg.sender] = 0;\r\n\r\n        uint256 flipProfit = _flipProfit[msg.sender];\r\n        _flipProfit[msg.sender] = 0;\r\n\r\n        uint256 waypointProfit = _waypointProfit[msg.sender];\r\n        _waypointProfit[msg.sender] = 0;\r\n\r\n        _transferDivis(msg.sender, splitProfit + flipProfit + waypointProfit);\r\n        emit onWithdraw(msg.sender, splitProfit, flipProfit, waypointProfit);\r\n    }\r\n\r\n    function _transferDivis(address msgSender_, uint256 payout_) internal{\r\n        assert(address(this).balance >= payout_);\r\n        if(msgSender_ == _admin){\r\n            _teamAmber.distribute.value(payout_)();\r\n        } else {\r\n            msgSender_.transfer(payout_);       \r\n        }\r\n    }\r\n\r\n    /*==============================\r\n    =            HELPERS           =\r\n    ==============================*/\r\n    function getStartTime() public view returns (uint256){\r\n        return _startTime;\r\n    }\r\n\r\n    function getSplitProfit(address user_) public view returns(uint256){\r\n        return _splitProfit[user_];\r\n    }\r\n\r\n    function getFlipProfit(address user_) public view returns(uint256){\r\n        return _flipProfit[user_];\r\n    }\r\n\r\n    function getWaypointProfit(address user_) public view returns(uint256){\r\n        return _waypointProfit[user_];\r\n    }\r\n\r\n    function getReferer(address user_) public view returns(address){\r\n    \treturn _referer[user_];\r\n    }\r\n\r\n    function getBalanceContract() public view returns(uint256){\r\n    \treturn address(this).balance;\r\n    }\r\n\r\n    function getAllBadges() public view returns(address[], uint256[], uint256[]){\r\n        uint256 chainLength = getChainLength();\r\n        return (getBadges(0, chainLength-1));\r\n    }\r\n\r\n    function getBadges(uint256 _from, uint256 _to) public view returns(address[], uint256[], uint256[]){\r\n        require(_from <= _to, 'Index FROM needs to be smaller or same than index TO');\r\n\r\n        address[] memory owner = new address[](_to - _from + 1);\r\n        uint256[] memory price = new uint256[](_to - _from + 1);\r\n        uint256[] memory totalDivis = new uint256[](_to - _from + 1);\r\n\r\n        for (uint256 i = _from; i <= _to; i++) {\r\n            owner[i - _from] = getOwner(i);\r\n            price[i - _from] = getPrice(i);\r\n            totalDivis[i - _from] = getTotalDivis(i);\r\n        }\r\n        return (owner, price, totalDivis);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"refArray_\",\"type\":\"address[]\"}],\"name\":\"initReferrals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"badgesFactoryAddress_\",\"type\":\"address\"},{\"name\":\"owner_\",\"type\":\"address[]\"},{\"name\":\"price_\",\"type\":\"uint256[]\"},{\"name\":\"totalDivis_\",\"type\":\"uint256[]\"}],\"name\":\"initGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getWaypointProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"addressNotSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"msgSender_\",\"type\":\"address\"},{\"name\":\"currentReferer_\",\"type\":\"address\"},{\"name\":\"newReferer_\",\"type\":\"address\"}],\"name\":\"refererAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"isAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getReferer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"msgSender_\",\"type\":\"address\"},{\"name\":\"compare_\",\"type\":\"address\"}],\"name\":\"isNotSelf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"badgeID_\",\"type\":\"uint256\"}],\"name\":\"getTotalDivis\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"badgeID_\",\"type\":\"uint256\"},{\"name\":\"newReferer_\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"badgeID_\",\"type\":\"uint256\"}],\"name\":\"isFirstBadgeEle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChainLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"msgValue_\",\"type\":\"uint256\"},{\"name\":\"ratio_\",\"type\":\"uint256\"}],\"name\":\"calcShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getBadges\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getFlipProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price_\",\"type\":\"uint256\"},{\"name\":\"msgValue_\",\"type\":\"uint256\"}],\"name\":\"isValidBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"badgeID_\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"badgeID_\",\"type\":\"uint256\"},{\"name\":\"badgeLength_\",\"type\":\"uint256\"}],\"name\":\"isLastBadgeEle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllBadges\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getSplitProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"badgeID_\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delay_\",\"type\":\"uint256\"}],\"name\":\"_startContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"},{\"name\":\"teamAmberAddress_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime_\",\"type\":\"uint256\"}],\"name\":\"onContractStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user_\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referer_\",\"type\":\"address\"}],\"name\":\"onRefererSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"badgeID_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"previousOwner_\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer_\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referer_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice_\",\"type\":\"uint256\"}],\"name\":\"onBadgeBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"splitProfit_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"flipProfit_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"waypointProfit_\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"}]","ContractName":"Amber","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ae5ac19f938f8338920e630cc9a8ecd6ce89bca10000000000000000000000001ce75bfd524489e7dd8678d4905cbd8f47f22083","Library":"SafeMathExt:B8E61C88B3CE99b80389B8913c03c13418F03A14","SwarmSource":"bzzr://781f840e5e835740d50a06910cd06ba9ee6285cc5d98915e787b8fd031cf857a"}]}