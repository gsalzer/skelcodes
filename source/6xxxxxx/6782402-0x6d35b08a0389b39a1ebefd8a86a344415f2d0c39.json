{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* \r\n* Web              - https://333eth.io\r\n* \r\n* Twitter          - https://twitter.com/333eth_io\r\n* \r\n* Telegram_channel - https://t.me/Ethereum333\r\n* \r\n* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\r\n* \r\n* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\r\n* \r\n* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\r\n* \r\n* Email:             mailto:support(at sign)333eth.io\r\n*/\r\n\r\n\r\n\r\nlibrary RecipientsStorage {\r\n  struct Storage {\r\n    mapping(address => Recipient) data;\r\n    KeyFlag[] keys;\r\n    uint size;\r\n  }\r\n\r\n  struct Recipient { \r\n    uint keyIndex;\r\n    Percent.percent percent;\r\n    bool isLocked;\r\n  }\r\n\r\n  struct KeyFlag { \r\n    address key; \r\n    bool deleted;\r\n  }\r\n\r\n  function init(Storage storage s) internal {\r\n    s.keys.length++;\r\n  }\r\n\r\n  function insert(Storage storage s, address key, Percent.percent memory percent, bool isLocked) internal returns (bool) {\r\n    if (s.data[key].isLocked) {\r\n      return false;\r\n    }\r\n\r\n    uint keyIndex = s.data[key].keyIndex;\r\n    s.data[key].percent = percent;\r\n    s.data[key].isLocked = isLocked;\r\n    if (keyIndex > 0) {\r\n      return true;\r\n    }\r\n    keyIndex = s.keys.length++;\r\n    s.data[key].keyIndex = keyIndex;\r\n    s.keys[keyIndex].key = key;\r\n    s.size++;\r\n    return true;\r\n  }\r\n\r\n  function remove(Storage storage s, address key) internal returns (bool) {\r\n    if (s.data[key].isLocked) {\r\n      return false;\r\n    }\r\n\r\n    uint keyIndex = s.data[key].keyIndex;\r\n    if (keyIndex == 0) {\r\n      return false;\r\n    }\r\n      \r\n    delete s.data[key];\r\n    s.keys[keyIndex].deleted = true;\r\n    s.size--;\r\n  }\r\n\r\n  function unlock(Storage storage s, address key) internal returns (bool) {\r\n    if (s.data[key].keyIndex == 0) {\r\n      return false;\r\n    }\r\n    s.data[key].isLocked = false;\r\n    return true;\r\n  }\r\n  \r\n\r\n  function recipient(Storage storage s, address key) internal view returns (Recipient memory r) {\r\n    return Recipient(s.data[key].keyIndex, s.data[key].percent, s.data[key].isLocked);\r\n  }\r\n\r\n  function iterStart(Storage storage s) internal view returns (uint keyIndex) {\r\n    return iterNext(s, 0);\r\n  }\r\n\r\n  function iterValid(Storage storage s, uint keyIndex) internal view returns (bool) {\r\n    return keyIndex < s.keys.length;\r\n  }\r\n\r\n  function iterNext(Storage storage s, uint keyIndex) internal view returns (uint r_keyIndex) {\r\n    r_keyIndex = keyIndex + 1;\r\n    while (r_keyIndex < s.keys.length && s.keys[r_keyIndex].deleted) {\r\n      r_keyIndex++;\r\n    }\r\n  }\r\n\r\n  function iterGet(Storage storage s, uint keyIndex) internal view returns (address key, Recipient memory r) {\r\n    key = s.keys[keyIndex].key;\r\n    r = Recipient(s.data[key].keyIndex, s.data[key].percent, s.data[key].isLocked);\r\n  }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n  enum AccessRank { None, Payout, Full }\r\n  mapping(address => AccessRank) internal m_admins;\r\n  modifier onlyAdmin(AccessRank  r) {\r\n    require(\r\n      m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full,\r\n      \"access denied\"\r\n    );\r\n    _;\r\n  }\r\n  event LogProvideAccess(address indexed whom, uint when,  AccessRank rank);\r\n\r\n  constructor() public {\r\n    m_admins[msg.sender] = AccessRank.Full;\r\n    emit LogProvideAccess(msg.sender, now, AccessRank.Full);\r\n  }\r\n  \r\n  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Full) {\r\n    require(m_admins[addr] != AccessRank.Full, \"cannot change full access rank\");\r\n    if (m_admins[addr] != rank) {\r\n      m_admins[addr] = rank;\r\n      emit LogProvideAccess(addr, now, rank);\r\n    }\r\n  }\r\n\r\n  function access(address addr) public view returns(AccessRank rank) {\r\n    rank = m_admins[addr];\r\n  }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  // storage operations\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) return 0; // solium-disable-line lbrace\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n\r\n  // memory operations\r\n  function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function msub(percent memory p, uint a) internal pure returns (uint) {\r\n    uint b = mmul(p, a);\r\n    if (b >= a) return 0; // solium-disable-line lbrace\r\n    return a - b;\r\n  }\r\n\r\n  function madd(percent memory p, uint a) internal pure returns (uint) {\r\n    return a + mmul(p, a);\r\n  }\r\n}\r\n\r\n\r\ncontract Distributor is Accessibility {\r\n  using Percent for Percent.percent;\r\n  using RecipientsStorage for RecipientsStorage.Storage;\r\n  RecipientsStorage.Storage private m_recipients;\r\n\r\n  uint public startupAO;\r\n  uint public payPaymentTime;\r\n  uint public payKeyIndex;\r\n  uint public payValue;\r\n\r\n  event LogPayDividends(address indexed addr, uint when, uint value);\r\n\r\n  constructor() public {\r\n    m_recipients.init();\r\n    payKeyIndex = m_recipients.iterStart();\r\n  }\r\n\r\n  function() external payable {}\r\n\r\n\r\n  function payoutIsDone() public view returns(bool done) {\r\n    return payKeyIndex == m_recipients.iterStart();\r\n  }\r\n\r\n  function initAO(address AO) public onlyAdmin(AccessRank.Full) {\r\n    require(startupAO == 0, \"cannot reinit\");\r\n    Percent.percent memory r = Percent.percent(74, 100); // 1% for payout bot\r\n    bool isLocked = true;\r\n    startupAO = now;\r\n    m_recipients.insert(AO, r, isLocked);\r\n  }\r\n\r\n  function unlockAO(address AO) public onlyAdmin(AccessRank.Full) {\r\n    require(startupAO > 0, \"cannot unlock zero AO\");\r\n    require((startupAO + 3 * 365 days) <= now, \"cannot unlock if 3 years not pass\");\r\n    m_recipients.unlock(AO);\r\n  }\r\n\r\n  function recipient(address addr) public view returns(uint numerator, uint denominator, bool isLocked) {\r\n    RecipientsStorage.Recipient memory r = m_recipients.recipient(addr);\r\n    return (r.percent.num, r.percent.den, r.isLocked);\r\n  }\r\n\r\n  function recipientsSize() public view returns(uint size) {\r\n    return m_recipients.size;\r\n  }\r\n\r\n  function recipients() public view returns(address[] memory addrs, uint[] memory nums, uint[] memory dens, bool[] memory isLockeds) {\r\n    addrs = new address[](m_recipients.size);\r\n    nums = new uint[](m_recipients.size);\r\n    dens = new uint[](m_recipients.size);\r\n    isLockeds = new bool[](m_recipients.size);\r\n    RecipientsStorage.Recipient memory r;\r\n    uint i = m_recipients.iterStart();\r\n    uint c;\r\n\r\n    for (i; m_recipients.iterValid(i); i = m_recipients.iterNext(i)) {\r\n      (addrs[c], r) = m_recipients.iterGet(i);\r\n      nums[c] = r.percent.num;\r\n      dens[c] = r.percent.den;\r\n      isLockeds[c] = r.isLocked;\r\n      c++;\r\n    }\r\n  }\r\n\r\n  function insertRecipients(address[] memory addrs, uint[] memory nums, uint[] memory dens) public onlyAdmin(AccessRank.Full) {\r\n    require(addrs.length == nums.length && nums.length == dens.length, \"invalid arguments length\");\r\n    bool isLocked = false;\r\n    for (uint i; i < addrs.length; i++) {\r\n      if (addrs[i] == address(0x0) || dens[i] == 0) {\r\n        continue;\r\n      }\r\n      m_recipients.insert(addrs[i], Percent.percent(nums[i], dens[i]), isLocked);\r\n    }\r\n  }\r\n\r\n  function removeRecipients(address[] memory addrs) public onlyAdmin(AccessRank.Full) {\r\n    for (uint i; i < addrs.length; i++) {\r\n      m_recipients.remove(addrs[i]);\r\n    }\r\n  }\r\n\r\n  function payout() public onlyAdmin(AccessRank.Payout) { \r\n    if (payKeyIndex == m_recipients.iterStart()) {\r\n      require(address(this).balance > 0, \"zero balance\");\r\n      require(now>payPaymentTime+12 hours, \"the latest payment was earlier than 12 hours\");\r\n      payPaymentTime = now;\r\n      payValue = address(this).balance;\r\n    }\r\n    \r\n    uint i = payKeyIndex;\r\n    uint dividends;\r\n    RecipientsStorage.Recipient memory r;\r\n    address rAddr;\r\n\r\n    for (i; m_recipients.iterValid(i) && gasleft() > 60000; i = m_recipients.iterNext(i)) {\r\n      (rAddr, r) = m_recipients.iterGet(i);\r\n      dividends = r.percent.mmul(payValue);\r\n      if (rAddr.send(dividends)) {\r\n        emit LogPayDividends(rAddr, now, dividends); \r\n      }\r\n    }\r\n\r\n    if (m_recipients.iterValid(i)) {\r\n      payKeyIndex = i;\r\n    } else {\r\n      payKeyIndex = m_recipients.iterStart();\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"recipients\",\"outputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"nums\",\"type\":\"uint256[]\"},{\"name\":\"dens\",\"type\":\"uint256[]\"},{\"name\":\"isLockeds\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"nums\",\"type\":\"uint256[]\"},{\"name\":\"dens\",\"type\":\"uint256[]\"}],\"name\":\"insertRecipients\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"AO\",\"type\":\"address\"}],\"name\":\"initAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeRecipients\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"access\",\"outputs\":[{\"name\":\"rank\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payKeyIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startupAO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"recipient\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"},{\"name\":\"isLocked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payPaymentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"provideAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"AO\",\"type\":\"address\"}],\"name\":\"unlockAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recipientsSize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutIsDone\",\"outputs\":[{\"name\":\"done\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"LogProvideAccess\",\"type\":\"event\"}]","ContractName":"Distributor","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://136911fb2994546cf8184e8a5a5106313102d0dcb824185e6b4c5bb453f1ff2e"}]}