{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/*\r\n *  GLOBAL  INVEST FUND PROJECT 130+\r\n * Web:         http://Globalinvest.fund \r\n * Twitter:     https://twitter.com/InvestFund_twit?lang=ru \r\n * Telegram:    https://telegram.me/GIFund_Chat\r\n * Iinstagram:  https://www.instagram.com/globalinvestfund/\r\n * Email:       globalblockchainfund@gmail.com  \r\n * \r\n * \r\n *  About the Project\r\n * Blockchain-enabled smart contracts have opened a new era of trustless relationships without   intermediaries. \r\n * This technology opens incredible financial possibilities. \r\n * Our automated investment  distribution model is written into a smart contract, uploaded to the Ethereum    blockchain and can be  freely accessed online.\r\n * In order to insure our investors' complete security, full control over the  project has been transferred from the organizers to the smart contract: nobody can influence the  system's permanent autonomous functioning.\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function toAddress(bytes source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source,0x14)) }\r\n        return addr;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor() internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract GlobalInvestFund130Plus is ReentrancyGuard {\r\n\r\n    using SafeMath for uint;\r\n    using Address for *;\r\n\r\n    address public marketingAddress;\r\n    address public techSupportAddress;\r\n    uint public creationDate;\r\n    uint constant twoWeeks = 14 days;\r\n    uint constant oneDay = 1 days;\r\n    uint constant minInvestment = 100000000000000000 wei;\r\n    uint constant maxInvestment = 100 ether;\r\n\r\n    struct Investor {\r\n        uint fullInvestment;\r\n        uint[] eachInvestmentValues;\r\n        mapping (uint => uint) timestampsForInvestments;\r\n        bool isInvestor;\r\n        bool isLast;\r\n        bool emergencyAvailable;\r\n        bool withdrawn;\r\n    }\r\n\r\n    address[] public allInvestors;\r\n    mapping (address => Investor) investors;\r\n    mapping (address => uint) public sendedDividends;\r\n    mapping (address => uint) public refferalDividends;\r\n    mapping (address => uint[]) doublePercentsEnd;\r\n    mapping (address => uint) lastWithdraw;\r\n\r\n    event Invest(address _address, uint _value);\r\n    event Withdraw(address _address, uint _value);\r\n\r\n    modifier onlyInRangeDeposit() {\r\n        require(msg.value >= minInvestment && msg.value <= maxInvestment);\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestor() {\r\n        require(investors[msg.sender].isInvestor && investors[msg.sender].fullInvestment > 0);\r\n        _;\r\n    }\r\n\r\n    function() external payable {\r\n        if(msg.value >= minInvestment && msg.value <= maxInvestment){\r\n            deposit(msg.data.toAddress());\r\n        } else {\r\n            if(msg.value == 112000000000000){\r\n                emergencyWithdraw();\r\n            } else {\r\n                if(msg.value == 0){\r\n                    withdraw();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(address _marketingAddress, address _techSupportAddress) public {\r\n        creationDate = block.timestamp;\r\n        marketingAddress = _marketingAddress;\r\n        techSupportAddress = _techSupportAddress;\r\n    }\r\n\r\n    function getDepositAmountFor(address _addr) public view returns(uint){\r\n        return investors[_addr].fullInvestment;\r\n    }\r\n\r\n    function calculatePercentsFor(address _addr) external view returns(uint){\r\n        return calculatePercents(_addr);\r\n    }\r\n    \r\n    function getInvestorsAmount() external view returns(uint){\r\n        return allInvestors.length;\r\n    }\r\n\r\n    function deposit(address _refferal) public payable onlyInRangeDeposit {\r\n\r\n        uint investmentValue = msg.value;\r\n\r\n        investmentValue = investmentValue.sub(msg.value.mul(2).div(100));\r\n        techSupportAddress.transfer(msg.value.mul(2).div(100));\r\n\r\n        investmentValue = investmentValue.sub(msg.value.mul(5).div(100));\r\n        marketingAddress.transfer(msg.value.mul(5).div(100));\r\n\r\n        // if refferal address is not investor or if it's myself, fine\r\n        if(!investors[_refferal].isInvestor || _refferal == msg.sender){\r\n            marketingAddress.transfer(msg.value.mul(2).div(100));\r\n            investmentValue = investmentValue.sub(msg.value.mul(2).div(100));\r\n        } else {\r\n            _refferal.transfer(msg.value.mul(2).div(100));\r\n            refferalDividends[_refferal] = refferalDividends[_refferal].add(msg.value.mul(2).div(100));\r\n            investmentValue = investmentValue.sub(msg.value.mul(2).div(100));\r\n        }\r\n\r\n        // if first investment or investment after emergenct withdraw\r\n        if(!investors[msg.sender].isInvestor){\r\n            allInvestors.push(msg.sender);\r\n            investors[msg.sender].isInvestor = true;\r\n            investors[msg.sender].isLast = true;\r\n            if(allInvestors.length > 3) {\r\n                doublePercentsEnd[allInvestors[allInvestors.length.sub(4)]].push(block.timestamp);\r\n                investors[allInvestors[allInvestors.length.sub(4)]].isLast = false;\r\n            }\r\n        }\r\n\r\n        investors[msg.sender].emergencyAvailable = true;\r\n        investors[msg.sender].fullInvestment = investors[msg.sender].fullInvestment.add(investmentValue);\r\n        investors[msg.sender].timestampsForInvestments[investors[msg.sender].eachInvestmentValues.length] = block.timestamp;\r\n        investors[msg.sender].eachInvestmentValues.push(investmentValue);\r\n\r\n        // if investor is not one of the 3 last investors\r\n        if(!investors[msg.sender].isLast){\r\n            allInvestors.push(msg.sender);\r\n            investors[msg.sender].isLast = true;\r\n            if(allInvestors.length > 3) {\r\n                doublePercentsEnd[allInvestors[allInvestors.length.sub(4)]].push(block.timestamp);\r\n                investors[allInvestors[allInvestors.length.sub(4)]].isLast = false;\r\n            }\r\n        }\r\n\r\n        emit Invest(msg.sender, investmentValue);\r\n    }\r\n\r\n    function withdraw() public nonReentrant onlyInvestor {\r\n        require(creationDate.add(twoWeeks)<=block.timestamp);\r\n        require(lastWithdraw[msg.sender].add(3 days) <= block.timestamp);\r\n        require(address(this).balance > 0);\r\n\r\n        uint fullDividends;\r\n        uint marketingFee;\r\n\r\n        investors[msg.sender].emergencyAvailable = false;\r\n        address receiver = msg.sender;\r\n\r\n        fullDividends = calculatePercents(msg.sender);\r\n        fullDividends = fullDividends.sub(sendedDividends[receiver]);\r\n\r\n        if(fullDividends < investors[msg.sender].fullInvestment.mul(130).div(100)){\r\n            marketingFee = fullDividends.mul(5).div(100);\r\n            marketingAddress.transfer(marketingFee);\r\n        }\r\n\r\n        lastWithdraw[msg.sender] = block.timestamp;\r\n        \r\n        if(address(this).balance >= fullDividends.sub(marketingFee)) {\r\n            receiver.transfer(fullDividends.sub(marketingFee));\r\n        } else{\r\n            receiver.transfer(address(this).balance);\r\n        }\r\n\r\n        sendedDividends[receiver] = sendedDividends[receiver].add(fullDividends);\r\n        investors[receiver].withdrawn = true;\r\n\r\n\r\n        emit Withdraw(receiver, fullDividends);\r\n    }\r\n\r\n    function calculatePercents(address _for) internal view returns(uint){\r\n        uint dividends;\r\n        uint fullDividends;\r\n        uint count = 0;\r\n        for(uint i = 1; i <= investors[_for].eachInvestmentValues.length; i++) {\r\n            if(i == investors[_for].eachInvestmentValues.length){\r\n                if(doublePercentsEnd[_for].length > count && doublePercentsEnd[_for][count] < block.timestamp){\r\n                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], block.timestamp, investors[_for].eachInvestmentValues[i.sub(1)], doublePercentsEnd[_for][count++]);\r\n                }\r\n                else{\r\n                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], block.timestamp, investors[_for].eachInvestmentValues[i.sub(1)], 0);\r\n                }\r\n\r\n            } else {\r\n                if(doublePercentsEnd[_for].length > count && doublePercentsEnd[_for][count] < investors[_for].timestampsForInvestments[i]){\r\n                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], investors[_for].timestampsForInvestments[i], investors[_for].eachInvestmentValues[i.sub(1)], doublePercentsEnd[_for][count++]);\r\n                }\r\n                else {\r\n                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], investors[_for].timestampsForInvestments[i], investors[_for].eachInvestmentValues[i.sub(1)], 0);\r\n                }\r\n\r\n            }\r\n            fullDividends = fullDividends.add(dividends);\r\n        }\r\n        return fullDividends;\r\n    }\r\n\r\n    function getDividendsForOnePeriod(uint _startTime, uint _endTime, uint _investmentValue, uint _doublePercentsEnd) internal view returns(uint) {\r\n        uint fullDaysForDividents = _endTime.sub(_startTime).div(oneDay);\r\n        uint maxDividends = investors[msg.sender].fullInvestment.mul(130).div(100);\r\n        uint maxDaysWithFullDividends = maxDividends.div(_investmentValue.mul(35).div(1000));\r\n        uint maxDaysWithDoubleDividends = maxDividends.div(_investmentValue.mul(7).div(100));\r\n        uint daysWithDoublePercents;\r\n\r\n        if(_doublePercentsEnd != 0){\r\n            daysWithDoublePercents = _doublePercentsEnd.sub(_startTime).div(oneDay);\r\n        } else {\r\n            daysWithDoublePercents = fullDaysForDividents;\r\n        }\r\n\r\n        uint dividends;\r\n\r\n        if(daysWithDoublePercents > maxDaysWithDoubleDividends && !investors[msg.sender].withdrawn){\r\n            dividends = _investmentValue.mul(7).div(100).mul(maxDaysWithDoubleDividends);\r\n            dividends = dividends.add(_investmentValue.div(100).mul(daysWithDoublePercents.sub(maxDaysWithDoubleDividends)));\r\n            return dividends;\r\n        } else {\r\n            if(daysWithDoublePercents > maxDaysWithDoubleDividends){\r\n                dividends = _investmentValue.mul(7).div(100).mul(maxDaysWithDoubleDividends);\r\n            } else {\r\n                dividends = _investmentValue.mul(7).div(100).mul(daysWithDoublePercents);\r\n            }\r\n            if(fullDaysForDividents != daysWithDoublePercents){\r\n                fullDaysForDividents = fullDaysForDividents.sub(daysWithDoublePercents);\r\n            } else {\r\n                return dividends;\r\n            }\r\n\r\n            maxDividends = maxDividends.sub(dividends);\r\n            maxDaysWithFullDividends = maxDividends.div(_investmentValue.mul(35).div(1000));\r\n\r\n            if(fullDaysForDividents > maxDaysWithFullDividends && !investors[msg.sender].withdrawn){\r\n                dividends = dividends.add(_investmentValue.mul(35).div(1000).mul(maxDaysWithFullDividends));\r\n                dividends = dividends.add(_investmentValue.mul(5).div(1000).mul(fullDaysForDividents.sub(maxDaysWithFullDividends)));\r\n                return dividends;\r\n            } else {\r\n                dividends = dividends.add(_investmentValue.mul(35).div(1000).mul(fullDaysForDividents));\r\n                return dividends;\r\n            }\r\n        }\r\n    }\r\n\r\n    function emergencyWithdraw() public payable nonReentrant onlyInvestor {\r\n        require(investors[msg.sender].emergencyAvailable == true);\r\n\r\n        // send 35% of full investment from this address to the tech support address\r\n        techSupportAddress.transfer(investors[msg.sender].fullInvestment.mul(35).div(100));\r\n\r\n        uint returnValue = investors[msg.sender].fullInvestment.sub(investors[msg.sender].fullInvestment.mul(35).div(100));\r\n\r\n        investors[msg.sender].fullInvestment = 0;\r\n        investors[msg.sender].isInvestor = false;\r\n\r\n        if(address(this).balance >= returnValue) {\r\n            // return remaining investments to the investor\r\n            msg.sender.transfer(returnValue);\r\n        } else {\r\n            // if eth is not enough on the contract return remaining eth of the contract to the investor\r\n            msg.sender.transfer(address(this).balance);\r\n        }\r\n\r\n\r\n        for(uint c = 0; c < investors[msg.sender].eachInvestmentValues.length; c++){\r\n            investors[msg.sender].eachInvestmentValues[c] = 0;\r\n        }\r\n\r\n        if(investors[msg.sender].isLast == true){\r\n            //DELETE from last investors\r\n            investors[msg.sender].isLast = false;\r\n            if(allInvestors.length > 3){\r\n                for(uint i = allInvestors.length.sub(1); i > allInvestors.length.sub(4); i--){\r\n                    if(allInvestors[i] == msg.sender){\r\n                        allInvestors[i] = address(0);\r\n                    }\r\n                }\r\n            } else {\r\n                for(uint y = 0; y < allInvestors.length.sub(1); y++){\r\n                    if(allInvestors[y] == msg.sender){\r\n                        allInvestors[y] = address(0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creationDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sendedDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"techSupportAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calculatePercentsFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorsAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getDepositAmountFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refferalDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refferal\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_marketingAddress\",\"type\":\"address\"},{\"name\":\"_techSupportAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"GlobalInvestFund130Plus","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000038e5b3e6550fee44c66b891bbab73977a897c1a3000000000000000000000000251cc2b71c27462c5376e26cb52828c5b1f92fc0","Library":"","SwarmSource":"bzzr://94470e3a3cea35c782c475975bc5149dd52ded03a8d9f5b8a8cf2bf43489e643"}]}