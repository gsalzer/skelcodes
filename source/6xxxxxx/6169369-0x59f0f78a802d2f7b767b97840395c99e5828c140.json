{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright (C) 2017-2018 Hashfuture Inc. All rights reserved.\r\n */\r\n\r\npragma solidity ^0.4.22;\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n    \r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n    \r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n    \r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n    \r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n    \r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n    \r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\ncontract owned {\r\n    address public holder;\r\n\r\n    constructor() public {\r\n        holder = msg.sender;\r\n    }\r\n\r\n    modifier onlyHolder {\r\n        require(msg.sender == holder, \"This func only can be calle by holder\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract asset is owned {\r\n    using strings for *;\r\n    /*Asset Struct*/\r\n    struct data {\r\n        //link URL of the original information for storing data\r\n        //     null means undisclosed\r\n        string link;\r\n        //The encryption method of the original data, such as SHA-256\r\n        string encryptionType;\r\n        //Hash value\r\n        string hashValue;\r\n    }\r\n\r\n    data[] dataArray;\r\n    uint dataNum;\r\n\r\n    //The validity of the contract\r\n    bool public isValid;\r\n    \r\n    //The init status\r\n    bool public isInit;\r\n    \r\n    //The tradeable status of asset\r\n    bool public isTradeable;\r\n    uint public price;\r\n\r\n    //Some notes\r\n    string public remark1;\r\n\r\n    //Other notes, holder can be written\r\n    //Reservations for validation functions\r\n    string public remark2;\r\n\r\n    /** constructor */\r\n    constructor() public {\r\n        isValid = true;\r\n        isInit = false;\r\n        isTradeable = false;\r\n        price = 0;\r\n        dataNum = 0;\r\n    }\r\n\r\n    /**\r\n     * Initialize a new asset\r\n     * @param dataNumber The number of data array\r\n     * @param linkSet The set of URL of the original information for storing data, if null means undisclosed\r\n     *          needle is \" \"\r\n     * @param encryptionTypeSet The set of encryption method of the original data, such as SHA-256\r\n     *          needle is \" \"\r\n     * @param hashValueSet The set of hashvalue\r\n     *          needle is \" \"\r\n     */\r\n    function initAsset(\r\n        uint dataNumber,\r\n        string linkSet,\r\n        string encryptionTypeSet,\r\n        string hashValueSet) public onlyHolder {\r\n        // split string to array\r\n        var links = linkSet.toSlice();\r\n        var encryptionTypes = encryptionTypeSet.toSlice();\r\n        var hashValues = hashValueSet.toSlice();\r\n        var delim = \" \".toSlice();\r\n        \r\n        dataNum = dataNumber;\r\n        \r\n        // after init, the initAsset function cannot be called\r\n        require(isInit == false, \"The contract has been initialized\");\r\n\r\n        //check data\r\n        require(dataNumber >= 1, \"The dataNumber should bigger than 1\");\r\n        require(dataNumber - 1 == links.count(delim), \"The uumber of linkSet error\");\r\n        require(dataNumber - 1 == encryptionTypes.count(delim), \"The uumber of encryptionTypeSet error\");\r\n        require(dataNumber - 1 == hashValues.count(delim), \"The uumber of hashValues error\");\r\n        \r\n        isInit = true;\r\n        \r\n        var empty = \"\".toSlice();\r\n        \r\n        for (uint i = 0; i < dataNumber; i++) {\r\n            var link = links.split(delim);\r\n            var encryptionType = encryptionTypes.split(delim);\r\n            var hashValue = hashValues.split(delim);\r\n            \r\n            //require data not null\r\n            // link can be empty\r\n            require(!encryptionType.empty(), \"The encryptionTypeSet data error\");\r\n            require(!hashValue.empty(), \"The hashValues data error\");\r\n            \r\n            dataArray.push(\r\n                data(link.toString(), encryptionType.toString(), hashValue.toString())\r\n                );\r\n        }\r\n    }\r\n    \r\n     /**\r\n     * Get base asset info\r\n     */\r\n    function getAssetBaseInfo() public view returns (uint _price,\r\n                                                 bool _isTradeable,\r\n                                                 uint _dataNum,\r\n                                                 string _remark1,\r\n                                                 string _remark2) {\r\n        require(isValid == true, \"contract is invaild\");\r\n        _price = price;\r\n        _isTradeable = isTradeable;\r\n        _dataNum = dataNum;\r\n        _remark1 = remark1;\r\n        _remark2 = remark2;\r\n    }\r\n    \r\n    /**\r\n     * Get data info by index\r\n     * @param index index of dataArray\r\n     */\r\n    function getDataByIndex(uint index) public view returns (string link, string encryptionType, string hashValue) {\r\n        require(isValid == true, \"contract is invaild\");\r\n        require(index >= 0, \"The idx smaller than 0\");\r\n        require(index < dataNum, \"The idx bigger than dataNum\");\r\n        link = dataArray[index].link;\r\n        encryptionType = dataArray[index].encryptionType;\r\n        hashValue = dataArray[index].hashValue;\r\n    }\r\n\r\n    /**\r\n     * set the price of asset\r\n     * @param newPrice price of asset\r\n     * Only can be called by holder\r\n     */\r\n    function setPrice(uint newPrice) public onlyHolder {\r\n        require(isValid == true, \"contract is invaild\");\r\n        price = newPrice;\r\n    }\r\n\r\n    /**\r\n     * set the tradeable status of asset\r\n     * @param status status of isTradeable\r\n     * Only can be called by holder\r\n     */\r\n    function setTradeable(bool status) public onlyHolder {\r\n        require(isValid == true, \"contract is invaild\");\r\n        isTradeable = status;\r\n    }\r\n\r\n    /**\r\n     * set the remark1\r\n     * @param content new content of remark1\r\n     * Only can be called by holder\r\n     */\r\n    function setRemark1(string content) public onlyHolder {\r\n        require(isValid == true, \"contract is invaild\");\r\n        remark1 = content;\r\n    }\r\n\r\n    /**\r\n     * set the remark2\r\n     * @param content new content of remark2\r\n     * Only can be called by holder\r\n     */\r\n    function setRemark2(string content) public onlyHolder {\r\n        require(isValid == true, \"contract is invaild\");\r\n        remark2 = content;\r\n    }\r\n\r\n    /**\r\n     * Modify the link of the indexth data to be url\r\n     * @param index index of assetInfo\r\n     * @param url new link\r\n     * Only can be called by holder\r\n     */\r\n    function setDataLink(uint index, string url) public onlyHolder {\r\n        require(isValid == true, \"contract is invaild\");\r\n        require(index >= 0, \"The index smaller than 0\");\r\n        require(index < dataNum, \"The index bigger than dataNum\");\r\n        dataArray[index].link = url;\r\n    }\r\n\r\n    /**\r\n     * cancel contract\r\n     * Only can be called by holder\r\n     */\r\n    function cancelContract() public onlyHolder {\r\n        isValid = false;\r\n    }\r\n    \r\n    /**\r\n     * Get the number of assetInfo\r\n     */\r\n    function getDataNum() public view returns (uint num) {\r\n        num = dataNum;\r\n    }\r\n\r\n    /**\r\n     * Transfer holder\r\n     */\r\n    function transferOwnership(address newHolder, bool status) public onlyHolder {\r\n        holder = newHolder;\r\n        isTradeable = status;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"setDataLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTradeable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDataByIndex\",\"outputs\":[{\"name\":\"link\",\"type\":\"string\"},{\"name\":\"encryptionType\",\"type\":\"string\"},{\"name\":\"hashValue\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remark1\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAssetBaseInfo\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_isTradeable\",\"type\":\"bool\"},{\"name\":\"_dataNum\",\"type\":\"uint256\"},{\"name\":\"_remark1\",\"type\":\"string\"},{\"name\":\"_remark2\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remark2\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setTradeable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataNum\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"content\",\"type\":\"string\"}],\"name\":\"setRemark2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHolder\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataNumber\",\"type\":\"uint256\"},{\"name\":\"linkSet\",\"type\":\"string\"},{\"name\":\"encryptionTypeSet\",\"type\":\"string\"},{\"name\":\"hashValueSet\",\"type\":\"string\"}],\"name\":\"initAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"content\",\"type\":\"string\"}],\"name\":\"setRemark1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"asset","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://72843e2f06f0f536aeee585c01bc66c1f6d4ccb4d80e826d6d62efdffb6c3241"}]}