{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*      _____    ______    ________ \r\n *     /     |  /      \\  /        |\r\n *     $$$$$ | /$$$$$$  | $$$$$$$$/ \r\n *        $$ | $$ |  $$/     $$ |  \r\n *   __   $$ | $$ |          $$ |  \r\n *  /  |  $$ | $$ |   __     $$ |  \r\n *  $$ \\__$$ | $$ \\__/  |    $$ |\r\n *  $$    $$/  $$    $$/     $$ |\r\n *   $$$$$$/    $$$$$$/      $$/ \r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization\r\n *      control functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public collector;\r\n    address public distributor;\r\n    address public freezer;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event CollectorshipTransferred(address indexed previousCollector, address indexed newCollector);\r\n    event DistributorshipTransferred(address indexed previousDistributor, address indexed newDistributor);\r\n    event FreezershipTransferred(address indexed previousFreezer, address indexed newFreezer);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner`, `collector`, `distributor` and `freezer` of the contract to the\r\n     *      sender account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        collector = msg.sender;\r\n        distributor = msg.sender;\r\n        freezer = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the collector.\r\n     */\r\n    modifier onlyCollector() {\r\n        require(msg.sender == collector);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the distributor.\r\n     */\r\n    modifier onlyDistributor() {\r\n        require(msg.sender == distributor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the freezer.\r\n     */\r\n    modifier onlyFreezer() {\r\n        require(msg.sender == freezer);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(isNonZeroAccount(newOwner));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to transfer control of the contract to a newCollector.\r\n     * @param newCollector The address to transfer collectorship to.\r\n     */\r\n    function transferCollectorship(address newCollector) onlyOwner public {\r\n        require(isNonZeroAccount(newCollector));\r\n        emit CollectorshipTransferred(collector, newCollector);\r\n        collector = newCollector;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to transfer control of the contract to a newDistributor.\r\n     * @param newDistributor The address to transfer distributorship to.\r\n     */\r\n    function transferDistributorship(address newDistributor) onlyOwner public {\r\n        require(isNonZeroAccount(newDistributor));\r\n        emit DistributorshipTransferred(distributor, newDistributor);\r\n        distributor = newDistributor;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to transfer control of the contract to a newFreezer.\r\n     * @param newFreezer The address to transfer freezership to.\r\n     */\r\n    function transferFreezership(address newFreezer) onlyOwner public {\r\n        require(isNonZeroAccount(newFreezer));\r\n        emit FreezershipTransferred(freezer, newFreezer);\r\n        freezer = newFreezer;\r\n    }\r\n\r\n    // check if the given account is valid\r\n    function isNonZeroAccount(address _addr) internal pure returns (bool is_nonzero_account) {\r\n        return _addr != address(0);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20\r\n * @dev ERC20 contract interface\r\n */\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns (uint);\r\n    function totalSupply() public view returns (uint256 _supply);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    function name() public view returns (string _name);\r\n    function symbol() public view returns (string _symbol);\r\n    function decimals() public view returns (uint8 _decimals);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n/**\r\n * @title JCT\r\n * @author Daisuke Hirata & Noriyuki Izawa\r\n * @dev JCT is an ERC20 Token. First envisioned by NANJCOIN\r\n */\r\ncontract JCT is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public name = \"JCT\";\r\n    string public symbol = \"JCT\";\r\n    uint8 public decimals = 8;\r\n    uint256 public totalSupply = 17e7 * 1e8;\r\n    address public relay;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n    mapping (address => bool) public frozenAccount;\r\n    mapping (address => uint256) public unlockUnixTime;\r\n\r\n    event FrozenFunds(address indexed target, bool frozen);\r\n    event LockedFunds(address indexed target, uint256 locked);\r\n\r\n    /**\r\n     * @dev Constructor is called only once and can not be called again\r\n     */\r\n    constructor(address founder, address _relay) public {\r\n        owner = founder;\r\n        collector = founder;\r\n        distributor = founder;\r\n        freezer = founder;\r\n\r\n        balanceOf[founder] = totalSupply;\r\n\r\n        relay = _relay;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == relay || checkMessageData(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function name() public view returns (string _name) {\r\n        return name;\r\n    }\r\n\r\n    function symbol() public view returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balanceOf[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent targets from sending or receiving tokens\r\n     * @param targets Addresses to be frozen\r\n     * @param isFrozen either to freeze it or not\r\n     */\r\n    function freezeAccounts(address[] targets, bool isFrozen) onlyFreezer public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(isNonZeroAccount(targets[j]));\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent targets from sending or receiving tokens by setting Unix times\r\n     * @param targets Addresses to be locked funds\r\n     * @param unixTimes Unix times when locking up will be finished\r\n     */\r\n    function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public {\r\n        require(hasSameArrayLength(targets, unixTimes));\r\n\r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Standard function transfer with no _data\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(hasEnoughBalance(msg.sender, _value)\r\n                && isAvailableAccount(msg.sender)\r\n                && isAvailableAccount(_to));\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(isNonZeroAccount(_to)\r\n                && hasEnoughBalance(_from, _value)\r\n                && hasEnoughAllowance(_from, msg.sender, _value)\r\n                && isAvailableAccount(_from)\r\n                && isAvailableAccount(_to));\r\n\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows _spender to spend no more than _value tokens in your behalf\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows _spender to spend no more than _value tokens in your behalf. intended to be called from TxRelay contract\r\n     */\r\n    function approveTokenCollection(address _claimedSender, address _spender, uint256 _value) onlyAuthorized public returns (bool success) {\r\n        require(isAvailableAccount(_claimedSender)\r\n                && isAvailableAccount(msg.sender));\r\n        allowance[_claimedSender][_spender] = _value;\r\n        emit Approval(_claimedSender, _spender, _value);\r\n        return true;\r\n    }    \r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender\r\n     * @param _owner address The address which owns the funds\r\n     * @param _spender address The address which will spend the funds\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowance[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to collect tokens from the list of addresses\r\n     */\r\n    function collectTokens(address[] addresses, uint[] amounts) onlyCollector public returns (bool) {\r\n        require(hasSameArrayLength(addresses, amounts));\r\n\r\n        uint256 totalAmount = 0;\r\n\r\n        for (uint j = 0; j < addresses.length; j++) {\r\n            require(amounts[j] > 0\r\n                    && isNonZeroAccount(addresses[j])\r\n                    && isAvailableAccount(addresses[j])\r\n                    && hasEnoughAllowance(addresses[j], msg.sender, amounts[j]));\r\n\r\n            require(hasEnoughBalance(addresses[j], amounts[j]));\r\n            balanceOf[addresses[j]] = balanceOf[addresses[j]].sub(amounts[j]);\r\n            allowance[addresses[j]][msg.sender] = allowance[addresses[j]][msg.sender].sub(amounts[j]);\r\n            totalAmount = totalAmount.add(amounts[j]);\r\n            emit Transfer(addresses[j], msg.sender, amounts[j]);\r\n        }\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(totalAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to distribute tokens to the list of addresses\r\n     */\r\n    function distributeTokens(address[] addresses, uint[] amounts) onlyDistributor public returns (bool) {\r\n        require(hasSameArrayLength(addresses, amounts)\r\n                && isAvailableAccount(msg.sender));\r\n\r\n        uint256 totalAmount = 0;\r\n\r\n        for(uint j = 0; j < addresses.length; j++){\r\n            require(amounts[j] > 0\r\n                    && isNonZeroAccount(addresses[j])\r\n                    && isAvailableAccount(addresses[j]));\r\n\r\n            totalAmount = totalAmount.add(amounts[j]);\r\n        }\r\n        require(hasEnoughBalance(msg.sender, totalAmount));\r\n\r\n        for (j = 0; j < addresses.length; j++) {\r\n            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amounts[j]);\r\n            emit Transfer(msg.sender, addresses[j], amounts[j]);\r\n        }\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);\r\n        return true;\r\n    }\r\n\r\n    // check if the given account is available\r\n    function isAvailableAccount(address _addr) public view returns (bool is_valid_account) {\r\n        return isUnLockedAccount(_addr) && isUnfrozenAccount(_addr);\r\n    }\r\n\r\n    // check if the given account is not locked up\r\n    function isUnLockedAccount(address _addr) public view returns (bool is_unlocked_account) {\r\n        return now > unlockUnixTime[_addr];\r\n    }\r\n\r\n    // check if the given account is not frozen\r\n    function isUnfrozenAccount(address _addr) public view returns (bool is_unfrozen_account) {\r\n        return frozenAccount[_addr] == false;\r\n    }\r\n\r\n    // check if the given account has enough balance more than given amount\r\n    function hasEnoughBalance(address _addr, uint256 _value) public view returns (bool has_enough_balance) {\r\n        return _value > 0 && balanceOf[_addr] >= _value;\r\n    }\r\n\r\n    // check if the given spender has enough allowance of owner more than given amount\r\n    function hasEnoughAllowance(address _owner, address _spender, uint256 _value) public view returns (bool has_enough_balance) {\r\n        return allowance[_owner][_spender] >= _value;\r\n    }    \r\n\r\n    // check if the given account is not frozen\r\n    function hasSameArrayLength(address[] addresses, uint[] amounts) private pure returns (bool has_same_array_length) {\r\n        return addresses.length > 0 && addresses.length == amounts.length;\r\n    }\r\n\r\n    //Checks that address a is the first input in msg.data.\r\n    //Has very minimal gas overhead.\r\n    function checkMessageData(address a) private pure returns (bool t) {\r\n        if (msg.data.length < 36) return false;\r\n        assembly {\r\n            let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n            t := eq(a, and(mask, calldataload(4)))\r\n        }\r\n    }    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"hasEnoughAllowance\",\"outputs\":[{\"name\":\"has_enough_balance\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isUnLockedAccount\",\"outputs\":[{\"name\":\"is_unlocked_account\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCollector\",\"type\":\"address\"}],\"name\":\"transferCollectorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFreezer\",\"type\":\"address\"}],\"name\":\"transferFreezership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targets\",\"type\":\"address[]\"},{\"name\":\"unixTimes\",\"type\":\"uint256[]\"}],\"name\":\"lockupAccounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collector\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_claimedSender\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveTokenCollection\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isAvailableAccount\",\"outputs\":[{\"name\":\"is_valid_account\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relay\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targets\",\"type\":\"address[]\"},{\"name\":\"isFrozen\",\"type\":\"bool\"}],\"name\":\"freezeAccounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unlockUnixTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"hasEnoughBalance\",\"outputs\":[{\"name\":\"has_enough_balance\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"transferDistributorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"collectTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isUnfrozenAccount\",\"outputs\":[{\"name\":\"is_unfrozen_account\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"founder\",\"type\":\"address\"},{\"name\":\"_relay\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"locked\",\"type\":\"uint256\"}],\"name\":\"LockedFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousCollector\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newCollector\",\"type\":\"address\"}],\"name\":\"CollectorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousDistributor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"DistributorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousFreezer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newFreezer\",\"type\":\"address\"}],\"name\":\"FreezershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"JCT","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f64c412d7ad6b9317cafec098c24f7c15cb3bcc10000000000000000000000002057bbafad6e3073c7ee643538770093c965d659","Library":"","SwarmSource":"bzzr://61f4b7adf3dbea7594296be2c8c490d8621b2b57eba5057cdbbd85ac570f74bb"}]}