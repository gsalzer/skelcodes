{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n *   _____  ___    ___   _____      _              \r\n *   \\_   \\/ __\\  / __\\ /__   \\___ | | _____ _ __  \r\n *    / /\\/__\\// / /      / /\\/ _ \\| |/ / _ \\ '_ \\ \r\n * /\\/ /_/ \\/  \\/ /___   / / | (_) |   <  __/ | | |\r\n * \\____/\\_____/\\____/   \\/   \\___/|_|\\_\\___|_| |_|\r\n * \r\n * Token Address: 0xDEcF3A00E37BAdA548EC438dcef99B43D7F9F67d\r\n */\r\ncontract Token {\r\n    string public symbol = \"\";\r\n    string public name = \"\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 _totalSupply = 0;\r\n    address owner = 0;\r\n    bool setupDone = false;\r\n   \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n \r\n    mapping(address => uint256) balances;\r\n \r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    function SetupToken(string tokenName, string tokenSymbol, uint256 tokenSupply);\r\n    function totalSupply() constant returns (uint256 totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _amount) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\r\n    function approve(address _spender, uint256 _amount) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n *   _____  ___    ___     __       _   _                  \r\n *   \\_   \\/ __\\  / __\\   / /  ___ | |_| |_ ___ _ __ _   _ \r\n *    / /\\/__\\// / /     / /  / _ \\| __| __/ _ \\ '__| | | |\r\n * /\\/ /_/ \\/  \\/ /___  / /__| (_) | |_| ||  __/ |  | |_| |\r\n * \\____/\\_____/\\____/  \\____/\\___/ \\__|\\__\\___|_|   \\__, |\r\n *                                                   |___/ \r\n */\r\n\r\ncontract IBCLottery\r\n{\r\n    uint256 private ticketPrice_;\r\n    \r\n    // (user => Tikcet)\r\n    mapping(address => Ticket) internal ticketRecord_;\r\n    \r\n    Token public ibcToken_;\r\n    \r\n    address public officialWallet_;\r\n    address public devATeamWallet_;\r\n    address public devBTeamWallet_;\r\n    \r\n    // round => tokenRaised\r\n    uint256 public tokenRaised_;\r\n    uint256 public actualTokenRaised_;\r\n    mapping(address => uint256) public userPaidIn_;\r\n    \r\n    // On mainnet:\r\n    // ibc coin: 0xdecf3a00e37bada548ec438dcef99b43d7f9f67d\r\n    // official wallet: 0xe49c794d9eb5cE8E72C52Ab4dc7ccB233AA7Eb7C\r\n    // devA team wallet: 0xB034209C57134625CD95f8843e504bD0fA8664E5\r\n    // devB team wallet: 0x2ECBD107C3D3AdC43EeF22EE07b0401DF11E9472\r\n    constructor(\r\n        address _ibcoin,\r\n        address _officialWallet,\r\n        address _devATeamWallet,\r\n        address _devBTeamWallet\r\n    )\r\n        public\r\n    {\r\n        ibcToken_ = Token(_ibcoin);\r\n        officialWallet_ = _officialWallet;\r\n        devATeamWallet_ = _devATeamWallet;\r\n        devBTeamWallet_ = _devBTeamWallet;\r\n    }\r\n    \r\n    /**\r\n     *    __                 _       \r\n     *   /__\\_   _____ _ __ | |_ ___ \r\n     *  /_\\ \\ \\ / / _ \\ '_ \\| __/ __|\r\n     * //__  \\ V /  __/ | | | |_\\__ \\\r\n     * \\__/   \\_/ \\___|_| |_|\\__|___/                       \r\n     */\r\n     \r\n    event BuyTicket(\r\n        address indexed buyer,\r\n        uint256 price\r\n    );\r\n     \r\n     /**\r\n     *                   _ _  __ _           \r\n     *   /\\/\\   ___   __| (_)/ _(_) ___ _ __ \r\n     *  /    \\ / _ \\ / _` | | |_| |/ _ \\ '__|\r\n     * / /\\/\\ \\ (_) | (_| | |  _| |  __/ |   \r\n     * \\/    \\/\\___/ \\__,_|_|_| |_|\\___|_|                                  \r\n     */\r\n     \r\n    modifier onlyBoughtTicket(\r\n        address _user,\r\n        uint256 _timeLeft\r\n    )\r\n    {\r\n        require(hasValidTicketCore(_user, _timeLeft), \"You don't have ticket yet!\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     *    ___       _     _ _          ___                 _   _                 \r\n     *   / _ \\_   _| |__ | (_) ___    / __\\   _ _ __   ___| |_(_) ___  _ __  ___ \r\n     *  / /_)/ | | | '_ \\| | |/ __|  / _\\| | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\r\n     * / ___/| |_| | |_) | | | (__  / /  | |_| | | | | (__| |_| | (_) | | | \\__ \\\r\n     * \\/     \\__,_|_.__/|_|_|\\___| \\/    \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\r\n     */\r\n    \r\n    function buyTicketCore(\r\n        uint256 _pot,\r\n        uint256 _timeLeft,\r\n        address _user\r\n    )\r\n        internal\r\n        returns\r\n        (bool)\r\n    {\r\n        if(!hasValidTicketCore(_user, _timeLeft)) {\r\n            if (_timeLeft == 0) return false;\r\n            // local allowance variable\r\n            uint256 _allowance = ibcToken_.allowance(_user, this);\r\n            \r\n            // check if allowance to this contract.\r\n            require(_allowance > 0, \"Please approve token to this contract.\");\r\n            \r\n            // how much IBC user should pay for ticket.\r\n            uint256 _ticketPrice = calculateTicketPrice(_pot, _timeLeft);\r\n            \r\n            // check if the allowance enough to pay the ticket.\r\n            require(_allowance >= _ticketPrice, \"Insufficient allowance for this contract.\");\r\n            \r\n            // transfer from token from user wallet to this contract.\r\n            require(ibcToken_.transferFrom(_user, this, _ticketPrice));\r\n            \r\n            // increase tocket raise for each round.\r\n            tokenRaised_ = tokenRaised_ + _ticketPrice;\r\n            \r\n            // assign ticket to user.\r\n            ticketRecord_[_user].hasTicket = true;\r\n            ticketRecord_[_user].expirationTime = now + 30 minutes;\r\n            ticketRecord_[_user].ticketPrice = _ticketPrice;\r\n            \r\n            emit BuyTicket(_user, _ticketPrice);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function hasValidTicketCore(\r\n        address _user,\r\n        uint256 _timeLeft\r\n    )\r\n        view\r\n        internal\r\n        returns\r\n        (bool)\r\n    {\r\n        if (_timeLeft == 0) return false;\r\n        bool _hasTicket = ticketRecord_[_user].hasTicket;\r\n        uint256 _expirationTime = ticketRecord_[_user].expirationTime;\r\n        \r\n        return (_hasTicket && now <= _expirationTime);\r\n    }\r\n    \r\n    function calculateTicketPrice(\r\n        uint256 _pot,\r\n        uint256 _timeLeft\r\n    ) \r\n        pure\r\n        internal\r\n        returns\r\n        (uint256)\r\n    {\r\n        uint256 _potFixed = _pot / 1000000000000000000;\r\n        \r\n        // calculate Left time\r\n        uint256 _leftHour = _timeLeft / 3600;\r\n        \r\n        // left hours over and equal 24 hours\r\n        // pot equal to 0\r\n        // this means initial status of the game,\r\n        // no need to calculate, return 1 IBC (10**18 wei)\r\n        if (_leftHour >= 24) return 1000000000000000000;\r\n        \r\n        // what the fuck is this condition XDDD\r\n        // when 10**8 ETH in pot, return 10**7 IBC\r\n        // it is impossible,\r\n        // total ETH supply only about 10**8 ETH,\r\n        if (_pot >= 100000000000000000000000000) \r\n            return 10000000000000000000000000;\r\n        \r\n        /** \r\n         * 1        -> 99       ETH in pot => 1        IBC (< 100)\r\n         * 100      -> 999      ETH in pot => 10      IBC (< 1000)\r\n         * 1000     -> 9999     ETH in pot => 100     IBC (< 10000)\r\n         * 10000    -> 99999    ETH in pot => 1000    IBC (< 100000)\r\n         * 100000   -> 999999   ETH in pot => 10000   IBC (< 1000000)\r\n         * 1000000  -> 9999999  ETH in pot => 100000  IBC (< 10000000)\r\n         * 10000000 -> 99999999 ETH in pot => 1000000 IBC (< 100000000)\r\n         * Why? \r\n         * Total supply will be reached 120 million,\r\n         * the pot only 20% will be in pot.\r\n         * \r\n         * Time left:\r\n         * 0  -> 2  hours left, ticket price * 8.\r\n         * 3  -> 5  hours left, ticket price * 7.\r\n         * 6  -> 8  hours left, ticket price * 6.\r\n         * 9  -> 11 hours left, ticket price * 5.\r\n         * 12 -> 14 hours left, ticket price * 4.\r\n         * 15 -> 17 hours left, ticket price * 3.\r\n         * 18 -> 20 hours left, ticket price * 2.\r\n         * 21 -> 23 hours left, ticket price * 1.\r\n         * */\r\n    \r\n        uint256 _gap = 100;\r\n        for(uint8 _step = 0; _step < 7; _gap = _gap * 10) {\r\n            if (_potFixed < _gap) {\r\n                return (_gap / 100) * (8 - (_leftHour / 3)) * 1000000000000000000;\r\n            }    \r\n        }\r\n    }\r\n    \r\n    function getTokenRaised()\r\n        view\r\n        public\r\n        returns\r\n        (uint256, uint256)\r\n    {\r\n        // team funding:\r\n        // (tokenRaised_[_round] - (actualTokenRaised_ / 4))\r\n        // 25% token refund to user.\r\n        return (\r\n            tokenRaised_, \r\n            actualTokenRaised_\r\n        );\r\n    }\r\n    \r\n    function getUserPaidIn(\r\n        address _address\r\n    )\r\n        view\r\n        public\r\n        returns\r\n        (uint256)\r\n    {\r\n        return userPaidIn_[_address];\r\n    }\r\n    \r\n    struct Ticket {\r\n        bool hasTicket;\r\n        uint256 expirationTime;\r\n        uint256 ticketPrice;\r\n    }\r\n}\r\n\r\n/**\r\n *     ___ _____   ___  __                 _       \r\n *    / __\\___ /  /   \\/__\\_   _____ _ __ | |_ ___ \r\n *   / _\\   |_ \\ / /\\ /_\\ \\ \\ / / _ \\ '_ \\| __/ __|\r\n *  / /    ___) / /_///__  \\ V /  __/ | | | |_\\__ \\\r\n *  \\/    |____/___,'\\__/   \\_/ \\___|_| |_|\\__|___/\r\n * */\r\ncontract IBCLotteryEvents {\r\n    \r\n    // fired at end of buy or reload\r\n    event onEndTx\r\n    (\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        address winnerAddr,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 genAmount,\r\n        uint256 potAmount\r\n    );\r\n    \r\n\t// fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a withdraw forces end round to be ran\r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        uint256 ethOut,\r\n        address winnerAddr,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // hit zero, and causes end round to be ran.\r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        address winnerAddr,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onBuyTicketAndDistribute\r\n    (\r\n        address playerAddress,\r\n        address winnerAddr,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // hit zero, and causes end round to be ran.\r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        address winnerAddr,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // fired whenever an affiliate is paid\r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    event onRefundTicket\r\n    (\r\n        uint256 indexed playerID,\r\n        uint256 refundAmount\r\n    );\r\n}\r\n\r\n/**\r\n *      ___            _                  _       \r\n *     / __\\___  _ __ | |_ _ __ __ _  ___| |_ ___ \r\n *    / /  / _ \\| '_ \\| __| '__/ _` |/ __| __/ __|\r\n *   / /__| (_) | | | | |_| | | (_| | (__| |_\\__ \\\r\n *   \\____/\\___/|_| |_|\\__|_|  \\__,_|\\___|\\__|___/\r\n * */\r\n\r\ncontract IBCLotteryGame is IBCLotteryEvents, IBCLottery {\r\n    using SafeMath for *;\r\n    using IBCLotteryKeysCalcLong for uint256;\r\n\t\r\n    /**\r\n     *    ___                       __      _   _   _                 \r\n     *   / _ \\__ _ _ __ ___   ___  / _\\ ___| |_| |_(_)_ __   __ _ ___ \r\n     *  / /_\\/ _` | '_ ` _ \\ / _ \\ \\ \\ / _ \\ __| __| | '_ \\ / _` / __|\r\n     * / /_\\\\ (_| | | | | | |  __/ _\\ \\  __/ |_| |_| | | | | (_| \\__ \\\r\n     * \\____/\\__,_|_| |_| |_|\\___| \\__/\\___|\\__|\\__|_|_| |_|\\__, |___/\r\n     *                                                      |___/     \r\n     * */\r\n    \r\n\t// round timer starts at this\r\n    // start at 24 hours\r\n    // this value used at: \r\n    //   - endRound() function\r\n    //   - activate() function\r\n    uint256 private rndInit_ = 24 hours;\r\n    // The timer will be added after the whole key purchased.\r\n    // this value used at: \r\n    //   - updateTimer() function\r\n    uint256 private rndInc_ = 1 minutes;\r\n    // Max length a round timer can be\r\n    // this value used at:\r\n    //   - updateTimer() function\r\n    uint256 private rndMax_ = 24 hours;\r\n    \r\n    // Auto Increment ID\r\n    // Inspired by MYSAL AUTO INCREMENT PRIMARY KEY.\r\n    uint256 private maxUserId_ = 0;\r\n    \r\n    address private owner_;\r\n\r\n    /**\r\n     *    ___                          ___      _        \r\n     *   / _ \\__ _ _ __ ___   ___     /   \\__ _| |_ __ _ \r\n     *  / /_\\/ _` | '_ ` _ \\ / _ \\   / /\\ / _` | __/ _` |\r\n     * / /_\\\\ (_| | | | | | |  __/  / /_// (_| | || (_| |\r\n     * \\____/\\__,_|_| |_| |_|\\___| /___,' \\__,_|\\__\\__,_|\r\n     * */\r\n\tuint256 public rID_;    // round id number / total rounds that have happened\r\n\r\n    /**\r\n     *    ___ _                            ___      _        \r\n     *   / _ \\ | __ _ _   _  ___ _ __     /   \\__ _| |_ __ _ \r\n     *  / /_)/ |/ _` | | | |/ _ \\ '__|   / /\\ / _` | __/ _` |\r\n     * / ___/| | (_| | |_| |  __/ |     / /_// (_| | || (_| |\r\n     * \\/    |_|\\__,_|\\__, |\\___|_|    /___,' \\__,_|\\__\\__,_|\r\n     *                |___/                                  \r\n     * */\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (uint256 => IBCLotteryDatasets.Player) public plyr_;   // (pID => data) player data\r\n    mapping (uint256 => IBCLotteryDatasets.PlayerRounds) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\r\n\r\n    /**\r\n     *    __                       _      ___      _        \r\n     *   /__\\ ___  _   _ _ __   __| |    /   \\__ _| |_ __ _ \r\n     *  / \\/// _ \\| | | | '_ \\ / _` |   / /\\ / _` | __/ _` |\r\n     * / _  \\ (_) | |_| | | | | (_| |  / /_// (_| | || (_| |\r\n     * \\/ \\_/\\___/ \\__,_|_| |_|\\__,_| /___,' \\__,_|\\__\\__,_|\r\n     * */\r\n    IBCLotteryDatasets.Round round_;   // (rID => data) round data\r\n\r\n    /**\r\n     *     ___                _                   _             \r\n     *    / __\\___  _ __  ___| |_ _ __ _   _  ___| |_ ___  _ __ \r\n     *   / /  / _ \\| '_ \\/ __| __| '__| | | |/ __| __/ _ \\| '__|\r\n     *  / /__| (_) | | | \\__ \\ |_| |  | |_| | (__| || (_) | |   \r\n     *  \\____/\\___/|_| |_|___/\\__|_|   \\__,_|\\___|\\__\\___/|_|   \r\n     * */\r\n    constructor(\r\n        address _ibcoin,\r\n        address _officialWallet,\r\n        address _devATeamWallet,\r\n        address _devBTeamWallet\r\n    )\r\n        IBCLottery(_ibcoin, _officialWallet, _devATeamWallet, _devBTeamWallet)\r\n        public\r\n    {\r\n        owner_ = msg.sender;\r\n\t}\r\n    /**\r\n                         _ _  __ _               \r\n     *   /\\/\\   ___   __| (_)/ _(_) ___ _ __ ___ \r\n     *  /    \\ / _ \\ / _` | | |_| |/ _ \\ '__/ __|\r\n     * / /\\/\\ \\ (_) | (_| | |  _| |  __/ |  \\__ \\\r\n     * \\/    \\/\\___/ \\__,_|_|_| |_|\\___|_|  |___/\r\n     */\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has \r\n     * been activated. \r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"Be patient!!!\"); \r\n        _;\r\n    }\r\n    /**\r\n     * @dev prevents contracts from interacting this contract\r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyInRound() {\r\n        require(!round_.ended, \"The game has ended\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n    \r\n    modifier onlyOwner(\r\n        address _address\r\n    ) {\r\n        require(_address == owner_, \"You are not owner!!!!\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     *    ___       _     _ _          ___                 _   _                 \r\n     *   / _ \\_   _| |__ | (_) ___    / __\\   _ _ __   ___| |_(_) ___  _ __  ___ \r\n     *  / /_)/ | | | '_ \\| | |/ __|  / _\\| | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\r\n     * / ___/| |_| | |_) | | | (__  / /  | |_| | | | | (__| |_| | (_) | | | \\__ \\\r\n     * \\/     \\__,_|_.__/|_|_|\\___| \\/    \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\r\n     * */\r\n    /**\r\n     * @dev emergency buy uses last stored affiliate ID and team snek\r\n     */\r\n    function()\r\n        isActivated()\r\n        onlyInRound()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        onlyBoughtTicket(msg.sender, getTimeLeft())\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        IBCLotteryDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        uint256 _affID = plyr_[_pID].laff;\r\n        \r\n        core(_pID, msg.value, _affID, _eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev converts all incoming ethereum to keys.\r\n     * -functionhash- 0x8f38f309 (using ID for affiliate)\r\n     * -functionhash- 0x98a0871d (using address for affiliate)\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     */\r\n    \r\n    function buyXaddr(address _affCode)\r\n        isActivated()\r\n        onlyInRound()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        onlyBoughtTicket(msg.sender, getTimeLeft())\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        IBCLotteryDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        // manage affiliate residuals\r\n        uint256 _affID = pIDxAddr_[_affCode];\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) \r\n            || _affCode == msg.sender \r\n            || plyrRnds_[_affID].keys < 1000000000000000000)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        core(_pID, msg.value, _affID, _eventData_);\r\n    }\r\n    \r\n    function buyTicket()\r\n        onlyInRound()\r\n        public\r\n        returns\r\n        (bool)\r\n    {\r\n        uint256 _now = now;\r\n        if (_now > round_.end && round_.ended == false && round_.plyr != 0) \r\n        {\r\n            IBCLotteryDatasets.EventReturns memory _eventData_;\r\n            \r\n            // end the round (distributes pot) & start new round\r\n\t\t    round_.ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n            \r\n            // fire buy and distribute event \r\n            emit IBCLotteryEvents.onBuyTicketAndDistribute\r\n            (\r\n                msg.sender, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.genAmount\r\n            );\r\n        } else {\r\n            uint256 _pot = round_.pot;\r\n            uint256 _timeLeft = getTimeLeft();\r\n            return buyTicketCore(_pot, _timeLeft, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev withdraws all of your earnings.\r\n     * -functionhash- 0x3ccfd60b\r\n     */\r\n    function withdraw()\r\n        isActivated()\r\n        isHuman()\r\n        public\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        \r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > round_.end && round_.ended == false && round_.plyr != 0)\r\n        {\r\n            // set up our tx event data\r\n            IBCLotteryDatasets.EventReturns memory _eventData_;\r\n            \r\n            // end the round (distributes pot)\r\n\t\t\tround_.ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n            \r\n\t\t\t// get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);    \r\n            \r\n            // fire withdraw and distribute event\r\n            emit IBCLotteryEvents.onWithdrawAndDistribute\r\n            (\r\n                msg.sender, \r\n                _eth, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.genAmount\r\n            );\r\n            \r\n        // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n            \r\n            // fire withdraw event\r\n            emit IBCLotteryEvents.onWithdraw(_pID, msg.sender, _eth, _now);\r\n        }\r\n        \r\n        if (now > round_.end && round_.plyr != 0) {\r\n            refundTicket(_pID);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *    ___     _   _                \r\n     *   / _ \\___| |_| |_ ___ _ __ ___ \r\n     *  / /_\\/ _ \\ __| __/ _ \\ '__/ __|\r\n     * / /_\\\\  __/ |_| ||  __/ |  \\__ \\\r\n     * \\____/\\___|\\__|\\__\\___|_|  |___/\r\n     * */\r\n    /**\r\n     * @dev return the price buyer will pay for next 1 individual key.\r\n     * -functionhash- 0x018a25e8\r\n     * @return price for next key bought (in wei format)\r\n     */\r\n    function getBuyPrice()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {  \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))\r\n            return ( (round_.keys.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( 75000000000000 ); // init\r\n    }\r\n    \r\n    /**\r\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node \r\n     * provider\r\n     * -functionhash- 0xc7e284b8\r\n     * @return time left in seconds\r\n     */\r\n    function getTimeLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        if (_now < round_.end)\r\n            if (_now > round_.strt)\r\n                return( (round_.end).sub(_now) );\r\n            else\r\n                return( (round_.strt).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev returns player earnings per vaults \r\n     * -functionhash- 0x63066434\r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n     * @return token share vault\r\n     */\r\n    function getPlayerVaults(uint256 _pID)\r\n        public\r\n        view\r\n        returns(uint256 ,uint256, uint256, uint256)\r\n    {\r\n        uint256 _gen;\r\n        uint256 _limiter;\r\n        uint256 _genShow;\r\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\r\n        if (now > round_.end && round_.ended == false && round_.plyr != 0)\r\n        {\r\n            // if player is winner \r\n            if (round_.plyr == _pID)\r\n            {\r\n                _gen = (plyr_[_pID].gen).add(getPlayerVaultsHelper(_pID).sub(plyrRnds_[_pID].mask));\r\n                _limiter = (plyrRnds_[_pID].eth.mul(22) / 10);\r\n                _genShow = 0;\r\n                \r\n                if (plyrRnds_[_pID].genWithdraw.add(_gen) > _limiter) {\r\n                    _genShow = _limiter - plyrRnds_[_pID].genWithdraw;\r\n                } else {\r\n                    _genShow = _gen;\r\n                }\r\n                \r\n                return\r\n                (\r\n                    (plyr_[_pID].win).add( ((round_.pot).mul(2)) / 5 ).add(getFinalDistribute(_pID)),\r\n                    _genShow,\r\n                    plyr_[_pID].aff,\r\n                    plyr_[_pID].tokenShare.add(getTokenShare(_pID))\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                \r\n                _gen = (plyr_[_pID].gen).add(getPlayerVaultsHelper(_pID).sub(plyrRnds_[_pID].mask));\r\n                _limiter = (plyrRnds_[_pID].eth.mul(22) / 10);\r\n                _genShow = 0;\r\n                \r\n                if (plyrRnds_[_pID].genWithdraw.add(_gen) > _limiter) {\r\n                    _genShow = _limiter - plyrRnds_[_pID].genWithdraw;\r\n                } else {\r\n                    _genShow = _gen;\r\n                }    \r\n                \r\n                return\r\n                (\r\n                    (plyr_[_pID]).win.add(getFinalDistribute(_pID)),\r\n                    _genShow,\r\n                    plyr_[_pID].aff,\r\n                    plyr_[_pID].tokenShare.add(getTokenShare(_pID))\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            _gen = (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID)) ;\r\n            _limiter = (plyrRnds_[_pID].eth.mul(22) / 10);\r\n            _genShow = 0;\r\n            \r\n            if (plyrRnds_[_pID].genWithdraw.add(_gen) > _limiter) {\r\n                _genShow = _limiter - plyrRnds_[_pID].genWithdraw;\r\n            } else {\r\n                _genShow = _gen;\r\n            }  \r\n            \r\n            return\r\n            (\r\n                plyr_[_pID].win.add(getFinalDistribute(_pID)),\r\n                _genShow,\r\n                plyr_[_pID].aff,\r\n                plyr_[_pID].tokenShare.add(getTokenShare(_pID))\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * solidity hates stack limits.  this lets us avoid that hate \r\n     */\r\n    function getPlayerVaultsHelper(uint256 _pID)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  (((round_.mask).mul(plyrRnds_[_pID].keys)) / 1000000000000000000)  );\r\n    }\r\n    \r\n    function getFinalDistribute(uint256 _pID)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _now = now;\r\n        \r\n        if (_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))\r\n        {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 _boughtTime = plyrRnds_[_pID].boughtTime;\r\n        \r\n        if(_boughtTime == 0) return 0;\r\n        \r\n        uint256 _firstKeyShare = round_.firstKeyShare;\r\n        \r\n        uint256 _eachKeyCanShare = round_.eachKeyCanShare;\r\n        uint256 _totalKeyCanShare = 0;\r\n        for (uint256 _bought = _boughtTime; _bought > 0; _bought --) {\r\n            uint256 _lastKey = plyrRnds_[_pID].boughtRecord[_bought].lastKey;\r\n            if (_lastKey < _firstKeyShare) break;\r\n            uint256 _amount = plyrRnds_[_pID].boughtRecord[_bought].amount;\r\n            uint256 _firstKey = _lastKey - _amount;\r\n            if (_firstKey > _firstKeyShare) {\r\n                _totalKeyCanShare = _totalKeyCanShare.add(_amount);\r\n            } else {\r\n                _totalKeyCanShare = _totalKeyCanShare.add(_lastKey - _firstKeyShare);\r\n            }\r\n        }\r\n        return (_totalKeyCanShare.mul(_eachKeyCanShare) / 1000000000000000000);\r\n    }\r\n    \r\n    function getTokenShare(uint256 _pID) \r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _now = now;\r\n        \r\n        if(plyrRnds_[_pID].tokenShareCalc) {\r\n            return 0;\r\n        }\r\n        \r\n        if (_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))\r\n        {\r\n            return 0;   \r\n        }\r\n        \r\n        address _address = plyr_[_pID].addr;\r\n        uint256 _userPaidIn = userPaidIn_[_address];\r\n        \r\n        return ((round_.tokenShare.mul(_userPaidIn)) / 1000000000000000000);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev returns all current round info needed for front end\r\n     * -functionhash- 0x747dff42\r\n     * @return round id \r\n     * @return total keys for round \r\n     * @return time round ends\r\n     * @return time round started\r\n     * @return current pot \r\n     * @return player ID in lead \r\n     * @return current player in leads address \r\n     * @return token raised for buying ticket\r\n     * @return token actual raised for using ticket.\r\n     */\r\n    function getCurrentRoundInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, address, uint256, uint256)\r\n    {\r\n        (uint256 _tokenRaised, uint256 _tokenActualRaised) = getTokenRaised();\r\n        \r\n        return\r\n        (\r\n            round_.keys,              //0\r\n            round_.end,               //1\r\n            round_.strt,              //2\r\n            round_.pot,               //3\r\n            round_.plyr,     //4\r\n            plyr_[round_.plyr].addr,  //5\r\n            _tokenRaised, // 6\r\n            _tokenActualRaised //7 \r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address.  if no address is given, it will \r\n     * use msg.sender \r\n     * -functionhash- 0xee0b5d8b\r\n     * @param _addr address of the player you want to lookup \r\n     * @return player ID \r\n     * @return keys owned (current round)\r\n     * @return winnings vault\r\n     * @return general vault \r\n     * @return affiliate vault \r\n\t * @return player round eth\r\n     */\r\n    function getPlayerInfoByAddress(address _addr)\r\n        public \r\n        view \r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        uint256 _gen = (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID));\r\n        uint256 _limiter = (plyrRnds_[_pID].eth.mul(22) / 10);\r\n        uint256 _genShow = 0;\r\n        \r\n        if (plyrRnds_[_pID].genWithdraw.add(_gen) > _limiter) {\r\n            _genShow = _limiter - plyrRnds_[_pID].genWithdraw;\r\n        } else {\r\n            _genShow = _gen;\r\n        } \r\n        \r\n        return\r\n        (\r\n            _pID,                               //0\r\n            plyrRnds_[_pID].keys,         //1\r\n            plyr_[_pID].win,                    //2\r\n            _genShow,       //3\r\n            plyr_[_pID].aff,                    //4\r\n            plyr_[_pID].tokenShare,             // 5\r\n            plyrRnds_[_pID].eth           //6\r\n        );\r\n    }\r\n\r\n    /**\r\n     *    ___                   __             _      \r\n     *   / __\\___  _ __ ___    / /  ___   __ _(_) ___ \r\n     *  / /  / _ \\| '__/ _ \\  / /  / _ \\ / _` | |/ __|\r\n     * / /__| (_) | | |  __/ / /__| (_) | (_| | | (__ \r\n     * \\____/\\___/|_|  \\___| \\____/\\___/ \\__, |_|\\___|\r\n     *                                   |___/        \r\n     * */\r\n    \r\n    /**\r\n     * @dev this is the core logic for any buy/reload that happens while a round \r\n     * is live.\r\n     */\r\n    function core(uint256 _pID, uint256 _eth, uint256 _affID, IBCLotteryDatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // if player is new to round\r\n        if (plyrRnds_[_pID].keys == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_);\r\n        \r\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\r\n        \r\n        // mint the new keys\r\n        uint256 _keys = (round_.eth).keysRec(_eth);\r\n        uint256 _keyBonus = getKeyBonus();\r\n        \r\n        _keys = (_keys.mul(_keyBonus) / 10);\r\n        \r\n        // if they bought at least 1 whole key\r\n        if (_keys >= 1000000000000000000 && _keyBonus == 10)\r\n        {\r\n            updateTimer(_keys);\r\n\r\n            // set new leaders\r\n            if (round_.plyr != _pID)\r\n                round_.plyr = _pID;  \r\n        }\r\n        \r\n        // new key cannot share over earning dividend.\r\n        if (round_.overEarningMask > 0) {\r\n            plyrRnds_[_pID].mask = plyrRnds_[_pID].mask.add(\r\n                (round_.overEarningMask.mul(_keys) / 1000000000000000000)\r\n            );\r\n        }\r\n        \r\n        // update player \r\n        plyrRnds_[_pID].keys = _keys.add(plyrRnds_[_pID].keys);\r\n        plyrRnds_[_pID].eth = _eth.add(plyrRnds_[_pID].eth);\r\n        \r\n        // update round\r\n        round_.keys = _keys.add(round_.keys);\r\n        round_.eth = _eth.add(round_.eth);\r\n        \r\n        uint256 _boughtTime = plyrRnds_[_pID].boughtTime + 1;\r\n        plyrRnds_[_pID].boughtTime = _boughtTime;\r\n        \r\n        plyrRnds_[_pID].boughtRecord[_boughtTime].lastKey = round_.keys;\r\n        plyrRnds_[_pID].boughtRecord[_boughtTime].amount = _keys;\r\n\r\n        // distribute eth\r\n        _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);\r\n        _eventData_ = distributeInternal(_pID, _eth, _keys, _eventData_);\r\n        \r\n        // call end tx function to fire end tx event.\r\n        endTx(_eth, _keys, _eventData_);\r\n    }\r\n    /**\r\n     *    ___      _            _       _   _                 \r\n     *   / __\\__ _| | ___ _   _| | __ _| |_(_) ___  _ __  ___ \r\n     *  / /  / _` | |/ __| | | | |/ _` | __| |/ _ \\| '_ \\/ __|\r\n     * / /__| (_| | | (__| |_| | | (_| | |_| | (_) | | | \\__ \\\r\n     * \\____/\\__,_|_|\\___|\\__,_|_|\\__,_|\\__|_|\\___/|_| |_|___/\r\n     * */\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\r\n     * @return earnings in wei format\r\n     */\r\n    function calcUnMaskedEarnings(uint256 _pID)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  (((round_.mask.add(round_.overEarningMask)).mul(plyrRnds_[_pID].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID].mask)  );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns the amount of keys you would get given an amount of eth. \r\n     * -functionhash- 0xce89c80c\r\n     * @param _eth amount of eth sent in \r\n     * @return keys received \r\n     */\r\n    function calcKeysReceived(uint256 _eth)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))\r\n            return ( (round_.eth).keysRec(_eth) );\r\n        else // rounds over.  need keys for new round\r\n            return ( (_eth).keys() );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns current eth price for X keys.  \r\n     * -functionhash- 0xcf808000\r\n     * @param _keys number of keys desired (in 18 decimal format)\r\n     * @return amount of eth needed to send\r\n     */\r\n    function iWantXKeys(uint256 _keys)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))\r\n            return ( (round_.keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n\r\n    function getTicketPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _now = now;\r\n        // in round\r\n        if (_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0)))\r\n        {\r\n            uint256 _timeLeft = round_.end - now;\r\n            return calculateTicketPrice(round_.pot, _timeLeft);\r\n        }\r\n        // not in round\r\n        else {\r\n            return 1000000000000000000;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *   _____            _     \r\n     *  /__   \\___   ___ | |___ \r\n     *   / /\\/ _ \\ / _ \\| / __|\r\n     *  / / | (_) | (_) | \\__ \\\r\n     *  \\/   \\___/ \\___/|_|___/\r\n     * */\r\n        \r\n    /**\r\n     * @dev gets existing or registers new pID.  use this when a player may be new\r\n     * @return pID \r\n     */\r\n    function determinePID(IBCLotteryDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (IBCLotteryDatasets.EventReturns)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        if (_pID == 0)\r\n        {\r\n            maxUserId_ = maxUserId_ + 1;\r\n            _pID = maxUserId_;\r\n            \r\n            // set up player account \r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n        } \r\n        return (_eventData_);\r\n    }\r\n    \r\n    function getKeyBonus()\r\n        view\r\n        internal\r\n        returns\r\n        (uint256)\r\n    {\r\n        uint256 _timeLeft = getTimeLeft();\r\n        \r\n        if(_timeLeft == 86400) return 10;\r\n        \r\n        uint256 _hoursLeft = _timeLeft / 3600;\r\n        uint256 _minutesLeft = (_timeLeft % 3600) / 60;\r\n        \r\n        if(_minutesLeft <= 59 && _minutesLeft >= 5) return 10;\r\n        \r\n        uint256 _flag = 0;\r\n        if (_hoursLeft <= 24 && _hoursLeft >= 12) {\r\n            _flag = 3;\r\n        } else {\r\n            _flag = 6;\r\n        }\r\n        \r\n        uint256 _randomNumber = getRandomNumber() % _flag;\r\n        \r\n        return ((5*_randomNumber) + 15);\r\n    }\r\n    \r\n    /**\r\n     * @dev decides if round end needs to be run & new round started.  and if \r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n    function managePlayer(uint256 _pID, IBCLotteryDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (IBCLotteryDatasets.EventReturns)\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID);\r\n            \r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev ends the round. manages paying out winner/splitting up pot\r\n     */\r\n    function endRound(IBCLotteryDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (IBCLotteryDatasets.EventReturns)\r\n    {\r\n        \r\n        // grab our winning player and team id's\r\n        uint256 _winPID = round_.plyr;\r\n        \r\n        // grab our pot amount\r\n        uint256 _pot = round_.pot;\r\n        \r\n        // calculate our winner share, community rewards, gen share, \r\n        // all eth in 20% to pot,\r\n        // winner share 40% of pot.\r\n        // last 1% user share another 50% of pot.\r\n        uint256 _win = ((_pot.mul(2)) / 5);\r\n        \r\n        // refund those ticket unused to ibcToken wallet.\r\n        uint256 tokenBackToTeam = tokenRaised_ - actualTokenRaised_;\r\n        if (tokenBackToTeam > 0) {\r\n            ibcToken_.transfer(officialWallet_, tokenBackToTeam / 2);\r\n            ibcToken_.transfer(devATeamWallet_, tokenBackToTeam / 2);\r\n        }\r\n        \r\n        // pay our winner\r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n        \r\n            \r\n        // prepare event data\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.amountWon = _win;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(uint256 _pID)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyrRnds_[_pID].mask = _earnings.add(plyrRnds_[_pID].mask);\r\n        }\r\n    }\r\n    \r\n    function updateFinalDistribute(uint256 _pID)\r\n        private\r\n    {\r\n        uint256 _now = now;\r\n        if (!(_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0))))\r\n        {\r\n            plyr_[_pID].win = plyr_[_pID].win + getFinalDistribute(_pID);\r\n            plyrRnds_[_pID].boughtTime = 0;\r\n        }\r\n    }\r\n    \r\n    function updateTokenShare(uint256 _pID)\r\n        internal\r\n    {\r\n        uint256 _now = now;\r\n        if (!(_now > round_.strt && (_now <= round_.end || (_now > round_.end && round_.plyr == 0))))\r\n        {\r\n            if (!plyrRnds_[_pID].tokenShareCalc) {\r\n                plyr_[_pID].tokenShare = plyr_[_pID].tokenShare + getTokenShare(_pID);\r\n                plyrRnds_[_pID].tokenShareCalc = true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev updates round timer based on number of whole keys bought.\r\n     */\r\n    function updateTimer(uint256 _keys)\r\n        private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // calculate time based on number of keys bought\r\n        uint256 _newTime;\r\n        if (_now > round_.end && round_.plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_.end);\r\n        \r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_.end = _newTime;\r\n        else\r\n            round_.end = rndMax_.add(_now);\r\n    }\r\n\r\n    /**\r\n     * @dev distributes eth based on fees to com, aff, and p3d\r\n     */\r\n    function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, IBCLotteryDatasets.EventReturns memory _eventData_)\r\n        private \r\n        returns(IBCLotteryDatasets.EventReturns)\r\n    {\r\n        \r\n        // distribute share to affiliate\r\n        // 20% for affiliate\r\n        // origin ((_eth / 5).mul(88) / 100)\r\n        uint256 _aff = ((_eth).mul(88) / 500);\r\n        \r\n        // decide what to do with affiliate share of fees\r\n        // affiliate must not be self, and must have a name registered\r\n        // what is this?\r\n        // all of player of this game has player ID.\r\n        // bu to be an legal affiliate must register, register can give user a name.\r\n        // those users who have name is an valid affiliate.\r\n        if (_affID != _pID && _affID != 0) {\r\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n            emit IBCLotteryEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, _pID, _aff, now);\r\n        } else if (!round_.firstPlayerIn){\r\n            // first user send to dev A wallet.\r\n            devATeamWallet_.transfer(_aff);\r\n            round_.firstPlayerIn = true;\r\n            emit IBCLotteryEvents.onAffiliatePayout(0, devATeamWallet_, _pID, _aff, now);\r\n        } else {\r\n            // no affiliate\r\n            // send to offical wallet.\r\n            devBTeamWallet_.transfer(_aff);\r\n            emit IBCLotteryEvents.onAffiliatePayout(0, devBTeamWallet_, _pID, _aff, now);\r\n        }\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev distributes eth based on fees to gen and pot\r\n     */\r\n    function distributeInternal(uint256 _pID, uint256 _eth, uint256 _keys, IBCLotteryDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns(IBCLotteryDatasets.EventReturns)\r\n    {\r\n        // calculate gen share 50%\r\n        // origin = (_eth.mul(45).mul(88) / 100 / 100)\r\n        uint256 _gen = (_eth.mul(3960) / 10000);\r\n        \r\n        // aff share 15%\r\n        // _gen 50%\r\n        // IBC share 10%\r\n        // pot 25%\r\n        \r\n        // calculate pot \r\n        // origin: ((_eth / 4).mul(88) / 100)\r\n        uint256 _pot = _pot.add((_eth.mul(88)) / 400);\r\n        \r\n        // distribute gen share (thats what updateMasks() does) and adjust\r\n        // balances for dust.\r\n        uint256 _dust = updateMasks(_pID, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n        \r\n        // add eth to pot\r\n        round_.pot = _pot.add(_dust).add(round_.pot);\r\n        \r\n        // set up event data\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    function refundTicket(uint256 _pID)\r\n        public\r\n    {\r\n        address _playerAddress = plyr_[_pID].addr;\r\n        uint256 _userPaidIn = userPaidIn_[_playerAddress];\r\n        \r\n        if (!plyr_[_pID].ibcRefund && _userPaidIn != 0) {\r\n            // do not do refund at round 1.\r\n            uint256 _refund = userPaidIn_[_playerAddress] / 4;\r\n            plyr_[_pID].ibcRefund = true;\r\n            ibcToken_.transfer(_playerAddress, _refund);\r\n            emit onRefundTicket(\r\n                _pID,\r\n                _refund\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev updates masks for round and player when keys are bought\r\n     * @return dust left over \r\n     */\r\n    function updateMasks(uint256 _pID, uint256 _gen, uint256 _keys)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        /* MASKING NOTES\r\n            earnings masks are a tricky thing for people to wrap their minds around.\r\n            the basic thing to understand here.  is were going to have a global\r\n            tracker based on profit per share for each round, that increases in\r\n            relevant proportion to the increase in share supply.\r\n            \r\n            the player will have an additional mask that basically says \"based\r\n            on the rounds mask, my shares, and how much i've already withdrawn,\r\n            how much is still owed to me?\"\r\n        */\r\n        \r\n        // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_.keys);\r\n        round_.mask = _ppt.add(round_.mask);\r\n            \r\n        // calculate player earning from their own buy (only based on the keys\r\n        // they just bought).  & update player earnings mask\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n        plyrRnds_[_pID].mask = (((round_.mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID].mask);\r\n        \r\n        // calculate & return dust\r\n        return(_gen.sub((_ppt.mul(round_.keys)) / (1000000000000000000)));\r\n    }\r\n    \r\n    /**\r\n     * @dev adds up unmasked earnings, & vault earnings, sets them all to 0\r\n     * @return earnings in wei format\r\n     */\r\n    function withdrawEarnings(uint256 _pID)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateGenVault(_pID);\r\n        updateTokenShare(_pID);\r\n        updateFinalDistribute(_pID);\r\n        \r\n        uint256 _playerGenWithdraw = plyrRnds_[_pID].genWithdraw;\r\n        \r\n        uint256 _limiter = (plyrRnds_[_pID].eth.mul(22) / 10);\r\n        \r\n        uint256 _withdrawGen = 0;\r\n        \r\n        if(_playerGenWithdraw.add(plyr_[_pID].gen) > _limiter) {\r\n            _withdrawGen = _limiter - _playerGenWithdraw;\r\n            \r\n            uint256 _overEarning = _playerGenWithdraw.add(plyr_[_pID].gen) - _limiter;\r\n            round_.overEarningMask = round_.overEarningMask.add(_overEarning.mul(1000000000000000000) / round_.keys);\r\n            for (int i = 0; i < 5; i ++) {\r\n                round_.overEarningMask = round_.overEarningMask.add(_overEarning.mul(1000000000000000000) / round_.keys);\r\n                _overEarning = (round_.overEarningMask.mul(plyrRnds_[_pID].keys) / 1000000000000000000);\r\n            }\r\n            \r\n            plyrRnds_[_pID].genWithdraw = _limiter;\r\n        } else {\r\n            _withdrawGen = plyr_[_pID].gen;\r\n            \r\n            plyrRnds_[_pID].genWithdraw = _playerGenWithdraw.add(plyr_[_pID].gen);\r\n        }\r\n        \r\n        // from vaults \r\n        uint256 _earnings = (plyr_[_pID].win)\r\n                            .add(_withdrawGen)\r\n                            .add(plyr_[_pID].aff)\r\n                            .add(plyr_[_pID].tokenShare);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n            plyr_[_pID].tokenShare = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n    \r\n    /**\r\n     * @dev prepares compression data and fires event for buy or reload tx's\r\n     */\r\n    function endTx(uint256 _eth, uint256 _keys, IBCLotteryDatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        uint256 _pot = round_.pot;\r\n        \r\n        round_.firstKeyShare = ((round_.keys.mul(95)) / 100);\r\n        uint256 _finalShareAmount = (round_.keys).sub(round_.firstKeyShare);\r\n        round_.eachKeyCanShare = ((((_pot * 3) / 5).mul(1000000000000000000)) / _finalShareAmount);\r\n        \r\n        uint256 _ticketPrice = ticketRecord_[msg.sender].ticketPrice;\r\n        \r\n        userPaidIn_[msg.sender] = userPaidIn_[msg.sender] + _ticketPrice;\r\n        actualTokenRaised_ = actualTokenRaised_ + _ticketPrice;\r\n        \r\n        ibcToken_.transfer(officialWallet_, (_ticketPrice / 2));\r\n        ibcToken_.transfer(devATeamWallet_, (_ticketPrice / 4));\r\n        \r\n        // calculate share per token\r\n        // origin: ((((round_.eth) / 10).mul(88)) / 100)\r\n        uint256 totalTokenShare = (((round_.eth).mul(88)) / 1000);\r\n        round_.tokenShare = ((totalTokenShare.mul(1000000000000000000)) / (actualTokenRaised_));\r\n        \r\n        devATeamWallet_.transfer(((_eth.mul(12)) / 100));\r\n        \r\n        ticketRecord_[msg.sender].hasTicket = false;\r\n        \r\n        emit IBCLotteryEvents.onEndTx\r\n        (\r\n            msg.sender,\r\n            _eth,\r\n            _keys,\r\n            _eventData_.winnerAddr,\r\n            _eventData_.amountWon,\r\n            _eventData_.newPot,\r\n            _eventData_.genAmount,\r\n            _eventData_.potAmount\r\n        );\r\n    }\r\n    \r\n    function getRandomNumber() \r\n        view\r\n        internal\r\n        returns\r\n        (uint8)\r\n    {\r\n        uint256 _timeLeft = getTimeLeft();\r\n        return uint8(uint256(keccak256(\r\n            abi.encodePacked(\r\n            block.timestamp, \r\n            block.difficulty, \r\n            block.coinbase,\r\n            _timeLeft,\r\n            msg.sender\r\n            )))%256);\r\n    }\r\n    \r\n    function hasValidTicket()\r\n        view\r\n        public\r\n        returns\r\n        (bool)\r\n    {\r\n        address _buyer = msg.sender;\r\n        uint256 _timeLeft = getTimeLeft();\r\n        \r\n        return hasValidTicketCore(_buyer, _timeLeft);\r\n    }\r\n    \r\n    /**\r\n     *    ___                                            _       \r\n     *   /___\\__      ___ __   ___ _ __       ___  _ __ | |_   _ \r\n     *  //  //\\ \\ /\\ / / '_ \\ / _ \\ '__|____ / _ \\| '_ \\| | | | |\r\n     * / \\_//  \\ V  V /| | | |  __/ | |_____| (_) | | | | | |_| |\r\n     * \\___/    \\_/\\_/ |_| |_|\\___|_|        \\___/|_| |_|_|\\__, |\r\n     *                                                     |___/ \r\n     * */\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs \r\n     * have time to set things up on the web end                            **/\r\n    bool public activated_ = false;\r\n    function activate()\r\n        onlyOwner(msg.sender)\r\n        public\r\n    {\r\n        // can only be ran once\r\n        require(activated_ == false, \"IBCLottery already activated\");\r\n        \r\n        // activate the contract \r\n        activated_ = true;\r\n        \r\n        // lets start first round\r\n\t\trID_ = 1;\r\n        round_.strt = now;\r\n        round_.end = now + rndInit_;\r\n    }\r\n}\r\n\r\n/**\r\n *   __ _                   _                  \r\n *  / _\\ |_ _ __ _   _  ___| |_ _   _ _ __ ___ \r\n *  \\ \\| __| '__| | | |/ __| __| | | | '__/ _ \\\r\n *  _\\ \\ |_| |  | |_| | (__| |_| |_| | | |  __/\r\n *  \\__/\\__|_|   \\__,_|\\___|\\__|\\__,_|_|  \\___|\r\n * */\r\n\r\nlibrary IBCLotteryDatasets {\r\n    struct EventReturns {\r\n        address winnerAddr;         // winner address\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 tokenShare; // earning from token share\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n        bool ibcRefund;\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask\r\n        bool tokenShareCalc; // if tokenShare value has been migrate.\r\n        mapping(uint256 => BoughtRecord) boughtRecord;\r\n        uint256 boughtTime;\r\n        uint256 genWithdraw;\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        bool firstPlayerIn;\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 tokenShare; // how many eth user share per token send in.\r\n        uint256 firstKeyShare;\r\n        uint256 eachKeyCanShare;\r\n        uint256 overEarningMask;\r\n    }\r\n    struct TeamFee {\r\n        uint256 gen;    // % of buy in thats paid to key holders of current round\r\n    }\r\n    struct BoughtRecord {\r\n        uint256 lastKey;\r\n        uint256 amount;\r\n    }\r\n}\r\n\r\n/**\r\n *                       ___      _            _       _   _             \r\n *    /\\ /\\___ _   _    / __\\__ _| | ___ _   _| | __ _| |_(_) ___  _ __  \r\n *   / //_/ _ \\ | | |  / /  / _` | |/ __| | | | |/ _` | __| |/ _ \\| '_ \\ \r\n *  / __ \\  __/ |_| | / /__| (_| | | (__| |_| | | (_| | |_| | (_) | | | |\r\n *  \\/  \\/\\___|\\__, | \\____/\\__,_|_|\\___|\\__,_|_|\\__,_|\\__|_|\\___/|_| |_|\r\n *             |___/                                                     \r\n * */\r\nlibrary IBCLotteryKeysCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n/**\r\n *  __        __                   _   _     \r\n * / _\\ __ _ / _| ___  /\\/\\   __ _| |_| |__  \r\n * \\ \\ / _` | |_ / _ \\/    \\ / _` | __| '_ \\ \r\n * _\\ \\ (_| |  _|  __/ /\\/\\ \\ (_| | |_| | | |\r\n * \\__/\\__,_|_|  \\___\\/    \\/\\__,_|\\__|_| |_|\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devATeamWallet_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRaised_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"refundTicket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devBTeamWallet_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTicketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"tokenShareCalc\",\"type\":\"bool\"},{\"name\":\"boughtTime\",\"type\":\"uint256\"},{\"name\":\"genWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPaidIn_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actualTokenRaised_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ibcToken_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserPaidIn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasValidTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"tokenShare\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"ibcRefund\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"officialWallet_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ibcoin\",\"type\":\"address\"},{\"name\":\"_officialWallet\",\"type\":\"address\"},{\"name\":\"_devATeamWallet\",\"type\":\"address\"},{\"name\":\"_devBTeamWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BuyTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyTicketAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundAmount\",\"type\":\"uint256\"}],\"name\":\"onRefundTicket\",\"type\":\"event\"}]","ContractName":"IBCLotteryGame","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000decf3a00e37bada548ec438dcef99b43d7f9f67d000000000000000000000000e49c794d9eb5ce8e72c52ab4dc7ccb233aa7eb7c000000000000000000000000b034209c57134625cd95f8843e504bd0fa8664e50000000000000000000000002ecbd107c3d3adc43eef22ee07b0401df11e9472","Library":"","SwarmSource":"bzzr://39637a56368ec4e6764247313145b5d66c549bcb0c737f9f2a0c12a4d18afbd4"}]}