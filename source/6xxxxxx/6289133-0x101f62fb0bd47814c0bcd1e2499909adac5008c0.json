{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/Upcoin.sol\r\n\r\ncontract Upcoin {\r\n    uint8 public decimals = 18;\r\n\r\n    function isUpcoin() public pure returns (bool);\r\n    function transferOrigin(address _to, uint256 _value) public returns (bool);\r\n}\r\n\r\n// File: contracts/Lottery.sol\r\n\r\ncontract Lottery is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event LotteryFinished();\r\n    event Roll(address indexed participant, uint256 prize);\r\n\r\n    struct Prize {\r\n        uint256 chance;\r\n        uint256 left;\r\n        uint256 min;\r\n        uint256 max;\r\n    }\r\n\r\n    bool public lotteryFinished = false;\r\n\r\n    uint256 private randomCount = 0;\r\n\r\n    Prize[] private prizes;\r\n    Upcoin private upcoin;\r\n\r\n\r\n    modifier canRoll() {\r\n        require(!lotteryFinished, \"Lottery already finished\");\r\n        _;\r\n    }\r\n\r\n    modifier hasPrizes() {\r\n        uint256 left = prizes[0].left;\r\n\r\n        for (uint256 i = 1; i < prizes.length; i = i.add(1)) {\r\n            if (prizes[i].left > left) {\r\n                left = prizes[i].left;\r\n            }\r\n        }\r\n\r\n        require(left > 0, \"No more prizes left\");\r\n        _;\r\n    }\r\n\r\n    modifier isUpcoin() {\r\n        require(address(upcoin) != address(0), \"Token address must be not null\");\r\n        require(upcoin.isUpcoin(), \"Token must be Upcoin instance\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _address) public {\r\n        upcoin = Upcoin(_address);\r\n\r\n        prizes.push(Prize(2, 1, 500000, 500000));\r\n        prizes.push(Prize(4, 3, 12001, 75000));\r\n        prizes.push(Prize(6, 6, 5001, 12000));\r\n        prizes.push(Prize(10, 40, 3001, 5000));\r\n        prizes.push(Prize(15, 50, 1001, 3000));\r\n        prizes.push(Prize(18, 400, 501, 1000));\r\n        prizes.push(Prize(20, 500, 251, 500));\r\n        prizes.push(Prize(25, 29000, 100, 250));\r\n    }\r\n\r\n    function finishLottery() public canRoll onlyOwner returns (bool) {\r\n        lotteryFinished = true;\r\n\r\n        emit LotteryFinished();\r\n\r\n        return true;\r\n    }\r\n\r\n    function getRandomPrize() private returns (Prize) {\r\n        uint256 chance = randomMinMax(0, 100);\r\n\r\n        uint256 index = 0;\r\n        uint256 percent = 0;\r\n\r\n        while (prizes[index].left == 0) {\r\n            percent = percent.add(prizes[index].chance);\r\n\r\n            index = index.add(1);\r\n        }\r\n\r\n        Prize memory prize = prizes[index];\r\n\r\n        uint256 start = index.add(1);\r\n\r\n        if (start < prizes.length && chance > percent + prize.chance) {\r\n            percent = percent.add(prize.chance);\r\n\r\n            for (uint256 i = start; i < prizes.length; i = i.add(1)) {\r\n                prize.chance = prizes[i].chance;\r\n\r\n                if (prizes[i].left > 0 && chance <= percent + prize.chance) {\r\n                    prize = prizes[i];\r\n\r\n                    index = i;\r\n\r\n                    break;\r\n                } else {\r\n                    percent = percent.add(prize.chance);\r\n                }\r\n            }\r\n        }\r\n\r\n        prize.left = prize.left.sub(1);\r\n\r\n        prizes[index] = prize;\r\n\r\n        return prize;\r\n    }\r\n\r\n    function getRandomAmount(uint256 _min, uint256 _max) private returns (uint256) {\r\n        return randomMinMax(_min, _max) * 10 ** uint256(upcoin.decimals());\r\n    }\r\n\r\n    function random() private returns (uint256) {\r\n        uint256 randomness = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), randomCount)));\r\n\r\n        randomCount = randomCount.add(1);\r\n\r\n        return randomness;\r\n    }\r\n\r\n    function randomMinMax(uint256 _min, uint256 _max) private returns (uint256) {\r\n        if (_min == _max) {\r\n            return _max;\r\n        }\r\n\r\n        if (_min > _max) {\r\n            (_min, _max) = (_max, _min);\r\n        }\r\n\r\n        uint256 value = random() % _max;\r\n\r\n        if (value < _min) {\r\n            value = _min + random() % (_max - _min);\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    function roll(address _address) public onlyOwner canRoll hasPrizes isUpcoin returns (bool) {\r\n        require(_address != address(0), \"Participant address must be not null\");\r\n\r\n        Prize memory prize = getRandomPrize();\r\n\r\n        uint256 amount = getRandomAmount(prize.min, prize.max);\r\n\r\n        upcoin.transferOrigin(_address, amount);\r\n\r\n        emit Roll(_address, amount);\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"roll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LotteryFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"Roll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ba8875544fc74999aee429fb0c80c78dc394f217","Library":"","SwarmSource":"bzzr://b53009a9bc51ef2f4fddf6ce4b0a3777792671312ab6e0af5792788df6969556"}]}