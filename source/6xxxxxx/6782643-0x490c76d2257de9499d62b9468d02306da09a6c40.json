{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\ninterface OraclizeResolverI {\r\n    function remoteSetWinner(uint _gameId, string _oraclizeSource, uint _callback_wei, uint _callback_gas_limit) external;\r\n    function eventSetWinner(uint _gameId, address _verityAddress, uint _verityResultIndex) external;\r\n}\r\n\r\n\r\ncontract Bet0xgameMaster {\r\n    address public owner;\r\n    address public resolverAddress;\r\n\r\n    mapping(bool => uint) boolMapping;\r\n\r\n    string constant draw = \"draw\";\r\n\r\n    uint public totalBetPool;\r\n\r\n    struct PlayerBet {\r\n        uint betAmount;\r\n        uint team;\r\n        bool withdrawn;\r\n    }\r\n\r\n    struct PlayerData {\r\n        uint totalBetAmount;\r\n        uint totalWithdrawn;\r\n    }\r\n    mapping(address => PlayerData) playerData;\r\n\r\n    struct Game {\r\n        uint WINNER;\r\n        uint loserOne;\r\n        uint loserTwo;\r\n        string teamOne;\r\n        string teamTwo;\r\n\r\n        string description;\r\n        string oddsApi;\r\n\r\n        string oraclizeSource;\r\n\r\n        address verityAddress;\r\n        uint verityResultIndex;\r\n\r\n        bytes32 category;\r\n        bytes32 subcategory;\r\n\r\n        uint betsCloseAt;\r\n        uint endsAt;\r\n\r\n        uint gameId;\r\n        uint balance;\r\n        uint totalPool;\r\n\r\n        bool drawPossible;\r\n\r\n        uint withdrawAfter;\r\n\r\n        mapping(uint => mapping(address => uint)) book;\r\n        mapping(uint => uint) oddsMapping;\r\n        mapping(string => uint) teamMapping;\r\n        mapping(address => mapping(uint => PlayerBet)) playerBets;\r\n    }\r\n    Game[] game;\r\n\r\n    /// Events\r\n    event PlayerJoined(\r\n        uint indexed gameId,\r\n        address indexed playerAddress,\r\n        uint betAmount,\r\n        uint team\r\n    );\r\n\r\n    event RewardWithdrawn(\r\n        uint indexed gameId,\r\n        address indexed withdrawer,\r\n        uint withdrawnAmount\r\n    );\r\n\r\n    event WinningTeamSet(\r\n        uint indexed gameId,\r\n        string team\r\n    );\r\n\r\n    event NewGame(\r\n        uint indexed gameId,\r\n        string teamOne,\r\n        string teamTwo,\r\n        uint betsCloseAt\r\n    );\r\n\r\n    event BetFailed(\r\n        uint indexed gameId,\r\n        address indexed playerAddress,\r\n        uint betAmount,\r\n        uint team\r\n    );\r\n\r\n    event GameInvalidated(\r\n        uint gameId\r\n    );\r\n\r\n    /// Modifiers\r\n    modifier onlyOwner {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only owner can do this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidTeamName(uint _gameId, string _team) {\r\n        require(\r\n            keccak256(bytes(_team)) == keccak256(bytes(game[_gameId].teamOne)) ||\r\n            keccak256(bytes(_team)) == keccak256(bytes(game[_gameId].teamTwo)) ||\r\n            keccak256(bytes(_team)) == keccak256(bytes(draw)),\r\n            \"Not a valid team name for game.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidTeam(uint _team) {\r\n        require(\r\n            _team > 0 &&\r\n            _team <= 3,\r\n            \"Not a valid team identifier.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterEndTime(uint _gameId) {\r\n        require(\r\n            now >= game[_gameId].endsAt,\r\n            \"Game not ended yet.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterWithdrawTime(uint _gameId) {\r\n        require(\r\n            now >= game[_gameId].withdrawAfter,\r\n            \"Can't withdraw remaining rewards yet.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfGameValid(uint _gameId) {\r\n        require(\r\n            game[_gameId].betsCloseAt > 0,\r\n            \"Game not valid\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfWinnerIsMissing(uint _gameId) {\r\n        require(\r\n            game[_gameId].WINNER == 0,\r\n            \"Winner already set.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfWinnerIsSet(uint _gameId) {\r\n        require(\r\n            game[_gameId].WINNER != 0,\r\n            \"Winner not set.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier endsAtAfterBetsCloseAt(uint _betsCloseAt, uint _endsAt) {\r\n        require(\r\n            _betsCloseAt < _endsAt,\r\n            \"Bets can't close after game ends.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyBeforeBetsCloseAt(uint _gameId) {\r\n        require(\r\n            now < game[_gameId].betsCloseAt,\r\n            \"Bets already closed.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyResolver {\r\n        require(\r\n            msg.sender == resolverAddress || msg.sender == address(this),\r\n            \"Only resolver can do this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// Constructor\r\n    constructor(address _resolverAddress) public {\r\n        owner = msg.sender;\r\n        resolverAddress = _resolverAddress;\r\n\r\n        buildBoolMapping();\r\n    }\r\n\r\n    /// Public functions\r\n    function createGame(\r\n        string _teamOne,\r\n        string _teamTwo,\r\n        uint _endsAt,\r\n        uint _betsCloseAt,\r\n        string _oraclizeSource,\r\n        address _verityAddress,\r\n        uint _verityResultIndex,\r\n        string _oddsApi,\r\n        bytes32[2] _categories,\r\n        bool _drawPossible,\r\n        string _description\r\n    )\r\n        public\r\n        onlyOwner\r\n        endsAtAfterBetsCloseAt(_betsCloseAt, _endsAt)\r\n    {\r\n        Game memory _game;\r\n\r\n        _game.gameId = game.length;\r\n        _game.teamOne = _teamOne;\r\n        _game.teamTwo = _teamTwo;\r\n        _game.betsCloseAt = _betsCloseAt;\r\n        _game.endsAt = _endsAt;\r\n        _game.oddsApi = _oddsApi;\r\n        _game.category = _categories[0];\r\n        _game.subcategory = _categories[1];\r\n        _game.drawPossible = _drawPossible;\r\n        _game.description = _description;\r\n        _game.verityAddress = _verityAddress;\r\n        _game.verityResultIndex = _verityResultIndex;\r\n        _game.oraclizeSource = _oraclizeSource;\r\n\r\n        _game.withdrawAfter = _endsAt + 1 weeks;\r\n\r\n        game.push(_game);\r\n\r\n        buildTeamMapping(_game.gameId);\r\n\r\n        emit NewGame(\r\n            _game.gameId,\r\n            _teamOne,\r\n            _teamTwo,\r\n            _betsCloseAt\r\n        );\r\n    }\r\n\r\n    function getGameLength() public view returns(uint) {\r\n        return game.length;\r\n    }\r\n\r\n    function getGame(uint _gameId) public view returns(string, string, bool, uint, uint, uint, uint, string, string) {\r\n        Game storage _game = game[_gameId];\r\n\r\n        return (\r\n            _game.teamOne,\r\n            _game.teamTwo,\r\n            _game.drawPossible,\r\n            _game.WINNER,\r\n            _game.betsCloseAt,\r\n            _game.endsAt,\r\n            _game.totalPool,\r\n            _game.oddsApi,\r\n            _game.description\r\n        );\r\n    }\r\n\r\n    // Returns only first 32 characters of each team's name\r\n    function getGames(uint[] _gameIds) public view returns(\r\n        uint[], bytes32[], bytes32[], bool[], uint[], uint[]\r\n    ) {\r\n        bytes32[] memory _teamOne = new bytes32[](_gameIds.length);\r\n        bytes32[] memory _teamTwo = new bytes32[](_gameIds.length);\r\n        uint[] memory _WINNER = new uint[](_gameIds.length);\r\n        uint[] memory _betsCloseAt = new uint[](_gameIds.length);\r\n\r\n        bool[] memory _drawPossible = new bool[](_gameIds.length);\r\n\r\n        for(uint i = 0; i < _gameIds.length; ++i) {\r\n            _teamOne[i] = strToBytes32(game[_gameIds[i]].teamOne);\r\n            _teamTwo[i] = strToBytes32(game[_gameIds[i]].teamTwo);\r\n            _WINNER[i] = game[_gameIds[i]].WINNER;\r\n            _betsCloseAt[i] = game[_gameIds[i]].betsCloseAt;\r\n            _drawPossible[i] = game[_gameIds[i]].drawPossible;\r\n\r\n        }\r\n\r\n        return (\r\n            _gameIds,\r\n            _teamOne,\r\n            _teamTwo,\r\n            _drawPossible,\r\n            _WINNER,\r\n            _betsCloseAt\r\n        );\r\n    }\r\n\r\n    function getGamesMeta(uint[] _gameIds) public view returns(\r\n        uint[], bytes32[], bytes32[], bool[], bool[]\r\n    ) {\r\n        bytes32[] memory _category = new bytes32[](_gameIds.length);\r\n        bytes32[] memory _subcategory = new bytes32[](_gameIds.length);\r\n        bool[] memory _hasOddsApi = new bool[](_gameIds.length);\r\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\r\n\r\n        for(uint i = 0; i < _gameIds.length; ++i) {\r\n            _category[i] = game[_gameIds[i]].category;\r\n            _subcategory[i] = game[_gameIds[i]].subcategory;\r\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\r\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\r\n        }\r\n\r\n        return (\r\n            _gameIds,\r\n            _category,\r\n            _subcategory,\r\n            _hasOddsApi,\r\n            _hasDescription\r\n        );\r\n    }\r\n\r\n    function getGamesPool(uint[] _gameIds) public view returns(\r\n        uint[], uint[], uint[], uint[]\r\n    ) {\r\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\r\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\r\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\r\n\r\n        for(uint i = 0; i < _gameIds.length; ++i) {\r\n            _oddsOne[i] = game[_gameIds[i]].oddsMapping[1];\r\n            _oddsTwo[i] = game[_gameIds[i]].oddsMapping[2];\r\n            _oddsDraw[i] = game[_gameIds[i]].oddsMapping[3];\r\n        }\r\n\r\n        return (\r\n            _gameIds,\r\n            _oddsOne,\r\n            _oddsTwo,\r\n            _oddsDraw\r\n        );\r\n    }\r\n\r\n    function getGameResolverData(uint _gameId) public view returns(string, address, uint) {\r\n        Game storage _game = game[_gameId];\r\n\r\n        return(\r\n            _game.oraclizeSource,\r\n            _game.verityAddress,\r\n            _game.verityResultIndex\r\n        );\r\n    }\r\n\r\n    function invalidateGame(uint _gameId)\r\n        public\r\n        onlyOwner\r\n        onlyIfWinnerIsMissing(_gameId)\r\n    {\r\n        Game storage _game = game[_gameId];\r\n\r\n        _game.betsCloseAt = 0;\r\n        _game.endsAt = 0;\r\n        _game.withdrawAfter = now + 1 weeks;\r\n\r\n        emit GameInvalidated(_gameId);\r\n    }\r\n\r\n    function bet(uint _gameId, uint _team)\r\n        public\r\n        payable\r\n    {\r\n        storeBet(_gameId, _team, msg.value);\r\n        playerData[msg.sender].totalBetAmount += msg.value;\r\n        totalBetPool += msg.value;\r\n    }\r\n\r\n    function multiBet(uint[] _gameIds, uint[] _teams, uint[] _amounts)\r\n        public\r\n        payable\r\n    {\r\n        require(\r\n            _gameIds.length == _teams.length &&\r\n            _gameIds.length == _amounts.length,\r\n            \"Lengths do not match.\"\r\n        );\r\n\r\n        uint _betsNum = _gameIds.length;\r\n        uint _balance = msg.value;\r\n\r\n        for(uint i = 0; i < _betsNum; ++i) {\r\n            if (_balance >= _amounts[i]) {\r\n                storeBet(_gameIds[i], _teams[i], _amounts[i]);\r\n                _balance -= _amounts[i];\r\n            } else {\r\n                revert(\"Not enough balance sent.\");\r\n            }\r\n        }\r\n\r\n        if (_balance > 0) {\r\n            msg.sender.transfer(_balance);\r\n            playerData[msg.sender].totalBetAmount += (msg.value - _balance);\r\n            totalBetPool += (msg.value - _balance);\r\n        }\r\n    }\r\n\r\n    function withdrawReward(uint _gameId)\r\n        public\r\n        onlyIfGameValid(_gameId)\r\n        onlyAfterEndTime(_gameId)\r\n        onlyIfWinnerIsSet(_gameId)\r\n    {\r\n        Game storage _game = game[_gameId];\r\n\r\n        uint betAmount = _game.book[_game.WINNER][msg.sender];\r\n        if (betAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        uint reward = betAmount + (\r\n            betAmount *\r\n            (_game.oddsMapping[_game.loserOne] + _game.oddsMapping[_game.loserTwo]) /\r\n            _game.oddsMapping[_game.WINNER]\r\n        );\r\n\r\n        if (_game.balance < reward) {\r\n            revert(\"Not enough balance on game. Contact 0xgame.\");\r\n        }\r\n        address(msg.sender).transfer(reward);\r\n        _game.balance -= reward;\r\n        playerData[msg.sender].totalWithdrawn += reward;\r\n\r\n        _game.playerBets[msg.sender][_game.WINNER].withdrawn = true;\r\n        _game.book[_game.WINNER][msg.sender] = 0;\r\n\r\n        emit RewardWithdrawn(_gameId, msg.sender, reward);\r\n    }\r\n\r\n    function multiWithdrawReward(uint[] _gameIds)\r\n        public\r\n    {\r\n        for (uint i = 0; i < _gameIds.length; ++i) {\r\n            withdrawReward(_gameIds[i]);\r\n        }\r\n    }\r\n\r\n    function withdrawInvalidated(uint _gameId)\r\n        public\r\n    {\r\n        Game storage _game = game[_gameId];\r\n\r\n        require(\r\n            _game.betsCloseAt == 0,\r\n            \"Game not invalidated.\"\r\n        );\r\n\r\n        uint[3][3] memory _playerData = getPlayerDataForGame(_gameId, msg.sender);\r\n\r\n        uint _totalBetAmount =\r\n            _playerData[0][1] +\r\n            _playerData[1][1] +\r\n            _playerData[2][1];\r\n\r\n        address(msg.sender).transfer(_totalBetAmount);\r\n\r\n        _game.playerBets[msg.sender][1].betAmount = 0;\r\n        _game.playerBets[msg.sender][2].betAmount = 0;\r\n        _game.playerBets[msg.sender][3].betAmount = 0;\r\n    }\r\n\r\n    function remoteSetWinner(uint _gameId, uint _callback_wei, uint _callback_gas_limit)\r\n        public\r\n        onlyAfterEndTime(_gameId)\r\n        onlyIfWinnerIsMissing(_gameId)\r\n    {\r\n        if (game[_gameId].verityAddress == 0x0) {\r\n            OraclizeResolverI(resolverAddress).remoteSetWinner(\r\n                _gameId,\r\n                game[_gameId].oraclizeSource,\r\n                _callback_wei,\r\n                _callback_gas_limit\r\n            );\r\n        } else {\r\n            OraclizeResolverI(resolverAddress).eventSetWinner(_gameId, game[_gameId].verityAddress, game[_gameId].verityResultIndex);\r\n        }\r\n    }\r\n\r\n    function callback(uint _gameId, string _result)\r\n        external\r\n        onlyResolver\r\n        onlyValidTeamName(_gameId, _result)\r\n    {\r\n        game[_gameId].WINNER = game[_gameId].teamMapping[_result];\r\n        emit WinningTeamSet(_gameId, _result);\r\n        setLosers(_gameId);\r\n    }\r\n\r\n    //  see private method buildTeamMapping, buildBoolMapping\r\n    //  first element in the nested array represents the team user betted on:\r\n    //    (teamOne -> 1, teamTwo -> 2, draw -> 3)\r\n    //  second element in nested array is the bet amount\r\n    //  third element in nested array represents withdrawal status:\r\n    //    (false -> 0, true -> 1)\r\n    //  additionally (applies to first level elements):\r\n    //    first array holds player data for teamOne\r\n    //    second array holds player data for teamTwo\r\n    //    third array holds pleyer data for draw\r\n    function getPlayerDataForGame(uint _gameId, address _playerAddress) public view returns(uint[3][3]) {\r\n        Game storage _game = game[_gameId];\r\n\r\n        return [\r\n            [\r\n                1,\r\n                _game.playerBets[_playerAddress][1].betAmount,\r\n                boolMapping[_game.playerBets[_playerAddress][1].withdrawn]\r\n            ],\r\n            [\r\n                2,\r\n                _game.playerBets[_playerAddress][2].betAmount,\r\n                boolMapping[_game.playerBets[_playerAddress][2].withdrawn]\r\n            ],\r\n            [\r\n                3,\r\n                _game.playerBets[_playerAddress][3].betAmount,\r\n                boolMapping[_game.playerBets[_playerAddress][3].withdrawn]\r\n            ]\r\n        ];\r\n    }\r\n\r\n    function getPlayerData(address _playerAddress) public view returns(uint[2]) {\r\n        return [\r\n            playerData[_playerAddress].totalBetAmount,\r\n            playerData[_playerAddress].totalWithdrawn\r\n        ];\r\n    }\r\n\r\n    function getGamePool(uint _gameId) public view returns(uint[3]) {\r\n        Game storage _game = game[_gameId];\r\n\r\n        return [\r\n            _game.oddsMapping[1],\r\n            _game.oddsMapping[2],\r\n            _game.oddsMapping[3]\r\n        ];\r\n    }\r\n\r\n    function addBalanceToGame(uint _gameId)\r\n        public\r\n        payable\r\n        onlyOwner\r\n    {\r\n        game[_gameId].balance += msg.value;\r\n    }\r\n\r\n    function withdrawRemainingRewards(uint _gameId)\r\n        public\r\n        onlyOwner\r\n        onlyAfterWithdrawTime(_gameId)\r\n    {\r\n        address(owner).transfer(game[_gameId].balance);\r\n    }\r\n\r\n    function setResolver(address _resolverAddress)\r\n        public\r\n        onlyOwner\r\n    {\r\n        resolverAddress = _resolverAddress;\r\n    }\r\n\r\n    function updateGameMeta(uint _gameId, string _oddsApi, string _description)\r\n        public\r\n        onlyOwner\r\n    {\r\n        Game storage _game = game[_gameId];\r\n\r\n        _game.oddsApi = _oddsApi;\r\n        _game.description = _description;\r\n    }\r\n\r\n    /// Private functions\r\n    function buildBoolMapping() private {\r\n        boolMapping[false] = 0;\r\n        boolMapping[true] = 1;\r\n    }\r\n\r\n    function buildTeamMapping(uint _gameId) internal {\r\n        game[_gameId].teamMapping[game[_gameId].teamOne] = 1;\r\n        game[_gameId].teamMapping[game[_gameId].teamTwo] = 2;\r\n        game[_gameId].teamMapping[draw] = 3;\r\n    }\r\n\r\n    function setLosers(uint _gameId) private returns(string) {\r\n        Game storage _game = game[_gameId];\r\n\r\n        if (_game.WINNER == 1) {\r\n            _game.loserOne = 2;\r\n            _game.loserTwo = 3;\r\n        } else if (_game.WINNER == 2) {\r\n            _game.loserOne = 1;\r\n            _game.loserTwo = 3;\r\n        } else if (_game.WINNER == 3) {\r\n            _game.loserOne = 1;\r\n            _game.loserTwo = 2;\r\n        }\r\n    }\r\n\r\n    function storeBet(uint _gameId, uint _team, uint _amount)\r\n        private\r\n        onlyIfGameValid(_gameId)\r\n        onlyValidTeam(_team)\r\n    {\r\n        Game storage _game = game[_gameId];\r\n\r\n        if (now > _game.betsCloseAt) {\r\n            emit BetFailed(_gameId, msg.sender, _amount, _team);\r\n            return;\r\n        }\r\n\r\n        _game.book[_team][msg.sender] += _amount;\r\n        _game.oddsMapping[_team] += _amount;\r\n        _game.balance += _amount;\r\n        _game.totalPool += _amount;\r\n\r\n        if (_game.playerBets[msg.sender][_team].betAmount == 0) {\r\n            _game.playerBets[msg.sender][_team] = PlayerBet(_amount, _team, false);\r\n        } else {\r\n            _game.playerBets[msg.sender][_team].betAmount += _amount;\r\n        }\r\n\r\n        emit PlayerJoined(_gameId, msg.sender, _amount, _team);\r\n    }\r\n\r\n    function strToBytes32(string _team) internal pure returns(bytes32 result) {\r\n        bytes memory _teamBytes;\r\n\r\n        _teamBytes = bytes(_team);\r\n        assembly {\r\n            result := mload(add(_teamBytes, 32))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalBetPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameIds\",\"type\":\"uint256[]\"},{\"name\":\"_teams\",\"type\":\"uint256[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"addBalanceToGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameIds\",\"type\":\"uint256[]\"}],\"name\":\"getGamesMeta\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"bool[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_callback_wei\",\"type\":\"uint256\"},{\"name\":\"_callback_gas_limit\",\"type\":\"uint256\"}],\"name\":\"remoteSetWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameIds\",\"type\":\"uint256[]\"}],\"name\":\"getGamesPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_resolverAddress\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getGameResolverData\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getGamePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_oddsApi\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"updateGameMeta\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameIds\",\"type\":\"uint256[]\"}],\"name\":\"getGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"bool[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getGame\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"invalidateGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"withdrawInvalidated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerDataForGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3][3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameIds\",\"type\":\"uint256[]\"}],\"name\":\"multiWithdrawReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_result\",\"type\":\"string\"}],\"name\":\"callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamOne\",\"type\":\"string\"},{\"name\":\"_teamTwo\",\"type\":\"string\"},{\"name\":\"_endsAt\",\"type\":\"uint256\"},{\"name\":\"_betsCloseAt\",\"type\":\"uint256\"},{\"name\":\"_oraclizeSource\",\"type\":\"string\"},{\"name\":\"_verityAddress\",\"type\":\"address\"},{\"name\":\"_verityResultIndex\",\"type\":\"uint256\"},{\"name\":\"_oddsApi\",\"type\":\"string\"},{\"name\":\"_categories\",\"type\":\"bytes32[2]\"},{\"name\":\"_drawPossible\",\"type\":\"bool\"},{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"withdrawRemainingRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolverAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"uint256\"}],\"name\":\"PlayerJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"name\":\"RewardWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"string\"}],\"name\":\"WinningTeamSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"teamOne\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"teamTwo\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"betsCloseAt\",\"type\":\"uint256\"}],\"name\":\"NewGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"uint256\"}],\"name\":\"BetFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"GameInvalidated\",\"type\":\"event\"}]","ContractName":"Bet0xgameMaster","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000018605a2efa250095c57909ca2f6be602925c03ed","Library":"","SwarmSource":"bzzr://56f76a146dba54b9e45777b38594494a9598adc726d38036a5e9cf26be0fe874"}]}