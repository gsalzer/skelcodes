{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n* ZETHR PRESENTS: SLOTS\r\n*\r\n* Written August 2018 by the Zethr team for zethr.game.\r\n*\r\n* Code framework written by Norsefire.\r\n* EV calculations written by TropicalRogue.\r\n* Audit and edits written by Klob.\r\n* Multiroll framework written by Etherguy.\r\n*\r\n* Rolling Odds:\r\n*   49.31%  Lose / 50.69% Win  \r\n*   35.64%  Two Matching Icons\r\n*       - 10.00% : 2.50x    Multiplier [Two Rockets]\r\n*       - 15.00% : 1.33x    Multiplier [Two Gold  Pyramids]\r\n*       - 15.00% : 1.00x    Multiplier [Two 'Z' Symbols]\r\n*       - 15.00% : 1.00x    Multiplier [Two 'T' Symbols]\r\n*       - 15.00% : 1.00x    Multiplier [Two 'H' Symbols]\r\n*       - 15.00% : 1.25x    Multiplier [Two Purple Pyramids]\r\n*       - 15.00% : 2.00x    Multiplier [Two Ether Icons]\r\n*   6.79%   One Of Each Pyramid\r\n*       - 1.50x  Multiplier\r\n*   2.94%   One Moon Icon\r\n*       - 2.50x Multiplier\r\n*   5.00%   Three Matching Icons\r\n*       - 03.00% : 13.00x   Multiplier [Three Rockets]\r\n*       - 05.00% : 09.00x   Multiplier [Three Gold  Pyramids]\r\n*       - 27.67% : 03.00x   Multiplier [Three 'Z' Symbols]\r\n*       - 27.67% : 03.00x   Multiplier [Three 'T' Symbols]\r\n*       - 27.67% : 03.00x   Multiplier [Three 'H' Symbols]\r\n*       - 05.00% : 07.50x   Multiplier [Three Purple Pyramids]\r\n*       - 04.00% : 11.00x   Multiplier [Three Ether Icons]\r\n*   0.28%   Z T H Prize\r\n*       - 20x Multiplier\r\n*   0.03%   Two Moon Icons\r\n*       - 50x  Multiplier\r\n*   0.0001% Three Moon Grand Jackpot\r\n*       - Jackpot Amount (variable)\r\n*\r\n*   From all of us at Zethr, thank you for playing!    \r\n*\r\n*/\r\n\r\n// Zethr Token Bankroll interface\r\ncontract ZethrTokenBankroll{\r\n  // Game request token transfer to player \r\n  function gameRequestTokens(address target, uint tokens) public;\r\n  function gameTokenAmount(address what) public returns (uint);\r\n}\r\n\r\n// Zether Main Bankroll interface\r\ncontract ZethrMainBankroll{\r\n  function gameGetTokenBankrollList() public view returns (address[7]);\r\n}\r\n\r\n// Zethr main contract interface\r\ncontract ZethrInterface{\r\n  function withdraw() public;\r\n}\r\n\r\n// Library for figuring out the \"tier\" (1-7) of a dividend rate\r\nlibrary ZethrTierLibrary{\r\n\r\n  function getTier(uint divRate) \r\n    internal \r\n    pure \r\n    returns (uint)\r\n  {\r\n    // Tier logic \r\n    // Returns the index of the UsedBankrollAddresses which should be used to call into to withdraw tokens \r\n        \r\n    // We can divide by magnitude\r\n    // Remainder is removed so we only get the actual number we want\r\n    uint actualDiv = divRate; \r\n    if (actualDiv >= 30){\r\n      return 6;\r\n    } else if (actualDiv >= 25){\r\n      return 5;\r\n    } else if (actualDiv >= 20){\r\n      return 4;\r\n    } else if (actualDiv >= 15){\r\n      return 3;\r\n    } else if (actualDiv >= 10){\r\n      return 2; \r\n    } else if (actualDiv >= 5){\r\n      return 1;\r\n    } else if (actualDiv >= 2){\r\n      return 0;\r\n    } else{\r\n      // Impossible\r\n      revert(); \r\n    }\r\n  }\r\n}\r\n\r\n// Contract that contains the functions to interact with the ZlotsJackpotHoldingContract\r\ncontract ZlotsJackpotHoldingContract {\r\n  function payOutWinner(address winner) public; \r\n  function getJackpot() public view returns (uint);\r\n}\r\n \r\n// Contract that contains the functions to interact with the bankroll system\r\ncontract ZethrBankrollBridge {\r\n  // Must have an interface with the main Zethr token contract \r\n  ZethrInterface Zethr;\r\n   \r\n  // Store the bankroll addresses \r\n  // address[0] is tier1: 2-5% \r\n  // address[1] is tier2: 5-10, etc\r\n  address[7] UsedBankrollAddresses; \r\n\r\n  // Mapping for easy checking\r\n  mapping(address => bool) ValidBankrollAddress;\r\n    \r\n  // Set up the tokenbankroll stuff \r\n  function setupBankrollInterface(address ZethrMainBankrollAddress) \r\n    internal \r\n  {\r\n    // Instantiate Zethr\r\n    Zethr = ZethrInterface(0xb9ab8eed48852de901c13543042204c6c569b811);\r\n\r\n    // Get the bankroll addresses from the main bankroll\r\n    UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList();\r\n    for(uint i=0; i<7; i++){\r\n      ValidBankrollAddress[UsedBankrollAddresses[i]] = true;\r\n    }\r\n  }\r\n    \r\n  // Require a function to be called from a *token* bankroll \r\n  modifier fromBankroll() {\r\n    require(ValidBankrollAddress[msg.sender], \"msg.sender should be a valid bankroll\");\r\n    _;\r\n  }\r\n    \r\n  // Request a payment in tokens to a user FROM the appropriate tokenBankroll \r\n  // Figure out the right bankroll via divRate \r\n  function RequestBankrollPayment(address to, uint tokens, uint tier) \r\n    internal \r\n  {\r\n    address tokenBankrollAddress = UsedBankrollAddresses[tier];\r\n    ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to, tokens);\r\n  }\r\n    \r\n  function getZethrTokenBankroll(uint divRate) \r\n    public \r\n    view \r\n    returns (ZethrTokenBankroll)\r\n  {\r\n    return ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)]);\r\n  }\r\n}\r\n\r\n// Contract that contains functions to move divs to the main bankroll\r\ncontract ZethrShell is ZethrBankrollBridge {\r\n\r\n  // Dump ETH balance to main bankroll\r\n  function WithdrawToBankroll() \r\n    public \r\n  {\r\n    address(UsedBankrollAddresses[0]).transfer(address(this).balance);\r\n  }\r\n\r\n  // Dump divs and dump ETH into bankroll\r\n  function WithdrawAndTransferToBankroll() \r\n    public \r\n  {\r\n    Zethr.withdraw();\r\n    WithdrawToBankroll();\r\n  }\r\n}\r\n\r\n// Zethr game data setup\r\n// Includes all necessary to run with Zethr\r\ncontract ZlotsMulti is ZethrShell {\r\n  using SafeMath for uint;\r\n\r\n  // ---------------------- Events\r\n\r\n  // Might as well notify everyone when the house takes its cut out.\r\n  event HouseRetrievedTake(\r\n    uint timeTaken,\r\n    uint tokensWithdrawn\r\n  );\r\n\r\n  // Fire an event whenever someone places a bet.\r\n  event TokensWagered(\r\n    address _wagerer,\r\n    uint _wagered\r\n  );\r\n\r\n  event LogResult(\r\n    address _wagerer,\r\n    uint _result,\r\n    uint _profit,\r\n    uint _wagered,\r\n    uint _category,\r\n    bool _win\r\n  );\r\n\r\n  // Result announcement events (to dictate UI output!)\r\n  event Loss(address _wagerer, uint _block);                  // Category 0\r\n  event ThreeMoonJackpot(address _wagerer, uint _block);      // Category 1\r\n  event TwoMoonPrize(address _wagerer, uint _block);          // Category 2\r\n  event ZTHPrize(address _wagerer, uint _block);              // Category 3\r\n  event ThreeZSymbols(address _wagerer, uint _block);         // Category 4\r\n  event ThreeTSymbols(address _wagerer, uint _block);         // Category 5\r\n  event ThreeHSymbols(address _wagerer, uint _block);         // Category 6\r\n  event ThreeEtherIcons(address _wagerer, uint _block);       // Category 7\r\n  event ThreePurplePyramids(address _wagerer, uint _block);   // Category 8\r\n  event ThreeGoldPyramids(address _wagerer, uint _block);     // Category 9\r\n  event ThreeRockets(address _wagerer, uint _block);          // Category 10\r\n  event OneMoonPrize(address _wagerer, uint _block);          // Category 11\r\n  event OneOfEachPyramidPrize(address _wagerer, uint _block); // Category 12\r\n  event TwoZSymbols(address _wagerer, uint _block);           // Category 13\r\n  event TwoTSymbols(address _wagerer, uint _block);           // Category 14\r\n  event TwoHSymbols(address _wagerer, uint _block);           // Category 15\r\n  event TwoEtherIcons(address _wagerer, uint _block);         // Category 16\r\n  event TwoPurplePyramids(address _wagerer, uint _block);     // Category 17\r\n  event TwoGoldPyramids(address _wagerer, uint _block);       // Category 18\r\n  event TwoRockets(address _wagerer, uint _block);            // Category 19    \r\n  event SpinConcluded(address _wagerer, uint _block);         // Debug event\r\n\r\n  // ---------------------- Modifiers\r\n\r\n  // Makes sure that player porfit can't exceed a maximum amount\r\n  // We use the max win here - 50x\r\n  modifier betIsValid(uint _betSize, uint divRate, uint8 spins) {\r\n    require(_betSize.div(spins).mul(50) <= getMaxProfit(divRate));\r\n    require(_betSize.div(spins) >= minBet);\r\n    _;\r\n  }\r\n\r\n  // Requires the game to be currently active\r\n  modifier gameIsActive {\r\n    require(gamePaused == false);\r\n    _;\r\n  }\r\n\r\n  // Require msg.sender to be owner\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner); \r\n    _;\r\n  }\r\n\r\n  // Requires msg.sender to be bankroll\r\n  modifier onlyBankroll {\r\n    require(msg.sender == bankroll);\r\n    _;\r\n  }\r\n\r\n  // Requires msg.sender to be owner or bankroll\r\n  modifier onlyOwnerOrBankroll {\r\n    require(msg.sender == owner || msg.sender == bankroll);\r\n    _;\r\n  }\r\n\r\n  // ---------------------- Variables\r\n\r\n  // Configurables\r\n  uint constant public maxProfitDivisor = 1000000;\r\n  uint constant public houseEdgeDivisor = 1000;\r\n  mapping (uint => uint) public maxProfit;\r\n  uint public maxProfitAsPercentOfHouse;\r\n  uint public minBet = 1e18;\r\n  address public zlotsJackpot;\r\n  address private owner;\r\n  address private bankroll;\r\n  bool public gamePaused;\r\n  bool public canMining = true;\r\n  uint public miningProfit = 100;\r\n  uint public minBetMining = 1e18;\r\n  // Trackers\r\n  uint  public totalSpins;\r\n  uint  public totalZTHWagered;\r\n  mapping (uint => uint) public contractBalance;\r\n    \r\n  // Is betting allowed? (Administrative function, in the event of unforeseen bugs)\r\n  //bool public gameActive;\r\n\r\n  // Bankroll & token addresses\r\n  address private ZTHTKNADDR;\r\n  address private ZTHBANKROLL;\r\n\r\n  // ---------------------- Functions \r\n\r\n  // Constructor; must supply bankroll address\r\n  constructor(address BankrollAddress) \r\n    public \r\n  {\r\n    // Set up the bankroll interface\r\n    setupBankrollInterface(BankrollAddress); \r\n\r\n    // Owner is deployer\r\n    owner = msg.sender;\r\n\r\n    // Default max profit to 5% of contract balance\r\n    ownerSetMaxProfitAsPercentOfHouse(500000);\r\n\r\n    // Set starting variables\r\n    bankroll      = ZTHBANKROLL;\r\n    //gameActive  = true;\r\n\r\n    // Init min bet (1 ZTH)\r\n    ownerSetMinBet(1e18);\r\n    \r\n    canMining = false;\r\n    miningProfit = 100;\r\n    minBetMining = 1e18;\r\n  }\r\n\r\n  // Zethr dividends gained are accumulated and sent to bankroll manually\r\n  function() public payable {  }\r\n\r\n  // If the contract receives tokens, bundle them up in a struct and fire them over to _spinTokens for validation.\r\n  struct TKN { address sender; uint value; }\r\n  function execute(address _from, uint _value, uint divRate, bytes _data) \r\n    public \r\n    fromBankroll gameIsActive\r\n    returns (bool)\r\n  {\r\n      TKN memory _tkn;\r\n      _tkn.sender = _from;\r\n      _tkn.value = _value;\r\n      _spinTokens(_tkn, divRate, uint8(_data[0]));\r\n      return true;\r\n  }\r\n\r\n  struct playerSpin {\r\n    uint192 tokenValue; // Token value in uint\r\n    uint48 blockn;      // Block number 48 bits\r\n    uint8 tier;\r\n    uint8 spins;\r\n    uint divRate;\r\n  }\r\n\r\n  // Mapping because a player can do one spin at a time\r\n  mapping(address => playerSpin) public playerSpins;\r\n\r\n  // Execute spin.\r\n  function _spinTokens(TKN _tkn, uint divRate, uint8 spins) \r\n    private gameIsActive\r\n    betIsValid(_tkn.value, divRate, spins)\r\n  {\r\n    //require(gameActive);\r\n    require(block.number <= ((2 ** 48) - 1));  // Current block number smaller than storage of 1 uint56\r\n    require(_tkn.value <= ((2 ** 192) - 1));\r\n    require(divRate < (2 ** 8 - 1)); // This should never throw \r\n    address _customerAddress = _tkn.sender;\r\n    uint    _wagered         = _tkn.value;\r\n\r\n    playerSpin memory spin = playerSpins[_tkn.sender];\r\n \r\n    // We update the contract balance *before* the spin is over, not after\r\n    // This means that we don't have to worry about unresolved rolls never resolving\r\n    // (we also update it when a player wins)\r\n    addContractBalance(divRate, _wagered);\r\n\r\n    // Cannot spin twice in one block\r\n    require(block.number != spin.blockn);\r\n\r\n    // If there exists a spin, finish it\r\n    if (spin.blockn != 0) {\r\n      _finishSpin(_tkn.sender);\r\n    }\r\n\r\n    // Set struct block number and token value\r\n    spin.blockn = uint48(block.number);\r\n    spin.tokenValue = uint192(_wagered.div(spins));\r\n    spin.tier = uint8(ZethrTierLibrary.getTier(divRate));\r\n    spin.divRate = divRate;\r\n    spin.spins = spins;\r\n\r\n    // Store the roll struct - 40k gas.\r\n    playerSpins[_tkn.sender] = spin;\r\n\r\n    // Increment total number of spins\r\n    totalSpins += spins;\r\n\r\n    // Total wagered\r\n    totalZTHWagered += _wagered;\r\n\r\n    // game mining\r\n    if(canMining && spin.tokenValue >= minBetMining){\r\n        uint miningAmout = SafeMath.div(SafeMath.mul(_wagered, miningProfit) , 10000);\r\n        RequestBankrollPayment(_tkn.sender, miningAmout, spin.divRate);\r\n    }\r\n\r\n    emit TokensWagered(_customerAddress, _wagered);\r\n  }\r\n\r\n  // Finish the current spin of a player, if they have one\r\n  function finishSpin() \r\n    public\r\n    gameIsActive\r\n    returns (uint[])\r\n  {\r\n    return _finishSpin(msg.sender);\r\n  }\r\n\r\n  // Stores the data for the roll (spin)\r\n  struct rollData {\r\n    uint win;\r\n    uint loss; \r\n    uint jp;\r\n  }\r\n\r\n  // Pay winners, update contract balance, send rewards where applicable.\r\n  function _finishSpin(address target)\r\n    private \r\n    returns (uint[])\r\n  {\r\n    playerSpin memory spin = playerSpins[target];\r\n\r\n    require(spin.tokenValue > 0); // No re-entrancy\r\n    require(spin.blockn != block.number);\r\n        \r\n    uint[] memory output = new uint[](spin.spins);\r\n    rollData memory outcomeTrack = rollData(0,0,0);\r\n    uint category = 0;\r\n    uint profit;\r\n    uint playerDivrate = spin.divRate;\r\n        \r\n    for(uint i=0; i<spin.spins; i++) {\r\n        \r\n      // If the block is more than 255 blocks old, we can't get the result\r\n      // Also, if the result has already happened, fail as well\r\n      uint result;\r\n      if (block.number - spin.blockn > 255) {\r\n        result = 1000000; // Can't win: default to largest number\r\n        output[i] = 1000000;\r\n      } else {\r\n        // Generate a result - random based ONLY on a past block (future when submitted).\r\n        // Case statement barrier numbers defined by the current payment schema at the top of the contract.\r\n        result = random(1000000, spin.blockn, target, i) + 1;\r\n        output[i] = result;\r\n      }\r\n\r\n      if (result > 506856) {\r\n        // Player has lost. Womp womp.\r\n\r\n        // Add one percent of player loss to the jackpot\r\n        // (do this by requesting a payout to the jackpot)\r\n        outcomeTrack.loss += spin.tokenValue/100;\r\n\r\n        emit Loss(target, spin.blockn);\r\n        emit LogResult(target, result, profit, spin.tokenValue, category, false);\r\n      } else if (result < 2) {\r\n        // Player has won the three-moon mega jackpot!\r\n      \r\n        // Get profit amount via jackpot\r\n        profit = ZlotsJackpotHoldingContract(zlotsJackpot).getJackpot();\r\n        category = 1;\r\n    \r\n        // Emit events\r\n        emit ThreeMoonJackpot(target, spin.blockn);\r\n        emit LogResult(target, result, profit, spin.tokenValue, category, true);\r\n\r\n        outcomeTrack.jp += 1;\r\n\r\n      } else {\r\n        if (result < 299) {\r\n          // Player has won a two-moon prize!\r\n          profit = SafeMath.mul(spin.tokenValue, 50);\r\n          category = 2;\r\n          emit TwoMoonPrize(target, spin.blockn);\r\n        } else if (result < 3128) {\r\n          // Player has won the Z T H prize!\r\n          profit = SafeMath.mul(spin.tokenValue, 20);\r\n          category = 3;\r\n          emit ZTHPrize(target, spin.blockn);\r\n        } else if (result < 16961) {\r\n          // Player has won a three Z symbol prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\r\n          category = 4;\r\n          emit ThreeZSymbols(target, spin.blockn);\r\n        } else if (result < 30794) {\r\n          // Player has won a three T symbol prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\r\n          category = 5;\r\n          emit ThreeTSymbols(target, spin.blockn);\r\n        } else if (result < 44627) {\r\n          // Player has won a three H symbol prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\r\n          category = 6;\r\n          emit ThreeHSymbols(target, spin.blockn);\r\n        } else if (result < 46627) {\r\n          // Player has won a three Ether icon prize!\r\n          profit = SafeMath.mul(spin.tokenValue, 11);\r\n          category = 7;\r\n          emit ThreeEtherIcons(target, spin.blockn);\r\n        } else if (result < 49127) {\r\n          // Player has won a three purple pyramid prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 75), 10);\r\n          category = 8;\r\n          emit ThreePurplePyramids(target, spin.blockn);\r\n        } else if (result < 51627) {\r\n          // Player has won a three gold pyramid prize!\r\n          profit = SafeMath.mul(spin.tokenValue, 9);\r\n          category = 9;\r\n          emit ThreeGoldPyramids(target, spin.blockn);\r\n        } else if (result < 53127) {\r\n          // Player has won a three rocket prize!\r\n          profit = SafeMath.mul(spin.tokenValue, 13);\r\n          category = 10;\r\n          emit ThreeRockets(target, spin.blockn);\r\n        } else if (result < 82530) {\r\n          // Player has won a one moon prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25),10);\r\n          category = 11;\r\n          emit OneMoonPrize(target, spin.blockn);\r\n        } else if (result < 150423) {\r\n          // Player has won a each-coloured-pyramid prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\r\n          category = 12;\r\n          emit OneOfEachPyramidPrize(target, spin.blockn);\r\n        } else if (result < 203888) {\r\n          // Player has won a two Z symbol prize!\r\n          profit = spin.tokenValue;\r\n          category = 13;\r\n          emit TwoZSymbols(target, spin.blockn);\r\n        } else if (result < 257353) {\r\n          // Player has won a two T symbol prize!\r\n          profit = spin.tokenValue;\r\n          category = 14;\r\n          emit TwoTSymbols(target, spin.blockn);\r\n        } else if (result < 310818) {\r\n          // Player has won a two H symbol prize!\r\n          profit = spin.tokenValue;\r\n          category = 15;\r\n          emit TwoHSymbols(target, spin.blockn);\r\n        } else if (result < 364283) {\r\n          // Player has won a two Ether icon prize!\r\n          profit = SafeMath.mul(spin.tokenValue, 2);\r\n          category = 16;\r\n          emit TwoEtherIcons(target, spin.blockn);\r\n        } else if (result < 417748) {\r\n          // Player has won a two purple pyramid prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125), 100);\r\n          category = 17;\r\n          emit TwoPurplePyramids(target, spin.blockn);\r\n        } else if (result < 471213) {\r\n          // Player has won a two gold pyramid prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 133), 100);\r\n          category = 18;\r\n          emit TwoGoldPyramids(target, spin.blockn);\r\n        } else {\r\n          // Player has won a two rocket prize!\r\n          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25), 10);\r\n          category = 19;\r\n          emit TwoRockets(target, spin.blockn);\r\n        }\r\n\r\n        uint newMaxProfit = getNewMaxProfit(playerDivrate, outcomeTrack.win);\r\n        if (profit > newMaxProfit){\r\n          profit = newMaxProfit;\r\n        }\r\n\r\n        emit LogResult(target, result, profit, spin.tokenValue, category, true);\r\n        outcomeTrack.win += profit;\r\n      }\r\n    }\r\n\r\n    playerSpins[target] = playerSpin(uint192(0), uint48(0), uint8(0), uint8(0),  uint(0));\r\n    if (outcomeTrack.jp > 0) {\r\n      for (i = 0; i < outcomeTrack.jp; i++) {\r\n        // In the weird case a player wins two jackpots, we of course pay them twice \r\n        ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target);\r\n      }\r\n    }\r\n\r\n    if (outcomeTrack.win > 0) {\r\n      RequestBankrollPayment(target, outcomeTrack.win, spin.tier);\r\n    }\r\n\r\n    if (outcomeTrack.loss > 0) {\r\n      // This loss is the loss to pay to the jackpot account \r\n      // The delta in contractBalance is already updated in a pending bet.\r\n      RequestBankrollPayment(zlotsJackpot, outcomeTrack.loss, spin.tier);\r\n    }\r\n            \r\n    emit SpinConcluded(target, spin.blockn);\r\n    return output;\r\n  }   \r\n\r\n  // Returns a random number using a specified block number\r\n  // Always use a FUTURE block number.\r\n  function maxRandom(uint blockn, address entropy, uint index) \r\n    private \r\n    view\r\n    returns (uint256 randomNumber) \r\n  {\r\n    return uint256(keccak256(\r\n        abi.encodePacked(\r\n          blockhash(blockn),\r\n          entropy,\r\n          index\r\n    )));\r\n  }\r\n\r\n  // Random helper\r\n  function random(uint256 upper, uint256 blockn, address entropy, uint index)\r\n    internal \r\n    view \r\n    returns (uint256 randomNumber)\r\n  {\r\n    return maxRandom(blockn, entropy, index) % upper;\r\n  }\r\n\r\n  // Sets max profit (internal)\r\n  function setMaxProfit(uint divRate) \r\n    internal \r\n  {\r\n    maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor; \r\n  } \r\n\r\n  // Gets max profit  \r\n  function getMaxProfit(uint divRate) \r\n    public \r\n    view \r\n    returns (uint) \r\n  {\r\n    return (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\r\n  }\r\n\r\n  function getNewMaxProfit(uint divRate, uint currentWin) \r\n    public \r\n    view \r\n    returns (uint) \r\n  {\r\n    return ((contractBalance[divRate] - currentWin) * maxProfitAsPercentOfHouse) / maxProfitDivisor;\r\n  }\r\n\r\n  // Subtracts from the contract balance tracking var\r\n  function subContractBalance(uint divRate, uint sub) \r\n    internal \r\n  {\r\n    contractBalance[divRate] = contractBalance[divRate].sub(sub);\r\n  }\r\n\r\n  // Adds to the contract balance tracking var\r\n  function addContractBalance(uint divRate, uint add) \r\n    internal \r\n  {\r\n    contractBalance[divRate] = contractBalance[divRate].add(add);\r\n  }\r\n  // Only owner adjust contract balance variable (only used for max profit calc)\r\n  function ownerUpdateContractBalance(uint newContractBalance, uint divRate) public\r\n  onlyOwner\r\n  {\r\n    contractBalance[divRate] = newContractBalance;\r\n  }\r\n  \r\n  function updateContractBalance(uint newContractBalance) public\r\n  onlyOwner\r\n  {\r\n    contractBalance[2] = newContractBalance;\r\n    setMaxProfit(2);\r\n    contractBalance[5] = newContractBalance;\r\n    setMaxProfit(5);\r\n    contractBalance[10] = newContractBalance;\r\n    setMaxProfit(10);\r\n    contractBalance[15] = newContractBalance;\r\n    setMaxProfit(15);\r\n    contractBalance[20] = newContractBalance;\r\n    setMaxProfit(20);\r\n    contractBalance[25] = newContractBalance;\r\n    setMaxProfit(25);\r\n    contractBalance[33] = newContractBalance;\r\n    setMaxProfit(33);\r\n  }  \r\n  // An EXTERNAL update of tokens should be handled here\r\n  // This is due to token allocation\r\n  // The game should handle internal updates itself (e.g. tokens are betted)\r\n  function bankrollExternalUpdateTokens(uint divRate, uint newBalance) \r\n    public \r\n    fromBankroll \r\n  {\r\n    contractBalance[divRate] = newBalance;\r\n    setMaxProfit(divRate);\r\n  }\r\n\r\n  // Set the new max profit as percent of house - can be as high as 20%\r\n  // (1,000,000 = 100%)\r\n  function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) \r\n    public\r\n    onlyOwner\r\n  {\r\n    // Restricts each bet to a maximum profit of 50% contractBalance\r\n    require(newMaxProfitAsPercent <= 500000);\r\n    maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\r\n    setMaxProfit(2);\r\n    setMaxProfit(5);\r\n    setMaxProfit(10);\r\n    setMaxProfit(15); \r\n    setMaxProfit(20);\r\n    setMaxProfit(25);\r\n    setMaxProfit(33);\r\n  }\r\n\r\n  // Only owner can set minBet\r\n  function ownerSetupBankrollInterface(address ZethrMainBankrollAddress) public\r\n  onlyOwner\r\n  {\r\n    setupBankrollInterface(ZethrMainBankrollAddress);\r\n  }  \r\n  function ownerSetMinBet(uint newMinimumBet) \r\n    public\r\n    onlyOwner\r\n  {\r\n    minBet = newMinimumBet;\r\n  }\r\n  function ownerPauseGame(bool newStatus) public\r\n  onlyOwner\r\n  {\r\n    gamePaused = newStatus;\r\n  }\r\n  function ownerSetCanMining(bool newStatus) public\r\n  onlyOwner\r\n  {\r\n    canMining = newStatus;\r\n  }\r\n  function ownerSetMiningProfit(uint newProfit) public\r\n  onlyOwner\r\n  {\r\n    miningProfit = newProfit;\r\n  }\r\n  function ownerSetMinBetMining(uint newMinBetMining) public\r\n  onlyOwner\r\n  {\r\n    minBetMining = newMinBetMining;\r\n  }    \r\n  // Only owner can set zlotsJackpot address\r\n  function ownerSetZlotsAddress(address zlotsAddress) \r\n    public\r\n    onlyOwner\r\n  {\r\n    zlotsJackpot = zlotsAddress;\r\n  }\r\n\r\n  // If, for any reason, betting needs to be paused (very unlikely), this will freeze all bets.\r\n  /*function pauseGame() \r\n    public \r\n    onlyOwnerOrBankroll \r\n  {\r\n    gameActive = false;\r\n  }\r\n\r\n  // The converse of the above, resuming betting if a freeze had been put in place.\r\n  function resumeGame() \r\n    public \r\n    onlyOwnerOrBankroll \r\n  {\r\n    gameActive = true;\r\n  }*/\r\n\r\n  // Administrative function to change the owner of the contract.\r\n  function changeOwner(address _newOwner) \r\n    public \r\n    onlyOwnerOrBankroll \r\n  {\r\n    owner = _newOwner;\r\n  }\r\n\r\n  // Administrative function to change the Zethr bankroll contract, should the need arise.\r\n  function changeBankroll(address _newBankroll) \r\n    public \r\n    onlyOwnerOrBankroll \r\n  {\r\n    bankroll = _newBankroll;\r\n  }\r\n\r\n  // Is the address that the token has come from actually ZTH?\r\n  function _zthToken(address _tokenContract) \r\n    private \r\n    view \r\n    returns (bool) \r\n  {\r\n    return _tokenContract == ZTHTKNADDR;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint a, uint b) \r\n    internal \r\n    pure \r\n    returns (uint) \r\n  {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint a, uint b) \r\n    internal \r\n    pure \r\n    returns (uint) \r\n  {\r\n    uint c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint a, uint b) \r\n    internal \r\n    pure \r\n    returns (uint) \r\n  {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint a, uint b) \r\n    internal \r\n    pure returns (uint) \r\n  {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalZTHWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawAndTransferToBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newProfit\",\"type\":\"uint256\"}],\"name\":\"ownerSetMiningProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canMining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerSpins\",\"outputs\":[{\"name\":\"tokenValue\",\"type\":\"uint192\"},{\"name\":\"blockn\",\"type\":\"uint48\"},{\"name\":\"tier\",\"type\":\"uint8\"},{\"name\":\"spins\",\"type\":\"uint8\"},{\"name\":\"divRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitAsPercentOfHouse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerSetCanMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zlotsJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxProfitAsPercent\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfitAsPercentOfHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractBalance\",\"type\":\"uint256\"},{\"name\":\"divRate\",\"type\":\"uint256\"}],\"name\":\"ownerUpdateContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"divRate\",\"type\":\"uint256\"},{\"name\":\"currentWin\",\"type\":\"uint256\"}],\"name\":\"getNewMaxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawToBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ZethrMainBankrollAddress\",\"type\":\"address\"}],\"name\":\"ownerSetupBankrollInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"zlotsAddress\",\"type\":\"address\"}],\"name\":\"ownerSetZlotsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"divRate\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSpins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishSpin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBetMining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBankroll\",\"type\":\"address\"}],\"name\":\"changeBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"divRate\",\"type\":\"uint256\"}],\"name\":\"getMaxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinBetMining\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBetMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"divRate\",\"type\":\"uint256\"}],\"name\":\"getZethrTokenBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractBalance\",\"type\":\"uint256\"}],\"name\":\"updateContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"divRate\",\"type\":\"uint256\"},{\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"bankrollExternalUpdateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"BankrollAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeTaken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensWithdrawn\",\"type\":\"uint256\"}],\"name\":\"HouseRetrievedTake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_wagered\",\"type\":\"uint256\"}],\"name\":\"TokensWagered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_result\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_wagered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_category\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_win\",\"type\":\"bool\"}],\"name\":\"LogResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"Loss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreeMoonJackpot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoMoonPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ZTHPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreeZSymbols\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreeTSymbols\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreeHSymbols\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreeEtherIcons\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreePurplePyramids\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreeGoldPyramids\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"ThreeRockets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"OneMoonPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"OneOfEachPyramidPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoZSymbols\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoTSymbols\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoHSymbols\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoEtherIcons\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoPurplePyramids\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoGoldPyramids\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"TwoRockets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"SpinConcluded\",\"type\":\"event\"}]","ContractName":"ZlotsMulti","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008481ff17c388ac87c5fa390e5c745677c6d99552","Library":"","SwarmSource":"bzzr://06b49e83d394ab17b9c590b0dab9bcb99155fb29d159a21ba4a1ad4d76d7a21e"}]}