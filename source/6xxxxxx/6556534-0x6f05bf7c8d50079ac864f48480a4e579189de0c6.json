{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n//==================================================\r\n// QIU3D Events\r\n//==================================================\r\ncontract QIU3Devents {\r\n    //fired whenever buy ticket\r\n    event onNewTicket(\r\n        address indexed player,\r\n        uint256 indexed matchId,\r\n        uint256 indexed ticketId,\r\n        uint256 fullMatResOpt,\r\n        uint256 goalsOpt,\r\n        uint256 gapGoalsOpt,\r\n        uint256 bothGoalOpt,\r\n        uint256 halfAndFullMatResOpt,\r\n        uint256 ticketValue,     \r\n        uint256 cost\r\n    );\r\n    //fired whenever buy bet\r\n    event onNewBet(\r\n        address indexed player,\r\n        uint256 indexed matchId,\r\n        uint256 indexed betId,\r\n        uint256 option,\r\n        uint256 odds,\r\n        uint256 cost\r\n    );\r\n\r\n    //fired at end match\r\n    event onEndMatch(\r\n        uint256 indexed matchId,\r\n        uint256 compressData\r\n    );\r\n\r\n    //fired at buy ticket with player invite\r\n    event onInvite(\r\n        address indexed player,\r\n        address indexed inviter,\r\n        uint256 profit\r\n    );\r\n\r\n    //fired at withdraw\r\n    event onWithdraw(\r\n        address indexed player,\r\n        uint256 withdraw,\r\n        uint256 withdrawType    //0-withdraw 1-buy ticket 2-buy bet\r\n    );\r\n}\r\n\r\n//==================================================\r\n// QIU3D contract setup\r\n//==================================================\r\ncontract QIU3D is QIU3Devents, Ownable {\r\n    using SafeMath for *;\r\n\r\n    //match data interface\r\n    Q3DMatchDataInterface private MatchDataInt_;\r\n    //foundation address, default is owner\r\n    address private foundationAddress_;\r\n\r\n    //jackpot and dividend percentage settings\r\n    uint256 constant private TxTJPPercentage = 63;  //Ticket jackpot percentage in Ticket fund\r\n    uint256 constant private BxTJPPercentage = 27;  //Bet jackpot percentage in Ticket fund\r\n    uint256 constant private BxBJPPercentage = 90;  //Bet jackpot percentage in Bet fund\r\n    uint256 constant private DxTJPPercentage = 10;  //Dividend percentage in Ticket fund\r\n    uint256 constant private DxBJPPercentage = 10;  //Dividend percentage in Bet fund\r\n    uint256 constant private TxDJPPercentage = 90;  //Tikcet dividend percentage in all Dividend\r\n    uint256 constant private FxDJPPercentage = 10;  //Foundation dividend percentage in all Dividend\r\n\r\n    //ticket options default invalid value\r\n    uint256 constant InvalidFullMatchResult = 0;\r\n    uint256 constant InvalidTotalGoals = 88;\r\n    uint256 constant InvalidGapGoals = 88;\r\n    uint256 constant InvalidBothGoals = 0;\r\n    uint256 constant InvalidHalfAndFullMatchResult = 0; \r\n\r\n    //ticket price settings\r\n    uint256 constant private TicketInitPrice = 100000000000000;     //Ticket initial price when match begin \r\n    uint256 constant private TicketIncreasePrice = 100000000000;    //Ticket increase price by each transaction\r\n    uint256 constant private PriceThreshold = 1000;                 //Speed up price incrase whenever ticket value is a large number\r\n\r\n    //bet settings\r\n    uint256 constant private OddsCommission = 10;         //Bet Odds commission\r\n    uint256 constant private OddsOpenPercentage = 30;     //Bet Odds open percentage\r\n    uint256 constant private OddsMaxDeviation = 5;        //Whenever frontend odds less than actual odds, player should accept the deviation\r\n\r\n    //invite settings\r\n    uint256 constant private InviteProfitPercentage = 10;  //profit percentage by invite player\r\n\r\n    //Match data\r\n    uint256 public openMatchId_;                                            //current opening matchId\r\n    uint256[] public matchIds_;                                             //match Id list\r\n    mapping(uint256 => QIU3Ddatasets.Match) public matches_;                //(matchId => Match) return match by match ID\r\n    mapping(uint256 => QIU3Ddatasets.MatchBetOptions) public betOptions_;   //(matchId => MatchBetOptions) return bet options by match ID\r\n\r\n    //Player data\r\n    mapping(address => QIU3Ddatasets.Player) public players_;       //(address => Player) return player by player address    \r\n\r\n    //ticket option values storage array\r\n    //|2-0| full match result option array\r\n    //|12-3| total goals option array\r\n    //|23-13| gap goals option array\r\n    //|25-24| both goals option array\r\n    //|34-26| half and full match result option array\r\n    mapping(uint256 => uint256[35]) public ticketOptionValues_;    //(matchId => array[35]) return ticket option value by match ID\r\n\r\n    constructor(address _matchDataAddress) public\r\n    {\r\n        openMatchId_ = 0; \r\n        MatchDataInt_ = Q3DMatchDataInterface(_matchDataAddress);\r\n        foundationAddress_ = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev update foundation address\r\n     **/\r\n    function setFoundationAddress(address _foundationAddr) public onlyOwner\r\n    {\r\n        foundationAddress_ = _foundationAddr;\r\n    }\r\n\r\n    //==================================================\r\n    // Modifier\r\n    //==================================================\r\n    modifier isHuman() \r\n    {\r\n        require(msg.sender == tx.origin, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    modifier isWithinLimits(uint256 _eth) \r\n    {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        _;    \r\n    }\r\n\r\n    /**\r\n     * @dev whenever player transfer eth to contract, default select match full time result is draw\r\n     **/\r\n    function() public isHuman() isWithinLimits(msg.value) payable\r\n    {\r\n        buyTicketCore_(\r\n            openMatchId_, \r\n            2, \r\n            InvalidTotalGoals, \r\n            InvalidGapGoals, \r\n            InvalidBothGoals, \r\n            InvalidHalfAndFullMatchResult, \r\n            msg.value, \r\n            address(0));\r\n    }\r\n\r\n    //==================================================\r\n    // public functions (interact with contract)\r\n    //==================================================\r\n    /**\r\n     * @dev player buy ticket with match options\r\n     * @param _matchId the ID of match\r\n     * @param _fullMatResOpt full time result (1-3), 0 to none\r\n     * @param _goalsOpt total goals (0-9), other values to none\r\n     * @param _gapGoalsOpt home team goals minus away team goals mapping value (0-10), mapping value = actual gap goals + 5, other values to none\r\n     * @param _bothGoalOpt both team goal (1-2)， 0 to none\r\n     * @param _halfAndFullMatResOpt match half time result and full time result (1-9)， 0 to none\r\n     * @param _inviteAddr address of invite player\r\n     */\r\n    function buyTicket(\r\n        uint256 _matchId,\r\n        uint256 _fullMatResOpt,\r\n        uint256 _goalsOpt,\r\n        uint256 _gapGoalsOpt,\r\n        uint256 _bothGoalOpt,\r\n        uint256 _halfAndFullMatResOpt,\r\n        address _inviteAddr\r\n        ) \r\n        public\r\n        isHuman() isWithinLimits(msg.value) payable\r\n    {\r\n        buyTicketCore_(\r\n            _matchId, \r\n            _fullMatResOpt, \r\n            _goalsOpt, \r\n            _gapGoalsOpt, \r\n            _bothGoalOpt, \r\n            _halfAndFullMatResOpt, \r\n            msg.value, \r\n            _inviteAddr);\r\n    }\r\n\r\n     /**\r\n     * @dev player buy ticket with vault\r\n     * @param _matchId the ID of match\r\n     * @param _fullMatResOpt full time result (1-3), 0 to none\r\n     * @param _goalsOpt total goals (0-9), other values to none\r\n     * @param _gapGoalsOpt home team goals minus away team goals mapping value (0-10), mapping value = actual gap goals + 5, other values to none\r\n     * @param _bothGoalOpt both team goal (1-2)， 0 to none\r\n     * @param _halfAndFullMatResOpt match half time result and full time result (1-9)， 0 to none\r\n     * @param _vaultEth pay eth value from vault\r\n     * @param _inviteAddr address of invite player\r\n     */\r\n    function buyTicketWithVault(\r\n        uint256 _matchId,\r\n        uint256 _fullMatResOpt,\r\n        uint256 _goalsOpt,\r\n        uint256 _gapGoalsOpt,\r\n        uint256 _bothGoalOpt,\r\n        uint256 _halfAndFullMatResOpt,\r\n        uint256 _vaultEth,\r\n        address _inviteAddr\r\n        )\r\n        public\r\n        isHuman() isWithinLimits(_vaultEth)\r\n    {\r\n        uint256 withdrawn = 0;\r\n        uint256 totalProfit = 0; \r\n        (totalProfit, withdrawn) = getPlayerVault_();\r\n        require(totalProfit >= withdrawn.add(_vaultEth), \"no balance\");\r\n        QIU3Ddatasets.Player storage _player_ = players_[msg.sender];\r\n        _player_.withdraw = withdrawn.add(_vaultEth);\r\n        buyTicketCore_(\r\n            _matchId, \r\n            _fullMatResOpt, \r\n            _goalsOpt, \r\n            _gapGoalsOpt, \r\n            _bothGoalOpt, \r\n            _halfAndFullMatResOpt, \r\n            _vaultEth, \r\n            _inviteAddr);\r\n        emit onWithdraw(msg.sender, _vaultEth, 1);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev player buy bet with bet option for current match\r\n     * @param _option match full time result, 0 - home win, 1 - draw , 2 - away win\r\n     * @param _odds odds value player want to buy\r\n     */\r\n\r\n    function bet(uint256 _option, uint256 _odds) public\r\n        isHuman() isWithinLimits(msg.value) payable\r\n    {\r\n        betCore_(_option, _odds, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev player buy bet with vault\r\n     * @param _option match full time result, 0 - home win, 1 - draw , 2 - away win\r\n     * @param _odds odds value player want to buy\r\n     * @param _vaultEth pay eth value from vault\r\n     */\r\n\r\n    function betWithVault(uint256 _option, uint256 _odds, uint256 _vaultEth) public\r\n        isHuman() isWithinLimits(_vaultEth)\r\n    {\r\n        uint256 withdrawn = 0;\r\n        uint256 totalProfit = 0; \r\n        (totalProfit, withdrawn) = getPlayerVault_();\r\n        require(totalProfit >= withdrawn.add(_vaultEth), \"no balance\");\r\n        QIU3Ddatasets.Player storage _player_ = players_[msg.sender];\r\n        _player_.withdraw = withdrawn.add(_vaultEth);\r\n        betCore_(_option, _odds, _vaultEth);\r\n        emit onWithdraw(msg.sender, _vaultEth, 2);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev player withdraw profit and dividend, everytime player call withdraw will empty balance\r\n     */\r\n    function withdraw() public isHuman()\r\n    {\r\n        uint256 withdrawn = 0;\r\n        uint256 totalProfit = 0; \r\n        (totalProfit, withdrawn) = getPlayerVault_();\r\n        require(totalProfit > withdrawn, \"no balance\");\r\n        QIU3Ddatasets.Player storage _player_ = players_[msg.sender];\r\n        _player_.withdraw = totalProfit;\r\n        msg.sender.transfer(totalProfit.sub(withdrawn));\r\n        emit onWithdraw(msg.sender, totalProfit.sub(withdrawn), 0);\r\n    }\r\n\r\n    //==================================================\r\n    // view functions (getter in contract)\r\n    //==================================================\r\n    /** \r\n     * @dev returns game basic information\r\n     * @return the ID of current match\r\n     * @return ticket price in real time\r\n     * @return the timestamp when match end\r\n     * @return total tickt fund from player buy ticket\r\n     * @return total bet fund from player buy bet\r\n     */\r\n    function getGameInfo() public view returns(uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        QIU3Ddatasets.Match memory _match_ = matches_[openMatchId_];\r\n        if(openMatchId_ == 0){\r\n            return (openMatchId_, TicketInitPrice, 0, 0, 0);\r\n        }else{\r\n            return (openMatchId_, _match_.currentPrice, _match_.endts, _match_.ticketFund, _match_.betFund);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev returns player information in QIU3D game\r\n     * @return last match id which player buy ticket\r\n     * @return total withdraw amount\r\n     * @return total invite profit\r\n     * @return total ticket profit\r\n     * @return total ticket dividend\r\n     * @return total bet profit\r\n     */\r\n    function getPlayerInGame() public view returns(uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        QIU3Ddatasets.Player memory _player_ = players_[msg.sender];\r\n        uint256 totalTicketProfit = 0;\r\n        uint256 totalTicketDividend = 0;\r\n        uint256 totalBetProfit = 0;\r\n        for(uint i = 0 ; i < _player_.matchIds.length; i++){\r\n            uint256 ticketProfit = 0;\r\n            uint256 ticketDividend = 0;\r\n            uint256 betProfit = 0;\r\n            (ticketProfit, ticketDividend, betProfit) = getPlayerProfitInMatch(_player_.matchIds[i]);\r\n            totalTicketProfit = totalTicketProfit.add(ticketProfit);\r\n            totalTicketDividend = totalTicketDividend.add(ticketDividend);\r\n            totalBetProfit = totalBetProfit.add(betProfit);\r\n        }\r\n        return (\r\n            _player_.lastBuyTicketMatchId,\r\n            _player_.withdraw,\r\n            _player_.inviteProfit,\r\n            totalTicketProfit,\r\n            totalTicketDividend,\r\n            totalBetProfit\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev returns player profit in special match\r\n     * @param matchId ID of match\r\n     * @return ticket dividend, show before match end.\r\n     * @return ticket profit, show after match end.\r\n     * @return bet profit, show after match end.\r\n     */\r\n    function getPlayerProfitInMatch(uint256 matchId) public view returns(uint256, uint256, uint256)\r\n    {\r\n        uint256 ticketProfit;\r\n        uint256 ticketDividend;\r\n        (ticketProfit, ticketDividend) = getTicketProfitAndDividend(matchId, 0);\r\n        uint256 betProfit = getBetProfit_(matchId);\r\n        return(ticketProfit, ticketDividend, betProfit);\r\n    }\r\n\r\n    /** \r\n     * @dev returns the current bet information \r\n     * @return return if bet opened\r\n     * @return home win odds\r\n     * @return draw odds\r\n     * @return away win odds\r\n     * @return home team win max sell\r\n     * @return draw win max sell\r\n     * @return away team win max sell\r\n     */\r\n    function getBet() public view returns(bool, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        QIU3Ddatasets.BetReturns memory _betReturn_;\r\n        _betReturn_ = getBetReturns_(_betReturn_);\r\n        return(\r\n            _betReturn_.opened,\r\n            _betReturn_.homeOdds,\r\n            _betReturn_.drawOdds,\r\n            _betReturn_.awayOdds,\r\n            _betReturn_.homeMaxSell,\r\n            _betReturn_.drawMaxSell,\r\n            _betReturn_.awayMaxSell\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev returns player's ticket profit and profit in special match\r\n     */\r\n    function getTicketProfitAndDividend(uint256 _matchId, uint256 _ticketId) public view returns(uint256, uint256)\r\n    {\r\n        uint256 totalTicketProfit = 0;\r\n        uint256 totalTicketDividend = 0;\r\n        uint256 _remainTicketJackpot = 0;\r\n        QIU3Ddatasets.Match storage _match_ = matches_[_matchId];\r\n        QIU3Ddatasets.TicketEventIntReturns memory _profitReturns_;\r\n        if(_match_.ended){\r\n            uint256 _ticketJackpot = getTicketJackpot_(_matchId, getBetClearedProfit_(_matchId, _match_.compressedData));\r\n            _profitReturns_ = calculateTicketProfitAssign_(_matchId, _match_.compressedData, _ticketJackpot, _profitReturns_);\r\n            if(_profitReturns_.count == 0){\r\n                _remainTicketJackpot = _ticketJackpot;\r\n            }\r\n        }\r\n        QIU3Ddatasets.MatchPlayer memory _matchPlayer_ = _match_.matchPlayers[msg.sender];\r\n        for(uint i = 0; i < _matchPlayer_.ticketIds.length; i++){\r\n            uint256 tId = 0;\r\n            if(_ticketId != 0){\r\n                tId = _ticketId;\r\n            }else{\r\n                tId = _matchPlayer_.ticketIds[i];\r\n            }\r\n            totalTicketProfit = totalTicketProfit.add(\r\n                calculateTicketProfit_(_matchId, _profitReturns_, _match_.tickets[tId]));\r\n            totalTicketDividend = totalTicketDividend.add(\r\n                calculateTicketDividend_(_matchId, _remainTicketJackpot, _match_.tickets[tId]));\r\n            if(_ticketId != 0){\r\n                //so disgusting code, but gas you know.\r\n                break;\r\n            }\r\n        }\r\n        return (totalTicketProfit, totalTicketDividend);\r\n    }\r\n\r\n    //==================================================\r\n    // private functions - calculate player ticket and bet profit\r\n    //==================================================\r\n    /** \r\n     * @dev calculate one ticket profit in special match\r\n     */\r\n    function calculateTicketProfit_(\r\n        uint256 _matchId, \r\n        QIU3Ddatasets.TicketEventIntReturns memory _profitReturns_, \r\n        QIU3Ddatasets.Ticket memory _ticket_\r\n        ) private view returns(uint256)\r\n    {\r\n        uint256 ticketProfit = 0;\r\n        QIU3Ddatasets.Match memory _match_ = matches_[_matchId];\r\n        if(_match_.ended && _profitReturns_.count > 0){\r\n            QIU3Ddatasets.TicketEventBoolReturns memory _compareReturns_ = compareOptionsResult_(\r\n                _ticket_.compressedData, _match_.compressedData, _compareReturns_);\r\n            uint256 optionTicketValue = _ticket_.ticketValue.div(_ticket_.compressedData.div(10000000));\r\n            if(_compareReturns_.fullMatch){\r\n                ticketProfit = ticketProfit.add((_profitReturns_.fullMatch.mul(optionTicketValue)).div(1000000000000000000));\r\n            }\r\n            if(_compareReturns_.totalGoal){\r\n                ticketProfit = ticketProfit.add((_profitReturns_.totalGoal.mul(optionTicketValue)).div(1000000000000000000));\r\n            }\r\n            if(_compareReturns_.gapGoal){\r\n                ticketProfit = ticketProfit.add((_profitReturns_.gapGoal.mul(optionTicketValue)).div(1000000000000000000));\r\n            }\r\n            if(_compareReturns_.bothGoal){\r\n                ticketProfit = ticketProfit.add((_profitReturns_.bothGoal.mul(optionTicketValue)).div(1000000000000000000));\r\n            }\r\n            if(_compareReturns_.halfAndFullMatch){\r\n                ticketProfit = ticketProfit.add((_profitReturns_.halfAndFullMatch.mul(optionTicketValue)).div(1000000000000000000));\r\n            }\r\n        }\r\n        return ticketProfit;\r\n    }\r\n\r\n    /** \r\n     * @dev calculate one ticket dividend in special match\r\n     */\r\n    function calculateTicketDividend_(\r\n        uint256 _matchId, \r\n        uint256 _remainTicketJackpot, \r\n        QIU3Ddatasets.Ticket memory _ticket_\r\n        ) private view returns(uint256)\r\n    {\r\n        uint256 totalDividend = 0;\r\n        totalDividend = getTicketDividendFromJackpot_(_matchId, _remainTicketJackpot);\r\n        uint256 totalOptionValues;\r\n        (totalOptionValues, ) = getTotalOptionValues_(_matchId);\r\n        uint256 dividendPerTicket = (totalDividend.mul(1000000000000000000)).div(totalOptionValues);\r\n        uint256 dividend = (_ticket_.ticketValue.mul(dividendPerTicket)).div(1000000000000000000);\r\n        return dividend;\r\n    }\r\n\r\n    /** \r\n     * @dev calculate ticket profit assign in special match, returns all option profit\r\n     */\r\n    function calculateTicketProfitAssign_(\r\n        uint256 _matchId, \r\n        uint256 _compressResult, \r\n        uint256 _ticketJackpot, \r\n        QIU3Ddatasets.TicketEventIntReturns memory _eventReturns_\r\n        ) private view returns(QIU3Ddatasets.TicketEventIntReturns)\r\n    {\r\n        QIU3Ddatasets.TicketEventIntReturns memory _optionReturns_ = getDecompressedOptions_(_compressResult, _optionReturns_);\r\n\r\n        uint256 fullMatchValue = ticketOptionValues_[_matchId][_optionReturns_.fullMatch.sub(1)];\r\n        if(fullMatchValue > 0){\r\n            _eventReturns_.count = _eventReturns_.count.add(1);\r\n        }\r\n\r\n        uint256 totalGoalValue = 0;\r\n        if(_optionReturns_.totalGoal != InvalidTotalGoals){\r\n            totalGoalValue = ticketOptionValues_[_matchId][_optionReturns_.totalGoal.add(3)];\r\n            if(totalGoalValue > 0){\r\n                _eventReturns_.count = _eventReturns_.count.add(1);\r\n            }\r\n        }\r\n\r\n        uint256 gapGoalValue = 0;\r\n        if(_optionReturns_.gapGoal != InvalidGapGoals){\r\n            gapGoalValue = ticketOptionValues_[_matchId][_optionReturns_.gapGoal.add(13)];\r\n            if(gapGoalValue > 0){\r\n                _eventReturns_.count = _eventReturns_.count.add(1);\r\n            }\r\n        }\r\n        uint256 bothGoalValue = ticketOptionValues_[_matchId][_optionReturns_.bothGoal.add(23)];\r\n        if(bothGoalValue > 0){\r\n            _eventReturns_.count = _eventReturns_.count.add(1);\r\n        }\r\n        uint256 halfAndFullMatchValue = ticketOptionValues_[_matchId][_optionReturns_.halfAndFullMatch.add(25)];\r\n        if(halfAndFullMatchValue > 0){\r\n            _eventReturns_.count = _eventReturns_.count.add(1);\r\n        }\r\n        if(_eventReturns_.count != 0){\r\n            uint256 perJackpot = _ticketJackpot.div(_eventReturns_.count);\r\n            if(fullMatchValue > 0){\r\n                _eventReturns_.fullMatch = perJackpot.mul(1000000000000000000).div(fullMatchValue);\r\n            }\r\n            if(totalGoalValue > 0){\r\n                _eventReturns_.totalGoal = perJackpot.mul(1000000000000000000).div(totalGoalValue);\r\n            }\r\n            if(gapGoalValue > 0){\r\n                _eventReturns_.gapGoal = perJackpot.mul(1000000000000000000).div(gapGoalValue);\r\n            }\r\n            if(bothGoalValue > 0){\r\n                _eventReturns_.bothGoal = perJackpot.mul(1000000000000000000).div(bothGoalValue);\r\n            }\r\n            if(halfAndFullMatchValue > 0){\r\n                _eventReturns_.halfAndFullMatch = perJackpot.mul(1000000000000000000).div(halfAndFullMatchValue);\r\n            }\r\n        }\r\n        return(_eventReturns_);\r\n    }\r\n\r\n    /** \r\n     * @dev get player bet profit in special match\r\n     */\r\n    function getBetProfit_(uint256 _matchId) public view returns(uint256)\r\n    {\r\n        uint256 betProfit = 0;\r\n        QIU3Ddatasets.Match storage _match_ = matches_[_matchId];\r\n        if(_match_.ended){\r\n            QIU3Ddatasets.MatchPlayer memory _matchPlayer_ = _match_.matchPlayers[msg.sender];\r\n            for(uint i = 0; i < _matchPlayer_.betIds.length; i++){\r\n                uint256 _betId = _matchPlayer_.betIds[i];\r\n                betProfit = betProfit.add(calculateBetProfit_(_match_, _betId));\r\n            }\r\n        }\r\n        return betProfit;\r\n    }\r\n\r\n\r\n    /** \r\n     * @dev calculate one bet profit in special match\r\n     */\r\n    function calculateBetProfit_(QIU3Ddatasets.Match storage _match_, uint256 betId) private view returns(uint256){\r\n        QIU3Ddatasets.Bet memory _bet_ = _match_.bets[betId];\r\n        uint256 option = _match_.compressedData % 10;\r\n        //odds option is different with match's full match result option, need +1\r\n        if(option == _bet_.option.add(1)){\r\n            return (_bet_.odds.mul(_bet_.cost)).div(100);\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** \r\n    * @dev get bet cleared profit\r\n    */\r\n    function getBetClearedProfit_(uint256 _matchId, uint256 _compressedData) private view returns(uint256)\r\n    {\r\n        uint256 _totalBetJackpot = getBetJackpot_(_matchId);\r\n        QIU3Ddatasets.MatchBetOptions memory _betOption_ = betOptions_[_matchId];\r\n        uint256 matchResult = _compressedData % 10;\r\n        if(matchResult == 1){\r\n            return _totalBetJackpot.sub(_betOption_.homeBetReturns);\r\n        }else if(matchResult == 2){\r\n            return _totalBetJackpot.sub(_betOption_.drawBetReturns);\r\n        }else {\r\n            return _totalBetJackpot.sub(_betOption_.awayBetReturns);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev get player total profit and withdraw\r\n     */\r\n    function getPlayerVault_() private view returns(uint256, uint256){\r\n        uint256 withdrawn = 0;\r\n        uint256 inviteProfit = 0;\r\n        uint256 ticketProfit = 0;\r\n        uint256 ticketDividend = 0;\r\n        uint256 betProfit = 0;\r\n        (,withdrawn, inviteProfit, ticketProfit, ticketDividend, betProfit) = getPlayerInGame();\r\n        uint256 totalProfit = ((inviteProfit.add(ticketProfit)).add(ticketDividend)).add(betProfit);\r\n        return (totalProfit, withdrawn);\r\n    }\r\n\r\n    //==================================================\r\n    // private functions - buy ticket\r\n    //==================================================\r\n    /** \r\n    * @dev buy ticket core\r\n    */\r\n    function buyTicketCore_(\r\n        uint256 _matchId,\r\n        uint256 _fullMatResOpt,\r\n        uint256 _goalsOpt,\r\n        uint256 _gapGoalsOpt,\r\n        uint256 _bothGoalOpt,\r\n        uint256 _halfAndFullMatResOpt,\r\n        uint256 _eth,\r\n        address _inviteAddr\r\n        ) private\r\n    {\r\n        determineMatch_(_matchId);\r\n        QIU3Ddatasets.Match storage _match_ = matches_[openMatchId_];\r\n        require(!_match_.ended && _match_.endts > now, \"no match open, wait for next match\");\r\n\r\n        uint256 _inviteProfit = grantInvitation_(_eth, _inviteAddr);\r\n\r\n        QIU3Ddatasets.Ticket memory _ticket_;\r\n        //generate new ticket ID\r\n        uint256 _ticketId = _match_.ticketIds.length.add(1);\r\n        _ticket_.ticketId = _ticketId;\r\n        _ticket_.compressedData = getCompressedOptions_(_fullMatResOpt, _goalsOpt, _gapGoalsOpt, _bothGoalOpt, _halfAndFullMatResOpt);\r\n        _ticket_.playerAddr = msg.sender;\r\n        _ticket_.cost = _eth;\r\n        _ticket_.ticketValue = (_eth.mul(1000000000000000000)).div(_match_.currentPrice);\r\n        \r\n        _match_.ticketIds.push(_ticketId);\r\n        _match_.tickets[_ticketId] = _ticket_;\r\n        _match_.ticketFund = _match_.ticketFund.add(_ticket_.cost.sub(_inviteProfit));\r\n        _match_.currentPrice = getTicketPrice_(_match_.currentPrice, _ticket_.ticketValue);\r\n    \r\n        updatePlayerWithTicket_(_ticket_, _match_);\r\n        updateMatchTicketOptions_(openMatchId_, _ticket_.compressedData, _ticket_.ticketValue);\r\n\r\n        emit onNewTicket(\r\n            msg.sender, \r\n            openMatchId_, \r\n            _ticketId, \r\n            _fullMatResOpt,\r\n            _goalsOpt,\r\n            _gapGoalsOpt,\r\n            _bothGoalOpt,\r\n            _halfAndFullMatResOpt,\r\n            _ticket_.ticketValue,\r\n            _eth\r\n        );\r\n    }\r\n\r\n    /** \r\n    * @dev determine if active new match\r\n    */\r\n    function determineMatch_(uint256 _matchId) private\r\n    {\r\n        require(_matchId > 0, \"invalid match ID\");\r\n        if(_matchId != openMatchId_){\r\n            if(openMatchId_ == 0){\r\n                startNewMatch_(_matchId);\r\n            }else{\r\n                bool ended;\r\n                uint256 halfHomeGoals;\r\n                uint256 halfAwayGoals;\r\n                uint256 homeGoals;\r\n                uint256 awayGoals;\r\n                (ended, halfHomeGoals, halfAwayGoals, homeGoals, awayGoals) = MatchDataInt_.getMatchStatus(openMatchId_);\r\n                require(ended, \"waiting match end\");\r\n                QIU3Ddatasets.Match storage _match_ = matches_[openMatchId_];\r\n                if(!_match_.ended){\r\n                    _match_.ended = true;\r\n                    _match_.compressedData = getCompressedMatchResult_(halfHomeGoals, halfAwayGoals, homeGoals, awayGoals);\r\n                    emit onEndMatch(openMatchId_, _match_.compressedData);\r\n                    uint256 _fundationDividend = getFoundationDividendFromJackpot_(openMatchId_);\r\n                    foundationAddress_.transfer(_fundationDividend);\r\n                }\r\n                startNewMatch_(_matchId);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** \r\n    * @dev start a new match\r\n    */\r\n    function startNewMatch_(uint256 _matchId) private\r\n    {\r\n        uint256 _newMatchId;\r\n        uint256 _kickoffTime;\r\n        (_newMatchId,_kickoffTime) = MatchDataInt_.getOpenMatchBaseInfo();\r\n\r\n        require(_matchId == _newMatchId, \"match ID invalid\");\r\n        require(_newMatchId > openMatchId_, \"No more match opening\");\r\n        openMatchId_ = _newMatchId;\r\n        QIU3Ddatasets.Match memory _match_;\r\n        _match_.matchId = _newMatchId;\r\n        _match_.endts = _kickoffTime;\r\n        _match_.currentPrice = TicketInitPrice;\r\n        matchIds_.push(_newMatchId);\r\n        matches_[_newMatchId] = _match_;\r\n    }\r\n\r\n    /** \r\n    * @dev grant invitor profit\r\n    */\r\n    function grantInvitation_(uint256 _eth, address _inviteAddr) private returns(uint256)\r\n    {\r\n        uint256 _inviteProfit = 0;\r\n        if(_inviteAddr != address(0) && _inviteAddr != msg.sender && (players_[_inviteAddr].lastBuyTicketMatchId == openMatchId_)){\r\n            _inviteProfit = (_eth.mul(InviteProfitPercentage)).div(100);\r\n            players_[_inviteAddr].inviteProfit = players_[_inviteAddr].inviteProfit.add(_inviteProfit);\r\n            emit onInvite(msg.sender, _inviteAddr, _inviteProfit);\r\n        }\r\n        return _inviteProfit;\r\n    }\r\n\r\n    /**\r\n    * @dev update player data whenever player buy ticket\r\n    */\r\n    function updatePlayerWithTicket_(QIU3Ddatasets.Ticket memory _ticket_, QIU3Ddatasets.Match storage _match_) private\r\n    {\r\n        QIU3Ddatasets.Player storage _player_ = players_[_ticket_.playerAddr];\r\n        _player_.lastBuyTicketMatchId = openMatchId_;\r\n\r\n        QIU3Ddatasets.MatchPlayer storage _matchPlayer_ = _match_.matchPlayers[_ticket_.playerAddr];\r\n        _matchPlayer_.ticketIds.push(_ticket_.ticketId);\r\n\r\n        bool playerInThisMatch = false;\r\n        for(uint i = 0 ; i < _player_.matchIds.length; i ++){\r\n            if(openMatchId_ == _player_.matchIds[i]){\r\n                playerInThisMatch = true;\r\n            }\r\n        }\r\n        if(!playerInThisMatch){\r\n            _player_.matchIds.push(openMatchId_);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev update match data with ticket options, also check if the bet could opened\r\n    */\r\n    function updateMatchTicketOptions_(uint256 _matchId, uint256 _compressedData, uint256 _ticketValue) private\r\n    {\r\n        QIU3Ddatasets.TicketEventBoolReturns memory _validReturns_ = getValidOptions_(_compressedData, _validReturns_);\r\n        QIU3Ddatasets.TicketEventIntReturns memory _optionReturns_ = getDecompressedOptions_(_compressedData, _optionReturns_);\r\n        //option value in ticket = total ticket value / valid options\r\n        uint256 _optionValue = _ticketValue.div(_validReturns_.count);\r\n        if(_validReturns_.fullMatch){\r\n            ticketOptionValues_[_matchId][_optionReturns_.fullMatch.sub(1)] = ticketOptionValues_[_matchId][_optionReturns_.fullMatch.sub(1)].add(_optionValue);\r\n        }\r\n        if(_validReturns_.totalGoal){\r\n            ticketOptionValues_[_matchId][_optionReturns_.totalGoal.add(3)] = ticketOptionValues_[_matchId][_optionReturns_.totalGoal.add(3)].add(_optionValue);\r\n        }\r\n        if(_validReturns_.gapGoal){\r\n            ticketOptionValues_[_matchId][_optionReturns_.gapGoal.add(13)] = ticketOptionValues_[_matchId][_optionReturns_.gapGoal.add(13)].add(_optionValue);\r\n        }\r\n        if(_validReturns_.bothGoal){\r\n            ticketOptionValues_[_matchId][_optionReturns_.bothGoal.add(23)] = ticketOptionValues_[_matchId][_optionReturns_.bothGoal.add(23)].add(_optionValue);\r\n        }\r\n        if(_validReturns_.halfAndFullMatch){\r\n            ticketOptionValues_[_matchId][_optionReturns_.halfAndFullMatch.add(25)] = ticketOptionValues_[_matchId][_optionReturns_.halfAndFullMatch.add(25)].add(_optionValue);\r\n        }\r\n\r\n        QIU3Ddatasets.MatchBetOptions storage _betOption_ = betOptions_[_matchId];\r\n\r\n        //open gambling conditions\r\n        if(!_betOption_.betOpened){\r\n            //condition 1: at least one player selected each full match result option(home/draw/away) \r\n            if(ticketOptionValues_[_matchId][0] != 0 && ticketOptionValues_[_matchId][1] != 0 && ticketOptionValues_[_matchId][2] != 0){\r\n                uint256 totalOptionValues;\r\n                uint256 fullMatchOptionValue;\r\n                (totalOptionValues, fullMatchOptionValue) = getTotalOptionValues_(_matchId);\r\n                //condition 2: full match result option value / total option value > 30%\r\n                if((fullMatchOptionValue.mul(100)).div(totalOptionValues) > OddsOpenPercentage){\r\n                    _betOption_.betOpened = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev get new ticket price\r\n    */\r\n    function getTicketPrice_(uint256 _currentPrice, uint256 _ticketValue) internal pure returns(uint256)\r\n    {\r\n        uint256 tv = _ticketValue.div(1000000000000000000);\r\n        if(tv < PriceThreshold){\r\n            //newPrice = _currentPrice + TicketIncreasePrice\r\n            return (_currentPrice.add(TicketIncreasePrice));\r\n        }else{\r\n            //newPrice = _currentPrice + TicketIncreasePrice * (_ticketValue/PriceThreshold + 1)\r\n            return (_currentPrice.add(TicketIncreasePrice.mul((tv.div(PriceThreshold)).add(1))));\r\n        }\r\n    }  \r\n\r\n\r\n    //==================================================\r\n    // private functions - ticket options operations\r\n    //==================================================\r\n    /**\r\n    * @dev get total ticket value in current match\r\n    */\r\n    function getTotalOptionValues_(uint256 _matchId) private view returns (uint256, uint256)\r\n    {\r\n        uint256 _totalCount = 0;\r\n        uint256 _fullMatchResult = 0;\r\n        for(uint i = 0 ; i < ticketOptionValues_[_matchId].length; i++){\r\n            if(i <= 2){\r\n                _fullMatchResult = _fullMatchResult.add(ticketOptionValues_[_matchId][i]);\r\n            }\r\n            _totalCount = _totalCount.add(ticketOptionValues_[_matchId][i]);\r\n        }\r\n        return (_totalCount, _fullMatchResult);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev compress ticket options value to uint256\r\n    */\r\n    function getCompressedOptions_(uint256 _fullResult, uint256 _totalGoals, uint256 _gapGoals, uint256 _bothGoals, uint256 _halfAndFullResult) \r\n        private pure returns (uint256)\r\n    {\r\n        //Ticket default settings\r\n        uint256 fullMatResOpt = InvalidFullMatchResult; \r\n        uint256 goalsOpt = InvalidTotalGoals; \r\n        uint256 gapGoalsOpt = InvalidGapGoals; \r\n        uint256 bothGoalOpt = InvalidBothGoals; \r\n        uint256 halfAndFullMatResOpt = InvalidHalfAndFullMatchResult; \r\n        uint256 vaildOptions = 0;\r\n\r\n        if(_fullResult > 0 && _fullResult <= 3){\r\n            vaildOptions = vaildOptions.add(1);\r\n            fullMatResOpt = _fullResult;\r\n        }\r\n        if(_totalGoals <= 9){\r\n            vaildOptions = vaildOptions.add(1);\r\n            goalsOpt = _totalGoals;\r\n        }\r\n        if(_gapGoals <= 10 ){\r\n            vaildOptions = vaildOptions.add(1);\r\n            gapGoalsOpt = _gapGoals;\r\n        }\r\n        if(_bothGoals == 1 || _bothGoals == 2){\r\n            vaildOptions = vaildOptions.add(1);\r\n            bothGoalOpt = _bothGoals;\r\n        }\r\n        if(_halfAndFullResult > 0 && _halfAndFullResult <= 9){\r\n            vaildOptions = vaildOptions.add(1);\r\n            halfAndFullMatResOpt = _halfAndFullResult;\r\n        }\r\n        //if no vaild option be seleced, select full match result is draw by default\r\n        if(vaildOptions == 0){\r\n            vaildOptions = 1;\r\n            fullMatResOpt == 2;\r\n        }\r\n        uint256 compressedData = fullMatResOpt;\r\n        compressedData = compressedData.add(goalsOpt.mul(10));\r\n        compressedData = compressedData.add(gapGoalsOpt.mul(1000));\r\n        compressedData = compressedData.add(bothGoalOpt.mul(100000));\r\n        compressedData = compressedData.add(halfAndFullMatResOpt.mul(1000000));\r\n        compressedData = compressedData.add(vaildOptions.mul(10000000));\r\n        return (compressedData);\r\n    }\r\n\r\n    /**\r\n    * @dev check ticket option's valid count\r\n    */\r\n    function getValidOptions_(uint256 _compressData, QIU3Ddatasets.TicketEventBoolReturns memory _eventReturns_) \r\n        private pure returns (QIU3Ddatasets.TicketEventBoolReturns)\r\n    {\r\n        _eventReturns_.fullMatch = (_compressData % 10 != InvalidFullMatchResult);\r\n        _eventReturns_.totalGoal = ((_compressData % 1000)/10 != InvalidTotalGoals);\r\n        _eventReturns_.gapGoal = ((_compressData % 100000)/1000 != InvalidGapGoals);\r\n        _eventReturns_.bothGoal = ((_compressData % 1000000)/100000 != InvalidBothGoals);\r\n        _eventReturns_.halfAndFullMatch = ((_compressData % 10000000)/1000000 != InvalidHalfAndFullMatchResult);\r\n        _eventReturns_.count = _compressData/10000000;\r\n        return (_eventReturns_);\r\n    }\r\n\r\n    //==================================================\r\n    // private functions - buy bet\r\n    //==================================================\r\n    \r\n    /** \r\n    * @dev buy bet core\r\n    */\r\n    function betCore_(uint256 _option, uint256 _odds, uint256 _eth) private\r\n    {\r\n        require(_option < 3, \"invalid bet option\");\r\n        QIU3Ddatasets.Match storage _match_ = matches_[openMatchId_];\r\n        require(!_match_.ended && _match_.endts > now, \"no match open, wait for next match\");\r\n        QIU3Ddatasets.BetReturns memory _betReturn_;\r\n        _betReturn_ = getBetReturns_(_betReturn_);\r\n        require(_betReturn_.opened, \"bet not open\");\r\n\r\n        QIU3Ddatasets.Bet memory _bet_;\r\n        if(_option == 0){\r\n            require(msg.value <= _betReturn_.homeMaxSell, \"not enough to sell\");\r\n            require(_odds <= _betReturn_.homeOdds, \"invalid odds\");\r\n            if(_odds < _betReturn_.homeOdds){\r\n                //when user bet odds less than live bet, only accept the deviation < 3%\r\n                require(((_betReturn_.homeOdds - _odds).mul(100)).div(_betReturn_.homeOdds) <= OddsMaxDeviation, \"Odds already changed\");\r\n            }\r\n            _bet_.odds = _betReturn_.homeOdds;\r\n        }else if(_option == 1){\r\n            require(msg.value <= _betReturn_.drawMaxSell, \"not enough to sell\");\r\n            require(_odds <= _betReturn_.drawOdds, \"invalid odds\");\r\n            if(_odds < _betReturn_.drawOdds){\r\n                //when user bet odds less than live bet, only accept the deviation < 3%\r\n                require(((_betReturn_.drawOdds - _odds).mul(100)).div(_betReturn_.drawOdds) <= OddsMaxDeviation, \"Odds already changed\");\r\n            }\r\n            _bet_.odds = _betReturn_.drawOdds;\r\n        }else if(_option == 2){\r\n            require(msg.value <= _betReturn_.awayMaxSell, \"not enough to sell\");\r\n            require(_odds <= _betReturn_.awayOdds, \"invalid odds\");\r\n            if(_odds < _betReturn_.awayOdds){\r\n                //when user bet odds less than live bet, only accept the deviation < 3%\r\n                require(((_betReturn_.awayOdds - _odds).mul(100)).div(_betReturn_.awayOdds) <= OddsMaxDeviation, \"Odds already changed\");\r\n            }\r\n            _bet_.odds = _betReturn_.awayOdds;\r\n        }\r\n\r\n        //generate new bet ID\r\n        uint256 _betId = _match_.betIds.length.add(1);\r\n        _bet_.betId = _betId;\r\n        _bet_.option = _option;\r\n        _bet_.playerAddr = msg.sender;\r\n        _bet_.cost = _eth;\r\n\r\n        _match_.betFund = _match_.betFund.add(_eth);\r\n        _match_.betIds.push(_betId);\r\n        _match_.bets[_betId] = _bet_;\r\n\r\n        updatePlayerWithBet_(_bet_, _match_);\r\n        updateMatchBetOptions_(_bet_);\r\n        \r\n        emit onNewBet(msg.sender, _match_.matchId, _betId, _option, _bet_.odds, _eth);\r\n    }\r\n\r\n    /**\r\n    * @dev get bet return information\r\n    */\r\n    function getBetReturns_(QIU3Ddatasets.BetReturns memory _betReturn_) private view returns(QIU3Ddatasets.BetReturns)\r\n    {\r\n        QIU3Ddatasets.MatchBetOptions memory _betOption_ = betOptions_[openMatchId_];\r\n        if(_betOption_.betOpened){\r\n            uint256 _totalValue = ticketOptionValues_[openMatchId_][0] + ticketOptionValues_[openMatchId_][1] + ticketOptionValues_[openMatchId_][2];\r\n            _betReturn_.homeOdds = calOdds_(_totalValue, ticketOptionValues_[openMatchId_][0]);\r\n            _betReturn_.drawOdds = calOdds_(_totalValue, ticketOptionValues_[openMatchId_][1]);\r\n            _betReturn_.awayOdds = calOdds_(_totalValue, ticketOptionValues_[openMatchId_][2]);\r\n\r\n            uint256 _totalBetJackpot = getBetJackpot_(openMatchId_);\r\n            _betReturn_.homeMaxSell = ((_totalBetJackpot.sub(_betOption_.homeBetReturns)).mul(100)).div(_betReturn_.homeOdds);\r\n            _betReturn_.drawMaxSell = ((_totalBetJackpot.sub(_betOption_.drawBetReturns)).mul(100)).div(_betReturn_.drawOdds);\r\n            _betReturn_.awayMaxSell = ((_totalBetJackpot.sub(_betOption_.awayBetReturns)).mul(100)).div(_betReturn_.awayOdds);\r\n            _betReturn_.opened = true;\r\n        }\r\n        return (_betReturn_);\r\n    }\r\n    \r\n    /**\r\n    * @dev update player information with bet \r\n    */\r\n    function updatePlayerWithBet_(QIU3Ddatasets.Bet memory _bet_, QIU3Ddatasets.Match storage _match_) private\r\n    {\r\n        QIU3Ddatasets.MatchPlayer storage _matchPlayer_ = _match_.matchPlayers[_bet_.playerAddr];\r\n        _matchPlayer_.betIds.push(_bet_.betId);\r\n\r\n        QIU3Ddatasets.Player storage _player_ = players_[_bet_.playerAddr];\r\n        bool playerInThisMatch = false;\r\n        for(uint i = 0 ; i < _player_.matchIds.length; i ++){\r\n            if(openMatchId_ == _player_.matchIds[i]){\r\n                playerInThisMatch = true;\r\n            }\r\n        }\r\n        if(!playerInThisMatch){\r\n            _player_.matchIds.push(openMatchId_);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev update bet return with bet \r\n    */\r\n    function updateMatchBetOptions_(QIU3Ddatasets.Bet memory _bet_) private\r\n    {\r\n        QIU3Ddatasets.MatchBetOptions storage _betOption_ = betOptions_[openMatchId_];\r\n        if(_bet_.option == 0){\r\n            _betOption_.homeBetReturns = _betOption_.homeBetReturns.add((_bet_.cost.mul(_bet_.odds)).div(100));\r\n        }else if(_bet_.option == 1){\r\n            _betOption_.drawBetReturns = _betOption_.drawBetReturns.add((_bet_.cost.mul(_bet_.odds)).div(100));\r\n        }else if(_bet_.option == 2){\r\n            _betOption_.awayBetReturns = _betOption_.awayBetReturns.add((_bet_.cost.mul(_bet_.odds)).div(100));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev calculate bet odds\r\n    */\r\n    function calOdds_(uint256 _totalValue, uint256 _optionValue) private pure returns(uint256){\r\n        uint256 _odds = (_totalValue.mul(100)).div(_optionValue);\r\n        uint256 _commission = _odds.div(OddsCommission);\r\n        return (_odds - _commission);\r\n    }\r\n\r\n\r\n    //==================================================\r\n    // private functions - jackpot and dividend\r\n    //==================================================\r\n    /**\r\n    * @dev get bet jackpot\r\n    */\r\n    function getBetJackpot_(uint256 _matchId) private view returns(uint256)\r\n    {\r\n        QIU3Ddatasets.Match memory _match_ = matches_[_matchId];\r\n        uint256 _betJackpot = ((_match_.ticketFund.mul(BxTJPPercentage)).div(100)).add((_match_.betFund.mul(BxBJPPercentage)).div(100));\r\n        return (_betJackpot);\r\n    }\r\n\r\n    /**\r\n    * @dev get ticket jackpot\r\n    */\r\n    function getTicketJackpot_(uint256 _matchId, uint256 _remainBetJackpot) private view returns(uint256)\r\n    {\r\n        QIU3Ddatasets.Match memory _match_ = matches_[_matchId];\r\n        uint256 _ticketJackpot = (_match_.ticketFund.mul(TxTJPPercentage)).div(100);\r\n        _ticketJackpot = _ticketJackpot.add(_remainBetJackpot);\r\n        return (_ticketJackpot);\r\n    }\r\n\r\n    /**\r\n    * @dev get ticket dividend\r\n    */\r\n    function getTicketDividendFromJackpot_(uint256 _matchId, uint256 _remainTicketJackpot) private view returns(uint256)\r\n    {\r\n        QIU3Ddatasets.Match memory _match_ = matches_[_matchId];\r\n        uint256 _totalDividend = (_match_.ticketFund.mul(DxTJPPercentage)).div(100);\r\n        if(_match_.ended){\r\n            _totalDividend = _totalDividend.add((_match_.betFund.mul(DxBJPPercentage)).div(100));\r\n            _totalDividend = _totalDividend.add(_remainTicketJackpot);\r\n        }\r\n        uint256 _ticketDividend = (_totalDividend.mul(TxDJPPercentage)).div(100);\r\n        return (_ticketDividend);\r\n    }\r\n\r\n    /**\r\n    * @dev get foundation dividend\r\n    */\r\n    function getFoundationDividendFromJackpot_(uint256 _matchId) private view returns(uint256)\r\n    {\r\n        QIU3Ddatasets.Match memory _match_ = matches_[_matchId];\r\n        uint256 _totalDividend = ((_match_.ticketFund.mul(DxTJPPercentage)).div(100)).add((_match_.betFund.mul(DxBJPPercentage)).div(100));\r\n\r\n        uint256 _betClearedProfit = getBetClearedProfit_(_matchId, _match_.compressedData);\r\n        uint256 _ticketJackpot = getTicketJackpot_(_matchId, _betClearedProfit);\r\n        QIU3Ddatasets.TicketEventIntReturns memory _profitReturns_ = calculateTicketProfitAssign_(\r\n            _matchId, \r\n            _match_.compressedData, \r\n            _ticketJackpot, \r\n            _profitReturns_);\r\n        \r\n        if(_profitReturns_.count == 0){\r\n            _totalDividend = _totalDividend.add(_ticketJackpot);\r\n        }\r\n\r\n        uint256 _foundationDividend = (_totalDividend.mul(FxDJPPercentage)).div(100);\r\n        return (_foundationDividend);\r\n    }\r\n\r\n    /**\r\n    * @dev compare two compressed ticket option and return bool resuts\r\n    */\r\n    function compareOptionsResult_(uint256 optionData, uint256 resultData, QIU3Ddatasets.TicketEventBoolReturns memory _eventReturns_) \r\n        private pure returns(QIU3Ddatasets.TicketEventBoolReturns)\r\n    {\r\n        _eventReturns_.fullMatch = (optionData % 10 == resultData % 10);\r\n        _eventReturns_.totalGoal = ((optionData % 1000)/10 == (resultData % 1000)/10) && ((resultData % 1000)/10 != InvalidTotalGoals);\r\n        _eventReturns_.gapGoal = ((optionData % 100000)/1000 == (resultData % 100000)/1000) && ((resultData % 100000)/1000 != InvalidGapGoals);\r\n        _eventReturns_.bothGoal = ((optionData % 1000000)/100000 == (resultData % 1000000)/100000);\r\n        _eventReturns_.halfAndFullMatch = ((optionData % 10000000)/1000000 == (resultData % 10000000)/1000000);\r\n        return (_eventReturns_);\r\n    }\r\n\r\n    /**\r\n    * @dev convert match score to ticket options value and compress to uint256\r\n    */\r\n    function getCompressedMatchResult_(uint256 _halfHomeGoals, uint256 _halfAwayGoals, uint256 _homeGoals, uint256 _awayGoals)\r\n        private pure returns (uint256)\r\n    {\r\n        uint256 validCount = 5;\r\n        //calculate full time match result\r\n        uint256 fullMatchResult;\r\n        //calculate gap goal = home goals - away goals\r\n        uint256 gapGoal;\r\n        if(_homeGoals >= _awayGoals){\r\n            gapGoal = (_homeGoals.sub(_awayGoals)).add(5);\r\n            if(gapGoal > 10){\r\n                gapGoal = InvalidGapGoals;\r\n                validCount = validCount.sub(1);\r\n            }\r\n        }else{\r\n            gapGoal = _awayGoals.sub(_homeGoals);\r\n            if(gapGoal > 5){\r\n                gapGoal = InvalidGapGoals;\r\n                validCount = validCount.sub(1);\r\n            }else{\r\n                gapGoal = 5 - gapGoal;\r\n            }\r\n        }\r\n        uint256 halfAndFullResult;\r\n        //calculate half and full time match result\r\n        if(_homeGoals > _awayGoals){\r\n            fullMatchResult = 1;\r\n            if(_halfHomeGoals > _halfAwayGoals){\r\n                halfAndFullResult = 1;\r\n            }else if(_halfHomeGoals == _halfAwayGoals){\r\n                halfAndFullResult = 2;\r\n            }else{\r\n                halfAndFullResult = 3;\r\n            }\r\n        }else if(_homeGoals == _awayGoals){\r\n            fullMatchResult = 2;\r\n            if(_halfHomeGoals > _halfAwayGoals){\r\n                halfAndFullResult = 4;\r\n            }else if(_halfHomeGoals == _halfAwayGoals){\r\n                halfAndFullResult = 5;\r\n            }else{\r\n                halfAndFullResult = 6;\r\n            }\r\n        }else{\r\n            fullMatchResult = 3;\r\n            if(_halfHomeGoals > _halfAwayGoals){\r\n                halfAndFullResult = 7;\r\n            }else if(_halfHomeGoals == _halfAwayGoals){\r\n                halfAndFullResult = 8;\r\n            }else{\r\n                halfAndFullResult = 9;\r\n            }\r\n        }\r\n        //calculate both team goals result\r\n        uint256 bothGoalResult = 1;\r\n        if(_homeGoals == 0 || _awayGoals == 0){\r\n            bothGoalResult = 2;\r\n        }\r\n        //calculate total goals result\r\n        uint256 totalGoalResult = _homeGoals + _awayGoals;\r\n        if(totalGoalResult > 9){\r\n            totalGoalResult = InvalidTotalGoals;\r\n            validCount = validCount.sub(1);\r\n        }\r\n\r\n        uint256 compressedData = fullMatchResult;\r\n        compressedData = compressedData.add(totalGoalResult.mul(10));\r\n        compressedData = compressedData.add(gapGoal.mul(1000));\r\n        compressedData = compressedData.add(bothGoalResult.mul(100000));\r\n        compressedData = compressedData.add(halfAndFullResult.mul(1000000));\r\n        compressedData = compressedData.add(validCount.mul(10000000));\r\n\r\n        return (compressedData);\r\n    }\r\n\r\n    /**\r\n    * @dev decompress ticket options\r\n    */\r\n    function getDecompressedOptions_(uint256 _compressData, QIU3Ddatasets.TicketEventIntReturns memory _eventReturns_) \r\n        private pure returns (QIU3Ddatasets.TicketEventIntReturns)\r\n    {\r\n        _eventReturns_.fullMatch = _compressData % 10;\r\n        _eventReturns_.totalGoal = (_compressData % 1000)/10;\r\n        _eventReturns_.gapGoal = (_compressData % 100000)/1000;\r\n        _eventReturns_.bothGoal = (_compressData % 1000000)/100000;\r\n        _eventReturns_.halfAndFullMatch = (_compressData % 10000000)/1000000;\r\n        _eventReturns_.count = _compressData/10000000;\r\n        return (_eventReturns_);\r\n    }\r\n}\r\n\r\n\r\n//==================================================\r\n// Interface\r\n//==================================================\r\ninterface Q3DMatchDataInterface {\r\n   function getOpenMatchBaseInfo() external view returns(uint256, uint256);\r\n   function getMatchStatus(uint256 _matchId) external view returns(bool, uint256, uint256, uint256, uint256);\r\n}\r\n\r\n//==================================================\r\n// Structs - Storage \r\n//==================================================\r\n\r\nlibrary QIU3Ddatasets{\r\n\r\n    struct Match{\r\n        bool ended;                     //if match ended\r\n        uint256 matchId;                //ID of soccer match      \r\n        uint256 endts;                  //match end timestamp\r\n        uint256 currentPrice;           //current ticket price\r\n        uint256 ticketFund;             //fund of ticket\r\n        uint256 betFund;                //fund of bet\r\n        uint256 compressedData;         //compressed options for match result\r\n        uint256[] ticketIds;            //ticket IDs in this match\r\n        uint256[] betIds;               //bet IDs in this match\r\n        mapping(uint256 => Ticket) tickets; //(ticketID => Ticket) return card by cardId\r\n        mapping(uint256 => Bet) bets;   //(betId => Bet) return bet by betId\r\n        mapping(address => MatchPlayer) matchPlayers;   //(address => MatchPlayer) return player in match by address\r\n    }\r\n\r\n    struct Player{\r\n        uint256 lastBuyTicketMatchId;   //save the last match ID when player buy ticket, check the player have right to invit other players\r\n        uint256 inviteProfit;   //profit by invite player\r\n        uint256 withdraw;       //player total withdraw\r\n        uint256[] matchIds;     //IDs of player join matches\r\n    }\r\n\r\n    struct MatchPlayer{\r\n        uint256[] ticketIds; \r\n        uint256[] betIds;\r\n    }\r\n\r\n    //====== Ticket Options ======\r\n    // compressedData Ticet Options\r\n    // [7][6][5][4-3][2-1][0]\r\n    // [0]: Full time match result option(0 - 9)\r\n        // 0 - none\r\n        // 1 - home team win \r\n        // 2 - draw\r\n        // 3 - away team win \r\n    // [2-1]: Full time total goals option(0 - 9)\r\n        // 88 - none\r\n    // [4-3]: Home goals minus Away goals option(0 - 99)\r\n        // 88 - none\r\n    // [5]: Both team goal(0 - 9)\r\n        // 0 - none\r\n        // 1 - yes\r\n        // 2 - no\r\n    // [6]: Half and full time match result option(0 - 9)\r\n        // 0 - none\r\n        // 1 - home/home\r\n        // 2 - home/draw\r\n        // 3 - home/away\r\n        // 4 - draw/home\r\n        // 5 - draw/draw\r\n        // 6 - draw/away\r\n        // 7 - away/home\r\n        // 8 - away/draw\r\n        // 9 - away/away\r\n    // [7]: valid option count(0 - 9)\r\n    struct Ticket{\r\n        uint256 compressedData;     //compressed ticket options data\r\n        uint256 ticketId;       //ID of ticket\r\n        address playerAddr;     //address of player\r\n        uint256 ticketValue;    //value of ticket\r\n        uint256 cost;           //cost of buy ticket\r\n    }\r\n\r\n    struct Bet{\r\n        uint256 betId;          //ID of bet\r\n        address playerAddr;     //address of player\r\n        uint256 option;           //player selected option (0 - home, 1 - draw , 2- away)\r\n        uint256 odds;           //odds when player bet\r\n        uint256 cost;           //cost of bet\r\n    }\r\n\r\n    struct MatchBetOptions{\r\n        bool betOpened;\r\n        uint256 homeBetReturns;\r\n        uint256 drawBetReturns;\r\n        uint256 awayBetReturns;\r\n    }\r\n\r\n    //==================================================\r\n    // Structs - Returns value\r\n    //==================================================\r\n    struct BetReturns{\r\n        bool opened;\r\n        uint256 homeOdds;\r\n        uint256 drawOdds;\r\n        uint256 awayOdds;\r\n        uint256 homeMaxSell;\r\n        uint256 drawMaxSell;\r\n        uint256 awayMaxSell; \r\n    }\r\n\r\n    struct TicketEventIntReturns{\r\n        uint256 fullMatch;\r\n        uint256 totalGoal;\r\n        uint256 gapGoal;\r\n        uint256 bothGoal;\r\n        uint256 halfAndFullMatch;\r\n        uint256 count;\r\n    }\r\n\r\n    struct TicketEventBoolReturns{\r\n        bool fullMatch;\r\n        bool totalGoal;\r\n        bool gapGoal;\r\n        bool bothGoal;\r\n        bool halfAndFullMatch;\r\n        uint256 count;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players_\",\"outputs\":[{\"name\":\"lastBuyTicketMatchId\",\"type\":\"uint256\"},{\"name\":\"inviteProfit\",\"type\":\"uint256\"},{\"name\":\"withdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint256\"},{\"name\":\"_fullMatResOpt\",\"type\":\"uint256\"},{\"name\":\"_goalsOpt\",\"type\":\"uint256\"},{\"name\":\"_gapGoalsOpt\",\"type\":\"uint256\"},{\"name\":\"_bothGoalOpt\",\"type\":\"uint256\"},{\"name\":\"_halfAndFullMatResOpt\",\"type\":\"uint256\"},{\"name\":\"_vaultEth\",\"type\":\"uint256\"},{\"name\":\"_inviteAddr\",\"type\":\"address\"}],\"name\":\"buyTicketWithVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matches_\",\"outputs\":[{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"endts\",\"type\":\"uint256\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"ticketFund\",\"type\":\"uint256\"},{\"name\":\"betFund\",\"type\":\"uint256\"},{\"name\":\"compressedData\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matchIds_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint256\"},{\"name\":\"_ticketId\",\"type\":\"uint256\"}],\"name\":\"getTicketProfitAndDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketOptionValues_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_option\",\"type\":\"uint256\"},{\"name\":\"_odds\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerInGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint256\"}],\"name\":\"getBetProfit_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint256\"},{\"name\":\"_fullMatResOpt\",\"type\":\"uint256\"},{\"name\":\"_goalsOpt\",\"type\":\"uint256\"},{\"name\":\"_gapGoalsOpt\",\"type\":\"uint256\"},{\"name\":\"_bothGoalOpt\",\"type\":\"uint256\"},{\"name\":\"_halfAndFullMatResOpt\",\"type\":\"uint256\"},{\"name\":\"_inviteAddr\",\"type\":\"address\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betOptions_\",\"outputs\":[{\"name\":\"betOpened\",\"type\":\"bool\"},{\"name\":\"homeBetReturns\",\"type\":\"uint256\"},{\"name\":\"drawBetReturns\",\"type\":\"uint256\"},{\"name\":\"awayBetReturns\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_option\",\"type\":\"uint256\"},{\"name\":\"_odds\",\"type\":\"uint256\"},{\"name\":\"_vaultEth\",\"type\":\"uint256\"}],\"name\":\"betWithVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getPlayerProfitInMatch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foundationAddr\",\"type\":\"address\"}],\"name\":\"setFoundationAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openMatchId_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_matchDataAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ticketId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fullMatResOpt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"goalsOpt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gapGoalsOpt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bothGoalOpt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"halfAndFullMatResOpt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ticketValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"onNewTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"option\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"odds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"onNewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressData\",\"type\":\"uint256\"}],\"name\":\"onEndMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"onInvite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdraw\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawType\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"}]","ContractName":"QIU3D","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000785839b325518b2ef6af7384aa5df07520bbebc7","Library":"","SwarmSource":"bzzr://d7920e64524901cc82d235b320fc47f53376a3d2a3ac41a4fd5bda316eebd6ee"}]}