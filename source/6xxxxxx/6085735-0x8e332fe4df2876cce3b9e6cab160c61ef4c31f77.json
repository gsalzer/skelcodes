{"status":"1","message":"OK","result":[{"SourceCode":"// Author: Nick Mudge <nick@perfectabstractions.com>\r\n// Perfect Abstractions LLC\r\n\r\npragma solidity 0.4.24;\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `safetransfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/eips/issues/721\r\n */\r\ninterface ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _tokenOwner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _tokenOwner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _tokenOwner) external view returns (uint256 _balance);\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address _tokenOwner);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    function approve(address _to, uint256 _tokenId) external;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address _operator);\r\n\r\n    function isApprovedForAll(address _tokenOwner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC20AndERC223 {\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function transfer(address to, uint value) external returns (bool success);\r\n    function transfer(address to, uint value, bytes data) external returns (bool success);\r\n}\r\n\r\n\r\ninterface ERC998ERC721BottomUp {\r\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;\r\n\r\n}\r\n\r\ncontract AbstractMokens {\r\n    address public owner;\r\n\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n\r\n    //tokenId to moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength = 0;\r\n\r\n    // tokenId => token API URL\r\n    string public defaultURIStart = \"https://api.mokens.io/moken/\";\r\n    string public defaultURIEnd = \".json\";\r\n\r\n    // the block number Mokens is deployed in\r\n    uint256 public blockNum;\r\n\r\n    // index to era\r\n    mapping(uint256 => bytes32) internal eras;\r\n    uint256 internal eraLength = 0;\r\n    // era to index+1\r\n    mapping(bytes32 => uint256) internal eraIndex;\r\n\r\n    uint256 public mintPriceOffset = 0 szabo;\r\n    uint256 public mintStepPrice = 500 szabo;\r\n    uint256 public mintPriceBuffer = 5000 szabo;\r\n\r\n    /// @dev Magic value to be returned upon successful reception of an NFT\r\n    bytes4 constant ERC721_RECEIVED_NEW = 0x150b7a02;\r\n    bytes4 constant ERC721_RECEIVED_OLD = 0xf0b9e5ba;\r\n    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;\r\n\r\n    uint256 constant UINT16_MASK = 0x000000000000000000000000000000000000000000000000000000000000ffff;\r\n    uint256 constant MOKEN_LINK_HASH_MASK = 0xffffffffffffffff000000000000000000000000000000000000000000000000;\r\n    uint256 constant MOKEN_DATA_MASK = 0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant MAX_MOKENS = 4294967296;\r\n    uint256 constant MAX_OWNER_MOKENS = 65536;\r\n\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\r\n\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n\r\n    address[] internal mintContracts;\r\n    mapping(address => uint256) internal mintContractIndex;\r\n\r\n    //moken name to tokenId+1\r\n    mapping(string => uint256) internal tokenByName_;\r\n\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n\r\n    // contract that contains other functions needed\r\n    address public delegate;\r\n\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\r\n    // Events\r\n    // ERC721\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _tokenOwner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _tokenOwner, address indexed _operator, bool _approved);\r\n    //ERC998ERC721TopDown\r\n    event ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId);\r\n    event TransferChild(uint256 indexed tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\r\n    //ERC998ERC20TopDown\r\n    event ReceivedERC20(address indexed _from, uint256 indexed _tokenId, address indexed _erc20Contract, uint256 _value);\r\n    event TransferERC20(uint256 indexed _tokenId, address indexed _to, address indexed _erc20Contract, uint256 _value);\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(addr)}\r\n        return size > 0;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Must be the contract owner.\");\r\n        _;\r\n    }\r\n\r\n    /*\r\n    function getSize() external view returns (uint256) {\r\n        uint256 size;\r\n        address addr = address(this);\r\n        assembly {size := extcodesize(addr)}\r\n        return size;\r\n    }\r\n    */\r\n\r\n    // Use Cases handled:\r\n    // Case 1: Token owner is this contract and token\r\n    // Case 2: Token owner is this contract and top-down composable.\r\n    // Case 3: Token owner is top-down composable\r\n    // Case 4: Token owner is an unknown contract\r\n    // Case 5: Token owner is a user\r\n    // Case 6: Token owner is a bottom-up composable\r\n    // Case 7: Token owner is ERC721 token owned by top-down token\r\n    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n    // Case 9: Token owner is ERC721 token owned by user\r\n    function rootOwnerOf(uint256 _tokenId) public view returns (bytes32 rootOwner) {\r\n        address rootOwnerAddress = address(mokens[_tokenId].data);\r\n        require(rootOwnerAddress != address(0), \"tokenId not found.\");\r\n        uint256 parentTokenId;\r\n        bool isParent;\r\n\r\n        while (rootOwnerAddress == address(this)) {\r\n            parentTokenId = mokens[_tokenId].parentTokenId;\r\n            isParent = parentTokenId > 0;\r\n            if(isParent) {\r\n                // Case 1: Token owner is this contract and token\r\n                _tokenId = parentTokenId - 1;\r\n            }\r\n            else {\r\n                // Case 2: Token owner is this contract and top-down composable.\r\n                _tokenId = childTokenOwner[rootOwnerAddress][_tokenId]-1;\r\n            }\r\n            rootOwnerAddress = address(mokens[_tokenId].data);\r\n        }\r\n\r\n        parentTokenId = mokens[_tokenId].parentTokenId;\r\n        isParent = parentTokenId > 0;\r\n        if(isParent) {\r\n            parentTokenId--;\r\n        }\r\n\r\n        bytes memory calldata;\r\n        bool callSuccess;\r\n\r\n        if (isParent == false) {\r\n\r\n            // success if this token is owned by a top-down token\r\n            // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n            calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 3: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // Case 4: Token owner is an unknown contract\r\n                // Or\r\n                // Case 5: Token owner is a user\r\n                return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n            }\r\n        }\r\n        else {\r\n\r\n            // 0x43a61a8e == rootOwnerOf(uint256)\r\n            calldata = abi.encodeWithSelector(0x43a61a8e, parentTokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 6: Token owner is a bottom-up composable\r\n                // Or\r\n                // Case 2: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // token owner is ERC721\r\n                address childContract = rootOwnerAddress;\r\n                //0x6352211e == \"ownerOf(uint256)\"\r\n                calldata = abi.encodeWithSelector(0x6352211e, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwnerAddress := mload(calldata)\r\n                    }\r\n                }\r\n                require(callSuccess, \"Call to ownerOf failed\");\r\n\r\n                // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n                calldata = abi.encodeWithSelector(0xed81cdda, childContract, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwner := mload(calldata)\r\n                    }\r\n                }\r\n                if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                    // Case 7: Token owner is ERC721 token owned by top-down token\r\n                    return rootOwner;\r\n                }\r\n                else {\r\n                    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n                    // Or\r\n                    // Case 9: Token owner is ERC721 token owned by user\r\n                    return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // returns the owner at the top of the tree of composables\r\n    function rootOwnerOfChild(address _childContract, uint256 _childTokenId) public view returns (bytes32 rootOwner) {\r\n        uint256 tokenId;\r\n        if (_childContract != address(0)) {\r\n            tokenId = childTokenOwner[_childContract][_childTokenId];\r\n            require(tokenId != 0, \"Child token does not exist\");\r\n            tokenId--;\r\n        }\r\n        else {\r\n            tokenId = _childTokenId;\r\n        }\r\n        return rootOwnerOf(tokenId);\r\n    }\r\n\r\n\r\n    function childApproved(address _from, uint256 _tokenId) internal {\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n        if(msg.sender != _from) {\r\n            bytes32 tokenOwner;\r\n            bool callSuccess;\r\n            // 0xeadb80b8 == ownerOfChild(address,uint256)\r\n            bytes memory calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, _from, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    tokenOwner := mload(calldata)\r\n                }\r\n            }\r\n            if(callSuccess == true) {\r\n                require(tokenOwner >> 224 != ERC998_MAGIC_VALUE, \"Token is child of top down composable\");\r\n            }\r\n            require(tokenOwnerToOperators[_from][msg.sender] || approvedAddress == msg.sender, \"msg.sender not _from/operator/approved.\");\r\n        }\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n            emit Approval(_from, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    function _transferFrom(uint256 data, address _to, uint256 _tokenId) internal {\r\n        address _from = address(data);\r\n        //removing the tokenId\r\n        // 1. We replace _tokenId in ownedTokens[_from] with the last token id\r\n        //    in ownedTokens[_from]\r\n        uint256 lastTokenIndex = ownedTokens[_from].length - 1;\r\n        uint256 lastTokenId = ownedTokens[_from][lastTokenIndex];\r\n        if (lastTokenId != _tokenId) {\r\n            uint256 tokenIndex = data >> 160 & UINT16_MASK;\r\n            ownedTokens[_from][tokenIndex] = uint32(lastTokenId);\r\n            // 2. We set lastTokeId to point to its new position in ownedTokens[_from]\r\n            mokens[lastTokenId].data = mokens[lastTokenId].data & 0xffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff | tokenIndex << 160;\r\n        }\r\n        // 3. We remove lastTokenId from the end of ownedTokens[_from]\r\n        ownedTokens[_from].length--;\r\n\r\n        //adding the tokenId\r\n        uint256 ownedTokensIndex = ownedTokens[_to].length;\r\n        // prevents 16 bit overflow\r\n        require(ownedTokensIndex < MAX_OWNER_MOKENS, \"A token owner address cannot possess more than 65,536 mokens.\");\r\n        mokens[_tokenId].data = data & 0xffffffffffffffffffff00000000000000000000000000000000000000000000 | ownedTokensIndex << 160 | uint256(_to);\r\n        ownedTokens[_to].push(uint32(_tokenId));\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n}\r\n\r\n// Author: Nick Mudge <nick@perfectabstractions.com>\r\n// Perfect Abstractions LLC\r\n\r\ncontract MokensDelegate is AbstractMokens {\r\n\r\n\r\n    //Events\r\n    event MintPriceConfigurationChange(\r\n        uint256 mintPrice,\r\n        uint256 mintStepPrice,\r\n        uint256 mintPriceOffset,\r\n        uint256 mintPriceBuffer\r\n    );\r\n    event MintPriceChange(\r\n        uint256 mintPrice\r\n    );\r\n\r\n    event TransferToParent(address indexed _toContract, uint256 indexed _toTokenId, uint256 _tokenId);\r\n    event TransferFromParent(address indexed _fromContract, uint256 indexed _fromTokenId, uint256 _tokenId);\r\n\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* Contract Management ***********************************************************/\r\n\r\n    function withdraw(address _sendTo, uint256 _amount) external onlyOwner {\r\n        address mokensContract = address(this);\r\n        require(_amount <= mokensContract.balance, \"Amount is greater than balance.\");\r\n        _sendTo.transfer(_amount);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"_newOwner cannot be 0 address.\");\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* authentication **************************************************/\r\n\r\n\r\n\r\n\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* LinkHash **************************************************/\r\n\r\n    event LinkHashChange(\r\n        uint256 indexed tokenId,\r\n        bytes32 linkHash\r\n    );\r\n\r\n    // changes the link hash of a moken\r\n    // this enables metadata/content data to be changed for mokens.\r\n    function updateLinkHash(uint256 _tokenId, bytes32 _linkHash) external {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        uint256 data = mokens[_tokenId].data & MOKEN_DATA_MASK | uint256(_linkHash) & MOKEN_LINK_HASH_MASK;\r\n        mokens[_tokenId].data = data;\r\n        emit LinkHashChange(_tokenId, bytes32(data));\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC721MetadataImpl Token URL **************************************************/\r\n\r\n    function setDefaultURIStart(string _defaultURIStart) external onlyOwner {\r\n        defaultURIStart = _defaultURIStart;\r\n    }\r\n\r\n    function setDefaultURIEnd(string _defaultURIEnd) external onlyOwner {\r\n        defaultURIEnd = _defaultURIEnd;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string tokenURIString) {\r\n        require(_tokenId < mokensLength, \"_tokenId does not exist.\");\r\n        return makeIntString(defaultURIStart, _tokenId, defaultURIEnd);\r\n    }\r\n\r\n    // creates a string made from an integer between two strings\r\n    function makeIntString(string startString, uint256 v, string endString) private pure returns (string) {\r\n        uint256 maxlength = 10;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint256 numDigits = 0;\r\n        if (v == 0) {\r\n            numDigits = 1;\r\n            reversed[0] = byte(48);\r\n        }\r\n        else {\r\n            while (v != 0) {\r\n                uint256 remainder = v % 10;\r\n                v = v / 10;\r\n                reversed[numDigits++] = byte(48 + remainder);\r\n            }\r\n        }\r\n        bytes memory startStringBytes = bytes(startString);\r\n        bytes memory endStringBytes = bytes(endString);\r\n        uint256 startStringLength = startStringBytes.length;\r\n        uint256 endStringLength = endStringBytes.length;\r\n        bytes memory newStringBytes = new bytes(startStringLength + numDigits + endStringLength);\r\n        uint256 i;\r\n        for (i = 0; i < startStringLength; i++) {\r\n            newStringBytes[i] = startStringBytes[i];\r\n        }\r\n        for (i = 0; i < numDigits; i++) {\r\n            newStringBytes[i + startStringLength] = reversed[numDigits - 1 - i];\r\n        }\r\n        for (i = 0; i < endStringLength; i++) {\r\n            newStringBytes[i + startStringLength + numDigits] = endStringBytes[i];\r\n        }\r\n        return string(newStringBytes);\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* Eras  **************************************************/\r\n\r\n    event NewEra(\r\n        uint256 index,\r\n        bytes32 name,\r\n        uint256 startTokenId\r\n    );\r\n\r\n\r\n    function startNextEra_(bytes32 _eraName) private returns (uint256 index, uint256 startTokenId) {\r\n        require(_eraName != 0, \"eraName is empty string.\");\r\n        require(eraIndex[_eraName] == 0, \"Era name already exists.\");\r\n        startTokenId = mokensLength;\r\n        index = eraLength++;\r\n        eras[index] = _eraName;\r\n        eraIndex[_eraName] = index + 1;\r\n        emit NewEra(index, _eraName, startTokenId);\r\n        return (index, startTokenId);\r\n    }\r\n\r\n    // It is predicted that often a new era comes with a mint price change\r\n    function startNextEra(bytes32 _eraName, uint256 _mintStepPrice, uint256 _mintPriceOffset, uint256 _mintPriceBuffer) external onlyOwner\r\n    returns (uint256 index, uint256 startTokenId, uint256 mintPrice) {\r\n        require(_mintStepPrice < 10000 ether, \"mintStepPrice must be less than 10,000 ether.\");\r\n        mintStepPrice = _mintStepPrice;\r\n        mintPriceOffset = _mintPriceOffset;\r\n        mintPriceBuffer = _mintPriceBuffer;\r\n        uint256 totalStepPrice = mokensLength * _mintStepPrice;\r\n        require(totalStepPrice >= _mintPriceOffset, \"(mokensLength * mintStepPrice) must be greater than or equal to mintPriceOffset.\");\r\n        mintPrice = totalStepPrice - _mintPriceOffset;\r\n        emit MintPriceConfigurationChange(mintPrice, _mintStepPrice, _mintPriceOffset, _mintPriceBuffer);\r\n        emit MintPriceChange(mintPrice);\r\n        (index, startTokenId) = startNextEra_(_eraName);\r\n        return (index, startTokenId, mintPrice);\r\n    }\r\n\r\n    function startNextEra(bytes32 _eraName) external onlyOwner returns (uint256 index, uint256 startTokenId) {\r\n        return startNextEra_(_eraName);\r\n    }\r\n\r\n    function setMintPrice(uint256 _mintStepPrice, uint256 _mintPriceOffset, uint256 _mintPriceBuffer) external onlyOwner returns (uint256 mintPrice) {\r\n        require(_mintStepPrice < 10000 ether, \"mintStepPrice must be less than 10,000 ether.\");\r\n        mintStepPrice = _mintStepPrice;\r\n        mintPriceOffset = _mintPriceOffset;\r\n        mintPriceBuffer = _mintPriceBuffer;\r\n        uint256 totalStepPrice = mokensLength * _mintStepPrice;\r\n        require(totalStepPrice >= _mintPriceOffset, \"(mokensLength * mintStepPrice) must be greater than or equal to mintPriceOffset.\");\r\n        mintPrice = totalStepPrice - _mintPriceOffset;\r\n        emit MintPriceConfigurationChange(mintPrice, _mintStepPrice, _mintPriceOffset, _mintPriceBuffer);\r\n        emit MintPriceChange(mintPrice);\r\n        return mintPrice;\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* Minting  **************************************************/\r\n    // add contract to list of contracts that can mint mokens\r\n    function addMintContract(address _contract) external onlyOwner {\r\n        require(isContract(_contract), \"Address is not a contract.\");\r\n        require(mintContractIndex[_contract] == 0, \"Contract already added.\");\r\n        mintContracts.push(_contract);\r\n        mintContractIndex[_contract] = mintContracts.length;\r\n    }\r\n\r\n    function removeMintContract(address _contract) external onlyOwner {\r\n        uint256 index = mintContractIndex[_contract];\r\n        require(index != 0, \"Mint contract was not added.\");\r\n        uint256 lastIndex = mintContracts.length - 1;\r\n        address lastMintContract = mintContracts[lastIndex];\r\n        mintContracts[index - 1] = lastMintContract;\r\n        mintContractIndex[lastMintContract] = index;\r\n        delete mintContractIndex[_contract];\r\n        mintContracts.length--;\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC998ERC721 Top Down Composable  **************************************************/\r\n\r\n    function removeChild(uint256 _fromTokenId, address _childContract, uint256 _childTokenId) private {\r\n        // remove child token\r\n        uint256 lastTokenIndex = childTokens[_fromTokenId][_childContract].length - 1;\r\n        uint256 lastToken = childTokens[_fromTokenId][_childContract][lastTokenIndex];\r\n        if (_childTokenId != lastToken) {\r\n            uint256 tokenIndex = childTokenIndex[_fromTokenId][_childContract][_childTokenId];\r\n            childTokens[_fromTokenId][_childContract][tokenIndex] = lastToken;\r\n            childTokenIndex[_fromTokenId][_childContract][lastToken] = tokenIndex;\r\n        }\r\n        childTokens[_fromTokenId][_childContract].length--;\r\n        delete childTokenIndex[_fromTokenId][_childContract][_childTokenId];\r\n        delete childTokenOwner[_childContract][_childTokenId];\r\n\r\n        // remove contract\r\n        if (lastTokenIndex == 0) {\r\n            uint256 lastContractIndex = childContracts[_fromTokenId].length - 1;\r\n            address lastContract = childContracts[_fromTokenId][lastContractIndex];\r\n            if (_childContract != lastContract) {\r\n                uint256 contractIndex = childContractIndex[_fromTokenId][_childContract];\r\n                childContracts[_fromTokenId][contractIndex] = lastContract;\r\n                childContractIndex[_fromTokenId][lastContract] = contractIndex;\r\n            }\r\n            childContracts[_fromTokenId].length--;\r\n            delete childContractIndex[_fromTokenId][_childContract];\r\n        }\r\n    }\r\n\r\n\r\n    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external {\r\n        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(tokenId != 0, \"Child token does not exist\");\r\n        require(_fromTokenId == tokenId - 1, \"_fromTokenId does not own the child token.\");\r\n        require(_to != address(0), \"_to cannot be 0 address.\");\r\n        address rootOwner = address(rootOwnerOf(_fromTokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        removeChild(_fromTokenId, _childContract, _childTokenId);\r\n        ERC721(_childContract).safeTransferFrom(this, _to, _childTokenId);\r\n        emit TransferChild(_fromTokenId, _to, _childContract, _childTokenId);\r\n    }\r\n\r\n    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external {\r\n        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(tokenId != 0, \"Child token does not exist\");\r\n        require(_fromTokenId == tokenId - 1, \"_fromTokenId does not own the child token.\");\r\n        require(_to != address(0), \"_to cannot be 0 address.\");\r\n        address rootOwner = address(rootOwnerOf(_fromTokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        removeChild(_fromTokenId, _childContract, _childTokenId);\r\n        ERC721(_childContract).safeTransferFrom(this, _to, _childTokenId, _data);\r\n        emit TransferChild(_fromTokenId, _to, _childContract, _childTokenId);\r\n    }\r\n\r\n    function transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external {\r\n        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(tokenId != 0, \"Child token does not exist\");\r\n        require(_fromTokenId == tokenId - 1, \"_fromTokenId does not own the child token.\");\r\n        require(_to != address(0), \"_to cannot be 0 address.\");\r\n        address rootOwner = address(rootOwnerOf(_fromTokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        removeChild(_fromTokenId, _childContract, _childTokenId);\r\n        //this is here to be compatible with cryptokitties and other old contracts that require being owner and approved\r\n        // before transferring.\r\n        //It is not required by current standard , so we let it fail if it fails\r\n        //0x095ea7b3 == \"approve(address,uint256)\"\r\n        bytes memory calldata = abi.encodeWithSelector(0x095ea7b3, this, _childTokenId);\r\n        assembly {\r\n            let success := call(gas, _childContract, 0, add(calldata, 0x20), mload(calldata), calldata, 0)\r\n        }\r\n        ERC721(_childContract).transferFrom(this, _to, _childTokenId);\r\n        emit TransferChild(_fromTokenId, _to, _childContract, _childTokenId);\r\n    }\r\n\r\n    function transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external {\r\n        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(tokenId != 0, \"Child token does not exist\");\r\n        require(_fromTokenId == tokenId - 1, \"_fromTokenId does not own the child token.\");\r\n        require(_toContract != address(0), \"_toContract cannot be 0 address.\");\r\n        address rootOwner = address(rootOwnerOf(_fromTokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        removeChild(_fromTokenId, _childContract, _childTokenId);\r\n        ERC998ERC721BottomUp(_childContract).transferToParent(address(this), _toContract, _toTokenId, _childTokenId, _data);\r\n        emit TransferChild(_fromTokenId, _toContract, _childContract, _childTokenId);\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC998ERC20 Top Down Composable  **************************************************/\r\n    function removeERC20(uint256 _tokenId, address _erc20Contract, uint256 _value) private {\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];\r\n        require(erc20Balance >= _value, \"Not enough token available to transfer.\");\r\n        uint256 newERC20Balance = erc20Balance - _value;\r\n        erc20Balances[_tokenId][_erc20Contract] = newERC20Balance;\r\n        if (newERC20Balance == 0) {\r\n            uint256 lastContractIndex = erc20Contracts[_tokenId].length - 1;\r\n            address lastContract = erc20Contracts[_tokenId][lastContractIndex];\r\n            if (_erc20Contract != lastContract) {\r\n                uint256 contractIndex = erc20ContractIndex[_tokenId][_erc20Contract];\r\n                erc20Contracts[_tokenId][contractIndex] = lastContract;\r\n                erc20ContractIndex[_tokenId][lastContract] = contractIndex;\r\n            }\r\n            erc20Contracts[_tokenId].length--;\r\n            delete erc20ContractIndex[_tokenId][_erc20Contract];\r\n        }\r\n    }\r\n\r\n\r\n    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        require(_to != address(0), \"_to cannot be 0 address\");\r\n        removeERC20(_tokenId, _erc20Contract, _value);\r\n        require(ERC20AndERC223(_erc20Contract).transfer(_to, _value), \"ERC20 transfer failed.\");\r\n        emit TransferERC20(_tokenId, _to, _erc20Contract, _value);\r\n    }\r\n\r\n    // implementation of ERC 223\r\n    function transferERC223(uint256 _tokenId, address _to, address _erc223Contract, uint256 _value, bytes _data) external {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        require(_to != address(0), \"_to cannot be 0 address\");\r\n        removeERC20(_tokenId, _erc223Contract, _value);\r\n        require(ERC20AndERC223(_erc223Contract).transfer(_to, _value, _data), \"ERC223 transfer failed.\");\r\n        emit TransferERC20(_tokenId, _to, _erc223Contract, _value);\r\n    }\r\n\r\n    // this contract has to be approved first by _erc20Contract\r\n    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) public {\r\n        bool allowed = _from == msg.sender;\r\n        if (!allowed) {\r\n            uint256 remaining;\r\n            // 0xdd62ed3e == allowance(address,address)\r\n            bytes memory calldata = abi.encodeWithSelector(0xdd62ed3e, _from, msg.sender);\r\n            bool callSuccess;\r\n            assembly {\r\n                callSuccess := staticcall(gas, _erc20Contract, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    remaining := mload(calldata)\r\n                }\r\n            }\r\n            require(callSuccess, \"call to allowance failed\");\r\n            require(remaining >= _value, \"Value greater than remaining\");\r\n            allowed = true;\r\n        }\r\n        require(allowed, \"msg.sender not _from and has no allowance.\");\r\n        erc20Received(_from, _tokenId, _erc20Contract, _value);\r\n        require(ERC20AndERC223(_erc20Contract).transferFrom(_from, this, _value), \"ERC20 transfer failed.\");\r\n    }\r\n\r\n    function erc20Received(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) private {\r\n        require(address(mokens[_tokenId].data) != address(0), \"_tokenId does not exist.\");\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];\r\n        if (erc20Balance == 0) {\r\n            erc20ContractIndex[_tokenId][_erc20Contract] = erc20Contracts[_tokenId].length;\r\n            erc20Contracts[_tokenId].push(_erc20Contract);\r\n        }\r\n        erc20Balances[_tokenId][_erc20Contract] += _value;\r\n        emit ReceivedERC20(_from, _tokenId, _erc20Contract, _value);\r\n    }\r\n\r\n    // used by ERC 223\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) external {\r\n        require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the token to.\");\r\n        require(isContract(msg.sender), \"msg.sender is not a contract\");\r\n        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes\r\n        uint256 tokenId;\r\n        assembly {\r\n            tokenId := calldataload(132)\r\n        }\r\n        if (_data.length < 32) {\r\n            tokenId = tokenId >> 256 - _data.length * 8;\r\n        }\r\n        //END TODO\r\n        erc20Received(_from, tokenId, msg.sender, _value);\r\n    }\r\n\r\n\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC998ERC721 Bottom Up Composable  **************************************************/\r\n\r\n    function removeBottomUpChild(address _fromContract, uint256 _fromTokenId, uint256 _tokenId) internal {\r\n        uint256 lastChildTokenIndex = parentToChildTokenIds[_fromContract][_fromTokenId].length - 1;\r\n        uint256 lastChildTokenId = parentToChildTokenIds[_fromContract][_fromTokenId][lastChildTokenIndex];\r\n\r\n        if (_tokenId != lastChildTokenId) {\r\n            uint256 currentChildTokenIndex = tokenIdToChildTokenIdsIndex[_tokenId];\r\n            parentToChildTokenIds[_fromContract][_fromTokenId][currentChildTokenIndex] = uint32(lastChildTokenId);\r\n            tokenIdToChildTokenIdsIndex[lastChildTokenId] = currentChildTokenIndex;\r\n        }\r\n        parentToChildTokenIds[_fromContract][_fromTokenId].length--;\r\n    }\r\n\r\n    function transferFromParent(address _fromContract, uint256 _fromTokenId, address _to, uint256 _tokenId, bytes _data) external {\r\n        require(_fromContract != address(0), \"_fromContract cannot be the 0 address.\");\r\n        require(_to != address(0), \"_to cannot be the 0 address.\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _fromContract, \"The tokenId is not owned by _fromContract.\");\r\n        uint256 parentTokenId = mokens[_tokenId].parentTokenId;\r\n        require(parentTokenId != 0, \"Token does not have a parent token.\");\r\n        require(parentTokenId - 1 == _fromTokenId, \"tokenId not owned by _fromTokenId\");\r\n\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        approvedAddress == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n            emit Approval(rootOwner, address(0), _tokenId);\r\n        }\r\n\r\n        mokens[_tokenId].parentTokenId = 0;\r\n\r\n        removeBottomUpChild(_fromContract, _fromTokenId, _tokenId);\r\n        delete tokenIdToChildTokenIdsIndex[_tokenId];\r\n\r\n        _transferFrom(data, _to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _fromContract, _tokenId, _data);\r\n            require(retval == ERC721_RECEIVED_NEW, \"Contract cannot receive ERC721 token.\");\r\n        }\r\n\r\n        emit TransferFromParent(_fromContract, _fromTokenId, _tokenId);\r\n\r\n    }\r\n\r\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external {\r\n        require(_from != address(0), \"_from cannot be the 0 address.\");\r\n        require(_toContract != address(0), \"toContract cannot be 0\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _from, \"The tokenId is not owned by _from.\");\r\n        require(mokens[_tokenId].parentTokenId == 0, \"Cannot transfer from address when owned by a token.\");\r\n\r\n        childApproved(_from, _tokenId);\r\n\r\n        uint256 parentTokenId = _toTokenId + 1;\r\n        assert(parentTokenId > _toTokenId);\r\n        mokens[_tokenId].parentTokenId = parentTokenId;\r\n\r\n        uint256 index = parentToChildTokenIds[_toContract][_toTokenId].length;\r\n        parentToChildTokenIds[_toContract][_toTokenId].push(uint32(_tokenId));\r\n        tokenIdToChildTokenIdsIndex[_tokenId] = index;\r\n\r\n        _transferFrom(data, _toContract, _tokenId);\r\n\r\n        require(ERC721(_toContract).ownerOf(_toTokenId) != address(0), \"_toTokenId does not exist\");\r\n        emit TransferToParent(_toContract, _toTokenId, _tokenId);\r\n    }\r\n\r\n    function transferAsChild(address _fromContract, uint256 _fromTokenId, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external {\r\n        require(_fromContract != address(0), \"_fromContract cannot be the 0 address.\");\r\n        require(_toContract != address(0), \"_toContract cannot be the 0 address.\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _fromContract, \"The tokenId is not owned by _fromContract.\");\r\n        uint256 parentTokenId = mokens[_tokenId].parentTokenId;\r\n        require(parentTokenId != 0, \"Token does not have a parent token.\");\r\n        require(parentTokenId - 1 == _fromTokenId, \"tokenId not owned by _fromTokenId\");\r\n\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        approvedAddress == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n            emit Approval(rootOwner, address(0), _tokenId);\r\n        }\r\n\r\n        removeBottomUpChild(_fromContract, _fromTokenId, _tokenId);\r\n\r\n        parentTokenId = _toTokenId + 1;\r\n        assert(parentTokenId > _toTokenId);\r\n        mokens[_tokenId].parentTokenId = parentTokenId;\r\n\r\n        uint256 index = parentToChildTokenIds[_toContract][_toTokenId].length;\r\n        parentToChildTokenIds[_toContract][_toTokenId].push(uint32(_tokenId));\r\n        tokenIdToChildTokenIdsIndex[_tokenId] = index;\r\n\r\n        _transferFrom(data, _toContract, _tokenId);\r\n\r\n        require(ERC721(_toContract).ownerOf(_toTokenId) != address(0), \"_toTokenId does not exist\");\r\n\r\n        emit Transfer(_fromContract, _toContract, _tokenId);\r\n        emit TransferFromParent(_fromContract, _fromTokenId, _tokenId);\r\n        emit TransferToParent(_toContract, _toTokenId, _tokenId);\r\n\r\n    }\r\n\r\n    function getStateHash(uint256 _tokenId) public view returns (bytes32 stateHash) {\r\n        address[] memory childContracts_ = childContracts[_tokenId];\r\n        stateHash = keccak256(childContracts_);\r\n        uint256 length = childContracts_.length;\r\n        uint256 i;\r\n        for (i = 0; i < length; i++) {\r\n            stateHash = keccak256(stateHash, childTokens[_tokenId][childContracts_[i]]);\r\n        }\r\n\r\n        address[] memory erc20Contracts_ = erc20Contracts[_tokenId];\r\n        stateHash = keccak256(erc20Contracts_);\r\n        length = erc20Contracts_.length;\r\n        for (i = 0; i < length; i++) {\r\n            stateHash = keccak256(stateHash, erc20Balances[_tokenId][erc20Contracts_[i]]);\r\n        }\r\n\r\n        uint256 linkHash = mokens[_tokenId].data & MOKEN_LINK_HASH_MASK;\r\n        return keccak256(stateHash, linkHash);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"addMintContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultURIEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferChildToParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPriceOffset\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mintStepPrice\",\"type\":\"uint256\"},{\"name\":\"_mintPriceOffset\",\"type\":\"uint256\"},{\"name\":\"_mintPriceBuffer\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[{\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eraName\",\"type\":\"bytes32\"},{\"name\":\"_mintStepPrice\",\"type\":\"uint256\"},{\"name\":\"_mintPriceOffset\",\"type\":\"uint256\"},{\"name\":\"_mintPriceBuffer\",\"type\":\"uint256\"}],\"name\":\"startNextEra\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"rootOwnerOf\",\"outputs\":[{\"name\":\"rootOwner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defaultURIEnd\",\"type\":\"string\"}],\"name\":\"setDefaultURIEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eraName\",\"type\":\"bytes32\"}],\"name\":\"startNextEra\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"startTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getStateHash\",\"outputs\":[{\"name\":\"stateHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defaultURIStart\",\"type\":\"string\"}],\"name\":\"setDefaultURIStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromContract\",\"type\":\"address\"},{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFromParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"transferChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromContract\",\"type\":\"address\"},{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAsChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPriceBuffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"removeMintContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"tokenURIString\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_linkHash\",\"type\":\"bytes32\"}],\"name\":\"updateLinkHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_erc223Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferERC223\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"rootOwnerOfChild\",\"outputs\":[{\"name\":\"rootOwner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sendTo\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferToParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultURIStart\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintStepPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mintStepPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mintPriceOffset\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mintPriceBuffer\",\"type\":\"uint256\"}],\"name\":\"MintPriceConfigurationChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"name\":\"MintPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_toContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"TransferToParent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_fromContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"TransferFromParent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"linkHash\",\"type\":\"bytes32\"}],\"name\":\"LinkHashChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"startTokenId\",\"type\":\"uint256\"}],\"name\":\"NewEra\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"ReceivedChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"TransferChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ReceivedERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferERC20\",\"type\":\"event\"}]","ContractName":"MokensDelegate","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5845217967d9ebe2d39a1224f5a19cd02443fb037f4ed8484f0258bb6da24f5d"}]}