{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*\r\n*\r\n*    __   ____  _________\r\n*   / /  / __ \\/ ___/ __ \\\r\n*  / /__/ /_/ / (_ / /_/ /\r\n* /____/\\____/\\___/\\____/\r\n*\r\n*\r\n*/\r\n\r\n// Contract must have an owner\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) onlyOwner public {\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n// SafeMath methods\r\ncontract SafeMath {\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_a >= _b);\r\n        return _a - _b;\r\n    }\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a * _b;\r\n        assert(_a == 0 || c / _a == _b);\r\n        return c;\r\n    }\r\n}\r\n\r\n// Standard ERC20 Token Interface\r\ninterface ERC20Token {\r\n    function name() external view returns (string _name);\r\n    function symbol() external view returns (string _symbol);\r\n    function decimals() external view returns (uint8 _decimals);\r\n    function totalSupply() external view returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint256 _balance);\r\n    function transfer(address _to, uint256 _value) external returns (bool _success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool _success);\r\n    function approve(address _spender, uint256 _value) external returns (bool _success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 _remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// the main ERC20-compliant multi-timelock enabled contract\r\ncontract TokenMultiTimeLock is SafeMath, Owned, ERC20Token {\r\n    string private constant standard = \"545028\";\r\n    string private constant version = \"alpha\";\r\n    string private _name = \"NTEST\";\r\n    string private _symbol = \"NTST\";\r\n    uint8 private _decimals = 18;\r\n    uint256 private _totalSupply = 2 * 10**9 * uint256(10)**_decimals;\r\n    mapping (address => uint256) private balanceP;\r\n    mapping (address => mapping (address => uint256)) private _allowance;\r\n\r\n    mapping (address => uint256[]) private lockTime;\r\n    mapping (address => uint256[]) private lockValue;\r\n    mapping (address => uint256) private lockNum;\r\n    uint256 private later = 0;\r\n    uint256 private earlier = 0;\r\n\r\n    // burn token event\r\n    event Burn(address indexed _from, uint256 _value);\r\n\r\n    // timelock-related events\r\n    event TransferLocked(address indexed _from, address indexed _to, uint256 _time, uint256 _value);\r\n    event TokenUnlocked(address indexed _address, uint256 _value);\r\n\r\n    // safety method-related events\r\n    event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount);\r\n    event WrongEtherEmptied(address indexed _addr, uint256 _amount);\r\n\r\n    // constructor for the ERC20 Token\r\n    constructor() public {\r\n        balanceP[msg.sender] = _totalSupply;\r\n    }\r\n\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    // fast-forward the timelocks for all accounts\r\n    function setUnlockEarlier(uint256 _earlier) public onlyOwner {\r\n        earlier = add(earlier, _earlier);\r\n    }\r\n\r\n    // delay the timelocks for all accounts\r\n    function setUnlockLater(uint256 _later) public onlyOwner {\r\n        later = add(later, _later);\r\n    }\r\n\r\n    // standard ERC20 name function\r\n    function name() public view returns (string) {\r\n        return _name;\r\n    }\r\n\r\n    // standard ERC20 symbol function\r\n    function symbol() public view returns (string) {\r\n        return _symbol;\r\n    }\r\n\r\n    // standard ERC20 decimals function\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    // standard ERC20 totalSupply function\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // standard ERC20 allowance function\r\n    function allowance(address _owner, address _spender) external view returns (uint256) {\r\n        return _allowance[_owner][_spender];\r\n    }\r\n\r\n    // show unlocked balance of an account\r\n    function balanceUnlocked(address _address) public view returns (uint256 _balance) {\r\n        _balance = balanceP[_address];\r\n        uint256 i = 0;\r\n        while (i < lockNum[_address]) {\r\n            if (add(now, earlier) >= add(lockTime[_address][i], later)) _balance = add(_balance, lockValue[_address][i]);\r\n            i++;\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    // show timelocked balance of an account\r\n    function balanceLocked(address _address) public view returns (uint256 _balance) {\r\n        _balance = 0;\r\n        uint256 i = 0;\r\n        while (i < lockNum[_address]) {\r\n            if (add(now, earlier) < add(lockTime[_address][i], later)) _balance = add(_balance, lockValue[_address][i]);\r\n            i++;\r\n        }\r\n        return  _balance;\r\n    }\r\n\r\n    // standard ERC20 balanceOf with timelock added\r\n    function balanceOf(address _address) public view returns (uint256 _balance) {\r\n        _balance = balanceP[_address];\r\n        uint256 i = 0;\r\n        while (i < lockNum[_address]) {\r\n            _balance = add(_balance, lockValue[_address][i]);\r\n            i++;\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    // show timelocks in an account\r\n    function showLockTimes(address _address) public view validAddress(_address) returns (uint256[] _times) {\r\n        uint i = 0;\r\n        uint256[] memory tempLockTime = new uint256[](lockNum[_address]);\r\n        while (i < lockNum[_address]) {\r\n            tempLockTime[i] = sub(add(lockTime[_address][i], later), earlier);\r\n            i++;\r\n        }\r\n        return tempLockTime;\r\n    }\r\n\r\n    // show values locked in an account's timelocks\r\n    function showLockValues(address _address) public view validAddress(_address) returns (uint256[] _values) {\r\n        return lockValue[_address];\r\n    }\r\n\r\n    function showLockNum(address _address) public view validAddress(_address) returns (uint256 _lockNum) {\r\n        return lockNum[_address];\r\n    }\r\n\r\n    // Calculate and process the timelock states of an account\r\n    function calcUnlock(address _address) private {\r\n        uint256 i = 0;\r\n        uint256 j = 0;\r\n        uint256[] memory currentLockTime;\r\n        uint256[] memory currentLockValue;\r\n        uint256[] memory newLockTime = new uint256[](lockNum[_address]);\r\n        uint256[] memory newLockValue = new uint256[](lockNum[_address]);\r\n        currentLockTime = lockTime[_address];\r\n        currentLockValue = lockValue[_address];\r\n        while (i < lockNum[_address]) {\r\n            if (add(now, earlier) >= add(currentLockTime[i], later)) {\r\n                balanceP[_address] = add(balanceP[_address], currentLockValue[i]);\r\n                emit TokenUnlocked(_address, currentLockValue[i]);\r\n            } else {\r\n                newLockTime[j] = currentLockTime[i];\r\n                newLockValue[j] = currentLockValue[i];\r\n                j++;\r\n            }\r\n            i++;\r\n        }\r\n        uint256[] memory trimLockTime = new uint256[](j);\r\n        uint256[] memory trimLockValue = new uint256[](j);\r\n        i = 0;\r\n        while (i < j) {\r\n            trimLockTime[i] = newLockTime[i];\r\n            trimLockValue[i] = newLockValue[i];\r\n            i++;\r\n        }\r\n        lockTime[_address] = trimLockTime;\r\n        lockValue[_address] = trimLockValue;\r\n        lockNum[_address] = j;\r\n    }\r\n\r\n    // standard ERC20 transfer\r\n    function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool _success) {\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        require(balanceP[msg.sender] >= _value && _value >= 0);\r\n        balanceP[msg.sender] = sub(balanceP[msg.sender], _value);\r\n        balanceP[_to] = add(balanceP[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // transfer Token with timelocks\r\n    function transferLocked(address _to, uint256[] _time, uint256[] _value) public validAddress(_to) returns (bool _success) {\r\n        require(_value.length == _time.length);\r\n\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        uint256 i = 0;\r\n        uint256 totalValue = 0;\r\n        while (i < _value.length) {\r\n            totalValue = add(totalValue, _value[i]);\r\n            i++;\r\n        }\r\n        require(balanceP[msg.sender] >= totalValue && totalValue >= 0);\r\n        require(add(lockNum[msg.sender], _time.length) <= 42);\r\n        i = 0;\r\n        while (i < _time.length) {\r\n            if (_value[i] > 0) {\r\n                balanceP[msg.sender] = sub(balanceP[msg.sender], _value[i]);\r\n                lockTime[_to].length = lockNum[_to]+1;\r\n                lockValue[_to].length = lockNum[_to]+1;\r\n                lockTime[_to][lockNum[_to]] = sub(add(add(now, _time[i]), earlier), later);\r\n                lockValue[_to][lockNum[_to]] = _value[i];\r\n                lockNum[_to]++;\r\n            }\r\n\r\n            // emit custom TransferLocked event\r\n            emit TransferLocked(msg.sender, _to, _time[i], _value[i]);\r\n\r\n            // emit standard Transfer event for wallets\r\n            emit Transfer(msg.sender, _to, _value[i]);\r\n\r\n            i++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // TransferFrom Token with timelocks\r\n    function transferLockedFrom(address _from, address _to, uint256[] _time, uint256[] _value) public\r\n\t    validAddress(_from) validAddress(_to) returns (bool success) {\r\n        require(_value.length == _time.length);\r\n\r\n        if (lockNum[_from] > 0) calcUnlock(_from);\r\n        uint256 i = 0;\r\n        uint256 totalValue = 0;\r\n        while (i < _value.length) {\r\n            totalValue = add(totalValue, _value[i]);\r\n            i++;\r\n        }\r\n        require(balanceP[_from] >= totalValue && totalValue >= 0 && _allowance[_from][msg.sender] >= totalValue);\r\n        require(add(lockNum[_from], _time.length) <= 42);\r\n        i = 0;\r\n        while (i < _time.length) {\r\n            if (_value[i] > 0) {\r\n                balanceP[_from] = sub(balanceP[_from], _value[i]);\r\n                _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value[i]);\r\n                lockTime[_to].length = lockNum[_to]+1;\r\n                lockValue[_to].length = lockNum[_to]+1;\r\n                lockTime[_to][lockNum[_to]] = sub(add(add(now, _time[i]), earlier), later);\r\n                lockValue[_to][lockNum[_to]] = _value[i];\r\n                lockNum[_to]++;\r\n            }\r\n\r\n            // emit custom TransferLocked event\r\n            emit TransferLocked(_from, _to, _time[i], _value[i]);\r\n\r\n            // emit standard Transfer event for wallets\r\n            emit Transfer(_from, _to, _value[i]);\r\n\r\n            i++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // standard ERC20 transferFrom\r\n    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_from) validAddress(_to) returns (bool _success) {\r\n        if (lockNum[_from] > 0) calcUnlock(_from);\r\n        require(balanceP[_from] >= _value && _value >= 0 && _allowance[_from][msg.sender] >= _value);\r\n        _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value);\r\n        balanceP[_from] = sub(balanceP[_from], _value);\r\n        balanceP[_to] = add(balanceP[_to], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // should only be called when first setting an _allowance\r\n    function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool _success) {\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        _allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // increase or decrease _allowance\r\n    function increaseApproval(address _spender, uint _value) public validAddress(_spender) returns (bool _success) {\r\n        _allowance[msg.sender][_spender] = add(_allowance[msg.sender][_spender], _value);\r\n        emit Approval(msg.sender, _spender, _allowance[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _value) public validAddress(_spender) returns (bool _success) {\r\n        if(_value >= _allowance[msg.sender][_spender]) {\r\n            _allowance[msg.sender][_spender] = 0;\r\n        } else {\r\n            _allowance[msg.sender][_spender] = sub(_allowance[msg.sender][_spender], _value);\r\n        }\r\n        emit Approval(msg.sender, _spender, _allowance[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    // owner may burn own token\r\n    function burn(uint256 _value) public onlyOwner returns (bool _success) {\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        require(balanceP[msg.sender] >= _value && _value >= 0);\r\n        balanceP[msg.sender] = sub(balanceP[msg.sender], _value);\r\n        _totalSupply = sub(_totalSupply, _value);\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    // safety methods\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    function emptyWrongToken(address _addr) onlyOwner public {\r\n        ERC20Token wrongToken = ERC20Token(_addr);\r\n        uint256 amount = wrongToken.balanceOf(address(this));\r\n        require(amount > 0);\r\n        require(wrongToken.transfer(msg.sender, amount));\r\n\r\n        emit WrongTokenEmptied(_addr, msg.sender, amount);\r\n    }\r\n\r\n    // shouldn't happen, just in case\r\n    function emptyWrongEther() onlyOwner public {\r\n        uint256 amount = address(this).balance;\r\n        require(amount > 0);\r\n        msg.sender.transfer(amount);\r\n\r\n        emit WrongEtherEmptied(msg.sender, amount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceUnlocked\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"transferLockedFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceLocked\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showLockTimes\",\"outputs\":[{\"name\":\"_times\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showLockValues\",\"outputs\":[{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_later\",\"type\":\"uint256\"}],\"name\":\"setUnlockLater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"emptyWrongToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emptyWrongEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_earlier\",\"type\":\"uint256\"}],\"name\":\"setUnlockEarlier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showLockNum\",\"outputs\":[{\"name\":\"_lockNum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WrongTokenEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WrongEtherEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"TokenMultiTimeLock","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6601c8ec02f13733781cf89cac7592be117536f66ee495d49e6ec7c9e2b7cbb8"}]}