{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n\trequire(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n\tbool wasInitializing = initializing;\r\n\tinitializing = true;\r\n\tinitialized = true;\r\n\r\n\t_;\r\n\r\n\tinitializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n\t// extcodesize checks the size of the code stored in an address, and\r\n\t// address returns the current address. Since the code is still not\r\n\t// deployed when running a constructor, any checks on its code size will\r\n\t// yield zero, making it an effective way to detect if a contract is\r\n\t// under construction or not.\r\n\tuint256 cs;\r\n\tassembly { cs := extcodesize(address) }\r\n\treturn cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n* @title IERC165\r\n* @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n*/\r\ninterface IERC165 {\r\n\r\n/**\r\n* @notice Query if a contract implements an interface\r\n* @param interfaceId The interface identifier, as specified in ERC-165\r\n* @dev Interface identification is specified in ERC-165. This function\r\n* uses less than 30,000 gas.\r\n*/\r\nfunction supportsInterface(bytes4 interfaceId)\r\n\texternal\r\n\tview\r\n\treturns (bool);\r\n}\r\n\r\n/**\r\n* @title ERC165\r\n* @author Matt Condon (@shrugs)\r\n* @dev Implements ERC165 using a lookup table.\r\n*/\r\ncontract ERC165 is IERC165, Initializable {\r\n\r\nbytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\r\n/**\r\n* 0x01ffc9a7 ===\r\n*   bytes4(keccak256('supportsInterface(bytes4)'))\r\n*/\r\n\r\n/**\r\n* @dev a mapping of interface id to whether or not it's supported\r\n*/\r\nmapping(bytes4 => bool) internal _supportedInterfaces;\r\n\r\n/**\r\n* @dev A contract implementing SupportsInterfaceWithLookup\r\n* implement ERC165 itself\r\n*/\r\nfunction initialize() initializer public {\r\n\t_registerInterface(_InterfaceId_ERC165);\r\n}\r\n\r\n/**\r\n* @dev implement supportsInterface(bytes4) using a lookup table\r\n*/\r\nfunction supportsInterface(bytes4 interfaceId)\r\n\texternal\r\n\tview\r\n\treturns (bool)\r\n{\r\n\treturn _supportedInterfaces[interfaceId];\r\n}\r\n\r\n/**\r\n* @dev private method for registering an interface\r\n*/\r\nfunction _registerInterface(bytes4 interfaceId)\r\n\tinternal\r\n{\r\n\trequire(interfaceId != 0xffffffff);\r\n\t_supportedInterfaces[interfaceId] = true;\r\n}\r\n}\r\n\r\n// import \"./ERC721.sol\";\r\n\r\n// import \"./IERC721.sol\";\r\n\r\n// import \"../../introspection/IERC165.sol\";\r\n\r\n/**\r\n* @title ERC721 Non-Fungible Token Standard basic interface\r\n* @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n*/\r\ncontract IERC721 is IERC165 {\r\n\r\nevent Transfer(\r\n\taddress indexed from,\r\n\taddress indexed to,\r\n\tuint256 indexed tokenId\r\n);\r\nevent Approval(\r\n\taddress indexed owner,\r\n\taddress indexed approved,\r\n\tuint256 indexed tokenId\r\n);\r\nevent ApprovalForAll(\r\n\taddress indexed owner,\r\n\taddress indexed operator,\r\n\tbool approved\r\n);\r\n\r\nfunction balanceOf(address owner) public view returns (uint256 balance);\r\nfunction ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\nfunction approve(address to, uint256 tokenId) public;\r\nfunction getApproved(uint256 tokenId)\r\n\tpublic view returns (address operator);\r\n\r\nfunction setApprovalForAll(address operator, bool _approved) public;\r\nfunction isApprovedForAll(address owner, address operator)\r\n\tpublic view returns (bool);\r\n\r\nfunction transferFrom(address from, address to, uint256 tokenId) public;\r\nfunction safeTransferFrom(address from, address to, uint256 tokenId)\r\n\tpublic;\r\n\r\nfunction safeTransferFrom(\r\n\taddress from,\r\n\taddress to,\r\n\tuint256 tokenId,\r\n\tbytes data\r\n)\r\n\tpublic;\r\n}\r\n// import \"./IERC721Receiver.sol\";\r\n\r\n/**\r\n* @title ERC721 token receiver interface\r\n* @dev Interface for any contract that wants to support safeTransfers\r\n* from ERC721 asset contracts.\r\n*/\r\ncontract IERC721Receiver {\r\n/**\r\n* @notice Handle the receipt of an NFT\r\n* @dev The ERC721 smart contract calls this function on the recipient\r\n* after a `safeTransfer`. This function MUST return the function selector,\r\n* otherwise the caller will revert the transaction. The selector to be\r\n* returned can be obtained as `this.onERC721Received.selector`. This\r\n* function MAY throw to revert and reject the transfer.\r\n* Note: the ERC721 contract address is always the message sender.\r\n* @param operator The address which called `safeTransferFrom` function\r\n* @param from The address which previously owned the token\r\n* @param tokenId The NFT identifier which is being transferred\r\n* @param data Additional data with no specified format\r\n* @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n*/\r\nfunction onERC721Received(\r\n\taddress operator,\r\n\taddress from,\r\n\tuint256 tokenId,\r\n\tbytes data\r\n)\r\n\tpublic\r\n\treturns(bytes4);\r\n}\r\n\r\n\r\n// import \"../../math/SafeMath.sol\";\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n/**\r\n* @dev Multiplies two numbers, reverts on overflow.\r\n*/\r\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t// benefit is lost if 'b' is also tested.\r\n\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\tif (a == 0) {\r\n\treturn 0;\r\n\t}\r\n\r\n\tuint256 c = a * b;\r\n\trequire(c / a == b);\r\n\r\n\treturn c;\r\n}\r\n\r\n/**\r\n* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n*/\r\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\trequire(b > 0);// Solidity only automatically asserts when dividing by 0\r\n\tuint256 c = a / b;\r\n\t// assert(a == b * c + a % b);// There is no case in which this doesn't hold\r\n\r\n\treturn c;\r\n}\r\n\r\n/**\r\n* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n*/\r\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\trequire(b <= a);\r\n\tuint256 c = a - b;\r\n\r\n\treturn c;\r\n}\r\n\r\n/**\r\n* @dev Adds two numbers, reverts on overflow.\r\n*/\r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\tuint256 c = a + b;\r\n\trequire(c >= a);\r\n\r\n\treturn c;\r\n}\r\n\r\n/**\r\n* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n* reverts when dividing by zero.\r\n*/\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\trequire(b != 0);\r\n\treturn a % b;\r\n}\r\n}\r\n// import \"../../utils/Address.sol\";\r\n\r\n/**\r\n* Utility library of inline functions on addresses\r\n*/\r\nlibrary Address {\r\n\r\n/**\r\n* Returns whether the target address is a contract\r\n* @dev This function will return false if invoked during the constructor of a contract,\r\n* as the code is not actually created until after the constructor finishes.\r\n* @param account address of the account to check\r\n* @return whether the target address is a contract\r\n*/\r\nfunction isContract(address account) internal view returns (bool) {\r\n\tuint256 size;\r\n\t// XXX Currently there is no better way to check if there is a contract in an address\r\n\t// than to check the size of the code at that address.\r\n\t// See https://ethereum.stackexchange.com/a/14016/36603\r\n\t// for more details about how this works.\r\n\t// TODO Check this again before the Serenity release, because all addresses will be\r\n\t// contracts then.\r\n\t// solium-disable-next-line security/no-inline-assembly\r\n\tassembly { size := extcodesize(account) }\r\n\treturn size > 0;\r\n}\r\n\r\n}\r\n\r\n/**\r\n* @title ERC721 Non-Fungible Token Standard basic implementation\r\n* @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n*/\r\ncontract ERC721 is ERC165, IERC721 {\r\n\r\nusing SafeMath for uint256;\r\nusing Address for address;\r\n\r\n// Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n// which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n// Mapping from token ID to owner\r\nmapping (uint256 => address) private _tokenOwner;\r\n\r\n// Mapping from token ID to approved address\r\nmapping (uint256 => address) private _tokenApprovals;\r\n\r\n// Mapping from owner to number of owned token\r\nmapping (address => uint256) private _ownedTokensCount;\r\n\r\n// Mapping from owner to operator approvals\r\nmapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\nbytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\r\n/*\r\n* 0x80ac58cd ===\r\n*   bytes4(keccak256('balanceOf(address)')) ^\r\n*   bytes4(keccak256('ownerOf(uint256)')) ^\r\n*   bytes4(keccak256('approve(address,uint256)')) ^\r\n*   bytes4(keccak256('getApproved(uint256)')) ^\r\n*   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n*   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n*   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n*   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n*   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n*/\r\n\r\nfunction initialize() initializer public {\r\n\t// register the supported interfaces to conform to ERC721 via ERC165\r\n\t_registerInterface(_InterfaceId_ERC721);\r\n}\r\n\r\n/**\r\n* @dev Gets the balance of the specified address\r\n* @param owner address to query the balance of\r\n* @return uint256 representing the amount owned by the passed address\r\n*/\r\nfunction balanceOf(address owner) public view returns (uint256) {\r\n\trequire(owner != address(0));\r\n\treturn _ownedTokensCount[owner];\r\n}\r\n\r\n/**\r\n* @dev Gets the owner of the specified token ID\r\n* @param tokenId uint256 ID of the token to query the owner of\r\n* @return owner address currently marked as the owner of the given token ID\r\n*/\r\nfunction ownerOf(uint256 tokenId) public view returns (address) {\r\n\taddress owner = _tokenOwner[tokenId];\r\n\trequire(owner != address(0));\r\n\treturn owner;\r\n}\r\n\r\n/**\r\n* @dev Approves another address to transfer the given token ID\r\n* The zero address indicates there is no approved address.\r\n* There can only be one approved address per token at a given time.\r\n* Can only be called by the token owner or an approved operator.\r\n* @param to address to be approved for the given token ID\r\n* @param tokenId uint256 ID of the token to be approved\r\n*/\r\nfunction approve(address to, uint256 tokenId) public {\r\n\taddress owner = ownerOf(tokenId);\r\n\trequire(to != owner);\r\n\trequire(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n\t_tokenApprovals[tokenId] = to;\r\n\temit Approval(owner, to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev Gets the approved address for a token ID, or zero if no address set\r\n* Reverts if the token ID does not exist.\r\n* @param tokenId uint256 ID of the token to query the approval of\r\n* @return address currently approved for the given token ID\r\n*/\r\nfunction getApproved(uint256 tokenId) public view returns (address) {\r\n\trequire(_exists(tokenId));\r\n\treturn _tokenApprovals[tokenId];\r\n}\r\n\r\n/**\r\n* @dev Sets or unsets the approval of a given operator\r\n* An operator is allowed to transfer all tokens of the sender on their behalf\r\n* @param to operator address to set the approval\r\n* @param approved representing the status of the approval to be set\r\n*/\r\nfunction setApprovalForAll(address to, bool approved) public {\r\n\trequire(to != msg.sender);\r\n\t_operatorApprovals[msg.sender][to] = approved;\r\n\temit ApprovalForAll(msg.sender, to, approved);\r\n}\r\n\r\n/**\r\n* @dev Tells whether an operator is approved by a given owner\r\n* @param owner owner address which you want to query the approval of\r\n* @param operator operator address which you want to query the approval of\r\n* @return bool whether the given operator is approved by the given owner\r\n*/\r\nfunction isApprovedForAll(\r\n\taddress owner,\r\n\taddress operator\r\n)\r\n\tpublic\r\n\tview\r\n\treturns (bool)\r\n{\r\n\treturn _operatorApprovals[owner][operator];\r\n}\r\n\r\n/**\r\n* @dev Transfers the ownership of a given token ID to another address\r\n* Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n* Requires the msg sender to be the owner, approved, or operator\r\n* @param from current owner of the token\r\n* @param to address to receive the ownership of the given token ID\r\n* @param tokenId uint256 ID of the token to be transferred\r\n*/\r\nfunction transferFrom(\r\n\taddress from,\r\n\taddress to,\r\n\tuint256 tokenId\r\n)\r\n\tpublic\r\n{\r\n\trequire(_isApprovedOrOwner(msg.sender, tokenId));\r\n\trequire(to != address(0));\r\n\r\n\t_clearApproval(from, tokenId);\r\n\t_removeTokenFrom(from, tokenId);\r\n\t_addTokenTo(to, tokenId);\r\n\r\n\temit Transfer(from, to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev Safely transfers the ownership of a given token ID to another address\r\n* If the target address is a contract, it must implement `onERC721Received`,\r\n* which is called upon a safe transfer, and return the magic value\r\n* `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`;otherwise,\r\n* the transfer is reverted.\r\n*\r\n* Requires the msg sender to be the owner, approved, or operator\r\n* @param from current owner of the token\r\n* @param to address to receive the ownership of the given token ID\r\n* @param tokenId uint256 ID of the token to be transferred\r\n*/\r\nfunction safeTransferFrom(\r\n\taddress from,\r\n\taddress to,\r\n\tuint256 tokenId\r\n)\r\n\tpublic\r\n{\r\n\t// solium-disable-next-line arg-overflow\r\n\tsafeTransferFrom(from, to, tokenId, \"\");\r\n}\r\n\r\n/**\r\n* @dev Safely transfers the ownership of a given token ID to another address\r\n* If the target address is a contract, it must implement `onERC721Received`,\r\n* which is called upon a safe transfer, and return the magic value\r\n* `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`;otherwise,\r\n* the transfer is reverted.\r\n* Requires the msg sender to be the owner, approved, or operator\r\n* @param from current owner of the token\r\n* @param to address to receive the ownership of the given token ID\r\n* @param tokenId uint256 ID of the token to be transferred\r\n* @param _data bytes data to send along with a safe transfer check\r\n*/\r\nfunction safeTransferFrom(\r\n\taddress from,\r\n\taddress to,\r\n\tuint256 tokenId,\r\n\tbytes _data\r\n)\r\n\tpublic\r\n{\r\n\ttransferFrom(from, to, tokenId);\r\n\t// solium-disable-next-line arg-overflow\r\n\trequire(_checkAndCallSafeTransfer(from, to, tokenId, _data));\r\n}\r\n\r\n/**\r\n* @dev Returns whether the specified token exists\r\n* @param tokenId uint256 ID of the token to query the existence of\r\n* @return whether the token exists\r\n*/\r\nfunction _exists(uint256 tokenId) internal view returns (bool) {\r\n\taddress owner = _tokenOwner[tokenId];\r\n\treturn owner != address(0);\r\n}\r\n\r\n/**\r\n* @dev Returns whether the given spender can transfer a given token ID\r\n* @param spender address of the spender to query\r\n* @param tokenId uint256 ID of the token to be transferred\r\n* @return bool whether the msg.sender is approved for the given token ID,\r\n*  is an operator of the owner, or is the owner of the token\r\n*/\r\nfunction _isApprovedOrOwner(\r\n\taddress spender,\r\n\tuint256 tokenId\r\n)\r\n\tinternal\r\n\tview\r\n\treturns (bool)\r\n{\r\n\taddress owner = ownerOf(tokenId);\r\n\t// Disable solium check because of\r\n\t// https://github.com/duaraghav8/Solium/issues/175\r\n\t// solium-disable-next-line operator-whitespace\r\n\treturn (\r\n\tspender == owner ||\r\n\tgetApproved(tokenId) == spender ||\r\n\tisApprovedForAll(owner, spender)\r\n\t);\r\n}\r\n\r\n/**\r\n* @dev Internal function to mint a new token\r\n* Reverts if the given token ID already exists\r\n* @param to The address that will own the minted token\r\n* @param tokenId uint256 ID of the token to be minted by the msg.sender\r\n*/\r\nfunction _mint(address to, uint256 tokenId) internal {\r\n\trequire(to != address(0));\r\n\t_addTokenTo(to, tokenId);\r\n\temit Transfer(address(0), to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev Internal function to burn a specific token\r\n* Reverts if the token does not exist\r\n* @param tokenId uint256 ID of the token being burned by the msg.sender\r\n*/\r\nfunction _burn(address owner, uint256 tokenId) internal {\r\n\t_clearApproval(owner, tokenId);\r\n\t_removeTokenFrom(owner, tokenId);\r\n\temit Transfer(owner, address(0), tokenId);\r\n}\r\n\r\n/**\r\n* @dev Internal function to clear current approval of a given token ID\r\n* Reverts if the given address is not indeed the owner of the token\r\n* @param owner owner of the token\r\n* @param tokenId uint256 ID of the token to be transferred\r\n*/\r\nfunction _clearApproval(address owner, uint256 tokenId) internal {\r\n\trequire(ownerOf(tokenId) == owner);\r\n\tif (_tokenApprovals[tokenId] != address(0)) {\r\n\t_tokenApprovals[tokenId] = address(0);\r\n\t}\r\n}\r\n\r\n/**\r\n* @dev Internal function to add a token ID to the list of a given address\r\n* @param to address representing the new owner of the given token ID\r\n* @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n*/\r\nfunction _addTokenTo(address to, uint256 tokenId) internal {\r\n\trequire(_tokenOwner[tokenId] == address(0));\r\n\t_tokenOwner[tokenId] = to;\r\n\t_ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n}\r\n\r\n/**\r\n* @dev Internal function to remove a token ID from the list of a given address\r\n* @param from address representing the previous owner of the given token ID\r\n* @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n*/\r\nfunction _removeTokenFrom(address from, uint256 tokenId) internal {\r\n\trequire(ownerOf(tokenId) == from);\r\n\t_ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\r\n\t_tokenOwner[tokenId] = address(0);\r\n}\r\n\r\n/**\r\n* @dev Internal function to invoke `onERC721Received` on a target address\r\n* The call is not executed if the target address is not a contract\r\n* @param from address representing the previous owner of the given token ID\r\n* @param to target address that will receive the tokens\r\n* @param tokenId uint256 ID of the token to be transferred\r\n* @param _data bytes optional data to send along with the call\r\n* @return whether the call correctly returned the expected magic value\r\n*/\r\nfunction _checkAndCallSafeTransfer(\r\n\taddress from,\r\n\taddress to,\r\n\tuint256 tokenId,\r\n\tbytes _data\r\n)\r\n\tinternal\r\n\treturns (bool)\r\n{\r\n\tif (!to.isContract()) {\r\n\treturn true;\r\n\t}\r\n\tbytes4 retval = IERC721Receiver(to).onERC721Received(\r\n\tmsg.sender, from, tokenId, _data);\r\n\treturn (retval == _ERC721_RECEIVED);\r\n}\r\n}\r\n\r\n//import \"./ERC721Enumerable.sol\";\r\n\r\n// import \"./IERC721Enumerable.sol\";\r\n\r\n// import \"./IERC721.sol\";\r\n\r\n/**\r\n* @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n* @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n*/\r\ncontract IERC721Enumerable is IERC721 {\r\nfunction totalSupply() public view returns (uint256);\r\nfunction tokenOfOwnerByIndex(\r\n\taddress owner,\r\n\tuint256 index\r\n)\r\n\tpublic\r\n\tview\r\n\treturns (uint256 tokenId);\r\n\r\nfunction tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n// import \"./ERC721.sol\";\r\n// import \"../../introspection/ERC165.sol\";\r\n\r\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\r\n// Mapping from owner to list of owned token IDs\r\nmapping(address => uint256[]) private _ownedTokens;\r\n\r\n// Mapping from token ID to index of the owner tokens list\r\nmapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n// Array with all token ids, used for enumeration\r\nuint256[] private _allTokens;\r\n\r\n// Mapping from token id to position in the allTokens array\r\nmapping(uint256 => uint256) private _allTokensIndex;\r\n\r\nbytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n/**\r\n* 0x780e9d63 ===\r\n*   bytes4(keccak256('totalSupply()')) ^\r\n*   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n*   bytes4(keccak256('tokenByIndex(uint256)'))\r\n*/\r\n\r\n/**\r\n* @dev Constructor function\r\n*/\r\nfunction initialize() initializer public {\r\n\t// register the supported interface to conform to ERC721 via ERC165\r\n\t_registerInterface(_InterfaceId_ERC721Enumerable);\r\n}\r\n\r\n/**\r\n* @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n* @param owner address owning the tokens list to be accessed\r\n* @param index uint256 representing the index to be accessed of the requested tokens list\r\n* @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n*/\r\nfunction tokenOfOwnerByIndex(\r\n\taddress owner,\r\n\tuint256 index\r\n)\r\n\tpublic\r\n\tview\r\n\treturns (uint256)\r\n{\r\n\trequire(index < balanceOf(owner));\r\n\treturn _ownedTokens[owner][index];\r\n}\r\n\r\n/**\r\n* @dev Gets the total amount of tokens stored by the contract\r\n* @return uint256 representing the total amount of tokens\r\n*/\r\nfunction totalSupply() public view returns (uint256) {\r\n\treturn _allTokens.length;\r\n}\r\n\r\n/**\r\n* @dev Gets the token ID at a given index of all the tokens in this contract\r\n* Reverts if the index is greater or equal to the total number of tokens\r\n* @param index uint256 representing the index to be accessed of the tokens list\r\n* @return uint256 token ID at the given index of the tokens list\r\n*/\r\nfunction tokenByIndex(uint256 index) public view returns (uint256) {\r\n\trequire(index < totalSupply());\r\n\treturn _allTokens[index];\r\n}\r\n\r\n/**\r\n* @dev Internal function to add a token ID to the list of a given address\r\n* @param to address representing the new owner of the given token ID\r\n* @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n*/\r\nfunction _addTokenTo(address to, uint256 tokenId) internal {\r\n\tsuper._addTokenTo(to, tokenId);\r\n\tuint256 length = _ownedTokens[to].length;\r\n\t_ownedTokens[to].push(tokenId);\r\n\t_ownedTokensIndex[tokenId] = length;\r\n}\r\n\r\n/**\r\n* @dev Internal function to remove a token ID from the list of a given address\r\n* @param from address representing the previous owner of the given token ID\r\n* @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n*/\r\nfunction _removeTokenFrom(address from, uint256 tokenId) internal {\r\n\tsuper._removeTokenFrom(from, tokenId);\r\n\r\n\t// To prevent a gap in the array, we store the last token in the index of the token to delete, and\r\n\t// then delete the last slot.\r\n\tuint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\tuint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n\tuint256 lastToken = _ownedTokens[from][lastTokenIndex];\r\n\r\n\t_ownedTokens[from][tokenIndex] = lastToken;\r\n\t// This also deletes the contents at the last position of the array\r\n\t_ownedTokens[from].length--;\r\n\r\n\t// Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n\t// be zero. Then we can make sure that we will remove tokenId from the ownedTokens list since we are first swapping\r\n\t// the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n\t_ownedTokensIndex[tokenId] = 0;\r\n\t_ownedTokensIndex[lastToken] = tokenIndex;\r\n}\r\n\r\n/**\r\n* @dev Internal function to mint a new token\r\n* Reverts if the given token ID already exists\r\n* @param to address the beneficiary that will own the minted token\r\n* @param tokenId uint256 ID of the token to be minted by the msg.sender\r\n*/\r\nfunction _mint(address to, uint256 tokenId) internal {\r\n\tsuper._mint(to, tokenId);\r\n\r\n\t_allTokensIndex[tokenId] = _allTokens.length;\r\n\t_allTokens.push(tokenId);\r\n}\r\n\r\n/**\r\n* @dev Internal function to burn a specific token\r\n* Reverts if the token does not exist\r\n* @param owner owner of the token to burn\r\n* @param tokenId uint256 ID of the token being burned by the msg.sender\r\n*/\r\nfunction _burn(address owner, uint256 tokenId) internal {\r\n\tsuper._burn(owner, tokenId);\r\n\r\n\t// Reorg all tokens array\r\n\tuint256 tokenIndex = _allTokensIndex[tokenId];\r\n\tuint256 lastTokenIndex = _allTokens.length.sub(1);\r\n\tuint256 lastToken = _allTokens[lastTokenIndex];\r\n\r\n\t_allTokens[tokenIndex] = lastToken;\r\n\t_allTokens[lastTokenIndex] = 0;\r\n\r\n\t_allTokens.length--;\r\n\t_allTokensIndex[tokenId] = 0;\r\n\t_allTokensIndex[lastToken] = tokenIndex;\r\n}\r\n}\r\n\r\n// import \"./ERC721Metadata.sol\";\r\n\r\n// import \"./IERC721Metadata.sol\";\r\n\r\n// import \"./IERC721.sol\";\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n  address private _owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n\taddress indexed previousOwner,\r\n\taddress indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n\tfunction initialize(address addr) initializer public {\r\n\t\t// can not be same as deployer!\r\n\t\t_owner = addr;\r\n\t\t\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n\treturn _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier contract_onlyOwner() {\r\n\trequire(isOwner());\r\n\t_;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n\treturn msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public contract_onlyOwner {\r\n\temit OwnershipRenounced(_owner);\r\n\t_owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public contract_onlyOwner {\r\n\t_transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n\trequire(newOwner != address(0));\r\n\temit OwnershipTransferred(_owner, newOwner);\r\n\t_owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n* @title Helper to allow various addresses to mint Chibis\r\n* @dev Adds addresses to mapping that can be true/false queried\r\n*/\r\ncontract MintWallets is Ownable {\r\n\tmapping (address => bool) internal _mintWallets;\r\n\t\r\n\tfunction initialize(address addr) initializer public {\r\n\t\t_mintWallets[msg.sender] = true;\r\n\t\t_mintWallets[addr] = true;\r\n\t}\r\n\t\r\n\t/**\r\n\t* @dev Add a wallet/contract to the mint function functionality\r\n\t* @param _address The address/contract to allow minting \r\n\t*/\r\n\tfunction setMintAddress(address _address, bool _active) public contract_onlyOwner {\r\n\t\t_mintWallets[_address] = _active;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Check if wallet is true/false\r\n\t* @param _address The address/contract to check\r\n\t*/\r\n\tfunction checkMintAllowed(address _address) public view returns (bool) {\r\n\t\treturn _mintWallets[_address];\r\n\t}\r\n\t\r\n\t/**\r\n\t* @dev Throws if called by any account other than the owner.\r\n\t*/\r\n\tmodifier mintAllowed(address _address) {\r\n\t\trequire(_mintWallets[_address]);\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n* @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n*/\r\ncontract IERC721Metadata is IERC721 {\r\nfunction name() external view returns (string);\r\nfunction symbol() external view returns (string);\r\nfunction tokenURI(uint256 tokenId) public view returns (string);\r\n}\r\n// import \"../../introspection/ERC165.sol\";\r\n\r\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata, MintWallets {\r\n// Token name\r\nstring internal _name;\r\n\r\n// Token symbol\r\nstring internal _symbol;\r\n\r\nstring infoUrlPrefix;\r\n\r\n\r\nbytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n/**\r\n* 0x5b5e139f ===\r\n*   bytes4(keccak256('name()')) ^\r\n*   bytes4(keccak256('symbol()')) ^\r\n*   bytes4(keccak256('tokenURI(uint256)'))\r\n*/\r\n\r\n/**\r\n* @dev Constructor function\r\n*/\r\nfunction initialize(string name, string symbol) initializer public {\r\n\t_name = name;\r\n\t_symbol = symbol;\r\n\r\n\t// register the supported interfaces to conform to ERC721 via ERC165\r\n\t_registerInterface(InterfaceId_ERC721Metadata);\r\n}\r\n\r\n/**\r\n* @dev Gets the token name\r\n* @return string representing the token name\r\n*/\r\nfunction name() external view returns (string) {\r\n\treturn _name;\r\n}\r\n\r\n/**\r\n* @dev Gets the token symbol\r\n* @return string representing the token symbol\r\n*/\r\nfunction symbol() external view returns (string) {\r\n\treturn _symbol;\r\n}\r\n\r\n/**\r\n* @dev Returns an URI for a given token ID\r\n* Throws if the token ID does not exist. May return an empty string.\r\n* @param tokenId uint256 ID of the token to query\r\n*/\r\nfunction tokenURI(uint256 tokenId) public view returns (string) {\r\n\trequire(_exists(tokenId));\r\n\tstring memory uri = strConcat(infoUrlPrefix, uint2str(tokenId));\r\n\treturn uri;\r\n}\r\n\r\n\r\n/**\r\n* @dev Internal function to burn a specific token\r\n* Reverts if the token does not exist\r\n* @param owner owner of the token to burn\r\n* @param tokenId uint256 ID of the token being burned by the msg.sender\r\n*/\r\nfunction _burn(address owner, uint256 tokenId) internal {\r\n\tsuper._burn(owner, tokenId);\r\n}\r\n\r\n\t// set info url for weapons\r\n\tfunction setInfoUrl(string _url) public contract_onlyOwner returns(bool success) {\r\n\t\tinfoUrlPrefix = _url;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * \r\n\t * Helper stuff\r\n\t * \r\n\t **/\r\n\t \r\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\r\n\t\tbytes memory tempEmptyStringTest = bytes(source);\r\n\t\tif (tempEmptyStringTest.length == 0) {\r\n\t\t\treturn 0x0;\r\n\t\t}\r\n\t\r\n\t\tassembly {\r\n\t\t\tresult := mload(add(source, 32))\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction strConcat(string _a, string _b) internal pure returns (string) {\r\n\t\treturn strConcatDoIt(_a, _b, \"\", \"\", \"\");\r\n\t}\r\n\t\r\n\tfunction strConcatDoIt(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n\t\tbytes memory _ba = bytes(_a);\r\n\t\tbytes memory _bb = bytes(_b);\r\n\t\tbytes memory _bc = bytes(_c);\r\n\t\tbytes memory _bd = bytes(_d);\r\n\t\tbytes memory _be = bytes(_e);\r\n\t\tstring memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n\t\tbytes memory babcde = bytes(abcde);\r\n\t\tuint k = 0;\r\n\t\tfor (uint i = 0;i < _ba.length;i++) babcde[k++] = _ba[i];\r\n\t\tfor (i = 0;i < _bb.length;i++) babcde[k++] = _bb[i];\r\n\t\tfor (i = 0;i < _bc.length;i++) babcde[k++] = _bc[i];\r\n\t\tfor (i = 0;i < _bd.length;i++) babcde[k++] = _bd[i];\r\n\t\tfor (i = 0;i < _be.length;i++) babcde[k++] = _be[i];\r\n\t\treturn string(babcde);\r\n\t}\r\n\t\r\n\tfunction uint2str(uint i) internal pure returns (string){\r\n\t\tif (i == 0) return \"0\";\r\n\t\tuint j = i;\r\n\t\tuint len;\r\n\t\twhile (j != 0){\r\n\t\t\tlen++;\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\tbytes memory bstr = new bytes(len);\r\n\t\tuint k = len - 1;\r\n\t\twhile (i != 0){\r\n\t\t\tbstr[k--] = byte(48 + i % 10);\r\n\t\t\ti /= 10;\r\n\t\t}\r\n\t\treturn string(bstr);\r\n\t}\r\n\r\n\tfunction bytesToUint(bytes b) internal pure returns (uint256) {\r\n\t  require(b.length == 32);\r\n\r\n\t  bytes32 out;\r\n\r\n\t  for (uint i = 0;i < 32;i++) {\r\n\t\tout |= bytes32(b[i] & 0xFF) >> (i * 8);\r\n\t  }\r\n\r\n\t  return uint256(out);\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n/**\r\n* @title Full ERC721 Token\r\n* This implementation includes all the required and some optional functionality of the ERC721 standard\r\n* Moreover, it includes approve all functionality using operator terminology\r\n* @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n*/\r\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\r\n\t\r\n\tstring name;\r\n\tstring symbol;\r\n\t\t\r\n\tfunction initialize() initializer public {\r\n\t\tname = 'weapons';\r\n\t\tsymbol = 'CBW';\r\n\t\tERC721Metadata.initialize(name, symbol);\r\n\t}\r\n\r\n}\r\n\r\n\r\ninterface ERC20InterfaceClassic {\r\n\tfunction transfer(address to, uint tokens) external returns (bool success);\r\n}\r\n\r\ninterface ERC20Interface {\r\n\tfunction transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n\tfunction transfer(address to, uint tokens) external;\r\n\tfunction balanceOf(address _owner) external view returns (uint256 _balance);\r\n}\r\n\r\n\r\ncontract Referral is Ownable {\r\n\t\r\n\tuint refIdCounter;\r\n\tuint refCutPerc;\r\n\t\r\n\tmapping (address => uint) refId;\r\n\tmapping (uint => address) refIdAddress;\r\n\tmapping (uint => uint) refCut;\r\n\tmapping (uint => uint) refIdAvail;\r\n\r\n\tevent RefPaid(uint refId, address indexed refOwner, uint amount);\r\n\tevent RefCreated(uint refId, address indexed wallet);\r\n\t\r\n\tfunction initialize() initializer public {\r\n\t\trefIdCounter = 400;\r\n\t\trefCutPerc = 12;\r\n\t}\r\n\r\n\t// creates a new refid if address has none\r\n    function createRefId() public {\r\n        require(refId[msg.sender] == 0);\r\n        \r\n        refIdCounter++;\r\n        refId[msg.sender] = refIdCounter;\r\n        refIdAddress[refIdCounter] = msg.sender;\r\n        refCut[refIdCounter] = refCutPerc;\r\n\r\n\t\temit RefCreated(refIdCounter, msg.sender);\r\n    }\r\n    \r\n    function setRefCut(uint _refId, uint _cut) public contract_onlyOwner {\r\n        refCut[_refId] = _cut;\r\n    }\r\n    \r\n    // user can query his own ref data, not that of others\r\n    function queryRefId() public view returns(uint _refId, uint _refCut, address _address) {\r\n        uint _id = refId[msg.sender];\r\n        return (_id, refCut[_id], refIdAddress[_id]);\r\n    }\r\n\t\r\n}\r\n\r\n\r\ncontract WeaponGenesInterface {\r\n\tfunction generateData(uint _tokenId) public view returns (uint, uint);\r\n\tfunction generateRareMythicData(uint _tokenId) public view returns (uint);\r\n\tfunction generateLegendaryData(uint _tokenId) public view returns (uint);\r\n}\r\n\r\n\r\n// new and old chibi contract\r\ncontract ChibiInterface {\r\n\tfunction queryChibiDNA(uint) public pure returns (\r\n\t\tuint16[13]\r\n\t\t) {}\r\n\r\n\tfunction ownerOf(uint256) public pure returns (address) {}\r\n\t\r\n\t// legacy support old chibi contract\r\n\tfunction queryChibi(uint) public pure returns (\r\n\t\tstring,\r\n\t\tstring,\r\n\t\tuint16[13],\r\n\t\tuint256,\r\n\t\tuint256,\r\n\t\tuint,\r\n\t\tuint\r\n\t\t) {}\r\n\t\r\n}\r\n\r\n\r\n/**\r\n *  Weapons for Chibis\r\n *  \r\n */\r\ncontract Weapons is ERC721Full, Referral {\r\n\t\r\n\t// couple events\r\n\tevent WeaponClaimed(address indexed from, uint chibiId, uint weaponTokenId, uint weaponRarity, uint weaponType);\r\n\tevent WeaponSaleBought(address indexed from, address indexed to, uint weaponTokenId, uint weaponPricePlayer, uint weaponPrice);\r\n\tevent WeaponBought(address indexed from, uint weaponTokenId, uint weaponRarity, uint weaponType);\r\n\tevent WeaponMintedToAddr(address indexed from, uint weaponTokenId, uint weaponRarity, uint weaponType, string weaponCode);\r\n\tevent WeaponForSale(address indexed from, uint weaponTokenId, uint weaponPrice);\r\n\tevent WeaponSaleCancelled(address indexed from, uint weaponTokenId);\r\n\r\n\tuint uniqueCounter;\r\n\r\n\tChibiInterface chibiContract;\r\n\r\n\tWeaponGenesInterface genesContract;\r\n\r\n\t// default weapon price\r\n\tuint _weaponPrice;\r\n\tuint _rareWeaponPrice;\r\n\tuint _mythicWeaponPrice;\r\n\tuint _legendaryWeaponPrice;\r\n\t\r\n\t// sell weapon internally\r\n\tmapping(uint256 => uint256) private _weaponSalePrice;\r\n\t\r\n\t// mapping for Chibi to claim weapon\r\n\tmapping(uint256 => bool) private _weaponClaimed;\r\n\t\r\n\t// our comission\r\n\tuint comission;\r\n\t\r\n\t// for players putting weapons up, to avoid super low prices from botters\r\n\tuint minPrice;\r\n\t\r\n\tstruct WeaponsData {\r\n\t\tuint rarity;\r\n\t\tuint weaponType;\r\n\t}\r\n\t\r\n\tbool public gameState;\r\n\tbool public gameStateClaim;\r\n\t\r\n\tmapping(uint256 => WeaponsData) private weapons;\r\n\r\n\tuint presaleLockdown;\r\n\t\r\n\tfunction initialize() initializer public {\r\n\r\n\t\t// 2019-02-28 00:00:00\r\n\t\tpresaleLockdown = 1551312000;\r\n\r\n\t\tERC721Full.initialize();\r\n\t\tERC165.initialize();\r\n\t\tERC721.initialize();\r\n\t\tERC721Enumerable.initialize();\r\n\t\tOwnable.initialize(address(0x3e0f98ea1B916BB2373BAf21c2C8E6eE970e1126));\r\n\t\tMintWallets.initialize(address(0x3e0f98ea1B916BB2373BAf21c2C8E6eE970e1126));\r\n\t\tReferral.initialize();\r\n\t\t\r\n\t\t// min price people can put up weapons\r\n\t\tminPrice = 100;\r\n\t\t\r\n\t\t// prices based on droprates\r\n\t\t_weaponPrice = 20000000000000000; // 0.02 ETH ~3.50 USD (nov 18)\r\n\t\t_rareWeaponPrice = 88000000000000000; // 0.088 ETH\r\n\t\t_mythicWeaponPrice = 200000000000000000; // 0.2 ETH\r\n\t\t_legendaryWeaponPrice = 3000000000000000000; // 3 ETH\r\n\r\n\t\tuniqueCounter = 0;\r\n\t\tinfoUrlPrefix = \"https://chibifighters.io/weaponapi/\";\r\n\r\n\t\t// set comission percentage inv\r\n\t\tcomission = 90;\r\n\t\t\r\n\t\tgameState = true;\r\n\t\tgameStateClaim = true;\r\n\t\t\r\n\t}\r\n\r\n\r\n    // returns min price for weapon sale to avoid cheap sales\r\n    function queryMinPrice() public view returns (uint price) {\r\n        return minPrice;\r\n    }\r\n\r\n    \t\r\n\tfunction queryDefaultSalePrice(uint rarity) public view returns (uint price) {\r\n\t\tif (rarity == 0) {\r\n\t\t\treturn _weaponPrice;\r\n\t\t}else\r\n\t\tif (rarity == 1) {\r\n\t\t\treturn _rareWeaponPrice;\r\n\t\t}else\r\n\t\tif (rarity == 2) {\r\n\t\t\treturn _mythicWeaponPrice;\r\n\t\t}else\r\n\t\tif (rarity == 3) {\r\n\t\t\treturn _legendaryWeaponPrice;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t// returns min price for weapon sale to avoid cheap sales\r\n\tfunction setMinPrice(uint _minPrice) public contract_onlyOwner returns (uint price) {\r\n\t\tminPrice = _minPrice;\r\n\t\treturn minPrice;\r\n\t}\r\n\r\n\t// returns min price for weapon sale to avoid cheap sales\r\n\tfunction setGameState(bool _paused) public contract_onlyOwner returns (bool paused) {\r\n\t\tgameState = _paused;\r\n\t\treturn gameState;\r\n\t}\r\n\t\r\n\t// returns min price for weapon sale to avoid cheap sales\r\n\tfunction setGameStateClaim(bool _paused) public contract_onlyOwner returns (bool paused) {\r\n\t\tgameStateClaim = _paused;\r\n\t\treturn gameState;\r\n\t}\r\n\t\r\n\tfunction queryWeaponData(uint _tokenId) public view returns (uint tokenId, address owner, uint rarity, uint weaponType) {\r\n\t\treturn (\r\n\t\t\t_tokenId,\r\n\t\t\townerOf(_tokenId),\r\n\t\t\tweapons[_tokenId].rarity,\r\n\t\t\tweapons[_tokenId].weaponType\r\n\t\t\t);\r\n\t}\r\n\r\n\t\r\n\t// check if chibi already claimed weapon\r\n\tfunction queryChibiClaimed(uint chibiId) public view returns (bool success) {\r\n\t\treturn _weaponClaimed[chibiId];\r\n\t}\r\n\t\r\n\r\n\tfunction setCommission(uint percent) public contract_onlyOwner returns(bool success) {\r\n\t\tcomission = 100 - percent;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\tfunction getCommission() public view contract_onlyOwner returns(uint _comission) {\r\n\t\treturn 100 - comission;\r\n\t}\r\n\r\n\r\n\tfunction putWeaponForSale(uint tokenId, uint price) public notPaused returns (bool success) {\r\n\t\trequire (msg.sender == ownerOf(tokenId));\r\n\t\trequire (price >= minPrice);\r\n\r\n\t\t_weaponSalePrice[tokenId] = price;\r\n\t\tapprove(this, tokenId);\r\n\r\n\t\temit WeaponForSale(msg.sender, tokenId, price);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\tfunction cancelWeaponSale(uint tokenId) public returns (bool success) {\r\n\t\trequire (msg.sender == ownerOf(tokenId));\r\n\t\t_weaponSalePrice[tokenId] = 0;\r\n\t\t\r\n\t\t// remove approval from contract\r\n\t\t_clearApproval(msg.sender, tokenId);\r\n\r\n\t\temit WeaponSaleCancelled(msg.sender, tokenId);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\tfunction buySaleWeapon(uint tokenId) public payable notPaused returns (bool success) {\r\n\t\trequire(msg.sender != ownerOf(tokenId));\r\n\t\trequire(_weaponSalePrice[tokenId] > 0);\r\n\t\trequire(msg.value == _weaponSalePrice[tokenId]);\r\n\t\trequire(_isApprovedOrOwner(this, tokenId));\r\n\t\t\r\n\t\taddress _to = msg.sender;\r\n\t\trequire(_to != address(0));\r\n\t\t\r\n\t\t_weaponSalePrice[tokenId] = 0;\r\n\t\taddress _from = ownerOf(tokenId);\r\n\t\t\r\n\t\tuint finalPrice = msg.value / 100 * comission;\r\n\t\t\r\n\t\t// transfer weapon\r\n\t\t_removeTokenFrom(_from, tokenId);\r\n\t\t_addTokenTo(_to, tokenId);\r\n\t\t_clearApproval(msg.sender, tokenId);\r\n\t\r\n\t\temit Transfer(_from, _to, tokenId);\r\n\r\n\t\t// transfer ether\r\n\t\t_from.transfer(finalPrice);\r\n\t\t\t\r\n\t\temit WeaponSaleBought(_from, _to, tokenId, finalPrice, msg.value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\t// price for default weapons\r\n\tfunction setWeaponPrice(uint mode, uint _setWeaponPrice) public contract_onlyOwner returns(bool success, uint weaponPrice) {\r\n\t\tif (mode == 0) {\r\n\t\t\t_weaponPrice = _setWeaponPrice;\r\n\t\t}else\r\n\t\tif (mode == 1) {\r\n\t\t\t_rareWeaponPrice = _setWeaponPrice;\r\n\t\t}else\r\n\t\tif (mode == 2) {\r\n\t\t\t_mythicWeaponPrice = _setWeaponPrice;\r\n\t\t}else\r\n\t\tif (mode == 3) {\r\n\t\t\t_legendaryWeaponPrice = _setWeaponPrice;\r\n\t\t}\r\n\t\t\r\n\t\treturn (true, _setWeaponPrice);\r\n\t}\r\n\t\r\n\r\n\t// set chibi contract\r\n\tfunction setChibiAddress(address _address) public contract_onlyOwner returns (bool success) {\r\n\t\tchibiContract = ChibiInterface(_address);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t// set genes contract\r\n\tfunction setGenesAddress(address _address) public contract_onlyOwner returns (bool success) {\r\n\t\tgenesContract = WeaponGenesInterface(_address);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t// get dna to claim weapons (only way to get founder weapons)\r\n\tfunction getChibiWeaponDna(uint _chibiId) internal view returns (uint weapon, uint rarity) {\r\n\t\tuint16[13] memory _dna = chibiContract.queryChibiDNA(_chibiId);\r\n\t\t\r\n\t\treturn (_dna[7], _dna[8]);\r\n\t}\r\n\t\r\n\r\n\t// buy a random weapon, can be anything from common to legendary\r\n\tfunction buyWeapon(uint amount, uint _refId) public payable notPaused {\r\n\t\trequire(_weaponPrice.mul(amount) == msg.value);\r\n\t\t// founder weapons can not be bought, and nothing that doesn't exist yet\r\n\r\n\t\tfor (uint i=0;i<amount;i++) {\r\n\t\t\tuniqueCounter++;\r\n\t\t\trequire(!_exists(uniqueCounter));\r\n\t\t\t\r\n\t\t\t// mint also triggers transfer event\r\n\t\t\t_mint(address(msg.sender), uniqueCounter);\r\n\t\t\t\r\n\t\t\t(uint _weaponRarity, uint _weaponType) = genesContract.generateData(uniqueCounter);\r\n\t\t\tweapons[uniqueCounter].rarity = _weaponRarity;\r\n\t\t\tweapons[uniqueCounter].weaponType = _weaponType;\r\n\t\t\t\r\n\t\t\temit WeaponBought(msg.sender, uniqueCounter, _weaponRarity, _weaponType);\r\n\t\t}\r\n\t\t\r\n\t\tif (refIdAddress[_refId] != address(0) && msg.sender != refIdAddress[_refId]) {\r\n\t\t    uint amountRef = msg.value.mul(refCut[_refId]).div(100);\r\n\t\t    refIdAddress[_refId].transfer(amountRef);\r\n\t\t    emit RefPaid(_refId, refIdAddress[_refId], amountRef);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t// buy a guaranteed rare weapon\r\n\tfunction buyWeaponRare(uint amount, uint _refId) public payable notPaused {\r\n\t\trequire(_rareWeaponPrice.mul(amount) == msg.value);\r\n\t\trequire(now < presaleLockdown);\r\n\r\n\t\tfor (uint i=0;i<amount;i++) {\r\n\t\t\tuniqueCounter++;\r\n\t\t\trequire(!_exists(uniqueCounter));\r\n\t\t\t\r\n\t\t\t// mint also triggers transfer event\r\n\t\t\t_mint(address(msg.sender), uniqueCounter);\r\n\t\t\t\r\n\t\t\tuint _weaponType = genesContract.generateRareMythicData(uniqueCounter);\r\n\t\t\tweapons[uniqueCounter].rarity = 1;\r\n\t\t\tweapons[uniqueCounter].weaponType = _weaponType;\r\n\r\n\t\t\temit WeaponBought(msg.sender, uniqueCounter, 1, _weaponType);\r\n\t\t}\r\n\t\t\r\n\t\tif (refIdAddress[_refId] != address(0) && msg.sender != refIdAddress[_refId]) {\r\n\t\t    uint amountRef = msg.value.mul(refCut[_refId]).div(100);\r\n\t\t    refIdAddress[_refId].transfer(amountRef);\r\n\t\t    emit RefPaid(_refId, refIdAddress[_refId], amountRef);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t// buy a guaranteed mythic weapon\r\n\tfunction buyWeaponMythic(uint amount, uint _refId) public payable notPaused {\r\n\t\trequire(_mythicWeaponPrice.mul(amount) == msg.value);\r\n\t\trequire(now < presaleLockdown);\r\n\r\n\t\tfor (uint i=0;i<amount;i++) {\r\n\t\t\tuniqueCounter++;\r\n\t\t\trequire(!_exists(uniqueCounter));\r\n\t\t\t\r\n\t\t\t// mint also triggers transfer event\r\n\t\t\t_mint(address(msg.sender), uniqueCounter);\r\n\t\t\t\r\n\t\t\tuint _weaponType = genesContract.generateRareMythicData(uniqueCounter);\r\n\t\t\tweapons[uniqueCounter].rarity = 2;\r\n\t\t\tweapons[uniqueCounter].weaponType = _weaponType;\r\n\r\n\t\t\temit WeaponBought(msg.sender, uniqueCounter, 2, _weaponType);\r\n\t\t}\r\n\t\t\r\n\t\tif (refIdAddress[_refId] != address(0) && msg.sender != refIdAddress[_refId]) {\r\n\t\t    uint amountRef = msg.value.mul(refCut[_refId]).div(100);\r\n\t\t    refIdAddress[_refId].transfer(amountRef);\r\n\t\t    emit RefPaid(_refId, refIdAddress[_refId], amountRef);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t// buy a guaranteed legendary weapon\r\n\tfunction buyWeaponLegendary(uint amount, uint _refId) public payable notPaused {\r\n\t\trequire(_legendaryWeaponPrice.mul(amount) == msg.value);\r\n\t\trequire(now < presaleLockdown);\r\n\r\n\t\tfor (uint i=0;i<amount;i++) {\r\n\t\t\tuniqueCounter++;\r\n\t\t\trequire(!_exists(uniqueCounter));\r\n\t\t\t\r\n\t\t\t// mint also triggers transfer event\r\n\t\t\t_mint(address(msg.sender), uniqueCounter);\r\n\t\t\t\r\n\t\t\tuint _weaponType = genesContract.generateLegendaryData(uniqueCounter);\r\n\t\t\tweapons[uniqueCounter].rarity = 3;\r\n\t\t\tweapons[uniqueCounter].weaponType = _weaponType;\r\n\r\n\t\t\temit WeaponBought(msg.sender, uniqueCounter, 3, _weaponType);\r\n\t\t}\r\n\t\t\r\n\t\tif (refIdAddress[_refId] != address(0) && msg.sender != refIdAddress[_refId]) {\r\n\t\t    uint amountRef = msg.value.mul(refCut[_refId]).div(100);\r\n\t\t    refIdAddress[_refId].transfer(amountRef);\r\n\t\t    emit RefPaid(_refId, refIdAddress[_refId], amountRef);\r\n\t\t}\r\n\t}\r\n\r\n\t// mint weapon as result of voucher purchase or what not\r\n\t// code is used to identify weapon and apply required stats\r\n\tfunction mintWeaponToAddr(uint _weaponRarity, uint _weaponType, address _receiver, string _code) public mintAllowed(msg.sender) {\r\n\r\n        if (_weaponType < 10 || (_weaponType>=8000 && _weaponType<=8013)) revert();\r\n        \r\n\t\tuniqueCounter++;\r\n\t\trequire(!_exists(uniqueCounter));\r\n\r\n\t\t// mint also triggers transfer event\r\n\t\t_mint(address(_receiver), uniqueCounter);\r\n\t\t\r\n\t\tweapons[uniqueCounter].rarity = _weaponRarity;\r\n\t\tweapons[uniqueCounter].weaponType = _weaponType;\r\n\t\t\r\n\t\temit WeaponMintedToAddr(_receiver, uniqueCounter, _weaponRarity, _weaponType, _code);\r\n\r\n\t}\r\n\t\r\n\t\r\n\t// Chibis can claim their initial weapon\r\n\t// that is also the only way to get a founder weapon\r\n\t//\r\n\tfunction claimWeapon(uint _chibiId) public claimNotPaused {\r\n\t\trequire(chibiContract.ownerOf(_chibiId) == msg.sender);\r\n\t\trequire(_weaponClaimed[_chibiId] == false);\r\n\t\t\r\n\t\tuniqueCounter++;\r\n\t\t\r\n\t\t// mark claimed\r\n\t\t_weaponClaimed[_chibiId] = true;\r\n\t\t\r\n\t\t// get weapon dna of chibi\r\n\t\t(uint _weaponType, uint _chibiRarity) = getChibiWeaponDna(_chibiId);\r\n\t\t\r\n\t\t_mint(address(msg.sender), uniqueCounter);\r\n\t\t\r\n\t\tweapons[uniqueCounter].weaponType = _weaponType;\r\n\r\n\t\tif (_weaponType < 10 || _weaponType > 7999) {\r\n\t\t\tweapons[uniqueCounter].rarity = 3;\r\n\t\t} else {\r\n\t\t\t// rarity comes from chibi when claimed, however legendary chibis still get just a mythic weapon since legendary weapons are either bought or made with a fragment\r\n\t\t\tif (_chibiRarity == 3) weapons[uniqueCounter].rarity = 2;\r\n\t\t\t\telse weapons[uniqueCounter].rarity = _chibiRarity;\r\n\t\t}\r\n\r\n\t\temit WeaponClaimed(msg.sender, _chibiId, uniqueCounter, weapons[uniqueCounter].rarity, weapons[uniqueCounter].weaponType);\r\n\t\t\r\n\t}\r\n\t\r\n\t// old chibi contract\r\n\tfunction claimWeaponOld(uint _chibiId) public notPaused {\r\n\t\trequire(chibiContract.ownerOf(_chibiId) == msg.sender);\r\n\t\trequire(_weaponClaimed[_chibiId] == false);\r\n\t\t\r\n\t\tuniqueCounter++;\r\n\t\t\r\n\t\t// mark claimed\r\n\t\t_weaponClaimed[_chibiId] = true;\r\n\t\t\r\n\t\t// get weapon dna of chibi\r\n\t\tuint16[13] memory _dna;\r\n\t\t(\r\n\t\t,\r\n\t\t,\r\n\t\t_dna,\r\n\t\t,\r\n\t\t,\r\n\t\t,\r\n\t\t\r\n\t\t) = chibiContract.queryChibi(_chibiId);\r\n\t\t\r\n\t\tuint _weaponType = _dna[7];\r\n\t\tuint _chibiRarity = _dna[8];\r\n\r\n\t\t_mint(address(msg.sender), uniqueCounter);\r\n\t\t\r\n\t\tweapons[uniqueCounter].weaponType = _weaponType;\r\n\r\n\t\tif (_weaponType < 10 || _weaponType > 7999) {\r\n\t\t\tweapons[uniqueCounter].rarity = 3;\r\n\t\t}else {\r\n\t\t\t// rarity comes from chibi when claimed, however legendary chibis still get just a mythic weapon since legendary weapons are either bought or made with a fragment\r\n\t\t\tif (_chibiRarity == 3) weapons[uniqueCounter].rarity = 2;\r\n\t\t\t\telse weapons[uniqueCounter].rarity = _chibiRarity;\r\n\t\t}\r\n\r\n\t\temit WeaponClaimed(msg.sender, _chibiId, uniqueCounter, weapons[uniqueCounter].rarity, weapons[uniqueCounter].weaponType);\r\n\t\t\r\n\t}\r\n\r\n\r\n\tfunction queryForSale(uint _tokenId) public view returns (uint price, address owner) {\r\n\t\trequire(_isApprovedOrOwner(this, _tokenId));\r\n\t\t\r\n\t\treturn (\r\n\t\t\t_weaponSalePrice[_tokenId],\r\n\t\t\townerOf(_tokenId)\r\n\t\t);\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t* @dev Send Ether to owner\r\n\t* @param _address Receiving address\r\n\t* @param _amountWei Amount in WEI to send\r\n\t**/\r\n\tfunction weiToOwner(address _address, uint _amountWei) public contract_onlyOwner returns (bool success) {\r\n\t\trequire(_amountWei <= address(this).balance);\r\n\t\t_address.transfer(_amountWei);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction ERC20ToOwner(address _to, uint256 _amount, ERC20Interface _tokenContract) public contract_onlyOwner {\r\n\t\t_tokenContract.transfer(_to, _amount);\r\n\t}\r\n\r\n\tfunction ERC20ClassicToOwner(address _to, uint256 _amount, ERC20InterfaceClassic _tokenContract) public contract_onlyOwner {\r\n\t\t_tokenContract.transfer(_to, _amount);\r\n\t}\r\n\t\r\n\tfunction queryERC20(ERC20Interface _tokenContract) public view contract_onlyOwner returns (uint) {\r\n\t\treturn _tokenContract.balanceOf(this);\r\n\t}\r\n\r\n\r\n\tmodifier notPaused() {\r\n\t\trequire(gameState == false);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier claimNotPaused() {\r\n\t\trequire(gameStateClaim == false);\r\n\t\t_;\r\n\t}\r\n\t\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amountWei\",\"type\":\"uint256\"}],\"name\":\"weiToOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"chibiId\",\"type\":\"uint256\"}],\"name\":\"queryChibiClaimed\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_weaponRarity\",\"type\":\"uint256\"},{\"name\":\"_weaponType\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_code\",\"type\":\"string\"}],\"name\":\"mintWeaponToAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"buySaleWeapon\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_refId\",\"type\":\"uint256\"}],\"name\":\"buyWeapon\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkMintAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"ERC20ClassicToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mode\",\"type\":\"uint256\"},{\"name\":\"_setWeaponPrice\",\"type\":\"uint256\"}],\"name\":\"setWeaponPrice\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"weaponPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_chibiId\",\"type\":\"uint256\"}],\"name\":\"claimWeapon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refId\",\"type\":\"uint256\"},{\"name\":\"_cut\",\"type\":\"uint256\"}],\"name\":\"setRefCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setCommission\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setGameState\",\"outputs\":[{\"name\":\"paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rarity\",\"type\":\"uint256\"}],\"name\":\"queryDefaultSalePrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"queryForSale\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"setMinPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setChibiAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"queryWeaponData\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"rarity\",\"type\":\"uint256\"},{\"name\":\"weaponType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createRefId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"queryERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setInfoUrl\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_refId\",\"type\":\"uint256\"}],\"name\":\"buyWeaponLegendary\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelWeaponSale\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameStateClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"putWeaponForSale\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGenesAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_refId\",\"type\":\"uint256\"}],\"name\":\"buyWeaponRare\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setGameStateClaim\",\"outputs\":[{\"name\":\"paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setMintAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryMinPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"ERC20ToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_refId\",\"type\":\"uint256\"}],\"name\":\"buyWeaponMythic\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCommission\",\"outputs\":[{\"name\":\"_comission\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_chibiId\",\"type\":\"uint256\"}],\"name\":\"claimWeaponOld\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryRefId\",\"outputs\":[{\"name\":\"_refId\",\"type\":\"uint256\"},{\"name\":\"_refCut\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"chibiId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponRarity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponType\",\"type\":\"uint256\"}],\"name\":\"WeaponClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weaponTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponPricePlayer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponPrice\",\"type\":\"uint256\"}],\"name\":\"WeaponSaleBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weaponTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponRarity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponType\",\"type\":\"uint256\"}],\"name\":\"WeaponBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weaponTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponRarity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponCode\",\"type\":\"string\"}],\"name\":\"WeaponMintedToAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weaponTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weaponPrice\",\"type\":\"uint256\"}],\"name\":\"WeaponForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weaponTokenId\",\"type\":\"uint256\"}],\"name\":\"WeaponSaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"refId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"refOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"refId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"RefCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"Weapons","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dfe4278897ea447884157fce294604df8548bb04e27ef5170ddc801e2a6dae66"}]}