{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ninterface IOwnable {\r\n    /**\r\n    * @dev Returns owner\r\n    */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    */\r\n    function renounceOwnership() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\ninterface ISecurityToken {\r\n\r\n    // Standard ERC20 interface\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    //transfer, transferFrom must respect the result of verifyTransfer\r\n    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is the amount of tokens that will be minted to the investor\r\n     */\r\n    function mint(address _investor, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is The amount of tokens that will be minted to the investor\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken on behalf of someone else\r\n     * @param _from Address for whom to burn tokens\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnFromWithData(address _from, uint256 _value, bytes _data) external;\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnWithData(uint256 _value, bytes _data) external;\r\n\r\n    event Minted(address indexed _to, uint256 _value);\r\n    event Burnt(address indexed _burner, uint256 _value);\r\n\r\n    // Permissions this to a Permission module, which has a key of 1\r\n    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\r\n    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8[] Module type\r\n\r\n     */\r\n    function getModule(address _module) external view returns(bytes32, address, address, bool, uint8[]);\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets length of investors array\r\n     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors\r\n     * @return Length\r\n     */\r\n    function getInvestors() external view returns (address[]);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]);\r\n    \r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Gets an investor at a particular index\r\n    * @param _index Index to return address from\r\n    * @return Investor address\r\n    */\r\n    function investors(uint256 _index) external view returns (address);\r\n\r\n   /**\r\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n    * @param _tokenContract Address of the ERC20Basic compliance token\r\n    * @param _value Amount of POLY to withdraw\r\n    */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to approve more POLY to one of the modules\r\n    * @param _module Module address\r\n    * @param _budget New budget\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _budget) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n    * @notice Removes addresses with zero balances from the investors list\r\n    * @param _start Index in investors list at which to start removing zero balances\r\n    * @param _iters Max number of iterations of the for loop\r\n    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\r\n    */\r\n    function pruneInvestors(uint256 _start, uint256 _iters) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Ends token minting period permanently\r\n     */\r\n    function freezeMinting() external;\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target investors.\r\n     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)\r\n     * @param _investors A list of addresses to whom the minted tokens will be delivered\r\n     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list\r\n     * @return Success\r\n     */\r\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     */\r\n    function addModule(\r\n        address _moduleFactory,\r\n        bytes _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget\r\n    ) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n    function getCheckpointTimes() external view returns(uint256[]);\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a forced transfer\r\n     * @param _from address from which to take tokens\r\n     * @param _to address where to send tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a foced burn\r\n     * @param _from address from which to take tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n     function disableController() external;\r\n\r\n     /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n     function getVersion() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Gets the investor count\r\n     */\r\n     function getInvestorCount() external view returns(uint256);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);\r\n\r\n     /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n     function granularity() external view returns(uint256);\r\n}\r\n\r\ncontract TokenInfo {\r\n    \r\n    struct Module {\r\n        bytes32 name;\r\n        address module;\r\n        address moduleFactory;\r\n        bool isArchived;\r\n        uint8[] moduleTypes;\r\n    }\r\n\r\n    struct Checkpoint {\r\n        uint256 checkpointId;\r\n        address[] investors;\r\n        uint256[] balances;\r\n        uint256 totalSupply;\r\n        uint256 time;\r\n    }\r\n    \r\n    struct Token {\r\n        address token;\r\n        address owner;\r\n        address[] investors;\r\n        uint256[] balances;\r\n        uint256 numInvestors;\r\n        uint256 totalSupply;\r\n        Module[] modules;\r\n        Checkpoint[] checkpoints;\r\n    }\r\n    \r\n    function getTokens(address[] _tokens) public view returns (Token[] memory tokens) {\r\n        tokens = new Token[](_tokens.length);\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            tokens[i] = getToken(_tokens[i]);\r\n        }\r\n    }\r\n    \r\n    function getToken(address _token) public view returns (Token memory t) {\r\n        \r\n        // Token memory t;\r\n        t.token = _token;\r\n        t.owner = IOwnable(_token).owner();\r\n        ISecurityToken st = ISecurityToken(_token);\r\n        t.investors = st.getInvestors();\r\n        t.totalSupply = st.totalSupply();\r\n        t.numInvestors = st.getInvestorCount();\r\n        t.balances = new uint256[](t.investors.length);\r\n        uint256 ii;\r\n        for (ii = 0; ii < t.investors.length; ii++) {\r\n            t.balances[ii] = st.balanceOf(t.investors[ii]);\r\n        }\r\n\r\n        //Get Modules\r\n        address[] memory modules;\r\n        uint256 counter = 0;\r\n        uint8 i;\r\n        uint256 j;\r\n        for (i = 1; i < 6; i++) {\r\n            modules = st.getModulesByType(i);\r\n            for (j = 0; j < modules.length; j++) {\r\n                counter = counter + modules.length;\r\n            }\r\n        }\r\n        t.modules = new Module[](counter);\r\n        counter = 0;\r\n        for (i = 1; i < 6; i++) {\r\n            modules = st.getModulesByType(i);\r\n            for (j = 0; j < modules.length; j++) {\r\n                t.modules[counter] = (getModule(_token, modules[j]));\r\n                counter++;\r\n            }\r\n        }\r\n        \r\n        //Get Checkpoints\r\n        t.checkpoints = new Checkpoint[](st.currentCheckpointId());\r\n        for (i = 0; i < st.currentCheckpointId(); i++) {\r\n            t.checkpoints[i] = getCheckpoint(_token, i);\r\n        }\r\n        return t;\r\n    }\r\n    \r\n    function getCheckpoint(address _token, uint256 _checkpointId) public view returns (Checkpoint memory) {\r\n        ISecurityToken st = ISecurityToken(_token);\r\n        uint256[] memory times = st.getCheckpointTimes();\r\n        Checkpoint memory c;\r\n        c.checkpointId = _checkpointId;\r\n        c.investors = st.getInvestorsAt(_checkpointId);\r\n        c.balances = new uint256[](c.investors.length);\r\n        for (uint256 i = 0; i < c.investors.length; i++) {\r\n            c.balances[i] = st.balanceOfAt(c.investors[i], _checkpointId);\r\n        }\r\n        c.totalSupply = st.totalSupplyAt(_checkpointId);\r\n        c.time = times[_checkpointId];\r\n        return c;\r\n    }\r\n    \r\n    function getModule(address _token, address _module) public view returns (Module memory) {\r\n        ISecurityToken st = ISecurityToken(_token);\r\n        (bytes32 name, address module, address moduleFactory, bool isArchived , uint8[] memory moduleTypes) = st.getModule(_module);\r\n        Module memory m;\r\n        m.name = name;\r\n        m.module = module;\r\n        m.moduleFactory = moduleFactory;\r\n        m.isArchived = isArchived;\r\n        m.moduleTypes = moduleTypes;\r\n        return m;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"numInvestors\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"module\",\"type\":\"address\"},{\"name\":\"moduleFactory\",\"type\":\"address\"},{\"name\":\"isArchived\",\"type\":\"bool\"},{\"name\":\"moduleTypes\",\"type\":\"uint8[]\"}],\"name\":\"modules\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"checkpointId\",\"type\":\"uint256\"},{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"checkpoints\",\"type\":\"tuple[]\"}],\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_checkpointId\",\"type\":\"uint256\"}],\"name\":\"getCheckpoint\",\"outputs\":[{\"components\":[{\"name\":\"checkpointId\",\"type\":\"uint256\"},{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getToken\",\"outputs\":[{\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"numInvestors\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"module\",\"type\":\"address\"},{\"name\":\"moduleFactory\",\"type\":\"address\"},{\"name\":\"isArchived\",\"type\":\"bool\"},{\"name\":\"moduleTypes\",\"type\":\"uint8[]\"}],\"name\":\"modules\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"checkpointId\",\"type\":\"uint256\"},{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"checkpoints\",\"type\":\"tuple[]\"}],\"name\":\"t\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"getModule\",\"outputs\":[{\"components\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"module\",\"type\":\"address\"},{\"name\":\"moduleFactory\",\"type\":\"address\"},{\"name\":\"isArchived\",\"type\":\"bool\"},{\"name\":\"moduleTypes\",\"type\":\"uint8[]\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenInfo","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://491d720bc2dd22f7824bb98da60b2b8202d60cbcf6fca69cd14ee57eaa6b6dc8"}]}