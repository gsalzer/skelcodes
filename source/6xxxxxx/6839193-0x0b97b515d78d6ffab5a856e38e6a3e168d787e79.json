{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter;\r\n\r\n  constructor() internal {\r\n    // The counter starts at one to prevent changing it from zero to a non-zero\r\n    // value, which is a more expensive operation.\r\n    _guardCounter = 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/math/Safemath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: lib/CanReclaimToken.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20 compatible tokens\r\n   * @param token ERC20 The address of the token contract\r\n   */\r\n  function reclaimToken(IERC20 token) external onlyOwner {\r\n    if (address(token) == address(0)) {\r\n      owner().transfer(address(this).balance);\r\n      return;\r\n    }\r\n    uint256 balance = token.balanceOf(this);\r\n    token.transfer(owner(), balance);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(!has(role, account));\r\n\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(has(role, account));\r\n\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: lib/ServiceRole.sol\r\n\r\ncontract ServiceRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event ServiceAdded(address indexed account);\r\n  event ServiceRemoved(address indexed account);\r\n\r\n  Roles.Role private services;\r\n\r\n  constructor() internal {\r\n    _addService(msg.sender);\r\n  }\r\n\r\n  modifier onlyService() {\r\n    require(isService(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isService(address account) public view returns (bool) {\r\n    return services.has(account);\r\n  }\r\n\r\n  function renounceService() public {\r\n    _removeService(msg.sender);\r\n  }\r\n\r\n  function _addService(address account) internal {\r\n    services.add(account);\r\n    emit ServiceAdded(account);\r\n  }\r\n\r\n  function _removeService(address account) internal {\r\n    services.remove(account);\r\n    emit ServiceRemoved(account);\r\n  }\r\n}\r\n\r\n// File: contracts/SaleFix.sol\r\n\r\ninterface HEROES {\r\n  function mint(address to, uint256 genes, uint256 level)  external returns (uint);\r\n}\r\n\r\n//Crypto Hero Rocket coin\r\ninterface CHR {\r\n  function mint(address _to, uint256 _amount) external returns (bool);\r\n}\r\n\r\ncontract SaleFix is Ownable, ServiceRole, ReentrancyGuard, CanReclaimToken {\r\n  using SafeMath for uint256;\r\n\r\n  event ItemUpdate(uint256 indexed itemId, uint256 genes, uint256 level, uint256 price, uint256 count);\r\n  event Sold(address indexed to, uint256 indexed tokenId, uint256 indexed itemId, uint256 genes, uint256 level, uint256 price);\r\n  event CoinReward(uint256 code, uint256 coins);\r\n  event EthReward(uint256 code, uint256 eth);\r\n  event CoinRewardGet(uint256 code, uint256 coins);\r\n  event EthRewardGet(uint256 code, uint256 eth);\r\n  event Income(address source, uint256 amount);\r\n\r\n  HEROES public heroes;\r\n  CHR public coin;\r\n\r\n  //MARKET\r\n  struct Item {\r\n    bool exists;\r\n    uint256 index;\r\n    uint256 genes;\r\n    uint256 level;\r\n    uint256 price;\r\n    uint256 count;\r\n  }\r\n\r\n  // item id => Item\r\n  mapping(uint256 => Item) items;\r\n  // market index => item id\r\n  mapping(uint256 => uint) public market;\r\n  uint256 public marketSize;\r\n\r\n  uint256 public lastItemId;\r\n\r\n\r\n  //REFERRALS\r\n  struct Affiliate {\r\n    uint256 affCode;\r\n    uint256 coinsToMint;\r\n    uint256 ethToSend;\r\n    uint256 coinsMinted;\r\n    uint256 ethSent;\r\n    bool active;\r\n  }\r\n\r\n  struct AffiliateReward {\r\n    uint256 coins;\r\n    //1% - 100, 10% - 1000 50% - 5000\r\n    uint256 percent;\r\n  }\r\n\r\n  //personal reward struct\r\n  struct StaffReward {\r\n    //1% - 100, 10% - 1000 50% - 5000\r\n    uint256 coins;\r\n    uint256 percent;\r\n    uint256 index;\r\n    bool exists;\r\n  }\r\n\r\n  //personal reward mapping\r\n  //staff affCode => StaffReward\r\n  mapping (uint256 => StaffReward) public staffReward;\r\n  //staff index => staff affCode\r\n  mapping (uint256 => uint) public staffList;\r\n  uint256 public staffCount;\r\n\r\n  //refCode => Affiliate\r\n  mapping(uint256 => Affiliate) public affiliates;\r\n  mapping(uint256 => bool) public vipAffiliates;\r\n  AffiliateReward[] public affLevelReward;\r\n  AffiliateReward[] public vipAffLevelReward;\r\n\r\n  //total reserved eth amount for affiliates\r\n  uint256 public totalReserved;\r\n\r\n  constructor(HEROES _heroes, CHR _coin) public {\r\n    require(address(_heroes) != address(0));\r\n    require(address(_coin) != address(0));\r\n    heroes = _heroes;\r\n    coin = _coin;\r\n\r\n    affLevelReward.push(AffiliateReward({coins : 2, percent : 0})); // level 0 - player self, 2CHR\r\n    affLevelReward.push(AffiliateReward({coins : 1, percent : 1000})); // level 1, 1CHR, 10%\r\n    affLevelReward.push(AffiliateReward({coins : 0, percent : 500})); // level 2, 0CHR, 5%\r\n  \r\n    vipAffLevelReward.push(AffiliateReward({coins : 2, percent : 0})); // level 0 - player self, 2CHR\r\n    vipAffLevelReward.push(AffiliateReward({coins : 1, percent : 2000})); // level 1, 1CHR, 20%\r\n    vipAffLevelReward.push(AffiliateReward({coins : 0, percent : 1000})); // level 2, 0CHR, 10%\r\n  }\r\n\r\n  /// @notice The fallback function payable\r\n  function() external payable {\r\n    require(msg.value > 0);\r\n    _flushBalance();\r\n  }\r\n\r\n  function _flushBalance() private {\r\n    uint256 balance = address(this).balance.sub(totalReserved);\r\n    if (balance > 0) {\r\n      address(heroes).transfer(balance);\r\n      emit Income(address(this), balance);\r\n    }\r\n  }\r\n\r\n  function addService(address account) public onlyOwner {\r\n    _addService(account);\r\n  }\r\n\r\n  function removeService(address account) public onlyOwner {\r\n    _removeService(account);\r\n  }\r\n\r\n//  function setCoin(CHR _coin) external onlyOwner {\r\n//    require(address(_coin) != address(0));\r\n//    coin = _coin;\r\n//  }\r\n\r\n\r\n  function setAffiliateLevel(uint256 _level, uint256 _rewardCoins, uint256 _rewardPercent) external onlyOwner {\r\n    require(_level < affLevelReward.length);\r\n    AffiliateReward storage rew = affLevelReward[_level];\r\n    rew.coins = _rewardCoins;\r\n    rew.percent = _rewardPercent;\r\n  }\r\n\r\n\r\n  function incAffiliateLevel(uint256 _rewardCoins, uint256 _rewardPercent) external onlyOwner {\r\n    affLevelReward.push(AffiliateReward({coins : _rewardCoins, percent : _rewardPercent}));\r\n  }\r\n\r\n  function decAffiliateLevel() external onlyOwner {\r\n    delete affLevelReward[affLevelReward.length--];\r\n  }\r\n\r\n  function affLevelsCount() external view returns (uint) {\r\n    return affLevelReward.length;\r\n  }\r\n\r\n  function setVipAffiliateLevel(uint256 _level, uint256 _rewardCoins, uint256 _rewardPercent) external onlyOwner {\r\n    require(_level < vipAffLevelReward.length);\r\n    AffiliateReward storage rew = vipAffLevelReward[_level];\r\n    rew.coins = _rewardCoins;\r\n    rew.percent = _rewardPercent;\r\n  }\r\n\r\n  function incVipAffiliateLevel(uint256 _rewardCoins, uint256 _rewardPercent) external onlyOwner {\r\n    vipAffLevelReward.push(AffiliateReward({coins : _rewardCoins, percent : _rewardPercent}));\r\n  }\r\n\r\n  function decVipAffiliateLevel() external onlyOwner {\r\n    delete vipAffLevelReward[vipAffLevelReward.length--];\r\n  }\r\n\r\n  function vipAffLevelsCount() external view returns (uint) {\r\n    return vipAffLevelReward.length;\r\n  }\r\n\r\n  function addVipAffiliates(address[] _affiliates) external onlyOwner {\r\n    require(_affiliates.length > 0);\r\n    for(uint256 i = 0; i < _affiliates.length; i++) {\r\n      vipAffiliates[_getAffCode(uint(_affiliates[i]))] = true;\r\n    }\r\n  }\r\n\r\n  function delVipAffiliates(address[] _affiliates) external onlyOwner {\r\n    require(_affiliates.length > 0);\r\n    for(uint256 i = 0; i < _affiliates.length; i++) {\r\n      delete vipAffiliates[_getAffCode(uint(_affiliates[i]))];\r\n    }\r\n  }\r\n\r\n  function addStaff(address _staff, uint256 _percent) external onlyOwner {\r\n    require(_staff != address(0) && _percent > 0);\r\n    uint256 affCode = _getAffCode(uint(_staff));\r\n    StaffReward storage sr = staffReward[affCode];\r\n    if (!sr.exists) {\r\n      sr.exists = true;\r\n      sr.index = staffCount;\r\n      staffList[staffCount++] = affCode;\r\n    }\r\n    sr.percent = _percent;\r\n  }\r\n\r\n  function delStaff(address _staff) external onlyOwner {\r\n    require(_staff != address(0));\r\n    uint256 affCode = _getAffCode(uint(_staff));\r\n    StaffReward storage sr = staffReward[affCode];\r\n    require(sr.exists);\r\n\r\n    staffReward[staffList[--staffCount]].index = staffReward[affCode].index;\r\n    staffList[staffReward[affCode].index] = staffList[staffCount];\r\n    delete staffList[staffCount];\r\n    delete staffReward[affCode];\r\n  }\r\n\r\n  //// MARKETPLACE\r\n\r\n  function addItem(uint256 genes, uint256 level, uint256 price, uint256 count) external onlyService {\r\n    items[++lastItemId] = Item({\r\n      exists : true,\r\n      index : marketSize,\r\n      genes : genes,\r\n      level : level,\r\n      price : price,\r\n      count : count\r\n      });\r\n    market[marketSize++] = lastItemId;\r\n    emit ItemUpdate(lastItemId, genes, level,  price, count);\r\n  }\r\n\r\n  function delItem(uint256 itemId) external onlyService {\r\n    require(items[itemId].exists);\r\n    items[market[--marketSize]].index = items[itemId].index;\r\n    market[items[itemId].index] = market[marketSize];\r\n    delete market[marketSize];\r\n    delete items[itemId];\r\n    emit ItemUpdate(itemId, 0, 0, 0, 0);\r\n  }\r\n\r\n  function setPrice(uint256 itemId, uint256 price) external onlyService {\r\n    Item memory i = items[itemId];\r\n    require(i.exists);\r\n    require(i.price != price);\r\n    i.price = price;\r\n    emit ItemUpdate(itemId, i.genes, i.level, i.price, i.count);\r\n  }\r\n\r\n  function setCount(uint256 itemId, uint256 count) external onlyService {\r\n    Item storage i = items[itemId];\r\n    require(i.exists);\r\n    require(i.count != count);\r\n    i.count = count;\r\n    emit ItemUpdate(itemId, i.genes, i.level, i.price, i.count);\r\n  }\r\n\r\n  function getItem(uint256 itemId) external view returns (uint256 genes, uint256 level, uint256 price, uint256 count) {\r\n    Item memory i = items[itemId];\r\n    require(i.exists);\r\n    return (i.genes, i.level, i.price, i.count);\r\n  }\r\n\r\n\r\n  //// AFFILIATE\r\n\r\n  function myAffiliateCode() public view returns (uint) {\r\n    return _getAffCode(uint(msg.sender));\r\n  }\r\n\r\n  function _getAffCode(uint256 _a) internal pure returns (uint) {\r\n    return (_a ^ (_a >> 80)) & 0xFFFFFFFFFFFFFFFFFFFF;\r\n  }\r\n\r\n  function buyItem(uint256 itemId, uint256 _affCode) public payable returns (uint256 tokenId) {\r\n    Item memory i = items[itemId];\r\n    require(i.exists);\r\n    require(i.count > 0);\r\n    require(msg.value == i.price);\r\n\r\n    //minting character\r\n    i.count--;\r\n    tokenId = heroes.mint(msg.sender, i.genes, i.level);\r\n\r\n    emit ItemUpdate(itemId, i.genes, i.level, i.price, i.count);\r\n    emit Sold(msg.sender, tokenId, itemId, i.genes, i.level, i.price);\r\n\r\n    // fetch player code\r\n    uint256 _pCode = _getAffCode(uint(msg.sender));\r\n    Affiliate storage p = affiliates[_pCode];\r\n\r\n    //check if it was 1st buy\r\n    if (!p.active) {\r\n      p.active = true;\r\n    }\r\n\r\n    // manage affiliate residuals\r\n\r\n    // if affiliate code was given and player not tried to use their own, lolz\r\n    // and its not the same as previously stored\r\n    if (_affCode != 0 && _affCode != _pCode && _affCode != p.affCode) {\r\n        // update last affiliate\r\n        p.affCode = _affCode;\r\n    }\r\n\r\n    //referral reward\r\n    _distributeAffiliateReward(i.price, _pCode, 0);\r\n\r\n    //staff reward\r\n    _distributeStaffReward(i.price, _pCode);\r\n\r\n    _flushBalance();\r\n  }\r\n\r\n  function _distributeAffiliateReward(uint256 _sum, uint256 _affCode, uint256 _level) internal {\r\n    Affiliate storage aff = affiliates[_affCode];\r\n    AffiliateReward storage ar = vipAffiliates[_affCode] ? vipAffLevelReward[_level] : affLevelReward[_level];\r\n    if (ar.coins > 0) {\r\n      aff.coinsToMint = aff.coinsToMint.add(ar.coins);\r\n      emit CoinReward(_affCode, ar.coins);\r\n    }\r\n    if (ar.percent > 0) {\r\n      uint256 pcnt = _getPercent(_sum, ar.percent);\r\n      aff.ethToSend = aff.ethToSend.add(pcnt);\r\n      totalReserved = totalReserved.add(pcnt);\r\n      emit EthReward(_affCode, pcnt);\r\n    }\r\n    if (++_level < affLevelReward.length && aff.affCode != 0) {\r\n      _distributeAffiliateReward(_sum, aff.affCode, _level);\r\n    }\r\n  }\r\n\r\n  //be aware of big number of staff - huge gas!\r\n  function _distributeStaffReward(uint256 _sum, uint256 _affCode) internal {\r\n    for (uint256 i = 0; i < staffCount; i++) {\r\n      if (_affCode != staffList[i]) {\r\n        Affiliate storage aff = affiliates[staffList[i]];\r\n        StaffReward memory sr = staffReward[staffList[i]];\r\n        if (sr.coins > 0) {\r\n          aff.coinsToMint = aff.coinsToMint.add(sr.coins);\r\n          emit CoinReward(_affCode, sr.coins);\r\n        }\r\n        if (sr.percent > 0) {\r\n          uint256 pcnt = _getPercent(_sum, sr.percent);\r\n          aff.ethToSend = aff.ethToSend.add(pcnt);\r\n          totalReserved = totalReserved.add(pcnt);\r\n          emit EthReward(_affCode, pcnt);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  //player can take all rewards after 1st buy of item when he became active\r\n  function getReward() external nonReentrant {\r\n    // fetch player code\r\n    uint256 _pCode = _getAffCode(uint(msg.sender));\r\n    Affiliate storage p = affiliates[_pCode];\r\n    require(p.active);\r\n\r\n    //minting coins\r\n    if (p.coinsToMint > 0) {\r\n      require(coin.mint(msg.sender, p.coinsToMint));\r\n      p.coinsMinted = p.coinsMinted.add(p.coinsToMint);\r\n      emit CoinRewardGet(_pCode, p.coinsToMint);\r\n      p.coinsToMint = 0;\r\n    }\r\n    //sending eth\r\n    if (p.ethToSend > 0) {\r\n      msg.sender.transfer(p.ethToSend);\r\n      p.ethSent = p.ethSent.add(p.ethToSend);\r\n      totalReserved = totalReserved.sub(p.ethToSend);\r\n      emit EthRewardGet(_pCode, p.ethToSend);\r\n      p.ethToSend = 0;\r\n    }\r\n  }\r\n\r\n  //// SERVICE\r\n  //1% - 100, 10% - 1000 50% - 5000\r\n  function _getPercent(uint256 _v, uint256 _p) internal pure returns (uint)    {\r\n    return _v.mul(_p).div(10000);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_rewardCoins\",\"type\":\"uint256\"},{\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"name\":\"setVipAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"staffReward\",\"outputs\":[{\"name\":\"coins\",\"type\":\"uint256\"},{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"affiliates\",\"outputs\":[{\"name\":\"affCode\",\"type\":\"uint256\"},{\"name\":\"coinsToMint\",\"type\":\"uint256\"},{\"name\":\"ethToSend\",\"type\":\"uint256\"},{\"name\":\"coinsMinted\",\"type\":\"uint256\"},{\"name\":\"ethSent\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staff\",\"type\":\"address\"},{\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"addStaff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heroes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staff\",\"type\":\"address\"}],\"name\":\"delStaff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"market\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"getItem\",\"outputs\":[{\"name\":\"genes\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staffCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastItemId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"genes\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"addItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vipAffLevelsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"decAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vipAffLevelReward\",\"outputs\":[{\"name\":\"coins\",\"type\":\"uint256\"},{\"name\":\"percent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myAffiliateCode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_rewardCoins\",\"type\":\"uint256\"},{\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"name\":\"setAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"itemId\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"setCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affLevelsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"itemId\",\"type\":\"uint256\"},{\"name\":\"_affCode\",\"type\":\"uint256\"}],\"name\":\"buyItem\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardCoins\",\"type\":\"uint256\"},{\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"name\":\"incVipAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"delItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"decVipAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vipAffiliates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affiliates\",\"type\":\"address[]\"}],\"name\":\"delVipAffiliates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"staffList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"affLevelReward\",\"outputs\":[{\"name\":\"coins\",\"type\":\"uint256\"},{\"name\":\"percent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardCoins\",\"type\":\"uint256\"},{\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"name\":\"incAffiliateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affiliates\",\"type\":\"address[]\"}],\"name\":\"addVipAffiliates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"itemId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_heroes\",\"type\":\"address\"},{\"name\":\"_coin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"itemId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"ItemUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"itemId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"code\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"CoinReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"code\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"EthReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"code\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"CoinRewardGet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"code\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"EthRewardGet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Income\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ServiceAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ServiceRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SaleFix","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d2bae9a30a40376d25353773010ffe52dba0d68800000000000000000000000004c271ef0e8dd18a24c194ae7e72d74398b3b4b0","Library":"","SwarmSource":"bzzr://ce66ea7e76bede4c1407539ad836834da3597d47f4c7eca0755be40b02c0b41a"}]}