{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n******************************************************************************************************************************************************************************************\r\n\r\n                    $$$$$$$\\                                                                    $$\\     $$\\                 $$\\                           $$\\       \r\n                    $$  __$$\\                                                                   $$ |    \\__|                $$ |                          $$ |      \r\n                    $$ |  $$ | $$$$$$\\  $$$$$$\\$$$$\\   $$$$$$\\   $$$$$$$\\  $$$$$$\\   $$$$$$\\  $$$$$$\\   $$\\  $$$$$$$\\       $$ |      $$\\   $$\\  $$$$$$$\\ $$ |  $$\\ \r\n                    $$ |  $$ |$$  __$$\\ $$  _$$  _$$\\ $$  __$$\\ $$  _____|$$  __$$\\  \\____$$\\ \\_$$  _|  $$ |$$  _____|      $$ |      $$ |  $$ |$$  _____|$$ | $$  |\r\n                    $$ |  $$ |$$$$$$$$ |$$ / $$ / $$ |$$ /  $$ |$$ /      $$ |  \\__| $$$$$$$ |  $$ |    $$ |$$ /            $$ |      $$ |  $$ |$$ /      $$$$$$  / \r\n                    $$ |  $$ |$$   ____|$$ | $$ | $$ |$$ |  $$ |$$ |      $$ |      $$  __$$ |  $$ |$$\\ $$ |$$ |            $$ |      $$ |  $$ |$$ |      $$  _$$<  \r\n                    $$$$$$$  |\\$$$$$$$\\ $$ | $$ | $$ |\\$$$$$$  |\\$$$$$$$\\ $$ |      \\$$$$$$$ |  \\$$$$  |$$ |\\$$$$$$$\\       $$$$$$$$\\ \\$$$$$$  |\\$$$$$$$\\ $$ | \\$$\\ \r\n                    \\_______/  \\_______|\\__| \\__| \\__| \\______/  \\_______|\\__|       \\_______|   \\____/ \\__| \\_______|      \\________| \\______/  \\_______|\\__|  \\__|\r\n                            \r\n                          \r\n                                                                                _    _                                        _  _              \r\n                                                                              | |  | |                                      | |(_)             \r\n                                        __      ____      ____      __     ___ | |_ | |__    __ _   __ _  _ __ ___    ___    | | _ __   __  ___ \r\n                                        \\ \\ /\\ / /\\ \\ /\\ / /\\ \\ /\\ / /    / _ \\| __|| '_ \\  / _` | / _` || '_ ` _ \\  / _ \\   | || |\\ \\ / / / _ \\\r\n                                        \\ V  V /  \\ V  V /  \\ V  V /  _ |  __/| |_ | | | || (_| || (_| || | | | | ||  __/ _ | || | \\ V / |  __/\r\n                                          \\_/\\_/    \\_/\\_/    \\_/\\_/  (_) \\___| \\__||_| |_| \\__, | \\__,_||_| |_| |_| \\___|(_)|_||_|  \\_/   \\___|\r\n                                                                                            __/ |                                              \r\n                                                                                            |___/                                               \r\n\r\n******************************************************************************************************************************************************************************************                                                                                                                                          \r\n\r\nContract Name: Democratic Luck\r\nContract Symbol: DemoLuck\r\nVersion: 1.0\r\nAuthor: Alan Yan\r\nAuthor Email: AlanYan99@outlook.com\r\nPublish Date: 2018/11\r\nOfficial Website: www.ethgame.live\r\nCopyright: All rights reserved\r\nContract Describe: \r\n    A game that include investment, math strategy, luck and democratic mechanism for game equilibrium. It based on eth blockchain network. \r\n    Let's hope the whole world's people can enjoy this new revolutionary game and have fun!\r\n    Game Rules:\r\n    1. This game use ether cryptocurrency. To participate in the game, user need to use a browser such as chrome/Firefox with the metamask plugin installed.\r\n    2. User can directly participate in the game without registration first. If user buy share or buy ticket, then will be automatically registered. User also \r\n      can manually register for free. The process of manual registration is very simple, just click the 'Register' button on the website, and then click 'Confirm' \r\n      in the pop-up metamask window. Registration will complete.\r\n    3. Each user will have an account with a purse and a dedicated promotion url link. User can send this link to others and invite others to participate in the game, \r\n      if the others join the game and get prize, user will always receive 5% of the others' prize as reward.\r\n    4. After each round of the game begins, user can buy shares of the game and become the shareholder. The price of the shares is 1eth/share, and 70% of the cost \r\n      ether will put into the jackpot prize pool, 20% will be constantly distributed to all earlier shares (including itself), and 10% will be given to the last \r\n      share buyer at the end of game round as a special prize.\r\n    5. When there is a jackpot prize pool, then anyone can buy luck tickets at any time to win the jackpot prize pool. The price of the luck ticket is 0.01 eth, \r\n      and 50% of the cost ether will instantly distribute to all current shares, and 50% of the cost ether will instantly distribute to all earlier luck tickets (including itself).\r\n    6. When a luck ticket was been bought, a 48-hour countdown will auto start. If a new luck ticket was been bought during the countdown, then 48-hour countdown\r\n      will restart again. If when the 48-hour countdown is over, there is still no new ticket was been bought. Then the game will enter the vote period. The vote\r\n      period is 24 hours. Every shareholder can participate in vote. Shareholder's share amount is votes amount. Shareholders can choose to continue wait or end \r\n      the game round. If the shareholder didn't not manually vote, the default option is continue wait, if votes amount of end game round is more than 50% of the \r\n      total votes amount, then game round will auto end. During the voting period, if a new luck ticket was been bought, then vote will be cancelled and restart \r\n      the 48-hour countdown again. After vote period over and shareholders didn't vote to end game round, then game will continue wait and restart the 48-hour countdown again.\r\n    7. During the game, shareholders or luck ticket buyers can view their own prize at any time. The prize is dynamic estimation and change with the game progress.\r\n    8. When the game is over, the prize will be automatically distributed. The prize distribution rules are: the instantly prize obtained by shareholders and luck \r\n      ticket buyers during the game will be their prize too, also the total share capital's 10% will reward to the last share buyer at the end of the game as a \r\n      special prize, the last luck ticket buyer will win the jackpot prize pool.\r\n    9. After the game is over, The prize that each player received, the platform will charge 5% as a service fee, and the remaining 95% will automatically deposited\r\n      into the purse of user's account. User can withdraw the prize to own personal ether account at any time.\r\n    10. If player (shareholder or luck ticket buyer) wins the prize in the game round, and player has a referrer, the referrer will receive 5% of the prize as a reward. \r\n      When player withdraw the prize from purse, the reward will be sent to referer's purse.\r\n    11. After each game round ended and distributed prize, the next round will automatically restart.\r\n\r\n**/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/** @title Democratic Luck */\r\ncontract DemocraticLuck {\r\n  \r\n  using SafeMath for uint256;\r\n  \r\n  //event when shareholder buy share \r\n  event event_buyShare(address indexed _addr, uint256 indexed _indexNo, uint256 _num);\r\n  //event when player buy luck ticket \r\n  event event_buyTicket(address indexed _addr, uint256 indexed _indexNo, uint256 _num);\r\n  //event when shareholder vote\r\n  event event_shareholderVote(address indexed _addr, uint256 indexed _indexNo, uint256 _vote);  \r\n  //event when round end and jackpot winner\r\n  event event_endRound(uint256 indexed _indexNo, address indexed _addr, uint256 _prize);\r\n  \r\n  address private Owner; \r\n  uint256 private rdSharePrice = 1 ether;  //share's price\r\n  uint256 private rdTicketPrice = 0.01 ether; //luck ticket's price\r\n  uint256 private rdIndexNo = 0; //game round's index No  counter\r\n  uint256 private userIDCnt = 0;  //user's id counter\r\n  uint256 private rdStateActive = 1;  //game round's active state \r\n  uint256 private rdStateEnd = 2;   //game round's end state\r\n  uint256 private rdTicketTime = 48 hours; //countdown time since a ticket was been bought\r\n  uint256 private rdVoteTime = 24 hours; //vote time since countdown time over\r\n  uint256 private serviceFee = 5; //system charge service fee rate\r\n  uint256 private refererFee = 5; //referer user's prize percent 5%\r\n  uint256 private sharePotRate = 70; //share price's percent into jackpot   \r\n  uint256 private shrPrizeRate = 20; //share price's percent to distribute to current shares\r\n  uint256 private shrLastBuyerRate = 10; //share price's percent to last share buyer\r\n  uint256 private ticketPotRate = 50; //ticket price's percent to distribute to current shares\r\n  uint256 private serviceFeeCnt; //owner service fee count\r\n   \r\n  //user's account information\r\n  struct userAcc{  \r\n        uint256 purse; //user's purse\r\n        uint256 refCode; //user's unique referrer code\r\n        uint256 frefCode; //user from referrer code \r\n  }\r\n  \r\n  //game shareholder's information\r\n  struct rdShareholder{\r\n        uint256 cost;  //shareholder cost to buy share\r\n        uint256 shareNum;  //shareholder's shares amount  \r\n        uint256 shrAvgBonus;  //shareholder's shares average value to calculate bonus from later shares  \r\n        uint256 shrTckAvgBonus;  //shareholder's shares average value to calculate bonus from tickets sale  \r\n        uint256 vote; //shareholder's vote to coutinue or end game round\r\n        uint256 lastShrVoteTime; //shareholder's last vote time       \r\n  }  \r\n  \r\n  //luck ticket buyer's information\r\n  struct rdTckBuyer{ \r\n        uint256 cost;   //ticket buyer cost to buy ticket\r\n        uint256 ticketNum; //ticket's amount\r\n        uint256 tckAvgBonus; //ticket buyer's average value to calculate bonus from later tickets\r\n  }\r\n  \r\n  //game round's information\r\n  struct rdInfo{ \r\n        uint256 state;   //round's state: 1,active 2,end\r\n        uint256 sharePot;    //all share's capital pot\r\n        uint256 shrJackpot;    //round's jackpot\r\n        uint256 shareholderNum; //shareholders amount        \r\n        uint256 shareNum;  //shares amount\r\n        uint256 shrAvgBonus;  //round's shares average value to calculate bonus from later shares\r\n        uint256 shrTckAvgBonus; //round's shares average value to calculate bonus from tickets sale\r\n        uint256 ticketPot; //luck ticket sales amount \r\n        uint256 tckBuyerNum; //luck ticket buyers amount      \r\n        uint256 ticketNum; //luck ticket's saled amount \r\n        uint256 tckAvgBonus; //round's ticket buyer's average value to calculate bonus from later tickets\r\n        uint256 lastTckBuyTime; //time of last ticket was been bought \r\n        uint256 lastShrVoteTime;  //last time of shareholders vote\r\n        uint256 shrVotesEnd;   //count of votes to end    \r\n        address lastShareBuyer; //who bought the last share \r\n        address lastTckBuyer; //who bought the last luck ticket\r\n   }\r\n\r\n \r\n  mapping(uint256 => address) private userIDAddr; //user'id => user's account\r\n  mapping(address => userAcc) private userAccs;  //user's account => user's account information\r\n  mapping(address => uint256[]) private userUnWithdrawRound; //round list that user didn't withdraw yet  \r\n  mapping(uint256 => mapping(address => rdShareholder)) private rdShareholders;  //round's index No => shareholder's account =>  shareholder's information  \r\n  mapping(uint256 => rdInfo) private rdInfos;  //round's index No => round's information\r\n  mapping(uint256 => mapping(address => rdTckBuyer)) private rdTckBuyers;  //round's index No => luck ticket buyer's account => ticket buyer's information  \r\n \r\n  \r\n  /* Modifiers */\r\n\r\n  /** @dev check caller is owner    \r\n  */\r\n  modifier onlyOwner()\r\n  {\r\n    require(Owner == msg.sender);\r\n    _;\r\n  }   \r\n  \r\n  /** @dev check caller is person     \r\n  */\r\n  modifier isPerson()\r\n  {        \r\n    address addr = msg.sender;\r\n    uint256 size;\r\n    \r\n    assembly {size := extcodesize(addr)}\r\n    require(size == 0);\r\n\r\n    require(tx.origin == msg.sender);\r\n    _;\r\n  }\r\n  \r\n  /** @dev create contract     \r\n  */\r\n  constructor()\r\n  public\r\n  {\r\n    Owner = msg.sender;   \r\n    startNewRound();\r\n  }\r\n  \r\n  /** @dev tarnsfer ownership to new account\r\n    * @param _owner  new owner account \r\n  */\r\n  function transferOwnership(address _owner)\r\n  onlyOwner()\r\n  public \r\n  { \r\n    Owner = _owner;\r\n  }  \r\n  \r\n  /** @dev get contract owner account\r\n    * @return _addr owner account \r\n  */\r\n  function owner()\r\n  public \r\n  view \r\n  returns (address _addr) \r\n  {\r\n    return Owner;\r\n  } \r\n  \r\n  /** @dev start new game round   \r\n  */\r\n  function startNewRound()\r\n  internal\r\n  {      \r\n    rdIndexNo++;\r\n    rdInfo memory rdInf = rdInfo(rdStateActive, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, address(0), address(0));\r\n    rdInfos[rdIndexNo] = rdInf;\r\n  } \r\n \r\n  /** @dev new user register \r\n    * @param _frefCode  referer id  \r\n  */\r\n  function userRegister(uint256 _frefCode)\r\n  isPerson() \r\n  public \r\n  {  \r\n    require(msg.sender != address(0));\r\n    require(!checkUserExist(msg.sender)); \r\n    \r\n    addNewUser(msg.sender, _frefCode);        \r\n  }    \r\n\r\n  /** @dev add new user\r\n    * @param _addr  user account\r\n    * @param _frefCode  referer id  \r\n  */\r\n  function addNewUser(address _addr, uint256 _frefCode)  \r\n  internal \r\n  {  \r\n    if(getAddrOfRefCode(_frefCode) == address(0))\r\n          _frefCode = 0;          \r\n    \r\n    userIDCnt++;       \r\n    userAcc memory uAcc = userAcc(0, userIDCnt, _frefCode);\r\n    userAccs[_addr] = uAcc;      \r\n    userIDAddr[userIDCnt] = _addr;                \r\n  }    \r\n\r\n  /** @dev add new shareholder into game round\r\n     * @param _indexNo  round's index No\r\n     * @param _addr  shareholder account     \r\n  */\r\n  function addRdShareholder(uint256 _indexNo, address _addr)\r\n  internal \r\n  {\r\n    rdShareholder memory rdPly = rdShareholder(0, 0, 0, 0, 0, 0);\r\n    rdShareholders[_indexNo][_addr] = rdPly;    \r\n    rdInfos[_indexNo].shareholderNum++;\r\n    if(!checkUserInUnWithdrawRd(_indexNo, _addr))\r\n      userUnWithdrawRound[_addr].push(_indexNo);\r\n  }  \r\n\r\n  /** @dev add new ticket buyer into game round\r\n     * @param _indexNo  round's index No\r\n     * @param _addr  ticket buyer account     \r\n  */\r\n  function addRdTicketBuyer(uint256 _indexNo, address _addr)\r\n  internal \r\n  {\r\n    rdTckBuyer memory rdPly = rdTckBuyer(0, 0, 0);\r\n    rdTckBuyers[_indexNo][_addr] = rdPly;    \r\n    rdInfos[_indexNo].tckBuyerNum++;\r\n    if(!checkUserInUnWithdrawRd(_indexNo, _addr))\r\n      userUnWithdrawRound[_addr].push(_indexNo);\r\n  }  \r\n  \r\n  /** @dev shareholder buy shares\r\n    * @param _indexNo  round's index No    \r\n    * @param _frefCode  referer id    \r\n  */\r\n  function buyShare(uint256 _indexNo, uint256 _frefCode)\r\n  isPerson() \r\n  public \r\n  payable \r\n  {\r\n    require(msg.sender != address(0)); \r\n    require(checkRdActive(_indexNo));    \r\n    require(msg.value.sub(rdSharePrice) >= 0);\r\n    \r\n    uint256 _num = msg.value.div(rdSharePrice);\r\n    uint256 cost = rdSharePrice.mul(_num);   \r\n\r\n    if(!checkUserExist(msg.sender))\r\n      addNewUser(msg.sender, _frefCode); \r\n\r\n    if(!checkShareholderInRd(_indexNo, msg.sender))\r\n      addRdShareholder(_indexNo, msg.sender); \r\n\r\n    addRoundShare(_indexNo, msg.sender, cost, _num); \r\n    calcServiceFee(cost);   \r\n\r\n    if(msg.value.sub(cost) > 0)\r\n       userAccs[msg.sender].purse += msg.value.sub(cost);\r\n    \r\n    emit event_buyShare(msg.sender, _indexNo, _num);\r\n  }  \r\n\r\n  /** @dev add shares info when shareholder bought\r\n    * @param _indexNo  round's index No   \r\n    * @param _addr shareholder's account\r\n    * @param _cost cost amount   \r\n    * @param _num shares amount    \r\n  */\r\n  function addRoundShare(uint256 _indexNo, address _addr, uint256 _cost, uint256 _num)\r\n  internal \r\n  {    \r\n    rdInfos[_indexNo].lastShareBuyer = _addr;       \r\n    rdInfos[_indexNo].shareNum += _num;\r\n    rdInfos[_indexNo].sharePot = rdInfos[_indexNo].sharePot + _cost; \r\n    rdInfos[_indexNo].shrJackpot = rdInfos[_indexNo].shrJackpot + (_cost * sharePotRate / 100); \r\n    rdInfos[_indexNo].shrAvgBonus = rdInfos[_indexNo].shrAvgBonus + (_cost * shrPrizeRate / 100) / rdInfos[_indexNo].shareNum;\r\n       \r\n    rdShareholders[_indexNo][_addr].cost += _cost;         \r\n    rdShareholders[_indexNo][_addr].shareNum += _num;  \r\n    rdShareholders[_indexNo][_addr].shrAvgBonus = (rdInfos[_indexNo].shrAvgBonus * rdShareholders[_indexNo][_addr].shareNum - (rdInfos[_indexNo].shrAvgBonus - (_cost * shrPrizeRate / 100) / rdInfos[_indexNo].shareNum - rdShareholders[_indexNo][_addr].shrAvgBonus) * (rdShareholders[_indexNo][_addr].shareNum - _num) - (_cost * shrPrizeRate / 100) * rdShareholders[_indexNo][_addr].shareNum / rdInfos[_indexNo].shareNum) / rdShareholders[_indexNo][_addr].shareNum;     \r\n    rdShareholders[_indexNo][_addr].shrTckAvgBonus = (rdInfos[_indexNo].shrTckAvgBonus * rdShareholders[_indexNo][_addr].shareNum - (rdInfos[_indexNo].shrTckAvgBonus - rdShareholders[_indexNo][_addr].shrTckAvgBonus) * (rdShareholders[_indexNo][_addr].shareNum - _num)) / rdShareholders[_indexNo][_addr].shareNum;       \r\n  } \r\n\r\n  /** @dev buy luck ticket\r\n    * @param _indexNo  round's index No  \r\n    * @param _frefCode  referer id\r\n  */\r\n  function buyTicket(uint256 _indexNo, uint256 _frefCode)\r\n  isPerson() \r\n  public \r\n  payable \r\n  { \r\n    require(msg.sender != address(0)); \r\n    require(checkRdActive(_indexNo));   \r\n    require(rdInfos[_indexNo].shrJackpot > 0); \r\n    require(msg.value.sub(rdTicketPrice) >= 0);\r\n    \r\n    uint256 _num = msg.value.div(rdTicketPrice);\r\n    uint256 cost = rdTicketPrice.mul(_num);\r\n\r\n    if(!checkUserExist(msg.sender))\r\n      addNewUser(msg.sender, _frefCode); \r\n    if(!checkTicketBuyerInRd(_indexNo, msg.sender))\r\n      addRdTicketBuyer(_indexNo, msg.sender); \r\n\r\n    addRoundTicket(_indexNo, msg.sender, cost, _num);    \r\n    calcServiceFee(cost); \r\n\r\n    if(msg.value.sub(cost) > 0)\r\n       userAccs[msg.sender].purse += msg.value.sub(cost);\r\n\r\n    emit event_buyTicket(msg.sender, _indexNo, _num);\r\n  } \r\n\r\n  /** @dev add ticket info\r\n    * @param _indexNo  round's index No   \r\n    * @param _addr buyer's account\r\n    * @param _cost cost amount   \r\n    * @param _num tickets amount    \r\n  */\r\n  function addRoundTicket(uint256 _indexNo, address _addr, uint256 _cost, uint256 _num)\r\n  internal \r\n  { \r\n    rdInfos[_indexNo].lastTckBuyTime = now;\r\n    rdInfos[_indexNo].lastTckBuyer = _addr; \r\n    rdInfos[_indexNo].ticketNum += _num;\r\n    rdInfos[_indexNo].ticketPot = rdInfos[_indexNo].ticketPot + _cost;        \r\n    rdInfos[_indexNo].shrTckAvgBonus = rdInfos[_indexNo].shrTckAvgBonus + (_cost * ticketPotRate / 100) / rdInfos[_indexNo].shareNum; \r\n    rdInfos[_indexNo].tckAvgBonus = rdInfos[_indexNo].tckAvgBonus + (_cost * (100 - ticketPotRate) / 100) / rdInfos[_indexNo].ticketNum;     \r\n\r\n    rdTckBuyers[_indexNo][_addr].cost += _cost;\r\n    rdTckBuyers[_indexNo][_addr].ticketNum += _num;\r\n    rdTckBuyers[_indexNo][_addr].tckAvgBonus = (rdInfos[_indexNo].tckAvgBonus * rdTckBuyers[_indexNo][_addr].ticketNum - (rdInfos[_indexNo].tckAvgBonus - (_cost * (100 - ticketPotRate) / 100) / rdInfos[_indexNo].ticketNum - rdTckBuyers[_indexNo][_addr].tckAvgBonus) * (rdTckBuyers[_indexNo][_addr].ticketNum - _num) - (_cost * (100 - ticketPotRate) / 100) * rdTckBuyers[_indexNo][_addr].ticketNum / rdInfos[_indexNo].ticketNum) / rdTckBuyers[_indexNo][_addr].ticketNum;   \r\n  }  \r\n  \r\n  /**\r\n  * @dev get user amount \r\n  * @return _num user amount \r\n  */\r\n  function getUserCount()\r\n  public \r\n  view \r\n  returns(uint256 _num) \r\n  {    \r\n    return userIDCnt;    \r\n  }\r\n  \r\n  /**\r\n  * @dev get user's information \r\n  * @param _addr  user's account \r\n  * @return user's information \r\n  */\r\n  function getUserInfo(address _addr)\r\n  public \r\n  view \r\n  returns(uint256, uint256, uint256) \r\n  {   \r\n    require(_addr != address(0));\r\n    require(checkUserExist(_addr));\r\n      \r\n    uint256 prize = 0;  \r\n\r\n    for(uint256 i = 0; i < userUnWithdrawRound[_addr].length; i++)\r\n    {\r\n      uint256 indexNo = userUnWithdrawRound[_addr][i];\r\n       \r\n      if(rdInfos[indexNo].state == rdStateEnd)      \r\n        prize += calcRdPlayerPrize(indexNo, _addr); \r\n    }\r\n\r\n    prize = userAccs[_addr].purse + prize * (100 - serviceFee) / 100; \r\n\r\n    return (prize, userAccs[_addr].refCode, userAccs[_addr].frefCode);    \r\n  }\r\n\r\n  /** @dev user withdraw eth from purse, withdraw all every time   \r\n  */\r\n  function userWithdraw()\r\n  isPerson() \r\n  public \r\n  {          \r\n    require(msg.sender != address(0));\r\n    require(checkUserExist(msg.sender));\r\n    \r\n    address addr = msg.sender;\r\n    uint256 prize = 0;\r\n    uint256 unEndRd = 0;\r\n\r\n    for(uint256 i = 0; i < userUnWithdrawRound[addr].length; i++)\r\n    {\r\n      uint256 indexNo = userUnWithdrawRound[addr][i];\r\n       \r\n      if(rdInfos[indexNo].state == rdStateEnd)      \r\n        prize += calcRdPlayerPrize(indexNo, addr); \r\n      else\r\n        unEndRd = indexNo;\r\n    }\r\n    \r\n    require(prize > 0); \r\n    userUnWithdrawRound[addr].length = 0;   \r\n    if(unEndRd > 0)\r\n      userUnWithdrawRound[addr].push(unEndRd);    \r\n    prize = prize * (100 - serviceFee) / 100;\r\n\r\n    if(userAccs[addr].frefCode != 0)\r\n    {\r\n      address frefAddr = getAddrOfRefCode(userAccs[addr].frefCode);\r\n      if(frefAddr != address(0))\r\n      {\r\n          uint256 refPrize = (prize * refererFee) / 100;\r\n          userAccs[frefAddr].purse += refPrize;\r\n          prize -= refPrize;\r\n      }    \r\n    }          \r\n\r\n    prize += userAccs[addr].purse;\r\n    userAccs[addr].purse = 0;\r\n    addr.transfer(prize);            \r\n  }   \r\n  \r\n  /**\r\n  * @dev calculate player's prize\r\n  * @param _indexNo  round's index No\r\n  * @param _addr  player's account\r\n  * @return _prize player's prize \r\n  */\r\n  function calcRdPlayerPrize(uint256 _indexNo, address _addr)\r\n  internal \r\n  view \r\n  returns(uint256 _prize)\r\n  { \r\n    uint256 prize = 0;\r\n    \r\n    if(rdShareholders[_indexNo][_addr].shareNum > 0)    \r\n      prize += calcShrPrize(_indexNo, _addr); \r\n     \r\n    if(rdTckBuyers[_indexNo][_addr].ticketNum > 0)\r\n      prize += calcTckPrize(_indexNo, _addr);\r\n\r\n    return prize;\r\n  }\r\n\r\n  /**\r\n  * @dev calculate shareholder's share prize\r\n  * @param _indexNo  round's index No\r\n  * @param _addr  shareholder account\r\n  * @return _prize shareholder's prize \r\n  */  \r\n  function calcShrPrize(uint256 _indexNo, address _addr)\r\n  internal \r\n  view \r\n  returns(uint256 _prize)\r\n  { \r\n    uint256 prize = 0;\r\n\r\n    prize += (rdInfos[_indexNo].shrAvgBonus - rdShareholders[_indexNo][_addr].shrAvgBonus) * rdShareholders[_indexNo][_addr].shareNum;\r\n    prize += (rdInfos[_indexNo].shrTckAvgBonus - rdShareholders[_indexNo][_addr].shrTckAvgBonus) * rdShareholders[_indexNo][_addr].shareNum;  \r\n    \r\n    if(rdInfos[_indexNo].lastShareBuyer == _addr) \r\n      prize += (rdInfos[_indexNo].sharePot * shrLastBuyerRate) / 100;  \r\n       \r\n    return prize;\r\n  }\r\n\r\n  /**\r\n  * @dev calculate ticket buyer's ticket prize\r\n  * @param _indexNo  round's index No\r\n  * @param _addr  buyer account\r\n  * @return _prize buyer's prize \r\n  */  \r\n  function calcTckPrize(uint256 _indexNo, address _addr)\r\n  internal \r\n  view \r\n  returns(uint256 _prize)\r\n  { \r\n    uint256 prize = 0;\r\n   \r\n    prize += (rdInfos[_indexNo].tckAvgBonus - rdTckBuyers[_indexNo][_addr].tckAvgBonus) * rdTckBuyers[_indexNo][_addr].ticketNum; \r\n    \r\n    if(rdInfos[_indexNo].lastTckBuyer == _addr) \r\n      prize += rdInfos[_indexNo].shrJackpot;  \r\n    \r\n    return prize;\r\n  }  \r\n \r\n  /** @dev get active round's index No\r\n    * @return _rdIndexNo active round's index No\r\n  */\r\n  function getRoundActive()\r\n  public \r\n  view \r\n  returns(uint256 _rdIndexNo) \r\n  {   \r\n     return rdIndexNo; \r\n  }\r\n      \r\n  /** @dev get round's information\r\n    * @param _indexNo  round's index No \r\n    * @return _rdIn rounds's information\r\n    * @return _addrs rounds's information\r\n  */\r\n  function getRdInfo(uint256 _indexNo)  \r\n  public \r\n  view \r\n  returns(uint256[] _rdIn, address[] _addrs)\r\n  {    \r\n    require(checkRdExist(_indexNo));\r\n    \r\n    uint256[] memory rdIn = new uint256[](16);    \r\n    address[] memory addrs = new address[](2);    \r\n    \r\n    rdIn[0] = rdSharePrice;    \r\n    rdIn[1] = rdTicketPrice;\r\n    rdIn[2] = rdInfos[_indexNo].state;\r\n    rdIn[3] = rdInfos[_indexNo].sharePot;\r\n    rdIn[4] = rdInfos[_indexNo].shrJackpot;\r\n    rdIn[5] = rdInfos[_indexNo].shareholderNum;\r\n    rdIn[6] = rdInfos[_indexNo].shareNum;     \r\n    rdIn[7] = rdInfos[_indexNo].shrAvgBonus; \r\n    rdIn[8] = rdInfos[_indexNo].shrTckAvgBonus;    \r\n    rdIn[9] = rdInfos[_indexNo].ticketPot; \r\n    rdIn[10] = rdInfos[_indexNo].tckBuyerNum;\r\n    rdIn[11] = rdInfos[_indexNo].ticketNum; \r\n    rdIn[12] = rdInfos[_indexNo].tckAvgBonus;\r\n    rdIn[13] = rdInfos[_indexNo].lastTckBuyTime;\r\n    rdIn[14] = rdInfos[_indexNo].lastShrVoteTime;\r\n    rdIn[15] = rdInfos[_indexNo].shrVotesEnd;   \r\n\r\n    addrs[0] =  rdInfos[_indexNo].lastShareBuyer;\r\n    addrs[1] =  rdInfos[_indexNo].lastTckBuyer; \r\n  \r\n    return (rdIn,  addrs);  \r\n  }\r\n  \r\n \r\n  /** @dev get round's countdown time or vote time state\r\n    * @param _indexNo  round's index No \r\n    * @return _timeState countdown time or vote time\r\n    * @return _timeLeft  left time   \r\n  */  \r\n  function getRdTimeState(uint256 _indexNo)  \r\n  public \r\n  view \r\n  returns(uint256 _timeState, uint256 _timeLeft) \r\n  {  \r\n    require(checkRdActive(_indexNo));\r\n    \r\n    uint256 nowTime = now;\r\n    uint256 timeState = 0;\r\n    uint256 timeLeft = 0;        \r\n    \r\n    uint256 timeStart = getRdLastCntDownStart(_indexNo, nowTime); \r\n    \r\n    if(timeStart > 0)\r\n    { \r\n      if(nowTime < (timeStart + rdTicketTime))\r\n      {\r\n        timeState = 1;\r\n        timeLeft = (timeStart + rdTicketTime) - nowTime;\r\n      }      \r\n      else\r\n      {\r\n        timeState = 2;\r\n        timeLeft = (timeStart + rdTicketTime + rdVoteTime) - nowTime; \r\n      }\r\n      \r\n    }   \r\n  \r\n    return (timeState, timeLeft);  \r\n  }\r\n\r\n  /** @dev get round's last countdown start time\r\n    * @param _indexNo  round's index No\r\n    * @param _nowTime  now time \r\n    * @return _timeStart last countdown start time\r\n  */  \r\n  function getRdLastCntDownStart(uint256 _indexNo, uint256 _nowTime)  \r\n  internal \r\n  view \r\n  returns(uint256 _timeStart) \r\n  {  \r\n    require(checkRdActive(_indexNo));\r\n   \r\n    uint256 timeStart = 0;   \r\n    \r\n    if(rdInfos[_indexNo].lastTckBuyTime > 0)\r\n    { \r\n      uint256 timeSpan = _nowTime - rdInfos[_indexNo].lastTckBuyTime;\r\n      uint256 num = timeSpan / (rdTicketTime + rdVoteTime);\r\n      timeStart = rdInfos[_indexNo].lastTckBuyTime + num * (rdTicketTime + rdVoteTime);\r\n    }   \r\n  \r\n    return timeStart;  \r\n  }\r\n \r\n  /** @dev get round's player's information\r\n    * @param _indexNo  round's index No \r\n    * @param _addr player's account   \r\n    * @return _rdPly1  shareholder's information \r\n    * @return _rdPly2  ticket buyer's information \r\n  */\r\n  function getRdPlayerInfo(uint256 _indexNo, address _addr)\r\n  public \r\n  view \r\n  returns(uint256[] _rdPly1, uint256[] _rdPly2) \r\n  { \r\n    require(checkShareholderInRd(_indexNo, _addr) || checkTicketBuyerInRd(_indexNo, _addr));\r\n    \r\n    uint256[] memory rdPly1 = new uint256[](6);\r\n    uint256[] memory rdPly2 = new uint256[](3);\r\n\r\n    if(checkShareholderInRd(_indexNo, _addr))\r\n    {\r\n      rdPly1[0] = rdShareholders[_indexNo][_addr].cost;    \r\n      rdPly1[1] = rdShareholders[_indexNo][_addr].shareNum; \r\n      rdPly1[2] = rdShareholders[_indexNo][_addr].shrAvgBonus;\r\n      rdPly1[3] = rdShareholders[_indexNo][_addr].shrTckAvgBonus;  \r\n      rdPly1[4] = calcShrPrize(_indexNo, _addr);  \r\n      rdPly1[5] = 0;  \r\n\r\n      if(checkRdInVoteState(_indexNo))         \r\n        rdPly1[5] = getRdshareholderVoteVal(_indexNo, _addr, now);\r\n    }\r\n    \r\n    if(checkTicketBuyerInRd(_indexNo, _addr))\r\n    {\r\n      rdPly2[0] = rdTckBuyers[_indexNo][_addr].cost;\r\n      rdPly2[1] = rdTckBuyers[_indexNo][_addr].ticketNum;\r\n      rdPly2[2] = calcTckPrize(_indexNo, _addr);   \r\n    }\r\n\r\n    return (rdPly1, rdPly2);  \r\n  }  \r\n  \r\n  /** @dev shareholder vote to coutinue or end round\r\n    * @param _indexNo  round's index No \r\n    * @param _vote coutinue or end round\r\n  */\r\n  function shareholderVote(uint256 _indexNo, uint256 _vote)\r\n  isPerson()\r\n  public \r\n  { \r\n    require(checkRdInVoteState(_indexNo));\r\n    require(checkShareholderInRd(_indexNo, msg.sender));    \r\n    require(_vote == 0 || _vote == 1);\r\n    \r\n    address addr = msg.sender;\r\n    uint256 nowTime = now;\r\n    uint256 timeStart = getRdLastCntDownStart(_indexNo, nowTime); \r\n\r\n    if(rdInfos[_indexNo].lastShrVoteTime < (timeStart + rdTicketTime))\r\n    {   \r\n        rdShareholders[_indexNo][addr].vote = 0;        \r\n        rdInfos[_indexNo].shrVotesEnd = 0;\r\n    } \r\n\r\n    if(rdShareholders[_indexNo][addr].lastShrVoteTime > (timeStart + rdTicketTime))\r\n    {\r\n      if(_vote == 1 && _vote != rdShareholders[_indexNo][addr].vote)\r\n        rdInfos[_indexNo].shrVotesEnd += rdShareholders[_indexNo][addr].shareNum;\r\n      else if(_vote == 0 && _vote != rdShareholders[_indexNo][addr].vote)\r\n        rdInfos[_indexNo].shrVotesEnd -= rdShareholders[_indexNo][addr].shareNum;\r\n    }\r\n    else if(_vote == 1)\r\n        rdInfos[_indexNo].shrVotesEnd += rdShareholders[_indexNo][addr].shareNum;      \r\n    \r\n    rdShareholders[_indexNo][addr].vote = _vote;\r\n    rdShareholders[_indexNo][addr].lastShrVoteTime = nowTime;\r\n    rdInfos[_indexNo].lastShrVoteTime = nowTime;\r\n    emit event_shareholderVote(addr, _indexNo, _vote); \r\n\r\n    if((rdInfos[_indexNo].shrVotesEnd * 2) > rdInfos[_indexNo].shareNum)\r\n       endRound(_indexNo);      \r\n  }   \r\n \r\n  /** @dev get round's shareholder vote result\r\n    * @param _indexNo  round's index No \r\n    * @return _votesEnd  votes amount to end round\r\n    * @return _voteAll  all votes amount\r\n  */ \r\n  function getRdVotesCount(uint256 _indexNo)\r\n  public \r\n  view \r\n  returns(uint256 _votesEnd, uint256 _voteAll)\r\n  { \r\n    require(checkRdInVoteState(_indexNo));\r\n\r\n    uint256 nowTime = now;\r\n    uint256 shrVotesEnd = 0;    \r\n    uint256 timeStart = getRdLastCntDownStart(_indexNo, nowTime);\r\n    \r\n    if(timeStart > 0 && rdInfos[_indexNo].lastShrVoteTime > (timeStart + rdTicketTime))   \r\n      shrVotesEnd = rdInfos[_indexNo].shrVotesEnd;    \r\n          \r\n    return (shrVotesEnd, rdInfos[_indexNo].shareNum);\r\n  } \r\n\r\n  /**\r\n  * @dev end game round,then start new round\r\n  * @param _indexNo  round's index No  \r\n  */\r\n  function endRound(uint256 _indexNo)\r\n  internal \r\n  {   \r\n    rdInfos[_indexNo].state = rdStateEnd;\r\n\r\n    owner().transfer(serviceFeeCnt);   \r\n    serviceFeeCnt = 0; \r\n\r\n    emit event_endRound(_indexNo, rdInfos[_indexNo].lastTckBuyer, rdInfos[_indexNo].shrJackpot);\r\n\r\n    startNewRound();   \r\n  }  \r\n  \r\n  /** @dev get user from referer id\r\n    * @param _refCode  referer id \r\n    * @return _addr  user account\r\n  */\r\n  function getAddrOfRefCode(uint256 _refCode) \r\n  internal \r\n  view \r\n  returns(address _addr) \r\n  {  \r\n    if(userIDAddr[_refCode] != address(0))\r\n      return userIDAddr[_refCode];\r\n    return address(0);\r\n  } \r\n\r\n  /** @dev check user registered?  \r\n    * @param _addr  user account\r\n    * @return _result exist or not\r\n  */\r\n  function checkUserExist(address _addr)\r\n  internal \r\n  view \r\n  returns(bool _result) \r\n  {\r\n    if(userAccs[_addr].refCode != 0)\r\n      return true;\r\n    return false;\r\n  }\r\n  \r\n  /** @dev check round exist?  \r\n    * @param _indexNo  round's index no\r\n    * @return _result  exist or not\r\n  */\r\n  function checkRdExist(uint256 _indexNo) \r\n  internal \r\n  view \r\n  returns(bool _result) \r\n  {\r\n    if(rdInfos[_indexNo].state > 0)\r\n      return true;\r\n    return false;\r\n  }\r\n  \r\n  /** @dev check round is active?  \r\n    * @param _indexNo  round's index no\r\n    * @return _result  active or not\r\n  */\r\n  function checkRdActive(uint256 _indexNo) \r\n  internal \r\n  view \r\n  returns(bool _result) \r\n  {\r\n    require(checkRdExist(_indexNo));\r\n    \r\n    if(rdInfos[_indexNo].state == rdStateActive)\r\n        return true;\r\n    return false;\r\n  }\r\n \r\n  /** @dev check round is in vote state?  \r\n    * @param _indexNo  round's index no\r\n    * @return _result  in vote state or not\r\n  */\r\n  function checkRdInVoteState(uint256 _indexNo)\r\n  internal \r\n  view \r\n  returns(bool _result) \r\n  {\r\n    require(checkRdActive(_indexNo));\r\n\r\n    uint256 timeState = 0;\r\n  \r\n    (timeState,) = getRdTimeState(_indexNo);\r\n    if(timeState == 2)\r\n        return true;\r\n\r\n    return false;\r\n  }\r\n  \r\n  /** @dev check user is shareholder in a round?  \r\n    * @param _indexNo  round's index no\r\n    * @param _addr  shareholder account\r\n    * @return _result  is shareholder or not\r\n  */\r\n  function checkShareholderInRd(uint256 _indexNo, address _addr) \r\n  public \r\n  view \r\n  returns(bool _result) \r\n  {\r\n    require(checkRdExist(_indexNo));\r\n\r\n    if(rdShareholders[_indexNo][_addr].shareNum > 0)\r\n      return true;\r\n    return false;\r\n  }\r\n\r\n  /** @dev check user is ticket buyer in a round?  \r\n    * @param _indexNo  round's index no\r\n    * @param _addr  ticket buyer account\r\n    * @return _result  is ticket buyer or not\r\n  */\r\n  function checkTicketBuyerInRd(uint256 _indexNo, address _addr) \r\n  public \r\n  view \r\n  returns(bool _result) \r\n  {\r\n    require(checkRdExist(_indexNo));\r\n\r\n    if(rdTckBuyers[_indexNo][_addr].ticketNum > 0)\r\n      return true;\r\n    return false;\r\n  }\r\n  \r\n  /** @dev check user in a round and didn't withdraw yet?  \r\n    * @param _indexNo  round's index no\r\n    * @param _addr  user account\r\n    * @return _result  in or not\r\n  */\r\n  function checkUserInUnWithdrawRd(uint256 _indexNo, address _addr) \r\n  internal \r\n  view \r\n  returns(bool _result) \r\n  {\r\n    require(checkUserExist(_addr));\r\n    require(checkRdExist(_indexNo));\r\n    \r\n    for(uint256 i = 0; i < userUnWithdrawRound[_addr].length; i++)\r\n    {\r\n      if(userUnWithdrawRound[_addr][i] == _indexNo)\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** @dev get shareholder's vote  \r\n    * @param _indexNo  round's index no\r\n    * @param _addr  shareholder account\r\n    * @param _nowTime  current time\r\n    * @return _result  shareholder's vote \r\n  */\r\n  function getRdshareholderVoteVal(uint256 _indexNo, address _addr, uint256 _nowTime) \r\n  internal \r\n  view \r\n  returns(uint256 _result) \r\n  {\r\n    uint256 timeStart = getRdLastCntDownStart(_indexNo, _nowTime);\r\n    if(rdShareholders[_indexNo][_addr].vote == 1 && rdShareholders[_indexNo][_addr].lastShrVoteTime > (timeStart + rdTicketTime))                  \r\n      return 1;\r\n\r\n    return 0;\r\n  }\r\n\r\n  /** @dev calculate service fee\r\n    * @param _cost  buyer's cost   \r\n  */\r\n  function calcServiceFee(uint256 _cost) \r\n  internal\r\n  {    \r\n    serviceFeeCnt += (_cost * serviceFee) / 100;\r\n    if(serviceFeeCnt >= 1 ether)\r\n    { \r\n      owner().transfer(serviceFeeCnt);   \r\n      serviceFeeCnt = 0; \r\n    }  \r\n  }  \r\n  \r\n\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) \r\n  internal \r\n  pure \r\n  returns(uint256) \r\n  {\r\n    if(a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) \r\n  internal \r\n  pure \r\n  returns(uint256) \r\n  {    \r\n    uint256 c = a / b;    \r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) \r\n  internal \r\n  pure \r\n  returns(uint256) \r\n  {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) \r\n  internal \r\n  pure \r\n  returns(uint256) \r\n  {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getRoundActive\",\"outputs\":[{\"name\":\"_rdIndexNo\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"name\":\"_frefCode\",\"type\":\"uint256\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getRdPlayerInfo\",\"outputs\":[{\"name\":\"_rdPly1\",\"type\":\"uint256[]\"},{\"name\":\"_rdPly2\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkTicketBuyerInRd\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"}],\"name\":\"getRdInfo\",\"outputs\":[{\"name\":\"_rdIn\",\"type\":\"uint256[]\"},{\"name\":\"_addrs\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkShareholderInRd\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"}],\"name\":\"getRdTimeState\",\"outputs\":[{\"name\":\"_timeState\",\"type\":\"uint256\"},{\"name\":\"_timeLeft\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"name\":\"_frefCode\",\"type\":\"uint256\"}],\"name\":\"buyShare\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_frefCode\",\"type\":\"uint256\"}],\"name\":\"userRegister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserCount\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"name\":\"_vote\",\"type\":\"uint256\"}],\"name\":\"shareholderVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_indexNo\",\"type\":\"uint256\"}],\"name\":\"getRdVotesCount\",\"outputs\":[{\"name\":\"_votesEnd\",\"type\":\"uint256\"},{\"name\":\"_voteAll\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"event_buyShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"event_buyTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_vote\",\"type\":\"uint256\"}],\"name\":\"event_shareholderVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_indexNo\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_prize\",\"type\":\"uint256\"}],\"name\":\"event_endRound\",\"type\":\"event\"}]","ContractName":"DemocraticLuck","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://69fac79199c8dce0db40be1f4494a0c126f7d561b3f0f0ceaf02e213e05bb5c3"}]}