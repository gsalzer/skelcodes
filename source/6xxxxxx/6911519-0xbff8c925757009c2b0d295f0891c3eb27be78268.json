{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract MajorityGameFactory {\r\n\r\n    address[] private deployedGames;\r\n    address[] private endedGames;\r\n\r\n    address private adminAddress;\r\n\r\n    mapping(address => uint) private gameAddressIdMap;\r\n\r\n    uint private gameCount = 320;\r\n    uint private endedGameCount = 0;\r\n\r\n    modifier adminOnly() {\r\n        require(msg.sender == adminAddress);\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n        adminAddress = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * create new game\r\n     **/\r\n    function createGame (uint _gameBet, uint _endTime, string _questionText, address _officialAddress) public adminOnly payable {\r\n        gameCount ++;\r\n        address newGameAddress = new MajorityGame(gameCount, _gameBet, _endTime, _questionText, _officialAddress);\r\n        deployedGames.push(newGameAddress);\r\n        gameAddressIdMap[newGameAddress] = deployedGames.length;\r\n\r\n        setJackpot(newGameAddress, msg.value);\r\n    }\r\n\r\n    /**\r\n     * return all available games address\r\n     **/\r\n    function getDeployedGames() public view returns (address[]) {\r\n        return deployedGames;\r\n    }\r\n\r\n    /**\r\n     * return all available games address\r\n     **/\r\n    function getEndedGames() public view returns (address[]) {\r\n        return endedGames;\r\n    }\r\n\r\n    /**\r\n     * set bonus of the game\r\n     **/\r\n    function setJackpot(address targetAddress, uint val) adminOnly public {\r\n        if (val > 0) {\r\n            MajorityGame mGame = MajorityGame(targetAddress);\r\n            mGame.setJackpot.value(val)();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * player submit choose\r\n     **/\r\n    function submitChoose(address gameAddress, uint choose) public payable {\r\n        if (msg.value > 0) {\r\n            MajorityGame mGame = MajorityGame(gameAddress);\r\n            mGame.submitChooseByFactory.value(msg.value)(msg.sender, choose);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * end the game\r\n     **/\r\n    function endGame(address targetAddress) public {\r\n        uint targetGameIndex = gameAddressIdMap[address(targetAddress)];\r\n        endedGameCount++;\r\n        endedGames.push(targetAddress);\r\n        deployedGames[targetGameIndex-1] = deployedGames[deployedGames.length-1];\r\n\r\n        gameAddressIdMap[deployedGames[deployedGames.length-1]] = targetGameIndex;\r\n\r\n        delete deployedGames[deployedGames.length-1];\r\n        deployedGames.length--;\r\n\r\n        MajorityGame mGame = MajorityGame(address(targetAddress));\r\n        mGame.endGame();\r\n    }\r\n\r\n    /**\r\n     * force to end the game\r\n     **/\r\n    function forceEndGame(address targetAddress) public adminOnly {\r\n        uint targetGameIndex = gameAddressIdMap[address(targetAddress)];\r\n        endedGameCount++;\r\n        endedGames.push(targetAddress);\r\n        deployedGames[targetGameIndex-1] = deployedGames[deployedGames.length-1];\r\n\r\n        gameAddressIdMap[deployedGames[deployedGames.length-1]] = targetGameIndex;\r\n\r\n        delete deployedGames[deployedGames.length-1];\r\n        deployedGames.length--;\r\n\r\n        MajorityGame mGame = MajorityGame(address(targetAddress));\r\n        mGame.forceEndGame();\r\n    }\r\n    \r\n    /**\r\n     * selfdestruct\r\n     */\r\n    function destruct() public adminOnly{\r\n        selfdestruct(adminAddress);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * destruct a game\r\n     */\r\n    function destructGame(address targetAddress) public adminOnly{\r\n        MajorityGame mGame = MajorityGame(address(targetAddress));\r\n        mGame.destruct();\r\n    }\r\n}\r\n\r\n\r\ncontract MajorityGame {\r\n\r\n    uint private gameId;\r\n\r\n    uint private jackpot;\r\n    uint private gameBet;\r\n\r\n    // address of the creator\r\n    address private adminAddress;\r\n    address private officialAddress;\r\n\r\n    // game start time\r\n    uint private startTime;\r\n    uint private endTime;\r\n\r\n    // game data\r\n    string private questionText;\r\n\r\n    // store all player option record\r\n    mapping(address => bool) private option1List;\r\n    mapping(address => bool) private option2List;\r\n\r\n    // address list\r\n    address[] private option1AddressList;\r\n    address[] private option2AddressList;\r\n\r\n\t// award\r\n    uint private awardCounter;\r\n\r\n    address[] private first6AddresstList;\r\n    address private lastAddress;\r\n\r\n    uint private winnerSide;\r\n    uint private finalBalance;\r\n    uint private award;\r\n\r\n    modifier adminOnly() {\r\n        require(msg.sender == adminAddress);\r\n        _;\r\n    }\r\n\r\n    modifier withinGameTime() {\r\n\t\t    require(now >= startTime);\r\n        require(now <= endTime);\r\n        _;\r\n    }\r\n\r\n    modifier afterGameTime() {\r\n        require(now > endTime);\r\n        _;\r\n    }\r\n\r\n    modifier notEnded() {\r\n        require(winnerSide == 0);\r\n        _;\r\n    }\r\n\r\n    modifier isEnded() {\r\n        require(winnerSide > 0);\r\n        _;\r\n    }\r\n\r\n    modifier withinLimitPlayer() {\r\n        require((option1AddressList.length + option2AddressList.length) < 500);\r\n        _;\r\n    }\r\n\r\n    constructor(uint _gameId, uint _gameBet, uint _endTime, string _questionText, address _officialAddress) public {\r\n        gameId = _gameId;\r\n        adminAddress = msg.sender;\r\n\r\n        gameBet = _gameBet;\r\n        startTime = _endTime - 25*60*60;\r\n        endTime = _endTime;\r\n        questionText = _questionText;\r\n\r\n        winnerSide = 0;\r\n        award = 0;\r\n\r\n        officialAddress = _officialAddress;\r\n    }\r\n\r\n    /**\r\n     * set the bonus of the game\r\n     **/\r\n    function setJackpot() public payable adminOnly returns (bool) {\r\n        if (msg.value > 0) {\r\n            jackpot += msg.value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * return the game details:\r\n     * 0 game id\r\n     * 1 start time\r\n     * 2 end time\r\n     * 3 no of player\r\n     * 4 game balance\r\n     * 5 question + option 1 + option 2\r\n     * 6 jackpot\r\n     * 7 is ended game\r\n     * 8 game bet value\r\n     **/\r\n    function getGameData() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) {\r\n\r\n        return (\r\n            gameId,\r\n            startTime,\r\n            endTime,\r\n            option1AddressList.length + option2AddressList.length,\r\n            address(this).balance,\r\n            questionText,\r\n            jackpot,\r\n            winnerSide,\r\n            gameBet\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * player submit their option\r\n     **/\r\n    function submitChooseByFactory(address playerAddress, uint _chooseValue) public payable adminOnly notEnded withinGameTime {\r\n        require(!option1List[playerAddress] && !option2List[playerAddress]);\r\n        require(msg.value == gameBet);\r\n\r\n        if (_chooseValue == 1) {\r\n            option1List[playerAddress] = true;\r\n            option1AddressList.push(playerAddress);\r\n        } else if (_chooseValue == 2) {\r\n            option2List[playerAddress] = true;\r\n            option2AddressList.push(playerAddress);\r\n        }\r\n\r\n        // add to first 6 player\r\n        if(option1AddressList.length + option2AddressList.length <= 6){\r\n            first6AddresstList.push(playerAddress);\r\n        }\r\n\r\n        // add to last player\r\n        lastAddress = playerAddress;\r\n    }\r\n\r\n\r\n    /**\r\n     * calculate the winner side\r\n     * calculate the award to winner\r\n     **/\r\n    function endGame() public afterGameTime {\r\n        require(winnerSide == 0);\r\n\r\n        finalBalance = address(this).balance;\r\n\r\n        // 10% for commision\r\n        uint totalAward = finalBalance * 9 / 10;\r\n\r\n        uint option1Count = uint(option1AddressList.length);\r\n        uint option2Count = uint(option2AddressList.length);\r\n\r\n        uint sumCount = option1Count + option2Count;\r\n\r\n        if(sumCount == 0 ){\r\n            award = 0;\r\n            awardCounter = 0;\r\n            if(gameId % 2 == 1){\r\n                winnerSide = 1;\r\n            }else{\r\n                winnerSide = 2;\r\n            }\r\n            return;\r\n        }else{\r\n            if (option1Count != 0 && sumCount / option1Count > 10) {\r\n\t\t\t\twinnerSide = 1;\r\n\t\t\t} else if (option2Count != 0 && sumCount / option2Count > 10) {\r\n\t\t\t\twinnerSide = 2;\r\n\t\t\t} else if (option1Count > option2Count || (option1Count == option2Count && gameId % 2 == 1)) {\r\n\t\t\t\twinnerSide = 1;\r\n\t\t\t} else {\r\n\t\t\t\twinnerSide = 2;\r\n\t\t\t}\r\n        }\r\n\r\n        if (winnerSide == 1) {\r\n            award = uint(totalAward / option1Count);\r\n            awardCounter = option1Count;\r\n        } else {\r\n            award = uint(totalAward / option2Count);\r\n            awardCounter = option2Count;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * calculate the winner side\r\n     * calculate the award to winner\r\n     **/\r\n    function forceEndGame() public adminOnly {\r\n        require(winnerSide == 0);\r\n\r\n        finalBalance = address(this).balance;\r\n\r\n        // 10% for commision\r\n        uint totalAward = finalBalance * 9 / 10;\r\n\r\n        uint option1Count = uint(option1AddressList.length);\r\n        uint option2Count = uint(option2AddressList.length);\r\n\r\n        uint sumCount = option1Count + option2Count;\r\n\r\n        if(sumCount == 0 ){\r\n            award = 0;\r\n            awardCounter = 0;\r\n            if(gameId % 2 == 1){\r\n                winnerSide = 1;\r\n            }else{\r\n                winnerSide = 2;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (option1Count != 0 && sumCount / option1Count > 10) {\r\n            winnerSide = 1;\r\n        } else if (option2Count != 0 && sumCount / option2Count > 10) {\r\n            winnerSide = 2;\r\n        } else if (option1Count > option2Count || (option1Count == option2Count && gameId % 2 == 1)) {\r\n            winnerSide = 1;\r\n        } else {\r\n            winnerSide = 2;\r\n        }\r\n\r\n        if (winnerSide == 1) {\r\n            award = uint(totalAward / option1Count);\r\n            awardCounter = option1Count;\r\n        } else {\r\n            award = uint(totalAward / option2Count);\r\n            awardCounter = option2Count;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * send award to winner\r\n     **/\r\n    function sendAward() public isEnded {\r\n        require(awardCounter > 0);\r\n\r\n        uint count = awardCounter;\r\n\r\n        if (awardCounter > 400) {\r\n            for (uint i = 0; i < 400; i++) {\r\n                this.sendAwardToLastOne();\r\n            }\r\n        } else {\r\n            for (uint j = 0; j < count; j++) {\r\n                this.sendAwardToLastOne();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * send award to last winner of the list\r\n     **/\r\n    function sendAwardToLastOne() public isEnded {\r\n\t\trequire(awardCounter > 0);\r\n        if(winnerSide == 1){\r\n            address(option1AddressList[awardCounter - 1]).transfer(award);\r\n        }else{\r\n            address(option2AddressList[awardCounter - 1]).transfer(award);\r\n        }\r\n\r\n        awardCounter--;\r\n\r\n        if(awardCounter == 0){\r\n            if(option1AddressList.length + option2AddressList.length >= 7){\r\n                // send 0.5% of total bet to each first player\r\n                uint awardFirst6 = uint(finalBalance / 200);\r\n                for (uint k = 0; k < 6; k++) {\r\n                    address(first6AddresstList[k]).transfer(awardFirst6);\r\n                }\r\n                // send 2% of total bet to last player\r\n                address(lastAddress).transfer(uint(finalBalance / 50));\r\n            }\r\n\r\n            // send the rest of balance to officialAddress\r\n            address(officialAddress).transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return the game details after ended\r\n     * 0 winner side\r\n     * 1 nomber of player who choose option 1\r\n     * 2 nomber of player who choose option 2\r\n     * 3 total award\r\n     * 4 award of each winner\r\n     **/\r\n    function getEndGameStatus() public isEnded view returns (uint, uint, uint, uint, uint) {\r\n        return (\r\n            winnerSide,\r\n            option1AddressList.length,\r\n            option2AddressList.length,\r\n            finalBalance,\r\n            award\r\n        );\r\n    }\r\n\r\n    /**\r\n    * get the option of the player choosed\r\n    **/\r\n    function getPlayerOption() public view returns (uint) {\r\n        if (option1List[msg.sender]) {\r\n            return 1;\r\n        } else if (option2List[msg.sender]) {\r\n            return 2;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return the players who won the game\r\n     **/\r\n    function getWinnerAddressList() public isEnded view returns (address[]) {\r\n      if (winnerSide == 1) {\r\n        return option1AddressList;\r\n      }else {\r\n        return option2AddressList;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * return the players who lose the game\r\n     **/\r\n    function getLoserAddressList() public isEnded view returns (address[]) {\r\n      if (winnerSide == 1) {\r\n        return option2AddressList;\r\n      }else {\r\n        return option1AddressList;\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * selfdestruct\r\n     */\r\n    function destruct() public adminOnly{\r\n        selfdestruct(adminAddress);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_gameBet\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_questionText\",\"type\":\"string\"},{\"name\":\"_officialAddress\",\"type\":\"address\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"endGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"},{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"forceEndGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"destructGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameAddress\",\"type\":\"address\"},{\"name\":\"choose\",\"type\":\"uint256\"}],\"name\":\"submitChoose\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEndedGames\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeployedGames\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MajorityGameFactory","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f0ca5da4381e8b97a4df29637774e27cd7aadab181c5fb4999d43a270e86db2a"}]}