{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public{\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, 'Only the owner can call this method');\r\n    _;\r\n  }\r\n\r\n}\r\n\r\ncontract EtheroStabilizationFund{\r\n    /**\r\n     * In the event of the shortage of funds for the level payments\r\n     * stabilization the contract of the stabilization fund provides backup support to the investment fund.\r\n     * ethero contract address = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;\r\n     */\r\n    \r\n    address public  ethero = 0x0223f73a53a549B8F5a9661aDB4cD9Dd4E25BEDa;\r\n    uint public investFund;\r\n    uint estGas = 100000;\r\n    event MoneyWithdraw(uint balance);\r\n    event MoneyAdd(uint holding);\r\n    \r\n     /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyHero() {\r\n         require(msg.sender == ethero, 'Only Hero call');\r\n         _;\r\n    }\r\n    \r\n    function ReturnEthToEthero()public onlyHero returns(bool){\r\n        \r\n        uint balance = address(this).balance;\r\n        \r\n        require(balance > estGas, 'Not enough funds for transaction');\r\n        \r\n        if(ethero.call.value(address(this).balance).gas(estGas)()){\r\n            emit MoneyWithdraw(balance);\r\n            investFund = address(this).balance;\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n        \r\n    }\r\n     \r\n    function() external payable{\r\n        \r\n        investFund+=msg.value;\r\n        emit MoneyAdd(msg.value);\r\n    }\r\n    \r\n    \r\n}\r\n\r\ncontract EtHero is Ownable{\r\n\r\n   using SafeMath for uint;\r\n    // array containing information about beneficiaries\r\n    mapping (address => uint) public balances;\r\n    //array containing information about the time of payment\r\n    mapping (address => uint) private time;\r\n    \r\n    //purse addresses for payments\r\n    //when call the method LevelUpDeposit, money is transferred to the first two purses\r\n    // fund1 and fund2\r\n    address public  fund1 = 0xf846f84841b3242Ccdeac8c43C9cF73Bd781baA7;\r\n    address public  fund2 = 0xa7A20b9f36CD88fC2c776C9BB23FcEA34ba80ef7;\r\n    address public stabFund;\r\n    uint estGas = 100000;\r\n    \r\n    uint standartPersent = 30; // 30/1000*100 = 3%\r\n    uint  minPercent = 5; // 5/1000*100 = 0.5%\r\n    uint public minPayment = 5 finney; //0.05 ether \r\n    \r\n    //the time through which dividends will be paid\r\n    uint dividendsTime = 1 days;\r\n    \r\n    event NewInvestor(address indexed investor, uint deposit);\r\n    event PayOffDividends(address indexed investor, uint value);\r\n    event NewDeposit(address indexed investor, uint value);\r\n    event ResiveFromStubFund(uint value);\r\n    \r\n    uint public allDeposits;\r\n    uint public allPercents;\r\n    uint public allBeneficiaries;\r\n    uint public lastPayment;\r\n    \r\n    struct Beneficiaries{\r\n      address investorAddress;\r\n      uint registerTime;\r\n      uint persentWithdraw;\r\n      uint ethWithdraw;\r\n      uint deposits;\r\n      bool real;\r\n      \r\n  }\r\n  \r\n  mapping(address => Beneficiaries) beneficiaries;\r\n  \r\n  \r\n  function setStubFund(address _address)onlyOwner public{\r\n      require(_address>0, 'Incorrect address');\r\n      stabFund = _address;\r\n      \r\n      \r\n  }\r\n  \r\n  \r\n  function insertBeneficiaries(address _address, uint _persentWithdraw, uint _ethWithdraw, uint _deposits)private{\r\n      \r\n      Beneficiaries storage s_beneficiaries = beneficiaries[_address];\r\n      \r\n      if (!s_beneficiaries.real){\r\n          \r\n          s_beneficiaries.real = true;\r\n          s_beneficiaries.investorAddress = _address;\r\n          s_beneficiaries.persentWithdraw = _persentWithdraw;\r\n          s_beneficiaries.ethWithdraw = _ethWithdraw;\r\n          s_beneficiaries.deposits = _deposits;\r\n          s_beneficiaries.registerTime = now;\r\n          \r\n          allBeneficiaries+=1;\r\n      }else{\r\n          s_beneficiaries.persentWithdraw += _persentWithdraw;\r\n          s_beneficiaries.ethWithdraw += _ethWithdraw;\r\n      }\r\n  } \r\n  \r\n  function getBeneficiaries(address _address)public view returns(\r\n      address investorAddress,\r\n      uint persentWithdraw,\r\n      uint ethWithdraw,\r\n      uint registerTime \r\n      ){\r\n      \r\n      Beneficiaries storage s_beneficiaries = beneficiaries[_address];\r\n      \r\n      require(s_beneficiaries.real, '404: Investor Not Found :(');\r\n      \r\n      \r\n      return(\r\n          s_beneficiaries.investorAddress,\r\n          s_beneficiaries.persentWithdraw,\r\n          s_beneficiaries.ethWithdraw,\r\n          s_beneficiaries.registerTime\r\n          );\r\n  } \r\n    \r\n    \r\n    \r\n    modifier isIssetRecepient(){\r\n        require(balances[msg.sender] > 0, \"Deposit not found\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * modifier checking the next payout time\r\n     */\r\n    modifier timeCheck(){\r\n        \r\n         require(now >= time[msg.sender].add(dividendsTime), \"Too fast payout request\");\r\n         _;\r\n        \r\n    }\r\n    \r\n   \r\n    function receivePayment()isIssetRecepient timeCheck internal{\r\n        uint percent = getPercent();\r\n        uint rate = balances[msg.sender].mul(percent).div(1000);\r\n        time[msg.sender] = now;\r\n        msg.sender.transfer(rate);\r\n        \r\n        allPercents+=rate;\r\n        lastPayment =now;\r\n        \r\n        insertBeneficiaries(msg.sender, percent, rate,0);\r\n        emit PayOffDividends(msg.sender, rate);\r\n        \r\n    }\r\n    \r\n    \r\n    function authorizationPayment()public view returns(bool){\r\n        \r\n        if (balances[msg.sender] > 0 && now >= (time[msg.sender].add(dividendsTime))){\r\n            return (true);\r\n        }else{\r\n            return(false);\r\n        }\r\n        \r\n    }\r\n   \r\n    \r\n    function getPercent()internal  returns(uint){\r\n        \r\n        \r\n        uint value = balances[msg.sender].mul(standartPersent).div(1000);\r\n        uint min_value = balances[msg.sender].mul(minPercent).div(1000);\r\n        \r\n        \r\n        \r\n        if(address(this).balance < min_value){\r\n            // Return money from stab. fund\r\n            EtheroStabilizationFund stubF = EtheroStabilizationFund(stabFund);\r\n            require(stubF.ReturnEthToEthero(), 'Forgive, the stabilization fund can not cover your deposit, try to withdraw your interest later ');\r\n            emit ResiveFromStubFund(25);\r\n        }\r\n        \r\n        \r\n        \r\n        uint contractBalance = address(this).balance;\r\n        \r\n        require(contractBalance > min_value, 'Out of money, wait a few days, we will attract new investments');\r\n       \r\n        if(contractBalance > (value.mul(standartPersent).div(1000))){\r\n            return(30);\r\n        }\r\n        if(contractBalance > (value.mul(standartPersent.sub(5)).div(1000))){\r\n            return(25);\r\n        }\r\n        if(contractBalance > (value.mul(standartPersent.sub(10)).div(1000))){\r\n            return(20);\r\n        }\r\n        if(contractBalance > (value.mul(standartPersent.sub(15)).div(1000))){\r\n            return(15);\r\n        }\r\n        if(contractBalance > (value.mul(standartPersent.sub(20)).div(1000))){\r\n            return(10);\r\n        }\r\n         if(contractBalance > (value.mul(standartPersent.sub(25)).div(1000))){\r\n            return(5);\r\n        }\r\n        \r\n        \r\n        \r\n    }\r\n    \r\n    function createDeposit() private{\r\n        \r\n        uint value = msg.value;\r\n        uint rateFund1 = value.mul(5).div(100);\r\n        uint rateFund2 = value.mul(5).div(100);\r\n        uint rateStubFund = value.mul(10).div(100);\r\n        \r\n        if(msg.value > 0){\r\n            \r\n            if (balances[msg.sender] == 0){\r\n                emit NewInvestor(msg.sender, msg.value);\r\n            }\r\n            \r\n            balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n            time[msg.sender] = now;\r\n            insertBeneficiaries(msg.sender,0,0, msg.value);\r\n            \r\n            fund1.transfer(rateFund1);\r\n            fund2.transfer(rateFund2);\r\n            stabFund.call.value(rateStubFund).gas(estGas)();\r\n            \r\n            allDeposits+=msg.value;\r\n            \r\n            emit NewDeposit(msg.sender, msg.value);\r\n            \r\n        }else{\r\n            \r\n            receivePayment();\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    function() external payable{\r\n        \r\n        //buffer overflow protection\r\n        require((balances[msg.sender].add(msg.value)) >= balances[msg.sender]);\r\n        if(msg.sender!=stabFund){\r\n            createDeposit();\r\n        }else{\r\n            emit ResiveFromStubFund(msg.value);\r\n        }        \r\n        \r\n       \r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBeneficiaries\",\"outputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"persentWithdraw\",\"type\":\"uint256\"},{\"name\":\"ethWithdraw\",\"type\":\"uint256\"},{\"name\":\"registerTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allPercents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stabFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorizationPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allBeneficiaries\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fund1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fund2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setStubFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"NewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PayOffDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ResiveFromStubFund\",\"type\":\"event\"}]","ContractName":"EtHero","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b185d681777b355eb15ea3f8a31ee5fa4b157ef618d6c3917373f23c3c100e94"}]}