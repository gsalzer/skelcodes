{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n/* import \"github.com/oraclize/ethereum-api/oraclizeAPI.sol\"; */\r\n\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) public returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() public returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofType_Android = 0x20;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\r\n            oraclize_setNetwork(networkID_auto);\r\n\r\n        if(address(oraclize) != OAR.getAddress())\r\n            oraclize = OraclizeI(OAR.getAddress());\r\n\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n      return oraclize_setNetwork();\r\n      networkID; // silence the warning and remain backwards compatible\r\n    }\r\n    function oraclize_setNetwork() internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result) public {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) public {\r\n      return;\r\n      myid; result; proof; // Silence compiler warnings\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\r\n        return oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function parseAddr(string _a) internal pure returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string _a, string _b) internal pure returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal pure returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\r\n            uint arrlen = arr.length;\r\n\r\n            // get correct cbor output length\r\n            uint outputlen = 0;\r\n            bytes[] memory elemArray = new bytes[](arrlen);\r\n            for (uint i = 0; i < arrlen; i++) {\r\n                elemArray[i] = (bytes(arr[i]));\r\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n            }\r\n            uint ctr = 0;\r\n            uint cborlen = arrlen + 0x80;\r\n            outputlen += byte(cborlen).length;\r\n            bytes memory res = new bytes(outputlen);\r\n\r\n            while (byte(cborlen).length > ctr) {\r\n                res[ctr] = byte(cborlen)[ctr];\r\n                ctr++;\r\n            }\r\n            for (i = 0; i < arrlen; i++) {\r\n                res[ctr] = 0x5F;\r\n                ctr++;\r\n                for (uint x = 0; x < elemArray[i].length; x++) {\r\n                    // if there's a bug with larger strings, this may be the culprit\r\n                    if (x % 23 == 0) {\r\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                        elemcborlen += 0x40;\r\n                        uint lctr = ctr;\r\n                        while (byte(elemcborlen).length > ctr - lctr) {\r\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                            ctr++;\r\n                        }\r\n                    }\r\n                    res[ctr] = elemArray[i][x];\r\n                    ctr++;\r\n                }\r\n                res[ctr] = 0xFF;\r\n                ctr++;\r\n            }\r\n            return res;\r\n        }\r\n\r\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\r\n            uint arrlen = arr.length;\r\n\r\n            // get correct cbor output length\r\n            uint outputlen = 0;\r\n            bytes[] memory elemArray = new bytes[](arrlen);\r\n            for (uint i = 0; i < arrlen; i++) {\r\n                elemArray[i] = (bytes(arr[i]));\r\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n            }\r\n            uint ctr = 0;\r\n            uint cborlen = arrlen + 0x80;\r\n            outputlen += byte(cborlen).length;\r\n            bytes memory res = new bytes(outputlen);\r\n\r\n            while (byte(cborlen).length > ctr) {\r\n                res[ctr] = byte(cborlen)[ctr];\r\n                ctr++;\r\n            }\r\n            for (i = 0; i < arrlen; i++) {\r\n                res[ctr] = 0x5F;\r\n                ctr++;\r\n                for (uint x = 0; x < elemArray[i].length; x++) {\r\n                    // if there's a bug with larger strings, this may be the culprit\r\n                    if (x % 23 == 0) {\r\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                        elemcborlen += 0x40;\r\n                        uint lctr = ctr;\r\n                        while (byte(elemcborlen).length > ctr - lctr) {\r\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                            ctr++;\r\n                        }\r\n                    }\r\n                    res[ctr] = elemArray[i][x];\r\n                    ctr++;\r\n                }\r\n                res[ctr] = 0xFF;\r\n                ctr++;\r\n            }\r\n            return res;\r\n        }\r\n\r\n\r\n    string oraclize_network_name;\r\n    function oraclize_setNetworkName(string _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n\r\n    function oraclize_getNetworkName() internal view returns (string) {\r\n        return oraclize_network_name;\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\r\n        require((_nbytes > 0) && (_nbytes <= 32));\r\n        // Convert from seconds to ledger timer ticks\r\n        _delay *= 10;\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(_nbytes);\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes memory delay = new bytes(32);\r\n        assembly {\r\n            mstore(add(delay, 0x20), _delay)\r\n        }\r\n\r\n        bytes memory delay_bytes8 = new bytes(8);\r\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\r\n\r\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\r\n\r\n        bytes memory delay_bytes8_left = new bytes(8);\r\n\r\n        assembly {\r\n            let x := mload(add(delay_bytes8, 0x20))\r\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n\r\n        }\r\n\r\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\r\n        return queryId;\r\n    }\r\n\r\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\r\n        oraclize_randomDS_args[queryId] = commitment;\r\n    }\r\n\r\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\r\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\r\n        bool sigok;\r\n        address signer;\r\n\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4+(uint(dersig[3]) - 0x20);\r\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\r\n\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n\r\n\r\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\r\n        if (address(keccak256(pubkey)) == signer) return true;\r\n        else {\r\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\r\n            return (address(keccak256(pubkey)) == signer);\r\n        }\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\r\n        bool sigok;\r\n\r\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\r\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\r\n\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\r\n\r\n        bytes memory tosign2 = new bytes(1+65+32);\r\n        tosign2[0] = byte(1); //role\r\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n\r\n        if (sigok == false) return false;\r\n\r\n\r\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n\r\n        bytes memory tosign3 = new bytes(1+65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(proof, 3, 65, tosign3, 1);\r\n\r\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\r\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\r\n\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n\r\n        return sigok;\r\n    }\r\n\r\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        require(proofVerified);\r\n\r\n        _;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (proofVerified == false) return 2;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\r\n        bool match_ = true;\r\n\r\n        require(prefix.length == n_random_bytes);\r\n\r\n        for (uint256 i=0; i< n_random_bytes; i++) {\r\n            if (content[i] != prefix[i]) match_ = false;\r\n        }\r\n\r\n        return match_;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\r\n\r\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\r\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\r\n\r\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\r\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\r\n\r\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\r\n\r\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\r\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\r\n\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\r\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\r\n\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\r\n            delete oraclize_randomDS_args[queryId];\r\n        } else return false;\r\n\r\n\r\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32+8+1+32);\r\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\r\n\r\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\r\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\r\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\r\n        }\r\n\r\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\r\n        uint minLength = length + toOffset;\r\n\r\n        // Buffer too small\r\n        require(to.length >= minLength); // Should be a better way?\r\n\r\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint i = 32 + fromOffset;\r\n        uint j = 32 + toOffset;\r\n\r\n        while (i < (32 + fromOffset + length)) {\r\n            assembly {\r\n                let tmp := mload(add(from, i))\r\n                mstore(add(to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly can't access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65)\r\n          return (false, 0);\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n\r\n            // Here we are loading the last 32 bytes. We exploit the fact that\r\n            // 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n\r\n            // Alternative solution:\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            // v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\r\n        // to match the YP range of [27, 28]\r\n        //\r\n        // geth uses [0, 1] and some clients have followed. This might change, see:\r\n        //  https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27)\r\n          v += 27;\r\n\r\n        if (v != 27 && v != 28)\r\n            return (false, 0);\r\n\r\n        return safer_ecrecover(hash, v, r, s);\r\n    }\r\n\r\n}\r\n\r\ncontract BetContract is usingOraclize{\r\n  uint  maxProfit;//最高奖池\r\n  uint  maxmoneypercent;\r\n  uint public contractBalance;\r\n  uint minBet;\r\n  uint onoff;//游戏启用或关闭\r\n  address private owner;\r\n  uint private orderId;\r\n  uint private randonce;\r\n\r\n  event LogNewOraclizeQuery(string description,bytes32 queryId);\r\n  event LogNewRandomNumber(string result,bytes32 queryId);\r\n  event LogSendBonus(uint id,bytes32 lableId,uint playId,uint content,uint singleMoney,uint mutilple,address user,uint betTime,uint status,uint winMoney);\r\n\r\n  mapping (address => bytes32[]) playerLableList;//玩家下注批次\r\n  mapping (bytes32 => mapping (uint => uint[7])) betList;//批次，注单映射\r\n  mapping (bytes32 => uint) lableCount;//批次，注单数\r\n  mapping (bytes32 => uint) lableTime;//批次，投注时间\r\n  mapping (bytes32 => uint) lableStatus;//批次，状态 0 未结算，1 已撤单，2 已结算 3 已派奖\r\n  mapping (bytes32 => uint[3]) openNumberList;//批次开奖号码映射\r\n  mapping (bytes32 => string) openNumberStr;//批次开奖号码映射\r\n  mapping (bytes32 => address) lableUser;\r\n\r\n  function BetContract() public {\r\n    owner = msg.sender;\r\n    orderId = 0;\r\n\r\n    onoff=1;\r\n    minBet=1500000000000000;//最小金额要比手续费大\r\n    maxmoneypercent=80;\r\n    contractBalance = this.balance;\r\n    maxProfit=(this.balance * maxmoneypercent)/100;\r\n    randonce = 0;\r\n  }\r\n\r\n  /*\r\n    * uintToString\r\n    */\r\n   function uintToString(uint i) internal  returns (string){\r\n       if (i == 0) return \"0\";\r\n       uint j = i;\r\n       uint len;\r\n       while (j != 0){\r\n           len++;\r\n           j /= 10;\r\n       }\r\n       bytes memory bstr = new bytes(len);\r\n       uint k = len - 1;\r\n       while (i != 0){\r\n           bstr[k--] = byte(48 + i % 10);\r\n           i /= 10;\r\n       }\r\n       return string(bstr);\r\n   }\r\n\r\n\r\n  modifier onlyAdmin() {\r\n      require(msg.sender == owner);\r\n      _;\r\n  }\r\n\r\n  function setGameOnoff(uint _on0ff) public onlyAdmin{\r\n    onoff=_on0ff;\r\n  }\r\n\r\n  function getPlayRate(uint playId,uint level) internal pure returns (uint){\r\n      uint result = 0;\r\n      if(playId == 1 || playId == 2){\r\n        //大小单双，赔率放大了10倍\r\n        result = 19;\r\n      }else if(playId == 3){\r\n        //二同号复选\r\n        result = 11;\r\n      }else if(playId == 4){\r\n        //三同号单选\r\n        result = 156;\r\n      }else if(playId == 5){\r\n        //三同号通选\r\n        result = 26;\r\n      }else if(playId == 6){\r\n        //和值\r\n        if(level == 4 || level == 17){\r\n          result = 53;\r\n        }else if(level == 5 || level == 16){\r\n          result = 21;\r\n        }else if(level == 6 || level == 15){\r\n          result = 17;\r\n        }else if(level == 7 || level == 14){\r\n          result = 13;\r\n        }else if(level == 8 || level == 13){\r\n          result = 9;\r\n        }else if(level == 9 || level == 12){\r\n          result = 8;\r\n        }else if(level == 10 || level == 11){\r\n          result = 7;\r\n        }\r\n      }else if(playId == 7){\r\n        //二不同号\r\n        result = 6;\r\n      }else if(playId == 8){\r\n        //猜1个号，赔率放大了10倍\r\n        if(level == 1){\r\n          result = 19;//单色子\r\n        }else if(level == 2){\r\n          result = 28;//对子\r\n        }else if(level == 3){\r\n          result = 37;//豹子\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    function doBet(uint[] playid,uint[] betMoney,uint[] betContent,uint mutiply) public payable returns (bytes32) {\r\n      require(onoff==1);\r\n      require(playid.length > 0);\r\n      require(mutiply > 0);\r\n      require(msg.value >= minBet);\r\n\r\n      /* checkBet(playid,betMoney,betContent,mutiply,msg.value); */\r\n\r\n      /* uint total = 0; */\r\n      bytes32 queryId;\r\n      queryId = keccak256(block.blockhash(block.number-1),now,randonce);\r\n\r\n       uint[7] tmp ;\r\n       uint totalspand = 0;\r\n      for(uint i=0;i<playid.length;i++){\r\n        orderId++;\r\n        tmp[0] =orderId;\r\n        tmp[1] =playid[i];\r\n        tmp[2] =betContent[i];\r\n        tmp[3] =betMoney[i]*mutiply;\r\n        totalspand +=betMoney[i]*mutiply;\r\n        tmp[4] =now;\r\n        tmp[5] =0;\r\n        tmp[6] =0;\r\n        betList[queryId][i] =tmp;\r\n      }\r\n      require(msg.value >= totalspand);\r\n\r\n      lableTime[queryId] = now;\r\n      lableCount[queryId] = playid.length;\r\n      lableUser[queryId] = msg.sender;\r\n      uint[3] memory codes = [uint(0),0,0];//开奖号码\r\n      openNumberList[queryId] = codes;\r\n      openNumberStr[queryId] =\"0,0,0\";\r\n      lableStatus[queryId] = 0;\r\n\r\n      uint index=playerLableList[msg.sender].length++;\r\n      playerLableList[msg.sender][index]=queryId;//index:id\r\n      opencode(queryId);\r\n      return queryId;\r\n    }\r\n\r\n    function checkBet(uint[] playid,uint[] betMoney,uint[] betContent,uint mutiply,uint betTotal) internal{\r\n        uint totalMoney = 0;\r\n      uint totalWin1 = 0;//三个开奖号码不同时的盈利\r\n      uint totalWin2 = 0;//两个开奖号码相同时的盈利\r\n      uint totalWin3 = 0;//三个号码相同时的盈利\r\n      uint rate;\r\n      uint i;\r\n      for(i=0;i<playid.length;i++){\r\n        if(playid[i] >=1 && playid[i]<= 8){\r\n          totalMoney += betMoney[i] * mutiply;\r\n        }else{\r\n          throw;\r\n        }\r\n        if(playid[i] ==1 || playid[i] ==2){\r\n          rate = getPlayRate(playid[i],0)-10;\r\n          totalWin1+=betMoney[i] * mutiply *rate/10;\r\n          totalWin2+=betMoney[i] * mutiply *rate/10;\r\n        }else if(playid[i] ==3){\r\n          rate = getPlayRate(playid[i],0)-1;\r\n          totalWin2+=betMoney[i] * mutiply *rate;\r\n          totalWin3+=betMoney[i] * mutiply *rate;\r\n        }else if(playid[i] ==4 || playid[i] ==5){\r\n          rate = getPlayRate(playid[i],0)-1;\r\n          totalWin3+=betMoney[i] * mutiply *rate;\r\n        }else if(playid[i] ==6){\r\n          rate = getPlayRate(playid[i],betContent[i])-1;\r\n          totalWin1+=betMoney[i] * mutiply *rate;\r\n          totalWin2+=betMoney[i] * mutiply *rate;\r\n        }else if(playid[i] ==7){\r\n          rate = getPlayRate(playid[i],0)-1;\r\n          totalWin1+=betMoney[i] * mutiply *rate;\r\n          totalWin2+=betMoney[i] * mutiply *rate;\r\n        }else if(playid[i] ==8){\r\n          totalWin1+=betMoney[i] * mutiply *9/10;\r\n          totalWin2+=betMoney[i] * mutiply *18/10;\r\n          totalWin3+=betMoney[i] * mutiply *27/10;\r\n        }\r\n      }\r\n      uint maxWin=totalWin1;\r\n      if(totalWin2 > maxWin){\r\n        maxWin=totalWin2;\r\n      }\r\n      if(totalWin3 > maxWin){\r\n        maxWin=totalWin3;\r\n      }\r\n      require(betTotal >= totalMoney);\r\n\r\n      require(maxWin < maxProfit);\r\n    }\r\n    \r\n    function opencode(bytes32 queryId) private {\r\n      if (lableCount[queryId] < 1) revert();\r\n      uint[3] memory codes = [uint(0),0,0];//开奖号码\r\n\r\n      bytes32 code0hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\r\n      randonce  = randonce + uint(code0hash)%10;\r\n      uint code0int = uint(code0hash) % 6 + 1;\r\n      bytes32 code1hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\r\n      randonce  = randonce + uint(code1hash)%10;\r\n      uint code1int = uint(code1hash) % 6 + 1;\r\n      bytes32 code2hash = keccak256(abi.encodePacked(block.blockhash(block.number-1), now,msg.sender,randonce));\r\n      randonce  = randonce + uint(code2hash)%10;\r\n      uint code2int = uint(code2hash) % 6 + 1;\r\n      var code0=uintToString(code0int);\r\n      var code1=uintToString(code1int);\r\n      var code2=uintToString(code2int);\r\n      codes[0] = code0int;\r\n      codes[1] = code1int;\r\n      codes[2] = code2int;\r\n      openNumberList[queryId] = codes;\r\n      openNumberStr[queryId] = strConcat(code0,\",\",code1,\",\",code2);\r\n\r\n      //结算，派奖\r\n      doCheckBounds(queryId);\r\n    }\r\n\r\n    function doCancel(bytes32 queryId) internal {\r\n      uint sta = lableStatus[queryId];\r\n      require(sta == 0);\r\n      uint[3] memory codes = openNumberList[queryId];\r\n      require(codes[0] == 0 || codes[1] == 0 ||codes[2] == 0);\r\n\r\n      uint totalBet = 0;\r\n      uint len = lableCount[queryId];\r\n\r\n      address to = lableUser[queryId];\r\n      for(uint aa = 0 ; aa<len; aa++){\r\n        //未结算\r\n        if(betList[queryId][aa][5] == 0){\r\n          totalBet+=betList[queryId][aa][3];\r\n        }\r\n      }\r\n\r\n      if(totalBet > 0){\r\n        to.transfer(totalBet);\r\n      }\r\n      contractBalance=this.balance;\r\n      maxProfit=(this.balance * maxmoneypercent)/100;\r\n      lableStatus[queryId] = 1;\r\n    }\r\n\r\n    function doSendBounds(bytes32 queryId) public payable {\r\n      uint sta = lableStatus[queryId];\r\n      require(sta == 2);\r\n\r\n      uint totalWin = 0;\r\n      uint len = lableCount[queryId];\r\n\r\n      address to = lableUser[queryId];\r\n      for(uint aa = 0 ; aa<len; aa++){\r\n        //中奖\r\n        if(betList[queryId][aa][5] == 2){\r\n          totalWin+=betList[queryId][aa][6];\r\n        }\r\n      }\r\n\r\n      if(totalWin > 0){\r\n          to.transfer(totalWin);//转账\r\n      }\r\n      lableStatus[queryId] = 3;\r\n      contractBalance=this.balance;\r\n      maxProfit=(this.balance * maxmoneypercent)/100;\r\n    }\r\n\r\n    //中奖判断\r\n    function checkWinMoney(uint[7] storage betinfo,uint[3] codes) internal {\r\n      uint rates;\r\n      if(betinfo[1] ==1){\r\n          //大小 豹子不中奖\r\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\r\n            betinfo[5]=1;//未中奖\r\n          }else{\r\n            uint sum = codes[0]+codes[1]+codes[2];\r\n            if(sum >= 4 && sum < 11){\r\n              sum = 4;//小\r\n            }else if(sum >= 11 && sum < 18){\r\n              sum = 17;//大\r\n            }else{\r\n              sum = 0;\r\n            }\r\n            betinfo[5]=1;\r\n            if(sum >0 && betinfo[2] == sum){\r\n                betinfo[5]=2;\r\n                rates = getPlayRate(betinfo[1],0);\r\n                betinfo[6]=betinfo[3]*rates/10;\r\n            }\r\n\r\n          }\r\n      }else if(betinfo[1] == 2){\r\n          //单双 豹子不中奖\r\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\r\n            betinfo[5]=1;//未中奖\r\n          }else{\r\n            uint sums = codes[0]+codes[1]+codes[2];\r\n            if(sums % 2 == 0){\r\n              sums = 2;//双\r\n            }else{\r\n              sums = 3;//单\r\n            }\r\n            betinfo[5]=1;\r\n            if(sums == betinfo[2]){\r\n              betinfo[5]=2;\r\n              rates = getPlayRate(betinfo[1],0);\r\n              betinfo[6]=betinfo[3]*rates/10;\r\n            }\r\n\r\n          }\r\n\r\n        }else if(betinfo[1] == 3){\r\n          //二同号复选\r\n          betinfo[5]=1;//不中奖\r\n          if(codes[0] == codes[1] || codes[1] == codes[2] ){\r\n            uint tmp = 0;\r\n            if(codes[0] == codes[1] ){\r\n              tmp = codes[0];\r\n            }else if(codes[1] == codes[2]){\r\n              tmp = codes[1];\r\n            }\r\n            if(tmp == betinfo[2]){\r\n              betinfo[5]=2;\r\n              rates = getPlayRate(betinfo[1],0);\r\n              betinfo[6]=betinfo[3]*rates;\r\n            }\r\n\r\n          }\r\n        }else if(betinfo[1] == 4){\r\n          //三同号单选\r\n          betinfo[5]=1;//不中奖\r\n          if(codes[0] == codes[1] && codes[1] == codes[2] ){\r\n            if(codes[0] == betinfo[2]){\r\n              betinfo[5]=2;\r\n              rates = getPlayRate(betinfo[1],0);\r\n              betinfo[6]=betinfo[3]*rates;\r\n            }\r\n          }\r\n        }else if(betinfo[1] == 5){\r\n          //三同号通选\r\n          betinfo[5]=1;//不中奖\r\n          if(codes[0] == codes[1] && codes[1] == codes[2] ){\r\n              betinfo[5]=2;\r\n              rates = getPlayRate(betinfo[1],0);\r\n              betinfo[6]=betinfo[3]*rates;\r\n          }\r\n        }else if(betinfo[1] == 6){\r\n          //和值 豹子不中奖\r\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\r\n            betinfo[5]=1;//不中奖\r\n          }else{\r\n            betinfo[5]=1;//不中奖\r\n            uint sum6 = codes[0]+codes[1]+codes[2];\r\n            if(sum6 == betinfo[2]){\r\n              betinfo[5]=2;\r\n              rates = getPlayRate(betinfo[1],sum6);\r\n              betinfo[6]=betinfo[3]*rates;\r\n            }\r\n          }\r\n        }else if(betinfo[1] == 7){\r\n          //二不同号 豹子不中奖\r\n          if(codes[0] == codes[1] && codes[1] == codes[2]){\r\n            betinfo[5]=1;//不中奖\r\n          }else{\r\n            uint[2] memory haoma = getErbutongHao(betinfo[2]);\r\n            bool atmp=false;\r\n            bool btmp=false;\r\n            for(uint ai=0;ai<codes.length;ai++){\r\n              if(codes[ai] == haoma[0]){\r\n                atmp = true;\r\n                continue;\r\n              }\r\n              if(codes[ai] == haoma[1]){\r\n                btmp = true;\r\n                continue;\r\n              }\r\n            }\r\n            betinfo[5]=1;\r\n            if(atmp && btmp){\r\n              betinfo[5]=2;\r\n              rates = getPlayRate(betinfo[1],0);\r\n              betinfo[6]=betinfo[3]*rates;\r\n            }\r\n          }\r\n        }else if(betinfo[1] == 8){\r\n          //猜1个号，赔率放大了10倍\r\n          uint tmpp = 0;\r\n          betinfo[5]=1;//不中奖\r\n          if(codes[0] == betinfo[2]){\r\n            tmpp++;\r\n          }\r\n          if(codes[1] == betinfo[2]){\r\n            tmpp++;\r\n          }\r\n          if(codes[2] == betinfo[2]){\r\n            tmpp++;\r\n          }\r\n          if(tmpp > 0){\r\n            betinfo[5]=2;\r\n            rates = getPlayRate(betinfo[1],tmpp);\r\n            betinfo[6]=betinfo[3]*rates/10;\r\n          }\r\n        }\r\n\r\n    }\r\n\r\n    function getErbutongHao(uint sss) internal view returns(uint[2]){\r\n      uint[2] memory result ;\r\n      if(sss == 12){\r\n        result = [uint(1),2];\r\n      }else if(sss == 13){\r\n         result = [uint(1),3];\r\n      }else if(sss == 14){\r\n         result = [uint(1),4];\r\n      }else if(sss == 15){\r\n         result = [uint(1),5];\r\n      }else if(sss == 16){\r\n         result = [uint(1),6];\r\n      }else if(sss == 23){\r\n         result = [uint(2),3];\r\n      }else if(sss == 24){\r\n         result = [uint(2),4];\r\n      }else if(sss == 25){\r\n         result = [uint(2),5];\r\n      }else if(sss == 26){\r\n         result = [uint(2),6];\r\n      }else if(sss == 34){\r\n         result = [uint(3),4];\r\n      }else if(sss == 35){\r\n         result = [uint(3),5];\r\n      }else if(sss == 36){\r\n         result = [uint(3),6];\r\n      }else if(sss == 45){\r\n         result = [uint(4),5];\r\n      }else if(sss == 46){\r\n         result = [uint(4),6];\r\n      }else if(sss == 56){\r\n         result = [uint(5),6];\r\n      }\r\n      return (result);\r\n    }\r\n\r\n    function getLastBet() public view returns(string,uint[7][]){\r\n      uint len=playerLableList[msg.sender].length;\r\n      require(len>0);\r\n\r\n      uint i=len-1;\r\n      bytes32 lastLable = playerLableList[msg.sender][i];\r\n      uint max = lableCount[lastLable];\r\n      if(max > 50){\r\n          max = 50;\r\n      }\r\n      uint[7][] memory result = new uint[7][](max) ;\r\n      var opennum = \"\";\r\n      for(uint a=0;a<max;a++){\r\n         var ttmp =openNumberStr[lastLable];\r\n         if(a==0){\r\n           opennum =ttmp;\r\n         }else{\r\n           opennum = strConcat(opennum,\";\",ttmp);\r\n         }\r\n\r\n         result[a] = betList[lastLable][a];\r\n         if(lableStatus[lastLable] == 1){\r\n           result[a][5]=3;\r\n         }\r\n\r\n      }\r\n\r\n      return (opennum,result);\r\n    }\r\n\r\n    function getLableRecords(bytes32 lable) public view returns(string,uint[7][]){\r\n      uint max = lableCount[lable];\r\n      if(max > 50){\r\n          max = 50;\r\n      }\r\n      uint[7][] memory result = new uint[7][](max) ;\r\n      var opennum=\"\";\r\n\r\n      for(uint a=0;a<max;a++){\r\n         result[a] = betList[lable][a];\r\n         if(lableStatus[lable] == 1){\r\n           result[a][5]=3;\r\n         }\r\n         var ttmp =openNumberStr[lable];\r\n         if(a==0){\r\n           opennum =ttmp;\r\n         }else{\r\n           opennum = strConcat(opennum,\";\",ttmp);\r\n         }\r\n      }\r\n\r\n      return (opennum,result);\r\n    }\r\n\r\n    function getAllRecords() public view returns(string,uint[7][]){\r\n        uint len=playerLableList[msg.sender].length;\r\n        require(len>0);\r\n\r\n        uint max;\r\n        bytes32 lastLable ;\r\n        uint ss;\r\n\r\n        for(uint i1=0;i1<len;i1++){\r\n            ss = len-i1-1;\r\n            lastLable = playerLableList[msg.sender][ss];\r\n            max += lableCount[lastLable];\r\n            if(100 < max){\r\n              max = 100;\r\n              break;\r\n            }\r\n        }\r\n\r\n        uint[7][] memory result = new uint[7][](max) ;\r\n        bytes32[] memory resultlable = new bytes32[](max) ;\r\n        var opennum=\"\";\r\n\r\n        bool flag=false;\r\n        uint betnums;\r\n        uint j=0;\r\n\r\n        for(uint ii=0;ii<len;ii++){\r\n            ss = len-ii-1;\r\n            lastLable = playerLableList[msg.sender][ss];\r\n            betnums = lableCount[lastLable];\r\n            for(uint k= 0; k<betnums; k++){\r\n              if(j<max){\r\n                  resultlable[j] = lastLable;\r\n              \t var ttmp =openNumberStr[lastLable];\r\n                 if(j==0){\r\n                   opennum =ttmp;\r\n                 }else{\r\n                   opennum = strConcat(opennum,\";\",ttmp);\r\n                 }\r\n                  result[j] = betList[lastLable][k];\r\n                  if(lableStatus[lastLable] == 1){\r\n                    result[j][5]=3;\r\n                  }else if(lableStatus[lastLable] == 2){\r\n                    if(result[j][5]==2){\r\n                      result[j][5]=4;\r\n                    }\r\n                  }else if(lableStatus[lastLable] == 3){\r\n                    if(result[j][5]==2){\r\n                      result[j][5]=5;\r\n                    }\r\n                  }\r\n                  j++;\r\n              }else{\r\n                flag = true;\r\n                break;\r\n              }\r\n            }\r\n            if(flag){\r\n                break;\r\n            }\r\n        }\r\n        return (opennum,result);\r\n    }\r\n\r\n  function senttest() public payable onlyAdmin{\r\n      contractBalance=this.balance;\r\n      maxProfit=(this.balance*maxmoneypercent)/100;\r\n  }\r\n\r\n  function setRandomSeed(uint _randomSeed) public payable onlyAdmin{\r\n      randonce = _randomSeed;\r\n  }\r\n\r\n  function getRandomSeed() public view onlyAdmin returns(uint _randonce) {\r\n      _randonce = randonce;\r\n  }\r\n\r\n  function withdraw(uint _amount , address desaccount) public onlyAdmin{\r\n      desaccount.transfer(_amount);\r\n      contractBalance=this.balance;\r\n      maxProfit=(this.balance * maxmoneypercent)/100;\r\n  }\r\n\r\n  function getDatas() public view returns(\r\n    uint _maxProfit,\r\n    uint _minBet,\r\n    uint _contractbalance,\r\n    uint _onoff,\r\n    address _owner\r\n    //uint _oraclizeFee\r\n    ){\r\n        _maxProfit=maxProfit;\r\n        _minBet=minBet;\r\n        _contractbalance=contractBalance;\r\n        _onoff=onoff;\r\n        _owner=owner;\r\n    }\r\n\r\n    function getLableList() public view returns(string,bytes32[],uint[],uint[],uint){\r\n      uint len=playerLableList[msg.sender].length;\r\n      require(len>0);\r\n\r\n      uint max=50;\r\n      if(len < 50){\r\n          max = len;\r\n      }\r\n\r\n      bytes32[] memory lablelist = new bytes32[](max) ;\r\n      uint[] memory labletime = new uint[](max) ;\r\n      uint[] memory lablestatus = new uint[](max) ;\r\n      var opennum=\"\";\r\n\r\n      bytes32 lastLable ;\r\n      for(uint i=0;i<max;i++){\r\n          lastLable = playerLableList[msg.sender][max-i-1];\r\n          lablelist[i]=lastLable;\r\n          labletime[i]=lableTime[lastLable];\r\n          lablestatus[i]=lableStatus[lastLable];\r\n          var ttmp =openNumberStr[lastLable];\r\n         if(i==0){\r\n           opennum =ttmp;\r\n         }else{\r\n           opennum = strConcat(opennum,\";\",ttmp);\r\n         }\r\n      }\r\n\r\n      return (opennum,lablelist,labletime,lablestatus,now);\r\n    }\r\n\r\n    function doCheckBounds(bytes32 queryId) internal{\r\n        uint sta = lableStatus[queryId];\r\n        require(sta == 0 || sta == 2);\r\n        uint[3] memory codes = openNumberList[queryId];\r\n        require(codes[0] > 0);\r\n        //结算\r\n        uint len = lableCount[queryId];\r\n\r\n        uint totalWin;\r\n        address to = lableUser[queryId];\r\n        for(uint aa = 0 ; aa<len; aa++){\r\n          //未结算\r\n          if(sta == 0){\r\n           if(betList[queryId][aa][5] == 0){\r\n             checkWinMoney(betList[queryId][aa],codes);\r\n             totalWin+=betList[queryId][aa][6];\r\n           }\r\n          }else if(sta == 2){\r\n              totalWin+=betList[queryId][aa][6];\r\n          }\r\n        }\r\n\r\n        lableStatus[queryId] = 2;\r\n        //派奖\r\n        if(totalWin > 0){\r\n          if(totalWin < this.balance){\r\n            to.transfer(totalWin);//转账\r\n            lableStatus[queryId] = 3;\r\n          }else{\r\n              LogNewOraclizeQuery(\"sent bouns fail.\",queryId);\r\n          }\r\n        }else{\r\n          lableStatus[queryId] = 3;\r\n        }\r\n        contractBalance=this.balance;\r\n        maxProfit=(this.balance * maxmoneypercent)/100;\r\n    }\r\n\r\n    function getOpenNum(bytes32 queryId) public view returns(string){\r\n        return openNumberStr[queryId];\r\n    }\r\n\r\n    function doCheckSendBounds() public payable{\r\n        uint len=playerLableList[msg.sender].length;\r\n\r\n      uint max=50;\r\n      if(len < 50){\r\n          max = len;\r\n      }\r\n\r\n      uint sta;\r\n      bytes32 lastLable ;\r\n      for(uint i=0;i<max;i++){\r\n          lastLable = playerLableList[msg.sender][max-i-1];\r\n          sta = lableStatus[lastLable];\r\n          if(sta == 0 || sta==2){\r\n            doCheckBounds(lastLable);\r\n          }\r\n      }\r\n    }\r\n\r\n    function doCancelAll() public payable{\r\n        uint len=playerLableList[msg.sender].length;\r\n\r\n      uint max=50;\r\n      if(len < 50){\r\n          max = len;\r\n      }\r\n\r\n      uint sta;\r\n      uint bettime;\r\n      bytes32 lastLable ;\r\n      for(uint i=0;i<max;i++){\r\n          lastLable = playerLableList[msg.sender][max-i-1];\r\n          sta = lableStatus[lastLable];\r\n          bettime = lableTime[lastLable];\r\n          if(sta == 0 && (now - bettime)>600){\r\n            doCancel(lastLable);\r\n          }\r\n      }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"desaccount\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"getOpenNum\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lable\",\"type\":\"bytes32\"}],\"name\":\"getLableRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLableList\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_randomSeed\",\"type\":\"uint256\"}],\"name\":\"setRandomSeed\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doCancelAll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDatas\",\"outputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"},{\"name\":\"_minBet\",\"type\":\"uint256\"},{\"name\":\"_contractbalance\",\"type\":\"uint256\"},{\"name\":\"_onoff\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_on0ff\",\"type\":\"uint256\"}],\"name\":\"setGameOnoff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRandomSeed\",\"outputs\":[{\"name\":\"_randonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doCheckSendBounds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"doSendBounds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastBet\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playid\",\"type\":\"uint256[]\"},{\"name\":\"betMoney\",\"type\":\"uint256[]\"},{\"name\":\"betContent\",\"type\":\"uint256[]\"},{\"name\":\"mutiply\",\"type\":\"uint256\"}],\"name\":\"doBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"senttest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogNewOraclizeQuery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogNewRandomNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lableId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"content\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"singleMoney\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mutilple\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winMoney\",\"type\":\"uint256\"}],\"name\":\"LogSendBonus\",\"type\":\"event\"}]","ContractName":"BetContract","CompilerVersion":"v0.4.23-nightly.2018.4.19+commit.ae834e3d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://aa14271f965593b58f59f582a2d3c4b1e7991e881778885d6693f435e10890f4"}]}