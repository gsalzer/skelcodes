{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\ncontract TokenConfig {\r\n  string public constant NAME = \"MANGO\";\r\n  string public constant SYMBOL = \"MANG\";\r\n  uint8 public constant DECIMALS = 5;\r\n  uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);\r\n  uint public constant TOTALSUPPLY = 10000000000 * DECIMALSFACTOR;\r\n}\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"can't mul\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"can't sub with zero.\");\r\n\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"can't sub\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"add overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"can't mod with zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value), \"safeTransfer\");\r\n  }\r\n\r\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n    require(token.transferFrom(from, to, value), \"safeTransferFrom\");\r\n  }\r\n\r\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require((value == 0) || (token.allowance(msg.sender, spender) == 0), \"safeApprove\");\r\n    require(token.approve(spender, value), \"safeApprove\");\r\n  }\r\n\r\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n    require(token.approve(spender, newAllowance), \"safeIncreaseAllowance\");\r\n  }\r\n\r\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n    require(token.approve(spender, newAllowance), \"safeDecreaseAllowance\");\r\n  }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter;\r\n\r\n  constructor () internal {\r\n    // The counter starts at one to prevent changing it from zero to a non-zero\r\n    // value, which is a more expensive operation.\r\n    _guardCounter = 1;\r\n  }\r\n\r\n  /**\r\n    * @dev Prevents a contract from calling itself, directly or indirectly.\r\n    * Calling a `nonReentrant` function from another `nonReentrant`\r\n    * function is not supported. It is possible to prevent this from happening\r\n    * by making the `nonReentrant` function external, and make it call a\r\n    * `private` function that does the actual work.\r\n    */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter, \"nonReentrant.\");\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"only for owner.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0), \"address is zero.\");\r\n    owner = newOwner;\r\n    emit OwnershipTransferred(owner, newOwner);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Paused(address account);\r\n  event Unpaused(address account);\r\n\r\n  bool private _paused;\r\n\r\n  constructor() internal {\r\n    _paused = false;\r\n  }\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns(bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused, \"Not paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    _paused = true;\r\n    emit Paused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    _paused = false;\r\n    emit Unpaused(msg.sender);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Crowdsale white list address\r\n */\r\ncontract Whitelist is Ownable {\r\n  event WhitelistAdded(address addr);\r\n  event WhitelistRemoved(address addr);\r\n\r\n  mapping (address => bool) private _whitelist;\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   */\r\n  function addWhiteListAddr(address[] addrs)\r\n    public\r\n  {\r\n    uint256 len = addrs.length;\r\n    for (uint256 i = 0; i < len; i++) {\r\n      _addAddressToWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   */\r\n  function removeWhiteListAddr(address addr)\r\n    public\r\n  {\r\n    _removeAddressToWhitelist(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function isWhiteListAddr(address addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(addr != address(0), \"address is zero\");\r\n    return _whitelist[addr];\r\n  }\r\n\r\n  modifier onlyAuthorised(address beneficiary) {\r\n    require(isWhiteListAddr(beneficiary),\"Not authorised\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   */\r\n  function _addAddressToWhitelist(address addr)\r\n    internal\r\n    onlyOwner\r\n  {\r\n    require(addr != address(0), \"address is zero\");\r\n    _whitelist[addr] = true;\r\n    emit WhitelistAdded(addr);\r\n  }\r\n\r\n    /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   */\r\n  function _removeAddressToWhitelist(address addr)\r\n    internal\r\n    onlyOwner\r\n  {\r\n    require(addr != address(0), \"address is zero\");\r\n    _whitelist[addr] = false;\r\n    emit WhitelistRemoved(addr);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale is TokenConfig, Pausable, ReentrancyGuard, Whitelist {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  // The token being sold\r\n  IERC20 private _token;\r\n\r\n  // Address where funds are collected\r\n  address private _wallet;\r\n\r\n  // Address where funds are collected\r\n  address private _tokenholder;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 private _rate;\r\n\r\n  // Amount of contribution wei raised\r\n  uint256 private _weiRaised;\r\n\r\n  // Amount of token sold\r\n  uint256 private _tokenSoldAmount;\r\n\r\n  // Minimum contribution amount of fund\r\n  uint256 private _minWeiAmount;\r\n\r\n  // balances of user should be sent\r\n  mapping (address => uint256) private _tokenBalances;\r\n\r\n  // balances of user fund\r\n  mapping (address => uint256) private _weiBalances;\r\n\r\n  // ICO period timestamp\r\n  uint256 private _openingTime;\r\n  uint256 private _closingTime;\r\n\r\n  // Amount of token hardcap\r\n  uint256 private _hardcap;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokensPurchased(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n  event TokensDelivered(address indexed beneficiary, uint256 amount);\r\n  event RateChanged(uint256 rate);\r\n  event MinWeiChanged(uint256 minWei);\r\n  event PeriodChanged(uint256 open, uint256 close);\r\n  event HardcapChanged(uint256 hardcap);\r\n\r\n  constructor(\r\n    uint256 rate,\r\n    uint256 minWeiAmount,\r\n    address wallet,\r\n    address tokenholder,\r\n    IERC20 token,\r\n    uint256 hardcap,\r\n    uint256 openingTime,\r\n    uint256 closingTime\r\n  ) public {\r\n    require(rate > 0, \"Rate is lower than zero.\");\r\n    require(wallet != address(0), \"Wallet address is zero\");\r\n    require(tokenholder != address(0), \"Tokenholder address is zero\");\r\n    require(token != address(0), \"Token address is zero\");\r\n\r\n    _rate = rate;\r\n    _minWeiAmount = minWeiAmount;\r\n    _wallet = wallet;\r\n    _tokenholder = tokenholder;\r\n    _token = token;\r\n    _hardcap = hardcap;\r\n    _openingTime = openingTime;\r\n    _closingTime = closingTime;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   * Note that other contracts will transfer fund with a base gas stipend\r\n   * of 2300, which is not enough to call buyTokens. Consider calling\r\n   * buyTokens directly when purchasing tokens from a contract.\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @return the token being sold.\r\n   */\r\n  function token() public view returns(IERC20) {\r\n    return _token;\r\n  }\r\n\r\n  /**\r\n   * @return token hardcap.\r\n   */\r\n  function hardcap() public view returns(uint256) {\r\n    return _hardcap;\r\n  }\r\n\r\n  /**\r\n   * @return the address where funds are collected.\r\n   */\r\n  function wallet() public view returns(address) {\r\n    return _wallet;\r\n  }\r\n\r\n  /**\r\n   * @return the number of token units a buyer gets per wei.\r\n   */\r\n  function rate() public view returns(uint256) {\r\n    return _rate;\r\n  }\r\n\r\n  /**\r\n   * @return the amount of wei raised.\r\n   */\r\n  function weiRaised() public view returns (uint256) {\r\n    return _weiRaised;\r\n  }\r\n\r\n  /**\r\n   * @return ICO opening time.\r\n   */\r\n  function openingTime() public view returns (uint256) {\r\n    return _openingTime;\r\n  }\r\n\r\n  /**\r\n   * @return ICO closing time.\r\n   */\r\n  function closingTime() public view returns (uint256) {\r\n    return _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @return the amount of token raised.\r\n   */\r\n  function tokenSoldAmount() public view returns (uint256) {\r\n    return _tokenSoldAmount;\r\n  }\r\n\r\n  /**\r\n   * @return the number of minimum amount buyer can fund.\r\n   */\r\n  function minWeiAmount() public view returns(uint256) {\r\n    return _minWeiAmount;\r\n  }\r\n\r\n  /**\r\n   * @return is ICO period\r\n   */\r\n  function isOpen() public view returns (bool) {\r\n     // solium-disable-next-line security/no-block-members\r\n    return now >= _openingTime && now <= _closingTime;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the token balance of the specified address for deliver\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function tokenBalanceOf(address owner) public view returns (uint256) {\r\n    return _tokenBalances[owner];\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the ETH balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function weiBalanceOf(address owner) public view returns (uint256) {\r\n    return _weiBalances[owner];\r\n  }\r\n\r\n  function setRate(uint256 value) public onlyOwner {\r\n    _rate = value;\r\n    emit RateChanged(value);\r\n  }\r\n\r\n  function setMinWeiAmount(uint256 value) public onlyOwner {\r\n    _minWeiAmount = value;\r\n    emit MinWeiChanged(value);\r\n  }\r\n\r\n  function setPeriodTimestamp(uint256 open, uint256 close)\r\n    public\r\n    onlyOwner\r\n  {\r\n    _openingTime = open;\r\n    _closingTime = close;\r\n    emit PeriodChanged(open, close);\r\n  }\r\n\r\n  function setHardcap(uint256 value) public onlyOwner {\r\n    _hardcap = value;\r\n    emit HardcapChanged(value);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * This function has a non-reentrancy guard, so it shouldn't be called by\r\n   * another `nonReentrant` function.\r\n   * @param beneficiary Recipient of the token purchase\r\n   */\r\n  function buyTokens(address beneficiary)\r\n    public\r\n    nonReentrant\r\n    whenNotPaused\r\n    payable\r\n  {\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(beneficiary, weiAmount);\r\n\r\n    // Calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    require(_hardcap > _tokenSoldAmount.add(tokens), \"Over hardcap\");\r\n\r\n    // Update state\r\n    _weiRaised = _weiRaised.add(weiAmount);\r\n    _tokenSoldAmount = _tokenSoldAmount.add(tokens);\r\n\r\n    _weiBalances[beneficiary] = _weiBalances[beneficiary].add(weiAmount);\r\n    _tokenBalances[beneficiary] = _tokenBalances[beneficiary].add(tokens);\r\n\r\n    emit TokensPurchased(\r\n      msg.sender,\r\n      beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _forwardFunds();\r\n  }\r\n\r\n  /**\r\n   * @dev method that deliver token to user\r\n   */\r\n  function deliverTokens(address[] users)\r\n    public\r\n    whenNotPaused\r\n    onlyOwner\r\n  {\r\n    uint256 len = users.length;\r\n    for (uint256 i = 0; i < len; i++) {\r\n      address user = users[i];\r\n      uint256 tokenAmount = _tokenBalances[user];\r\n      _deliverTokens(user, tokenAmount);\r\n      _tokenBalances[user] = 0;\r\n\r\n      emit TokensDelivered(user, tokenAmount);\r\n    }\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n   * @param beneficiary Address performing the token purchase\r\n   * @param weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address beneficiary,\r\n    uint256 weiAmount\r\n  )\r\n    internal\r\n    view\r\n    onlyAuthorised(beneficiary)\r\n  {\r\n    require(weiAmount != 0, \"Zero ETH\");\r\n    require(weiAmount >= _minWeiAmount, \"Must be equal or higher than minimum\");\r\n    require(beneficiary != address(0), \"Beneficiary address is zero\");\r\n    require(isOpen(), \"Sales is close\");\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param beneficiary Address performing the token purchase\r\n   * @param tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address beneficiary,\r\n    uint256 tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _token.safeTransferFrom(_tokenholder, beneficiary, tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 weiAmount) internal view returns (uint256)\r\n  {\r\n    uint ethDecimals = 18;\r\n    require(DECIMALS <= ethDecimals, \"\");\r\n\r\n    uint256 covertedTokens = weiAmount;\r\n    if (DECIMALS != ethDecimals) {\r\n      covertedTokens = weiAmount.div((10 ** uint256(ethDecimals - DECIMALS)));\r\n    }\r\n    return covertedTokens.mul(_rate);\r\n  }\r\n\r\n  /**\r\n    * @dev Determines how ETH is stored/forwarded on purchases.\r\n    */\r\n  function _forwardFunds() internal {\r\n    _wallet.transfer(msg.value);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"minWeiAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"open\",\"type\":\"uint256\"},{\"name\":\"close\",\"type\":\"uint256\"}],\"name\":\"setPeriodTimestamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addWhiteListAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"deliverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeWhiteListAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALSFACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTALSUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"weiBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isWhiteListAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setHardcap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSoldAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinWeiAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"minWeiAmount\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"tokenholder\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"hardcap\",\"type\":\"uint256\"},{\"name\":\"openingTime\",\"type\":\"uint256\"},{\"name\":\"closingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"RateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minWei\",\"type\":\"uint256\"}],\"name\":\"MinWeiChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"open\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"close\",\"type\":\"uint256\"}],\"name\":\"PeriodChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hardcap\",\"type\":\"uint256\"}],\"name\":\"HardcapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000002540be400000000000000000000000000623757024311d8073e8d09541d2466c28d67c857000000000000000000000000623757024311d8073e8d09541d2466c28d67c8570000000000000000000000000e37c5fc37fecadd19ea885ac33c4055851b38ee0000000000000000000000000000000000000000000000000001c6bf52634000000000000000000000000000000000000000000000000000000000005c1b30f9000000000000000000000000000000000000000000000000000000005e7d8af9","Library":"","SwarmSource":"bzzr://ef1b6b62790a0b4e3725cc320d08d3ea9d0e9b8c5001bf09bd899b08acab8186"}]}