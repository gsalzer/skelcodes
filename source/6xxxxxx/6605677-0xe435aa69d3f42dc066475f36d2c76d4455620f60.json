{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// SafeMath library\r\nlibrary SafeMath {\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_a >= _b);\r\n        return _a - _b;\r\n    }\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n}\r\n\r\n// Contract must have an owner\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"sender must be owner\");\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) onlyOwner public {\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n// SaleBook Contract\r\ncontract SaleBook is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // admins info\r\n    mapping (uint256 => address) public admins;\r\n    mapping (address => uint256) public adminId;\r\n    uint256 public adminCount = 0;\r\n\r\n    // investor data\r\n    struct InvestorData {\r\n        uint256 id;\r\n        address addr;\r\n        uint256 ref;\r\n        address ref1;\r\n        address ref2;\r\n        uint256 reffed;\r\n        uint256 topref;\r\n        uint256 topreffed;\r\n    }\r\n\r\n    mapping (uint256 => InvestorData) public investors;\r\n    mapping (address => uint256) public investorId;\r\n    uint256 public investorCount = 0;\r\n\r\n    event AdminAdded(address indexed _addr, uint256 _id, address indexed _adder);\r\n    event AdminRemoved(address indexed _addr, uint256 _id, address indexed _remover);\r\n    event InvestorAdded(address indexed _addr, uint256 _id, address _ref1, address _ref2, address indexed _adder);\r\n\r\n    // check the address is human or contract\r\n    function isHuman(address _addr) public view returns (bool) {\r\n        uint256 _codeLength;\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        return (_codeLength == 0);\r\n    }\r\n\r\n    modifier validAddress(address _addr) {\r\n        require(_addr != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(adminId[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        adminId[address(0x0)] = 0;\r\n        admins[0] = address(0x0);\r\n\r\n        investorId[address(0x0)] = 0;\r\n        investors[0] = InvestorData({id: 0, addr: address(0x0), ref: 0, ref1: address(0x0), ref2: address(0x0), reffed: 0, topref: 0, topreffed: 0});\r\n\r\n\r\n        // first admin is owner\r\n        addAdmin(owner);\r\n    }\r\n\r\n    // owner may add or remove admins\r\n    function addAdmin(address _admin) onlyOwner validAddress(_admin) public {\r\n        require(isHuman(_admin));\r\n\r\n        uint256 id = adminId[_admin];\r\n        if (id == 0) {\r\n            id = adminCount.add(1);\r\n            adminId[_admin] = id;\r\n            admins[id] = _admin;\r\n            adminCount = id;\r\n            emit AdminAdded(_admin, id, msg.sender);\r\n        }\r\n    }\r\n\r\n    function removeAdmin(address _admin) onlyOwner validAddress(_admin) public {\r\n        require(adminId[_admin] != 0);\r\n\r\n        uint256 aid = adminId[_admin];\r\n        adminId[_admin] = 0;\r\n        for (uint256 i = aid; i < adminCount; i++){\r\n            admins[i] = admins[i + 1];\r\n            adminId[admins[i]] = i;\r\n        }\r\n        delete admins[adminCount];\r\n        adminCount--;\r\n        emit AdminRemoved(_admin, aid, msg.sender);\r\n    }\r\n\r\n    // admins may batch add investors, and investors cannot be removed\r\n    function addInvestor(address _addr, address _ref1, address _ref2) validAddress(_addr) internal returns (uint256) {\r\n        require(investorId[_addr] == 0 && isHuman(_addr));\r\n        if (investorId[_ref1] == 0) _ref1 = address(0x0);\r\n        if (investorId[_ref2] == 0) _ref2 = address(0x0);\r\n\r\n        investorCount++;\r\n        investorId[_addr] = investorCount;\r\n\r\n        investors[investorCount] = InvestorData({id: investorCount, addr: _addr, ref: 0, ref1: _ref1, ref2: _ref2, reffed: 0, topref: 0, topreffed: 0});\r\n\r\n        emit InvestorAdded(_addr, investorCount, _ref1, _ref2, msg.sender);\r\n        return investorCount;\r\n    }\r\n\r\n}\r\n\r\ninterface ERC20Token {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function balanceOf(address _addr) external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract CNTOSale is SaleBook {\r\n    using SafeMath for uint256;\r\n\r\n    string constant name = \"CNTO Sale\";\r\n    string constant version = \"1.8\";\r\n    uint256 constant keybase = 1000000000000000000;\r\n    uint256 constant DAY_IN_SECONDS = 86400;\r\n    uint256 private rseed = 0;\r\n\r\n    // various token related stuff\r\n    struct TokenInfo {\r\n        ERC20Token token;\r\n        address addr;\r\n        uint8 decimals;\r\n        address payaddr;\r\n        uint256 bought;\r\n        uint256 vaulted;\r\n        uint256 price;\r\n        uint256 buypercent;\r\n        uint256 lockperiod;\r\n    }\r\n\r\n    TokenInfo public tokenInfo;\r\n\r\n    // Investor's time-locked vaults to store tokens\r\n    struct InvestorTokenVault {\r\n        mapping (uint256 => uint256) lockValue;\r\n        mapping (uint256 => uint256) lockTime;\r\n        uint256 totalToken;\r\n        uint256 locks;\r\n        uint256 withdraws;\r\n        uint256 withdrawn;\r\n    }\r\n\r\n    mapping(uint256 => InvestorTokenVault) public investorVaults;\r\n\r\n\r\n    // Round related data\r\n    struct RoundData {\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        bool ended;\r\n        uint256 keys;\r\n        uint256 shares;\r\n        uint256 ethers;\r\n        uint256 pot;\r\n        uint256 divie;\r\n        uint256 currentInvestor;\r\n    }\r\n\r\n    bool public saleActive;\r\n    uint256 public saleEndTime;\r\n    uint256 public roundNum = 0; // current Round number\r\n    uint256 public endNum = 0; // end Round number\r\n    mapping (uint256 => RoundData) public rounds; // all rounds data for the game\r\n\r\n    // investor related info\r\n    struct InvestorInfo {\r\n        address addr;\r\n        uint256 lastRound;\r\n        uint256 invested;\r\n        uint256 keys;\r\n        uint256 prevEther;\r\n        uint256 lastEther;\r\n        uint256 potEther;\r\n        uint256 candyEther;\r\n        uint256 refEther;\r\n        uint256 withdrawn;\r\n    }\r\n\r\n    mapping (uint256 => InvestorInfo) public investorInfo; // all investor info for the sale\r\n\r\n    // Investor keys and shares in each round\r\n    struct InvestorRoundData {\r\n        uint256 keys;\r\n        uint256 shares;\r\n    }\r\n\r\n    mapping (uint256 => mapping (uint256 => InvestorRoundData)) public investorAtRound; // round number => id => investor keys and shares\r\n\r\n    // attributes of the entire Game\r\n    uint256 public roundTimeLimit;\r\n    uint256 public keyTime;\r\n    uint256 public keyprice;\r\n    uint256 public stepped;\r\n    uint256 public potpercent;\r\n    uint256 public diviepercent;\r\n    uint256 public tokenpercent;\r\n    uint256 public candypercent;\r\n    uint256 public candyvalue;\r\n    uint256 public candythreshold;\r\n    uint256 public candyprob;\r\n    uint256 public ref1percent;\r\n    uint256 public ref2percent;\r\n    uint256 public oppercent;\r\n    address public opaddress;\r\n    address public defaddress;\r\n    uint256 public defid;\r\n\r\n    // Round related events\r\n    event KeyBought(uint256 _round, uint256 _id, uint256 _keys, uint256 _shares);\r\n    event NewRoundCreated(uint256 _round, uint256 _id, uint256 _startTime, uint256 _endTime);\r\n    event RoundExtended(uint256 _round, uint256 _id, uint256 _endTime);\r\n    event PotWon(uint256 _round, uint256 _id, uint256 _pot);\r\n    event CandyWon(uint256 _round, uint256 _id, uint256 _candy);\r\n    event EtherWithdrawn(uint256 _round, uint256 _id, uint256 _value);\r\n    event EndingSale(address indexed _ender, uint256 _round, uint256 _time);\r\n    event SaleEnded(uint256 _round, uint256 _time);\r\n    event EtherReturned(address indexed _sender, uint256 _value, uint256 _time);\r\n\r\n    // Token related events\r\n    event TokenBought(uint256 _id, uint256 _amount);\r\n    event TokenLocked(uint256 _id, uint256 _amount, uint256 _locktime);\r\n    event TokenFundPaid(address indexed _paddr, uint256 _value);\r\n    event TokenWithdrawn(uint256 _id, uint256 _amount);\r\n\r\n    // Safety measure events\r\n    event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount, address indexed _target);\r\n    event InactiveTokenEmptied(address indexed _addr, uint256 _amount, address indexed _target);\r\n    event InactiveEtherEmptied(address indexed _addr, uint256 _amount, address indexed _target);\r\n    event ForgottenTokenEmptied(address indexed _addr, uint256 _amount, address indexed _target);\r\n    event ForgottenEtherEmptied(address indexed _addr, uint256 _amount, address indexed _target);\r\n\r\n    constructor(address _tokenAddress, address _payAddress, uint256 _price, uint256 _buypercent, uint256 _lockperiod, uint256 _candythreshold,\r\n    uint256 _candyprob, address _defaddress) public {\r\n        tokenInfo.token = ERC20Token(_tokenAddress);\r\n        tokenInfo.addr = _tokenAddress;\r\n        tokenInfo.decimals = tokenInfo.token.decimals();\r\n        tokenInfo.payaddr = _payAddress;\r\n        tokenInfo.bought = 0;\r\n        tokenInfo.vaulted = 0;\r\n        tokenInfo.price = _price;\r\n        tokenInfo.buypercent = _buypercent;\r\n        tokenInfo.lockperiod = _lockperiod;\r\n        candythreshold = _candythreshold;\r\n        candyprob = _candyprob;\r\n        defaddress = _defaddress;\r\n\r\n        defid = addInvestor(defaddress, address(0x0), address(0x0));\r\n    }\r\n\r\n    function initRound(uint256 _roundTimeLimit, uint256 _keyTime, uint256 _keyprice, uint256 _stepped, uint256 _potpercent, uint256 _diviepercent, uint256 _tokenpercent,\r\n    uint256 _candypercent, uint256 _ref1percent, uint256 _ref2percent, uint256 _oppercent, address _opaddress) onlyAdmin public {\r\n        require(roundNum == 0, \"already initialized\");\r\n        require(!((_potpercent + _diviepercent + _tokenpercent + _candypercent + _ref1percent + _ref2percent + _oppercent) > 100), \"the sum cannot be greater than 100\");\r\n        roundTimeLimit = _roundTimeLimit;\r\n        keyTime = _keyTime;\r\n        keyprice = _keyprice;\r\n        stepped = _stepped;\r\n        potpercent = _potpercent;\r\n        diviepercent = _diviepercent;\r\n        tokenpercent = _tokenpercent;\r\n        candypercent = _candypercent;\r\n        ref1percent = _ref1percent;\r\n        ref2percent = _ref2percent;\r\n        oppercent = _oppercent;\r\n        opaddress = _opaddress;\r\n\r\n        candyvalue = 0;\r\n        saleActive = true;\r\n        roundNum = 1;\r\n\r\n        rounds[roundNum] = RoundData({startTime: now, endTime: now.add(roundTimeLimit), ended: false, keys: 0, shares: 0, ethers: 0, pot: 0, divie: 0, currentInvestor: 0});\r\n        emit NewRoundCreated(roundNum, 0, rounds[roundNum].startTime, rounds[roundNum].endTime);\r\n    }\r\n\r\n    function saleState() public view returns (uint8 _status) {\r\n        if (roundNum == 0) return 0;\r\n        if (!saleActive && roundNum >= endNum) return 2;\r\n        return 1;\r\n    }\r\n\r\n    function roundStatus(uint256 _round) public view returns (uint8 _status) {\r\n        require(_round <= roundNum);\r\n        if (rounds[_round].ended) return 0;\r\n        return 1;\r\n    }\r\n\r\n    function getCurrentRoundInfo() public view returns (uint256 _divie, uint256 _startTime, uint256 _endTime,\r\n    uint256 _ethers, uint256 _keyTime, uint256 _keys, uint256 _pot, uint256 _candy, uint256 _roundNum,\r\n    uint8 _status, uint256 _tokenprice, uint256 _keyprice, uint8 _activityStatus, uint256 _activityStartTime) {\r\n        if(saleState() == 2) {\r\n            return (rounds[roundNum - 1].divie, rounds[roundNum - 1].startTime, rounds[roundNum - 1].endTime, rounds[roundNum - 1].ethers, keyTime, rounds[roundNum - 1].keys,\r\n            rounds[roundNum - 1].pot, candyvalue, roundNum - 1, roundStatus(roundNum - 1), tokenInfo.price, keyprice, saleState(), rounds[1].startTime);\r\n        }\r\n        return (rounds[roundNum].divie, rounds[roundNum].startTime, rounds[roundNum].endTime, rounds[roundNum].ethers, keyTime, rounds[roundNum].keys,\r\n        rounds[roundNum].pot, candyvalue, roundNum, roundStatus(roundNum), tokenInfo.price, keyprice, saleState(), rounds[1].startTime);\r\n    }\r\n\r\n    function getRoundInfo(uint256 _round) public view returns (uint256 _divie, uint256 _startTime, uint256 _endTime,\r\n    uint256 _ethers, uint256 _keys, uint256 _pot, uint8 _status) {\r\n        require(_round <= roundNum);\r\n        return (rounds[_round].divie, rounds[_round].startTime, rounds[_round].endTime,\r\n        rounds[_round].ethers, rounds[_round].keys, rounds[_round].pot, roundStatus(_round));\r\n    }\r\n\r\n    function getAllRoundsInfo() external view returns (uint256[] _divies, uint256[] _startTimes, uint256[] _endTimes,\r\n    uint256[] _ethers, uint256[] _keys, uint256[] _pots, uint8[] _status) {\r\n        uint256 i = 0;\r\n\r\n        _divies = new uint256[](roundNum);\r\n        _startTimes = new uint256[](roundNum);\r\n        _endTimes = new uint256[](roundNum);\r\n        _ethers = new uint256[](roundNum);\r\n        _keys = new uint256[](roundNum);\r\n        _pots = new uint256[](roundNum);\r\n        _status = new uint8[](roundNum);\r\n\r\n        while (i < roundNum) {\r\n            (_divies[i], _startTimes[i], _endTimes[i], _ethers[i], _keys[i], _pots[i], _status[i]) = getRoundInfo(i + 1);\r\n            i++;\r\n        }\r\n        return (_divies, _startTimes, _endTimes, _ethers, _keys, _pots, _status);\r\n    }\r\n\r\n    function tokenBalance() public view returns (uint256 _balance) {\r\n        return tokenInfo.token.balanceOf(address(this)).sub(tokenInfo.vaulted);\r\n    }\r\n\r\n    function tokenBuyable(uint256 _eth) public view returns (bool _buyable) {\r\n        if (!saleActive && roundNum >= endNum) return false;\r\n        uint256 buyAmount = (_eth).mul(tokenInfo.buypercent).div(100).mul(uint256(10)**tokenInfo.decimals).div(tokenInfo.price);\r\n        return (tokenBalance() >= buyAmount);\r\n    }\r\n\r\n    // Handles the buying of Tokens\r\n    function buyToken(uint256 _id, uint256 _eth) internal {\r\n        require(_id <= investorCount, \"invalid investor id\");\r\n        require(tokenBuyable(_eth), \"not enough token in reserve\");\r\n\r\n        uint256 buyAmount = (_eth).mul(tokenInfo.buypercent).div(100).mul(uint256(10)**tokenInfo.decimals).div(tokenInfo.price);\r\n        assert(tokenBalance() >= buyAmount);\r\n\r\n        tokenInfo.bought = tokenInfo.bought.add(buyAmount);\r\n        tokenInfo.vaulted = tokenInfo.vaulted.add(buyAmount);\r\n\r\n        emit TokenBought(_id, buyAmount);\r\n\r\n        uint256 lockStartTime = rounds[roundNum].startTime;\r\n        tokenTimeLock(_id, buyAmount, lockStartTime);\r\n\r\n        tokenInfo.payaddr.transfer(_eth);\r\n\r\n        emit TokenFundPaid(tokenInfo.payaddr, _eth);\r\n    }\r\n\r\n    // lock the Tokens allocated to investors with a timelock\r\n    function tokenTimeLock(uint256 _id, uint256 _amount, uint256 _start) private {\r\n        uint256 lockTime;\r\n        uint256 lockNum;\r\n        uint256 withdrawNum;\r\n\r\n        for (uint256 i = 0; i < 10; i++) {\r\n            lockTime = _start + tokenInfo.lockperiod.div(10).mul(i.add(1));\r\n            lockNum = investorVaults[_id].locks;\r\n            withdrawNum = investorVaults[_id].withdraws;\r\n            if (lockNum >= 10 && lockNum >= withdrawNum.add(10)) {\r\n                if (investorVaults[_id].lockTime[lockNum.sub(10).add(i)] == lockTime) {\r\n                    investorVaults[_id].lockValue[lockNum.sub(10).add(i)] = investorVaults[_id].lockValue[lockNum.sub(10).add(i)].add(_amount.div(10));\r\n                } else {\r\n                    investorVaults[_id].lockTime[lockNum] = lockTime;\r\n                    investorVaults[_id].lockValue[lockNum] = _amount.div(10);\r\n                    investorVaults[_id].locks++;\r\n                }\r\n            } else {\r\n                investorVaults[_id].lockTime[lockNum] = lockTime;\r\n                investorVaults[_id].lockValue[lockNum] = _amount.div(10);\r\n                investorVaults[_id].locks++;\r\n            }\r\n            emit TokenLocked(_id, _amount.div(10), lockTime);\r\n        }\r\n\r\n        investorVaults[_id].totalToken = investorVaults[_id].totalToken.add(_amount);\r\n    }\r\n\r\n    function showInvestorVaultByAddress(address _addr) public view returns (uint256 _total, uint256 _locked, uint256 _unlocked, uint256 _withdrawable, uint256 _withdrawn) {\r\n        uint256 id = investorId[_addr];\r\n        if (id == 0) {\r\n            return (0, 0, 0, 0, 0);\r\n        }\r\n        return showInvestorVaultById(id);\r\n    }\r\n\r\n    function showInvestorVaultById(uint256 _id) public view returns (uint256 _total, uint256 _locked, uint256 _unlocked, uint256 _withdrawable, uint256 _withdrawn) {\r\n        require(_id <= investorCount && _id > 0, \"invalid investor id\");\r\n        uint256 locked = 0;\r\n        uint256 unlocked = 0;\r\n        uint256 withdrawable = 0;\r\n        uint256 withdraws = investorVaults[_id].withdraws;\r\n        uint256 locks = investorVaults[_id].locks;\r\n        uint256 withdrawn = investorVaults[_id].withdrawn;\r\n        for (uint256 i = withdraws; i < locks; i++) {\r\n            if (investorVaults[_id].lockTime[i] < now) {\r\n                unlocked = unlocked.add(investorVaults[_id].lockValue[i]);\r\n                if (i - withdraws < 50) withdrawable = withdrawable.add(investorVaults[_id].lockValue[i]);\r\n            } else {\r\n                locked = locked.add(investorVaults[_id].lockValue[i]);\r\n            }\r\n        }\r\n        return (investorVaults[_id].totalToken, locked, unlocked, withdrawable, withdrawn);\r\n    }\r\n\r\n    function showInvestorVaultTime(uint256 _id, uint256 _count) public view returns (uint256 _time) {\r\n        return investorVaults[_id].lockTime[_count];\r\n    }\r\n\r\n    function showInvestorVaultValue(uint256 _id, uint256 _count) public view returns (uint256 _value) {\r\n        return investorVaults[_id].lockValue[_count];\r\n    }\r\n\r\n    // investors may withdraw tokens after the timelock period\r\n    function withdrawToken() public {\r\n        uint256 id = investorId[msg.sender];\r\n        require(id > 0, \"withdraw need valid investor\");\r\n        uint256 withdrawable = 0;\r\n        uint256 i = investorVaults[id].withdraws;\r\n        uint256 count = 0;\r\n        uint256 locks = investorVaults[id].locks;\r\n        for (; (i < locks) && (count < 50); i++) {\r\n            if (investorVaults[id].lockTime[i] < now) {\r\n                withdrawable = withdrawable.add(investorVaults[id].lockValue[i]);\r\n                investorVaults[id].withdraws = i + 1;\r\n            }\r\n            count++;\r\n        }\r\n\r\n        assert((tokenInfo.token.balanceOf(address(this)) >= withdrawable) && (tokenInfo.vaulted >= withdrawable));\r\n        tokenInfo.vaulted = tokenInfo.vaulted.sub(withdrawable);\r\n        investorVaults[id].withdrawn = investorVaults[id].withdrawn.add(withdrawable);\r\n        require(tokenInfo.token.transfer(msg.sender, withdrawable), \"token withdraw transfer failed\");\r\n\r\n        emit TokenWithdrawn(id, withdrawable);\r\n    }\r\n\r\n    modifier isPaid() {\r\n        // paymnent must be greater than 1GWei and less than 100k ETH\r\n        require((msg.value > 1000000000) && (msg.value < 100000000000000000000000), \"payment invalid\");\r\n        _;\r\n    }\r\n\r\n    function buyKey(address _ref1, address _ref2, address _node) isPaid public payable returns (bool _success) {\r\n        require(roundNum > 0, \"uninitialized\");\r\n        require(!rounds[roundNum].ended, \"cannot buy key from ended round\");\r\n\r\n        if (_ref1 == address(0x0)) {\r\n            _ref1 = defaddress;\r\n        }\r\n        if (_ref2 == address(0x0)) {\r\n            _ref2 = defaddress;\r\n        }\r\n        if (_node == address(0x0)) {\r\n            _node = defaddress;\r\n        }\r\n\r\n        uint256 id = investorId[msg.sender];\r\n        if (id == 0) {\r\n            if (investorId[_node] == 0) {\r\n                _node = defaddress;\r\n            }\r\n            if (investorId[_ref1] == 0) {\r\n                _ref1 = _node;\r\n            }\r\n            if (investorId[_ref2] == 0) {\r\n                _ref2 = _node;\r\n            }\r\n            id = addInvestor(msg.sender, _ref1, _ref2);\r\n        }\r\n        investorInfo[id].addr = msg.sender;\r\n        if (rounds[roundNum].ethers == 0) {\r\n            rounds[roundNum].startTime = now;\r\n            rounds[roundNum].endTime = now.add(roundTimeLimit);\r\n        }\r\n        uint256 topot = msg.value.mul(potpercent).div(100);\r\n        uint256 todivie = msg.value.mul(diviepercent).div(100);\r\n        uint256 totoken = msg.value.mul(tokenpercent).div(100);\r\n        uint256 tocandy = msg.value.mul(candypercent).div(100);\r\n        uint256 toref1 = msg.value.mul(ref1percent).div(100);\r\n        uint256 toref2 = msg.value.mul(ref2percent).div(100);\r\n        uint256 toop = msg.value.mul(oppercent).div(100);\r\n\r\n\r\n        if (now > rounds[roundNum].endTime) {\r\n            // current round ended, pot goes to winner\r\n            investorInfo[rounds[roundNum].currentInvestor].potEther = investorInfo[rounds[roundNum].currentInvestor].potEther.add(rounds[roundNum].pot);\r\n            emit PotWon(roundNum, rounds[roundNum].currentInvestor, rounds[roundNum].pot);\r\n\r\n            // start a new round\r\n            startNewRound(id, msg.value, topot, todivie);\r\n        } else {\r\n            processCurrentRound(id, msg.value, topot, todivie);\r\n        }\r\n\r\n        if (rounds[roundNum].ended) {\r\n            msg.sender.transfer(msg.value);\r\n            emit EtherReturned(msg.sender, msg.value, now);\r\n            return false;\r\n        }\r\n\r\n        uint256 cn = tryRandom();\r\n\r\n        candyvalue = candyvalue.add(tocandy);\r\n        if ((cn % candyprob == 0) && (msg.value >= candythreshold)) {\r\n            investorInfo[id].candyEther = investorInfo[id].candyEther.add(candyvalue);\r\n            candyvalue = 0;\r\n        }\r\n\r\n        toRef(id, toref1, toref2);\r\n\r\n        investorInfo[id].invested = investorInfo[id].invested.add(msg.value);\r\n\r\n        opaddress.transfer(toop);\r\n        buyToken(id, totoken);\r\n        return true;\r\n    }\r\n\r\n    function toRef(uint256 _id, uint256 _toref1, uint256 _toref2) private {\r\n        uint256 ref1 = investorId[investors[_id].ref1];\r\n        uint256 ref2 = investorId[investors[_id].ref2];\r\n        if (ref1 == 0 || ref1 > investorCount) {\r\n            ref1 = defid;\r\n        }\r\n        if (ref2 == 0 || ref2 > investorCount) {\r\n            ref2 = defid;\r\n        }\r\n        investorInfo[ref1].refEther = investorInfo[ref1].refEther.add(_toref1);\r\n        investorInfo[ref2].refEther = investorInfo[ref2].refEther.add(_toref2);\r\n    }\r\n\r\n    function tryRandom() private returns (uint256) {\r\n        uint256 bn = block.number;\r\n        rseed++;\r\n        uint256 bm1 = uint256(blockhash(bn - 1)) % 250 + 1;\r\n        uint256 bm2 = uint256(keccak256(abi.encodePacked(now))) % 250 + 2;\r\n        uint256 bm3 = uint256(keccak256(abi.encodePacked(block.difficulty))) % 250 + 3;\r\n        uint256 bm4 = uint256(keccak256(abi.encodePacked(uint256(msg.sender) + gasleft() + block.gaslimit))) % 250 + 4;\r\n        uint256 bm5 = uint256(keccak256(abi.encodePacked(uint256(keccak256(msg.data)) + msg.value + uint256(block.coinbase)))) % 250 + 5;\r\n        uint256 cn = uint256(keccak256(abi.encodePacked((bn + rseed) ^ uint256(blockhash(bn - bm1)) ^ uint256(blockhash(bn - bm2)) ^ uint256(blockhash(bn - bm3))\r\n        ^ uint256(blockhash(bn - bm4)) ^ uint256(blockhash(bn - bm5)))));\r\n        return cn;\r\n    }\r\n\r\n    function startNewRound(uint256 _id, uint256 _eth, uint256 _topot, uint256 _todivie) private {\r\n        processLastEther(_id);\r\n        investorInfo[_id].prevEther = investorInfo[_id].prevEther.add(investorInfo[_id].lastEther);\r\n        investorInfo[_id].lastEther = 0;\r\n        rounds[roundNum].ended = true;\r\n        roundNum++;\r\n        if (!saleActive) {\r\n            rounds[roundNum].ended = true;\r\n            saleEndTime = now;\r\n            emit SaleEnded(roundNum.sub(1), now);\r\n            return;\r\n        }\r\n        rounds[roundNum] = RoundData({startTime: now, endTime: now.add(roundTimeLimit), ended: false, keys: 0, shares: 0, ethers: _eth, pot: _topot, divie: _todivie, currentInvestor: _id});\r\n        uint256 boughtkeys = _eth.mul(keybase).div(keyprice);\r\n        uint256 denominator = uint256(1).add(rounds[roundNum].keys.div(stepped).div(keybase));\r\n        rounds[roundNum].keys = boughtkeys;\r\n        investorAtRound[roundNum][_id].keys = boughtkeys;\r\n        investorInfo[_id].keys = investorInfo[_id].keys.add(boughtkeys);\r\n        uint256 boughtshares = boughtkeys.div(denominator);\r\n        rounds[roundNum].shares = boughtshares;\r\n        investorAtRound[roundNum][_id].shares = boughtshares;\r\n        investorInfo[_id].lastRound = roundNum;\r\n        investorInfo[_id].lastEther = rounds[roundNum].divie.mul(investorAtRound[roundNum][_id].shares).div(rounds[roundNum].shares);\r\n\r\n        emit NewRoundCreated(roundNum, _id, rounds[roundNum].startTime, rounds[roundNum].endTime);\r\n        emit KeyBought(roundNum, _id, boughtkeys, boughtshares);\r\n    }\r\n\r\n    function processCurrentRound(uint256 _id, uint256 _eth, uint256 _topot, uint256 _todivie) private {\r\n        processLastEther(_id);\r\n        rounds[roundNum].ethers = rounds[roundNum].ethers.add(_eth);\r\n        rounds[roundNum].pot = rounds[roundNum].pot.add(_topot);\r\n        rounds[roundNum].divie = rounds[roundNum].divie.add(_todivie);\r\n        uint256 boughtkeys = _eth.mul(keybase).div(keyprice);\r\n        uint256 denominator = uint256(1).add(rounds[roundNum].keys.div(stepped).div(keybase));\r\n        rounds[roundNum].keys = rounds[roundNum].keys.add(boughtkeys);\r\n        investorAtRound[roundNum][_id].keys = investorAtRound[roundNum][_id].keys.add(boughtkeys);\r\n        investorInfo[_id].keys = investorInfo[_id].keys.add(boughtkeys);\r\n        uint256 boughtshares = boughtkeys.div(denominator);\r\n        rounds[roundNum].shares = rounds[roundNum].shares.add(boughtshares);\r\n        investorAtRound[roundNum][_id].shares = investorAtRound[roundNum][_id].shares.add(boughtshares);\r\n        investorInfo[_id].lastRound = roundNum;\r\n        investorInfo[_id].lastEther = rounds[roundNum].divie.mul(investorAtRound[roundNum][_id].shares).div(rounds[roundNum].shares);\r\n\r\n        rounds[roundNum].endTime = rounds[roundNum].endTime.add(boughtkeys.div(keybase).mul(keyTime));\r\n        if (rounds[roundNum].endTime > now.add(roundTimeLimit)) {\r\n            rounds[roundNum].endTime = now.add(roundTimeLimit);\r\n        }\r\n\r\n        rounds[roundNum].currentInvestor = _id;\r\n\r\n        emit RoundExtended(roundNum, _id, rounds[roundNum].endTime);\r\n        emit KeyBought(roundNum, _id, boughtkeys, boughtshares);\r\n    }\r\n\r\n    function processLastEther(uint256 _id) private {\r\n        uint256 pround = investorInfo[_id].lastRound;\r\n        assert(pround <= roundNum);\r\n        if (pround < roundNum && rounds[pround].shares > 0) {\r\n            investorInfo[_id].prevEther = investorInfo[_id].prevEther.add(rounds[pround].divie.mul(investorAtRound[pround][_id].shares).div(rounds[pround].shares));\r\n        }\r\n        if (rounds[roundNum].shares > 0) {\r\n            investorInfo[_id].lastEther = rounds[roundNum].divie.mul(investorAtRound[roundNum][_id].shares).div(rounds[roundNum].shares);\r\n        } else {\r\n            investorInfo[_id].lastEther = 0;\r\n        }\r\n        investorInfo[_id].lastRound = roundNum;\r\n    }\r\n\r\n    function showInvestorExtraByAddress(address _addr) public view returns (uint256 _invested, uint256 _lastRound, uint256 _keys, uint8 _activityStatus, uint256 _roundNum, uint256 _startTime) {\r\n        uint256 id = investorId[_addr];\r\n        if (id == 0) {\r\n            return (0, 0, 0, 0, 0, 0);\r\n        }\r\n        return showInvestorExtraById(id);\r\n    }\r\n\r\n    function showInvestorExtraById(uint256 _id ) public view returns (uint256 _invested, uint256 _lastRound, uint256 _keys, uint8 _activityStatus, uint256 _roundNum, uint256 _startTime) {\r\n        require(_id <= investorCount && _id > 0, \"invalid investor id\");\r\n        uint256 pinvested = investorInfo[_id].invested;\r\n        uint256 plastRound = investorInfo[_id].lastRound;\r\n        uint256 pkeys = investorInfo[_id].keys;\r\n        return (pinvested, plastRound, pkeys, saleState(), (saleState() == 2) ? roundNum - 1 : roundNum, rounds[1].startTime);\r\n    }\r\n\r\n    // show Investor's ether info\r\n    function showInvestorEtherByAddress(address _addr) public view returns (uint256 _divie, uint256 _pot, uint256 _candy, uint256 _ref, uint256 _withdrawable, uint256 _withdrawn) {\r\n        uint256 id = investorId[_addr];\r\n        if (id == 0) {\r\n            return (0, 0, 0, 0, 0, 0);\r\n        }\r\n        return showInvestorEtherById(id);\r\n    }\r\n\r\n    function showInvestorEtherById(uint256 _id) public view returns (uint256 _divie, uint256 _pot, uint256 _candy, uint256 _ref, uint256 _withdrawable, uint256 _withdrawn) {\r\n        require(_id <= investorCount && _id > 0, \"invalid investor id\");\r\n        uint256 pdivie;\r\n        uint256 ppot;\r\n        uint256 pcandy;\r\n        uint256 pref;\r\n        (pdivie, ppot, pcandy, pref) = investorInfoById(_id);\r\n        uint256 pwithdrawn = investorInfo[_id].withdrawn;\r\n        uint256 pwithdrawable = pdivie.add(ppot).add(pcandy).add(pref).sub(pwithdrawn);\r\n        return (pdivie, ppot, pcandy, pref, pwithdrawable, pwithdrawn);\r\n    }\r\n\r\n    function investorInfoById(uint256 _id) private view returns (uint256 _divie, uint256 _pot, uint256 _candy, uint256 _ref) {\r\n        require(_id <= investorCount && _id > 0, \"invalid investor id\");\r\n\r\n        uint256 pdivie = investorInfo[_id].prevEther;\r\n        if (investorInfo[_id].lastRound > 0) {\r\n            uint256 pround = investorInfo[_id].lastRound;\r\n            assert(pround <= roundNum);\r\n            pdivie = pdivie.add(rounds[pround].divie.mul(investorAtRound[pround][_id].shares).div(rounds[pround].shares));\r\n        }\r\n        uint256 ppot = investorInfo[_id].potEther;\r\n        uint256 pcandy = investorInfo[_id].candyEther;\r\n        uint256 pref = investorInfo[_id].refEther;\r\n\r\n        return (pdivie, ppot, pcandy, pref);\r\n    }\r\n\r\n    // investor withdraw ether\r\n    function withdraw() public {\r\n        require(roundNum > 0, \"uninitialized\");\r\n        if (now > rounds[roundNum].endTime) {\r\n            // current round ended, pot goes to winner\r\n            investorInfo[rounds[roundNum].currentInvestor].potEther = investorInfo[rounds[roundNum].currentInvestor].potEther.add(rounds[roundNum].pot);\r\n            emit PotWon(roundNum, rounds[roundNum].currentInvestor, rounds[roundNum].pot);\r\n\r\n            // start a new round\r\n            startNewRoundFromWithdrawal();\r\n        }\r\n        uint256 pdivie;\r\n        uint256 ppot;\r\n        uint256 pcandy;\r\n        uint256 pref;\r\n        uint256 withdrawable;\r\n        uint256 withdrawn;\r\n        uint256 id = investorId[msg.sender];\r\n        (pdivie, ppot, pcandy, pref, withdrawable, withdrawn) = showInvestorEtherById(id);\r\n        require(withdrawable > 0, \"no ether to withdraw\");\r\n        require(address(this).balance >= withdrawable, \"something wrong, not enough ether in reserve\");\r\n        investorInfo[id].withdrawn = investorInfo[id].withdrawn.add(withdrawable);\r\n        msg.sender.transfer(withdrawable);\r\n\r\n        emit EtherWithdrawn(roundNum, id, withdrawable);\r\n    }\r\n\r\n    function startNewRoundFromWithdrawal() private {\r\n        rounds[roundNum].ended = true;\r\n        roundNum++;\r\n        if (!saleActive) {\r\n            rounds[roundNum].ended = true;\r\n            saleEndTime = now;\r\n            emit SaleEnded(roundNum.sub(1), now);\r\n            return;\r\n        }\r\n        rounds[roundNum] = RoundData({startTime: now, endTime: now.add(roundTimeLimit), ended: false, keys: 0, shares: 0, ethers: 0, pot: 0, divie: 0, currentInvestor: 0});\r\n\r\n        emit NewRoundCreated(roundNum, 0, rounds[roundNum].startTime, rounds[roundNum].endTime);\r\n    }\r\n\r\n    // end the whole Sale after the current round\r\n    function endSale() onlyAdmin public {\r\n        saleActive = false;\r\n        endNum = roundNum.add(1);\r\n        emit EndingSale(msg.sender, roundNum, now);\r\n    }\r\n\r\n    // admin can empty wrongly sent Tokens\r\n    function emptyWrongToken(address _addr, address _target) onlyAdmin public {\r\n        require(_addr != tokenInfo.addr, \"this is not a wrong token\");\r\n        ERC20Token wrongToken = ERC20Token(_addr);\r\n        uint256 amount = wrongToken.balanceOf(address(this));\r\n        require(amount > 0, \"no wrong token sent here\");\r\n        require(wrongToken.transfer(_target, amount), \"token transfer failed\");\r\n\r\n        emit WrongTokenEmptied(_addr, msg.sender, amount, _target);\r\n    }\r\n\r\n    // admins can empty unsold tokens after sale ended\r\n    function emptyInactiveToken(address _target) onlyAdmin public {\r\n        require(!saleActive && roundNum >= endNum, \"sale still active\");\r\n        uint256 amount = tokenInfo.token.balanceOf(address(this)).sub(tokenInfo.vaulted);\r\n        require(tokenInfo.token.transfer(_target, amount), \"inactive token transfer failed\");\r\n\r\n        emit InactiveTokenEmptied(msg.sender, amount, _target);\r\n    }\r\n\r\n    // admins can empty unclaimed candy ethers after sale ended\r\n    function emptyInactiveEther(address _target) onlyAdmin public {\r\n        require(!saleActive && roundNum >= endNum, \"sale still active\");\r\n        require(candyvalue > 0, \"no inactive ether\");\r\n        uint256 amount = candyvalue;\r\n        _target.transfer(amount);\r\n        candyvalue = 0;\r\n\r\n        emit InactiveEtherEmptied(msg.sender, amount, _target);\r\n    }\r\n\r\n\r\n    // Emoty tokens and ethers after a long time?\r\n    function emptyForgottenToken(address _target) onlyAdmin public {\r\n        require(!saleActive && roundNum >= endNum, \"sale still active\");\r\n        require(now > saleEndTime.add(tokenInfo.lockperiod).add(180 * DAY_IN_SECONDS), \"still in waiting period\");\r\n        uint256 amount = tokenInfo.token.balanceOf(address(this));\r\n        require(tokenInfo.token.transfer(_target, amount), \"forgotten token transfer failed\");\r\n\r\n        emit ForgottenTokenEmptied(msg.sender, amount, _target);\r\n    }\r\n\r\n    function emptyForgottenEther(address _target) onlyAdmin public {\r\n        require(!saleActive && roundNum >= endNum, \"sale still active\");\r\n        require(now > saleEndTime.add(tokenInfo.lockperiod).add(180 * DAY_IN_SECONDS), \"still in waiting period\");\r\n        uint256 amount = address(this).balance;\r\n        _target.transfer(amount);\r\n\r\n        emit ForgottenEtherEmptied(msg.sender, amount, _target);\r\n    }\r\n\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorAtRound\",\"outputs\":[{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ref1percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"candypercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyprice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"showInvestorEtherById\",\"outputs\":[{\"name\":\"_divie\",\"type\":\"uint256\"},{\"name\":\"_pot\",\"type\":\"uint256\"},{\"name\":\"_candy\",\"type\":\"uint256\"},{\"name\":\"_ref\",\"type\":\"uint256\"},{\"name\":\"_withdrawable\",\"type\":\"uint256\"},{\"name\":\"_withdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"emptyInactiveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"showInvestorVaultValue\",\"outputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"emptyForgottenEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ref1\",\"type\":\"address\"},{\"name\":\"_ref2\",\"type\":\"address\"},{\"name\":\"_node\",\"type\":\"address\"}],\"name\":\"buyKey\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"showInvestorVaultTime\",\"outputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"showInvestorVaultById\",\"outputs\":[{\"name\":\"_total\",\"type\":\"uint256\"},{\"name\":\"_locked\",\"type\":\"uint256\"},{\"name\":\"_unlocked\",\"type\":\"uint256\"},{\"name\":\"_withdrawable\",\"type\":\"uint256\"},{\"name\":\"_withdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"showInvestorEtherByAddress\",\"outputs\":[{\"name\":\"_divie\",\"type\":\"uint256\"},{\"name\":\"_pot\",\"type\":\"uint256\"},{\"name\":\"_candy\",\"type\":\"uint256\"},{\"name\":\"_ref\",\"type\":\"uint256\"},{\"name\":\"_withdrawable\",\"type\":\"uint256\"},{\"name\":\"_withdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"ref\",\"type\":\"uint256\"},{\"name\":\"ref1\",\"type\":\"address\"},{\"name\":\"ref2\",\"type\":\"address\"},{\"name\":\"reffed\",\"type\":\"uint256\"},{\"name\":\"topref\",\"type\":\"uint256\"},{\"name\":\"topreffed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"emptyInactiveEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"candyprob\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"name\":\"_status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenpercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenInfo\",\"outputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"payaddr\",\"type\":\"address\"},{\"name\":\"bought\",\"type\":\"uint256\"},{\"name\":\"vaulted\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"buypercent\",\"type\":\"uint256\"},{\"name\":\"lockperiod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potpercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"_divie\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_ethers\",\"type\":\"uint256\"},{\"name\":\"_keyTime\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256\"},{\"name\":\"_pot\",\"type\":\"uint256\"},{\"name\":\"_candy\",\"type\":\"uint256\"},{\"name\":\"_roundNum\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"uint8\"},{\"name\":\"_tokenprice\",\"type\":\"uint256\"},{\"name\":\"_keyprice\",\"type\":\"uint256\"},{\"name\":\"_activityStatus\",\"type\":\"uint8\"},{\"name\":\"_activityStartTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"_divie\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_ethers\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256\"},{\"name\":\"_pot\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"emptyWrongToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"ethers\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"divie\",\"type\":\"uint256\"},{\"name\":\"currentInvestor\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"lastRound\",\"type\":\"uint256\"},{\"name\":\"invested\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"prevEther\",\"type\":\"uint256\"},{\"name\":\"lastEther\",\"type\":\"uint256\"},{\"name\":\"potEther\",\"type\":\"uint256\"},{\"name\":\"candyEther\",\"type\":\"uint256\"},{\"name\":\"refEther\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllRoundsInfo\",\"outputs\":[{\"name\":\"_divies\",\"type\":\"uint256[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"},{\"name\":\"_endTimes\",\"type\":\"uint256[]\"},{\"name\":\"_ethers\",\"type\":\"uint256[]\"},{\"name\":\"_keys\",\"type\":\"uint256[]\"},{\"name\":\"_pots\",\"type\":\"uint256[]\"},{\"name\":\"_status\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"showInvestorExtraById\",\"outputs\":[{\"name\":\"_invested\",\"type\":\"uint256\"},{\"name\":\"_lastRound\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256\"},{\"name\":\"_activityStatus\",\"type\":\"uint8\"},{\"name\":\"_roundNum\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"showInvestorVaultByAddress\",\"outputs\":[{\"name\":\"_total\",\"type\":\"uint256\"},{\"name\":\"_locked\",\"type\":\"uint256\"},{\"name\":\"_unlocked\",\"type\":\"uint256\"},{\"name\":\"_withdrawable\",\"type\":\"uint256\"},{\"name\":\"_withdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"diviepercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"candyvalue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"candythreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oppercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"roundStatus\",\"outputs\":[{\"name\":\"_status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundTimeLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"showInvestorExtraByAddress\",\"outputs\":[{\"name\":\"_invested\",\"type\":\"uint256\"},{\"name\":\"_lastRound\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256\"},{\"name\":\"_activityStatus\",\"type\":\"uint8\"},{\"name\":\"_roundNum\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stepped\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundTimeLimit\",\"type\":\"uint256\"},{\"name\":\"_keyTime\",\"type\":\"uint256\"},{\"name\":\"_keyprice\",\"type\":\"uint256\"},{\"name\":\"_stepped\",\"type\":\"uint256\"},{\"name\":\"_potpercent\",\"type\":\"uint256\"},{\"name\":\"_diviepercent\",\"type\":\"uint256\"},{\"name\":\"_tokenpercent\",\"type\":\"uint256\"},{\"name\":\"_candypercent\",\"type\":\"uint256\"},{\"name\":\"_ref1percent\",\"type\":\"uint256\"},{\"name\":\"_ref2percent\",\"type\":\"uint256\"},{\"name\":\"_oppercent\",\"type\":\"uint256\"},{\"name\":\"_opaddress\",\"type\":\"address\"}],\"name\":\"initRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"tokenBuyable\",\"outputs\":[{\"name\":\"_buyable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ref2percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"emptyForgottenToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isHuman\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorVaults\",\"outputs\":[{\"name\":\"totalToken\",\"type\":\"uint256\"},{\"name\":\"locks\",\"type\":\"uint256\"},{\"name\":\"withdraws\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_payAddress\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_buypercent\",\"type\":\"uint256\"},{\"name\":\"_lockperiod\",\"type\":\"uint256\"},{\"name\":\"_candythreshold\",\"type\":\"uint256\"},{\"name\":\"_candyprob\",\"type\":\"uint256\"},{\"name\":\"_defaddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_keys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"KeyBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"NewRoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"RoundExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_pot\",\"type\":\"uint256\"}],\"name\":\"PotWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_candy\",\"type\":\"uint256\"}],\"name\":\"CandyWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_ender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"EndingSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"SaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"EtherReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_locktime\",\"type\":\"uint256\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_paddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokenFundPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"WrongTokenEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"InactiveTokenEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"InactiveEtherEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"ForgottenTokenEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"ForgottenEtherEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_adder\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_remover\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ref1\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ref2\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_adder\",\"type\":\"address\"}],\"name\":\"InvestorAdded\",\"type\":\"event\"}]","ContractName":"CNTOSale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000088803cec3decaf5d4184bd2f816a51b2670a59f00000000000000000000000094a56a8485c93ccc02b39e6d8a182023212d6e2e00000000000000000000000000000000000000000000000000005af3107a400000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000094a56a8485c93ccc02b39e6d8a182023212d6e2e","Library":"","SwarmSource":"bzzr://cb3c33f3987c9b8746ab804ebb2aa5eeb12873f451a340174f07c2ff85d6f262"}]}