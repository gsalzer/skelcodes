{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\npragma experimental ABIEncoderV2;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nlibrary ECTools {\r\n\r\n    // @dev Recovers the address which has signed a message\r\n    // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n    function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\r\n        require(_hashedMsg != 0x00);\r\n\r\n        // need this for test RPC\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\r\n\r\n        if (bytes(_sig).length != 132) {\r\n            return 0x0;\r\n        }\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        if (v < 27 || v > 28) {\r\n            return 0x0;\r\n        }\r\n        return ecrecover(prefixedHash, v, r, s);\r\n    }\r\n\r\n    // @dev Verifies if the message is signed by an address\r\n    function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\r\n        require(_addr != 0x0);\r\n\r\n        return _addr == recoverSigner(_hashedMsg, _sig);\r\n    }\r\n\r\n    // @dev Converts an hexstring to bytes\r\n    function hexstrToBytes(string _hexstr) public pure returns (bytes) {\r\n        uint len = bytes(_hexstr).length;\r\n        require(len % 2 == 0);\r\n\r\n        bytes memory bstr = bytes(new string(len / 2));\r\n        uint k = 0;\r\n        string memory s;\r\n        string memory r;\r\n        for (uint i = 0; i < len; i += 2) {\r\n            s = substring(_hexstr, i, i + 1);\r\n            r = substring(_hexstr, i + 1, i + 2);\r\n            uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\r\n            bstr[k++] = uintToBytes32(p)[31];\r\n        }\r\n        return bstr;\r\n    }\r\n\r\n    // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\r\n    function parseInt16Char(string _char) public pure returns (uint) {\r\n        bytes memory bresult = bytes(_char);\r\n        // bool decimals = false;\r\n        if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\r\n            return uint(bresult[0]) - 48;\r\n        } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\r\n            return uint(bresult[0]) - 55;\r\n        } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\r\n            return uint(bresult[0]) - 87;\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // @dev Converts a uint to a bytes32\r\n    // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\r\n    function uintToBytes32(uint _uint) public pure returns (bytes b) {\r\n        b = new bytes(32);\r\n        assembly {mstore(add(b, 32), _uint)}\r\n    }\r\n\r\n    // @dev Hashes the signed message\r\n    // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\r\n    function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\r\n        uint len = bytes(_msg).length;\r\n        require(len > 0);\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\r\n        return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\r\n    }\r\n\r\n    // @dev Converts a uint in a string\r\n    function uintToString(uint _uint) public pure returns (string str) {\r\n        uint len = 0;\r\n        uint m = _uint + 0;\r\n        while (m != 0) {\r\n            len++;\r\n            m /= 10;\r\n        }\r\n        bytes memory b = new bytes(len);\r\n        uint i = len - 1;\r\n        while (_uint != 0) {\r\n            uint remainder = _uint % 10;\r\n            _uint = _uint / 10;\r\n            b[i--] = byte(48 + remainder);\r\n        }\r\n        str = string(b);\r\n    }\r\n\r\n\r\n    // @dev extract a substring\r\n    // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\r\n    function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\r\n        bytes memory strBytes = bytes(_str);\r\n        require(_startIndex <= _endIndex);\r\n        require(_startIndex >= 0);\r\n        require(_endIndex <= strBytes.length);\r\n\r\n        bytes memory result = new bytes(_endIndex - _startIndex);\r\n        for (uint i = _startIndex; i < _endIndex; i++) {\r\n            result[i - _startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n}\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ChannelManager {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant NAME = \"Channel Manager\";\r\n    string public constant VERSION = \"0.0.1\";\r\n\r\n    address public hub;\r\n    uint256 public challengePeriod;\r\n    ERC20 public approvedToken;\r\n\r\n    uint256 public totalChannelWei;\r\n    uint256 public totalChannelToken;\r\n\r\n    event DidHubContractWithdraw (\r\n        uint256 weiAmount,\r\n        uint256 tokenAmount\r\n    );\r\n\r\n    // Note: the payload of DidUpdateChannel contains the state that caused\r\n    // the update, not the state post-update (ex, if the update contains a\r\n    // deposit, the event's ``pendingDeposit`` field will be present and the\r\n    // event's ``balance`` field will not have been updated to reflect that\r\n    // balance).\r\n    event DidUpdateChannel (\r\n        address indexed user,\r\n        uint256 senderIdx, // 0: hub, 1: user\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[4] pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[4] pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[2] txCount, // [global, onchain]\r\n        bytes32 threadRoot,\r\n        uint256 threadCount\r\n    );\r\n\r\n    // Note: unlike the DidUpdateChannel event, the ``DidStartExitChannel``\r\n    // event will contain the channel state after any state that has been\r\n    // applied as part of startExitWithUpdate.\r\n    event DidStartExitChannel (\r\n        address indexed user,\r\n        uint256 senderIdx, // 0: hub, 1: user\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[2] txCount, // [global, onchain]\r\n        bytes32 threadRoot,\r\n        uint256 threadCount\r\n    );\r\n\r\n    event DidEmptyChannel (\r\n        address indexed user,\r\n        uint256 senderIdx, // 0: hub, 1: user\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[2] txCount, // [global, onchain]\r\n        bytes32 threadRoot,\r\n        uint256 threadCount\r\n    );\r\n\r\n    event DidStartExitThread (\r\n        address user,\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint256 threadId,\r\n        address senderAddress, // either hub or user\r\n        uint256[2] weiBalances, // [sender, receiver]\r\n        uint256[2] tokenBalances, // [sender, receiver]\r\n        uint256 txCount\r\n    );\r\n\r\n    event DidChallengeThread (\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint256 threadId,\r\n        address senderAddress, // can be either hub, sender, or receiver\r\n        uint256[2] weiBalances, // [sender, receiver]\r\n        uint256[2] tokenBalances, // [sender, receiver]\r\n        uint256 txCount\r\n    );\r\n\r\n    event DidEmptyThread (\r\n        address user,\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint256 threadId,\r\n        address senderAddress, // can be anyone\r\n        uint256[2] channelWeiBalances,\r\n        uint256[2] channelTokenBalances,\r\n        uint256[2] channelTxCount,\r\n        bytes32 channelThreadRoot,\r\n        uint256 channelThreadCount\r\n    );\r\n\r\n    event DidNukeThreads(\r\n        address indexed user,\r\n        address senderAddress, // can be anyone\r\n        uint256 weiAmount, // amount of wei sent\r\n        uint256 tokenAmount, // amount of tokens sent\r\n        uint256[2] channelWeiBalances,\r\n        uint256[2] channelTokenBalances,\r\n        uint256[2] channelTxCount,\r\n        bytes32 channelThreadRoot,\r\n        uint256 channelThreadCount\r\n    );\r\n\r\n    enum ChannelStatus {\r\n       Open,\r\n       ChannelDispute,\r\n       ThreadDispute\r\n    }\r\n\r\n    struct Channel {\r\n        uint256[3] weiBalances; // [hub, user, total]\r\n        uint256[3] tokenBalances; // [hub, user, total]\r\n        uint256[2] txCount; // persisted onchain even when empty [global, pending]\r\n        bytes32 threadRoot;\r\n        uint256 threadCount;\r\n        address exitInitiator;\r\n        uint256 channelClosingTime;\r\n        ChannelStatus status;\r\n    }\r\n\r\n    struct Thread {\r\n        uint256[2] weiBalances; // [sender, receiver]\r\n        uint256[2] tokenBalances; // [sender, receiver]\r\n        uint256 txCount; // persisted onchain even when empty\r\n        uint256 threadClosingTime;\r\n        bool[2] emptied; // [sender, receiver]\r\n    }\r\n\r\n    mapping(address => Channel) public channels;\r\n    mapping(address => mapping(address => mapping(uint256 => Thread))) threads; // threads[sender][receiver][threadId]\r\n\r\n    bool locked;\r\n\r\n    modifier onlyHub() {\r\n        require(msg.sender == hub);\r\n        _;\r\n    }\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call.\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor(address _hub, uint256 _challengePeriod, address _tokenAddress) public {\r\n        hub = _hub;\r\n        challengePeriod = _challengePeriod;\r\n        approvedToken = ERC20(_tokenAddress);\r\n    }\r\n\r\n    function hubContractWithdraw(uint256 weiAmount, uint256 tokenAmount) public noReentrancy onlyHub {\r\n        require(\r\n            getHubReserveWei() >= weiAmount,\r\n            \"hubContractWithdraw: Contract wei funds not sufficient to withdraw\"\r\n        );\r\n        require(\r\n            getHubReserveTokens() >= tokenAmount,\r\n            \"hubContractWithdraw: Contract token funds not sufficient to withdraw\"\r\n        );\r\n\r\n        hub.transfer(weiAmount);\r\n        require(\r\n            approvedToken.transfer(hub, tokenAmount),\r\n            \"hubContractWithdraw: Token transfer failure\"\r\n        );\r\n\r\n        emit DidHubContractWithdraw(weiAmount, tokenAmount);\r\n    }\r\n\r\n    function getHubReserveWei() public view returns (uint256) {\r\n        return address(this).balance.sub(totalChannelWei);\r\n    }\r\n\r\n    function getHubReserveTokens() public view returns (uint256) {\r\n        return approvedToken.balanceOf(address(this)).sub(totalChannelToken);\r\n    }\r\n\r\n    function hubAuthorizedUpdate(\r\n        address user,\r\n        address recipient,\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[4] pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[4] pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[2] txCount, // [global, onchain] persisted onchain even when empty\r\n        bytes32 threadRoot,\r\n        uint256 threadCount,\r\n        uint256 timeout,\r\n        string sigUser\r\n    ) public noReentrancy onlyHub {\r\n        Channel storage channel = channels[user];\r\n\r\n        _verifyAuthorizedUpdate(\r\n            channel,\r\n            txCount,\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates,\r\n            pendingTokenUpdates,\r\n            timeout,\r\n            true\r\n        );\r\n\r\n        _verifySig(\r\n            [user, recipient],\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            txCount,\r\n            threadRoot,\r\n            threadCount,\r\n            timeout,\r\n            \"\", // skip hub sig verification\r\n            sigUser,\r\n            [false, true] // [checkHubSig?, checkUser] <- only need to check user\r\n        );\r\n\r\n        _updateChannelBalances(channel, weiBalances, tokenBalances, pendingWeiUpdates, pendingTokenUpdates);\r\n\r\n        // transfer wei and token to recipient\r\n        recipient.transfer(pendingWeiUpdates[3]);\r\n        require(approvedToken.transfer(recipient, pendingTokenUpdates[3]), \"user token withdrawal transfer failed\");\r\n\r\n        // update state variables\r\n        channel.txCount = txCount;\r\n        channel.threadRoot = threadRoot;\r\n        channel.threadCount = threadCount;\r\n\r\n        emit DidUpdateChannel(\r\n            user,\r\n            0, // senderIdx\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates,\r\n            pendingTokenUpdates,\r\n            txCount,\r\n            threadRoot,\r\n            threadCount\r\n        );\r\n    }\r\n\r\n    function userAuthorizedUpdate(\r\n        address recipient,\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[4] pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[4] pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[2] txCount, // persisted onchain even when empty\r\n        bytes32 threadRoot,\r\n        uint256 threadCount,\r\n        uint256 timeout,\r\n        string sigHub\r\n    ) public payable noReentrancy {\r\n        require(msg.value == pendingWeiUpdates[2], \"msg.value is not equal to pending user deposit\");\r\n\r\n        Channel storage channel = channels[msg.sender];\r\n\r\n        _verifyAuthorizedUpdate(\r\n            channel,\r\n            txCount,\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates,\r\n            pendingTokenUpdates,\r\n            timeout,\r\n            false\r\n        );\r\n\r\n        _verifySig(\r\n            [msg.sender, recipient],\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            txCount,\r\n            threadRoot,\r\n            threadCount,\r\n            timeout,\r\n            sigHub,\r\n            \"\", // skip user sig verification\r\n            [true, false] // [checkHubSig?, checkUser] <- only need to check hub\r\n        );\r\n\r\n        // transfer user token deposit to this contract\r\n        require(approvedToken.transferFrom(msg.sender, address(this), pendingTokenUpdates[2]), \"user token deposit failed\");\r\n\r\n        _updateChannelBalances(channel, weiBalances, tokenBalances, pendingWeiUpdates, pendingTokenUpdates);\r\n\r\n        // transfer wei and token to recipient\r\n        recipient.transfer(pendingWeiUpdates[3]);\r\n        require(approvedToken.transfer(recipient, pendingTokenUpdates[3]), \"user token withdrawal transfer failed\");\r\n\r\n        // update state variables\r\n        channel.txCount = txCount;\r\n        channel.threadRoot = threadRoot;\r\n        channel.threadCount = threadCount;\r\n\r\n        emit DidUpdateChannel(\r\n            msg.sender,\r\n            1, // senderIdx\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates,\r\n            pendingTokenUpdates,\r\n            channel.txCount,\r\n            channel.threadRoot,\r\n            channel.threadCount\r\n        );\r\n    }\r\n\r\n    /**********************\r\n     * Unilateral Functions\r\n     *********************/\r\n\r\n    // start exit with onchain state\r\n    function startExit(\r\n        address user\r\n    ) public noReentrancy {\r\n        require(user != hub, \"user can not be hub\");\r\n        require(user != address(this), \"user can not be channel manager\");\r\n\r\n        Channel storage channel = channels[user];\r\n        require(channel.status == ChannelStatus.Open, \"channel must be open\");\r\n\r\n        require(msg.sender == hub || msg.sender == user, \"exit initiator must be user or hub\");\r\n\r\n        channel.exitInitiator = msg.sender;\r\n        channel.channelClosingTime = now.add(challengePeriod);\r\n        channel.status = ChannelStatus.ChannelDispute;\r\n\r\n        emit DidStartExitChannel(\r\n            user,\r\n            msg.sender == hub ? 0 : 1,\r\n            [channel.weiBalances[0], channel.weiBalances[1]],\r\n            [channel.tokenBalances[0], channel.tokenBalances[1]],\r\n            channel.txCount,\r\n            channel.threadRoot,\r\n            channel.threadCount\r\n        );\r\n    }\r\n\r\n    // start exit with offchain state\r\n    function startExitWithUpdate(\r\n        address[2] user, // [user, recipient]\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[4] pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[4] pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[2] txCount, // [global, onchain] persisted onchain even when empty\r\n        bytes32 threadRoot,\r\n        uint256 threadCount,\r\n        uint256 timeout,\r\n        string sigHub,\r\n        string sigUser\r\n    ) public noReentrancy {\r\n        Channel storage channel = channels[user[0]];\r\n        require(channel.status == ChannelStatus.Open, \"channel must be open\");\r\n\r\n        require(msg.sender == hub || msg.sender == user[0], \"exit initiator must be user or hub\");\r\n\r\n        require(timeout == 0, \"can't start exit with time-sensitive states\");\r\n\r\n        _verifySig(\r\n            user,\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            txCount,\r\n            threadRoot,\r\n            threadCount,\r\n            timeout,\r\n            sigHub,\r\n            sigUser,\r\n            [true, true] // [checkHubSig?, checkUser] <- check both sigs\r\n        );\r\n\r\n        require(txCount[0] > channel.txCount[0], \"global txCount must be higher than the current global txCount\");\r\n        require(txCount[1] >= channel.txCount[1], \"onchain txCount must be higher or equal to the current onchain txCount\");\r\n\r\n        // offchain wei/token balances do not exceed onchain total wei/token\r\n        require(weiBalances[0].add(weiBalances[1]) <= channel.weiBalances[2], \"wei must be conserved\");\r\n        require(tokenBalances[0].add(tokenBalances[1]) <= channel.tokenBalances[2], \"tokens must be conserved\");\r\n\r\n        // pending onchain txs have been executed - force update offchain state to reflect this\r\n        if (txCount[1] == channel.txCount[1]) {\r\n            _applyPendingUpdates(channel.weiBalances, weiBalances, pendingWeiUpdates);\r\n            _applyPendingUpdates(channel.tokenBalances, tokenBalances, pendingTokenUpdates);\r\n\r\n        // pending onchain txs have *not* been executed - revert pending deposits and withdrawals back into offchain balances\r\n        } else { //txCount[1] > channel.txCount[1]\r\n            _revertPendingUpdates(channel.weiBalances, weiBalances, pendingWeiUpdates);\r\n            _revertPendingUpdates(channel.tokenBalances, tokenBalances, pendingTokenUpdates);\r\n        }\r\n\r\n        // update state variables\r\n        // only update txCount[0] (global)\r\n        // - txCount[1] should only be updated by user/hubAuthorizedUpdate\r\n        channel.txCount[0] = txCount[0];\r\n        channel.threadRoot = threadRoot;\r\n        channel.threadCount = threadCount;\r\n\r\n        channel.exitInitiator = msg.sender;\r\n        channel.channelClosingTime = now.add(challengePeriod);\r\n        channel.status = ChannelStatus.ChannelDispute;\r\n\r\n        emit DidStartExitChannel(\r\n            user[0],\r\n            msg.sender == hub ? 0 : 1,\r\n            [channel.weiBalances[0], channel.weiBalances[1]],\r\n            [channel.tokenBalances[0], channel.tokenBalances[1]],\r\n            channel.txCount,\r\n            channel.threadRoot,\r\n            channel.threadCount\r\n        );\r\n    }\r\n\r\n    // party that didn't start exit can challenge and empty\r\n    function emptyChannelWithChallenge(\r\n        address[2] user,\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[4] pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[4] pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[2] txCount, // persisted onchain even when empty\r\n        bytes32 threadRoot,\r\n        uint256 threadCount,\r\n        uint256 timeout,\r\n        string sigHub,\r\n        string sigUser\r\n    ) public noReentrancy {\r\n        Channel storage channel = channels[user[0]];\r\n        require(channel.status == ChannelStatus.ChannelDispute, \"channel must be in dispute\");\r\n        require(now < channel.channelClosingTime, \"channel closing time must not have passed\");\r\n\r\n        require(msg.sender != channel.exitInitiator, \"challenger can not be exit initiator\");\r\n        require(msg.sender == hub || msg.sender == user[0], \"challenger must be either user or hub\");\r\n\r\n        require(timeout == 0, \"can't start exit with time-sensitive states\");\r\n\r\n        _verifySig(\r\n            user,\r\n            weiBalances,\r\n            tokenBalances,\r\n            pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n            txCount,\r\n            threadRoot,\r\n            threadCount,\r\n            timeout,\r\n            sigHub,\r\n            sigUser,\r\n            [true, true] // [checkHubSig?, checkUser] <- check both sigs\r\n        );\r\n\r\n        require(txCount[0] > channel.txCount[0], \"global txCount must be higher than the current global txCount\");\r\n        require(txCount[1] >= channel.txCount[1], \"onchain txCount must be higher or equal to the current onchain txCount\");\r\n\r\n        // offchain wei/token balances do not exceed onchain total wei/token\r\n        require(weiBalances[0].add(weiBalances[1]) <= channel.weiBalances[2], \"wei must be conserved\");\r\n        require(tokenBalances[0].add(tokenBalances[1]) <= channel.tokenBalances[2], \"tokens must be conserved\");\r\n\r\n        // pending onchain txs have been executed - force update offchain state to reflect this\r\n        if (txCount[1] == channel.txCount[1]) {\r\n            _applyPendingUpdates(channel.weiBalances, weiBalances, pendingWeiUpdates);\r\n            _applyPendingUpdates(channel.tokenBalances, tokenBalances, pendingTokenUpdates);\r\n\r\n        // pending onchain txs have *not* been executed - revert pending deposits and withdrawals back into offchain balances\r\n        } else { //txCount[1] > channel.txCount[1]\r\n            _revertPendingUpdates(channel.weiBalances, weiBalances, pendingWeiUpdates);\r\n            _revertPendingUpdates(channel.tokenBalances, tokenBalances, pendingTokenUpdates);\r\n        }\r\n\r\n        // deduct hub/user wei/tokens from total channel balances\r\n        channel.weiBalances[2] = channel.weiBalances[2].sub(channel.weiBalances[0]).sub(channel.weiBalances[1]);\r\n        channel.tokenBalances[2] = channel.tokenBalances[2].sub(channel.tokenBalances[0]).sub(channel.tokenBalances[1]);\r\n\r\n        // transfer hub wei balance from channel to reserves\r\n        totalChannelWei = totalChannelWei.sub(channel.weiBalances[0]).sub(channel.weiBalances[1]);\r\n        // transfer user wei balance to user\r\n        user[0].transfer(channel.weiBalances[1]);\r\n        channel.weiBalances[0] = 0;\r\n        channel.weiBalances[1] = 0;\r\n\r\n        // transfer hub token balance from channel to reserves\r\n        totalChannelToken = totalChannelToken.sub(channel.tokenBalances[0]).sub(channel.tokenBalances[1]);\r\n        // transfer user token balance to user\r\n        require(approvedToken.transfer(user[0], channel.tokenBalances[1]), \"user token withdrawal transfer failed\");\r\n        channel.tokenBalances[0] = 0;\r\n        channel.tokenBalances[1] = 0;\r\n\r\n        // update state variables\r\n        // only update txCount[0] (global)\r\n        // - txCount[1] should only be updated by user/hubAuthorizedUpdate\r\n        channel.txCount[0] = txCount[0];\r\n        channel.threadRoot = threadRoot;\r\n        channel.threadCount = threadCount;\r\n\r\n        if (channel.threadCount > 0) {\r\n            channel.status = ChannelStatus.ThreadDispute;\r\n        } else {\r\n            channel.channelClosingTime = 0;\r\n            channel.status = ChannelStatus.Open;\r\n        }\r\n\r\n        channel.exitInitiator = address(0x0);\r\n\r\n        emit DidEmptyChannel(\r\n            user[0],\r\n            msg.sender == hub ? 0 : 1,\r\n            [channel.weiBalances[0], channel.weiBalances[1]],\r\n            [channel.tokenBalances[0], channel.tokenBalances[1]],\r\n            channel.txCount,\r\n            channel.threadRoot,\r\n            channel.threadCount\r\n        );\r\n    }\r\n\r\n    // after timer expires - anyone can call; even before timer expires, non-exit-initiating party can call\r\n    function emptyChannel(\r\n        address user\r\n    ) public noReentrancy {\r\n        require(user != hub, \"user can not be hub\");\r\n        require(user != address(this), \"user can not be channel manager\");\r\n\r\n        Channel storage channel = channels[user];\r\n        require(channel.status == ChannelStatus.ChannelDispute, \"channel must be in dispute\");\r\n\r\n        require(\r\n          channel.channelClosingTime < now ||\r\n          msg.sender != channel.exitInitiator && (msg.sender == hub || msg.sender == user),\r\n          \"channel closing time must have passed or msg.sender must be non-exit-initiating party\"\r\n        );\r\n\r\n        // deduct hub/user wei/tokens from total channel balances\r\n        channel.weiBalances[2] = channel.weiBalances[2].sub(channel.weiBalances[0]).sub(channel.weiBalances[1]);\r\n        channel.tokenBalances[2] = channel.tokenBalances[2].sub(channel.tokenBalances[0]).sub(channel.tokenBalances[1]);\r\n\r\n        // transfer hub wei balance from channel to reserves\r\n        totalChannelWei = totalChannelWei.sub(channel.weiBalances[0]).sub(channel.weiBalances[1]);\r\n        // transfer user wei balance to user\r\n        user.transfer(channel.weiBalances[1]);\r\n        channel.weiBalances[0] = 0;\r\n        channel.weiBalances[1] = 0;\r\n\r\n        // transfer hub token balance from channel to reserves\r\n        totalChannelToken = totalChannelToken.sub(channel.tokenBalances[0]).sub(channel.tokenBalances[1]);\r\n        // transfer user token balance to user\r\n        require(approvedToken.transfer(user, channel.tokenBalances[1]), \"user token withdrawal transfer failed\");\r\n        channel.tokenBalances[0] = 0;\r\n        channel.tokenBalances[1] = 0;\r\n\r\n        if (channel.threadCount > 0) {\r\n            channel.status = ChannelStatus.ThreadDispute;\r\n        } else {\r\n            channel.channelClosingTime = 0;\r\n            channel.status = ChannelStatus.Open;\r\n        }\r\n\r\n        channel.exitInitiator = address(0x0);\r\n\r\n        emit DidEmptyChannel(\r\n            user,\r\n            msg.sender == hub ? 0 : 1,\r\n            [channel.weiBalances[0], channel.weiBalances[1]],\r\n            [channel.tokenBalances[0], channel.tokenBalances[1]],\r\n            channel.txCount,\r\n            channel.threadRoot,\r\n            channel.threadCount\r\n        );\r\n    }\r\n\r\n    // **********************\r\n    // THREAD DISPUTE METHODS\r\n    // **********************\r\n\r\n    // either party starts exit with initial state\r\n    function startExitThread(\r\n        address user,\r\n        address sender,\r\n        address receiver,\r\n        uint256 threadId,\r\n        uint256[2] weiBalances, // [sender, receiver]\r\n        uint256[2] tokenBalances, // [sender, receiver]\r\n        bytes proof,\r\n        string sig\r\n    ) public noReentrancy {\r\n        Channel storage channel = channels[user];\r\n        require(channel.status == ChannelStatus.ThreadDispute, \"channel must be in thread dispute phase\");\r\n        require(msg.sender == hub || msg.sender == user, \"thread exit initiator must be user or hub\");\r\n        require(user == sender || user == receiver, \"user must be thread sender or receiver\");\r\n\r\n        require(weiBalances[1] == 0 && tokenBalances[1] == 0, \"initial receiver balances must be zero\");\r\n\r\n        Thread storage thread = threads[sender][receiver][threadId];\r\n\r\n        require(thread.threadClosingTime == 0, \"thread closing time must be zero\");\r\n\r\n        _verifyThread(sender, receiver, threadId, weiBalances, tokenBalances, 0, proof, sig, channel.threadRoot);\r\n\r\n        thread.weiBalances = weiBalances;\r\n        thread.tokenBalances = tokenBalances;\r\n        thread.threadClosingTime = now.add(challengePeriod);\r\n\r\n        emit DidStartExitThread(\r\n            user,\r\n            sender,\r\n            receiver,\r\n            threadId,\r\n            msg.sender,\r\n            thread.weiBalances,\r\n            thread.tokenBalances,\r\n            thread.txCount\r\n        );\r\n    }\r\n\r\n    // either party starts exit with offchain state\r\n    function startExitThreadWithUpdate(\r\n        address user,\r\n        address[2] threadMembers, //[sender, receiver]\r\n        uint256 threadId,\r\n        uint256[2] weiBalances, // [sender, receiver]\r\n        uint256[2] tokenBalances, // [sender, receiver]\r\n        bytes proof,\r\n        string sig,\r\n        uint256[2] updatedWeiBalances, // [sender, receiver]\r\n        uint256[2] updatedTokenBalances, // [sender, receiver]\r\n        uint256 updatedTxCount,\r\n        string updateSig\r\n    ) public noReentrancy {\r\n        Channel storage channel = channels[user];\r\n        require(channel.status == ChannelStatus.ThreadDispute, \"channel must be in thread dispute phase\");\r\n        require(msg.sender == hub || msg.sender == user, \"thread exit initiator must be user or hub\");\r\n        require(user == threadMembers[0] || user == threadMembers[1], \"user must be thread sender or receiver\");\r\n\r\n        require(weiBalances[1] == 0 && tokenBalances[1] == 0, \"initial receiver balances must be zero\");\r\n\r\n        Thread storage thread = threads[threadMembers[0]][threadMembers[1]][threadId];\r\n        require(thread.threadClosingTime == 0, \"thread closing time must be zero\");\r\n\r\n        _verifyThread(threadMembers[0], threadMembers[1], threadId, weiBalances, tokenBalances, 0, proof, sig, channel.threadRoot);\r\n\r\n        // *********************\r\n        // PROCESS THREAD UPDATE\r\n        // *********************\r\n\r\n        require(updatedTxCount > 0, \"updated thread txCount must be higher than 0\");\r\n        require(updatedWeiBalances[0].add(updatedWeiBalances[1]) == weiBalances[0], \"sum of updated wei balances must match sender's initial wei balance\");\r\n        require(updatedTokenBalances[0].add(updatedTokenBalances[1]) == tokenBalances[0], \"sum of updated token balances must match sender's initial token balance\");\r\n\r\n        // Note: explicitly set threadRoot == 0x0 because then it doesn't get checked by _isContained (updated state is not part of root)\r\n        _verifyThread(threadMembers[0], threadMembers[1], threadId, updatedWeiBalances, updatedTokenBalances, updatedTxCount, \"\", updateSig, bytes32(0x0));\r\n\r\n        thread.weiBalances = updatedWeiBalances;\r\n        thread.tokenBalances = updatedTokenBalances;\r\n        thread.txCount = updatedTxCount;\r\n        thread.threadClosingTime = now.add(challengePeriod);\r\n\r\n        emit DidStartExitThread(\r\n            user,\r\n            threadMembers[0],\r\n            threadMembers[1],\r\n            threadId,\r\n            msg.sender == hub ? 0 : 1,\r\n            thread.weiBalances,\r\n            thread.tokenBalances,\r\n            thread.txCount\r\n        );\r\n    }\r\n\r\n    // either hub, sender, or receiver can update the thread state in place\r\n    function challengeThread(\r\n        address sender,\r\n        address receiver,\r\n        uint256 threadId,\r\n        uint256[2] weiBalances, // updated weiBalances\r\n        uint256[2] tokenBalances, // updated tokenBalances\r\n        uint256 txCount,\r\n        string sig\r\n    ) public noReentrancy {\r\n        require(msg.sender == hub || msg.sender == sender || msg.sender == receiver, \"only hub, sender, or receiver can call this function\");\r\n\r\n        Thread storage thread = threads[sender][receiver][threadId];\r\n        //verify that thread settlement period has not yet expired\r\n        require(now < thread.threadClosingTime, \"thread closing time must not have passed\");\r\n\r\n        // assumes that the non-sender has a later thread state than what was being proposed when the thread exit started\r\n        require(txCount > thread.txCount, \"thread txCount must be higher than the current thread txCount\");\r\n        require(weiBalances[0].add(weiBalances[1]) == thread.weiBalances[0].add(thread.weiBalances[1]), \"updated wei balances must match sum of thread wei balances\");\r\n        require(tokenBalances[0].add(tokenBalances[1]) == thread.tokenBalances[0].add(thread.tokenBalances[1]), \"updated token balances must match sum of thread token balances\");\r\n\r\n        require(weiBalances[1] >= thread.weiBalances[1] && tokenBalances[1] >= thread.tokenBalances[1], \"receiver balances may never decrease\");\r\n\r\n        // Note: explicitly set threadRoot == 0x0 because then it doesn't get checked by _isContained (updated state is not part of root)\r\n        _verifyThread(sender, receiver, threadId, weiBalances, tokenBalances, txCount, \"\", sig, bytes32(0x0));\r\n\r\n        // save the thread balances and txCount\r\n        thread.weiBalances = weiBalances;\r\n        thread.tokenBalances = tokenBalances;\r\n        thread.txCount = txCount;\r\n\r\n        emit DidChallengeThread(\r\n            sender,\r\n            receiver,\r\n            threadId,\r\n            msg.sender,\r\n            thread.weiBalances,\r\n            thread.tokenBalances,\r\n            thread.txCount\r\n        );\r\n    }\r\n\r\n    //After the thread state has been finalized onchain, emptyThread can be called to withdraw funds for each channel separately.\r\n    function emptyThread(\r\n        address user,\r\n        address sender,\r\n        address receiver,\r\n        uint256 threadId,\r\n        uint256[2] weiBalances, // [sender, receiver] -> initial balances\r\n        uint256[2] tokenBalances, // [sender, receiver] -> initial balances\r\n        bytes proof,\r\n        string sig\r\n    ) public noReentrancy {\r\n        Channel storage channel = channels[user];\r\n        require(channel.status == ChannelStatus.ThreadDispute, \"channel must be in thread dispute\");\r\n        require(msg.sender == hub || msg.sender == user, \"only hub or user can empty thread\");\r\n        require(user == sender || user == receiver, \"user must be thread sender or receiver\");\r\n\r\n        require(weiBalances[1] == 0 && tokenBalances[1] == 0, \"initial receiver balances must be zero\");\r\n\r\n        Thread storage thread = threads[sender][receiver][threadId];\r\n\r\n        // We check to make sure that the thread state has been finalized\r\n        require(thread.threadClosingTime != 0 && thread.threadClosingTime < now, \"Thread closing time must have passed\");\r\n\r\n        // Make sure user has not emptied before\r\n        require(!thread.emptied[user == sender ? 0 : 1], \"user cannot empty twice\");\r\n\r\n        // verify initial thread state.\r\n        _verifyThread(sender, receiver, threadId, weiBalances, tokenBalances, 0, proof, sig, channel.threadRoot);\r\n\r\n        require(thread.weiBalances[0].add(thread.weiBalances[1]) == weiBalances[0], \"sum of thread wei balances must match sender's initial wei balance\");\r\n        require(thread.tokenBalances[0].add(thread.tokenBalances[1]) == tokenBalances[0], \"sum of thread token balances must match sender's initial token balance\");\r\n\r\n        // deduct sender/receiver wei/tokens about to be emptied from the thread from the total channel balances\r\n        channel.weiBalances[2] = channel.weiBalances[2].sub(thread.weiBalances[0]).sub(thread.weiBalances[1]);\r\n        channel.tokenBalances[2] = channel.tokenBalances[2].sub(thread.tokenBalances[0]).sub(thread.tokenBalances[1]);\r\n\r\n        // deduct wei balances from total channel wei and reset thread balances\r\n        totalChannelWei = totalChannelWei.sub(thread.weiBalances[0]).sub(thread.weiBalances[1]);\r\n\r\n        // if user is receiver, send them receiver wei balance\r\n        if (user == receiver) {\r\n            user.transfer(thread.weiBalances[1]);\r\n        // if user is sender, send them remaining sender wei balance\r\n        } else if (user == sender) {\r\n            user.transfer(thread.weiBalances[0]);\r\n        }\r\n\r\n        // deduct token balances from channel total balances and reset thread balances\r\n        totalChannelToken = totalChannelToken.sub(thread.tokenBalances[0]).sub(thread.tokenBalances[1]);\r\n\r\n        // if user is receiver, send them receiver token balance\r\n        if (user == receiver) {\r\n            require(approvedToken.transfer(user, thread.tokenBalances[1]), \"user [receiver] token withdrawal transfer failed\");\r\n        // if user is sender, send them remaining sender token balance\r\n        } else if (user == sender) {\r\n            require(approvedToken.transfer(user, thread.tokenBalances[0]), \"user [sender] token withdrawal transfer failed\");\r\n        }\r\n\r\n        // Record that user has emptied\r\n        thread.emptied[user == sender ? 0 : 1] = true;\r\n\r\n        // decrement the channel threadCount\r\n        channel.threadCount = channel.threadCount.sub(1);\r\n\r\n        // if this is the last thread being emptied, re-open the channel\r\n        if (channel.threadCount == 0) {\r\n            channel.threadRoot = bytes32(0x0);\r\n            channel.channelClosingTime = 0;\r\n            channel.status = ChannelStatus.Open;\r\n        }\r\n\r\n        emit DidEmptyThread(\r\n            user,\r\n            sender,\r\n            receiver,\r\n            threadId,\r\n            msg.sender,\r\n            [channel.weiBalances[0], channel.weiBalances[1]],\r\n            [channel.tokenBalances[0], channel.tokenBalances[1]],\r\n            channel.txCount,\r\n            channel.threadRoot,\r\n            channel.threadCount\r\n        );\r\n    }\r\n\r\n\r\n    // anyone can call to re-open an account stuck in threadDispute after 10x challengePeriods from channel state finalization\r\n    function nukeThreads(\r\n        address user\r\n    ) public noReentrancy {\r\n        require(user != hub, \"user can not be hub\");\r\n        require(user != address(this), \"user can not be channel manager\");\r\n\r\n        Channel storage channel = channels[user];\r\n        require(channel.status == ChannelStatus.ThreadDispute, \"channel must be in thread dispute\");\r\n        require(channel.channelClosingTime.add(challengePeriod.mul(10)) < now, \"channel closing time must have passed by 10 challenge periods\");\r\n\r\n        // transfer any remaining channel wei to user\r\n        totalChannelWei = totalChannelWei.sub(channel.weiBalances[2]);\r\n        user.transfer(channel.weiBalances[2]);\r\n        uint256 weiAmount = channel.weiBalances[2];\r\n        channel.weiBalances[2] = 0;\r\n\r\n        // transfer any remaining channel tokens to user\r\n        totalChannelToken = totalChannelToken.sub(channel.tokenBalances[2]);\r\n        require(approvedToken.transfer(user, channel.tokenBalances[2]), \"user token withdrawal transfer failed\");\r\n        uint256 tokenAmount = channel.tokenBalances[2];\r\n        channel.tokenBalances[2] = 0;\r\n\r\n        // reset channel params\r\n        channel.threadCount = 0;\r\n        channel.threadRoot = bytes32(0x0);\r\n        channel.channelClosingTime = 0;\r\n        channel.status = ChannelStatus.Open;\r\n\r\n        emit DidNukeThreads(\r\n            user,\r\n            msg.sender,\r\n            weiAmount,\r\n            tokenAmount,\r\n            [channel.weiBalances[0], channel.weiBalances[1]],\r\n            [channel.tokenBalances[0], channel.tokenBalances[1]],\r\n            channel.txCount,\r\n            channel.threadRoot,\r\n            channel.threadCount\r\n        );\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    // ******************\r\n    // INTERNAL FUNCTIONS\r\n    // ******************\r\n\r\n    function _verifyAuthorizedUpdate(\r\n        Channel storage channel,\r\n        uint256[2] txCount,\r\n        uint256[2] weiBalances,\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[4] pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[4] pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256 timeout,\r\n        bool isHub\r\n    ) internal view {\r\n        require(channel.status == ChannelStatus.Open, \"channel must be open\");\r\n\r\n        // Usage:\r\n        // 1. exchange operations to protect user from exchange rate fluctuations\r\n        // 2. protects hub against user delaying forever\r\n        require(timeout == 0 || now < timeout, \"the timeout must be zero or not have passed\");\r\n\r\n        require(txCount[0] > channel.txCount[0], \"global txCount must be higher than the current global txCount\");\r\n        require(txCount[1] >= channel.txCount[1], \"onchain txCount must be higher or equal to the current onchain txCount\");\r\n\r\n        // offchain wei/token balances do not exceed onchain total wei/token\r\n        require(weiBalances[0].add(weiBalances[1]) <= channel.weiBalances[2], \"wei must be conserved\");\r\n        require(tokenBalances[0].add(tokenBalances[1]) <= channel.tokenBalances[2], \"tokens must be conserved\");\r\n\r\n        // hub has enough reserves for wei/token deposits for both the user and itself (if isHub, user deposit comes from hub)\r\n        if (isHub) {\r\n            require(pendingWeiUpdates[0].add(pendingWeiUpdates[2]) <= getHubReserveWei(), \"insufficient reserve wei for deposits\");\r\n            require(pendingTokenUpdates[0].add(pendingTokenUpdates[2]) <= getHubReserveTokens(), \"insufficient reserve tokens for deposits\");\r\n        // hub has enough reserves for only its own wei/token deposits\r\n        } else {\r\n            require(pendingWeiUpdates[0] <= getHubReserveWei(), \"insufficient reserve wei for deposits\");\r\n            require(pendingTokenUpdates[0] <= getHubReserveTokens(), \"insufficient reserve tokens for deposits\");\r\n        }\r\n\r\n        // wei is conserved - the current total channel wei + both deposits > final balances + both withdrawals\r\n        require(channel.weiBalances[2].add(pendingWeiUpdates[0]).add(pendingWeiUpdates[2]) >=\r\n                weiBalances[0].add(weiBalances[1]).add(pendingWeiUpdates[1]).add(pendingWeiUpdates[3]), \"insufficient wei\");\r\n\r\n        // token is conserved - the current total channel token + both deposits > final balances + both withdrawals\r\n        require(channel.tokenBalances[2].add(pendingTokenUpdates[0]).add(pendingTokenUpdates[2]) >=\r\n                tokenBalances[0].add(tokenBalances[1]).add(pendingTokenUpdates[1]).add(pendingTokenUpdates[3]), \"insufficient token\");\r\n    }\r\n\r\n    function _applyPendingUpdates(\r\n        uint256[3] storage channelBalances,\r\n        uint256[2] balances,\r\n        uint256[4] pendingUpdates\r\n    ) internal {\r\n        // update hub balance\r\n        // If the deposit is greater than the withdrawal, add the net of deposit minus withdrawal to the balances.\r\n        // Assumes the net has *not yet* been added to the balances.\r\n        if (pendingUpdates[0] > pendingUpdates[1]) {\r\n            channelBalances[0] = balances[0].add(pendingUpdates[0].sub(pendingUpdates[1]));\r\n        // Otherwise, if the deposit is less than or equal to the withdrawal,\r\n        // Assumes the net has *already* been added to the balances.\r\n        } else {\r\n            channelBalances[0] = balances[0];\r\n        }\r\n\r\n        // update user balance\r\n        // If the deposit is greater than the withdrawal, add the net of deposit minus withdrawal to the balances.\r\n        // Assumes the net has *not yet* been added to the balances.\r\n        if (pendingUpdates[2] > pendingUpdates[3]) {\r\n            channelBalances[1] = balances[1].add(pendingUpdates[2].sub(pendingUpdates[3]));\r\n\r\n        // Otherwise, if the deposit is less than or equal to the withdrawal,\r\n        // Assumes the net has *already* been added to the balances.\r\n        } else {\r\n            channelBalances[1] = balances[1];\r\n        }\r\n    }\r\n\r\n    function _revertPendingUpdates(\r\n        uint256[3] storage channelBalances,\r\n        uint256[2] balances,\r\n        uint256[4] pendingUpdates\r\n    ) internal {\r\n        // If the pending update has NOT been executed AND deposits > withdrawals, offchain state was NOT updated with delta, and is thus correct\r\n        if (pendingUpdates[0] > pendingUpdates[1]) {\r\n            channelBalances[0] = balances[0];\r\n\r\n        // If the pending update has NOT been executed AND deposits < withdrawals, offchain state should have been updated with delta, and must be reverted\r\n        } else {\r\n            channelBalances[0] = balances[0].add(pendingUpdates[1].sub(pendingUpdates[0])); // <- add withdrawal, sub deposit (opposite order as _applyPendingUpdates)\r\n        }\r\n\r\n        // If the pending update has NOT been executed AND deposits > withdrawals, offchain state was NOT updated with delta, and is thus correct\r\n        if (pendingUpdates[2] > pendingUpdates[3]) {\r\n            channelBalances[1] = balances[1];\r\n\r\n        // If the pending update has NOT been executed AND deposits > withdrawals, offchain state should have been updated with delta, and must be reverted\r\n        } else {\r\n            channelBalances[1] = balances[1].add(pendingUpdates[3].sub(pendingUpdates[2])); // <- add withdrawal, sub deposit (opposite order as _applyPendingUpdates)\r\n        }\r\n    }\r\n\r\n    function _updateChannelBalances(\r\n        Channel storage channel,\r\n        uint256[2] weiBalances,\r\n        uint256[2] tokenBalances,\r\n        uint256[4] pendingWeiUpdates,\r\n        uint256[4] pendingTokenUpdates\r\n    ) internal {\r\n        _applyPendingUpdates(channel.weiBalances, weiBalances, pendingWeiUpdates);\r\n        _applyPendingUpdates(channel.tokenBalances, tokenBalances, pendingTokenUpdates);\r\n\r\n        totalChannelWei = totalChannelWei.add(pendingWeiUpdates[0]).add(pendingWeiUpdates[2]).sub(pendingWeiUpdates[1]).sub(pendingWeiUpdates[3]);\r\n        totalChannelToken = totalChannelToken.add(pendingTokenUpdates[0]).add(pendingTokenUpdates[2]).sub(pendingTokenUpdates[1]).sub(pendingTokenUpdates[3]);\r\n\r\n        // update channel total balances\r\n        channel.weiBalances[2] = channel.weiBalances[2].add(pendingWeiUpdates[0]).add(pendingWeiUpdates[2]).sub(pendingWeiUpdates[1]).sub(pendingWeiUpdates[3]);\r\n        channel.tokenBalances[2] = channel.tokenBalances[2].add(pendingTokenUpdates[0]).add(pendingTokenUpdates[2]).sub(pendingTokenUpdates[1]).sub(pendingTokenUpdates[3]);\r\n    }\r\n\r\n    function _verifySig (\r\n        address[2] user, // [user, recipient]\r\n        uint256[2] weiBalances, // [hub, user]\r\n        uint256[2] tokenBalances, // [hub, user]\r\n        uint256[4] pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[4] pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n        uint256[2] txCount, // [global, onchain] persisted onchain even when empty\r\n        bytes32 threadRoot,\r\n        uint256 threadCount,\r\n        uint256 timeout,\r\n        string sigHub,\r\n        string sigUser,\r\n        bool[2] checks // [checkHubSig?, checkUserSig?]\r\n    ) internal view {\r\n        require(user[0] != hub, \"user can not be hub\");\r\n        require(user[0] != address(this), \"user can not be channel manager\");\r\n\r\n        // prepare state hash to check hub sig\r\n        bytes32 state = keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                user, // [user, recipient]\r\n                weiBalances, // [hub, user]\r\n                tokenBalances, // [hub, user]\r\n                pendingWeiUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n                pendingTokenUpdates, // [hubDeposit, hubWithdrawal, userDeposit, userWithdrawal]\r\n                txCount, // persisted onchain even when empty\r\n                threadRoot,\r\n                threadCount,\r\n                timeout\r\n            )\r\n        );\r\n\r\n        if (checks[0]) {\r\n            require(hub == ECTools.recoverSigner(state, sigHub), \"hub signature invalid\");\r\n        }\r\n\r\n        if (checks[1]) {\r\n            require(user[0] == ECTools.recoverSigner(state, sigUser), \"user signature invalid\");\r\n        }\r\n    }\r\n\r\n    function _verifyThread(\r\n        address sender,\r\n        address receiver,\r\n        uint256 threadId,\r\n        uint256[2] weiBalances,\r\n        uint256[2] tokenBalances,\r\n        uint256 txCount,\r\n        bytes proof,\r\n        string sig,\r\n        bytes32 threadRoot\r\n    ) internal view {\r\n        require(sender != receiver, \"sender can not be receiver\");\r\n        require(sender != hub && receiver != hub, \"hub can not be sender or receiver\");\r\n        require(sender != address(this) && receiver != address(this), \"channel manager can not be sender or receiver\");\r\n\r\n        bytes32 state = keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                sender,\r\n                receiver,\r\n                threadId,\r\n                weiBalances, // [sender, receiver]\r\n                tokenBalances, // [sender, receiver]\r\n                txCount // persisted onchain even when empty\r\n            )\r\n        );\r\n        require(ECTools.isSignedBy(state, sig, sender), \"signature invalid\");\r\n\r\n        if (threadRoot != bytes32(0x0)) {\r\n            require(_isContained(state, proof, threadRoot), \"initial thread state is not contained in threadRoot\");\r\n        }\r\n    }\r\n\r\n    function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\r\n        bytes32 cursor = _hash;\r\n        bytes32 proofElem;\r\n\r\n        for (uint256 i = 64; i <= _proof.length; i += 32) {\r\n            assembly { proofElem := mload(add(_proof, i)) }\r\n\r\n            if (cursor < proofElem) {\r\n                cursor = keccak256(abi.encodePacked(cursor, proofElem));\r\n            } else {\r\n                cursor = keccak256(abi.encodePacked(proofElem, cursor));\r\n            }\r\n        }\r\n\r\n        return cursor == _root;\r\n    }\r\n\r\n    function getChannelBalances(address user) constant public returns (\r\n        uint256 weiHub,\r\n        uint256 weiUser,\r\n        uint256 weiTotal,\r\n        uint256 tokenHub,\r\n        uint256 tokenUser,\r\n        uint256 tokenTotal\r\n    ) {\r\n        Channel memory channel = channels[user];\r\n        return (\r\n            channel.weiBalances[0],\r\n            channel.weiBalances[1],\r\n            channel.weiBalances[2],\r\n            channel.tokenBalances[0],\r\n            channel.tokenBalances[1],\r\n            channel.tokenBalances[2]\r\n        );\r\n    }\r\n\r\n    function getChannelDetails(address user) constant public returns (\r\n        uint256 txCountGlobal,\r\n        uint256 txCountChain,\r\n        bytes32 threadRoot,\r\n        uint256 threadCount,\r\n        address exitInitiator,\r\n        uint256 channelClosingTime,\r\n        ChannelStatus status\r\n    ) {\r\n        Channel memory channel = channels[user];\r\n        return (\r\n            channel.txCount[0],\r\n            channel.txCount[1],\r\n            channel.threadRoot,\r\n            channel.threadCount,\r\n            channel.exitInitiator,\r\n            channel.channelClosingTime,\r\n            channel.status\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalChannelWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"hubContractWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"threadMembers\",\"type\":\"address[2]\"},{\"name\":\"threadId\",\"type\":\"uint256\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"sig\",\"type\":\"string\"},{\"name\":\"updatedWeiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"updatedTokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"updatedTxCount\",\"type\":\"uint256\"},{\"name\":\"updateSig\",\"type\":\"string\"}],\"name\":\"startExitThreadWithUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"threadId\",\"type\":\"uint256\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"txCount\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"string\"}],\"name\":\"challengeThread\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalChannelToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hub\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getChannelBalances\",\"outputs\":[{\"name\":\"weiHub\",\"type\":\"uint256\"},{\"name\":\"weiUser\",\"type\":\"uint256\"},{\"name\":\"weiTotal\",\"type\":\"uint256\"},{\"name\":\"tokenHub\",\"type\":\"uint256\"},{\"name\":\"tokenUser\",\"type\":\"uint256\"},{\"name\":\"tokenTotal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"emptyChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"pendingWeiUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"pendingTokenUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"txCount\",\"type\":\"uint256[2]\"},{\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"name\":\"threadCount\",\"type\":\"uint256\"},{\"name\":\"timeout\",\"type\":\"uint256\"},{\"name\":\"sigUser\",\"type\":\"string\"}],\"name\":\"hubAuthorizedUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address[2]\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"pendingWeiUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"pendingTokenUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"txCount\",\"type\":\"uint256[2]\"},{\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"name\":\"threadCount\",\"type\":\"uint256\"},{\"name\":\"timeout\",\"type\":\"uint256\"},{\"name\":\"sigHub\",\"type\":\"string\"},{\"name\":\"sigUser\",\"type\":\"string\"}],\"name\":\"startExitWithUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"startExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getChannelDetails\",\"outputs\":[{\"name\":\"txCountGlobal\",\"type\":\"uint256\"},{\"name\":\"txCountChain\",\"type\":\"uint256\"},{\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"name\":\"threadCount\",\"type\":\"uint256\"},{\"name\":\"exitInitiator\",\"type\":\"address\"},{\"name\":\"channelClosingTime\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"nukeThreads\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"channels\",\"outputs\":[{\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"name\":\"threadCount\",\"type\":\"uint256\"},{\"name\":\"exitInitiator\",\"type\":\"address\"},{\"name\":\"channelClosingTime\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHubReserveTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address[2]\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"pendingWeiUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"pendingTokenUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"txCount\",\"type\":\"uint256[2]\"},{\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"name\":\"threadCount\",\"type\":\"uint256\"},{\"name\":\"timeout\",\"type\":\"uint256\"},{\"name\":\"sigHub\",\"type\":\"string\"},{\"name\":\"sigUser\",\"type\":\"string\"}],\"name\":\"emptyChannelWithChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHubReserveWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"threadId\",\"type\":\"uint256\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"sig\",\"type\":\"string\"}],\"name\":\"emptyThread\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"threadId\",\"type\":\"uint256\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"sig\",\"type\":\"string\"}],\"name\":\"startExitThread\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"name\":\"pendingWeiUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"pendingTokenUpdates\",\"type\":\"uint256[4]\"},{\"name\":\"txCount\",\"type\":\"uint256[2]\"},{\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"name\":\"threadCount\",\"type\":\"uint256\"},{\"name\":\"timeout\",\"type\":\"uint256\"},{\"name\":\"sigHub\",\"type\":\"string\"}],\"name\":\"userAuthorizedUpdate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_hub\",\"type\":\"address\"},{\"name\":\"_challengePeriod\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"DidHubContractWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"senderIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"pendingWeiUpdates\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"name\":\"pendingTokenUpdates\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"name\":\"txCount\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"threadCount\",\"type\":\"uint256\"}],\"name\":\"DidUpdateChannel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"senderIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"txCount\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"threadCount\",\"type\":\"uint256\"}],\"name\":\"DidStartExitChannel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"senderIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"txCount\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"threadRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"threadCount\",\"type\":\"uint256\"}],\"name\":\"DidEmptyChannel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"threadId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"txCount\",\"type\":\"uint256\"}],\"name\":\"DidStartExitThread\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"threadId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"tokenBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"txCount\",\"type\":\"uint256\"}],\"name\":\"DidChallengeThread\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"threadId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"channelWeiBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"channelTokenBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"channelTxCount\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"channelThreadRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"channelThreadCount\",\"type\":\"uint256\"}],\"name\":\"DidEmptyThread\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"channelWeiBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"channelTokenBalances\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"channelTxCount\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"channelThreadRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"channelThreadCount\",\"type\":\"uint256\"}],\"name\":\"DidNukeThreads\",\"type\":\"event\"}]","ContractName":"ChannelManager","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"000000000000000000000000526d0cd57a8b977d3628f12cdeceab12dd49297c00000000000000000000000000000000000000000000000000000000000151800000000000000000000000006b01c3170ae1efebee1a3159172cb3f7a5ecf9e5","Library":"ECTools:b01c6adaf785f06f2c01bcfe782e30ceefa90a26","SwarmSource":"bzzr://346bdebc5b65e540f2c06b10af9e3b0da5200dccdafe3e47d580b94d094ebdf9"}]}