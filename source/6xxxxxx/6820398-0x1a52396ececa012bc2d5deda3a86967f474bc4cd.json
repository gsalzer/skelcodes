{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: solidity-rlp/contracts/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.4.24;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        if (item.length == 0) \r\n            return RLPItem(0, 0);\r\n\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Helpers\r\n    */\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) internal pure returns (uint) {\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) internal pure returns (uint len) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            return byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            return byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) internal pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes) {\r\n        bytes memory result = new bytes(item.len);\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1, \"Invalid RLPItem. Booleans are encoded in 1 byte\");\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix according to RLP spec\r\n        require(item.len <= 21, \"Invalid RLPItem. Addresses are encoded in 20 bytes or less\");\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n        uint memPtr = item.memPtr + offset;\r\n\r\n        uint result;\r\n        assembly {\r\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) internal pure {\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BetStorage.sol\r\n\r\n/**\r\n * @title ClashHash\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without\r\n * express written consent from the creators is prohibited.\r\n */\r\n\r\n\r\n\r\n\r\ncontract BetStorage is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => mapping(address => uint256)) public bets;\r\n    mapping(address => uint256) public betsSumByOption;\r\n    mapping(address => uint256) public betsSumByUser;\r\n    address public wonOption;\r\n\r\n    event BetAdded(address indexed user, address indexed option, uint256 value);\r\n    event Finalized(address indexed option);\r\n    event RewardClaimed(address indexed user, uint256 reward);\r\n    \r\n    function addBet(address user, address option) public payable onlyOwner {\r\n        require(msg.value > 0, \"Empty bet is not allowed\");\r\n        require(betsSumByUser[user] > 0 || bets[user][option] == 0, \"Deny different bets for single user\");\r\n\r\n        bets[user][option] = bets[user][option].add(msg.value);\r\n        betsSumByOption[option] = betsSumByOption[option].add(msg.value);\r\n        betsSumByUser[user] = betsSumByUser[user].add(msg.value);\r\n        emit BetAdded(user, option, msg.value);\r\n    }\r\n\r\n    function finalize(address option, uint256 fee) public onlyOwner {\r\n        require(wonOption == address(0), \"Finalization could be called only once\");\r\n        require(option != address(0), \"Won option should not be zero\");\r\n\r\n        wonOption = option;\r\n        emit Finalized(option);\r\n\r\n        if (betsSumByOption[option] == 0) {\r\n            selfdestruct(msg.sender);\r\n        } else {\r\n            msg.sender.transfer(address(this).balance.mul(fee).div(100));\r\n        }\r\n    }\r\n\r\n    function claimReward(address user) public onlyOwner returns(uint256 reward) {\r\n        require(wonOption != address(0), \"Round not yet finalized\");\r\n\r\n        reward = address(this).balance.mul(bets[user][wonOption]).div(betsSumByOption[wonOption]);\r\n        require(reward > 0, \"Reward was claimed previously or never existed\");\r\n        betsSumByOption[wonOption] = betsSumByOption[wonOption].sub(bets[user][wonOption]);\r\n        bets[user][wonOption] = 0;\r\n        user.transfer(reward);\r\n        emit RewardClaimed(user, reward);\r\n\r\n        if (betsSumByOption[wonOption] == 0) {\r\n            selfdestruct(msg.sender);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ClashHash.sol\r\n\r\n/**\r\n * @title ClashHash\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without\r\n * express written consent from the creators is prohibited.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ClashHash is Ownable {\r\n    using SafeMath for uint256;\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n    \r\n    struct Round {\r\n        BetStorage records;\r\n        uint256 usersCount;\r\n        uint256 betsCount;\r\n        uint256 totalReward;\r\n        address winner;\r\n    }\r\n\r\n    uint256 constant public MIN_BLOCKS_BEFORE_ROUND = 10;\r\n    uint256 constant public MIN_BLOCKS_AFTER_ROUND = 10;\r\n    uint256 constant public MAX_BLOCKS_AFTER_ROUND = 256;\r\n\r\n    uint256 constant public ADMIN_FEE = 5;\r\n    uint256 constant public JACKPOT_FEE = 10;\r\n    uint256 constant public ADMIN_FEE_NOONE_WON = 10;\r\n    uint256 constant public JACKPOT_FEE_NOONE_WON = 90;\r\n\r\n    mapping(uint256 => Round) public rounds;\r\n    address private _allowedSender;\r\n    address private _admin = msg.sender;\r\n\r\n    //\r\n\r\n    event RoundCreated(uint256 indexed blockNumber, address contractAddress);\r\n    event RoundBetAdded(uint256 indexed blockNumber, address indexed user, address indexed option, uint256 value);\r\n    event RoundFinalized(uint256 indexed blockNumber, address indexed option);\r\n    event RewardClaimed(uint256 indexed blockNumber, address indexed user, uint256 reward);\r\n\r\n    //\r\n\r\n    function () public payable {\r\n        require(msg.sender == _allowedSender, \"Do not send ETH directly to the contract\");\r\n    }\r\n\r\n    function addBet(uint256 blockNumber, address option) public payable {\r\n        require(block.number <= blockNumber - MIN_BLOCKS_BEFORE_ROUND, \"It's too late\");\r\n\r\n        Round storage round = rounds[blockNumber];\r\n        if (round.records == address(0)) {\r\n            round.records = new BetStorage();\r\n            emit RoundCreated(blockNumber, round.records);\r\n        }\r\n\r\n        if (round.records.betsSumByUser(msg.sender) == 0) {\r\n            round.usersCount += 1;\r\n        }\r\n        round.betsCount += 1;\r\n        round.totalReward = round.totalReward.add(msg.value);\r\n        round.records.addBet.value(msg.value)(msg.sender, option);\r\n\r\n        emit RoundBetAdded(\r\n            blockNumber,\r\n            msg.sender,\r\n            option,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    function claimRewardWithBlockData(uint256 blockNumber, bytes blockData) public {\r\n        if (blockData.length > 0 && rounds[blockNumber].winner == address(0)) {\r\n            addBlockData(blockNumber, blockData);\r\n        }\r\n\r\n        claimRewardForUser(blockNumber, msg.sender);\r\n    }\r\n\r\n    function claimRewardForUser(uint256 blockNumber, address user) public {\r\n        Round storage round = rounds[blockNumber];\r\n        require(round.records.wonOption() != address(0), \"Round not yet finished\");\r\n\r\n        uint256 reward = round.records.claimReward(user);\r\n        emit RewardClaimed(blockNumber, user, reward);\r\n    }\r\n\r\n    function read(bytes data, uint i) public pure returns(uint) {\r\n        RLPReader.RLPItem[] memory items = data.toRlpItem().toList();\r\n        return items[i].toUint();\r\n    }\r\n\r\n    function addBlockData(uint256 blockNumber, bytes blockData) public {\r\n        require(block.number <= blockNumber + MAX_BLOCKS_AFTER_ROUND, \"It's too late, 256 blocks gone\");\r\n        require(block.number >= blockNumber + MIN_BLOCKS_AFTER_ROUND, \"Wait at least 10 blocks\");\r\n        require(keccak256(blockData) == blockhash(blockNumber), \"Block data isn't valid\");\r\n\r\n        RLPReader.RLPItem[] memory items = blockData.toRlpItem().toList();\r\n        address blockBeneficiary = items[2].toAddress();\r\n\r\n        Round storage round = rounds[blockNumber];\r\n        round.winner = blockBeneficiary;\r\n        emit RoundFinalized(blockNumber, blockBeneficiary);\r\n        bool noOneWon = (round.records.betsSumByOption(blockBeneficiary) == 0);\r\n        uint256 roundBalance = address(round.records).balance;\r\n        \r\n        _allowedSender = round.records;\r\n        round.records.finalize(blockBeneficiary, ADMIN_FEE.add(JACKPOT_FEE));\r\n        delete _allowedSender;\r\n\r\n        if (noOneWon) {\r\n            _admin.transfer(roundBalance.mul(ADMIN_FEE_NOONE_WON).div(100));\r\n        } else {\r\n            _admin.transfer(roundBalance.mul(ADMIN_FEE).div(100));\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"blockData\",\"type\":\"bytes\"}],\"name\":\"claimRewardWithBlockData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"blockData\",\"type\":\"bytes\"}],\"name\":\"addBlockData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BLOCKS_BEFORE_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"read\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimRewardForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BLOCKS_AFTER_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_FEE_NOONE_WON\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"records\",\"type\":\"address\"},{\"name\":\"usersCount\",\"type\":\"uint256\"},{\"name\":\"betsCount\",\"type\":\"uint256\"},{\"name\":\"totalReward\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BLOCKS_AFTER_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN_FEE_NOONE_WON\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"option\",\"type\":\"address\"}],\"name\":\"addBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"option\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RoundBetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"option\",\"type\":\"address\"}],\"name\":\"RoundFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ClashHash","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2e5cb35f3858babc04a5448b9113da9a1f8ce6c322b5e682fc7c32b345a49f52"}]}