{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ninterface AbstractENS {\r\n    function owner(bytes32 _node) public constant returns (address);\r\n    function resolver(bytes32 _node) public constant returns (address);\r\n    function ttl(bytes32 _node) public constant returns (uint64);\r\n    function setOwner(bytes32 _node, address _owner) public;\r\n    function setSubnodeOwner(bytes32 _node, bytes32 label, address _owner) public;\r\n    function setResolver(bytes32 _node, address _resolver) public;\r\n    function setTTL(bytes32 _node, uint64 _ttl) public;\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed _node, bytes32 indexed _label, address _owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed _node, address _owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed _node, address _resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed _node, uint64 _ttl);\r\n}\r\n\r\npragma solidity ^0.4.0;\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver {\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\r\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\r\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    struct Record {\r\n        address addr;\r\n        bytes32 content;\r\n        string name;\r\n        PublicKey pubkey;\r\n        mapping(string=>string) text;\r\n        mapping(uint256=>bytes) abis;\r\n    }\r\n\r\n    AbstractENS ens;\r\n    mapping(bytes32=>Record) records;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        if (ens.owner(node) != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    function PublicResolver(AbstractENS ensAddr) public {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n               interfaceID == CONTENT_INTERFACE_ID ||\r\n               interfaceID == NAME_INTERFACE_ID ||\r\n               interfaceID == ABI_INTERFACE_ID ||\r\n               interfaceID == PUBKEY_INTERFACE_ID ||\r\n               interfaceID == TEXT_INTERFACE_ID ||\r\n               interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public constant returns (address ret) {\r\n        ret = records[node].addr;\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) only_owner(node) public {\r\n        records[node].addr = addr;\r\n        AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) public constant returns (bytes32 ret) {\r\n        ret = records[node].content;\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) only_owner(node) public {\r\n        records[node].content = hash;\r\n        ContentChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) public constant returns (string ret) {\r\n        ret = records[node].name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string name) only_owner(node) public {\r\n        records[node].name = name;\r\n        NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) public constant returns (uint256 contentType, bytes data) {\r\n        var record = records[node];\r\n        for(contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\r\n                data = record.abis[contentType];\r\n                return;\r\n            }\r\n        }\r\n        contentType = 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes data) only_owner(node) public {\r\n        // Content types must be powers of 2\r\n        if (((contentType - 1) & contentType) != 0) throw;\r\n\r\n        records[node].abis[contentType] = data;\r\n        ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) public constant returns (bytes32 x, bytes32 y) {\r\n        return (records[node].pubkey.x, records[node].pubkey.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) only_owner(node) public {\r\n        records[node].pubkey = PublicKey(x, y);\r\n        PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string key) public constant returns (string ret) {\r\n        ret = records[node].text[key];\r\n    }\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string key, string value) only_owner(node) public {\r\n        records[node].text[key] = value;\r\n        TextChanged(node, key, key);\r\n    }\r\n}\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ENSConstants {\r\n    bytes32 constant public ENS_ROOT = bytes32(0);\r\n    bytes32 constant public ETH_TLD_LABEL = keccak256(\"eth\");\r\n    bytes32 constant public ETH_TLD_NODE = keccak256(abi.encodePacked(ENS_ROOT, ETH_TLD_LABEL));\r\n    bytes32 constant public PUBLIC_RESOLVER_LABEL = keccak256(\"resolver\");\r\n    bytes32 constant public PUBLIC_RESOLVER_NODE = keccak256(abi.encodePacked(ETH_TLD_NODE, PUBLIC_RESOLVER_LABEL));\r\n    address constant public PORTAL_NETWORK_RESOLVER = 0x1da022710dF5002339274AaDEe8D58218e9D6AB5;\r\n}\r\n\r\n\r\ncontract dwebregistry is ENSConstants {\r\n    \r\n    AbstractENS public ens = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b);\r\n    event NewDWeb(bytes32 indexed node, string label, string hash);\r\n\r\n    function createDWeb(bytes32 _rootNode, string _label, string dnslink, bytes32 content) external returns (bytes32 node) {\r\n        return _createDWeb(_rootNode, _label, msg.sender, dnslink, content);\r\n    }\r\n\r\n    function _createDWeb(bytes32 _rootNode, string _label, address _owner, string dnslink, bytes32 content) internal returns (bytes32 node) {\r\n        require(ens.owner(_rootNode) == address(this));\r\n\r\n        node = getNodeForLabel(_rootNode, getKeccak256Label(_label));\r\n        require(ens.owner(node) == address(0)); // avoid name reset\r\n        \r\n        ens.setSubnodeOwner(_rootNode, getKeccak256Label(_label), address(this));\r\n        \r\n        address publicResolver = getAddr(PUBLIC_RESOLVER_NODE);\r\n        ens.setResolver(node, publicResolver);\r\n\r\n        PublicResolver(publicResolver).setText(node,'dnslink', dnslink);\r\n        PublicResolver(publicResolver).setContent(node, content);\r\n        \r\n        ens.setSubnodeOwner(_rootNode, getKeccak256Label(_label), _owner);\r\n\r\n        emit NewDWeb(node, _label, dnslink);\r\n\r\n        return node;\r\n    }\r\n    \r\n    function getAddr(bytes32 node) internal view returns (address) {\r\n        address resolver = ens.resolver(node);\r\n        return PublicResolver(resolver).addr(node);\r\n    }\r\n    \r\n    function getNodeForLabel(bytes32 _rootNode, bytes32 _label) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_rootNode, _label));\r\n    }\r\n    \r\n    function getKeccak256Label(string _label) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_label));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PUBLIC_RESOLVER_NODE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rootNode\",\"type\":\"bytes32\"},{\"name\":\"_label\",\"type\":\"string\"},{\"name\":\"dnslink\",\"type\":\"string\"},{\"name\":\"content\",\"type\":\"bytes32\"}],\"name\":\"createDWeb\",\"outputs\":[{\"name\":\"node\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PORTAL_NETWORK_RESOLVER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_TLD_LABEL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ENS_ROOT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PUBLIC_RESOLVER_LABEL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_TLD_NODE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"label\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"string\"}],\"name\":\"NewDWeb\",\"type\":\"event\"}]","ContractName":"dwebregistry","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ce4b82a88f5330393c35314184131b01a96ccd407c73d053e0835dc0cca296fd"}]}