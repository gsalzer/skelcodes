{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n /**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  \r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract BattleBase is Ownable {\r\n\t using SafeMath for uint256;\r\n\t \r\n\t/***********************************************************************************/\r\n\t/* EVENTS\r\n\t/***********************************************************************************/\r\n\t\r\n\t/**\r\n\t* History sequence will be represented by uint256, in other words the max round is 256 (rounds more than this will decide on hp left or draw)\r\n\t*  1 is challenger attack\r\n\t*  2 is defender attack\r\n\t*  3 is challenger attack with critical\r\n\t*  4 is defender attack with critical\r\n\t*/\r\n\tevent BattleHistory(\r\n\t\tuint256 historyId,\r\n\t\tuint8 winner, // 0 - challenger; 1 - defender; 2 - draw;\r\n\t\tuint64 battleTime,\r\n\t\tuint256 sequence,\r\n\t\tuint256 blockNumber,\r\n\t\tuint256 tokensGained);\r\n\t\r\n\tevent BattleHistoryChallenger(\r\n\t\tuint256 historyId,\r\n\t\tuint256 cardId,\r\n\t\tuint8 element,\r\n\t\tuint16 level,\r\n\t\tuint32 attack,\r\n\t\tuint32 defense,\r\n\t\tuint32 hp,\r\n\t\tuint32 speed,\r\n\t\tuint32 criticalRate,\r\n\t\tuint256 rank);\r\n\t\t\r\n\tevent BattleHistoryDefender(\r\n\t\tuint256 historyId,\r\n\t\tuint256 cardId,\r\n\t\tuint8 element,\r\n\t\tuint16 level,\r\n\t\tuint32 attack,\r\n\t\tuint32 defense,\r\n\t\tuint32 hp,\r\n\t\tuint32 speed,\r\n\t\tuint16 criticalRate,\r\n\t\tuint256 rank);\r\n\t\r\n\tevent RejectChallenge(\r\n\t\tuint256 challengerId,\r\n\t\tuint256 defenderId,\r\n\t\tuint256 defenderRank,\r\n\t\tuint8 rejectCode,\r\n\t\tuint256 blockNumber);\r\n\t\t\r\n\tevent HashUpdated(\r\n\t\tuint256 cardId, \r\n\t\tuint256 cardHash);\r\n\t\t\r\n\tevent LevelUp(uint256 cardId);\r\n\t\r\n\tevent CardCreated(address owner, uint256 cardId);\r\n\t\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* CONST DATA\r\n\t/***********************************************************************************/\t\t\r\n\tuint32[] expToNextLevelArr = [0,103,103,207,207,207,414,414,414,414,724,724,724,828,828,931,931,1035,1035,1138,1138,1242,1242,1345,1345,1449,1449,1552,1552,1656,1656,1759,1759,1863,1863,1966,1966,2070,2070,2173,2173,2173,2277,2277,2380,2380,2484,2484,2587,2587,2691,2691,2794,2794,2898,2898,3001,3001,3105,3105,3208,3208,3312,3312,3415,3415,3519,3519,3622,3622,3622,3726,3726,3829,3829,3933,3933,4036,4036,4140,4140,4243,4243,4347,4347,4450,4450,4554,4554,4657,4657,4761,4761,4864,4864,4968,4968,5071,5071,5175];\r\n\t\r\n\tuint32[] activeWinExp = [10,11,14,19,26,35,46,59,74,91,100,103,108,116,125,135,146,158,171,185,200,215,231,248,265,283,302,321,341,361,382];\r\n\t\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* DATA VARIABLES\r\n\t/***********************************************************************************/\t\t\r\n\t//Card structure that holds all information for battle\r\n\tstruct Card {\r\n\t\tuint8 element; // 1 - fire; 2 - water; 3 - wood;    8 - light; 9 - dark;\r\n\t\tuint16 level; //\"unlimited\" level bound to uint16 Max level is 65535\r\n\t\tuint32 attack;\r\n\t\tuint32 defense;\r\n\t\tuint32 hp;\r\n\t\tuint32 speed;\r\n\t\tuint16 criticalRate; //max 8000\r\n\t\tuint32 flexiGems;\r\n\t\tuint256 cardHash;\r\n\t\tuint32 currentExp;\r\n\t\tuint32 expToNextLevel;\r\n\t\tuint64 createdDatetime;\r\n\r\n\t\tuint256 rank; //rank is n-1 (need to add 1 for display);\r\n\r\n\t\t//uint8 passiveSkill; //TBC\r\n\t}\r\n\t\r\n\t// Mapping from tokenId to Card Struct\r\n\tmapping (uint256 => Card) public cards;\r\n\t\r\n\tuint256[] ranking; //stores the token id according to array position starts from 0 (rank 1)\r\n\t\r\n\t// Mapping from rank to amount held in that rank (challenge tokens)\r\n\tmapping (uint256 => uint256) public rankTokens;\r\n\t\r\n\tuint8 public currentElement = 0; //start with 0 as +1 will become fire\r\n\t\r\n\tuint256 public historyId = 0;\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* CONFIGURATIONS\r\n\t/***********************************************************************************/\r\n\t/// @dev The address of the HogSmashToken\r\n\tHogSmashToken public hogsmashToken;\r\n\t\r\n\t/// @dev The address of the Marketplace\r\n\tMarketplace public marketplace;\r\n\t\t\t\r\n\t// Challenge fee changes on ranking difference\r\n\tuint256 public challengeFee;\r\n\r\n\t// Upgrade fee\r\n\tuint256 public upgradeFee;\r\n\t\r\n\t// Avatar fee\r\n\tuint256 public avatarFee;\r\n\t\r\n\t// Referrer fee in % (x10000)\r\n\tuint256 public referrerFee;\r\n\t\r\n\t// Developer Cut in % (x10000)\r\n\tuint256 public developerCut;\r\n\t\r\n\tuint256 internal totalDeveloperCut;\r\n\r\n\t// Price for each card draw (in wei)\r\n\tuint256 public cardDrawPrice;\r\n\r\n\t// Gems provided for upgrade every level up\r\n\tuint8 public upgradeGems; //\r\n\t// Gems provided for upgrade every 10 level up\r\n\tuint8 public upgradeGemsSpecial;\r\n\t// 1 Gem to attack conversion\r\n\tuint16 public gemAttackConversion;\r\n\t// 1 Gem to defense conversion\r\n\tuint16 public gemDefenseConversion;\r\n\t// 1 Gem to hp conversion\r\n\tuint16 public gemHpConversion;\r\n\t// 1 Gem to speed conversion\r\n\tuint16 public gemSpeedConversion;\r\n\t// 1 Gem to critical rate conversion divided by 100, eg 25 = 0.25\r\n\tuint16 public gemCriticalRateConversion;\r\n\t\r\n\t//% to get a gold card, 0 to 100\r\n\tuint8 public goldPercentage;\r\n\t\r\n\t//% to get a silver card, 0 to 100\r\n\tuint8 public silverPercentage;\r\n \t\r\n\t//Range of event card number 1-99999999\r\n\tuint32 public eventCardRangeMin;\r\n\t\r\n\t//Range of event card number 1-99999999\r\n\tuint32 public eventCardRangeMax;\r\n\t\r\n\t// Maximum rounds of battle, cannot exceed 128\r\n\tuint8 public maxBattleRounds; //\r\n\t\t\r\n\t// Record how much tokens are held as rank tokens\r\n\tuint256 internal totalRankTokens;\r\n\t\r\n\t// Flag for start fighting\r\n\tbool internal battleStart;\r\n\t\r\n\t//Flag for starter pack sale\r\n\tbool internal starterPackOnSale;\r\n\t\r\n\tuint256 public starterPackPrice; //price of starter pack\r\n\t\r\n\tuint16 public starterPackCardLevel; //card level from starter pack\r\n\t\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* ADMIN FUNCTIONS FOR SETTING CONFIGS\r\n\t/***********************************************************************************/\t\t\r\n\t/// @dev Sets the reference to the marketplace.\r\n\t/// @param _address - Address of marketplace.\r\n\tfunction setMarketplaceAddress(address _address) external onlyOwner {\r\n\t\tMarketplace candidateContract = Marketplace(_address);\r\n\r\n\t\trequire(candidateContract.isMarketplace(),\"needs to be marketplace\");\r\n\r\n\t\t// Set the new contract address\r\n\t\tmarketplace = candidateContract;\r\n\t}\r\n\t\t\r\n\t/**\r\n\t* @dev set upgrade gems for each level up and each 10 level up\r\n\t* @param _upgradeGems upgrade gems for normal levels\r\n\t* @param _upgradeGemsSpecial upgrade gems for every n levels\r\n\t* @param _gemAttackConversion gem to attack conversion\r\n\t* @param _gemDefenseConversion gem to defense conversion\r\n\t* @param _gemHpConversion gem to hp conversion\r\n\t* @param _gemSpeedConversion gem to speed conversion\r\n\t* @param _gemCriticalRateConversion gem to critical rate conversion\r\n\t* @param _goldPercentage percentage to get gold card\r\n\t* @param _silverPercentage percentage to get silver card\r\n\t* @param _eventCardRangeMin event card hash range start (inclusive)\r\n\t* @param _eventCardRangeMax event card hash range end (inclusive)\t\r\n\t* @param _newMaxBattleRounds maximum battle rounds\r\n\t*/\r\n\tfunction setSettingValues(  uint8 _upgradeGems,\r\n\tuint8 _upgradeGemsSpecial,\r\n\tuint16 _gemAttackConversion,\r\n\tuint16 _gemDefenseConversion,\r\n\tuint16 _gemHpConversion,\r\n\tuint16 _gemSpeedConversion,\r\n\tuint16 _gemCriticalRateConversion,\r\n\tuint8 _goldPercentage,\r\n\tuint8 _silverPercentage,\r\n\tuint32 _eventCardRangeMin,\r\n\tuint32 _eventCardRangeMax,\r\n\tuint8 _newMaxBattleRounds) external onlyOwner {\r\n\t\trequire(_eventCardRangeMax >= _eventCardRangeMin, \"range max must be larger or equals range min\" );\r\n\t\trequire(_eventCardRangeMax<100000000, \"range max cannot exceed 99999999\");\r\n\t\trequire((_newMaxBattleRounds <= 128) && (_newMaxBattleRounds >0), \"battle rounds must be between 0 and 128\");\r\n\t\tupgradeGems = _upgradeGems;\r\n\t\tupgradeGemsSpecial = _upgradeGemsSpecial;\r\n\t\tgemAttackConversion = _gemAttackConversion;\r\n\t\tgemDefenseConversion = _gemDefenseConversion;\r\n\t\tgemHpConversion = _gemHpConversion;\r\n\t\tgemSpeedConversion = _gemSpeedConversion;\r\n\t\tgemCriticalRateConversion = _gemCriticalRateConversion;\r\n\t\tgoldPercentage = _goldPercentage;\r\n\t\tsilverPercentage = _silverPercentage;\r\n\t\teventCardRangeMin = _eventCardRangeMin;\r\n\t\teventCardRangeMax = _eventCardRangeMax;\r\n\t\tmaxBattleRounds = _newMaxBattleRounds;\r\n\t}\r\n\t\r\n\t\r\n\t// @dev function to allow contract owner to change the price (in wei) per card draw\r\n\tfunction setStarterPack(uint256 _newStarterPackPrice, uint16 _newStarterPackCardLevel) external onlyOwner {\r\n\t\trequire(_newStarterPackCardLevel<=20, \"starter pack level cannot exceed 20\"); //starter pack level cannot exceed 20\r\n\t\tstarterPackPrice = _newStarterPackPrice;\r\n\t\tstarterPackCardLevel = _newStarterPackCardLevel;\t\t\r\n\t} \t\r\n\t\r\n\t// @dev function to allow contract owner to enable/disable starter pack sale\r\n\tfunction setStarterPackOnSale(bool _newStarterPackOnSale) external onlyOwner {\r\n\t\tstarterPackOnSale = _newStarterPackOnSale;\r\n\t}\r\n\t\r\n\t// @dev function to allow contract owner to start/stop the battle\r\n\tfunction setBattleStart(bool _newBattleStart) external onlyOwner {\r\n\t\tbattleStart = _newBattleStart;\r\n\t}\r\n\t\r\n\t// @dev function to allow contract owner to change the price (in wei) per card draw\r\n\tfunction setCardDrawPrice(uint256 _newCardDrawPrice) external onlyOwner {\r\n\t\tcardDrawPrice = _newCardDrawPrice;\r\n\t}\r\n\t\r\n\t// @dev function to allow contract owner to change the referrer fee (in %, eg 3.75% is 375)\r\n\tfunction setReferrerFee(uint256 _newReferrerFee) external onlyOwner {\r\n\t\treferrerFee = _newReferrerFee;\r\n\t}\r\n\r\n\t// @dev function to allow contract owner to change the challenge fee (in wei)\r\n\tfunction setChallengeFee(uint256 _newChallengeFee) external onlyOwner {\r\n\t\tchallengeFee = _newChallengeFee;\r\n\t}\r\n\r\n\t// @dev function to allow contract owner to change the upgrade fee (in wei)\r\n\tfunction setUpgradeFee(uint256 _newUpgradeFee) external onlyOwner {\r\n\t\tupgradeFee = _newUpgradeFee;\r\n\t}\r\n\t\r\n\t// @dev function to allow contract owner to change the avatar fee (in wei)\r\n\tfunction setAvatarFee(uint256 _newAvatarFee) external onlyOwner {\r\n\t\tavatarFee = _newAvatarFee;\r\n\t}\r\n\t\r\n\t// @dev function to allow contract owner to change the developer cut (%) divide by 100\r\n\tfunction setDeveloperCut(uint256 _newDeveloperCut) external onlyOwner {\r\n\t\tdeveloperCut = _newDeveloperCut;\r\n\t}\r\n\t\t\r\n\tfunction getTotalDeveloperCut() external view onlyOwner returns (uint256) {\r\n\t\treturn totalDeveloperCut;\r\n\t}\r\n\t\t\r\n\tfunction getTotalRankTokens() external view returns (uint256) {\r\n\t\treturn totalRankTokens;\r\n\t}\r\n\t\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* GET SETTINGS FUNCTION\r\n\t/***********************************************************************************/\t\r\n\t/**\r\n\t* @dev get upgrade gems and conversion ratios of each field\r\n\t* @return _upgradeGems upgrade gems for normal levels\r\n\t* @return _upgradeGemsSpecial upgrade gems for every n levels\r\n\t* @return _gemAttackConversion gem to attack conversion\r\n\t* @return _gemDefenseConversion gem to defense conversion\r\n\t* @return _gemHpConversion gem to hp conversion\r\n\t* @return _gemSpeedConversion gem to speed conversion\r\n\t* @return _gemCriticalRateConversion gem to critical rate conversion\r\n\t*/\r\n\tfunction getSettingValues() external view returns(  uint8 _upgradeGems,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint8 _upgradeGemsSpecial,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint16 _gemAttackConversion,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint16 _gemDefenseConversion,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint16 _gemHpConversion,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint16 _gemSpeedConversion,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint16 _gemCriticalRateConversion,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint8 _maxBattleRounds)\r\n\t{\r\n\t\t_upgradeGems = uint8(upgradeGems);\r\n\t\t_upgradeGemsSpecial = uint8(upgradeGemsSpecial);\r\n\t\t_gemAttackConversion = uint16(gemAttackConversion);\r\n\t\t_gemDefenseConversion = uint16(gemDefenseConversion);\r\n\t\t_gemHpConversion = uint16(gemHpConversion);\r\n\t\t_gemSpeedConversion = uint16(gemSpeedConversion);\r\n\t\t_gemCriticalRateConversion = uint16(gemCriticalRateConversion);\r\n\t\t_maxBattleRounds = uint8(maxBattleRounds);\r\n\t}\r\n\t\t\r\n\r\n}\r\n\r\n/***********************************************************************************/\r\n/* RANDOM GENERATOR\r\n/***********************************************************************************/\r\ncontract Random {\r\n\tuint private pSeed = block.number;\r\n\r\n\tfunction getRandom() internal returns(uint256) {\r\n\t\treturn (pSeed = uint(keccak256(abi.encodePacked(pSeed,\r\n\t\tblockhash(block.number - 1),\r\n\t\tblockhash(block.number - 3),\r\n\t\tblockhash(block.number - 5),\r\n\t\tblockhash(block.number - 7))\r\n\t\t)));\r\n\t}\r\n}\r\n\r\n/***********************************************************************************/\r\n/* CORE BATTLE CONTRACT\r\n/***********************************************************************************/\r\n/**\r\n* Omits fallback to prevent accidentally sending ether to this contract\r\n*/\r\ncontract Battle is BattleBase, Random, Pausable {\r\n\r\n\t/***********************************************************************************/\r\n\t/* CONSTRUCTOR\r\n\t/***********************************************************************************/\r\n\t// @dev Contructor for Battle Contract\r\n\tconstructor(address _tokenAddress) public {\r\n\t\tHogSmashToken candidateContract = HogSmashToken(_tokenAddress);\r\n\t\t// Set the new contract address\r\n\t\thogsmashToken = candidateContract;\r\n\t\t\r\n\t\tstarterPackPrice = 30000000000000000;\r\n\t\tstarterPackCardLevel = 5;\r\n\t\tstarterPackOnSale = true; // start by selling starter pack\r\n\t\t\r\n\t\tchallengeFee = 10000000000000000;\r\n\t\t\r\n\t\tupgradeFee = 10000000000000000;\r\n\t\t\r\n\t\tavatarFee = 50000000000000000;\r\n\t\t\r\n\t\tdeveloperCut = 375;\r\n\t\t\r\n\t\treferrerFee = 2000;\r\n\t\t\r\n\t\tcardDrawPrice = 15000000000000000;\r\n \t\t\r\n\t\tbattleStart = true;\r\n \t\t\r\n\t\tpaused = false; //default contract paused\r\n\t\t\t\t\r\n\t\ttotalDeveloperCut = 0; //init to 0\r\n\t}\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* MODIFIER\r\n\t/***********************************************************************************/\r\n\t/**\r\n\t* @dev Guarantees msg.sender is owner of the given token\r\n\t* @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n\t*/\r\n\tmodifier onlyOwnerOf(uint256 _tokenId) {\r\n\t\trequire(hogsmashToken.ownerOf(_tokenId) == msg.sender, \"must be owner of token\");\r\n\t\t_;\r\n\t}\r\n\t\t\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* GAME FUNCTIONS\r\n\t/***********************************************************************************/\r\n\t/**\r\n\t* @dev External function for getting info of card\r\n\t* @param _id card id of target query card\r\n\t* @return information of the card\r\n\t*/\r\n\tfunction getCard(uint256 _id) external view returns (\r\n\tuint256 cardId,\r\n\taddress owner,\r\n\tuint8 element,\r\n\tuint16 level,\r\n\tuint32[] stats,\r\n\tuint32 currentExp,\r\n\tuint32 expToNextLevel,\r\n\tuint256 cardHash,\r\n\tuint64 createdDatetime,\r\n\tuint256 rank\r\n\t) {\r\n\t\tcardId = _id;\r\n\t\t\r\n\t\towner = hogsmashToken.ownerOf(_id);\r\n\t\t\r\n\t\tCard storage card = cards[_id];\r\n\t\t\r\n\t\tuint32[] memory tempStats = new uint32[](6);\r\n\r\n\t\telement = uint8(card.element);\r\n\t\tlevel = uint16(card.level);\r\n\t\ttempStats[0] = uint32(card.attack);\r\n\t\ttempStats[1] = uint32(card.defense);\r\n\t\ttempStats[2] = uint32(card.hp);\r\n\t\ttempStats[3] = uint32(card.speed);\r\n\t\ttempStats[4] = uint16(card.criticalRate);\r\n\t\ttempStats[5] = uint32(card.flexiGems);\r\n\t\tstats = tempStats;\r\n\t\tcurrentExp = uint32(card.currentExp);\r\n\t\texpToNextLevel = uint32(card.expToNextLevel);\r\n\t\tcardHash = uint256(card.cardHash);\r\n\t\tcreatedDatetime = uint64(card.createdDatetime);\r\n\t\trank = uint256(card.rank);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev External function for querying card Id at rank (zero based)\r\n\t* @param _rank zero based rank of the card\r\n\t* @return id of the card at the rank\r\n\t*/\r\n\tfunction getCardIdByRank(uint256 _rank) external view returns(uint256 cardId) {\r\n\t\treturn ranking[_rank];\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t* @dev External function for drafting new card\r\n\t* @return uint of cardId\r\n\t*/\r\n\tfunction draftNewCard() external payable whenNotPaused returns (uint256) {\r\n\t\trequire(msg.value == cardDrawPrice, \"fee must be equal to draw price\"); //make sure the fee is enough for drafting a new card`\r\n\t\t\t\t\r\n\t\trequire(address(marketplace) != address(0), \"marketplace not set\"); //need to set up marketplace before drafting new cards is allowed\r\n\t\t\t\t\r\n\t\thogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true); //let marketplace have approval for escrow if the card goes on sale\r\n\t\t\r\n\t\ttotalDeveloperCut = totalDeveloperCut.add(cardDrawPrice);\r\n\t\t\r\n\t\treturn _createCard(msg.sender, 1); //level 1 cards\r\n\t}\r\n\t\r\n\t/**\r\n\t* @dev External function for drafting new card\r\n\t* @return uint of cardId\r\n\t*/\r\n\tfunction draftNewCardWithReferrer(address referrer) external payable whenNotPaused returns (uint256 cardId) {\r\n\t\trequire(msg.value == cardDrawPrice, \"fee must be equal to draw price\"); //make sure the fee is enough for drafting a new card`\r\n\t\t\t\t\r\n\t\trequire(address(marketplace) != address(0), \"marketplace not set\"); //need to set up marketplace before drafting new cards is allowed\r\n\t\t\t\t\r\n\t\thogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true); //let marketplace have approval for escrow if the card goes on sale\r\n\t\t\r\n\t\tcardId = _createCard(msg.sender, 1); //level 1 cards\r\n\t\t\r\n\t\tif ((referrer != address(0)) && (referrerFee!=0) && (referrer!=msg.sender) && (hogsmashToken.balanceOf(referrer)>0)) {\r\n\t\t\tuint256 referrerCut = msg.value.mul(referrerFee)/10000;\r\n\t\t\trequire(referrerCut<=msg.value, \"referre cut cannot be larger than fee\");\r\n\t\t\treferrer.transfer(referrerCut);\r\n\t\t\ttotalDeveloperCut = totalDeveloperCut.add(cardDrawPrice.sub(referrerCut));\r\n\t\t} else {\r\n\t\t\ttotalDeveloperCut = totalDeveloperCut.add(cardDrawPrice);\r\n\t\t}\t\t\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t* @dev External function for leveling up\r\n\t* @param _id card id of target query card\r\n\t* @param _attackLevelUp gems allocated to each attribute for upgrade\r\n\t* @param _defenseLevelUp gems allocated to each attribute for upgrade\r\n\t* @param _hpLevelUp gems allocated to each attribute for upgrade\r\n\t* @param _speedLevelUp gems allocated to each attribute for upgrade\r\n\t* @param _criticalRateLevelUp gems allocated to each attribute for upgrade\r\n\t* @param _flexiGemsLevelUp are gems allocated to each attribute for upgrade\r\n\t*/\r\n\tfunction levelUp( \tuint256 _id,\r\n\t\t\t\t\t\tuint16 _attackLevelUp,\r\n\t\t\t\t\t\tuint16 _defenseLevelUp,\r\n\t\t\t\t\t\tuint16 _hpLevelUp,\r\n\t\t\t\t\t\tuint16 _speedLevelUp,\r\n\t\t\t\t\t\tuint16 _criticalRateLevelUp,\r\n\t\t\t\t\t\tuint16 _flexiGemsLevelUp) external payable whenNotPaused onlyOwnerOf(_id) {\r\n\t\trequire(\r\n\t\t_attackLevelUp >= 0        &&\r\n\t\t_defenseLevelUp >= 0       &&\r\n\t\t_hpLevelUp >= 0            &&\r\n\t\t_speedLevelUp >= 0         &&\r\n\t\t_criticalRateLevelUp >= 0  &&\r\n\t\t_flexiGemsLevelUp >= 0, \"level up attributes must be more than 0\"\r\n\t\t); //make sure all upgrade attributes will not be negative\r\n\r\n\t\trequire(msg.value == upgradeFee, \"fee must be equals to upgrade price\"); //make sure the fee is enough for upgrade\r\n\r\n\t\tCard storage card = cards[_id];\t\t\r\n\t\trequire(card.currentExp==card.expToNextLevel, \"exp is not max yet for level up\"); //reject if currentexp not maxed out\r\n\t\t\r\n\t\trequire(card.level < 65535, \"card level maximum has reached\"); //make sure level is not maxed out, although not likely\r\n\t\t\r\n\t\trequire((card.criticalRate + (_criticalRateLevelUp * gemCriticalRateConversion))<=7000, \"critical rate max of 70 has reached\"); //make sure criticalrate is not upgraded when it reaches 70 to prevent waste\r\n\r\n\t\tuint totalInputGems = _attackLevelUp + _defenseLevelUp + _hpLevelUp;\r\n\t\ttotalInputGems += _speedLevelUp + _criticalRateLevelUp + _flexiGemsLevelUp;\r\n\t\t\r\n\t\tuint16 numOfSpecials = 0;\r\n\t\t\t\t\r\n\t\t//Cater for initial high level cards but have not leveled up before\r\n\t\tif ((card.level > 1) && (card.attack==1) && (card.defense==1) && (card.hp==3) && (card.speed==1) && (card.criticalRate==25) && (card.flexiGems==1)) {\r\n\t\t\tnumOfSpecials = (card.level+1)/5; //auto floor to indicate how many Ns for upgradeGemsSpecial; cardlevel +1 is the new level\r\n\t\t\tuint totalGems = (numOfSpecials * upgradeGemsSpecial) + (((card.level) - numOfSpecials) * upgradeGems);\r\n\t\t\trequire(totalInputGems==totalGems, \"upgrade gems not used up\"); //must use up all gems when upgrade\r\n\t\t} else {\r\n\t\t\tif (((card.level+1)%5)==0) { //special gem every 5 levels\r\n\t\t\t\trequire(totalInputGems==upgradeGemsSpecial, \"upgrade gems not used up\"); //must use up all gems when upgrade\t\r\n\t\t\t\tnumOfSpecials = 1;\r\n\t\t\t} else {\r\n\t\t\t\trequire(totalInputGems==upgradeGems, \"upgrade gems not used up\"); //must use up all gems when upgrade\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ttotalDeveloperCut = totalDeveloperCut.add(upgradeFee);\r\n\t\t\r\n\t\t//start level up process\r\n\t\t_upgradeLevel(_id, _attackLevelUp, _defenseLevelUp, _hpLevelUp, _speedLevelUp, _criticalRateLevelUp, _flexiGemsLevelUp, numOfSpecials);\r\n\t\t\t\t\t\t\t\t\r\n\t\temit LevelUp(_id);\r\n\t}\r\n\r\n\tfunction _upgradeLevel( uint256 _id,\r\n\t\t\t\t\t\t\tuint16 _attackLevelUp,\r\n\t\t\t\t\t\t\tuint16 _defenseLevelUp,\r\n\t\t\t\t\t\t\tuint16 _hpLevelUp,\r\n\t\t\t\t\t\t\tuint16 _speedLevelUp,\r\n\t\t\t\t\t\t\tuint16 _criticalRateLevelUp,\r\n\t\t\t\t\t\t\tuint16 _flexiGemsLevelUp,\r\n\t\t\t\t\t\t\tuint16 numOfSpecials) private {\r\n\t\tCard storage card = cards[_id];\r\n\t\tuint16[] memory extraStats = new uint16[](5); //attack, defense, hp, speed, flexigem\r\n\t\tif (numOfSpecials>0) { //special gem every 5 levels\r\n\t\t\tif (card.cardHash%100 >= 70) { //6* or 7* cards\r\n\t\t\t\tuint cardType = (uint(card.cardHash/10000000000))%100; //0-99\r\n\t\t\t\tif (cardType < 20) {\r\n\t\t\t\t\textraStats[0]+=numOfSpecials;\r\n\t\t\t\t} else if (cardType < 40) {\r\n\t\t\t\t\textraStats[1]+=numOfSpecials;\r\n\t\t\t\t} else if (cardType < 60) {\r\n\t\t\t\t\textraStats[2]+=numOfSpecials;\r\n\t\t\t\t} else if (cardType < 80) {\r\n\t\t\t\t\textraStats[3]+=numOfSpecials;\r\n\t\t\t\t} else {\r\n\t\t\t\t\textraStats[4]+=numOfSpecials;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (card.cardHash%100 >=90) { //7* cards\t\t\t\r\n\t\t\t\t\tuint cardTypeInner = cardType%10; //0-9\r\n\t\t\t\t\tif (cardTypeInner < 2) {\r\n\t\t\t\t\t\textraStats[0]+=numOfSpecials;\r\n\t\t\t\t\t} else if (cardTypeInner < 4) {\r\n\t\t\t\t\t\textraStats[1]+=numOfSpecials;\r\n\t\t\t\t\t} else if (cardTypeInner < 6) {\r\n\t\t\t\t\t\textraStats[2]+=numOfSpecials;\r\n\t\t\t\t\t} else if (cardTypeInner < 8) {\r\n\t\t\t\t\t\textraStats[3]+=numOfSpecials;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textraStats[4]+=numOfSpecials;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcard.attack += (_attackLevelUp + extraStats[0]) * gemAttackConversion;\r\n\t\tcard.defense += (_defenseLevelUp + extraStats[1]) * gemDefenseConversion;\r\n\t\tcard.hp += (_hpLevelUp + extraStats[2]) * gemHpConversion;\r\n\t\tcard.speed += (_speedLevelUp + extraStats[3]) * gemSpeedConversion;\t\t\r\n\t\tcard.criticalRate += uint16(_criticalRateLevelUp * gemCriticalRateConversion);\r\n\t\tcard.flexiGems += _flexiGemsLevelUp + extraStats[4]; // turn Gem into FlexiGem\r\n\t\tcard.level += 1; //level + 1\r\n\r\n\t\tcard.currentExp = 0; //reset exp\r\n\t\t//card.expToNextLevel = card.level*100 + max(0,card.level-8) * (1045/1000)**card.level;\r\n\t\tuint256 tempExpLevel = card.level;\r\n\t\tif (tempExpLevel > expToNextLevelArr.length) {\r\n\t\t\ttempExpLevel = expToNextLevelArr.length; //cap it at max level exp\r\n\t\t}\r\n\t\tcard.expToNextLevel = expToNextLevelArr[tempExpLevel];\r\n\t}\r\n\r\n\tfunction max(uint a, uint b) private pure returns (uint) {\r\n\t\treturn a > b ? a : b;\r\n\t}\r\n\r\n\tfunction challenge( uint256 _challengerCardId,\r\n\t\t\t\t\t\tuint32[5] _statUp, //0-attack, 1-defense, 2-hp, 3-speed, 4-criticalrate\r\n\t\t\t\t\t\tuint256 _defenderCardId,\t\t\t\t\t\t\r\n\t\t\t\t\t\tuint256 _defenderRank,\r\n\t\t\t\t\t\tuint16 _defenderLevel) external payable whenNotPaused onlyOwnerOf(_challengerCardId) {\r\n\t\trequire(battleStart != false, \"battle has not started\"); //make sure the battle has started\r\n\t\trequire(msg.sender != hogsmashToken.ownerOf(_defenderCardId), \"cannot challenge own cards\"); //make sure user doesn't attack his own cards\r\n\t\tCard storage challenger = cards[_challengerCardId];\t\t\r\n\t\trequire((_statUp[0] + _statUp[1] + _statUp[2] + _statUp[3] + _statUp[4])==challenger.flexiGems, \"flexi gems not used up\"); //flexi points must be exactly used, not more not less\r\n\t\t\r\n\t\tCard storage defender = cards[_defenderCardId];\r\n\t\t\r\n\t\tif (defender.rank != _defenderRank) {\r\n\t\t\temit RejectChallenge(_challengerCardId, _defenderCardId, _defenderRank, 1, uint256(block.number));\r\n\t\t\t(msg.sender).transfer(msg.value);\t\t\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif (defender.level != _defenderLevel) {\r\n\t\t\temit RejectChallenge(_challengerCardId, _defenderCardId, _defenderRank, 2, uint256(block.number));\r\n\t\t\t(msg.sender).transfer(msg.value);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tuint256 requiredChallengeFee = challengeFee;\r\n\t\tif (defender.rank <150) { //0-149 rank within 150\r\n\t\t\trequiredChallengeFee = requiredChallengeFee.mul(2);\r\n\t\t}\r\n\t\trequire(msg.value == requiredChallengeFee, \"fee must be equals to challenge price\"); //challenge fee to challenge defender\r\n\t\t\r\n\t\tuint256 developerFee = 0;\r\n\t\tif (msg.value > 0) {\r\n\t\t\tdeveloperFee = _calculateFee(msg.value);\r\n\t\t}\r\n\t\t\r\n\t\tuint256[] memory stats = new uint256[](14); //challengerattack, challengerdefense, challengerhp, challengerspeed, challengercritical, defendercritical, defenderhp, finalWinner\r\n\r\n\t\tstats[0] = challenger.attack + (_statUp[0] * gemAttackConversion);\r\n\t\tstats[1] = challenger.defense + (_statUp[1] * gemDefenseConversion);\r\n\t\tstats[2] = challenger.hp + (_statUp[2] * gemHpConversion);\r\n\t\tstats[3] = challenger.speed + (_statUp[3] * gemSpeedConversion);\r\n\t\tstats[4] = challenger.criticalRate + (_statUp[4] * gemCriticalRateConversion);\r\n\t\tstats[5] = defender.criticalRate;\r\n\t\tstats[6] = defender.hp;\r\n\t\tstats[8] = challenger.hp + (_statUp[2] * gemHpConversion); //challenger hp for record purpose\r\n\t\tstats[9] = challenger.rank; //for looting\r\n\t\tstats[10] = defender.rank; //for looting\r\n\t\tstats[11] = 0; //tokensGained\r\n\t\tstats[12] = _challengerCardId;\r\n\t\tstats[13] = _defenderCardId;\r\n\r\n\t\t//check challenger critical rate\r\n\t\tif (stats[4]>7000) {\r\n\t\t\tstats[4] = 7000; //hard cap at 70 critical rate\r\n\t\t}\r\n\r\n\t\t//check defender critical rate\r\n\t\tif (stats[5]>7000) {\r\n\t\t\tstats[5] = 7000; //hard cap at 70 critical rate\r\n\t\t}\r\n\r\n\t\t// 1 - fire; 2 - water; 3 - wood;    8 - light; 9 - dark;\r\n\t\tif (((challenger.element-1) == defender.element) || ((challenger.element==1) && (defender.element==3)) || ((challenger.element==8) && (defender.element==9))) {\r\n\t\t\tstats[4] += 3000; //30% critical rate increase for challenger\r\n\t\t\tif (stats[4]>8000) {\r\n\t\t\t\tstats[4] = 8000; //hard cap at 80 critical rate for element advantage\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (((defender.element-1) == challenger.element) || ((defender.element==1) && (challenger.element==3)) || ((defender.element==8) && (challenger.element==9))) {\r\n\t\t\tstats[5] += 3000; //30% critical rate increase for defender\r\n\t\t\tif (stats[5]>8000) {\r\n\t\t\t\tstats[5] = 8000; //hard cap at 80 critical rate for element advantage\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tuint256 battleSequence = _simulateBattle(challenger, defender, stats);\r\n\t\t\r\n\t\tstats[11] = _transferFees(_challengerCardId, stats, developerFee);\t\r\n\t\t\r\n\t\t\r\n\t\temit BattleHistory(\r\n\t\t\thistoryId,\r\n\t\t\tuint8(stats[7]),\r\n\t\t\tuint64(now),\r\n\t\t\tuint256(battleSequence),\r\n\t\t\tuint256(block.number),\r\n\t\t\tuint256(stats[11])\r\n\t\t);\r\n\t\t\r\n\t\temit BattleHistoryChallenger(\r\n\t\t\thistoryId,\r\n\t\t\tuint256(_challengerCardId),\r\n\t\t\tuint8(challenger.element),\r\n\t\t\tuint16(challenger.level),\r\n\t\t\tuint32(stats[0]),\r\n\t\t\tuint32(stats[1]),\r\n\t\t\tuint32(stats[8]),\r\n\t\t\tuint32(stats[3]),\r\n\t\t\tuint16(stats[4]), //pretty sure trimming down the uint won't affect the number as max is just 80000\r\n\t\t\tuint256(stats[9])\r\n\t\t);\r\n\t\t\t\r\n\t\temit BattleHistoryDefender(\t\r\n\t\t\thistoryId,\r\n\t\t\tuint256(_defenderCardId),\r\n\t\t\tuint8(defender.element),\r\n\t\t\tuint16(defender.level),\r\n\t\t\tuint32(defender.attack),\r\n\t\t\tuint32(defender.defense),\r\n\t\t\tuint32(defender.hp),\r\n\t\t\tuint32(defender.speed),\r\n\t\t\tuint16(stats[5]),\r\n\t\t\tuint256(stats[10])\r\n\t\t);\r\n\t\t\r\n\t\thistoryId = historyId.add(1); //add one for next history\r\n\t}\r\n\t\r\n\tfunction _addBattleSequence(uint8 attackType, uint8 rounds, uint256 battleSequence) private pure returns (uint256) {\r\n\t\t// Assumed rounds 0-based; attackType is 0xB (B:0,1,2,3), i.e. the last 2 bits is the value with other bits zeros\r\n\t\tuint256 mask = 0x3;\r\n\t\tmask = ~(mask << 2*rounds);\r\n\t\tuint256 newSeq = battleSequence & mask;\r\n\r\n\t\tnewSeq = newSeq | (uint256(attackType) << 2*rounds);\r\n\r\n\t\treturn newSeq;\r\n\t}\r\n\r\n\r\n\tfunction _simulateBattle(Card storage challenger, Card storage defender, uint[] memory stats) private returns (uint256 battleSequence) {\r\n\t\r\n\t\tbool continueBattle = true;\r\n\t\tuint8 currentAttacker = 0; //0 challenger, 1 defender\r\n\t\tuint256 tempAttackStrength;\r\n\t\tuint8 battleRound = 0;\r\n\t\tif (!_isChallengerAttackFirst(stats[3], defender.speed)){\r\n\t\t\tcurrentAttacker = 1;\r\n\t\t}\r\n\t\twhile (continueBattle) {\r\n\t\t\tif (currentAttacker==0) { //challenger attack\r\n\t\t\t\tif (_rollCriticalDice() <= stats[4]){\r\n\t\t\t\t\ttempAttackStrength = stats[0] * 2; //critical hit\r\n\t\t\t\t\tbattleSequence = _addBattleSequence(2, battleRound, battleSequence); //move sequence to left and add record\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttempAttackStrength = stats[0]; //normal hit\r\n\t\t\t\t\tbattleSequence = _addBattleSequence(0, battleRound, battleSequence); //move sequence to left and add record\r\n\t\t\t\t}\r\n\t\t\t\tif (tempAttackStrength <= defender.defense) {\r\n\t\t\t\t\ttempAttackStrength = 1; //at least deduct 1 hp\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttempAttackStrength -= defender.defense;\r\n\t\t\t\t}\r\n\t\t\t\tif (stats[6] <= tempAttackStrength) {\r\n\t\t\t\t\tstats[6] = 0; //do not let it overflow\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstats[6] -= tempAttackStrength; //defender hp\r\n\t\t\t\t}\r\n\t\t\t\tcurrentAttacker = 1; //defender turn up next\r\n\t\t\t} else if (currentAttacker==1) { //defender attack\r\n\t\t\t\tif (_rollCriticalDice() <= stats[5]){\r\n\t\t\t\t\ttempAttackStrength = defender.attack * 2; //critical hit\r\n\t\t\t\t\tbattleSequence = _addBattleSequence(3, battleRound, battleSequence); //move sequence to left and add record\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttempAttackStrength = defender.attack; //normal hit\r\n\t\t\t\t\tbattleSequence = _addBattleSequence(1, battleRound, battleSequence); //move sequence to left and add record\r\n\t\t\t\t}\r\n\t\t\t\tif (tempAttackStrength <= stats[1]) {\r\n\t\t\t\t\ttempAttackStrength = 1; //at least deduct 1 hp\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttempAttackStrength -= stats[1];\r\n\t\t\t\t}\r\n\t\t\t\tif (stats[2] <= tempAttackStrength) {\r\n\t\t\t\t\tstats[2] = 0; //do not let it overflow\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstats[2] -= tempAttackStrength; //challenger hp\r\n\t\t\t\t}\r\n\t\t\t\tcurrentAttacker = 0; //challenger turn up next\r\n\t\t\t}\r\n\t\t\tbattleRound ++;\r\n\r\n\t\t\tif ((battleRound>=maxBattleRounds) || (stats[6]<=0) || (stats[2]<=0)){\r\n\t\t\t\tcontinueBattle = false; //end battle\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint32 challengerGainExp = 0;\r\n\t\tuint32 defenderGainExp = 0;\r\n\r\n\t\t//calculate Exp\r\n\t\tif (challenger.level == defender.level) { //challenging a same level card\r\n\t\t\tchallengerGainExp = activeWinExp[10];\r\n\t\t} else if (challenger.level > defender.level) { //challenging a lower level card\r\n\t\t\tif ((challenger.level - defender.level) >= 11) {\r\n\t\t\t\tchallengerGainExp = 1; //defender too weak, grant only 1 exp\r\n\t\t\t} else {\r\n\t\t\t\t//challengerGainExp = (((1 + ((defender.level - challenger.level)/10))**2) + (1/10)) * baseExp;\r\n\t\t\t\tchallengerGainExp = activeWinExp[10 + defender.level - challenger.level]; //0 - 9\r\n\t\t\t}\r\n\t\t} else if (challenger.level < defender.level) { //challenging a higher level card\r\n\t\t\t//challengerGainExp = ((1 + ((defender.level - challenger.level)/10)**(3/2))) * baseExp;\r\n\t\t\tuint256 levelDiff = defender.level - challenger.level;\r\n\t\t\tif (levelDiff > 20) {\r\n\t\t\t\tlevelDiff = 20; //limit level difference to 20 as max exp gain\r\n\t\t\t}\r\n\t\t\tchallengerGainExp = activeWinExp[10+levelDiff];\r\n\t\t}\r\n\t\t\r\n\t\tif (stats[2] == stats[6]) { //challenger hp = defender hp\r\n\t\t\tstats[7] = 2; //draw\r\n\t\t\t//No EXP when draw\r\n\t\t} else if (stats[2] > stats[6]) { //challenger hp > defender hp\r\n\t\t\tstats[7] = 0; //challenger wins\r\n\t\t\tif (defender.rank < challenger.rank) { //swap ranks\r\n\t\t\t\tranking[defender.rank] = stats[12]; //update ranking table position\r\n\t\t\t\tranking[challenger.rank] = stats[13]; //update ranking table position\r\n\t\t\t\tuint256 tempRank = defender.rank;\r\n\t\t\t\tdefender.rank = challenger.rank; //update rank on card\r\n\t\t\t\tchallenger.rank = tempRank; //update rank on card\r\n\t\t\t}\r\n\r\n\t\t\t//award Exp\r\n\t\t\t//active win\r\n\t\t\tchallenger.currentExp += challengerGainExp;\r\n\t\t\tif (challenger.currentExp > challenger.expToNextLevel) {\r\n\t\t\t\tchallenger.currentExp = challenger.expToNextLevel; //cap it at max exp for level up\r\n\t\t\t}\r\n\r\n\t\t\t//passive lose\r\n\t\t\t//defenderGainExp = challengerGainExp*35/100*30/100 + (5/10);\r\n\t\t\tdefenderGainExp = ((challengerGainExp*105/100) + 5)/10; // 30% of 35% + round up\r\n\t\t\tif (defenderGainExp <= 0) {\r\n\t\t\t\tdefenderGainExp = 1; //at least 1 Exp\r\n\t\t\t}\r\n\t\t\tdefender.currentExp += defenderGainExp;\r\n\t\t\tif (defender.currentExp > defender.expToNextLevel) {\r\n\t\t\t\tdefender.currentExp = defender.expToNextLevel; //cap it at max exp for level up\r\n\t\t\t}\r\n\r\n\t\t} else if (stats[6] > stats[2]) { //defender hp > challenger hp\r\n\t\t\tstats[7] = 1; //defender wins\r\n\t\t\t//award Exp\r\n\t\t\t//active lose\r\n\t\t\tuint32 tempChallengerGain = challengerGainExp*35/100; //35% of winning\r\n\t\t\tif (tempChallengerGain <= 0) {\r\n\t\t\t\ttempChallengerGain = 1; //at least 1 Exp\r\n\t\t\t}\r\n\t\t\tchallenger.currentExp += tempChallengerGain; //35% of winning\r\n\t\t\tif (challenger.currentExp > challenger.expToNextLevel) {\r\n\t\t\t\tchallenger.currentExp = challenger.expToNextLevel; //cap it at max exp for level up\r\n\t\t\t}\r\n\r\n\t\t\t//passive win\r\n\t\t\tdefenderGainExp = challengerGainExp*30/100;\r\n\t\t\tif (defenderGainExp <= 0) {\r\n\t\t\t\tdefenderGainExp = 1; //at least 1 Exp\r\n\t\t\t}\r\n\t\t\tdefender.currentExp += defenderGainExp;\r\n\t\t\tif (defender.currentExp > defender.expToNextLevel) {\r\n\t\t\t\tdefender.currentExp = defender.expToNextLevel; //cap it at max exp for level up\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn battleSequence;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\tfunction _transferFees(uint256 _challengerCardId, uint[] stats, uint256 developerFee) private returns (uint256 totalGained) {\r\n\t\ttotalDeveloperCut = totalDeveloperCut.add(developerFee);\t\t\r\n\t\tuint256 remainFee = msg.value.sub(developerFee); //minus developer fee\r\n\t\ttotalGained = 0;\r\n\t\tif (stats[7] == 1) { //challenger loses\t\t\t\r\n\t\t\t// put all of challenger fee in rankTokens (minus developerfee of course)\t\t\t\r\n\t\t\trankTokens[stats[10]] = rankTokens[stats[10]].add(remainFee);\r\n\t\t\ttotalRankTokens = totalRankTokens.add(remainFee);\r\n\t\t} else { //draw or challenger wins\r\n\t\t\taddress challengerAddress = hogsmashToken.ownerOf(_challengerCardId); //get address of card owner\r\n\t\t\tif (stats[7] == 0) { //challenger wins\t\t\t\t\r\n\t\t\t\tif (stats[9] > stats[10]) { //challenging a higher ranking defender\t\t\t\t\t\r\n\t\t\t\t\t//1. get tokens from defender rank if defender rank is higher\r\n\t\t\t\t\tif (rankTokens[stats[10]] > 0) {\r\n\t\t\t\t\t\ttotalGained = totalGained.add(rankTokens[stats[10]]);\r\n\t\t\t\t\t\ttotalRankTokens = totalRankTokens.sub(rankTokens[stats[10]]);\r\n\t\t\t\t\t\trankTokens[stats[10]] = 0;\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//2. get self rank tokens if moved to higher rank\r\n\t\t\t\t\tif (rankTokens[stats[9]] > 0) {\r\n\t\t\t\t\t\ttotalGained = totalGained.add(rankTokens[stats[9]]);\r\n\t\t\t\t\t\ttotalRankTokens = totalRankTokens.sub(rankTokens[stats[9]]);\r\n\t\t\t\t\t\trankTokens[stats[9]] = 0;\r\n\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t} else { //challenging a lower ranking defender\t\t\t\t\t\r\n\t\t\t\t\tif (stats[9]<50) { //rank 1-50 gets to get self rank tokens and lower rank (within 150) tokens if win\r\n\t\t\t\t\t\tif ((stats[10] < 150) && (rankTokens[stats[10]] > 0)) { // can get defender rank tokens if defender rank within top 150 (0-149)\r\n\t\t\t\t\t\t\ttotalGained = totalGained.add(rankTokens[stats[10]]);\r\n\t\t\t\t\t\t\ttotalRankTokens = totalRankTokens.sub(rankTokens[stats[10]]);\r\n\t\t\t\t\t\t\trankTokens[stats[10]] = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif ((stats[10] < 150) && (rankTokens[stats[9]] > 0)) { //can get self rank tokens if defender rank within top 150\r\n\t\t\t\t\t\t\ttotalGained = totalGained.add(rankTokens[stats[9]]);\r\n\t\t\t\t\t\t\ttotalRankTokens = totalRankTokens.sub(rankTokens[stats[9]]);\r\n\t\t\t\t\t\t\trankTokens[stats[9]] = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tchallengerAddress.transfer(totalGained.add(remainFee)); //give back challenge fee untouched + total gained\t\t\t\t\r\n\t\t\t} else { //draw\r\n\t\t\t\tchallengerAddress.transfer(remainFee); //give back challenge fee untouched\r\n\t\t\t} \r\n\t\t}\t\t\t\r\n\t}\r\n\t\r\n\r\n\tfunction _rollCriticalDice() private returns (uint16 result){\r\n\t\treturn uint16((getRandom() % 10000) + 1); //get 1 to 10000\r\n\t}\r\n\r\n\tfunction _isChallengerAttackFirst(uint _challengerSpeed, uint _defenderSpeed ) private returns (bool){\r\n\t\tuint8 randResult = uint8((getRandom() % 100) + 1); //get 1 to 100\r\n\t\tuint challengerChance = (((_challengerSpeed * 10 ** 3) / (_challengerSpeed + _defenderSpeed))+5) / 10;//round\r\n\t\tif (randResult <= challengerChance) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\t/// @dev function to buy starter package, with card and tokens directly from contract\r\n\tfunction buyStarterPack() external payable whenNotPaused returns (uint256){\r\n\t\trequire(starterPackOnSale==true, \"starter pack is not on sale\");\r\n\t\trequire(msg.value==starterPackPrice, \"fee must be equals to starter pack price\");\r\n\t\trequire(address(marketplace) != address(0), \"marketplace not set\"); //need to set up marketplace before drafting new cards is allowed\r\n\t\t\r\n\t\ttotalDeveloperCut = totalDeveloperCut.add(starterPackPrice);\r\n\t\t\t\t\r\n\t\thogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true); //let marketplace have approval for escrow if the card goes on sale\r\n\t\t\r\n\t\treturn _createCard(msg.sender, starterPackCardLevel); //level n cards\r\n\t}\r\n\t\t\r\n\t/**\r\n\t* @dev Create card function\r\n\t* @param _to The address that will own the minted card\r\n\t* @param _initLevel The level to start with, usually 1\r\n\t* @return uint256 ID of the new card\r\n\t*/\r\n\tfunction _createCard(address _to, uint16 _initLevel) private returns (uint256) {\r\n\t\trequire(_to != address(0), \"cannot create card for unknown address\"); //check if address is not 0 (the origin address)\r\n\r\n\t\tcurrentElement+= 1;\r\n\t\tif (currentElement==4) {\r\n\t\t\tcurrentElement = 8;\r\n\t\t}\r\n\t\tif (currentElement == 10) {\r\n\t\t\tcurrentElement = 1;\r\n\t\t}\r\n\t\tuint256 tempExpLevel = _initLevel;\r\n\t\tif (tempExpLevel > expToNextLevelArr.length) {\r\n\t\t\ttempExpLevel = expToNextLevelArr.length; //cap it at max level exp\r\n\t\t}\r\n\t\t\r\n\t\tuint32 tempCurrentExp = 0;\r\n\t\tif (_initLevel>1) { //let exp max out so that user can level up the card according to preference\r\n\t\t\ttempCurrentExp = expToNextLevelArr[tempExpLevel];\r\n\t\t}\r\n\t\t\r\n\t\tuint256 tokenId = hogsmashToken.mint(_to);\r\n\t\t\r\n\t\t// use memory as this is a temporary variable, cheaper and will not be stored since cards store all of them\r\n\t\tCard memory _card = Card({\r\n\t\t\telement: currentElement, // 1 - fire; 2 - water; 3 - wood;    8 - light; 9 - dark;\r\n\t\t\tlevel: _initLevel, // level\r\n\t\t\tattack: 1, // attack,\r\n\t\t\tdefense: 1, // defense,\r\n\t\t\thp: 3, // hp,\r\n\t\t\tspeed: 1, // speed,\r\n\t\t\tcriticalRate: 25, // criticalRate\r\n\t\t\tflexiGems: 1, // flexiGems,\r\n\t\t\tcurrentExp: tempCurrentExp, // currentExp,\r\n\t\t\texpToNextLevel: expToNextLevelArr[tempExpLevel], // expToNextLevel,\r\n\t\t\tcardHash: generateHash(),\r\n\t\t\tcreatedDatetime :uint64(now),\r\n\t\t\trank: tokenId // rank\r\n\t\t});\r\n\t\t\r\n\t\tcards[tokenId] = _card;\r\n\t\tranking.push(tokenId); //push to ranking mapping\r\n\t\t\r\n\t\temit CardCreated(msg.sender, tokenId);\r\n\r\n\t\treturn tokenId;\r\n\t}\r\n\t\r\n\tfunction generateHash() private returns (uint256 hash){\r\n\t\thash = uint256((getRandom()%1000000000000)/10000000000);\t\t\r\n\t\thash = hash.mul(10000000000);\r\n\t\t\r\n\t\tuint256 tempHash = ((getRandom()%(eventCardRangeMax-eventCardRangeMin+1))+eventCardRangeMin)*100;\r\n\t\thash = hash.add(tempHash);\r\n\t\t\r\n\t\ttempHash = getRandom()%100;\r\n\t\t\r\n\t\tif (tempHash < goldPercentage) {\r\n\t\t\thash = hash.add(90);\r\n\t\t} else if (tempHash < (goldPercentage+silverPercentage)) {\r\n\t\t\thash = hash.add(70);\r\n\t\t} else {\r\n\t\t\thash = hash.add(50);\r\n\t\t}\r\n\t}\r\n\t\r\n\t/// @dev function to update avatar hash \r\n\tfunction updateAvatar(uint256 _cardId, uint256 avatarHash) external payable whenNotPaused onlyOwnerOf(_cardId) {\r\n\t\trequire(msg.value==avatarFee, \"fee must be equals to avatar price\");\r\n\t\t\t\t\r\n\t\tCard storage card = cards[_cardId];\r\n\t\t\r\n\t\tuint256 tempHash = card.cardHash%1000000000000; //retain hash fixed section\r\n\t\t\r\n\t\tcard.cardHash = tempHash.add(avatarHash.mul(1000000000000));\r\n\t\t\r\n\t\temit HashUpdated(_cardId, card.cardHash);\t\t\r\n\t}\r\n\t\t\r\n\t\r\n\t/// @dev Compute developer's fee\r\n\t/// @param _challengeFee - transaction fee\r\n\tfunction _calculateFee(uint256 _challengeFee) internal view returns (uint256) {\r\n\t\treturn developerCut.mul(_challengeFee/10000);\r\n\t}\r\n\t\r\n\t\r\n\t/***********************************************************************************/\r\n\t/* ADMIN FUNCTIONS\r\n\t/***********************************************************************************/\t\r\n\t/**\r\n\t* @dev External function for drafting new card for Owner, for promotional purposes\r\n\t* @param _cardLevel initial level of card created, must be less or equals to 20\r\n\t* @return uint of cardId\r\n\t*/\r\n\tfunction generateInitialCard(uint16 _cardLevel) external whenNotPaused onlyOwner returns (uint256) {\r\n\t\trequire(address(marketplace) != address(0), \"marketplace not set\"); //need to set up marketplace before drafting new cards is allowed\r\n\t\trequire(_cardLevel<=20, \"maximum level cannot exceed 20\"); //set maximum level at 20 that Owner can generate\r\n\t\t\r\n\t\thogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true); //let marketplace have approval for escrow if the card goes on sale\r\n\r\n\t\treturn _createCard(msg.sender, _cardLevel); //level 1 cards\r\n\t}\r\n\t\r\n\t/// @dev Function for contract owner to put tokens into ranks for events\r\n\tfunction distributeTokensToRank(uint[] ranks, uint256 tokensPerRank) external payable onlyOwner {\r\n\t\trequire(msg.value == (tokensPerRank*ranks.length), \"tokens must be enough to distribute among ranks\");\r\n\t\tuint i;\r\n\t\tfor (i=0; i<ranks.length; i++) {\r\n\t\t\trankTokens[ranks[i]] = rankTokens[ranks[i]].add(tokensPerRank);\r\n\t\t\ttotalRankTokens = totalRankTokens.add(tokensPerRank);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t// @dev Allows contract owner to withdraw the all developer cut from the contract\r\n\tfunction withdrawBalance() external onlyOwner {\r\n\t\taddress thisAddress = this;\r\n\t\tuint256 balance = thisAddress.balance;\r\n\t\tuint256 withdrawalSum = totalDeveloperCut;\r\n\r\n\t\tif (balance >= withdrawalSum) {\r\n\t\t\ttotalDeveloperCut = 0;\r\n\t\t\towner.transfer(withdrawalSum);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/***********************************************************************************/\r\n/* INTERFACES\r\n/***********************************************************************************/\r\ninterface Marketplace {\r\n\tfunction isMarketplace() external returns (bool);\r\n}\r\n\r\ninterface HogSmashToken {\r\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\r\n\tfunction balanceOf(address _owner) external view returns (uint256);\r\n\tfunction tokensOf(address _owner) external view returns (uint256[]);\r\n\tfunction mint(address _to) external returns (uint256 _tokenId);\r\n\tfunction setTokenURI(uint256 _tokenId, string _uri) external;\r\n\tfunction setApprovalForAllByContract(address _sender, address _to, bool _approved) external;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"gemCriticalRateConversion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeGems\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_upgradeGems\",\"type\":\"uint8\"},{\"name\":\"_upgradeGemsSpecial\",\"type\":\"uint8\"},{\"name\":\"_gemAttackConversion\",\"type\":\"uint16\"},{\"name\":\"_gemDefenseConversion\",\"type\":\"uint16\"},{\"name\":\"_gemHpConversion\",\"type\":\"uint16\"},{\"name\":\"_gemSpeedConversion\",\"type\":\"uint16\"},{\"name\":\"_gemCriticalRateConversion\",\"type\":\"uint16\"},{\"name\":\"_goldPercentage\",\"type\":\"uint8\"},{\"name\":\"_silverPercentage\",\"type\":\"uint8\"},{\"name\":\"_eventCardRangeMin\",\"type\":\"uint32\"},{\"name\":\"_eventCardRangeMax\",\"type\":\"uint32\"},{\"name\":\"_newMaxBattleRounds\",\"type\":\"uint8\"}],\"name\":\"setSettingValues\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_attackLevelUp\",\"type\":\"uint16\"},{\"name\":\"_defenseLevelUp\",\"type\":\"uint16\"},{\"name\":\"_hpLevelUp\",\"type\":\"uint16\"},{\"name\":\"_speedLevelUp\",\"type\":\"uint16\"},{\"name\":\"_criticalRateLevelUp\",\"type\":\"uint16\"},{\"name\":\"_flexiGemsLevelUp\",\"type\":\"uint16\"}],\"name\":\"levelUp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalDeveloperCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starterPackCardLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeFee\",\"type\":\"uint256\"}],\"name\":\"setChallengeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBattleRounds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ranks\",\"type\":\"uint256[]\"},{\"name\":\"tokensPerRank\",\"type\":\"uint256\"}],\"name\":\"distributeTokensToRank\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCardDrawPrice\",\"type\":\"uint256\"}],\"name\":\"setCardDrawPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventCardRangeMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStarterPackPrice\",\"type\":\"uint256\"},{\"name\":\"_newStarterPackCardLevel\",\"type\":\"uint16\"}],\"name\":\"setStarterPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starterPackPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gemAttackConversion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_challengerCardId\",\"type\":\"uint256\"},{\"name\":\"_statUp\",\"type\":\"uint32[5]\"},{\"name\":\"_defenderCardId\",\"type\":\"uint256\"},{\"name\":\"_defenderRank\",\"type\":\"uint256\"},{\"name\":\"_defenderLevel\",\"type\":\"uint16\"}],\"name\":\"challenge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gemSpeedConversion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rankTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStarterPackOnSale\",\"type\":\"bool\"}],\"name\":\"setStarterPackOnSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hogsmashToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeGemsSpecial\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cardId\",\"type\":\"uint256\"},{\"name\":\"avatarHash\",\"type\":\"uint256\"}],\"name\":\"updateAvatar\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBattleStart\",\"type\":\"bool\"}],\"name\":\"setBattleStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"silverPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalRankTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards\",\"outputs\":[{\"name\":\"element\",\"type\":\"uint8\"},{\"name\":\"level\",\"type\":\"uint16\"},{\"name\":\"attack\",\"type\":\"uint32\"},{\"name\":\"defense\",\"type\":\"uint32\"},{\"name\":\"hp\",\"type\":\"uint32\"},{\"name\":\"speed\",\"type\":\"uint32\"},{\"name\":\"criticalRate\",\"type\":\"uint16\"},{\"name\":\"flexiGems\",\"type\":\"uint32\"},{\"name\":\"cardHash\",\"type\":\"uint256\"},{\"name\":\"currentExp\",\"type\":\"uint32\"},{\"name\":\"expToNextLevel\",\"type\":\"uint32\"},{\"name\":\"createdDatetime\",\"type\":\"uint64\"},{\"name\":\"rank\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rank\",\"type\":\"uint256\"}],\"name\":\"getCardIdByRank\",\"outputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCard\",\"outputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"element\",\"type\":\"uint8\"},{\"name\":\"level\",\"type\":\"uint16\"},{\"name\":\"stats\",\"type\":\"uint32[]\"},{\"name\":\"currentExp\",\"type\":\"uint32\"},{\"name\":\"expToNextLevel\",\"type\":\"uint32\"},{\"name\":\"cardHash\",\"type\":\"uint256\"},{\"name\":\"createdDatetime\",\"type\":\"uint64\"},{\"name\":\"rank\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"draftNewCard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cardDrawPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gemHpConversion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"draftNewCardWithReferrer\",\"outputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cardLevel\",\"type\":\"uint16\"}],\"name\":\"generateInitialCard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketplace\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMarketplaceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAvatarFee\",\"type\":\"uint256\"}],\"name\":\"setAvatarFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newUpgradeFee\",\"type\":\"uint256\"}],\"name\":\"setUpgradeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gemDefenseConversion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"historyId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goldPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentElement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventCardRangeMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyStarterPack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDeveloperCut\",\"type\":\"uint256\"}],\"name\":\"setDeveloperCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newReferrerFee\",\"type\":\"uint256\"}],\"name\":\"setReferrerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avatarFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSettingValues\",\"outputs\":[{\"name\":\"_upgradeGems\",\"type\":\"uint8\"},{\"name\":\"_upgradeGemsSpecial\",\"type\":\"uint8\"},{\"name\":\"_gemAttackConversion\",\"type\":\"uint16\"},{\"name\":\"_gemDefenseConversion\",\"type\":\"uint16\"},{\"name\":\"_gemHpConversion\",\"type\":\"uint16\"},{\"name\":\"_gemSpeedConversion\",\"type\":\"uint16\"},{\"name\":\"_gemCriticalRateConversion\",\"type\":\"uint16\"},{\"name\":\"_maxBattleRounds\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"historyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"battleTime\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"sequence\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensGained\",\"type\":\"uint256\"}],\"name\":\"BattleHistory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"historyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"element\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"attack\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"defense\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"hp\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"speed\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"criticalRate\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"BattleHistoryChallenger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"historyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"element\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"attack\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"defense\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"hp\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"speed\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"criticalRate\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"BattleHistoryDefender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"challengerId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defenderId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defenderRank\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rejectCode\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"RejectChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cardHash\",\"type\":\"uint256\"}],\"name\":\"HashUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"LevelUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"CardCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Battle","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003a633c367c4276311c06d13c92a156f40a272c4c","Library":"","SwarmSource":"bzzr://bcbe2d0f8c761e0b8f5e6c28256e268c350d361db7e971d7fef2140b04cfee7e"}]}