{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n    function transfer(address receiver, uint amount) public;\r\n    function balanceOf(address receiver)public returns(uint);\r\n}\r\n\r\n///@title Axioms-Airdrops\r\n///@author  Lucasxhy & Kafcioo\r\n\r\ncontract Axioms {\r\n    Airdrop [] public airdrops;\r\n    address owner;\r\n    uint idCounter;\r\n    \r\n    ///@notice  Set the creator of the smart contract to be its sole owner\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    \r\n    ///@notice  Modifier to require a minimum amount fo ether for the function to add and airdrop\r\n    modifier minEth {\r\n        require(msg.value >= 2000); //Change this to amount of eth needed for gas fee in GWEI!\r\n        _;\r\n    }\r\n    ///@notice  Modifier that only allows the owner to execute a function\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract.\r\n    struct Airdrop {\r\n        uint id;\r\n        uint tokenAmount;\r\n        string name;\r\n        uint countDown;\r\n        address distributor;\r\n        Token tokenSC;\r\n        mapping(address => address) uniqueAirdrop;\r\n    }\r\n\r\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\r\n   function addNewAirdrop(\r\n   uint _tokenAmount,\r\n   string _name,\r\n   uint _countDown,\r\n   address  _smartContract\r\n   \r\n   )\r\n   public\r\n   minEth\r\n   payable\r\n   {\r\n       Token t = Token(_smartContract);\r\n       if(t.balanceOf(this)>=_tokenAmount){\r\n        uint lastIndex = airdrops.length++;\r\n        Airdrop storage airdrop = airdrops[lastIndex];\r\n        airdrop.id =idCounter;\r\n        airdrop.tokenAmount = _tokenAmount;\r\n        airdrop.name=_name;\r\n        airdrop.countDown=_countDown;\r\n        airdrop.distributor = msg.sender;\r\n        airdrop.tokenSC = Token(_smartContract);\r\n        airdrop.uniqueAirdrop[msg.sender]=_smartContract;\r\n        idCounter = airdrop.id+1;\r\n       }else revert('Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop');\r\n   }\r\n\r\n    ///@notice  Distirbutes a differen quantity of tokens to all the specified addresses.\r\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammounts\r\n    ///@param index  The airdrop to distribute based in the the array in which is saved\r\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\r\n    ///@param _vals  The set of values to be distributed to each address in array form\r\n    function distributeVariable(\r\n        uint index,\r\n        address[] _addrs,\r\n        uint[] _vals\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        if(timeGone(index)==true) {\r\n            Airdrop memory airdrop = airdrops[index];\r\n            for(uint i = 0; i < _addrs.length; ++i) {\r\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\r\n            }\r\n        } else revert(\"Distribution Failed: Count Down not gone yet\");\r\n    }\r\n\r\n    ///@notice  Distributes a constant quantity of tokens to all the specified addresses.\r\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\r\n    ///@param index The airdrop token to withdraw based in the the array in which is saved\r\n    ///@param _amoutToEach  The amount to be withdrawn from the smart contract\r\n    function distributeFixed(\r\n        uint index,\r\n        address[] _addrs,\r\n        uint _amoutToEach\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n         if(timeGone(index)==true) {\r\n            Airdrop memory airdrop = airdrops[index];\r\n            for(uint i = 0; i < _addrs.length; ++i) {\r\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\r\n            }\r\n        } else revert(\"Distribution Failed: Coun Down not gone yet\");\r\n    }\r\n\r\n// Refound tokens back to the to airdrop creator \r\n    function refoundTokens(\r\n        uint index,\r\n        address receiver,\r\n        address sc\r\n    )\r\n        public\r\n        onlyOwner\r\n    {   \r\n        \r\n        Airdrop memory airdrop = airdrops[index];\r\n        if(cheackIfAirDropIsUnique(index,receiver,sc)==true){\r\n        airdrop.tokenSC.transfer(airdrop.distributor,airdrop.tokenAmount);\r\n        }else revert();\r\n        \r\n    }\r\n    \r\n    // Refound eth left over from Distribution back to the airdrop creator \r\n      function refoundLeftOverEth (\r\n    uint index,\r\n    uint amount,\r\n    address receiver,\r\n    address sc\r\n    )\r\n      public \r\n      onlyOwner\r\n   {\r\n       Airdrop memory airdrop = airdrops[index];\r\n       if(cheackIfAirDropIsUnique(index,receiver,sc)==true){\r\n      airdrop.distributor.transfer(amount);\r\n       }else revert();\r\n   }\r\n    \r\n    ///@notice  Determines whether an aidrop is due to be distributed or not.\r\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\r\n   function timeGone(uint index) private view returns(bool){\r\n      Airdrop memory airdrop = airdrops[index];\r\n      uint timenow=now;\r\n      if ( airdrop.countDown <timenow){\r\n          return (true);\r\n      }else return (false);\r\n    }\r\n    \r\n    function cheackIfAirDropIsUnique(uint index, address receiver, address sc) private view returns(bool){\r\n        Airdrop storage airdrop = airdrops[index];\r\n        if(airdrop.uniqueAirdrop[receiver]==sc){\r\n            return true;\r\n        }else return false;\r\n    \r\n    }\r\n    function transferOwnership(address _newOwner) public onlyOwner(){\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_amoutToEach\",\"type\":\"uint256\"}],\"name\":\"distributeFixed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"sc\",\"type\":\"address\"}],\"name\":\"refoundLeftOverEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdrops\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"countDown\",\"type\":\"uint256\"},{\"name\":\"distributor\",\"type\":\"address\"},{\"name\":\"tokenSC\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_vals\",\"type\":\"uint256[]\"}],\"name\":\"distributeVariable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_countDown\",\"type\":\"uint256\"},{\"name\":\"_smartContract\",\"type\":\"address\"}],\"name\":\"addNewAirdrop\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"sc\",\"type\":\"address\"}],\"name\":\"refoundTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Axioms","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://926daba0a2eb8ad7dc30a356afb503effa1c3ec0f7e61abfc73debf62cf06578"}]}