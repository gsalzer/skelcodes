{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ninterface ITokenContract {\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n  \r\n    function transfer(\r\n        address _to, \r\n        uint256 _amount\r\n    )\r\n        external \r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _amount\r\n    ) \r\n        external \r\n        returns (bool success);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Supports ERC20 tokens\r\n* The escrow smart contract for the OpenBazaar trades in Ethereum\r\n* The smart contract is designed keeping in mind the current wallet interface\r\n* of OB-core:\r\n* https://github.com/OpenBazaar/wallet-interface/blob/master/wallet.go\r\n* Current wallet interface strictly adheres to UTXO(bitcoin) model\r\n* Please read below mentioned link for detailed specs\r\n* https://github.com/OpenBazaar/smart-contracts/blob/master/contracts/escrow/EscrowSpec.md\r\n*/\r\ncontract Escrow_v1_0 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    enum Status {FUNDED, RELEASED}\r\n\r\n    enum TransactionType {ETHER, TOKEN}\r\n\r\n    event Executed(\r\n        bytes32 indexed scriptHash,\r\n        address[] destinations,\r\n        uint256[] amounts\r\n    );\r\n\r\n    event FundAdded(\r\n        bytes32 indexed scriptHash,\r\n        address indexed from,\r\n        uint256 valueAdded\r\n    );\r\n\r\n    event Funded(\r\n        bytes32 indexed scriptHash,\r\n        address indexed from,\r\n        uint256 value\r\n    );\r\n\r\n    struct Transaction {\r\n        uint256 value;\r\n        uint256 lastModified; //time txn was last modified (in seconds)\r\n        Status status;\r\n        TransactionType transactionType;\r\n        uint8 threshold;\r\n        uint32 timeoutHours;\r\n        address buyer;\r\n        address seller;\r\n        address tokenAddress; //token address in case of token transfer\r\n        address moderator;\r\n        mapping(address => bool) isOwner; //to keep track of owners.\r\n        mapping(address => bool) voted; //to keep track of who all voted\r\n        mapping(address => bool) beneficiaries; //beneficiaries of execution\r\n    }\r\n\r\n    mapping(bytes32 => Transaction) public transactions;\r\n\r\n    uint256 public transactionCount = 0;\r\n\r\n    //Contains mapping between each party and all of their transactions\r\n    mapping(address => bytes32[]) private partyVsTransaction;\r\n\r\n    modifier transactionExists(bytes32 scriptHash) {\r\n        require(\r\n            transactions[scriptHash].value != 0, \"Transaction does not exist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier transactionDoesNotExist(bytes32 scriptHash) {\r\n        require(transactions[scriptHash].value == 0, \"Transaction exists\");\r\n        _;\r\n    }\r\n\r\n    modifier inFundedState(bytes32 scriptHash) {\r\n        require(\r\n            transactions[scriptHash].status == Status.FUNDED,\r\n            \"Transaction is not in FUNDED state\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address addressToCheck) {\r\n        require(addressToCheck != address(0), \"Zero address passed\");\r\n        _;\r\n    }\r\n\r\n    modifier checkTransactionType(\r\n        bytes32 scriptHash,\r\n        TransactionType transactionType\r\n    )\r\n    {\r\n        require(\r\n            transactions[scriptHash].transactionType == transactionType,\r\n            \"Transaction type does not match\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyBuyer(bytes32 scriptHash) {\r\n        require(\r\n            msg.sender == transactions[scriptHash].buyer,\r\n            \"The initiator of the transaction is not buyer\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Add new transaction in the contract\r\n    * @param buyer The buyer of the transaction\r\n    * @param seller The seller of the listing associated with the transaction\r\n    * @param moderator Moderator for this transaction\r\n    * @param threshold Minimum number of signatures required to released funds\r\n    * @param timeoutHours Hours after which seller can release funds into his\r\n    * favour by signing transaction unilaterally\r\n    * @param scriptHash keccak256 hash of the redeem script\r\n    * @param uniqueId bytes20 unique id for the transaction, generated by\r\n    * ETH wallet\r\n    * Redeem Script format will be following\r\n    * <uniqueId: 20><threshold:1><timeoutHours:4><buyer:20><seller:20>\r\n    * <moderator:20><multisigAddress:20>\r\n    * Pass amount of the ETH to be put in escrow\r\n    */\r\n    function addTransaction(\r\n        address buyer,\r\n        address seller,\r\n        address moderator,\r\n        uint8 threshold,\r\n        uint32 timeoutHours,\r\n        bytes32 scriptHash,\r\n        bytes20 uniqueId\r\n    )\r\n        external\r\n        payable\r\n        transactionDoesNotExist(scriptHash)\r\n        nonZeroAddress(buyer)\r\n        nonZeroAddress(seller)\r\n    {\r\n        _addTransaction(\r\n            buyer,\r\n            seller,\r\n            moderator,\r\n            threshold,\r\n            timeoutHours,\r\n            scriptHash,\r\n            msg.value,\r\n            uniqueId,\r\n            TransactionType.ETHER,\r\n            address(0)\r\n        );\r\n\r\n        emit Funded(scriptHash, msg.sender, msg.value);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Add new transaction in the contract\r\n    * @param buyer The buyer of the transaction\r\n    * @param seller The seller of the listing associated with the transaction\r\n    * @param moderator Moderator for this transaction\r\n    * @param threshold Minimum number of signatures required to released funds\r\n    * @param timeoutHours Hours after which seller can release funds into his\r\n    * favour by signing transaction unilaterally\r\n    * @param scriptHash keccak256 hash of the redeem script\r\n    * @param value Amount of tokens to be put in escrow\r\n    * @param uniqueId bytes20 unique id for the transaction, generated by\r\n    * ETH wallet\r\n    * @param tokenAddress Address of the token to be used\r\n    * Redeem Script format will be following:\r\n    * <uniqueId: 20><threshold:1><timeoutHours:4><buyer:20><seller:20>\r\n    * <moderator:20><multisigAddress:20><tokenAddress:20>\r\n    * Approve escrow contract to spend amount of token on sender's behalf\r\n    */\r\n    function addTokenTransaction(\r\n        address buyer,\r\n        address seller,\r\n        address moderator,\r\n        uint8 threshold,\r\n        uint32 timeoutHours,\r\n        bytes32 scriptHash,\r\n        uint256 value,\r\n        bytes20 uniqueId,\r\n        address tokenAddress\r\n    )\r\n        external\r\n        transactionDoesNotExist(scriptHash)\r\n        nonZeroAddress(buyer)\r\n        nonZeroAddress(seller)\r\n        nonZeroAddress(tokenAddress)\r\n    {\r\n\r\n        _addTransaction(\r\n            buyer,\r\n            seller,\r\n            moderator,\r\n            threshold,\r\n            timeoutHours,\r\n            scriptHash,\r\n            value,\r\n            uniqueId,\r\n            TransactionType.TOKEN,\r\n            tokenAddress\r\n        );\r\n\r\n        ITokenContract token = ITokenContract(tokenAddress);\r\n\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), value),\r\n            \"Token transfer failed, maybe you did not approve escrow contract to spend on behalf of sender\"\r\n        );\r\n        emit Funded(scriptHash, msg.sender, value);\r\n    }\r\n\r\n    /**\r\n    * @dev This method will check whether given address was a beneficiary of\r\n    * transaction execution or not\r\n    * @param scriptHash script hash of the transaction\r\n    * @param beneficiary Beneficiary address to be checked\r\n    */\r\n    function checkBeneficiary(\r\n        bytes32 scriptHash,\r\n        address beneficiary\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return transactions[scriptHash].beneficiaries[beneficiary];\r\n    }\r\n\r\n    /**\r\n    * @dev This method will check whether given party has voted or not\r\n    * @param scriptHash script hash of the transaction\r\n    * @param party Address of the party whose vote has to be checked\r\n    * @return bool vote\r\n    */\r\n    function checkVote(\r\n        bytes32 scriptHash,\r\n        address party\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return transactions[scriptHash].voted[party];\r\n    }\r\n\r\n    /**\r\n    * @dev Allows buyer of the transaction to add more funds(ether) in the\r\n    * transaction.\r\n    * This will help to cater scenarios wherein initially buyer missed to\r\n    * fund transaction as required\r\n    * @param scriptHash script hash of the transaction\r\n    * Only buyer of the transaction can invoke this method\r\n    */\r\n    function addFundsToTransaction(\r\n        bytes32 scriptHash\r\n    )\r\n        external\r\n        payable\r\n        transactionExists(scriptHash)\r\n        inFundedState(scriptHash)\r\n        checkTransactionType(scriptHash, TransactionType.ETHER)\r\n        onlyBuyer(scriptHash)\r\n\r\n    {\r\n\r\n        require(msg.value > 0, \"Value must be greater than zero.\");\r\n\r\n        transactions[scriptHash].value = transactions[scriptHash].value\r\n            .add(msg.value);\r\n\r\n        emit FundAdded(scriptHash, msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows buyer of the transaction to add more funds(Tokens) in the\r\n    * transaction.\r\n    * This will help to cater scenarios wherein initially buyer missed to\r\n    * fund transaction as required\r\n    * @param scriptHash script hash of the transaction\r\n    * Only buyer of the transaction can invoke this method\r\n    */\r\n    function addTokensToTransaction(\r\n        bytes32 scriptHash,\r\n        uint256 value\r\n    )\r\n        external\r\n        transactionExists(scriptHash)\r\n        inFundedState(scriptHash)\r\n        checkTransactionType(scriptHash, TransactionType.TOKEN)\r\n        onlyBuyer(scriptHash)\r\n    {\r\n\r\n        require(value > 0, \"Value must be greater than zero.\");\r\n\r\n        ITokenContract token = ITokenContract(\r\n            transactions[scriptHash].tokenAddress\r\n        );\r\n\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), value),\r\n            \"Token transfer failed, maybe you did not approve the escrow contract to spend on behalf of the buyer\"\r\n        );\r\n\r\n        transactions[scriptHash].value = transactions[scriptHash].value\r\n            .add(value);\r\n\r\n        emit FundAdded(scriptHash, msg.sender, value);\r\n    }\r\n\r\n    /**\r\n    *@dev Returns all transaction ids for a party\r\n    *@param partyAddress Address of the party\r\n    */\r\n    function getAllTransactionsForParty(\r\n        address partyAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bytes32[])\r\n    {\r\n        return partyVsTransaction[partyAddress];\r\n    }\r\n\r\n    /**\r\n    *@dev This method will be used to release funds associated with\r\n    * the transaction\r\n    * Please see specs https://github.com/OpenBazaar/smart-contracts/blob/master/contracts/escrow/EscrowSpec.md\r\n    *@param sigV Array containing V component of all the signatures\r\n    *@param sigR Array containing R component of all the signatures\r\n    *@param signS Array containing S component of all the signatures\r\n    *@param scriptHash script hash of the transaction\r\n    *@param destinations List of addresses who will receive funds\r\n    *@param amounts amount released to each destination\r\n    */\r\n    function execute(\r\n        uint8[] sigV,\r\n        bytes32[] sigR,\r\n        bytes32[] sigS,\r\n        bytes32 scriptHash,\r\n        address[] destinations,\r\n        uint256[] amounts\r\n    )\r\n        external\r\n        transactionExists(scriptHash)\r\n        inFundedState(scriptHash)\r\n    {\r\n\r\n        require(\r\n            destinations.length > 0,\r\n            \"Number of destinations must be greater than 0\"\r\n        );\r\n        require(\r\n            destinations.length == amounts.length,\r\n            \"Number of destinations must match number of values sent\"\r\n        );\r\n\r\n        _verifyTransaction(\r\n            sigV,\r\n            sigR,\r\n            sigS,\r\n            scriptHash,\r\n            destinations,\r\n            amounts\r\n        );\r\n\r\n        transactions[scriptHash].status = Status.RELEASED;\r\n        //Last modified timestamp modified, which will be used by rewards\r\n        transactions[scriptHash].lastModified = block.timestamp;\r\n        require(\r\n            _transferFunds(scriptHash, destinations, amounts) == transactions[scriptHash].value,\r\n            \"Total value to be released must be equal to the transaction escrow value\"\r\n        );\r\n\r\n        emit Executed(scriptHash, destinations, amounts);\r\n    }\r\n\r\n\r\n    /**\r\n    *@dev Method for calculating script hash. Calculation will depend upon\r\n    * the type of transaction\r\n    * ETHER Type transaction-:\r\n    * Script Hash- keccak256(uniqueId, threshold, timeoutHours, buyer, seller,\r\n    * moderator, multiSigContractAddress)\r\n    * TOKEN Type transaction\r\n    * Script Hash- keccak256(uniqueId, threshold, timeoutHours, buyer, seller,\r\n    * moderator, multiSigContractAddress, tokenAddress)\r\n    * Client can use this method to verify whether it has calculated correct\r\n    * script hash or not\r\n    */\r\n    function calculateRedeemScriptHash(\r\n        bytes20 uniqueId,\r\n        uint8 threshold,\r\n        uint32 timeoutHours,\r\n        address buyer,\r\n        address seller,\r\n        address moderator,\r\n        address tokenAddress\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        if (tokenAddress == address(0)) {\r\n            return keccak256(\r\n                abi.encodePacked(\r\n                    uniqueId,\r\n                    threshold,\r\n                    timeoutHours,\r\n                    buyer,\r\n                    seller,\r\n                    moderator,\r\n                    address(this)\r\n                )\r\n            );\r\n        } else {\r\n            return keccak256(\r\n                abi.encodePacked(\r\n                    uniqueId,\r\n                    threshold,\r\n                    timeoutHours,\r\n                    buyer,\r\n                    seller,\r\n                    moderator,\r\n                    address(this),\r\n                    tokenAddress\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev This methods checks validity of transaction\r\n    * 1. Verify Signatures\r\n    * 2. Check if minimum number of signatures has been acquired\r\n    * 3. If above condition is false, check if timelock is expired or if the\r\n    *    execution is signed by seller\r\n    */\r\n    function _verifyTransaction(\r\n        uint8[] sigV,\r\n        bytes32[] sigR,\r\n        bytes32[] sigS,\r\n        bytes32 scriptHash,\r\n        address[] destinations,\r\n        uint256[] amounts\r\n    )\r\n        private\r\n    {\r\n        _verifySignatures(\r\n            sigV,\r\n            sigR,\r\n            sigS,\r\n            scriptHash,\r\n            destinations,\r\n            amounts\r\n        );\r\n\r\n        bool timeLockExpired = _isTimeLockExpired(\r\n            transactions[scriptHash].timeoutHours,\r\n            transactions[scriptHash].lastModified\r\n        );\r\n\r\n        //if the minimum number of signatures are not gathered and either\r\n        //timelock has not expired or transaction was not signed by seller\r\n        //then revert\r\n        if (sigV.length < transactions[scriptHash].threshold) {\r\n            if (!timeLockExpired) {\r\n                revert(\"Min number of sigs not present and timelock not expired\");\r\n            }\r\n            else if (!transactions[scriptHash].voted[transactions[scriptHash].seller]) {\r\n                revert(\"Min number of sigs not present and seller did not sign\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *@dev Private method to transfer funds to the destination addresses on\r\n    * the basis of transaction type\r\n    */\r\n    function _transferFunds(\r\n        bytes32 scriptHash,\r\n        address[]destinations,\r\n        uint256[]amounts\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        Transaction storage t = transactions[scriptHash];\r\n\r\n        uint256 valueTransferred = 0;\r\n\r\n        if (t.transactionType == TransactionType.ETHER) {\r\n            for (uint256 i = 0; i < destinations.length; i++) {\r\n\r\n                require(\r\n                    destinations[i] != address(0),\r\n                    \"zero address is not allowed as destination address\"\r\n                );\r\n\r\n                require(\r\n                    t.isOwner[destinations[i]],\r\n                    \"Destination address is not one of the owners\"\r\n                );\r\n\r\n                require(\r\n                    amounts[i] > 0,\r\n                    \"Amount to be sent should be greater than 0\"\r\n                );\r\n\r\n                valueTransferred = valueTransferred.add(amounts[i]);\r\n\r\n                //add receiver as beneficiary\r\n                t.beneficiaries[destinations[i]] = true;\r\n                destinations[i].transfer(amounts[i]);\r\n            }\r\n\r\n        } else if (t.transactionType == TransactionType.TOKEN) {\r\n\r\n            ITokenContract token = ITokenContract(t.tokenAddress);\r\n\r\n            for (uint256 j = 0; j<destinations.length; j++) {\r\n\r\n                require(\r\n                    destinations[j] != address(0),\r\n                    \"zero address is not allowed as destination address\"\r\n                );\r\n\r\n                require(\r\n                    t.isOwner[destinations[j]],\r\n                    \"Destination address is not one of the owners\"\r\n                );\r\n\r\n                require(\r\n                    amounts[j] > 0,\r\n                    \"Amount to be sent should be greater than 0\"\r\n                );\r\n\r\n                valueTransferred = valueTransferred.add(amounts[j]);\r\n\r\n                //add receiver as beneficiary\r\n                t.beneficiaries[destinations[j]] = true;\r\n\r\n                require(\r\n                    token.transfer(destinations[j], amounts[j]),\r\n                    \"Token transfer failed.\"\r\n                );\r\n            }\r\n        }\r\n        return valueTransferred;\r\n    }\r\n\r\n\r\n    /**\r\n    *@dev Checks whether the signatures are valid or not and marks signers as\r\n    * having \"voted\".\r\n    */\r\n    function _verifySignatures(\r\n        uint8[] sigV,\r\n        bytes32[] sigR,\r\n        bytes32[] sigS,\r\n        bytes32 scriptHash,\r\n        address[] destinations,\r\n        uint256[]amounts\r\n    )\r\n        private\r\n    {\r\n        require(sigR.length == sigS.length, \"R,S length mismatch\");\r\n        require(sigR.length == sigV.length, \"R,V length mismatch\");\r\n\r\n        // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191\r\n        bytes32 txHash = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19),\r\n                        byte(0),\r\n                        address(this),\r\n                        destinations,\r\n                        amounts,\r\n                        scriptHash\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        for (uint i = 0; i < sigR.length; i++) {\r\n\r\n            address recovered = ecrecover(\r\n                txHash,\r\n                sigV[i],\r\n                sigR[i],\r\n                sigS[i]\r\n            );\r\n\r\n            require(\r\n                transactions[scriptHash].isOwner[recovered],\r\n                \"Invalid signature\"\r\n            );\r\n            require(\r\n                !transactions[scriptHash].voted[recovered],\r\n                \"Same signature sent twice\"\r\n            );\r\n            transactions[scriptHash].voted[recovered] = true;\r\n        }\r\n    }\r\n\r\n    function _isTimeLockExpired(\r\n        uint32 timeoutHours,\r\n        uint256 lastModified\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 timeSince = now.sub(lastModified);\r\n        return (\r\n            timeoutHours == 0 ? false : timeSince > uint256(timeoutHours).mul(3600)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * Private method to add transaction to reduce code redundancy\r\n    */\r\n    function _addTransaction(\r\n        address buyer,\r\n        address seller,\r\n        address moderator,\r\n        uint8 threshold,\r\n        uint32 timeoutHours,\r\n        bytes32 scriptHash,\r\n        uint256 value,\r\n        bytes20 uniqueId,\r\n        TransactionType transactionType,\r\n        address tokenAddress\r\n    )\r\n        private\r\n    {\r\n        require(buyer != seller, \"Buyer and seller are same\");\r\n\r\n        //value passed should be greater than 0\r\n        require(value > 0, \"Value passed is 0\");\r\n\r\n        // For now allowing 0 moderator to support 1-2 multisig wallet\r\n        require(threshold > 0, \"Threshold must be greater than 0\");\r\n        require(threshold <= 3, \"Threshold must not be greater than 3\");\r\n\r\n        //if threshold is 1 then moderator can be any address\r\n        //otherwise moderator should be a valid address\r\n        require(\r\n            threshold == 1 || moderator != address(0),\r\n            \"Either threshold should be 1 or valid moderator address should be passed\"\r\n        );\r\n\r\n        require(\r\n            scriptHash == calculateRedeemScriptHash(\r\n                uniqueId,\r\n                threshold,\r\n                timeoutHours,\r\n                buyer,\r\n                seller,\r\n                moderator,\r\n                tokenAddress\r\n            ),\r\n            \"Calculated script hash does not match passed script hash.\"\r\n        );\r\n\r\n        transactions[scriptHash] = Transaction({\r\n            buyer: buyer,\r\n            seller: seller,\r\n            moderator: moderator,\r\n            value: value,\r\n            status: Status.FUNDED,\r\n            lastModified: block.timestamp,\r\n            threshold: threshold,\r\n            timeoutHours: timeoutHours,\r\n            transactionType:transactionType,\r\n            tokenAddress:tokenAddress\r\n        });\r\n\r\n        transactions[scriptHash].isOwner[seller] = true;\r\n        transactions[scriptHash].isOwner[buyer] = true;\r\n\r\n        //check if buyer or seller are not passed as moderator\r\n        require(\r\n            !transactions[scriptHash].isOwner[moderator],\r\n            \"Either buyer or seller is passed as moderator\"\r\n        );\r\n\r\n        //set moderator as one of the owners only if threshold is greater than\r\n        // 1 otherwise only buyer and seller should be able to release funds\r\n        if (threshold > 1) {\r\n            transactions[scriptHash].isOwner[moderator] = true;\r\n        }\r\n\r\n\r\n        transactionCount++;\r\n\r\n        partyVsTransaction[buyer].push(scriptHash);\r\n        partyVsTransaction[seller].push(scriptHash);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"moderator\",\"type\":\"address\"},{\"name\":\"threshold\",\"type\":\"uint8\"},{\"name\":\"timeoutHours\",\"type\":\"uint32\"},{\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"name\":\"uniqueId\",\"type\":\"bytes20\"}],\"name\":\"addTransaction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"scriptHash\",\"type\":\"bytes32\"}],\"name\":\"addFundsToTransaction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uniqueId\",\"type\":\"bytes20\"},{\"name\":\"threshold\",\"type\":\"uint8\"},{\"name\":\"timeoutHours\",\"type\":\"uint32\"},{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"moderator\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"calculateRedeemScriptHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"moderator\",\"type\":\"address\"},{\"name\":\"threshold\",\"type\":\"uint8\"},{\"name\":\"timeoutHours\",\"type\":\"uint32\"},{\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"uniqueId\",\"type\":\"bytes20\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addTokenTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"lastModified\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"transactionType\",\"type\":\"uint8\"},{\"name\":\"threshold\",\"type\":\"uint8\"},{\"name\":\"timeoutHours\",\"type\":\"uint32\"},{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"moderator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"checkBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"addTokensToTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partyAddress\",\"type\":\"address\"}],\"name\":\"getAllTransactionsForParty\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sigV\",\"type\":\"uint8[]\"},{\"name\":\"sigR\",\"type\":\"bytes32[]\"},{\"name\":\"sigS\",\"type\":\"bytes32[]\"},{\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"name\":\"destinations\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"name\":\"party\",\"type\":\"address\"}],\"name\":\"checkVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"destinations\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueAdded\",\"type\":\"uint256\"}],\"name\":\"FundAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"scriptHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"}]","ContractName":"Escrow_v1_0","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://820184516f7c71f5a640f6dbff04a5616950e06c6cfb14e2ca4a738762bcdbb2"}]}