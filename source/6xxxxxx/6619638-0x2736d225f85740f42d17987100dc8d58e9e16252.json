{"status":"1","message":"OK","result":[{"SourceCode":"/***********************************************************\r\n* This file is part of the Slock.it IoT Layer.             *\r\n* The Slock.it IoT Layer contains:                         *\r\n*   - USN (Universal Sharing Network)                      *\r\n*   - INCUBED (Trustless INcentivized remote Node Network) *\r\n************************************************************\r\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\r\n* All Rights Reserved.                                     *\r\n************************************************************\r\n* You may use, distribute and modify this code under the   *\r\n* terms of the license contract you have concluded with    *\r\n* Slock.it GmbH.                                           *\r\n* For information about liability, maintenance etc. also   *\r\n* refer to the contract concluded with Slock.it GmbH.      *\r\n************************************************************\r\n* For more information, please refer to https://slock.it    *\r\n* For questions, please contact info@slock.it              *\r\n***********************************************************/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/// @title Registry for IN3-Servers\r\ncontract ServerRegistry {\r\n\r\n    /// server has been registered or updated its registry props or deposit\r\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\r\n\r\n    ///  a caller requested to unregister a server.\r\n    event LogServerUnregisterRequested(string url, address owner, address caller);\r\n\r\n    /// the owner canceled the unregister-proccess\r\n    event LogServerUnregisterCanceled(string url, address owner);\r\n\r\n    /// a Server was convicted\r\n    event LogServerConvicted(string url, address owner);\r\n\r\n    /// a Server is removed\r\n    event LogServerRemoved(string url, address owner);\r\n\r\n    struct In3Server {\r\n        string url;  // the url of the server\r\n        address owner; // the owner, which is also the key to sign blockhashes\r\n        uint deposit; // stored deposit\r\n        uint props; // a list of properties-flags representing the capabilities of the server\r\n\r\n        // unregister state\r\n        uint128 unregisterTime; // earliest timestamp in to to call unregister\r\n        uint128 unregisterDeposit; // Deposit for unregistering\r\n        address unregisterCaller; // address of the caller requesting the unregister\r\n    }\r\n\r\n    /// server list of incubed nodes    \r\n    In3Server[] public servers;\r\n\r\n    // index for unique url and owner\r\n    mapping (address => bool) ownerIndex;\r\n    mapping (bytes32 => bool) urlIndex;\r\n    \r\n    /// length of the serverlist\r\n    function totalServers() public view returns (uint)  {\r\n        return servers.length;\r\n    }\r\n\r\n    /// register a new Server with the sender as owner    \r\n    function registerServer(string _url, uint _props) public payable {\r\n        checkLimits();\r\n\r\n        bytes32 urlHash = keccak256(bytes(_url));\r\n\r\n        // make sure this url and also this owner was not registered before.\r\n        require (!urlIndex[urlHash] && !ownerIndex[msg.sender], \"a Server with the same url or owner is already registered\");\r\n\r\n        // add new In3Server\r\n        In3Server memory m;\r\n        m.url = _url;\r\n        m.props = _props;\r\n        m.owner = msg.sender;\r\n        m.deposit = msg.value;\r\n        servers.push(m);\r\n\r\n        // make sure they are used\r\n        urlIndex[urlHash] = true;\r\n        ownerIndex[msg.sender] = true;\r\n\r\n        // emit event\r\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\r\n    }\r\n\r\n    /// updates a Server by adding the msg.value to the deposit and setting the props    \r\n    function updateServer(uint _serverIndex, uint _props) public payable {\r\n        checkLimits();\r\n\r\n        In3Server storage server = servers[_serverIndex];\r\n        require(server.owner == msg.sender, \"only the owner may update the server\");\r\n\r\n        if (msg.value>0) \r\n          server.deposit += msg.value;\r\n\r\n        if (_props!=server.props)\r\n          server.props = _props;\r\n        emit LogServerRegistered(server.url, _props, msg.sender,server.deposit);\r\n    }\r\n\r\n    /// this should be called before unregistering a server.\r\n    /// there are 2 use cases:\r\n    /// a) the owner wants to stop offering the service and remove the server.\r\n    ///    in this case he has to wait for one hour before actually removing the server. \r\n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\r\n    /// b) anybody can request to remove a server because it has been inactive.\r\n    ///    in this case he needs to pay a small deposit, which he will lose \r\n    //       if the owner become active again \r\n    //       or the caller will receive 20% of the deposit in case the owner does not react.\r\n    function requestUnregisteringServer(uint _serverIndex) payable public {\r\n\r\n        In3Server storage server = servers[_serverIndex];\r\n\r\n        // this can only be called if nobody requested it before\r\n        require(server.unregisterCaller == address(0x0), \"Server is already unregistering\");\r\n\r\n        if (server.unregisterCaller == server.owner) \r\n           server.unregisterTime = uint128(now + 1 hours);\r\n        else {\r\n            server.unregisterTime = uint128(now + 28 days); // 28 days are always good ;-) \r\n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\r\n            require(msg.value == calcUnregisterDeposit(_serverIndex), \"the exact calcUnregisterDeposit is required to request unregister\");\r\n            server.unregisterDeposit = uint128(msg.value);\r\n        }\r\n        server.unregisterCaller = msg.sender;\r\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender);\r\n    }\r\n    \r\n    /// this function must be called by the caller of the requestUnregisteringServer-function after 28 days\r\n    /// if the owner did not cancel, the caller will receive 20% of the server deposit + his own deposit.\r\n    /// the owner will receive 80% of the server deposit before the server will be removed.\r\n    function confirmUnregisteringServer(uint _serverIndex) public {\r\n        In3Server storage server = servers[_serverIndex];\r\n        // this can only be called if somebody requested it before\r\n        require(server.unregisterCaller != address(0x0) && server.unregisterTime < now, \"Only the caller is allowed to confirm\");\r\n\r\n        uint payBackOwner = server.deposit;\r\n        if (server.unregisterCaller != server.owner) {\r\n            payBackOwner -= server.deposit / 5;  // the owner will only receive 80% of his deposit back.\r\n            server.unregisterCaller.transfer(server.unregisterDeposit + server.deposit - payBackOwner);\r\n        }\r\n\r\n        if (payBackOwner > 0)\r\n            server.owner.transfer(payBackOwner);\r\n\r\n        removeServer(_serverIndex);\r\n    }\r\n\r\n    /// this function must be called by the owner to cancel the unregister-process.\r\n    /// if the caller is not the owner, then he will also get the deposit paid by the caller.\r\n    function cancelUnregisteringServer(uint _serverIndex) public {\r\n        In3Server storage server = servers[_serverIndex];\r\n\r\n        // this can only be called by the owner and if somebody requested it before\r\n        require(server.unregisterCaller != address(0) && server.owner == msg.sender, \"only the owner is allowed to cancel unregister\");\r\n\r\n        // if this was requested by somebody who does not own this server,\r\n        // the owner will get his deposit\r\n        if (server.unregisterCaller != server.owner) \r\n            server.owner.transfer(server.unregisterDeposit);\r\n\r\n        // set back storage values\r\n        server.unregisterCaller = address(0);\r\n        server.unregisterTime = 0;\r\n        server.unregisterDeposit = 0;\r\n\r\n        /// emit event\r\n        emit LogServerUnregisterCanceled(server.url, server.owner);\r\n    }\r\n\r\n\r\n    /// convicts a server that signed a wrong blockhash\r\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\r\n        bytes32 evm_blockhash = blockhash(_blocknumber);\r\n        \r\n        // if the blockhash is correct you cannot convict the server\r\n        require(evm_blockhash != 0x0 && evm_blockhash != _blockhash, \"the block is too old or you try to convict with a correct hash\");\r\n\r\n        // make sure the hash was signed by the owner of the server\r\n        require(\r\n            ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner, \r\n            \"the block was not signed by the owner of the server\");\r\n\r\n        // remove the deposit\r\n        if (servers[_serverIndex].deposit > 0) {\r\n            uint payout = servers[_serverIndex].deposit / 2;\r\n            // send 50% to the caller of this function\r\n            msg.sender.transfer(payout);\r\n\r\n            // and burn the rest by sending it to the 0x0-address\r\n            // this is done in order to make it useless trying to convict your own server with a second account\r\n            // and this getting all the deposit back after signing a wrong hash.\r\n            address(0).transfer(servers[_serverIndex].deposit-payout);\r\n        }\r\n\r\n        // emit event\r\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\r\n        \r\n        removeServer(_serverIndex);\r\n    }\r\n\r\n    /// calculates the minimum deposit you need to pay in order to request unregistering of a server.\r\n    function calcUnregisterDeposit(uint _serverIndex) public view returns(uint128) {\r\n         // cancelUnregisteringServer costs 22k gas, we took about twist that much due to volatility of gasPrices\r\n        return uint128(servers[_serverIndex].deposit / 50 + tx.gasprice * 50000);\r\n    }\r\n\r\n    // internal helper functions\r\n    \r\n    function removeServer(uint _serverIndex) internal {\r\n        // trigger event\r\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner);\r\n\r\n        // remove from unique index\r\n        urlIndex[keccak256(bytes(servers[_serverIndex].url))] = false;\r\n        ownerIndex[servers[_serverIndex].owner] = false;\r\n\r\n        uint length = servers.length;\r\n        if (length>0) {\r\n            // move the last entry to the removed one.\r\n            In3Server memory m = servers[length - 1];\r\n            servers[_serverIndex] = m;\r\n        }\r\n        servers.length--;\r\n    }\r\n\r\n    function checkLimits() internal view {\r\n        // within the next 6 months this contract may never hold more than 50 ETH\r\n        if (now < 1560808800)\r\n           require(address(this).balance < 50 ether, \"Limit of 50 ETH reached\");\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalServers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serverIndex\",\"type\":\"uint256\"},{\"name\":\"_props\",\"type\":\"uint256\"}],\"name\":\"updateServer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_url\",\"type\":\"string\"},{\"name\":\"_props\",\"type\":\"uint256\"}],\"name\":\"registerServer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"servers\",\"outputs\":[{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"props\",\"type\":\"uint256\"},{\"name\":\"unregisterTime\",\"type\":\"uint128\"},{\"name\":\"unregisterDeposit\",\"type\":\"uint128\"},{\"name\":\"unregisterCaller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serverIndex\",\"type\":\"uint256\"}],\"name\":\"cancelUnregisteringServer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serverIndex\",\"type\":\"uint256\"},{\"name\":\"_blockhash\",\"type\":\"bytes32\"},{\"name\":\"_blocknumber\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"convict\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_serverIndex\",\"type\":\"uint256\"}],\"name\":\"calcUnregisterDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serverIndex\",\"type\":\"uint256\"}],\"name\":\"confirmUnregisteringServer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serverIndex\",\"type\":\"uint256\"}],\"name\":\"requestUnregisteringServer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"props\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"LogServerRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"LogServerUnregisterRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogServerUnregisterCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogServerConvicted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogServerRemoved\",\"type\":\"event\"}]","ContractName":"ServerRegistry","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c6ea0fa6fc31737d9c24b2614a8fd765bc2e2012834a860eb41b8239cc143409"}]}