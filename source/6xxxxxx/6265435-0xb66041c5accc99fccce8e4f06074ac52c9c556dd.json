{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\nlibrary SafeMathExt{\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (b == 0){\r\n      return 1;\r\n    }\r\n    if (b == 1){\r\n      return a;\r\n    }\r\n    uint256 c = a;\r\n    for(uint i = 1; i<b; i++){\r\n      c = mul(c, a);\r\n    }\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function roundUp(uint256 a, uint256 b) public pure returns(uint256){\r\n    // ((a + b - 1) / b) * b\r\n    uint256 c = (mul(div(sub(add(a, b), 1), b), b));\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary PureAmber{\r\n    /*==============================\r\n    =             BUY              =\r\n    ==============================*/\r\n    function isValidBuy(uint256 price_, uint256 msgValue_) public pure returns(bool){\r\n        return (price_ == msgValue_);\r\n    }\r\n    function refererAllowed(address msgSender_, address currentReferer_, address newReferer_) public pure returns(bool){\r\n        return (addressNotSet(currentReferer_) && isAddress(newReferer_) && isNotSelf(msgSender_, newReferer_));\r\n    }\r\n    function addressNotSet(address address_) public pure returns(bool){\r\n        return (address_ == 0x0);\r\n    }\r\n    function isAddress(address address_) public pure returns(bool){\r\n        return (address_ != 0x0);\r\n    }\r\n    function isNotSelf(address msgSender_, address compare_) public pure returns(bool){\r\n        return (msgSender_ != compare_);\r\n    }\r\n\r\n    /*==============================\r\n    =         BADGE SYSTEM         =\r\n    ==============================*/\r\n    function isFirstBadgeEle(uint256 badgeID_) public pure returns(bool){\r\n        return (badgeID_ == 0);\r\n    }\r\n    function isLastBadgeEle(uint256 badgeID_, uint256 badgeLength_) public pure returns(bool){\r\n        assert(badgeID_ <= SafeMathExt.sub(badgeLength_, 1));\r\n        return (badgeID_ == SafeMathExt.sub(badgeLength_, 1));\r\n    }\r\n\r\n    function roundUp(uint256 input_, uint256 decimals_) public pure returns(uint256){\r\n        return ((input_ + decimals_ - 1) / decimals_) * decimals_;\r\n    }\r\n\r\n    /*==============================\r\n    =          DIVI SPLIT          =\r\n    ==============================*/   \r\n    function calcShare(uint256 msgValue_, uint256 ratio_) public pure returns(uint256){\r\n        assert(ratio_ <= 100 && msgValue_ >= 0);\r\n        return SafeMathExt.div((SafeMathExt.mul(msgValue_, ratio_)), 100);\r\n    }\r\n    function calcDiviDistribution(uint256 value_, uint256 userCount_) public pure returns(uint256){\r\n        assert(value_ >= 0);\r\n        return SafeMathExt.div(value_, userCount_);\r\n    }\r\n}\r\n\r\ncontract BadgeFactoryInterface{\r\n\tfunction _initBadges(address admin_, uint256 badgeBasePrice_, uint256 badgeStartMultiplier_, uint256 badgeStartQuantity_) external;\r\n\tfunction _createNewBadge(address owner_, uint256 price_) external;\r\n\tfunction _setOwner(uint256 badgeID_, address owner_) external;\r\n\tfunction getOwner(uint256 badgeID_) public view returns(address);\r\n\tfunction _increasePrice(uint256 badgeID_) external;\r\n\tfunction getPrice(uint256 badgeID_) public view returns(uint256);\r\n\tfunction _increaseTotalDivis(uint256 badgeID_, uint256 divis_) external;\r\n\tfunction getTotalDivis(uint256 badgeID_) public view returns(uint256);\r\n\tfunction _setBuyTime(uint256 badgeID_, uint32 timeStamp_) external;\r\n\tfunction getBuyTime(uint256 badgeID_) public view returns(uint32);\r\n\tfunction getCreationTime(uint256 badgeID_) public view returns(uint32);\r\n\tfunction getChainLength() public view returns(uint256);\r\n}\r\n\r\ncontract TeamAmberInterface{\r\n    function distribute() public payable;\r\n}\r\n\r\ncontract Amber{\r\n\tusing SafeMathExt for uint256;\r\n    /*===============================================================================\r\n    =                      DATA SET                     DATA SET                    =\r\n    ===============================================================================*/\r\n    /*==============================\r\n    =          INTERFACES          =\r\n    ==============================*/\r\n    BadgeFactoryInterface internal _badgeFactory;\r\n    TeamAmberInterface internal _teamAmber;\r\n\r\n    /*==============================\r\n    =          CONSTANTS           =\r\n    ==============================*/\r\n    uint256 internal constant FINNEY = 10**15;\r\n    uint256 internal constant _sharePreviousOwnerRatio = 50;\r\n    uint256 internal constant _shareReferalRatio = 5;\r\n    uint256 internal constant _shareDistributionRatio = 45;\r\n\r\n    /*==============================\r\n    =          VARIABLES           =\r\n    ==============================*/\r\n    address internal _contractOwner;\r\n    address internal _admin;\r\n    uint256 internal _badgeBasePrice;\r\n    uint256 internal _startTime;\r\n\r\n    /*==============================\r\n    =        USER MAPPINGS         =\r\n    ==============================*/\r\n    mapping(address => uint256) private _balanceDivis;\r\n    mapping(address => address) private _referer;\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onContractStart(uint256 startTime_);\r\n    event onRefererSet(address indexed user_, address indexed referer_);\r\n    event onBadgeBuy(uint256 indexed badgeID_, address indexed previousOwner_, address indexed buyer_, uint256 price_, uint256 newPrice_);\r\n    event onWithdraw(address indexed receiver_, uint256 amount_);\r\n\r\n    /*==============================\r\n    =          MODIFIERS           =\r\n    ==============================*/\r\n    modifier onlyContractOwner(){\r\n    \trequire(msg.sender == _contractOwner, 'Sender is not the contract owner.');\r\n    \t_;\r\n    }\r\n    modifier isNotAContract(){\r\n        require (msg.sender == tx.origin, 'Contracts are not allowed to interact.');\r\n        _;\r\n    }\r\n    modifier isRunning(){\r\n    \trequire(_startTime != 0 && _startTime <= now, 'The contract is not running yet.');\r\n    \t_;\r\n    }\r\n\r\n    /*===============================================================================\r\n    =                       FUNCTIONS                       FUNCTIONS               =\r\n    ===============================================================================*/\r\n    /*==============================\r\n    =           OWNER ONLY         =\r\n    ==============================*/\r\n    constructor(address admin_, address teamAmberAddress_) public{\r\n    \t_contractOwner = msg.sender;\r\n        _admin = admin_;\r\n        _teamAmber = TeamAmberInterface(teamAmberAddress_);\r\n    }\r\n\r\n    function initGame(address badgesFactoryAddress_, uint256 badgeBasePrice_, uint256 badgeStartMultiplier_, uint256 badgeStartQuantity_) external onlyContractOwner{\r\n        require(_badgeBasePrice == 0);\r\n\r\n        _badgeBasePrice = badgeBasePrice_;\r\n        _badgeFactory = BadgeFactoryInterface(badgesFactoryAddress_);\r\n        _badgeFactory._initBadges(_admin, badgeBasePrice_, badgeStartMultiplier_, badgeStartQuantity_);\r\n    }\r\n\r\n    function _startContract(uint256 delay_) external onlyContractOwner{\r\n    \trequire(_startTime == 0);\r\n        _startTime = now + delay_;\r\n\r\n        emit onContractStart(_startTime);\r\n    }\r\n\r\n    /*==============================\r\n    =             BUY              =\r\n    ==============================*/\r\n    //Hex Data: 0x7deb6025\r\n    function buy(uint256 badgeID_, address newReferer_) public payable isNotAContract isRunning{\r\n    \t_refererUpdate(msg.sender, newReferer_);\r\n    \t_buy(badgeID_, msg.sender, msg.value);\r\n    }\r\n\r\n    function _buy(uint256 badgeID_, address msgSender_, uint256 msgValue_) internal{\r\n        address previousOwner = _badgeFactory.getOwner(badgeID_);\r\n        require(PureAmber.isNotSelf(msgSender_, _badgeFactory.getOwner(badgeID_)), 'You can not buy from yourself.');\r\n        require(PureAmber.isValidBuy(_badgeFactory.getPrice(badgeID_), msgValue_), 'It is not a valid buy.');        \r\n\r\n        _diviSplit(badgeID_, previousOwner, msgSender_, msgValue_);\r\n        _extendBadges(badgeID_, msgSender_, _badgeBasePrice);\r\n        _badgeOwnerChange(badgeID_, msgSender_);\r\n        _badgeFactory._increasePrice(badgeID_);\r\n\r\n        emit onBadgeBuy (badgeID_, previousOwner, msgSender_, msgValue_, _badgeFactory.getPrice(badgeID_));\r\n    }\r\n\r\n    function _refererUpdate(address user_, address newReferer_) internal{\r\n    \tif (PureAmber.refererAllowed(user_, _referer[user_], newReferer_)){\r\n    \t\t_referer[user_] = newReferer_;\r\n    \t\temit onRefererSet(user_, newReferer_);\r\n    \t}\r\n    }\r\n\r\n    /*==============================\r\n    =         BADGE SYSTEM         =\r\n    ==============================*/\r\n    function _extendBadges(uint256 badgeID_, address owner_, uint256 price_) internal{\r\n        if (PureAmber.isLastBadgeEle(badgeID_, _badgeFactory.getChainLength())){\r\n            _badgeFactory._createNewBadge(owner_, price_);\r\n        }\r\n    }\r\n\r\n    function _badgeOwnerChange(uint256 badgeID_, address newOwner_) internal{      \r\n        _badgeFactory._setOwner(badgeID_, newOwner_);\r\n        _badgeFactory._setBuyTime(badgeID_, uint32(now));\r\n    }\r\n\r\n    /*==============================\r\n    =          DIVI SPLIT          =\r\n    ==============================*/\r\n    function _diviSplit(uint256 badgeID_, address previousOwner_, address msgSender_, uint256 msgValue_) internal{\r\n    \t_shareToPreviousOwner(previousOwner_, msgValue_, _sharePreviousOwnerRatio);\r\n    \t_shareToReferer(_referer[msgSender_], msgValue_, _shareReferalRatio);\r\n    \t_shareToDistribution(badgeID_, previousOwner_, msgValue_, _shareDistributionRatio);\r\n    }\r\n\r\n    function _shareToPreviousOwner(address previousOwner_, uint256 msgValue_, uint256 ratio_) internal{\r\n    \t_increasePlayerDivis(previousOwner_, PureAmber.calcShare(msgValue_, ratio_));\r\n    }\r\n\r\n    function _shareToReferer(address referer_, uint256 msgValue_, uint256 ratio_) internal{\r\n    \tif (PureAmber.addressNotSet(referer_)){\r\n    \t\t_increasePlayerDivis(_admin, PureAmber.calcShare(msgValue_, ratio_));\r\n    \t} else {\r\n    \t\t_increasePlayerDivis(referer_, PureAmber.calcShare(msgValue_, ratio_));\r\n    \t}\r\n    }\r\n\r\n    function _shareToDistribution(uint256 badgeID_, address previousOwner_, uint256 msgValue_, uint256 ratio_) internal{\r\n    \tuint256 share = PureAmber.calcShare(msgValue_, ratio_);\r\n\r\n    \tif (PureAmber.isFirstBadgeEle(badgeID_)){\r\n    \t\t_specialDistribution(previousOwner_, share);\r\n    \t} else {\r\n    \t\t_normalDistribution(badgeID_, PureAmber.calcDiviDistribution(share, badgeID_));\r\n    \t}\r\n    }\r\n\r\n    function _normalDistribution(uint256 badgeID_, uint256 divis_) internal{\r\n    \tfor(uint256 i = 0; i<badgeID_; i++){\r\n            _badgeFactory._increaseTotalDivis(i, divis_);\r\n            _increasePlayerDivis(_badgeFactory.getOwner(i), divis_);\r\n        }\r\n    }\r\n\r\n    function _specialDistribution(address previousOwner_, uint256 divis_) internal{\r\n        _badgeFactory._increaseTotalDivis(0, divis_);\r\n        _increasePlayerDivis(previousOwner_, divis_);\r\n    }\r\n\r\n    function _increasePlayerDivis(address user_, uint256 amount_) internal{\r\n        _balanceDivis[user_] = SafeMathExt.add(_balanceDivis[user_], amount_);\r\n    }\r\n\r\n    /*==============================\r\n    =           WITHDRAW           =\r\n    ==============================*/\r\n    //Hex Data: 0x0ed86f04\r\n    function withdrawDivis() public isNotAContract{\r\n    \t_withdrawDivis(msg.sender);\r\n    }\r\n\r\n    function _withdrawDivis(address msgSender_) internal{\r\n    \trequire (_balanceDivis[msgSender_] >= 0, 'Hack attempt: Sender does not have enough Divis to withdraw.');\r\n    \tuint256 payout = _balanceDivis[msgSender_];\r\n        _resetBalanceDivis(msgSender_);\r\n        _transferDivis(msgSender_, payout);\r\n\r\n        emit onWithdraw (msgSender_, payout);\r\n    }\r\n\r\n    function _transferDivis(address msgSender_, uint256 payout_) internal{\r\n    \tassert(address(this).balance >= payout_);\r\n    \tif(msgSender_ == _admin){\r\n    \t\t_teamAmber.distribute.value(payout_)();\r\n    \t} else {\r\n    \t\tmsgSender_.transfer(payout_); \t\t\r\n    \t}\r\n    }\r\n\r\n    function _resetBalanceDivis(address user_) internal{\r\n    \t_balanceDivis[user_] = 0;\r\n    }\r\n\r\n    /*==============================\r\n    =            HELPERS           =\r\n    ==============================*/\r\n    function getStartTime() public view returns (uint256){\r\n        return _startTime;\r\n    }\r\n\r\n    function getBalanceDivis(address user_) public view returns(uint256){\r\n    \treturn _balanceDivis[user_];\r\n    }\r\n\r\n    function getReferer(address user_) public view returns(address){\r\n    \treturn _referer[user_];\r\n    }\r\n\r\n    function getBalanceContract() public view returns(uint256){\r\n    \treturn address(this).balance;\r\n    }\r\n\r\n    function getBadges() public view returns(address[], uint256[], uint256[], uint32[], uint32[]){\r\n    \tuint256 length = _badgeFactory.getChainLength();\r\n    \taddress[] memory owner = new address[](length);\r\n    \tuint256[] memory price = new uint256[](length);\r\n    \tuint256[] memory totalDivis = new uint256[](length);\r\n    \tuint32[] memory buyTime = new uint32[](length);\r\n        uint32[] memory creationTime = new uint32[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n           owner[i] = _badgeFactory.getOwner(i);\r\n           price[i] = _badgeFactory.getPrice(i);\r\n           totalDivis[i] = _badgeFactory.getTotalDivis(i);\r\n           buyTime[i] = _badgeFactory.getBuyTime(i);\r\n           creationTime[i] = _badgeFactory.getCreationTime(i);\r\n       }\r\n       return (owner, price, totalDivis, buyTime, creationTime);\r\n   }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDivis\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getBalanceDivis\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBadges\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint32[]\"},{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getReferer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"badgesFactoryAddress_\",\"type\":\"address\"},{\"name\":\"badgeBasePrice_\",\"type\":\"uint256\"},{\"name\":\"badgeStartMultiplier_\",\"type\":\"uint256\"},{\"name\":\"badgeStartQuantity_\",\"type\":\"uint256\"}],\"name\":\"initGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"badgeID_\",\"type\":\"uint256\"},{\"name\":\"newReferer_\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delay_\",\"type\":\"uint256\"}],\"name\":\"_startContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"},{\"name\":\"teamAmberAddress_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime_\",\"type\":\"uint256\"}],\"name\":\"onContractStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user_\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referer_\",\"type\":\"address\"}],\"name\":\"onRefererSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"badgeID_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"previousOwner_\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice_\",\"type\":\"uint256\"}],\"name\":\"onBadgeBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"}]","ContractName":"Amber","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ae5ac19f938f8338920e630cc9a8ecd6ce89bca10000000000000000000000001ce75bfd524489e7dd8678d4905cbd8f47f22083","Library":"PureAmber:b0d6cdE34E2C79021891230Dc6457eEBFcaFFE74","SwarmSource":"bzzr://e966811642418f241f22e010340931e41701c41d694ca7e3830ef2a2ac9ba502"}]}