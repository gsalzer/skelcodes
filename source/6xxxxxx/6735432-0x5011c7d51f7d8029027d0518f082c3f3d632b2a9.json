{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract HexBoard3 {\r\n\r\n  // To ease iteration\r\n  uint8 constant public minTileId= 1;\r\n  uint8 constant public maxTileId = 19;\r\n  uint8 constant public numTiles = 19;\r\n\r\n  // Any 0s in the neighbor array represent non-neighbors. There might be a better way to do this, but w/e\r\n  mapping(uint8 => uint8[6]) public tileToNeighbors;\r\n  uint8 constant public nullNeighborValue = 0;\r\n\r\n  // TODO: Add neighbor calculation in if we want to use neighbors in jackpot calculation\r\n  constructor() public {\r\n  }\r\n}\r\n\r\ncontract JackpotRules {\r\n  using SafeMath for uint256;\r\n\r\n  constructor() public {}\r\n\r\n  // NOTE: The next methods *must* add up to 100%\r\n\r\n  // 50%\r\n  function _winnerJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return jackpot.div(2);\r\n  }\r\n\r\n  // 40%\r\n  function _landholderJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return (jackpot.mul(2)).div(5);\r\n  }\r\n\r\n  // 5%\r\n  function _nextPotJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return jackpot.div(20);\r\n  }\r\n\r\n  // 5%\r\n  function _teamJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return jackpot.div(20);\r\n  }\r\n}\r\n\r\nlibrary Math {\r\n  /**\r\n  * @dev Returns the largest of two numbers.\r\n  */\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the smallest of two numbers.\r\n  */\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /**\r\n  * @dev Calculates the average of two numbers. Since these are integers,\r\n  * averages of an even and odd number cannot be represented, and will be\r\n  * rounded down.\r\n  */\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PullPayment {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public payments;\r\n    uint256 public totalPayments;\r\n\r\n    /**\r\n     * @dev Withdraw accumulated balance, called by payee.\r\n     */\r\n    function withdrawPayments() public {\r\n        address payee = msg.sender;\r\n        uint256 payment = payments[payee];\r\n\r\n        require(payment != 0);\r\n        require(address(this).balance >= payment);\r\n\r\n        totalPayments = totalPayments.sub(payment);\r\n        payments[payee] = 0;\r\n\r\n        payee.transfer(payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n     * @param dest The destination address of the funds.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function asyncSend(address dest, uint256 amount) internal {\r\n        payments[dest] = payments[dest].add(amount);\r\n        totalPayments = totalPayments.add(amount);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract TaxRules {\r\n    using SafeMath for uint256;\r\n\r\n    constructor() public {}\r\n\r\n    // 10%\r\n    function _priceToTax(uint256 price) public pure returns (uint256) {\r\n        return price.div(10);\r\n    }\r\n\r\n    // NOTE: The next methods *must* add up to 100%\r\n\r\n    // 40%\r\n    function _jackpotTax(uint256 tax) public pure returns (uint256) {\r\n        return (tax.mul(2)).div(5);\r\n    }\r\n\r\n    // 38%\r\n    function _totalLandholderTax(uint256 tax) public pure returns (uint256) {\r\n        return (tax.mul(19)).div(50);\r\n    }\r\n\r\n    // 17%/12%\r\n    function _teamTax(uint256 tax, bool hasReferrer) public pure returns (uint256) {\r\n        if (hasReferrer) {\r\n            return (tax.mul(3)).div(25);\r\n        } else {\r\n            return (tax.mul(17)).div(100);\r\n        }\r\n    }\r\n\r\n    // 5% although only invoked if _teamTax is lower value\r\n    function _referrerTax(uint256 tax, bool hasReferrer)  public pure returns (uint256) {\r\n        if (hasReferrer) {\r\n            return tax.div(20);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // 5%\r\n    function _nextPotTax(uint256 tax) public pure returns (uint256) {\r\n        return tax.div(20);\r\n    }\r\n}\r\n\r\ncontract Microverse is\r\n    HexBoard3,\r\n    PullPayment,\r\n    Ownable,\r\n    TaxRules,\r\n    JackpotRules {\r\n    using SafeMath for uint256;\r\n    using Math for uint256;\r\n\r\n    // states this contract progresses through\r\n    enum Stage {\r\n        DutchAuction,\r\n        GameRounds\r\n    }\r\n    Stage public stage = Stage.DutchAuction;\r\n\r\n    modifier atStage(Stage _stage) {\r\n        require(\r\n            stage == _stage,\r\n            \"Function cannot be called at this time.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // NOTE: stage arg for debugging purposes only! Should just be set to 0 by default\r\n    constructor(uint startingStage) public {\r\n        if (startingStage == uint(Stage.GameRounds)) {\r\n            stage = Stage.GameRounds;\r\n            _startGameRound();\r\n        } else {\r\n            _startAuction();\r\n        }\r\n    }\r\n\r\n    mapping(uint8 => address) public tileToOwner;\r\n    mapping(uint8 => uint256) public tileToPrice;\r\n    uint256 public totalTileValue;\r\n\r\n    function _changeTilePrice(uint8 tileId, uint256 newPrice) private {\r\n        uint256 oldPrice = tileToPrice[tileId];\r\n        tileToPrice[tileId] = newPrice;\r\n        totalTileValue = (totalTileValue.sub(oldPrice)).add(newPrice);\r\n    }\r\n\r\n    event TileOwnerChanged(\r\n        uint8 indexed tileId,\r\n        address indexed oldOwner,\r\n        address indexed newOwner,\r\n        uint256 oldPrice,\r\n        uint256 newPrice\r\n    );\r\n\r\n    /////////////\r\n    // Team stuff\r\n    /////////////\r\n\r\n    // The muscle behind microverse\r\n    address public teamAddress1 = 0xcB46219bA114245c3A18761E4f7891f9C4BeF8c0;\r\n    address public teamAddress2 = 0xF2AFb5c2D205B36F22BE528A1300393B1C399E79;\r\n    address public teamAddress3 = 0x22FC59B3878F0Aa2e43F7f3388c1e20D83Cf8ba2;\r\n\r\n    function _sendToTeam(uint256 amount) private {\r\n        uint256 perTeamMemberFee = amount.div(3);\r\n\r\n        asyncSend(teamAddress1, perTeamMemberFee);\r\n        asyncSend(teamAddress2, perTeamMemberFee);\r\n        asyncSend(teamAddress3, perTeamMemberFee);\r\n    }\r\n\r\n    //////////\r\n    // Auction\r\n    //////////\r\n\r\n    event AuctionStarted(\r\n        uint256 startingAuctionPrice,\r\n        uint256 endingAuctionPrice,\r\n        uint256 auctionDuration,\r\n        uint256 startTime\r\n    );\r\n\r\n    event AuctionEnded(\r\n        uint256 endTime\r\n    );\r\n\r\n    uint256 constant public startingAuctionPrice = 1 ether;\r\n    uint256 constant public endingAuctionPrice = 0.05 ether;\r\n    uint256 constant public auctionDuration = 5 days; // period over which land price decreases linearly\r\n\r\n    uint256 public numBoughtTiles;\r\n    uint256 public auctionStartTime;\r\n\r\n    function buyTileAuction(uint8 tileId, uint256 newPrice, address referrer) public payable atStage(Stage.DutchAuction) {\r\n        require(\r\n            tileToOwner[tileId] == address(0) && tileToPrice[tileId] == 0,\r\n            \"Can't buy a tile that's already been auctioned off\"\r\n        );\r\n\r\n        uint256 tax = _priceToTax(newPrice);\r\n        uint256 price = getTilePriceAuction();\r\n\r\n        require(\r\n            msg.value >= tax.add(price),\r\n            \"Must pay the full price and tax for a tile on auction\"\r\n        );\r\n\r\n        // NOTE: *entire* payment distributed as Game taxes\r\n        _distributeAuctionTax(msg.value, referrer);\r\n\r\n        tileToOwner[tileId] = msg.sender;\r\n        _changeTilePrice(tileId, newPrice);\r\n\r\n        numBoughtTiles = numBoughtTiles.add(1);\r\n\r\n        emit TileOwnerChanged(tileId, address(0), msg.sender, price, newPrice);\r\n\r\n        if (numBoughtTiles >= numTiles) {\r\n            endAuction();\r\n        }\r\n    }\r\n\r\n    // NOTE: Some common logic with _distributeTax\r\n    function _distributeAuctionTax(uint256 tax, address referrer) private {\r\n        _distributeLandholderTax(_totalLandholderTax(tax));\r\n\r\n        // NOTE: Because no notion of 'current jackpot', everything added to next pot\r\n        uint256 totalJackpotTax = _jackpotTax(tax).add(_nextPotTax(tax));\r\n        nextJackpot = nextJackpot.add(totalJackpotTax);\r\n\r\n        // NOTE: referrer tax comes out of dev team tax\r\n        bool hasReferrer = referrer != address(0);\r\n        _sendToTeam(_teamTax(tax, hasReferrer));\r\n        asyncSend(referrer, _referrerTax(tax, hasReferrer));\r\n    }\r\n\r\n    function getTilePriceAuction() public view atStage(Stage.DutchAuction) returns (uint256) {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // This should always be the case...\r\n        if (now > auctionStartTime) {\r\n            secondsPassed = now.sub(auctionStartTime);\r\n        }\r\n\r\n        if (secondsPassed >= auctionDuration) {\r\n            return endingAuctionPrice;\r\n        } else {\r\n            uint256 maxPriceDelta = startingAuctionPrice.sub(endingAuctionPrice);\r\n            uint256 actualPriceDelta = (maxPriceDelta.mul(secondsPassed)).div(auctionDuration);\r\n\r\n            return startingAuctionPrice.sub(actualPriceDelta);\r\n        }\r\n    }\r\n\r\n    function endAuction() private {\r\n        require(\r\n            numBoughtTiles >= numTiles,\r\n            \"Can't end auction if are unbought tiles\"\r\n        );\r\n\r\n        stage = Stage.GameRounds;\r\n        _startGameRound();\r\n\r\n        emit AuctionEnded(now);\r\n    }\r\n\r\n    function _startAuction() private {\r\n        auctionStartTime = now;\r\n        numBoughtTiles = 0;\r\n\r\n        emit AuctionStarted(startingAuctionPrice,\r\n                            endingAuctionPrice,\r\n                            auctionDuration,\r\n                            auctionStartTime);\r\n    }\r\n\r\n    ///////\r\n    // Game\r\n    ///////\r\n\r\n    uint256 constant public startingRoundExtension = 12 hours;\r\n    uint256 constant public halvingVolume = 10 ether; // tx volume before next duration halving\r\n    uint256 constant public minRoundExtension = 10 seconds; // could set to 1 second\r\n\r\n    uint256 public roundNumber = 0;\r\n\r\n    uint256 public curExtensionVolume;\r\n    uint256 public curRoundExtension;\r\n\r\n    uint256 public roundEndTime;\r\n\r\n    uint256 public jackpot;\r\n    uint256 public nextJackpot;\r\n\r\n    // Only emitted if owner doesn't *also* change\r\n    event TilePriceChanged(\r\n        uint8 indexed tileId,\r\n        address indexed owner,\r\n        uint256 oldPrice,\r\n        uint256 newPrice\r\n    );\r\n\r\n    event GameRoundStarted(\r\n        uint256 initJackpot,\r\n        uint256 endTime,\r\n        uint256 roundNumber\r\n    );\r\n\r\n    event GameRoundExtended(\r\n        uint256 endTime\r\n    );\r\n\r\n    event GameRoundEnded(\r\n        uint256 jackpot\r\n    );\r\n\r\n    ////////////////////////////////////\r\n    // [Game] Round extension management\r\n    ////////////////////////////////////\r\n\r\n    function roundTimeRemaining() public view atStage(Stage.GameRounds) returns (uint256)  {\r\n        if (_roundOver()) {\r\n            return 0;\r\n        } else {\r\n            return roundEndTime.sub(now);\r\n        }\r\n    }\r\n\r\n    function _extendRound() private {\r\n        roundEndTime = roundEndTime.max(now.add(curRoundExtension));\r\n\r\n        emit GameRoundExtended(roundEndTime);\r\n    }\r\n\r\n    function _startGameRound() private {\r\n        curExtensionVolume = 0 ether;\r\n        curRoundExtension = startingRoundExtension;\r\n\r\n        jackpot = nextJackpot;\r\n        nextJackpot = 0;\r\n\r\n        roundNumber = roundNumber.add(1);\r\n\r\n        _extendRound();\r\n\r\n        emit GameRoundStarted(jackpot, roundEndTime, roundNumber);\r\n    }\r\n\r\n    function _roundOver() private view returns (bool) {\r\n        return now >= roundEndTime;\r\n    }\r\n\r\n    modifier duringRound() {\r\n        require(\r\n            !_roundOver(),\r\n            \"Round can't be over!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // NOTE: Must be called for all volume we want to count towards round extension halving\r\n    function _logRoundExtensionVolume(uint256 amount) private {\r\n        curExtensionVolume = curExtensionVolume.add(amount);\r\n\r\n        if (curExtensionVolume >= halvingVolume) {\r\n            curRoundExtension = curRoundExtension.div(2).max(minRoundExtension);\r\n            curExtensionVolume = 0 ether;\r\n        }\r\n    }\r\n\r\n    ////////////////////////\r\n    // [Game] Player actions\r\n    ////////////////////////\r\n\r\n    function endGameRound() public atStage(Stage.GameRounds) {\r\n        require(\r\n            _roundOver(),\r\n            \"Round must be over!\"\r\n        );\r\n\r\n        _distributeJackpot();\r\n\r\n        emit GameRoundEnded(jackpot);\r\n\r\n        _startGameRound();\r\n    }\r\n\r\n    function setTilePrice(uint8 tileId, uint256 newPrice, address referrer)\r\n        public\r\n        payable\r\n        atStage(Stage.GameRounds)\r\n        duringRound {\r\n        require(\r\n            tileToOwner[tileId] == msg.sender,\r\n            \"Can't set tile price for a tile you don't own!\"\r\n        );\r\n\r\n        uint256 tax = _priceToTax(newPrice);\r\n\r\n        require(\r\n            msg.value >= tax,\r\n            \"Must pay tax on new tile price!\"\r\n        );\r\n\r\n        uint256 oldPrice = tileToPrice[tileId];\r\n        _distributeTax(msg.value, referrer);\r\n        _changeTilePrice(tileId, newPrice);\r\n\r\n        // NOTE: Currently we extend round for 'every' tile price change. Alternatively could do only on\r\n        // increases or decreases or changes exceeding some magnitude\r\n        _extendRound();\r\n        _logRoundExtensionVolume(msg.value);\r\n\r\n        emit TilePriceChanged(tileId, tileToOwner[tileId], oldPrice, newPrice);\r\n    }\r\n\r\n    function buyTile(uint8 tileId, uint256 newPrice, address referrer)\r\n        public\r\n        payable\r\n        atStage(Stage.GameRounds)\r\n        duringRound {\r\n        address oldOwner = tileToOwner[tileId];\r\n        require(\r\n            oldOwner != msg.sender,\r\n            \"Can't buy a tile you already own\"\r\n        );\r\n\r\n        uint256 tax = _priceToTax(newPrice);\r\n\r\n        uint256 oldPrice = tileToPrice[tileId];\r\n        require(\r\n            msg.value >= tax.add(oldPrice),\r\n            \"Must pay full price and tax for tile\"\r\n        );\r\n\r\n        // pay seller\r\n        asyncSend(oldOwner, tileToPrice[tileId]);\r\n        tileToOwner[tileId] = msg.sender;\r\n\r\n        uint256 actualTax = msg.value.sub(oldPrice);\r\n        _distributeTax(actualTax, referrer);\r\n\r\n        _changeTilePrice(tileId, newPrice);\r\n        _extendRound();\r\n        _logRoundExtensionVolume(msg.value);\r\n\r\n        emit TileOwnerChanged(tileId, oldOwner, msg.sender, oldPrice, newPrice);\r\n    }\r\n\r\n    ///////////////////////////////////////\r\n    // [Game] Dividend/jackpot distribution\r\n    ///////////////////////////////////////\r\n\r\n    function _distributeJackpot() private {\r\n        uint256 winnerJackpot = _winnerJackpot(jackpot);\r\n        uint256 landholderJackpot = _landholderJackpot(jackpot);\r\n        _distributeWinnerAndLandholderJackpot(winnerJackpot, landholderJackpot);\r\n\r\n        _sendToTeam(_teamJackpot(jackpot));\r\n        nextJackpot = nextJackpot.add(_nextPotJackpot(jackpot));\r\n    }\r\n\r\n    function _calculatePriceComplement(uint8 tileId) private view returns (uint256) {\r\n        return totalTileValue.sub(tileToPrice[tileId]);\r\n    }\r\n\r\n    // NOTE: These are bundled together so that we only have to compute complements once\r\n    function _distributeWinnerAndLandholderJackpot(uint256 winnerJackpot, uint256 landholderJackpot) private {\r\n        uint256[] memory complements = new uint256[](numTiles + 1); // inc necessary b/c tiles are 1-indexed\r\n        uint256 totalPriceComplement = 0;\r\n\r\n        uint256 bestComplement = 0;\r\n        uint8 lastWinningTileId = 0;\r\n        for (uint8 i = minTileId; i <= maxTileId; i++) {\r\n            uint256 priceComplement = _calculatePriceComplement(i);\r\n\r\n            // update winner\r\n            if (bestComplement == 0 || priceComplement > bestComplement) {\r\n                bestComplement = priceComplement;\r\n                lastWinningTileId = i;\r\n            }\r\n\r\n            complements[i] = priceComplement;\r\n            totalPriceComplement = totalPriceComplement.add(priceComplement);\r\n        }\r\n        uint256 numWinners = 0;\r\n        for (i = minTileId; i <= maxTileId; i++) {\r\n            if (_calculatePriceComplement(i) == bestComplement) {\r\n                numWinners++;\r\n            }\r\n        }\r\n\r\n        // distribute jackpot among all winners. save time on the majority (1-winner) case\r\n        if (numWinners == 1) {\r\n            asyncSend(tileToOwner[lastWinningTileId], winnerJackpot);\r\n        } else {\r\n            for (i = minTileId; i <= maxTileId; i++) {\r\n                if (_calculatePriceComplement(i) == bestComplement) {\r\n                    asyncSend(tileToOwner[i], winnerJackpot.div(numWinners));\r\n                }\r\n            }\r\n        }\r\n\r\n        // distribute landholder things\r\n        for (i = minTileId; i <= maxTileId; i++) {\r\n            // NOTE: We don't exclude the jackpot winner(s) here, so the winner(s) is paid 'twice'\r\n            uint256 landholderAllocation = complements[i].mul(landholderJackpot).div(totalPriceComplement);\r\n\r\n            asyncSend(tileToOwner[i], landholderAllocation);\r\n        }\r\n    }\r\n\r\n    function _distributeTax(uint256 tax, address referrer) private {\r\n        jackpot = jackpot.add(_jackpotTax(tax));\r\n\r\n        _distributeLandholderTax(_totalLandholderTax(tax));\r\n        nextJackpot = nextJackpot.add(_nextPotTax(tax));\r\n\r\n        // NOTE: referrer tax comes out of dev team tax\r\n        bool hasReferrer = referrer != address(0);\r\n        _sendToTeam(_teamTax(tax, hasReferrer));\r\n        asyncSend(referrer, _referrerTax(tax, hasReferrer));\r\n    }\r\n\r\n    function _distributeLandholderTax(uint256 tax) private {\r\n        for (uint8 tile = minTileId; tile <= maxTileId; tile++) {\r\n            if (tileToOwner[tile] != address(0) && tileToPrice[tile] != 0) {\r\n                uint256 tilePrice = tileToPrice[tile];\r\n                uint256 allocation = tax.mul(tilePrice).div(totalTileValue);\r\n\r\n                asyncSend(tileToOwner[tile], allocation);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_winnerJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"_jackpotTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endGameRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingRoundExtension\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTileId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTileValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTilePriceAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_nextPotJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingAuctionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"},{\"name\":\"hasReferrer\",\"type\":\"bool\"}],\"name\":\"_teamTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tileId\",\"type\":\"uint8\"},{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"setTilePrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endingAuctionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halvingVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tileToPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_landholderJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tileToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tileId\",\"type\":\"uint8\"},{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyTileAuction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"_totalLandholderTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBoughtTiles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tileId\",\"type\":\"uint8\"},{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyTile\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"_nextPotTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curExtensionVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tileToNeighbors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"_priceToTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"},{\"name\":\"hasReferrer\",\"type\":\"bool\"}],\"name\":\"_referrerTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nullNeighborValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundTimeRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curRoundExtension\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTileId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_teamJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minRoundExtension\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTiles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"startingStage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tileId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"TileOwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startingAuctionPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingAuctionPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tileId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"TilePriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"initJackpot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"name\":\"GameRoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"GameRoundExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"GameRoundEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Microverse","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://68a4fe1c2201a93f7e716cd2ac72ebcfce66209a198b7158565b57ddb4febae3"}]}