{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ninterface IFlyDropTokenMgr {\r\n    // Send tokens to other multi addresses in one function\r\n    function prepare(uint256 _rand,\r\n                     address _from,\r\n                     address _token,\r\n                     uint256 _value) external returns (bool);\r\n\r\n    // Send tokens to other multi addresses in one function\r\n    function flyDrop(address[] _destAddrs, uint256[] _values) external returns (uint256);\r\n\r\n    // getter to determine if address has poweruser role\r\n    function isPoweruser(address _addr) external view returns (bool);\r\n}\r\n\r\ninterface ILockedStorage {\r\n    // get frozen status for the _wallet address\r\n    function frozenAccounts(address _wallet) external view returns (bool);\r\n\r\n    // get a wallet address by the account address and the index\r\n    function isExisted(address _wallet) external view returns (bool);\r\n\r\n    // get a wallet name by the account address and the index\r\n    function walletName(address _wallet) external view returns (string);\r\n\r\n    // get the frozen amount of the account address\r\n    function frozenAmount(address _wallet) external view returns (uint256);\r\n\r\n    // get the balance of the account address\r\n    function balanceOf(address _wallet) external view returns (uint256);\r\n\r\n    // get the account address by index\r\n    function addressByIndex(uint256 _ind) external view returns (address);\r\n\r\n    // get the number of the locked stage of the target address\r\n    function lockedStagesNum(address _target) external view returns (uint256);\r\n\r\n    // get the endtime of the locked stages of an account\r\n    function endTimeOfStage(address _target, uint _ind) external view returns (uint256);\r\n\r\n    // get the remain unrleased tokens of the locked stages of an account\r\n    function remainOfStage(address _target, uint _ind) external view returns (uint256);\r\n\r\n    // get the remain unrleased tokens of the locked stages of an account\r\n    function amountOfStage(address _target, uint _ind) external view returns (uint256);\r\n\r\n    // get the remain releasing period end time of an account\r\n    function releaseEndTimeOfStage(address _target, uint _ind) external view returns (uint256);\r\n\r\n    // get the frozen amount of the account address\r\n    function size() external view returns (uint256);\r\n\r\n    // add one account address for that wallet\r\n    function addAccount(address _wallet, string _name, uint256 _value) external returns (bool);\r\n\r\n    // add a time record of one account\r\n    function addLockedTime(address _target,\r\n                           uint256 _value,\r\n                           uint256 _frozenEndTime,\r\n                           uint256 _releasePeriod) external returns (bool);\r\n\r\n    // freeze or release the tokens that has been locked in the account address.\r\n    function freezeTokens(address _wallet, bool _freeze, uint256 _value) external returns (bool);\r\n\r\n    // increase balance of this account address\r\n    function increaseBalance(address _wallet, uint256 _value) external returns (bool);\r\n\r\n    // decrease balance of this account address\r\n    function decreaseBalance(address _wallet, uint256 _value) external returns (bool);\r\n\r\n    // remove account contract address from storage\r\n    function removeAccount(address _wallet) external returns (bool);\r\n\r\n    // remove a time records from the time records list of one account\r\n    function removeLockedTime(address _target, uint _ind) external returns (bool);\r\n\r\n    // set the new endtime of the released time of an account\r\n    function changeEndTime(address _target, uint256 _ind, uint256 _newEndTime) external returns (bool);\r\n\r\n    // set the new released period end time of an account\r\n    function setNewReleaseEndTime(address _target, uint256 _ind, uint256 _newReleaseEndTime) external returns (bool);\r\n\r\n    // decrease the remaining locked amount of an account\r\n    function decreaseRemainLockedOf(address _target, uint256 _ind, uint256 _value) external returns (bool);\r\n\r\n    // withdraw tokens from this contract\r\n    function withdrawToken(address _token, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\ncontract DelayedClaimable is Claimable {\r\n\r\n  uint256 public end;\r\n  uint256 public start;\r\n\r\n  /**\r\n   * @dev Used to specify the time period during which a pending\r\n   * owner can claim ownership.\r\n   * @param _start The earliest time ownership can be claimed.\r\n   * @param _end The latest time ownership can be claimed.\r\n   */\r\n  function setLimits(uint256 _start, uint256 _end) public onlyOwner {\r\n    require(_start <= _end);\r\n    end = _end;\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\r\n   * the specified start and end time.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    require((block.number <= end) && (block.number >= start));\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n    end = 0;\r\n  }\r\n\r\n}\r\n\r\ncontract OwnerContract is DelayedClaimable {\r\n    Claimable public ownedContract;\r\n    address public pendingOwnedOwner;\r\n    // address internal origOwner;\r\n\r\n    /**\r\n     * @dev bind a contract as its owner\r\n     *\r\n     * @param _contract the contract address that will be binded by this Owner Contract\r\n     */\r\n    function bindContract(address _contract) onlyOwner public returns (bool) {\r\n        require(_contract != address(0));\r\n        ownedContract = Claimable(_contract);\r\n        // origOwner = ownedContract.owner();\r\n\r\n        // take ownership of the owned contract\r\n        if (ownedContract.owner() != address(this)) {\r\n            ownedContract.claimOwnership();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change the owner of the contract from this contract address to the original one.\r\n     *\r\n     */\r\n    // function transferOwnershipBack() onlyOwner public {\r\n    //     ownedContract.transferOwnership(origOwner);\r\n    //     ownedContract = Claimable(address(0));\r\n    //     origOwner = address(0);\r\n    // }\r\n\r\n    /**\r\n     * @dev change the owner of the contract from this contract address to another one.\r\n     *\r\n     * @param _nextOwner the contract address that will be next Owner of the original Contract\r\n     */\r\n    function changeOwnershipto(address _nextOwner)  onlyOwner public {\r\n        require(ownedContract != address(0));\r\n\r\n        if (ownedContract.owner() != pendingOwnedOwner) {\r\n            ownedContract.transferOwnership(_nextOwner);\r\n            pendingOwnedOwner = _nextOwner;\r\n            // ownedContract = Claimable(address(0));\r\n            // origOwner = address(0);\r\n        } else {\r\n            // the pending owner has already taken the ownership\r\n            ownedContract = Claimable(address(0));\r\n            pendingOwnedOwner = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to confirm the owner of the owned contract has already been transferred.\r\n     *\r\n     */\r\n    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\r\n        require(ownedContract != address(0));\r\n        if (ownedContract.owner() == pendingOwnedOwner) {\r\n            // the pending owner has already taken the ownership\r\n            ownedContract = Claimable(address(0));\r\n            pendingOwnedOwner = address(0);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract ReleaseAndLockToken is OwnerContract {\r\n    using SafeMath for uint256;\r\n\r\n    ILockedStorage lockedStorage;\r\n    IFlyDropTokenMgr flyDropMgr;\r\n    // ERC20 public erc20tk;\r\n    mapping (address => uint256) preReleaseAmounts;\r\n\r\n    event ReleaseFunds(address indexed _target, uint256 _amount);\r\n\r\n    /**\r\n     * @dev bind a contract as its owner\r\n     *\r\n     * @param _contract the LockedStorage contract address that will be binded by this Owner Contract\r\n     * @param _flyDropContract the flydrop contract for transfer tokens from the fixed main accounts\r\n     */\r\n    function initialize(address _contract, address _flyDropContract) onlyOwner public returns (bool) {\r\n        require(_contract != address(0));\r\n        require(_flyDropContract != address(0));\r\n\r\n        require(super.bindContract(_contract));\r\n        lockedStorage = ILockedStorage(_contract);\r\n        flyDropMgr = IFlyDropTokenMgr(_flyDropContract);\r\n        // erc20tk = ERC20(_tk);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * judge whether we need to release some of the locked token\r\n     *\r\n     */\r\n    function needRelease() public view returns (bool) {\r\n        uint256 len = lockedStorage.size();\r\n        uint256 i = 0;\r\n        while (i < len) {\r\n            address frozenAddr = lockedStorage.addressByIndex(i);\r\n            uint256 timeRecLen = lockedStorage.lockedStagesNum(frozenAddr);\r\n            uint256 j = 0;\r\n            while (j < timeRecLen) {\r\n                if (now >= lockedStorage.endTimeOfStage(frozenAddr, j)) {\r\n                    return true;\r\n                }\r\n\r\n                j = j.add(1);\r\n            }\r\n\r\n            i = i.add(1);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev judge whether we need to release the locked token of the target address\r\n     * @param _target the owner of the amount of tokens\r\n     *\r\n     */\r\n    function needReleaseFor(address _target) public view returns (bool) {\r\n        require(_target != address(0));\r\n\r\n        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\r\n        uint256 j = 0;\r\n        while (j < timeRecLen) {\r\n            if (now >= lockedStorage.endTimeOfStage(_target, j)) {\r\n                return true;\r\n            }\r\n\r\n            j = j.add(1);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev freeze the amount of tokens of an account\r\n     *\r\n     * @param _target the owner of some amount of tokens\r\n     * @param _name the user name of the _target\r\n     * @param _value the amount of the tokens\r\n     * @param _frozenEndTime the end time of the lock period, unit is second\r\n     * @param _releasePeriod the locking period, unit is second\r\n     */\r\n    function freeze(address _target, string _name, uint256 _value, uint256 _frozenEndTime, uint256 _releasePeriod) onlyOwner public returns (bool) {\r\n        //require(_tokenAddr != address(0));\r\n        require(_target != address(0));\r\n        require(_value > 0);\r\n        require(_frozenEndTime > 0);\r\n\r\n        if (!lockedStorage.isExisted(_target)) {\r\n            lockedStorage.addAccount(_target, _name, _value); // add new account\r\n        }\r\n\r\n        // each time the new locked time will be added to the backend\r\n        require(lockedStorage.addLockedTime(_target, _value, _frozenEndTime, _releasePeriod));\r\n        require(lockedStorage.freezeTokens(_target, true, _value));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer an amount of tokens to an account, and then freeze the tokens\r\n     *\r\n     * @param _target the account address that will hold an amount of the tokens\r\n     * @param _name the user name of the _target\r\n     * @param _from the tokens holder who will transfer the tokens to target address\r\n     * @param _tk the erc20 token need to be transferred\r\n     * @param _value the amount of the tokens which has been transferred\r\n     * @param _frozenEndTime the end time of the lock period, unit is second\r\n     * @param _releasePeriod the locking period, unit is second\r\n     */\r\n    function transferAndFreeze(address _target,\r\n                               string _name,\r\n                               address _from,\r\n                               address _tk,\r\n                               uint256 _value,\r\n                               uint256 _frozenEndTime,\r\n                               uint256 _releasePeriod) onlyOwner public returns (bool) {\r\n        require(_from != address(0));\r\n        require(_target != address(0));\r\n        require(_value > 0);\r\n        require(_frozenEndTime > 0);\r\n\r\n        // check firstly that the allowance of this contract has been set\r\n        // require(owned.allowance(msg.sender, this) > 0);\r\n        uint rand = now % 6 + 7; // random number between 7 to 12\r\n        require(flyDropMgr.prepare(rand, _from, _tk, _value));\r\n\r\n        // now we need transfer the funds before freeze them\r\n        // require(owned.transferFrom(msg.sender, lockedStorage, _value));\r\n        address[] memory dests = new address[](1);\r\n        dests[0] = address(lockedStorage);\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = _value;\r\n        require(flyDropMgr.flyDrop(dests, amounts) >= 1);\r\n        if (!lockedStorage.isExisted(_target)) {\r\n            require(lockedStorage.addAccount(_target, _name, _value));\r\n        } else {\r\n            require(lockedStorage.increaseBalance(_target, _value));\r\n        }\r\n\r\n        // freeze the account after transfering funds\r\n        require(freeze(_target, _name, _value, _frozenEndTime, _releasePeriod));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer an amount of tokens to an account, and then freeze the tokens\r\n     *\r\n     * @param _target the account address that will hold an amount of the tokens\r\n     * @param _tk the erc20 token need to be transferred\r\n     * @param _value the amount of the tokens which has been transferred\r\n     */\r\n    function releaseTokens(address _target, address _tk, uint256 _value) internal {\r\n        require(lockedStorage.withdrawToken(_tk, _target, _value));\r\n        require(lockedStorage.freezeTokens(_target, false, _value));\r\n        require(lockedStorage.decreaseBalance(_target, _value));\r\n    }\r\n\r\n    /**\r\n     * @dev release the token which are locked for once and will be total released at once\r\n     * after the end point of the lock period\r\n     * @param _tk the erc20 token need to be transferred\r\n     */\r\n    function releaseAllOnceLock(address _tk) onlyOwner public returns (bool) {\r\n        require(_tk != address(0));\r\n\r\n        uint256 len = lockedStorage.size();\r\n        uint256 i = 0;\r\n        while (i < len) {\r\n            address target = lockedStorage.addressByIndex(i);\r\n            if (lockedStorage.lockedStagesNum(target) == 1\r\n                && lockedStorage.endTimeOfStage(target, 0) == lockedStorage.releaseEndTimeOfStage(target, 0)\r\n                && lockedStorage.endTimeOfStage(target, 0) > 0\r\n                && now >= lockedStorage.endTimeOfStage(target, 0)) {\r\n                uint256 releasedAmount = lockedStorage.amountOfStage(target, 0);\r\n\r\n                // remove current release period time record\r\n                if (!lockedStorage.removeLockedTime(target, 0)) {\r\n                    return false;\r\n                }\r\n\r\n                // remove the froze account\r\n                if (!lockedStorage.removeAccount(target)) {\r\n                    return false;\r\n                }\r\n\r\n                releaseTokens(target, _tk, releasedAmount);\r\n                emit ReleaseFunds(target, releasedAmount);\r\n                len = len.sub(1);\r\n            } else {\r\n                // no account has been removed\r\n                i = i.add(1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev release the locked tokens owned by an account, which only have only one locked time\r\n     * and don't have release stage.\r\n     *\r\n     * @param _target the account address that hold an amount of locked tokens\r\n     * @param _tk the erc20 token need to be transferred\r\n     */\r\n    function releaseAccount(address _target, address _tk) onlyOwner public returns (bool) {\r\n        require(_tk != address(0));\r\n\r\n        if (!lockedStorage.isExisted(_target)) {\r\n            return false;\r\n        }\r\n\r\n        if (lockedStorage.lockedStagesNum(_target) == 1\r\n            && lockedStorage.endTimeOfStage(_target, 0) == lockedStorage.releaseEndTimeOfStage(_target, 0)\r\n            && lockedStorage.endTimeOfStage(_target, 0) > 0\r\n            && now >= lockedStorage.endTimeOfStage(_target, 0)) {\r\n            uint256 releasedAmount = lockedStorage.amountOfStage(_target, 0);\r\n\r\n            // remove current release period time record\r\n            if (!lockedStorage.removeLockedTime(_target, 0)) {\r\n                return false;\r\n            }\r\n\r\n            // remove the froze account\r\n            if (!lockedStorage.removeAccount(_target)) {\r\n                return false;\r\n            }\r\n\r\n            releaseTokens(_target, _tk, releasedAmount);\r\n            emit ReleaseFunds(_target, releasedAmount);\r\n        }\r\n\r\n        // if the account are not locked for once, we will do nothing here\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev release the locked tokens owned by an account with several stages\r\n     * this need the contract get approval from the account by call approve() in the token contract\r\n     *\r\n     * @param _target the account address that hold an amount of locked tokens\r\n     * @param _tk the erc20 token need to be transferred\r\n     */\r\n    function releaseWithStage(address _target, address _tk) onlyOwner public returns (bool) {\r\n        require(_tk != address(0));\r\n\r\n        address frozenAddr = _target;\r\n        if (!lockedStorage.isExisted(frozenAddr)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 timeRecLen = lockedStorage.lockedStagesNum(frozenAddr);\r\n        bool released = false;\r\n        uint256 nowTime = now;\r\n        for (uint256 j = 0; j < timeRecLen; released = false) {\r\n            // iterate every time records to caculate how many tokens need to be released.\r\n            uint256 endTime = lockedStorage.endTimeOfStage(frozenAddr, j);\r\n            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(frozenAddr, j);\r\n            uint256 amount = lockedStorage.amountOfStage(frozenAddr, j);\r\n            uint256 remain = lockedStorage.remainOfStage(frozenAddr, j);\r\n            if (nowTime > endTime && endTime > 0 && releasedEndTime > endTime) {\r\n                uint256 lastReleased = amount.sub(remain);\r\n                uint256 value = (amount * nowTime.sub(endTime) / releasedEndTime.sub(endTime)).sub(lastReleased);\r\n\r\n                if (value > remain) {\r\n                    value = remain;\r\n                }\r\n                lockedStorage.decreaseRemainLockedOf(frozenAddr, j, value);\r\n                emit ReleaseFunds(_target, value);\r\n\r\n                preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(value);\r\n                if (lockedStorage.remainOfStage(frozenAddr, j) < 1e8) {\r\n                    if (!lockedStorage.removeLockedTime(frozenAddr, j)) {\r\n                        return false;\r\n                    }\r\n                    released = true;\r\n                    timeRecLen = timeRecLen.sub(1);\r\n                }\r\n            } else if (nowTime >= endTime && endTime > 0 && releasedEndTime == endTime) {\r\n                lockedStorage.decreaseRemainLockedOf(frozenAddr, j, remain);\r\n                emit ReleaseFunds(frozenAddr, amount);\r\n                preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(amount);\r\n                if (!lockedStorage.removeLockedTime(frozenAddr, j)) {\r\n                    return false;\r\n                }\r\n                released = true;\r\n                timeRecLen = timeRecLen.sub(1);\r\n            }\r\n\r\n            if (!released) {\r\n                j = j.add(1);\r\n            }\r\n        }\r\n\r\n        // we got some amount need to be released\r\n        if (preReleaseAmounts[frozenAddr] > 0) {\r\n            releaseTokens(frozenAddr, _tk, preReleaseAmounts[frozenAddr]);\r\n\r\n            // set the pre-release amount to 0 for next time\r\n            preReleaseAmounts[frozenAddr] = 0;\r\n        }\r\n\r\n        // if all the frozen amounts had been released, then unlock the account finally\r\n        if (lockedStorage.lockedStagesNum(frozenAddr) == 0) {\r\n            if (!lockedStorage.removeAccount(frozenAddr)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev set the new endtime of the released time of an account\r\n     *\r\n     * @param _target the owner of some amount of tokens\r\n     * @param _oldEndTime the original endtime for the lock period, unit is second\r\n     * @param _oldDuration the original duration time for the released period, unit is second\r\n     * @param _newEndTime the new endtime for the lock period\r\n     */\r\n    function setNewEndtime(address _target, uint256 _oldEndTime, uint256 _oldDuration, uint256 _newEndTime) onlyOwner public returns (bool) {\r\n        require(_target != address(0));\r\n        require(_oldEndTime > 0 && _newEndTime > 0);\r\n\r\n        if (!lockedStorage.isExisted(_target)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\r\n        uint256 j = 0;\r\n        while (j < timeRecLen) {\r\n            uint256 endTime = lockedStorage.endTimeOfStage(_target, j);\r\n            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(_target, j);\r\n            uint256 duration = releasedEndTime.sub(endTime);\r\n            if (_oldEndTime == endTime && _oldDuration == duration) {\r\n                bool res = lockedStorage.changeEndTime(_target, j, _newEndTime);\r\n                res = lockedStorage.setNewReleaseEndTime(_target, j, _newEndTime.add(duration)) && res;\r\n                return res;\r\n            }\r\n\r\n            j = j.add(1);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev set the new released period length of an account\r\n     *\r\n     * @param _target the owner of some amount of tokens\r\n     * @param _origEndTime the original endtime for the lock period\r\n     * @param _origDuration the original duration time for the released period, unit is second\r\n     * @param _newDuration the new releasing period\r\n     */\r\n    function setNewReleasePeriod(address _target, uint256 _origEndTime, uint256 _origDuration, uint256 _newDuration) onlyOwner public returns (bool) {\r\n        require(_target != address(0));\r\n        require(_origEndTime > 0);\r\n\r\n        if (!lockedStorage.isExisted(_target)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\r\n        uint256 j = 0;\r\n        while (j < timeRecLen) {\r\n            uint256 endTime = lockedStorage.endTimeOfStage(_target, j);\r\n            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(_target, j);\r\n            if (_origEndTime == endTime && _origDuration == releasedEndTime.sub(endTime)) {\r\n                return lockedStorage.setNewReleaseEndTime(_target, j, _origEndTime.add(_newDuration));\r\n            }\r\n\r\n            j = j.add(1);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev get the locked stages of an account\r\n     *\r\n     * @param _target the owner of some amount of tokens\r\n     */\r\n    function getLockedStages(address _target) public view returns (uint) {\r\n        require(_target != address(0));\r\n\r\n        return lockedStorage.lockedStagesNum(_target);\r\n    }\r\n\r\n    /**\r\n     * @dev get the endtime of the locked stages of an account\r\n     *\r\n     * @param _target the owner of some amount of tokens\r\n     * @param _num the stage number of the releasing period\r\n     */\r\n    function getEndTimeOfStage(address _target, uint _num) public view returns (uint256) {\r\n        require(_target != address(0));\r\n\r\n        return lockedStorage.endTimeOfStage(_target, _num);\r\n    }\r\n\r\n    /**\r\n     * @dev get the remain unrleased tokens of the locked stages of an account\r\n     *\r\n     * @param _target the owner of some amount of tokens\r\n     * @param _num the stage number of the releasing period\r\n     */\r\n    function getRemainOfStage(address _target, uint _num) public view returns (uint256) {\r\n        require(_target != address(0));\r\n\r\n        return lockedStorage.remainOfStage(_target, _num);\r\n    }\r\n\r\n    /**\r\n     * @dev get total remain locked tokens of an account\r\n     *\r\n     * @param _account the owner of some amount of tokens\r\n     */\r\n    function getRemainLockedOf(address _account) public view returns (uint256) {\r\n        require(_account != address(0));\r\n\r\n        uint256 totalRemain = 0;\r\n        if(lockedStorage.isExisted(_account)) {\r\n            uint256 timeRecLen = lockedStorage.lockedStagesNum(_account);\r\n            uint256 j = 0;\r\n            while (j < timeRecLen) {\r\n                totalRemain = totalRemain.add(lockedStorage.remainOfStage(_account, j));\r\n                j = j.add(1);\r\n            }\r\n        }\r\n\r\n        return totalRemain;\r\n    }\r\n\r\n    /**\r\n     * @dev get the remain releasing period of an account\r\n     *\r\n     * @param _target the owner of some amount of tokens\r\n     * @param _num the stage number of the releasing period\r\n     */\r\n    function getRemainReleaseTimeOfStage(address _target, uint _num) public view returns (uint256) {\r\n        require(_target != address(0));\r\n\r\n        uint256 nowTime = now;\r\n        uint256 releaseEndTime = lockedStorage.releaseEndTimeOfStage(_target, _num);\r\n\r\n        if (releaseEndTime == 0 || releaseEndTime < nowTime) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 endTime = lockedStorage.endTimeOfStage(_target, _num);\r\n        if (releaseEndTime == endTime || nowTime <= endTime ) {\r\n            return (releaseEndTime.sub(endTime));\r\n        }\r\n\r\n        return (releaseEndTime.sub(nowTime));\r\n    }\r\n\r\n    /**\r\n     * @dev release the locked tokens owned by a number of accounts\r\n     *\r\n     * @param _targets the accounts list that hold an amount of locked tokens\r\n     * @param _tk the erc20 token need to be transferred\r\n     */\r\n    function releaseMultiAccounts(address[] _targets, address _tk) onlyOwner public returns (bool) {\r\n        require(_targets.length != 0);\r\n\r\n        bool res = false;\r\n        uint256 i = 0;\r\n        while (i < _targets.length) {\r\n            res = releaseAccount(_targets[i], _tk) || res;\r\n            i = i.add(1);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev release the locked tokens owned by an account\r\n     *\r\n     * @param _targets the account addresses list that hold amounts of locked tokens\r\n     * @param _tk the erc20 token need to be transferred\r\n     */\r\n    function releaseMultiWithStage(address[] _targets, address _tk) onlyOwner public returns (bool) {\r\n        require(_targets.length != 0);\r\n\r\n        bool res = false;\r\n        uint256 i = 0;\r\n        while (i < _targets.length) {\r\n            res = releaseWithStage(_targets[i], _tk) || res; // as long as there is one true transaction, then the result will be true\r\n            i = i.add(1);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev convert bytes32 stream to string\r\n     *\r\n     * @param _b32 the bytes32 that hold a string in content\r\n     */\r\n    function bytes32ToString(bytes32 _b32) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(_b32) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n     /**\r\n     * @dev freeze multiple of the accounts\r\n     *\r\n     * @param _targets the owners of some amount of tokens\r\n     * @param _names the user names of the _targets\r\n     * @param _values the amounts of the tokens\r\n     * @param _frozenEndTimes the list of the end time of the lock period, unit is second\r\n     * @param _releasePeriods the list of the locking period, unit is second\r\n     */\r\n    function freezeMulti(address[] _targets, bytes32[] _names, uint256[] _values, uint256[] _frozenEndTimes, uint256[] _releasePeriods) onlyOwner public returns (bool) {\r\n        require(_targets.length != 0);\r\n        require(_names.length != 0);\r\n        require(_values.length != 0);\r\n        require(_frozenEndTimes.length != 0);\r\n        require(_releasePeriods.length != 0);\r\n        require(_targets.length == _names.length && _names.length == _values.length && _values.length == _frozenEndTimes.length && _frozenEndTimes.length == _releasePeriods.length);\r\n\r\n        bool res = true;\r\n        for (uint256 i = 0; i < _targets.length; i = i.add(1)) {\r\n            // as long as one transaction failed, then the result will be failure\r\n            res = freeze(_targets[i], bytes32ToString(_names[i]), _values[i], _frozenEndTimes[i], _releasePeriods[i]) && res;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer a list of amounts of tokens to a list of accounts, and then freeze the tokens\r\n     *\r\n     * @param _targets the account addresses that will hold a list of amounts of the tokens\r\n     * @param _names the user names of the _targets\r\n     * @param _from the tokens holder who will transfer the tokens to target address\r\n     * @param _tk the erc20 token need to be transferred\r\n     * @param _values the amounts of the tokens which have been transferred\r\n     * @param _frozenEndTimes the end time list of the locked periods, unit is second\r\n     * @param _releasePeriods the list of locking periods, unit is second\r\n     */\r\n    function transferAndFreezeMulti(address[] _targets, bytes32[] _names, address _from, address _tk, uint256[] _values, uint256[] _frozenEndTimes, uint256[] _releasePeriods) onlyOwner public returns (bool) {\r\n        require(_targets.length != 0);\r\n        require(_names.length != 0);\r\n        require(_values.length != 0);\r\n        require(_frozenEndTimes.length != 0);\r\n        require(_releasePeriods.length != 0);\r\n        require(_targets.length == _names.length && _names.length == _values.length && _values.length == _frozenEndTimes.length && _frozenEndTimes.length == _releasePeriods.length);\r\n\r\n        bool res = true;\r\n        for (uint256 i = 0; i < _targets.length; i = i.add(1)) {\r\n            // as long as one transaction failed, then the result will be failure\r\n            res = transferAndFreeze(_targets[i], bytes32ToString(_names[i]), _from, _tk, _values[i], _frozenEndTimes[i], _releasePeriods[i]) && res;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_tk\",\"type\":\"address\"}],\"name\":\"releaseAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_origEndTime\",\"type\":\"uint256\"},{\"name\":\"_origDuration\",\"type\":\"uint256\"},{\"name\":\"_newDuration\",\"type\":\"uint256\"}],\"name\":\"setNewReleasePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"getRemainReleaseTimeOfStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_tk\",\"type\":\"address\"}],\"name\":\"releaseWithStage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_tk\",\"type\":\"address\"}],\"name\":\"releaseMultiWithStage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tk\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_frozenEndTime\",\"type\":\"uint256\"},{\"name\":\"_releasePeriod\",\"type\":\"uint256\"}],\"name\":\"transferAndFreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_flyDropContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwnedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tk\",\"type\":\"address\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_frozenEndTimes\",\"type\":\"uint256[]\"},{\"name\":\"_releasePeriods\",\"type\":\"uint256[]\"}],\"name\":\"transferAndFreezeMulti\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_frozenEndTime\",\"type\":\"uint256\"},{\"name\":\"_releasePeriod\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"bindContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"getRemainOfStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"needReleaseFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_frozenEndTimes\",\"type\":\"uint256[]\"},{\"name\":\"_releasePeriods\",\"type\":\"uint256[]\"}],\"name\":\"freezeMulti\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownedContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getRemainLockedOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownedOwnershipTransferred\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_tk\",\"type\":\"address\"}],\"name\":\"releaseMultiAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"getEndTimeOfStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"getLockedStages\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"changeOwnershipto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_oldEndTime\",\"type\":\"uint256\"},{\"name\":\"_oldDuration\",\"type\":\"uint256\"},{\"name\":\"_newEndTime\",\"type\":\"uint256\"}],\"name\":\"setNewEndtime\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tk\",\"type\":\"address\"}],\"name\":\"releaseAllOnceLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ReleaseFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ReleaseAndLockToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ecc8d44502f407227e349abc5419cf0a46fe7a29665ef32082b531a900cd6d1b"}]}