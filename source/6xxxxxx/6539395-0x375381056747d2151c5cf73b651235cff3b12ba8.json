{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n  address private _owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function initialize(address sender) public initializer {\r\n    _owner = sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(_owner);\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n\r\ncontract PauserRole is Initializable {\r\n  using Roles for Roles.Role;\r\n\r\n  event PauserAdded(address indexed account);\r\n  event PauserRemoved(address indexed account);\r\n\r\n  Roles.Role private pausers;\r\n\r\n  function initialize(address sender) public initializer {\r\n    if (!isPauser(sender)) {\r\n      _addPauser(sender);\r\n    }\r\n  }\r\n\r\n  modifier onlyPauser() {\r\n    require(isPauser(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isPauser(address account) public view returns (bool) {\r\n    return pausers.has(account);\r\n  }\r\n\r\n  function addPauser(address account) public onlyPauser {\r\n    _addPauser(account);\r\n  }\r\n\r\n  function renouncePauser() public {\r\n    _removePauser(msg.sender);\r\n  }\r\n\r\n  function _addPauser(address account) internal {\r\n    pausers.add(account);\r\n    emit PauserAdded(account);\r\n  }\r\n\r\n  function _removePauser(address account) internal {\r\n    pausers.remove(account);\r\n    emit PauserRemoved(account);\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Initializable, PauserRole {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  function initialize(address sender) public initializer {\r\n    PauserRole.initialize(sender);\r\n  }\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns(bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyPauser whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyPauser whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Attribute Registry interface. EIP-165 ID: 0x5f46473f\r\n */\r\ninterface AttributeRegistryInterface {\r\n  /**\r\n   * @notice Check if an attribute of the type with ID `attributeTypeID` has\r\n   * been assigned to the account at `account` and is still valid.\r\n   * @param account address The account to check for a valid attribute.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return True if the attribute is assigned and valid, false otherwise.\r\n   */\r\n  function hasAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Retrieve the value of the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account`, assuming it is valid.\r\n   * @param account address The account to check for the given attribute value.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return The attribute value if the attribute is valid, reverts otherwise.\r\n   */\r\n  function getAttributeValue(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the registry.\r\n   * @return The number of available attribute types.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic TPL Jurisdiction Interface.\r\n */\r\ninterface BasicJurisdictionInterface {\r\n  // declare events\r\n  event AttributeTypeAdded(uint256 indexed attributeTypeID, string description);\r\n  \r\n  event AttributeTypeRemoved(uint256 indexed attributeTypeID);\r\n  \r\n  event ValidatorAdded(address indexed validator, string description);\r\n  \r\n  event ValidatorRemoved(address indexed validator);\r\n  \r\n  event ValidatorApprovalAdded(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event ValidatorApprovalRemoved(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event AttributeAdded(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID,\r\n    uint256 attributeValue\r\n  );\r\n\r\n  event AttributeRemoved(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID\r\n  );\r\n\r\n  /**\r\n  * @notice Add an attribute type with ID `ID` and description `description` to\r\n  * the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to add.\r\n  * @param description string A description of the attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description of the\r\n  * attribute type cannot be changed, even if the attribute type is removed and\r\n  * added back later.\r\n  */\r\n  function addAttributeType(uint256 ID, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to remove.\r\n  * @dev All issued attributes of the given type will become invalid upon\r\n  * removal, but will become valid again if the attribute is reinstated.\r\n  */\r\n  function removeAttributeType(uint256 ID) external;\r\n\r\n  /**\r\n  * @notice Add account `validator` as a validator with a description\r\n  * `description` who can be approved to set attributes of specific types.\r\n  * @param validator address The account to assign as the validator.\r\n  * @param description string A description of the validator.\r\n  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\r\n  */\r\n  function addValidator(address validator, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the validator at address `validator` from the jurisdiction.\r\n  * @param validator address The account of the validator to remove.\r\n  * @dev Any attributes issued by the validator will become invalid upon their\r\n  * removal. If the validator is reinstated, those attributes will become valid\r\n  * again. Any approvals to issue attributes of a given type will need to be\r\n  * set from scratch in the event a validator is reinstated.\r\n  */\r\n  function removeValidator(address validator) external;\r\n\r\n  /**\r\n  * @notice Approve the validator at address `validator` to issue attributes of\r\n  * the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator to approve.\r\n  * @param attributeTypeID uint256 The ID of the approved attribute type.\r\n  */\r\n  function addValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Deny the validator at address `validator` the ability to continue to\r\n  * issue attributes of the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator with removed approval.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\r\n  * @dev Any attributes of the specified type issued by the validator in\r\n  * question will become invalid once the approval is removed. If the approval\r\n  * is reinstated, those attributes will become valid again. The approval will\r\n  * also be removed if the approved validator is removed.\r\n  */\r\n  function removeValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\r\n  * of `value` to `account` if `message.caller.address()` is approved validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @param value uint256 An optional value for the issued attribute.\r\n  * @dev Existing attributes of the given type on the address must be removed\r\n  * in order to set a new attribute. Be aware that ownership of the account to\r\n  * which the attribute is assigned may still be transferable - restricting\r\n  * assignment to externally-owned accounts may partially alleviate this issue.\r\n  */\r\n  function issueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value\r\n  ) external payable;\r\n\r\n  /**\r\n  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\r\n  * `account` if `message.caller.address()` is the issuing validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @dev Validators may still revoke issued attributes even after they have been\r\n  * removed or had their approval to issue the attribute type removed - this\r\n  * enables them to address any objectionable issuances before being reinstated.\r\n  */\r\n  function revokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Determine if a validator at account `validator` is able to issue\r\n   * attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canIssueAttributeType(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Get a description of the attribute type with ID `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return A description of the attribute type.\r\n   */\r\n  function getAttributeTypeInformation(\r\n    uint256 attributeTypeID\r\n  ) external view returns (string description);\r\n  \r\n  /**\r\n   * @notice Get a description of the validator at account `validator`.\r\n   * @param validator address The account of the validator in question.\r\n   * @return A description of the validator.\r\n   */\r\n  function getValidatorInformation(\r\n    address validator\r\n  ) external view returns (string description);\r\n\r\n  /**\r\n   * @notice Find the validator that issued the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account` and determine if the\r\n   * validator is still valid.\r\n   * @param account address The account that contains the attribute be checked.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return The validator and the current status of the validator as it\r\n   * pertains to the attribute type in question.\r\n   * @dev if no attribute of the given attribute type exists on the account, the\r\n   * function will return (address(0), false).\r\n   */\r\n  function getAttributeValidator(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (address validator, bool isStillValid);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the jurisdiction.\r\n   * @return The number of available attribute types.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the IDs of all available attribute types on the jurisdiction.\r\n   * @return A dynamic array containing all available attribute type IDs.\r\n   */\r\n  function getAttributeTypeIDs() external view returns (uint256[]);\r\n\r\n  /**\r\n   * @notice Count the number of validators defined by the jurisdiction.\r\n   * @return The number of defined validators.\r\n   */\r\n  function countValidators() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the account of the validator at index `index`.\r\n   * @param index uint256 The index of the validator in question.\r\n   * @return The account of the validator.\r\n   */\r\n  function getValidator(uint256 index) external view returns (address);\r\n\r\n  /**\r\n   * @notice Get the accounts of all available validators on the jurisdiction.\r\n   * @return A dynamic array containing all available validator accounts.\r\n   */\r\n  function getValidators() external view returns (address[]);\r\n}\r\n\r\n\r\n/**\r\n * @title Organizations validator contract .\r\n */\r\ncontract OrganizationsValidator is Initializable, Ownable, Pausable {\r\n  // declare events\r\n  event OrganizationAdded(address organization, string name);\r\n  \r\n  event AttributeIssued(\r\n    address indexed organization,\r\n    address attributee\r\n  );\r\n  \r\n  event AttributeRevoked(\r\n    address indexed organization,\r\n    address attributee\r\n  );\r\n  \r\n  event IssuancePaused();\r\n  \r\n  event IssuanceUnpaused();\r\n\r\n  // declare registry interface, used to request attributes from a jurisdiction\r\n  AttributeRegistryInterface private _registry;\r\n\r\n  // declare jurisdiction interface, used to set attributes in the jurisdiction\r\n  BasicJurisdictionInterface private _jurisdiction;\r\n\r\n  // declare the attribute ID required by the validator in order to transfer tokens\r\n  uint256 private _validAttributeTypeID;\r\n\r\n  // organizations are entities who can add attibutes to a number of accounts\r\n  struct Organization {\r\n    bool exists;\r\n    uint256 maximumAccounts; // NOTE: consider using uint248 to pack w/ exists\r\n    string name;\r\n    address[] accounts;\r\n    mapping(address => bool) issuedAccounts;\r\n    mapping(address => uint256) issuedAccountsIndex;\r\n  }\r\n\r\n  // organization data & issued attribute accounts are held in a struct mapping\r\n  mapping(address => Organization) private _organizations;\r\n\r\n  // accounts of all organizations are held in an array (enables enumeration)\r\n  address[] private _organizationAccounts;\r\n\r\n  // issuance of new attributes may be paused and unpaused by the validator.\r\n  bool private _issuancePaused;\r\n\r\n  /**\r\n  * @notice Add an organization at account `organization` and with an initial\r\n  * allocation of issuable attributes of `maximumIssuableAttributes`.\r\n  * @param organization address The account to assign to the organization.  \r\n  * @param maximumIssuableAttributes uint256 The number of issuable accounts.\r\n  */\r\n  function addOrganization(\r\n    address organization,\r\n    uint256 maximumIssuableAttributes,\r\n    string name\r\n  ) external onlyOwner whenNotPaused {\r\n    // check that an empty account was not provided by mistake\r\n    require(organization != address(0), \"must supply a valid account address\");\r\n\r\n    // prevent existing organizations from being overwritten\r\n    require(\r\n      _organizations[organization].exists == false,\r\n      \"an organization already exists at the provided account address\"\r\n    );\r\n\r\n    // set up the organization in the organizations mapping\r\n    _organizations[organization].exists = true;\r\n    _organizations[organization].maximumAccounts = maximumIssuableAttributes;\r\n    _organizations[organization].name = name;\r\n    \r\n    // add the organization to the end of the organizationAccounts array\r\n    _organizationAccounts.push(organization);\r\n\r\n    // log the addition of the organization\r\n    emit OrganizationAdded(organization, name);\r\n  }\r\n\r\n  /**\r\n  * @notice Modify an organization at account `organization` to change the\r\n  * number of issuable attributes to `maximumIssuableAttributes`.\r\n  * @param organization address The account assigned to the organization.  \r\n  * @param maximumIssuableAttributes uint256 The number of issuable attributes.\r\n  * @dev Note that the maximum number of accounts cannot currently be set to a\r\n  * value less than the current number of issued accounts. This feature, coupled\r\n  * with the ability to revoke attributes, will *prevent an organization from\r\n  * being 'frozen' since the organization can remove an address and then add an\r\n  * arbitrary address in its place. Options to address this include a dedicated\r\n  * method for freezing organizations, or a special exception to the requirement\r\n  * below that allows the maximum to be set to 0 which will achieve the intended\r\n  * effect.\r\n  */\r\n  function setMaximumIssuableAttributes(\r\n    address organization,\r\n    uint256 maximumIssuableAttributes\r\n  ) external onlyOwner whenNotPaused {\r\n    require(\r\n      _organizations[organization].exists == true,\r\n      \"an organization does not exist at the provided account address\"\r\n    );\r\n\r\n    // make sure that maximum is not set below the current number of addresses\r\n    require(\r\n      _organizations[organization].accounts.length <= maximumIssuableAttributes,\r\n      \"maximum cannot be set to amounts less than the current account total\"\r\n    );\r\n\r\n    // set the organization's maximum addresses; a value == current freezes them\r\n    _organizations[organization].maximumAccounts = maximumIssuableAttributes;\r\n  }\r\n\r\n  /**\r\n  * @notice Add an attribute to account `account`.\r\n  * @param account address The account to issue the attribute to.  \r\n  * @dev This function would need to be made payable to support jurisdictions\r\n  * that require fees in order to set attributes.\r\n  */\r\n  function issueAttribute(\r\n    address account\r\n  ) external whenNotPaused whenIssuanceNotPaused {\r\n    // check that an empty address was not provided by mistake\r\n    require(account != address(0), \"must supply a valid account address\");\r\n\r\n    // make sure the request is coming from a valid organization\r\n    require(\r\n      _organizations[msg.sender].exists == true,\r\n      \"only organizations may issue attributes\"\r\n    );\r\n\r\n    // ensure that the maximum has not been reached yet\r\n    uint256 maximum = uint256(_organizations[msg.sender].maximumAccounts);\r\n    require(\r\n      _organizations[msg.sender].accounts.length < maximum,\r\n      \"the organization is not permitted to issue any additional attributes\"\r\n    );\r\n \r\n    // assign the attribute to the jurisdiction (NOTE: a value is not required)\r\n    _jurisdiction.issueAttribute(account, _validAttributeTypeID, 0);\r\n\r\n    // ensure that the attribute was correctly assigned\r\n    require(\r\n      _registry.hasAttribute(account, _validAttributeTypeID) == true,\r\n      \"attribute addition was not accepted by the jurisdiction\"\r\n    );\r\n\r\n    // add the account to the mapping of issued accounts\r\n    _organizations[msg.sender].issuedAccounts[account] = true;\r\n\r\n    // add the index of the account to the mapping of issued accounts\r\n    uint256 index = _organizations[msg.sender].accounts.length;\r\n    _organizations[msg.sender].issuedAccountsIndex[account] = index;\r\n\r\n    // add the address to the end of the organization's `accounts` array\r\n    _organizations[msg.sender].accounts.push(account);\r\n    \r\n    // log the addition of the new attributed account\r\n    emit AttributeIssued(msg.sender, account);\r\n  }\r\n\r\n  /**\r\n  * @notice Revoke an attribute from account `account`.\r\n  * @param account address The account to revoke the attribute from.  \r\n  * @dev Organizations may still revoke attributes even after new issuance has\r\n  * been paused. This is the intended behavior, as it allows them to correct\r\n  * attributes they have issued that become compromised or otherwise erroneous.\r\n  */\r\n  function revokeAttribute(address account) external whenNotPaused {\r\n    // check that an empty address was not provided by mistake\r\n    require(account != address(0), \"must supply a valid account address\");\r\n\r\n    // make sure the request is coming from a valid organization\r\n    require(\r\n      _organizations[msg.sender].exists == true,\r\n      \"only organizations may revoke attributes\"\r\n    );\r\n\r\n    // ensure that the account has been issued an attribute\r\n    require(\r\n      _organizations[msg.sender].issuedAccounts[account] &&\r\n      _organizations[msg.sender].accounts.length > 0,\r\n      \"the organization is not permitted to revoke an unissued attribute\"\r\n    );\r\n \r\n    // remove the attribute from the jurisdiction\r\n    _jurisdiction.revokeAttribute(account, _validAttributeTypeID);\r\n\r\n    // ensure that the attribute was correctly removed\r\n    require(\r\n      _registry.hasAttribute(account, _validAttributeTypeID) == false,\r\n      \"attribute revocation was not accepted by the jurisdiction\"\r\n    );\r\n\r\n    // get the account at the last index of the array\r\n    uint256 lastIndex = _organizations[msg.sender].accounts.length - 1;\r\n    address lastAccount = _organizations[msg.sender].accounts[lastIndex];\r\n\r\n    // get the index to delete\r\n    uint256 indexToDelete = _organizations[msg.sender].issuedAccountsIndex[account];\r\n\r\n    // set the account at indexToDelete to last account\r\n    _organizations[msg.sender].accounts[indexToDelete] = lastAccount;\r\n\r\n    // update the index of the account that was moved\r\n    _organizations[msg.sender].issuedAccountsIndex[lastAccount] = indexToDelete;\r\n    \r\n    // remove the (now duplicate) account at the end by trimming the array\r\n    _organizations[msg.sender].accounts.length--;\r\n\r\n    // remove the account from the organization's issuedAccounts mapping as well\r\n    delete _organizations[msg.sender].issuedAccounts[account];\r\n    \r\n    // log the addition of the new attributed account\r\n    emit AttributeRevoked(msg.sender, account);\r\n  }\r\n\r\n  /**\r\n   * @notice Count the number of organizations defined by the validator.\r\n   * @return The number of defined organizations.\r\n   */\r\n  function countOrganizations() external view returns (uint256) {\r\n    return _organizationAccounts.length;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the account of the organization at index `index`.\r\n   * @param index uint256 The index of the organization in question.\r\n   * @return The account of the organization.\r\n   */\r\n  function getOrganization(uint256 index) external view returns (\r\n    address organization\r\n  ) {\r\n    return _organizationAccounts[index];\r\n  }\r\n\r\n  /**\r\n   * @notice Get the accounts of all available organizations.\r\n   * @return A dynamic array containing all defined organization accounts.\r\n   */\r\n  function getOrganizations() external view returns (address[] accounts) {\r\n    return _organizationAccounts;\r\n  }\r\n\r\n  /**\r\n   * @notice Get information about the organization at account `account`.\r\n   * @param organization address The account of the organization in question.\r\n   * @return The organization's existence, the maximum issuable accounts, the\r\n   * name of the organization, and a dynamic array containing issued accounts.\r\n   * @dev Note that an organization issuing numerous attributes may cause the\r\n   * function to fail, as the dynamic array could grow beyond a returnable size.\r\n   */\r\n  function getOrganizationInformation(\r\n    address organization\r\n  ) external view returns (\r\n    bool exists,\r\n    uint256 maximumAccounts,\r\n    string name,\r\n    address[] issuedAccounts\r\n  ) {\r\n    return (\r\n      _organizations[organization].exists,\r\n      _organizations[organization].maximumAccounts,\r\n      _organizations[organization].name,\r\n      _organizations[organization].accounts\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Get the account of the utilized jurisdiction.\r\n   * @return The account of the jurisdiction.\r\n   */\r\n  function getJurisdiction() external view returns (address) {\r\n    return address(_jurisdiction);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type that the validator can issue.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getValidAttributeTypeID() external view returns (uint256) {\r\n    return _validAttributeTypeID;\r\n  }\r\n\r\n  /**\r\n  * @notice The initializer function for the OrganizationsValidator,\r\n  * with owner and pauser roles initially assigned to contract creator,\r\n  * and with an associated jurisdiction at `jurisdiction` and an assignable\r\n  * attribute type with ID `validAttributeTypeID`.\r\n  * @param jurisdiction address The account of the associated jurisdiction.  \r\n  * @param validAttributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @param sender address The account to be set as pauser and owner of the contract.\r\n  * @dev Note that it may be appropriate to require that the referenced\r\n  * jurisdiction supports the correct interface via EIP-165 and that the\r\n  * validator has been approved to issue attributes of the specified type when\r\n  * initializing the contract - it is not currently required.\r\n  */\r\n  function initialize(\r\n    address jurisdiction,\r\n    uint256 validAttributeTypeID,\r\n    address sender\r\n  )\r\n    public\r\n    initializer\r\n  {\r\n    Ownable.initialize(sender);\r\n    Pausable.initialize(sender);\r\n    _issuancePaused = false;\r\n    _registry = AttributeRegistryInterface(jurisdiction);\r\n    _jurisdiction = BasicJurisdictionInterface(jurisdiction);\r\n    _validAttributeTypeID = validAttributeTypeID;\r\n  }\r\n\r\n  /**\r\n   * @notice Pause all issuance of new attributes by organizations.\r\n   */\r\n  function pauseIssuance() public onlyOwner whenNotPaused whenIssuanceNotPaused {\r\n    _issuancePaused = true;\r\n    emit IssuancePaused();\r\n  }\r\n\r\n  /**\r\n   * @notice Unpause issuance of new attributes by organizations.\r\n   */\r\n  function unpauseIssuance() public onlyOwner whenNotPaused {\r\n    require(_issuancePaused); // only allow unpausing when issuance is paused\r\n    _issuancePaused = false;\r\n    emit IssuanceUnpaused();\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if attribute issuance is currently paused.\r\n   * @return True if issuance is currently paused, false otherwise.\r\n   */\r\n  function issuanceIsPaused() public view returns (bool) {\r\n    return _issuancePaused;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier to allow issuing attributes only when not paused\r\n   */\r\n  modifier whenIssuanceNotPaused() {\r\n    require(!_issuancePaused);\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getJurisdiction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseIssuance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"organization\",\"type\":\"address\"},{\"name\":\"maximumIssuableAttributes\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"addOrganization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOrganizations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOrganization\",\"outputs\":[{\"name\":\"organization\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceIsPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"organization\",\"type\":\"address\"}],\"name\":\"getOrganizationInformation\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"maximumAccounts\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"issuedAccounts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrganizations\",\"outputs\":[{\"name\":\"accounts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidAttributeTypeID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"organization\",\"type\":\"address\"},{\"name\":\"maximumIssuableAttributes\",\"type\":\"uint256\"}],\"name\":\"setMaximumIssuableAttributes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"jurisdiction\",\"type\":\"address\"},{\"name\":\"validAttributeTypeID\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"issueAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseIssuance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"organization\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"OrganizationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"organization\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attributee\",\"type\":\"address\"}],\"name\":\"AttributeIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"organization\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attributee\",\"type\":\"address\"}],\"name\":\"AttributeRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"IssuancePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"IssuanceUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OrganizationsValidator","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f7fa5d050fec31b0b1da7dadea952c9211b1a0b4ec159c3e11c1003acc8adaaf"}]}