{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract Issuer {\r\n    \r\n    address internal issuer = 0x692202c797ca194be918114780db7796e9397c13;\r\n    \r\n    function changeIssuer(address _to) public {\r\n        \r\n        require(msg.sender == issuer); \r\n        \r\n        issuer = _to;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    \r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    \r\n}\r\n\r\nlibrary StringHelper {\r\n\r\n    function stringToUint(string s) pure internal returns (uint result) {\r\n        bytes memory b = bytes(s);\r\n        uint i;\r\n        result = 0;\r\n        for (i = 0; i < b.length; i++) {\r\n            uint c = uint(b[i]);\r\n            if (c >= 48 && c <= 57) {\r\n                result = result * 10 + (c - 48);\r\n            }\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    \r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    \r\n}\r\n\r\ncontract ERC20 is Issuer, ERC20Interface {\r\n\r\n    using SafeMath for uint;\r\n\r\n    bool public locked = true;\r\n    \r\n    string public constant name = \"Ethnamed\";\r\n    string public constant symbol = \"NAME\";\r\n    uint8 public constant decimals = 18;\r\n    uint internal tokenPrice;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    \r\n    struct Contributor {\r\n        mapping(address => uint) allowed;\r\n        uint balance;\r\n    }\r\n    \r\n    mapping(address => Contributor) contributors;\r\n    \r\n    function ERC20() public {\r\n        tokenPrice = 10**uint(decimals);\r\n        Contributor storage contributor = contributors[issuer];\r\n        contributor.balance = totalSupply();\r\n        emit Transfer(address(0), issuer, totalSupply());\r\n    }\r\n    \r\n    function unlock() public {\r\n        require(msg.sender == issuer);\r\n        locked = false;\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint) {\r\n        return 1000000 * tokenPrice;\r\n    }\r\n    \r\n    function balanceOf(address _tokenOwner) public view returns (uint) {\r\n        Contributor storage contributor = contributors[_tokenOwner];\r\n        return contributor.balance;\r\n    }\r\n    \r\n    function transfer(address _to, uint _tokens) public returns (bool) {\r\n        require(!locked || msg.sender == issuer);\r\n        Contributor storage sender = contributors[msg.sender];\r\n        Contributor storage recepient = contributors[_to];\r\n        sender.balance = sender.balance.sub(_tokens);\r\n        recepient.balance = recepient.balance.add(_tokens);\r\n        emit Transfer(msg.sender, _to, _tokens);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _tokenOwner, address _spender) public view returns (uint) {\r\n        Contributor storage owner = contributors[_tokenOwner];\r\n        return owner.allowed[_spender];\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _tokens) public returns (bool) {\r\n        \r\n        Contributor storage owner = contributors[_from];\r\n        \r\n        require(owner.allowed[msg.sender] >= _tokens);\r\n        \r\n        Contributor storage receiver = contributors[_to];\r\n        \r\n        owner.balance = owner.balance.sub(_tokens);\r\n        owner.allowed[msg.sender] = owner.allowed[msg.sender].sub(_tokens);\r\n        \r\n        receiver.balance = receiver.balance.add(_tokens);\r\n        \r\n        emit Transfer(_from, _to, _tokens);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint _tokens) public returns (bool) {\r\n        \r\n        require(!locked);\r\n        \r\n        Contributor storage owner = contributors[msg.sender];\r\n        owner.allowed[_spender] = _tokens;\r\n        \r\n        emit Approval(msg.sender, _spender, _tokens);\r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\ncontract DEXified is ERC20 {\r\n\r\n    using SafeMath for uint;\r\n\r\n    //use struct Contributor from ERC20\r\n    //use bool locked from ERC20\r\n    \r\n    struct Sales {\r\n        address[] items;\r\n        mapping(address => uint) lookup;\r\n    }\r\n    \r\n    struct Offer {\r\n        uint256 tokens;\r\n        uint256 price;\r\n    }\r\n    \r\n    mapping(address => Offer) exchange;\r\n    \r\n    uint256 public market = 0;\r\n    \r\n    //Credits to https://github.com/k06a\r\n    Sales internal sales;\r\n    \r\n    function sellers(uint index) public view returns (address) {\r\n        return sales.items[index];\r\n    }\r\n    \r\n    function getOffer(address _owner) public view returns (uint256[2]) {\r\n        Offer storage offer = exchange[_owner];\r\n        return ([offer.price , offer.tokens]);\r\n    }\r\n    \r\n    function addSeller(address item) private {\r\n        if (sales.lookup[item] > 0) {\r\n            return;\r\n        }\r\n        sales.lookup[item] = sales.items.push(item);\r\n    }\r\n\r\n    function removeSeller(address item) private {\r\n        uint index = sales.lookup[item];\r\n        if (index == 0) {\r\n            return;\r\n        }\r\n        if (index < sales.items.length) {\r\n            address lastItem = sales.items[sales.items.length - 1];\r\n            sales.items[index - 1] = lastItem;\r\n            sales.lookup[lastItem] = index;\r\n        }\r\n        sales.items.length -= 1;\r\n        delete sales.lookup[item];\r\n    }\r\n    \r\n    \r\n    function setOffer(address _owner, uint256 _price, uint256 _value) internal {\r\n        exchange[_owner].price = _price;\r\n        market =  market.sub(exchange[_owner].tokens);\r\n        exchange[_owner].tokens = _value;\r\n        market =  market.add(_value);\r\n        if (_value == 0) {\r\n            removeSeller(_owner);\r\n        }\r\n        else {\r\n            addSeller(_owner);\r\n        }\r\n    }\r\n    \r\n\r\n    function offerToSell(uint256 _price, uint256 _value) public {\r\n        require(!locked);\r\n        setOffer(msg.sender, _price, _value);\r\n    }\r\n    \r\n    function executeOffer(address _owner) public payable {\r\n        require(!locked);\r\n        Offer storage offer = exchange[_owner];\r\n        require(offer.tokens > 0);\r\n        require(msg.value == offer.price);\r\n        _owner.transfer(msg.value);\r\n        \r\n        Contributor storage owner_c  = contributors[_owner];\r\n        Contributor storage sender_c = contributors[msg.sender];\r\n        \r\n        require(owner_c.balance >= offer.tokens);\r\n        owner_c.balance = owner_c.balance.sub(offer.tokens);\r\n        sender_c.balance =  sender_c.balance.add(offer.tokens);\r\n        emit Transfer(_owner, msg.sender, offer.tokens);\r\n        setOffer(_owner, 0, 0);\r\n    }\r\n    \r\n}\r\n\r\ncontract Ethnamed is DEXified {\r\n\r\n    using SafeMath for uint;\r\n    using StringHelper for string;\r\n    \r\n    struct Name {\r\n        string record;\r\n        address owner;\r\n        uint expires;\r\n        uint balance;\r\n    }\r\n    \r\n    function withdraw(address _to) public {\r\n\r\n        require(msg.sender == issuer); \r\n        \r\n        _to.transfer(address(this).balance);\r\n    }\r\n    \r\n    mapping (string => Name) internal registry;\r\n    \r\n    mapping (bytes32 => string) internal lookup;\r\n    \r\n    function resolve(string _name) public view returns (string) {\r\n        return registry[_name].record;\r\n    }\r\n    \r\n    function whois(bytes32 _hash) public view returns (string) {\r\n        return lookup[_hash];\r\n    }\r\n    \r\n    function transferOwnership(string _name, address _to) public {\r\n        \r\n        require(registry[_name].owner == msg.sender);\r\n        \r\n        registry[_name].owner = _to;\r\n    }\r\n\r\n    function removeName(string _name) internal {\r\n        Name storage item = registry[_name];\r\n        \r\n        bytes32 hash = keccak256(item.record);\r\n        \r\n        delete registry[_name];\r\n        \r\n        delete lookup[hash];\r\n    }\r\n\r\n    function removeExpiredName(string _name) public {\r\n        \r\n        require(registry[_name].expires < now);\r\n        \r\n        removeName(_name);\r\n    }\r\n    \r\n    function removeNameByOwner(string _name) public {\r\n        \r\n        Name storage item = registry[_name];\r\n        \r\n        require(item.owner == msg.sender);\r\n        \r\n        removeName(_name);\r\n    }\r\n    \r\n\r\n    function sendTo(string _name) public payable {\r\n        \r\n        if (registry[_name].owner == address(0)) {\r\n            registry[_name].balance = registry[_name].balance.add(msg.value);\r\n        }\r\n        else {\r\n            registry[_name].owner.transfer(msg.value);\r\n        }\r\n    \r\n    }\r\n    \r\n    \r\n    \r\n    function setupCore(string _name, string _record, address _owner, uint _life) internal {\r\n        \r\n        Name storage item = registry[_name];\r\n        \r\n        require(item.owner == msg.sender || item.owner == 0x0);\r\n        item.record = _record;\r\n        item.owner = _owner;\r\n        if (item.balance > 0) {\r\n            item.owner.transfer(item.balance);\r\n            item.balance = 0;\r\n        }\r\n        item.expires = now + _life;\r\n        bytes32 hash = keccak256(_record);\r\n        lookup[hash] = _name;\r\n        \r\n    }\r\n\r\n    function setupViaAuthority(\r\n        string _length,\r\n        string _name,\r\n        string _record,\r\n        string _blockExpiry,\r\n        address _owner,\r\n        uint8 _v, \r\n        bytes32 _r, \r\n        bytes32 _s,\r\n        uint _life\r\n    ) internal {\r\n        \r\n        require(_blockExpiry.stringToUint() >= block.number);\r\n        \r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n\", _length, _name, \"r=\", _record, \"e=\", _blockExpiry), _v, _r, _s) == issuer);\r\n        \r\n        setupCore(_name, _record, _owner, _life);\r\n        \r\n    }\r\n\r\n    function setOrUpdateRecord2(\r\n        string _length,\r\n        string _name,\r\n        string _record,\r\n        string _blockExpiry,\r\n        address _owner,\r\n        uint8 _v, \r\n        bytes32 _r, \r\n        bytes32 _s\r\n    ) public {\r\n        \r\n        Contributor storage contributor = contributors[msg.sender];\r\n        \r\n        require(contributor.balance >= tokenPrice);\r\n        \r\n        contributor.balance = contributor.balance.sub(tokenPrice);\r\n        \r\n        uint life = 48 weeks;\r\n     \r\n        setupViaAuthority(_length, _name, _record, _blockExpiry, _owner, _v, _r, _s, life);   \r\n    }\r\n\r\n    function setOrUpdateRecord(\r\n        string _length,\r\n        string _name,\r\n        string _record,\r\n        string _blockExpiry,\r\n        address _owner,\r\n        uint8 _v, \r\n        bytes32 _r, \r\n        bytes32 _s\r\n    ) public payable {\r\n        \r\n        uint life = msg.value == 0.01  ether ?  48 weeks : \r\n                    msg.value == 0.008 ether ?  24 weeks :\r\n                    msg.value == 0.006 ether ?  12 weeks :\r\n                    msg.value == 0.002 ether ?  4  weeks :\r\n                    0;\r\n                       \r\n        require(life > 0);\r\n        \r\n        setupViaAuthority(_length, _name, _record, _blockExpiry, _owner, _v, _r, _s, life);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"whois\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_length\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_record\",\"type\":\"string\"},{\"name\":\"_blockExpiry\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"setOrUpdateRecord\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"sendTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"offerToSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_length\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_record\",\"type\":\"string\"},{\"name\":\"_blockExpiry\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"setOrUpdateRecord2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"sellers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"removeNameByOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"removeExpiredName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"executeOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Ethnamed","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bddff2ec9b924280df2c1db1c7a41513ec6beecdfe3cf59c7c2165561dc71a2d"}]}