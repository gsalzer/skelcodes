{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner()\r\n    {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only the owner of that contract can execute this method\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(\r\n            newOwner != address(0x0),\r\n            \"Invalid address\"\r\n        );\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n// Inspired by https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\r\n// The old ERC20 token standard defines transfer and transferFrom without return value.\r\n// So the current ERC20 token standard is incompatible with this one.\r\ninterface IOldERC20 {\r\n\tfunction transfer(address to, uint256 value)\r\n        external;\r\n\r\n\tfunction transferFrom(address from, address to, uint256 value)\r\n        external;\r\n\r\n\tfunction approve(address spender, uint256 value)\r\n        external;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeOldERC20 {\r\n\t// definitely not a pure fn but the compiler complains otherwise\r\n    function checkSuccess()\r\n        private\r\n        pure\r\n\t\treturns (bool)\r\n\t{\r\n        uint256 returnValue = 0;\r\n\r\n        assembly {\r\n\t\t\t// check number of bytes returned from last function call\r\n\t\t\tswitch returndatasize\r\n\r\n\t\t\t// no bytes returned: assume success\r\n\t\t\tcase 0x0 {\r\n\t\t\t\treturnValue := 1\r\n\t\t\t}\r\n\r\n\t\t\t// 32 bytes returned: check if non-zero\r\n\t\t\tcase 0x20 {\r\n\t\t\t\t// copy 32 bytes into scratch space\r\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\r\n\r\n\t\t\t\t// load those bytes into returnValue\r\n\t\t\t\treturnValue := mload(0x0)\r\n\t\t\t}\r\n\r\n\t\t\t// not sure what was returned: don't mark as success\r\n\t\t\tdefault { }\r\n        }\r\n\r\n        return returnValue != 0;\r\n    }\r\n\r\n    function transfer(address token, address to, uint256 amount) internal {\r\n        IOldERC20(token).transfer(to, amount);\r\n        require(checkSuccess(), \"Transfer failed\");\r\n    }\r\n\r\n    function transferFrom(address token, address from, address to, uint256 amount) internal {\r\n        IOldERC20(token).transferFrom(from, to, amount);\r\n        require(checkSuccess(), \"Transfer From failed\");\r\n    }\r\n}\r\n\r\nlibrary CrowdsaleLib {\r\n\r\n    struct Crowdsale {\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 capacity;\r\n        uint256 leftAmount;\r\n        uint256 tokenRatio;\r\n        uint256 minContribution;\r\n        uint256 maxContribution;\r\n        uint256 weiRaised;\r\n        address wallet;\r\n    }\r\n\r\n    function isValid(Crowdsale storage _self)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            (_self.startTime >= now) &&\r\n            (_self.endTime >= _self.startTime) &&\r\n            (_self.tokenRatio > 0) &&\r\n            (_self.wallet != address(0))\r\n        );\r\n    }\r\n\r\n    function isOpened(Crowdsale storage _self)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (now >= _self.startTime && now <= _self.endTime);\r\n    }\r\n\r\n    function createCrowdsale(\r\n        address _wallet,\r\n        uint256[8] _values\r\n    )\r\n        internal\r\n        pure\r\n        returns (Crowdsale memory)\r\n    {\r\n        return Crowdsale({\r\n            startTime: _values[0],\r\n            endTime: _values[1],\r\n            capacity: _values[2],\r\n            leftAmount: _values[3],\r\n            tokenRatio: _values[4],\r\n            minContribution: _values[5],\r\n            maxContribution: _values[6],\r\n            weiRaised: _values[7],\r\n            wallet: _wallet\r\n        });\r\n    }\r\n}\r\n\r\ncontract IUpgradableExchange {\r\n\r\n    uint8 public VERSION;\r\n\r\n    event FundsMigrated(address indexed user, address indexed exchangeAddress);\r\n\r\n    function allowOrRestrictMigrations() external;\r\n\r\n    function migrateFunds(address[] _tokens) external;\r\n\r\n    function migrateEthers() private;\r\n\r\n    function migrateTokens(address[] _tokens) private;\r\n\r\n    function importEthers(address _user) external payable;\r\n\r\n    function importTokens(address _tokenAddress, uint256 _tokenAmount, address _user) external;\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value)\r\n        external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n        external returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary OrderLib {\r\n\r\n    struct Order {\r\n        uint256 makerSellAmount;\r\n        uint256 makerBuyAmount;\r\n        uint256 nonce;\r\n        address maker;\r\n        address makerSellToken;\r\n        address makerBuyToken;\r\n    }\r\n\r\n    /**\r\n    * @dev Hashes the order.\r\n    * @param order Order to be hashed.\r\n    * @return hash result\r\n    */\r\n    function createHash(Order memory order)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                order.maker,\r\n                order.makerSellToken,\r\n                order.makerSellAmount,\r\n                order.makerBuyToken,\r\n                order.makerBuyAmount,\r\n                order.nonce,\r\n                this\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Creates order struct from value arrays.\r\n    * @param addresses Array of trade's maker, makerToken and takerToken.\r\n    * @param values Array of trade's makerTokenAmount, takerTokenAmount, expires and nonce.\r\n    * @return Order struct\r\n    */\r\n    function createOrder(\r\n        address[3] addresses,\r\n        uint256[3] values\r\n    )\r\n        internal\r\n        pure\r\n        returns (Order memory)\r\n    {\r\n        return Order({\r\n            maker: addresses[0],\r\n            makerSellToken: addresses[1],\r\n            makerSellAmount: values[0],\r\n            makerBuyToken: addresses[2],\r\n            makerBuyAmount: values[1],\r\n            nonce: values[2]\r\n        });\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary Math {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256 c)\r\n    {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the ration between two assets. For example ETH/WDX\r\n    * @param _numerator uint256 base currency\r\n    * @param _denominator uint256 quote currency\r\n    */\r\n    function calculateRate(\r\n        uint256 _numerator,\r\n        uint256 _denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return div(mul(_numerator, 1e18), _denominator);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the fee in WDX\r\n    * @param _fee uint256 full fee\r\n    * @param _referralFeeRate uint256 referral fee rate\r\n    */\r\n    function calculateReferralFee(uint256 _fee, uint256 _referralFeeRate) internal pure returns (uint256) {\r\n        return div(_fee, _referralFeeRate);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the fee in WDX\r\n    * @param _etherAmount uint256 amount in Ethers\r\n    * @param _tokenRatio uint256 the rate between ETH/WDX\r\n    * @param _feeRate uint256 the fee rate\r\n    */\r\n    function calculateWdxFee(uint256 _etherAmount, uint256 _tokenRatio, uint256 _feeRate) internal pure returns (uint256) {\r\n        return div(div(mul(_etherAmount, 1e18), _tokenRatio), mul(_feeRate, 2));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Token contract\r\n * @dev extending ERC20 to support ExchangeOffering functionality.\r\n */\r\ncontract Token is IERC20 {\r\n    function getBonusFactor(uint256 _startTime, uint256 _endTime, uint256 _weiAmount)\r\n        public view returns (uint256);\r\n\r\n    function isUserWhitelisted(address _user)\r\n        public view returns (bool);\r\n}\r\n\r\ncontract Exchange is Ownable {\r\n\r\n    using Math for uint256;\r\n\r\n    using OrderLib for OrderLib.Order;\r\n\r\n    uint256 public feeRate;\r\n\r\n    mapping(address => mapping(address => uint256)) public balances;\r\n\r\n    mapping(bytes32 => uint256) public filledAmounts;\r\n\r\n    address constant public ETH = address(0x0);\r\n\r\n    address public feeAccount;\r\n\r\n    constructor(\r\n        address _feeAccount,\r\n        uint256 _feeRate\r\n    )\r\n        public\r\n    {\r\n        feeAccount = _feeAccount;\r\n        feeRate = _feeRate;\r\n    }\r\n\r\n    enum ErrorCode {\r\n        INSUFFICIENT_MAKER_BALANCE,\r\n        INSUFFICIENT_TAKER_BALANCE,\r\n        INSUFFICIENT_ORDER_AMOUNT\r\n    }\r\n\r\n    event Deposit(\r\n        address indexed tokenAddress,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 balance\r\n    );\r\n\r\n    event Withdraw(\r\n        address indexed tokenAddress,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 balance\r\n    );\r\n\r\n    event CancelOrder(\r\n        address indexed makerBuyToken,\r\n        address indexed makerSellToken,\r\n        address indexed maker,\r\n        bytes32 orderHash,\r\n        uint256 nonce\r\n    );\r\n\r\n    event TakeOrder(\r\n        address indexed maker,\r\n        address taker,\r\n        address indexed makerBuyToken,\r\n        address indexed makerSellToken,\r\n        uint256 takerGivenAmount,\r\n        uint256 takerReceivedAmount,\r\n        bytes32 orderHash,\r\n        uint256 nonce\r\n    );\r\n\r\n    event Error(\r\n        uint8 eventId,\r\n        bytes32 orderHash\r\n    );\r\n\r\n    /**\r\n    * @dev Owner can set the exchange fee\r\n    * @param _feeRate uint256 new fee rate\r\n    */\r\n    function setFee(uint256 _feeRate)\r\n        external\r\n        onlyOwner\r\n    {\r\n        feeRate = _feeRate;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner can set the new fee account\r\n    * @param _feeAccount address\r\n    */\r\n    function setFeeAccount(address _feeAccount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        feeAccount = _feeAccount;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to deposit Ethers in the exchange contract.\r\n    * Only the respected user can withdraw these Ethers.\r\n    */\r\n    function depositEthers() external payable\r\n    {\r\n        address user = msg.sender;\r\n        _depositEthers(user);\r\n        emit Deposit(ETH, user, msg.value, balances[ETH][user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to deposit Ethers for beneficiary in the exchange contract.\r\n    * @param _beneficiary address\r\n    * Only the beneficiary can withdraw these Ethers.\r\n    */\r\n    function depositEthersFor(\r\n        address\r\n        _beneficiary\r\n    )\r\n        external\r\n        payable\r\n    {\r\n        _depositEthers(_beneficiary);\r\n        emit Deposit(ETH, _beneficiary, msg.value, balances[ETH][_beneficiary]);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to deposit Tokens in the exchange contract.\r\n    * Only the respected user can withdraw these tokens.\r\n    * @param _tokenAddress address representing the token contract address.\r\n    * @param _amount uint256 representing the token amount to be deposited.\r\n    */\r\n    function depositTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        address user = msg.sender;\r\n        _depositTokens(_tokenAddress, _amount, user);\r\n        emit Deposit(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\r\n    }\r\n\r\n        /**\r\n    * @dev Allows user to deposit Tokens for beneficiary in the exchange contract.\r\n    * Only the beneficiary can withdraw these tokens.\r\n    * @param _tokenAddress address representing the token contract address.\r\n    * @param _amount uint256 representing the token amount to be deposited.\r\n    * @param _beneficiary address representing the token amount to be deposited.\r\n    */\r\n    function depositTokensFor(\r\n        address _tokenAddress,\r\n        uint256 _amount,\r\n        address _beneficiary\r\n    )\r\n        external\r\n    {\r\n        _depositTokens(_tokenAddress, _amount, _beneficiary);\r\n        emit Deposit(_tokenAddress, _beneficiary, _amount, balances[_tokenAddress][_beneficiary]);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal version of deposit Ethers.\r\n    */\r\n    function _depositEthers(\r\n        address\r\n        _beneficiary\r\n    )\r\n        internal\r\n    {\r\n        balances[ETH][_beneficiary] = balances[ETH][_beneficiary].add(msg.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal version of deposit Tokens.\r\n    */\r\n    function _depositTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount,\r\n        address _beneficiary\r\n    )\r\n        internal\r\n    {\r\n        balances[_tokenAddress][_beneficiary] = balances[_tokenAddress][_beneficiary].add(_amount);\r\n\r\n        require(\r\n            Token(_tokenAddress).transferFrom(msg.sender, this, _amount),\r\n            \"Token transfer is not successfull (maybe you haven't used approve first?)\"\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to withdraw Ethers from the exchange contract.\r\n    * Throws if the user balance is lower than the requested amount.\r\n    * @param _amount uint256 representing the amount to be withdrawn.\r\n    */\r\n    function withdrawEthers(uint256 _amount) external\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            balances[ETH][user] >= _amount,\r\n            \"Not enough funds to withdraw.\"\r\n        );\r\n\r\n        balances[ETH][user] = balances[ETH][user].sub(_amount);\r\n\r\n        user.transfer(_amount);\r\n\r\n        emit Withdraw(ETH, user, _amount, balances[ETH][user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to withdraw specific Token from the exchange contract.\r\n    * Throws if the user balance is lower than the requested amount.\r\n    * @param _tokenAddress address representing the token contract address.\r\n    * @param _amount uint256 representing the amount to be withdrawn.\r\n    */\r\n    function withdrawTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            balances[_tokenAddress][user] >= _amount,\r\n            \"Not enough funds to withdraw.\"\r\n        );\r\n\r\n        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\r\n\r\n        require(\r\n            Token(_tokenAddress).transfer(user, _amount),\r\n            \"Token transfer is not successfull.\"\r\n        );\r\n\r\n        emit Withdraw(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to transfer specific Token inside the exchange.\r\n    * @param _tokenAddress address representing the token address.\r\n    * @param _to address representing the beneficier.\r\n    * @param _amount uint256 representing the amount to be transferred.\r\n    */\r\n    function transfer(\r\n        address _tokenAddress,\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            balances[_tokenAddress][user] >= _amount,\r\n            \"Not enough funds to transfer.\"\r\n        );\r\n\r\n        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\r\n\r\n        balances[_tokenAddress][_to] = balances[_tokenAddress][_to].add(_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Common take order implementation\r\n    * @param _order OrderLib.Order memory - order info\r\n    * @param _takerSellAmount uint256 - amount being given by the taker\r\n    * @param _v uint8 part of the signature\r\n    * @param _r bytes32 part of the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32 part of the signature (from 32 to 64 bytes)\r\n    */\r\n    function takeOrder(\r\n        OrderLib.Order memory _order,\r\n        uint256 _takerSellAmount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        bytes32 orderHash = _order.createHash();\r\n\r\n        require(\r\n            ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", orderHash)), _v, _r, _s) == _order.maker,\r\n            \"Order maker is invalid.\"\r\n        );\r\n\r\n        if(balances[_order.makerBuyToken][msg.sender] < _takerSellAmount) {\r\n            emit Error(uint8(ErrorCode.INSUFFICIENT_TAKER_BALANCE), orderHash);\r\n            return 0;\r\n        }\r\n\r\n        uint256 receivedAmount = (_order.makerSellAmount.mul(_takerSellAmount)).div(_order.makerBuyAmount);\r\n\r\n        if(balances[_order.makerSellToken][_order.maker] < receivedAmount) {\r\n            emit Error(uint8(ErrorCode.INSUFFICIENT_MAKER_BALANCE), orderHash);\r\n            return 0;\r\n        }\r\n\r\n        if(filledAmounts[orderHash].add(_takerSellAmount) > _order.makerBuyAmount) {\r\n            emit Error(uint8(ErrorCode.INSUFFICIENT_ORDER_AMOUNT), orderHash);\r\n            return 0;\r\n        }\r\n\r\n        filledAmounts[orderHash] = filledAmounts[orderHash].add(_takerSellAmount);\r\n\r\n        balances[_order.makerBuyToken][msg.sender] = balances[_order.makerBuyToken][msg.sender].sub(_takerSellAmount);\r\n        balances[_order.makerBuyToken][_order.maker] = balances[_order.makerBuyToken][_order.maker].add(_takerSellAmount);\r\n\r\n        balances[_order.makerSellToken][msg.sender] = balances[_order.makerSellToken][msg.sender].add(receivedAmount);\r\n        balances[_order.makerSellToken][_order.maker] = balances[_order.makerSellToken][_order.maker].sub(receivedAmount);\r\n\r\n        emit TakeOrder(\r\n            _order.maker,\r\n            msg.sender,\r\n            _order.makerBuyToken,\r\n            _order.makerSellToken,\r\n            _takerSellAmount,\r\n            receivedAmount,\r\n            orderHash,\r\n            _order.nonce\r\n        );\r\n\r\n        return receivedAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Order maker can call this function in order to cancel it.\r\n    * What actually happens is that the order become\r\n    * fulfilled in the \"filledAmounts\" mapping. Thus we avoid someone calling\r\n    * \"takeOrder\" directly from the contract if the order hash is available to him.\r\n    * @param _orderAddresses address[3]\r\n    * @param _orderValues uint256[3]\r\n    * @param _v uint8 parameter parsed from the signature recovery\r\n    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function cancelOrder(\r\n        address[3] _orderAddresses,\r\n        uint256[3] _orderValues,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n    {\r\n        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\r\n        bytes32 orderHash = order.createHash();\r\n\r\n        require(\r\n            ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", orderHash)), _v, _r, _s) == msg.sender,\r\n            \"Only order maker can cancel it.\"\r\n        );\r\n\r\n        filledAmounts[orderHash] = filledAmounts[orderHash].add(order.makerBuyAmount);\r\n\r\n        emit CancelOrder(\r\n            order.makerBuyToken,\r\n            order.makerSellToken,\r\n            msg.sender,\r\n            orderHash,\r\n            order.nonce\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Cancel multiple orders in a single transaction.\r\n    * @param _orderAddresses address[3][]\r\n    * @param _orderValues uint256[3][]\r\n    * @param _v uint8[] parameter parsed from the signature recovery\r\n    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function cancelMultipleOrders(\r\n        address[3][] _orderAddresses,\r\n        uint256[3][] _orderValues,\r\n        uint8[] _v,\r\n        bytes32[] _r,\r\n        bytes32[] _s\r\n    )\r\n        external\r\n    {\r\n        for (uint256 index = 0; index < _orderAddresses.length; index++) {\r\n            cancelOrder(\r\n                _orderAddresses[index],\r\n                _orderValues[index],\r\n                _v[index],\r\n                _r[index],\r\n                _s[index]\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ncontract DailyVolumeUpdater is Ownable {\r\n\r\n    using Math for uint256;\r\n\r\n    uint256 public dailyVolume;\r\n\r\n    uint256 public dailyVolumeCap;\r\n\r\n    uint256 private lastDay;\r\n\r\n    constructor()\r\n        public\r\n    {\r\n        dailyVolume = 0;\r\n        dailyVolumeCap = 1000 ether;\r\n        lastDay = today();\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the owner to change the daily volume capacity.\r\n    * @param _dailyVolumeCap uint256 representing the daily volume capacity\r\n    */\r\n    function setDailyVolumeCap(uint256 _dailyVolumeCap)\r\n        public\r\n        onlyOwner\r\n    {\r\n        dailyVolumeCap = _dailyVolumeCap;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that increments the daily volume.\r\n    * @param _volume uint256 representing the amount of volume increasement.\r\n    */\r\n    function updateVolume(uint256 _volume)\r\n        internal\r\n    {\r\n        if(today() > lastDay) {\r\n            dailyVolume = _volume;\r\n            lastDay = today();\r\n        } else {\r\n            dailyVolume = dailyVolume.add(_volume);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if the volume capacity is reached.\r\n    * @return Whether the volume is reached or not.\r\n    */\r\n    function isVolumeReached()\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        return dailyVolume >= dailyVolumeCap;\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to determine today's index\r\n    * @return uint256 of today's index.\r\n    */\r\n    function today()\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return block.timestamp.div(1 days);\r\n    }\r\n}\r\n\r\ncontract DiscountTokenExchange is Exchange, DailyVolumeUpdater {\r\n\r\n    uint256 internal discountTokenRatio;\r\n\r\n    uint256 private minimumTokenAmountForUpdate;\r\n\r\n    address public discountTokenAddress;\r\n\r\n    bool internal initialized = false;\r\n\r\n    constructor(\r\n        address _discountTokenAddress,\r\n        uint256 _discountTokenRatio\r\n    )\r\n        public\r\n    {\r\n        discountTokenAddress = _discountTokenAddress;\r\n        discountTokenRatio = _discountTokenRatio;\r\n    }\r\n\r\n    modifier onlyOnce() {\r\n        require(\r\n            initialized == false,\r\n            \"Exchange is already initialized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Update the token discount contract.\r\n    * @param _discountTokenAddress address of the token used for fee discount\r\n    * @param _discountTokenRatio uint256 initial rate of the token discount contract\r\n    */\r\n    function setDiscountToken(\r\n        address _discountTokenAddress,\r\n        uint256 _discountTokenRatio,\r\n        uint256 _minimumTokenAmountForUpdate\r\n    )\r\n        public\r\n        onlyOwner\r\n        onlyOnce\r\n    {\r\n        discountTokenAddress = _discountTokenAddress;\r\n        discountTokenRatio = _discountTokenRatio;\r\n        minimumTokenAmountForUpdate = _minimumTokenAmountForUpdate;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Update the token ratio.\r\n    * Add a minimum requirement for the amount of tokens being traded\r\n    * to avoid possible intentional manipulation\r\n    * @param _etherAmount uint256 amount in Ethers (wei)\r\n    * @param _tokenAmount uint256 amount in Tokens\r\n    */\r\n    function updateTokenRatio(\r\n        uint256 _etherAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        if(_tokenAmount >= minimumTokenAmountForUpdate) {\r\n            discountTokenRatio = _etherAmount.calculateRate(_tokenAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Set the minimum requirement for updating the price.\r\n    * This should be called whenever the rate of the token\r\n    * has changed massively.\r\n    * In order to avoid token price manipulation (that will reduce the fee)\r\n    * The minimum amount requirement take place.\r\n    * For example: Someone buys or sells 0.0000000001 Tokens with\r\n    * high rate against ETH and after that execute a trade,\r\n    * reducing his fees to approximately zero.\r\n    * Having the mimimum amount requirement for updating\r\n    * the price will protect us from such cases because\r\n    * it will not be worth to do it.\r\n    * @param _minimumTokenAmountForUpdate - the new mimimum amount of\r\n    * tokens for updating the ratio (price)\r\n    */\r\n    function setMinimumTokenAmountForUpdate(\r\n        uint256 _minimumTokenAmountForUpdate\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        minimumTokenAmountForUpdate = _minimumTokenAmountForUpdate;\r\n    }\r\n\r\n    /**\r\n    * @dev Execute WeiDexToken Sale Order based on the order input parameters\r\n    * and the signature from the maker's signing.\r\n    * @param _orderAddresses address[3] representing\r\n    * [0] address of the order maker\r\n    * [1] address of WeiDexToken\r\n    * [2] address of Ether (0x0)\r\n    * @param _orderValues uint256[4] representing\r\n    * [0] amount in WDX\r\n    * [1] amount in Ethers (wei)\r\n    * [2] order nonce used for hash uniqueness\r\n    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in ethers\r\n    * @param _v uint8 parameter parsed from the signature recovery\r\n    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function takeSellTokenOrder(\r\n        address[3] _orderAddresses,\r\n        uint256[3] _orderValues,\r\n        uint256 _takerSellAmount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            _orderAddresses[1] == discountTokenAddress,\r\n            \"Should sell WeiDex Tokens\"\r\n        );\r\n\r\n        require(\r\n            0 < takeOrder(OrderLib.createOrder(_orderAddresses, _orderValues), _takerSellAmount, _v, _r, _s),\r\n            \"Trade failure\"\r\n        );\r\n        updateVolume(_takerSellAmount);\r\n        updateTokenRatio(_orderValues[1], _orderValues[0]);\r\n    }\r\n\r\n    /**\r\n    * @dev Execute WeiDexToken Buy Order based on the order input parameters\r\n    * and the signature from the maker's signing.\r\n    * @param _orderAddresses address[3] representing\r\n    * [0] address of the order maker\r\n    * [1] address of Ether (0x0)\r\n    * [2] address of WeiDexToken\r\n    * @param _orderValues uint256[4] representing\r\n    * [0] amount in Ethers\r\n    * [1] amount in WDX\r\n    * [2] order nonce used for hash uniqueness\r\n    * @param _takerSellAmount uint256 - amount being asked from the taker\r\n    * @param _v uint8 parameter parsed from the signature recovery\r\n    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function takeBuyTokenOrder(\r\n        address[3] _orderAddresses,\r\n        uint256[3] _orderValues,\r\n        uint256 _takerSellAmount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            _orderAddresses[2] == discountTokenAddress,\r\n            \"Should buy WeiDex Tokens\"\r\n        );\r\n\r\n        uint256 receivedAmount = takeOrder(OrderLib.createOrder(_orderAddresses, _orderValues), _takerSellAmount, _v, _r, _s);\r\n        require(0 < receivedAmount, \"Trade failure\");\r\n        updateVolume(receivedAmount);\r\n        updateTokenRatio(_orderValues[0], _orderValues[1]);\r\n    }\r\n}\r\n\r\ncontract ReferralExchange is Exchange {\r\n\r\n    uint256 public referralFeeRate;\r\n\r\n    mapping(address => address) public referrals;\r\n\r\n    constructor(\r\n        uint256 _referralFeeRate\r\n    )\r\n        public\r\n    {\r\n        referralFeeRate = _referralFeeRate;\r\n    }\r\n\r\n    event ReferralBalanceUpdated(\r\n        address refererAddress,\r\n        address referralAddress,\r\n        address tokenAddress,\r\n        uint256 feeAmount,\r\n        uint256 referralFeeAmount\r\n    );\r\n\r\n    event ReferralDeposit(\r\n        address token,\r\n        address indexed user,\r\n        address indexed referrer,\r\n        uint256 amount,\r\n        uint256 balance\r\n    );\r\n\r\n    /**\r\n    * @dev Deposit Ethers with a given referrer address\r\n    * @param _referrer address of the referrer\r\n    */\r\n    function depositEthers(address _referrer)\r\n        external\r\n        payable\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            0x0 == referrals[user],\r\n            \"This user already have a referrer.\"\r\n        );\r\n\r\n        super._depositEthers(user);\r\n        referrals[user] = _referrer;\r\n        emit ReferralDeposit(ETH, user, _referrer, msg.value, balances[ETH][user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Deposit Tokens with a given referrer address\r\n    * @param _referrer address of the referrer\r\n    */\r\n    function depositTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount,\r\n        address _referrer\r\n    )\r\n        external\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            0x0 == referrals[user],\r\n            \"This user already have a referrer.\"\r\n        );\r\n\r\n        super._depositTokens(_tokenAddress, _amount, user);\r\n        referrals[user] = _referrer;\r\n        emit ReferralDeposit(_tokenAddress, user, _referrer, _amount, balances[_tokenAddress][user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Update the referral fee rate,\r\n    * i.e. the rate of the fee that will be accounted to the referrer\r\n    * @param _referralFeeRate uint256 amount of fee going to the referrer\r\n    */\r\n    function setReferralFee(uint256 _referralFeeRate)\r\n        external\r\n        onlyOwner\r\n    {\r\n        referralFeeRate = _referralFeeRate;\r\n    }\r\n\r\n    /**\r\n    * @dev Return the feeAccount address if user doesn't have referrer\r\n    * @param _user address user whom referrer is being checked.\r\n    * @return address of user's referrer.\r\n    */\r\n    function getReferrer(address _user)\r\n        internal\r\n        view\r\n        returns(address referrer)\r\n    {\r\n        return referrals[_user] != address(0x0) ? referrals[_user] : feeAccount;\r\n    }\r\n}\r\n\r\ncontract UpgradableExchange is Exchange {\r\n\r\n    uint8 constant public VERSION = 0;\r\n\r\n    address public newExchangeAddress;\r\n\r\n    bool public isMigrationAllowed;\r\n\r\n    event FundsMigrated(address indexed user, address indexed exchangeAddress);\r\n\r\n    /**\r\n    * @dev Owner can set the address of the new version of the exchange contract.\r\n    * @param _newExchangeAddress address representing the new exchange contract address\r\n    */\r\n    function setNewExchangeAddress(address _newExchangeAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        newExchangeAddress = _newExchangeAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev Enables/Disables the migrations. Can be called only by the owner.\r\n    */\r\n    function allowOrRestrictMigrations()\r\n        external\r\n        onlyOwner\r\n    {\r\n        isMigrationAllowed = !isMigrationAllowed;\r\n    }\r\n\r\n    /**\r\n    * @dev Set the address of the new version of the exchange contract. Should be called by the user.\r\n    * @param _tokens address[] representing the token addresses which are going to be migrated.\r\n    */\r\n    function migrateFunds(address[] _tokens) external {\r\n\r\n        require(\r\n            false != isMigrationAllowed,\r\n            \"Fund migration is not allowed\"\r\n        );\r\n\r\n        require(\r\n            IUpgradableExchange(newExchangeAddress).VERSION() > VERSION,\r\n            \"New exchange version should be greater than the current version.\"\r\n        );\r\n\r\n        migrateEthers();\r\n\r\n        migrateTokens(_tokens);\r\n\r\n        emit FundsMigrated(msg.sender, newExchangeAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Helper function to migrate user's Ethers. Should be called in migrateFunds() function.\r\n    */\r\n    function migrateEthers() private {\r\n\r\n        uint256 etherAmount = balances[ETH][msg.sender];\r\n        if (etherAmount > 0) {\r\n            balances[ETH][msg.sender] = 0;\r\n\r\n            IUpgradableExchange(newExchangeAddress).importEthers.value(etherAmount)(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Helper function to migrate user's tokens. Should be called in migrateFunds() function.\r\n    * @param _tokens address[] representing the token addresses which are going to be migrated.\r\n    */\r\n    function migrateTokens(address[] _tokens) private {\r\n\r\n        for (uint256 index = 0; index < _tokens.length; index++) {\r\n\r\n            address tokenAddress = _tokens[index];\r\n\r\n            uint256 tokenAmount = balances[tokenAddress][msg.sender];\r\n\r\n            if (0 == tokenAmount) {\r\n                continue;\r\n            }\r\n\r\n            require(\r\n                Token(tokenAddress).approve(newExchangeAddress, tokenAmount),\r\n                \"Approve failed\"\r\n            );\r\n\r\n            balances[tokenAddress][msg.sender] = 0;\r\n\r\n            IUpgradableExchange(newExchangeAddress).importTokens(tokenAddress, tokenAmount, msg.sender);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ExchangeOffering is Exchange {\r\n\r\n    using CrowdsaleLib for CrowdsaleLib.Crowdsale;\r\n\r\n    mapping(address => CrowdsaleLib.Crowdsale) public crowdsales;\r\n\r\n    mapping(address => mapping(address => uint256)) public userContributionForProject;\r\n\r\n    event TokenPurchase(\r\n        address indexed project,\r\n        address indexed contributor,\r\n        uint256 tokens,\r\n        uint256 weiAmount\r\n    );\r\n\r\n    function registerCrowdsale(\r\n        address _project,\r\n        address _projectWallet,\r\n        uint256[8] _values\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        crowdsales[_project] = CrowdsaleLib.createCrowdsale(_projectWallet, _values);\r\n\r\n        require(\r\n            crowdsales[_project].isValid(),\r\n            \"Crowdsale is not active.\"\r\n        );\r\n\r\n        // project contract validation\r\n        require(\r\n            getBonusFactor(_project, crowdsales[_project].minContribution) >= 0,\r\n            \"The project should have *getBonusFactor* function implemented. The function should return the bonus percentage depending on the start/end date and contribution amount. Should return 0 if there is no bonus.\"\r\n        );\r\n\r\n        // project contract validation\r\n        require(\r\n            isUserWhitelisted(_project, this),\r\n            \"The project should have *isUserWhitelisted* function implemented. This contract address should be whitelisted\"\r\n        );\r\n    }\r\n\r\n    function buyTokens(address _project)\r\n       public\r\n       payable\r\n    {\r\n        uint256 weiAmount = msg.value;\r\n\r\n        address contributor = msg.sender;\r\n\r\n        address crowdsaleWallet = crowdsales[_project].wallet;\r\n\r\n        require(\r\n            isUserWhitelisted(_project, contributor), \"User is not whitelisted\"\r\n        );\r\n\r\n        require(\r\n            validContribution(_project, contributor, weiAmount),\r\n            \"Contribution is not valid: Check minimum/maximum contribution amount or if crowdsale cap is reached\"\r\n        );\r\n\r\n        uint256 tokens = weiAmount.mul(crowdsales[_project].tokenRatio);\r\n\r\n        uint256 bonus = getBonusFactor(_project, weiAmount);\r\n\r\n        uint256 bonusAmount = tokens.mul(bonus).div(100);\r\n\r\n        uint256 totalPurchasedTokens = tokens.add(bonusAmount);\r\n\r\n        crowdsales[_project].leftAmount = crowdsales[_project].leftAmount.sub(totalPurchasedTokens);\r\n\r\n        require(Token(_project).transfer(contributor, totalPurchasedTokens), \"Transfer failed\");\r\n\r\n        crowdsales[_project].weiRaised = crowdsales[_project].weiRaised.add(weiAmount);\r\n\r\n        userContributionForProject[_project][contributor] = userContributionForProject[_project][contributor].add(weiAmount);\r\n\r\n        balances[ETH][crowdsaleWallet] = balances[ETH][crowdsaleWallet].add(weiAmount);\r\n\r\n        emit TokenPurchase(_project, contributor, totalPurchasedTokens, weiAmount);\r\n    }\r\n\r\n    function withdrawWhenFinished(address _project) public {\r\n\r\n        address crowdsaleWallet = crowdsales[_project].wallet;\r\n\r\n        require(\r\n            msg.sender == crowdsaleWallet,\r\n            \"Only crowdsale owner can withdraw funds that are left.\"\r\n        );\r\n\r\n        require(\r\n            !crowdsales[_project].isOpened(),\r\n            \"You can't withdraw funds yet. Crowdsale should end first.\"\r\n        );\r\n\r\n        uint256 leftAmount = crowdsales[_project].leftAmount;\r\n\r\n        crowdsales[_project].leftAmount = 0;\r\n\r\n        require(Token(_project).transfer(crowdsaleWallet, leftAmount), \"Transfer failed\");\r\n    }\r\n\r\n    function saleOpen(address _project)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return crowdsales[_project].isOpened();\r\n    }\r\n\r\n    function getBonusFactor(address _project, uint256 _weiAmount)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Token(_project).getBonusFactor(crowdsales[_project].startTime, crowdsales[_project].endTime, _weiAmount);\r\n    }\r\n\r\n    function isUserWhitelisted(address _project, address _user)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return Token(_project).isUserWhitelisted(_user);\r\n    }\r\n\r\n    function validContribution(\r\n        address _project,\r\n        address _user,\r\n        uint256 _weiAmount\r\n    )\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        if (saleOpen(_project)) {\r\n            // minimum contribution check\r\n            if (_weiAmount < crowdsales[_project].minContribution) {\r\n                return false;\r\n            }\r\n\r\n            // maximum contribution check\r\n            if (userContributionForProject[_project][_user].add(_weiAmount) > crowdsales[_project].maxContribution) {\r\n                return false;\r\n            }\r\n\r\n            // token sale capacity check\r\n            if (crowdsales[_project].capacity < crowdsales[_project].weiRaised.add(_weiAmount)) {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n        return msg.value != 0; // check for non zero contribution\r\n    }\r\n}\r\n\r\ncontract OldERC20ExchangeSupport is Exchange, ReferralExchange {\r\n\r\n    /**\r\n    * @dev Allows user to deposit Tokens in the exchange contract.\r\n    * Only the respected user can withdraw these tokens.\r\n    * @param _tokenAddress address representing the token contract address.\r\n    * @param _amount uint256 representing the token amount to be deposited.\r\n    */\r\n    function depositOldTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        address user = msg.sender;\r\n        _depositOldTokens(_tokenAddress, _amount, user);\r\n        emit Deposit(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Deposit Tokens with a given referrer address\r\n    * @param _referrer address of the referrer\r\n    */\r\n    function depositOldTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount,\r\n        address _referrer\r\n    )\r\n        external\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            0x0 == referrals[user],\r\n            \"This user already have a referrer.\"\r\n        );\r\n\r\n        _depositOldTokens(_tokenAddress, _amount, user);\r\n        referrals[user] = _referrer;\r\n        emit ReferralDeposit(_tokenAddress, user, _referrer, _amount, balances[_tokenAddress][user]);\r\n    }\r\n\r\n        /**\r\n    * @dev Allows user to deposit Tokens for beneficiary in the exchange contract.\r\n    * Only the beneficiary can withdraw these tokens.\r\n    * @param _tokenAddress address representing the token contract address.\r\n    * @param _amount uint256 representing the token amount to be deposited.\r\n    * @param _beneficiary address representing the token amount to be deposited.\r\n    */\r\n    function depositOldTokensFor(\r\n        address _tokenAddress,\r\n        uint256 _amount,\r\n        address _beneficiary\r\n    )\r\n        external\r\n    {\r\n        _depositOldTokens(_tokenAddress, _amount, _beneficiary);\r\n        emit Deposit(_tokenAddress, _beneficiary, _amount, balances[_tokenAddress][_beneficiary]);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to withdraw specific Token from the exchange contract.\r\n    * Throws if the user balance is lower than the requested amount.\r\n    * @param _tokenAddress address representing the token contract address.\r\n    * @param _amount uint256 representing the amount to be withdrawn.\r\n    */\r\n    function withdrawOldTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            balances[_tokenAddress][user] >= _amount,\r\n            \"Not enough funds to withdraw.\"\r\n        );\r\n\r\n        balances[_tokenAddress][user] = balances[_tokenAddress][user].sub(_amount);\r\n\r\n        SafeOldERC20.transfer(_tokenAddress, user, _amount);\r\n\r\n        emit Withdraw(_tokenAddress, user, _amount, balances[_tokenAddress][user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal version of deposit Tokens.\r\n    */\r\n    function _depositOldTokens(\r\n        address _tokenAddress,\r\n        uint256 _amount,\r\n        address _beneficiary\r\n    )\r\n        internal\r\n    {\r\n        balances[_tokenAddress][_beneficiary] = balances[_tokenAddress][_beneficiary].add(_amount);\r\n\r\n        SafeOldERC20.transferFrom(_tokenAddress, msg.sender, this, _amount);\r\n    }\r\n}\r\n\r\ncontract WeiDex is DiscountTokenExchange, ReferralExchange, UpgradableExchange, ExchangeOffering, OldERC20ExchangeSupport  {\r\n\r\n    mapping(bytes4 => bool) private allowedMethods;\r\n\r\n    function () public payable {\r\n        revert(\"Cannot send Ethers to the contract, use depositEthers\");\r\n    }\r\n\r\n    constructor(\r\n        address _feeAccount,\r\n        uint256 _feeRate,\r\n        uint256 _referralFeeRate,\r\n        address _discountTokenAddress,\r\n        uint256 _discountTokenRatio\r\n    )\r\n        public\r\n        Exchange(_feeAccount, _feeRate)\r\n        ReferralExchange(_referralFeeRate)\r\n        DiscountTokenExchange(_discountTokenAddress, _discountTokenRatio)\r\n    {\r\n        // empty constructor\r\n    }\r\n\r\n    /**\r\n    * @dev Allows or restricts methods from being executed in takeAllPossible and takeAllOrRevert\r\n    * @param _methodId bytes4 method id that will be allowed/forbidded from execution\r\n    * @param _allowed bool\r\n    */\r\n    function allowOrRestrictMethod(\r\n        bytes4 _methodId,\r\n        bool _allowed\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        allowedMethods[_methodId] = _allowed;\r\n    }\r\n\r\n    /**\r\n    * @dev Execute multiple order by given method id\r\n    * @param _orderAddresses address[3][] representing\r\n    * @param _orderValues uint256[4][] representing\r\n    * @param _takerSellAmount uint256[] - amounts being asked from the taker, should be in tokens\r\n    * @param _v uint8[] parameter parsed from the signature recovery\r\n    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function takeAllOrRevert(\r\n        address[3][] _orderAddresses,\r\n        uint256[3][] _orderValues,\r\n        uint256[] _takerSellAmount,\r\n        uint8[] _v,\r\n        bytes32[] _r,\r\n        bytes32[] _s,\r\n        bytes4 _methodId\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            allowedMethods[_methodId],\r\n            \"Can't call this method\"\r\n        );\r\n\r\n        for (uint256 index = 0; index < _orderAddresses.length; index++) {\r\n            require(\r\n                address(this).delegatecall(\r\n                _methodId,\r\n                _orderAddresses[index],\r\n                _orderValues[index],\r\n                _takerSellAmount[index],\r\n                _v[index],\r\n                _r[index],\r\n                _s[index]\r\n                ),\r\n                \"Method call failed\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Execute multiple order by given method id\r\n    * @param _orderAddresses address[3][]\r\n    * @param _orderValues uint256[4][]\r\n    * @param _takerSellAmount uint256[] - amounts being asked from the taker, should be in tokens\r\n    * @param _v uint8[] parameter parsed from the signature recovery\r\n    * @param _r bytes32[] parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32[] parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function takeAllPossible(\r\n        address[3][] _orderAddresses,\r\n        uint256[3][] _orderValues,\r\n        uint256[] _takerSellAmount,\r\n        uint8[] _v,\r\n        bytes32[] _r,\r\n        bytes32[] _s,\r\n        bytes4 _methodId\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            allowedMethods[_methodId],\r\n            \"Can't call this method\"\r\n        );\r\n\r\n        for (uint256 index = 0; index < _orderAddresses.length; index++) {\r\n            address(this).delegatecall(\r\n            _methodId,\r\n            _orderAddresses[index],\r\n            _orderValues[index],\r\n            _takerSellAmount[index],\r\n            _v[index],\r\n            _r[index],\r\n            _s[index]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Execute buy order based on the order input parameters\r\n    * and the signature from the maker's signing\r\n    * @param _orderAddresses address[3] representing\r\n    * [0] address of the order maker\r\n    * [1] address of ether (0x0)\r\n    * [2] address of token being bought\r\n    * @param _orderValues uint256[4] representing\r\n    * [0] amount in Ethers (wei)\r\n    * [1] amount in tokens\r\n    * [2] order nonce used for hash uniqueness\r\n    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in tokens\r\n    * @param _v uint8 parameter parsed from the signature recovery\r\n    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function takeBuyOrder(\r\n        address[3] _orderAddresses,\r\n        uint256[3] _orderValues,\r\n        uint256 _takerSellAmount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            _orderAddresses[1] == ETH,\r\n            \"Base currency must be ether's (0x0)\"\r\n        );\r\n\r\n        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\r\n        uint256 receivedAmount = takeOrder(order, _takerSellAmount, _v, _r, _s);\r\n\r\n        require(0 < receivedAmount, \"Trade failure\");\r\n\r\n        updateVolume(receivedAmount);\r\n\r\n        if (!isVolumeReached()) {\r\n            takeFee(order.maker, msg.sender, order.makerBuyToken, _takerSellAmount, receivedAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Execute sell order based on the order input parameters\r\n    * and the signature from the maker's signing\r\n    * @param _orderAddresses address[3] representing\r\n    * [0] address of the order maker\r\n    * [1] address of token being sold\r\n    * [2] address of ether (0x0)\r\n    * @param _orderValues uint256[4] representing\r\n    * [0] amount in tokens\r\n    * [1] amount in Ethers (wei)\r\n    * [2] order nonce used for hash uniqueness\r\n    * @param _takerSellAmount uint256 - amount being asked from the taker, should be in ethers\r\n    * @param _v uint8 parameter parsed from the signature recovery\r\n    * @param _r bytes32 parameter parsed from the signature (from 0 to 32 bytes)\r\n    * @param _s bytes32 parameter parsed from the signature (from 32 to 64 bytes)\r\n    */\r\n    function takeSellOrder(\r\n        address[3] _orderAddresses,\r\n        uint256[3] _orderValues,\r\n        uint256 _takerSellAmount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            _orderAddresses[2] == ETH,\r\n            \"Base currency must be ether's (0x0)\"\r\n        );\r\n\r\n        OrderLib.Order memory order = OrderLib.createOrder(_orderAddresses, _orderValues);\r\n\r\n        uint256 receivedAmount = takeOrder(order, _takerSellAmount, _v, _r, _s);\r\n\r\n        require(0 < receivedAmount, \"Trade failure\");\r\n\r\n        updateVolume(_takerSellAmount);\r\n\r\n        if (!isVolumeReached()) {\r\n            takeFee(order.maker, msg.sender, order.makerSellToken, receivedAmount, _takerSellAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Takes fee for making/taking the order\r\n    * @param _maker address\r\n    * @param _taker address\r\n    * @param _tokenAddress address\r\n    * @param _tokenFulfilledAmount uint256 fulfilled amount in tokens\r\n    * @param _etherFulfilledAmount uint256 fulfilled amount in ethers\r\n    */\r\n    function takeFee(\r\n        address _maker,\r\n        address _taker,\r\n        address _tokenAddress,\r\n        uint256 _tokenFulfilledAmount,\r\n        uint256 _etherFulfilledAmount\r\n    )\r\n        private\r\n    {\r\n        uint256 _feeRate = feeRate; // gas optimization\r\n        uint256 feeInWdx = _etherFulfilledAmount.calculateWdxFee(discountTokenRatio, feeRate);\r\n\r\n        takeFee(_maker, ETH, _etherFulfilledAmount.div(_feeRate), feeInWdx);\r\n        takeFee(_taker, _tokenAddress, _tokenFulfilledAmount.div(_feeRate), feeInWdx);\r\n    }\r\n\r\n    /**\r\n    * @dev Takes fee in WDX or the given token address\r\n    * @param _user address taker or maker\r\n    * @param _tokenAddress address of the token\r\n    * @param _tokenFeeAmount uint256 amount in given token address\r\n    * @param _wdxFeeAmount uint256 amount in WDX tokens\r\n    */\r\n    function takeFee(\r\n        address _user,\r\n        address _tokenAddress,\r\n        uint256 _tokenFeeAmount,\r\n        uint256 _wdxFeeAmount\r\n        )\r\n        private\r\n    {\r\n        if(balances[discountTokenAddress][_user] >= _wdxFeeAmount) {\r\n            takeFee(_user, discountTokenAddress, _wdxFeeAmount);\r\n        } else {\r\n            takeFee(_user, _tokenAddress, _tokenFeeAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Takes fee in WDX or the given token address\r\n    * @param _user address taker or maker\r\n    * @param _tokenAddress address\r\n    * @param _fullFee uint256 fee taken from a given token address\r\n    */\r\n    function takeFee(\r\n        address _user,\r\n        address _tokenAddress,\r\n        uint256 _fullFee\r\n        )\r\n        private\r\n    {\r\n        address _feeAccount = feeAccount; // gas optimization\r\n        address referrer = getReferrer(_user);\r\n        uint256 referralFee = _fullFee.calculateReferralFee(referralFeeRate);\r\n\r\n        balances[_tokenAddress][_user] = balances[_tokenAddress][_user].sub(_fullFee);\r\n\r\n        if(referrer == _feeAccount) {\r\n            balances[_tokenAddress][_feeAccount] = balances[_tokenAddress][_feeAccount].add(_fullFee);\r\n        } else {\r\n            balances[_tokenAddress][_feeAccount] = balances[_tokenAddress][_feeAccount].add(_fullFee.sub(referralFee));\r\n            balances[_tokenAddress][referrer] = balances[_tokenAddress][referrer].add(referralFee);\r\n        }\r\n        emit ReferralBalanceUpdated(referrer, _user, _tokenAddress, _fullFee, referralFee);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3][]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3][]\"},{\"name\":\"_takerSellAmount\",\"type\":\"uint256[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"takeAllPossible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimumTokenAmountForUpdate\",\"type\":\"uint256\"}],\"name\":\"setMinimumTokenAmountForUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dailyVolumeCap\",\"type\":\"uint256\"}],\"name\":\"setDailyVolumeCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_methodId\",\"type\":\"bytes4\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"allowOrRestrictMethod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3]\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3]\"},{\"name\":\"_takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"takeBuyOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMigrationAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3]\"},{\"name\":\"_takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"takeSellTokenOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filledAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3]\"},{\"name\":\"_takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"takeSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"setFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"depositTokensFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_discountTokenAddress\",\"type\":\"address\"},{\"name\":\"_discountTokenRatio\",\"type\":\"uint256\"},{\"name\":\"_minimumTokenAmountForUpdate\",\"type\":\"uint256\"}],\"name\":\"setDiscountToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeRate\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userContributionForProject\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referralFeeRate\",\"type\":\"uint256\"}],\"name\":\"setReferralFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3][]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3][]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"cancelMultipleOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3][]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3][]\"},{\"name\":\"_takerSellAmount\",\"type\":\"uint256[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"takeAllOrRevert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositOldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExchangeAddress\",\"type\":\"address\"}],\"name\":\"setNewExchangeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newExchangeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyVolumeCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowOrRestrictMigrations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"migrateFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"getBonusFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isUserWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositEthers\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"depositOldTokensFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"crowdsales\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"capacity\",\"type\":\"uint256\"},{\"name\":\"leftAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRatio\",\"type\":\"uint256\"},{\"name\":\"minContribution\",\"type\":\"uint256\"},{\"name\":\"maxContribution\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"}],\"name\":\"withdrawWhenFinished\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"},{\"name\":\"_projectWallet\",\"type\":\"address\"},{\"name\":\"_values\",\"type\":\"uint256[8]\"}],\"name\":\"registerCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"}],\"name\":\"saleOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"depositEthersFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositOldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawOldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[3]\"},{\"name\":\"_takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"takeBuyTokenOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEthers\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discountTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeAccount\",\"type\":\"address\"},{\"name\":\"_feeRate\",\"type\":\"uint256\"},{\"name\":\"_referralFeeRate\",\"type\":\"uint256\"},{\"name\":\"_discountTokenAddress\",\"type\":\"address\"},{\"name\":\"_discountTokenRatio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"project\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"exchangeAddress\",\"type\":\"address\"}],\"name\":\"FundsMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"refererAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referralFeeAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ReferralDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerBuyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"makerSellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"CancelOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"makerBuyToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"makerSellToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerGivenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerReceivedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"TakeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"eventId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"WeiDex","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004c7fecf4d0be2ac527119fca1b31a4811cccece3000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000dead00000000000000000000000000000000000000000000000000071afd498d0000","Library":"","SwarmSource":"bzzr://a2214fbc358cecd0a04650a7cd0356e0d3a1b5977b4f27f5488617e123b79c5f"}]}