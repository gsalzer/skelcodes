{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n\r\nWhen executed after the Kings contract, the entire token balance inside the contract will be transferred to the minter if they becomes the king which they are already the king.\r\n\r\n\r\n*/\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ERC918Interface {\r\n\r\n  function epochCount() public constant returns (uint);\r\n\r\n  function totalSupply() public constant returns (uint);\r\n  function getMiningDifficulty() public constant returns (uint);\r\n  function getMiningTarget() public constant returns (uint);\r\n  function getMiningReward() public constant returns (uint);\r\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n\r\n  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\r\n\r\n  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n\r\n}\r\n\r\ncontract mintForwarderInterface\r\n{\r\n  function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool success);\r\n}\r\n\r\ncontract proxyMinterInterface\r\n{\r\n  function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\r\n}\r\n\r\ncontract miningKingContract\r\n{\r\n  function getKing() public returns (address king);\r\n}\r\n\r\n\r\ncontract ownedContractInterface\r\n{\r\n  address public owner;\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\n// Owned contract\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    address public newOwner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n\r\n    function Owned() public {\r\n\r\n        owner = msg.sender;\r\n\r\n    }\r\n\r\n\r\n    modifier onlyOwner {\r\n\r\n        require(msg.sender == owner);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n\r\n        newOwner = _newOwner;\r\n\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n\r\n        require(msg.sender == newOwner);\r\n\r\n        OwnershipTransferred(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n\r\n        newOwner = address(0);\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract DoubleKingsReward is Owned\r\n{\r\n\r\n\r\n  using SafeMath for uint;\r\n\r\n\r\n   address public kingContract;\r\n\r\n   address public minedToken;\r\n\r\n\r\n\r\n   // 0xBTC is 0xb6ed7644c69416d67b522e20bc294a9a9b405b31;\r\n  constructor(address mToken, address mkContract) public  {\r\n    minedToken = mToken;\r\n    kingContract = mkContract;\r\n  }\r\n\r\n\r\n  function getBalance() view public returns (uint)\r\n  {\r\n    return ERC20Interface(minedToken).balanceOf(this);\r\n  }\r\n\r\n  //do not allow ether to enter\r\n  function() public payable {\r\n      revert();\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n Pay out the token balance if the king becomes the king twice in a row\r\n**/\r\n\r\n//proxyMintWithKing\r\n   function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool)\r\n   {\r\n\r\n       require(proxyMintArray.length > 0);\r\n\r\n\r\n       uint previousEpochCount = ERC918Interface(minedToken).epochCount();\r\n\r\n       address proxyMinter = proxyMintArray[0];\r\n\r\n       if(proxyMintArray.length == 1)\r\n       {\r\n         //Forward to the last proxyMint contract, typically a pool's owned  mint contract\r\n         require(proxyMinterInterface(proxyMinter).proxyMint(nonce, challenge_digest));\r\n       }else{\r\n         //if array length is greater than 1, pop the proxyMinter from the front of the array and keep cascading down the chain...\r\n         address[] memory remainingProxyMintArray = popFirstFromArray(proxyMintArray);\r\n\r\n         require(mintForwarderInterface(proxyMinter).mintForwarder(nonce, challenge_digest,remainingProxyMintArray));\r\n       }\r\n\r\n      //make sure that the minedToken really was proxy minted through the proxyMint delegate call chain\r\n       require( ERC918Interface(minedToken).epochCount() == previousEpochCount.add(1) );\r\n\r\n\r\n\r\n\r\n       // UNIQUE CONTRACT ACTION SPACE\r\n       address proxyMinterAddress = ownedContractInterface(proxyMinter).owner();\r\n       require(proxyMinterAddress == owner);\r\n\r\n       address miningKing = miningKingContract(kingContract).getKing();\r\n\r\n       bytes memory nonceBytes = uintToBytesForAddress(nonce);\r\n\r\n       address newKing = bytesToAddress(nonceBytes);\r\n\r\n       if(miningKing == newKing)\r\n       {\r\n         uint balance = ERC20Interface(minedToken).balanceOf(this);\r\n         require(ERC20Interface(minedToken).transfer(newKing,balance));\r\n       }\r\n       // --------\r\n\r\n       return true;\r\n   }\r\n\r\n\r\n  function popFirstFromArray(address[] array) pure public returns (address[] memory)\r\n  {\r\n    address[] memory newArray = new address[](array.length-1);\r\n\r\n    for (uint i=0; i < array.length-1; i++) {\r\n      newArray[i] =  array[i+1]  ;\r\n    }\r\n\r\n    return newArray;\r\n  }\r\n\r\n function uintToBytesForAddress(uint256 x) pure public returns (bytes b) {\r\n\r\n      b = new bytes(20);\r\n      for (uint i = 0; i < 20; i++) {\r\n          b[i] = byte(uint8(x / (2**(8*(31 - i)))));\r\n      }\r\n\r\n      return b;\r\n    }\r\n\r\n\r\n function bytesToAddress (bytes b) pure public returns (address) {\r\n     uint result = 0;\r\n     for (uint i = b.length-1; i+1 > 0; i--) {\r\n       uint c = uint(b[i]);\r\n       uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n       result += to_inc;\r\n     }\r\n     return address(result);\r\n }\r\n\r\n // ------------------------------------------------------------------------\r\n\r\n // Owner can transfer out any accidentally sent ERC20 tokens\r\n\r\n // ------------------------------------------------------------------------\r\n\r\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n\r\n     return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n\r\n }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"array\",\"type\":\"address[]\"}],\"name\":\"popFirstFromArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"bytesToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kingContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"uintToBytesForAddress\",\"outputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"name\":\"proxyMintArray\",\"type\":\"address[]\"}],\"name\":\"mintForwarder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"mToken\",\"type\":\"address\"},{\"name\":\"mkContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DoubleKingsReward","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b6ed7644c69416d67b522e20bc294a9a9b405b310000000000000000000000000b98f937f6edd6f66b0f0a210d3dcd8ec1063cb6","Library":"","SwarmSource":"bzzr://1245710ac241e8117f8656fbdedcc47cddda96bb2243e75be4173689758dfbcd"}]}