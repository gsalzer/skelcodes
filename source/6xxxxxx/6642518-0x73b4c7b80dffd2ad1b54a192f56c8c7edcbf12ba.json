{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/* - https://eth-invest.com/      version: 1.0.1\r\n*  - Ref bonuses 8% per day, 0.33% every hour\r\n*  - Invest dividends 8%\r\n*  - Invest and get 120% But u can't get more than 120%\r\n*  - Dont snooze, you can earn ETH only the first fifteen days!!!\r\n*  - Invite your friends, you will get 4% for each other, they will get +2% to their deposit. Also, if u already got 120% u can get invite bonuses\r\n*  - Have a nice day :)\r\n*/\r\ncontract MainContract {\r\n    address owner;\r\n    address advertisingAddress;\r\n\r\n    uint private constant minInvest = 10 finney; // 0.01 eth\r\n    \r\n    uint constant maxPayment = 360; // maxPayment value every hour your payment + 1; 24 hours * 15 days = 360 :)\r\n    using Calc for uint;\r\n    using PercentCalc for PercentCalc.percent;\r\n    using Zero for *;\r\n    using compileLibrary for *;\r\n\r\n    struct User {\r\n        uint idx;\r\n        uint value;\r\n        uint bonus;\r\n        uint payValue;\r\n        uint payTime;\r\n    }\r\n\r\n    mapping(address => User) investorsStorage;\r\n\r\n    address[] users;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    event logsDataPayable(uint value, uint time, address indexed addr);\r\n    event logsDataConstructor(address creater, uint when, string text);\r\n    event newInvestor(address indexed addr, uint when, uint value);\r\n    event investToProject(address creater, uint when, string text);\r\n    event logPaymentUser(uint value, uint when, address indexed addr, string text);\r\n    event logPayDividends(uint value, uint when, address indexed addr, string text);\r\n    event logPayBonus(uint value, uint when, address indexed addr, string text);\r\n    event notEnoughETH(uint when, string text);\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        users.length++;\r\n        emit logsDataConstructor(msg.sender, now, \"constructor\");\r\n    }\r\n\r\n    //     PercentCalc\r\n    PercentCalc.percent private dividendPercent = PercentCalc.percent(8); // 8%\r\n    PercentCalc.percent private refPercent = PercentCalc.percent(2); // 2%\r\n    PercentCalc.percent private refPercentBonus = PercentCalc.percent(4); // 4% \r\n    PercentCalc.percent private advertisingPercent = PercentCalc.percent(5); // 5%\r\n    PercentCalc.percent private ownerPercent = PercentCalc.percent(2); // 2%\r\n\r\n    function() public payable {\r\n        if (msg.value == 0) {\r\n            fetchDividends();\r\n            return;\r\n        }\r\n\r\n        require(msg.value >= minInvest, \"value can't be < than 0.01\");\r\n        if (investorsStorage[msg.sender].idx > 0) { // dont send more if u have already invested!!! \r\n            sendValueToAdv(msg.value);\r\n        } else {\r\n            address ref = msg.data.toAddr();\r\n            uint idx = investorsStorage[msg.sender].idx;\r\n            uint value = msg.value;\r\n            idx = users.length++;\r\n            if (ref.notZero() && investorsStorage[ref].idx > 0) {\r\n                setUserBonus(ref, msg.value);\r\n                value += refPercent.getValueByPercent(value);\r\n            }\r\n            emit newInvestor(msg.sender, now, msg.value);\r\n            investorsStorage[msg.sender] = User({\r\n                idx : idx,\r\n                value : value,\r\n                bonus : 0,\r\n                payValue: 0,\r\n                payTime : now\r\n                });\r\n        }\r\n\r\n        sendValueToOwner(msg.value);\r\n        sendValueToAdv(msg.value);\r\n\r\n        emit logsDataPayable(msg.value, now, msg.sender);\r\n    }\r\n\r\n\r\n    function setUserBonus(address addr, uint value) private {\r\n        uint bonus = refPercentBonus.getValueByPercent(value);\r\n        if (investorsStorage[addr].idx > 0) {\r\n            investorsStorage[addr].bonus += bonus;\r\n        } else {\r\n            sendValueToAdv(bonus);\r\n        }\r\n    }\r\n\r\n    function fetchDividends() private {\r\n        User memory inv = findInvestorByAddress(msg.sender);\r\n        require(inv.idx > 0, \"Payer is not investor\");\r\n        uint payValueByTime = now.sub(inv.payTime).getDiffValue(1 hours);\r\n        require(payValueByTime > 0, \"the payment was earlier than 1 hours\");\r\n        uint newPayValye = payValueByTime + inv.payValue; // do not snooze\r\n        if (newPayValye > maxPayment) {\r\n            require(inv.bonus > 0, \"you've already got 120%\");\r\n            sendUserBonus(msg.sender, inv.bonus);\r\n        } else {\r\n            uint dividendValue = (dividendPercent.getValueByPercent(inv.value) * payValueByTime) / 24;\r\n            if (address(this).balance < dividendValue + inv.bonus) {\r\n                emit notEnoughETH(now, \"not enough Eth at address\");\r\n                return;\r\n            }\r\n            emit logPaymentUser(newPayValye, now, msg.sender, 'gotPercent value');\r\n            investorsStorage[msg.sender].payValue += payValueByTime;\r\n            if (inv.bonus > 0) {\r\n                sendDividendsWithBonus(msg.sender, dividendValue, inv.bonus);\r\n            } else {\r\n                sendDividends(msg.sender, dividendValue);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function sendUserBonus(address addr, uint bonus) private {\r\n        addr.transfer(bonus);\r\n        investorsStorage[addr].bonus = 0;\r\n        emit logPayBonus(bonus, now, addr, \"Investor got bonuses!\");\r\n    }\r\n\r\n    function setAdvertisingAddress(address addr) public onlyOwner {\r\n        advertisingAddress = addr;\r\n    }\r\n\r\n\r\n    function sendDividends(address addr, uint value) private {\r\n        updatePayTime(addr, now);\r\n        emit logPayDividends(value, now, addr, \"dividends\");\r\n        addr.transfer(value);\r\n    }\r\n\r\n    function sendDividendsWithBonus(address addr, uint value, uint bonus) private {\r\n        updatePayTime(addr, now);\r\n        addr.transfer(value + bonus);\r\n        investorsStorage[addr].bonus = 0;\r\n        emit logPayDividends(value + bonus, now, addr, \"dividends with bonus\");\r\n    }\r\n\r\n    function findInvestorByAddress(address addr) internal view returns (User) {\r\n        return User(\r\n            investorsStorage[addr].idx,\r\n            investorsStorage[addr].value,\r\n            investorsStorage[addr].bonus,\r\n            investorsStorage[addr].payValue,\r\n            investorsStorage[addr].payTime\r\n        );\r\n    }\r\n\r\n    function sendValueToOwner(uint val) private {\r\n        owner.transfer(ownerPercent.getValueByPercent(val));\r\n    }\r\n\r\n    function sendValueToAdv(uint val) private {\r\n        advertisingAddress.transfer(advertisingPercent.getValueByPercent(val));\r\n    }\r\n\r\n\r\n    function updatePayTime(address addr, uint time) private returns (bool) {\r\n        if (investorsStorage[addr].idx == 0) return false;\r\n        investorsStorage[addr].payTime = time;\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// Calc library\r\nlibrary Calc {\r\n    function getDiffValue(uint _a, uint _b) internal pure returns (uint) {\r\n        require(_b > 0);\r\n        uint c = _a / _b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint _a, uint _b) internal pure returns (uint) {\r\n        require(_b <= _a);\r\n        uint c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n}\r\n// Percent Calc library\r\nlibrary PercentCalc {\r\n    struct percent {\r\n        uint val;\r\n    }\r\n\r\n    function getValueByPercent(percent storage p, uint a) internal view returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a * p.val / 100;\r\n    }\r\n}\r\n\r\nlibrary Zero {\r\n    function notZero(address addr) internal pure returns (bool) {\r\n        return !(addr == address(0));\r\n    }\r\n}\r\n\r\n\r\nlibrary compileLibrary {\r\n    function toAddr(bytes source) internal pure returns (address addr) {\r\n        assembly {addr := mload(add(source, 0x14))}\r\n        return addr;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"logsDataPayable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"logsDataConstructor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"newInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"investToProject\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"logPaymentUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"logPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"logPayBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"notEnoughETH\",\"type\":\"event\"}]","ContractName":"MainContract","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://09d99c21aaf7a5f255862854b65a91e406f36839a6e6abb17f49071e256539a7"}]}