{"status":"1","message":"OK","result":[{"SourceCode":"contract UTU {\r\n    string public name = \"Upgrade Token Utility\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"UTU\";\r\n\r\n    address public owner;\r\n    address public feesAddr;\r\n    address trancheAdmin;\r\n\r\n    uint256 public totalSupply = 50000000000000000000000000; // 50m e18\r\n    uint public trancheLevel = 1;\r\n    uint256 public circulatingSupply = 0;\r\n    uint maxTranche = 4;\r\n    uint loopCount = 0;\r\n    uint256 feePercent = 1500;  // the calculation expects % * 100 (so 10% is 1000)\r\n    uint256 public trancheOneSaleTime;\r\n    bool public receiveEth = true;\r\n    bool payFees = true;\r\n    bool addTranches = true;\r\n    bool trancheOne = true;\r\n\r\n    // Storage\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => uint256) public trancheOneBalances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // mining schedule\r\n    mapping(uint => uint256) public trancheTokens;\r\n    mapping(uint => uint256) public trancheRate;\r\n\r\n    // events (ERC20)\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function UTU() {\r\n        owner = msg.sender;\r\n        feesAddr = msg.sender;\r\n        trancheAdmin = msg.sender;\r\n        trancheOneSaleTime = now + 182 days;    // 6 months\r\n        populateTrancheTokens();\r\n        populateTrancheRates();\r\n    }\r\n\r\n    function populateTrancheTokens() internal {\r\n        trancheTokens[1] = 1E25;\r\n        trancheTokens[2] = 2E25;\r\n        trancheTokens[3] = 1E25;\r\n        trancheTokens[4] = 1E25;\r\n    }\r\n\r\n    function populateTrancheRates() internal {\r\n        trancheRate[1] = 3.457E20;\r\n        trancheRate[2] = 8.643E19;\r\n        trancheRate[3] = 4.321E19;\r\n        trancheRate[4] = 2.161E19;\r\n    }\r\n\r\n    function () payable public {\r\n        require((msg.value > 0) && (receiveEth));\r\n        allocateTokens(msg.value,0);\r\n    }\r\n\r\n    function allocateTokens(uint256 _submitted, uint256 _tokenCount) internal {\r\n        uint256 _tokensAfforded = 0;\r\n        loopCount++;\r\n\r\n        if((trancheLevel <= maxTranche) && (loopCount <= maxTranche)) {\r\n            _tokensAfforded = div(mul(_submitted, trancheRate[trancheLevel]), 1 ether);\r\n        }\r\n\r\n        if((_tokensAfforded >= trancheTokens[trancheLevel]) && (loopCount <= maxTranche)) {\r\n            _submitted = sub(_submitted, div(mul(trancheTokens[trancheLevel], 1 ether), trancheRate[trancheLevel]));\r\n            _tokenCount = add(_tokenCount, trancheTokens[trancheLevel]);\r\n\r\n            if(trancheLevel == 1) {\r\n                // we need to record tranche1 purchases so we can stop sale/transfer of them during the first 6 mths\r\n                trancheOneBalances[msg.sender] = add(trancheOneBalances[msg.sender], trancheTokens[trancheLevel]);\r\n            }\r\n\r\n            circulatingSupply = add(circulatingSupply, _tokensAfforded);\r\n            trancheTokens[trancheLevel] = 0;\r\n\r\n            trancheLevel++;\r\n\r\n            if(trancheLevel == 2) {\r\n                trancheOne = false;\r\n            }\r\n\r\n            allocateTokens(_submitted, _tokenCount);\r\n        }\r\n        else if((trancheTokens[trancheLevel] >= _tokensAfforded) && (_tokensAfforded > 0) && (loopCount <= maxTranche)) {\r\n            trancheTokens[trancheLevel] = sub(trancheTokens[trancheLevel], _tokensAfforded);\r\n            _tokenCount = add(_tokenCount, _tokensAfforded);\r\n            circulatingSupply = add(circulatingSupply, _tokensAfforded);\r\n\r\n            if(trancheLevel == 1) {\r\n                // we need to record tranche1 purchases\r\n                trancheOneBalances[msg.sender] = add(trancheOneBalances[msg.sender], _tokenCount);\r\n            }\r\n\r\n            // we've spent up - go around again and issue tokens to recipient\r\n            allocateTokens(0, _tokenCount);\r\n        }\r\n        else {\r\n            // 15% of the purchased tokens amount is fees\r\n            uint256 fees = 0;\r\n            if(payFees) {\r\n                fees = add(fees, ((_tokenCount * feePercent) / 10000));\r\n                circulatingSupply = add(circulatingSupply, fees);\r\n            }\r\n\r\n            balances[msg.sender] = add(balances[msg.sender], _tokenCount);\r\n            trancheTokens[maxTranche] = sub(trancheTokens[maxTranche], fees);\r\n            balances[feesAddr] = add(balances[feesAddr], fees);\r\n\r\n            if(trancheOne) {\r\n                trancheOneBalances[feesAddr] = add(trancheOneBalances[feesAddr], fees);\r\n            }\r\n\r\n            Transfer(this, msg.sender, _tokenCount);\r\n            Transfer(this, feesAddr, fees);\r\n            loopCount = 0;\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if(_to == address(this)) {\r\n            // WARNING: if you transfer tokens back to the contract you will lose them\r\n            balances[msg.sender] = sub(balances[msg.sender], _value);\r\n\r\n            if(_value >= trancheOneBalances[msg.sender]) {\r\n                trancheOneBalances[msg.sender] = 0;\r\n            }\r\n            else {\r\n                trancheOneBalances[msg.sender] = sub(trancheOneBalances[msg.sender], _value);\r\n            }\r\n\r\n            circulatingSupply = sub(circulatingSupply, _value);\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n        else {\r\n            if(now >= trancheOneSaleTime) {\r\n                balances[msg.sender] = sub(balances[msg.sender], _value);\r\n                balances[_to] = add(balances[_to], _value);\r\n                Transfer(msg.sender, _to, _value);\r\n            }\r\n            else {\r\n                if(_value <= sub(balances[msg.sender],trancheOneBalances[msg.sender])) {\r\n                    balances[msg.sender] = sub(balances[msg.sender], _value);\r\n                    balances[_to] = add(balances[_to], _value);\r\n                    Transfer(msg.sender, _to, _value);\r\n                }\r\n                else revert();  // you can't transfer tranche1 tokens during the first 6 months\r\n            }\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _receiver) public constant returns (uint256) {\r\n        return balances[_receiver];\r\n    }\r\n\r\n    function trancheOneBalanceOf(address _receiver) public constant returns (uint256) {\r\n        return trancheOneBalances[_receiver];\r\n    }\r\n\r\n    function balanceInTranche() public constant returns (uint256) {\r\n        return trancheTokens[trancheLevel];\r\n    }\r\n\r\n    function balanceInSpecificTranche(uint256 _tranche) public constant returns (uint256) {\r\n        return trancheTokens[_tranche];\r\n    }\r\n\r\n    function rateOfSpecificTranche(uint256 _tranche) public constant returns (uint256) {\r\n        return trancheRate[_tranche];\r\n    }\r\n\r\n    function changeFeesAddress(address _fees) public {\r\n        require(msg.sender == feesAddr);\r\n        feesAddr = _fees;\r\n    }\r\n\r\n    function payFeesToggle() public {\r\n        require(msg.sender == owner);\r\n        if(payFees) {\r\n            payFees = false;\r\n        }\r\n        else {\r\n            payFees = true;\r\n        }\r\n    }\r\n\r\n    // enables fee update - must be between 0 and 100 (%)\r\n    function updateFeeAmount(uint _newFee) public {\r\n        require(msg.sender == owner);\r\n        require((_newFee >= 0) && (_newFee <= 100));\r\n        feePercent = _newFee * 100;\r\n    }\r\n\r\n    function changeOwner(address _recipient) public {\r\n        require(msg.sender == owner);\r\n        owner = _recipient;\r\n    }\r\n\r\n    function changeTrancheAdmin(address _trancheAdmin) public {\r\n        require((msg.sender == owner) || (msg.sender == trancheAdmin));\r\n        trancheAdmin = _trancheAdmin;\r\n    }\r\n\r\n    function toggleReceiveEth() public {\r\n        require(msg.sender == owner);\r\n        if(receiveEth == true) {\r\n            receiveEth = false;\r\n        }\r\n        else receiveEth = true;\r\n    }\r\n\r\n    function otcPurchase(uint256 _tokens, address _recipient) public {\r\n        require(msg.sender == owner);\r\n        balances[_recipient] = add(balances[_recipient], _tokens);\r\n        circulatingSupply = add(circulatingSupply, _tokens);\r\n        Transfer(this, _recipient, _tokens);\r\n    }\r\n\r\n    function otcPurchaseAndEscrow(uint256 _tokens, address _recipient) public {\r\n        require(msg.sender == owner);\r\n        balances[_recipient] = add(balances[_recipient], _tokens);\r\n        trancheOneBalances[msg.sender] = add(trancheOneBalances[msg.sender], _tokens);\r\n        circulatingSupply = add(circulatingSupply, _tokens);\r\n        Transfer(this, _recipient, _tokens);\r\n    }\r\n\r\n    function safeWithdrawal(address _receiver, uint256 _value) public {\r\n        require(msg.sender == owner);\r\n        require(_value <= this.balance);\r\n        _receiver.transfer(_value);\r\n    }\r\n\r\n    function addTrancheRateAndTokens(uint256 _tokens, uint256 _rate) public {\r\n        require(((msg.sender == owner) || (msg.sender == trancheAdmin)) && (addTranches == true));\r\n        require(add(_tokens, circulatingSupply) <= totalSupply);\r\n        maxTranche++;\r\n        trancheTokens[maxTranche] = _tokens;\r\n        trancheRate[maxTranche] = _rate;\r\n    }\r\n\r\n    // enables adjustment based on ETH/EUR variation\r\n    function updateTrancheRate(uint256 _level, uint256 _rate) {\r\n        require(((msg.sender == owner) || (msg.sender == trancheAdmin)) && trancheRate[_level] > 0);\r\n        trancheRate[_level] = _rate;\r\n    }\r\n\r\n    // when all tranches have been added to the contract trigger this to make adding more impossible\r\n    function closeTrancheAddition() public {\r\n        require(msg.sender == owner);\r\n        addTranches = false;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    // ERC20 compliance\r\n    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool success) {\r\n        require(balances[_from] >= _tokens);\r\n        balances[_from] = sub(balances[_from],_tokens);\r\n        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender],_tokens);\r\n        balances[_to] = add(balances[_to],_tokens);\r\n        Transfer(_from, _to, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _tokens) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _tokens;\r\n        Approval(msg.sender, _spender, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _tokenOwner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_tokenOwner][_spender];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"trancheLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tranche\",\"type\":\"uint256\"}],\"name\":\"balanceInSpecificTranche\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"addTrancheRateAndTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tranche\",\"type\":\"uint256\"}],\"name\":\"rateOfSpecificTranche\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiveEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trancheRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trancheOneBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateTrancheRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"trancheOneBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleReceiveEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trancheOneSaleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInTranche\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeTrancheAddition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"updateFeeAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"otcPurchaseAndEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payFeesToggle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"otcPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trancheAdmin\",\"type\":\"address\"}],\"name\":\"changeTrancheAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trancheTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fees\",\"type\":\"address\"}],\"name\":\"changeFeesAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"UTU","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2001733ae11d480752a110192f2e7d2e90b72a5670b597a56e09a0d23eb4ea6c"}]}