{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n  \r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    \r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    \r\n    return c;\r\n  }\r\n  \r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    \r\n    return c;\r\n  }\r\n  \r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n    \r\n    return c;\r\n  }\r\n  \r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    \r\n    return c;\r\n  }\r\n  \r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract BMRoll {\r\n  using SafeMath for uint256;\r\n  /*\r\n  * checks player profit, bet size and player number is within range\r\n  */\r\n  modifier betIsValid(uint _betSize, uint _playerNumber) {\r\n    require(_betSize >= minBet && _playerNumber >= minNumber && _playerNumber <= maxNumber && (((((_betSize * (100-(_playerNumber.sub(1)))) / (_playerNumber.sub(1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize <= maxProfit));\r\n    _;\r\n  }\r\n  \r\n  /*\r\n  * checks game is currently active\r\n  */\r\n  modifier gameIsActive {\r\n    require(gamePaused == false);\r\n    _;\r\n  }\r\n  \r\n  /*\r\n  * checks payouts are currently active\r\n  */\r\n  modifier payoutsAreActive {\r\n    require(payoutsPaused == false);\r\n    _;\r\n  }\r\n  /*\r\n  * checks only owner address is calling\r\n  */\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  /*\r\n  * checks only treasury address is calling\r\n  */\r\n  modifier onlyTreasury {\r\n    require (msg.sender == treasury);\r\n    _;\r\n  }\r\n  \r\n  /*\r\n  * game vars\r\n  */\r\n  uint constant public maxProfitDivisor = 1000000;\r\n  uint constant public houseEdgeDivisor = 1000;\r\n  uint constant public maxNumber = 99;\r\n  uint constant public minNumber = 2;\r\n  bool public gamePaused;\r\n  address public owner;\r\n  address public server;\r\n  bool public payoutsPaused;\r\n  address public treasury;\r\n  uint public contractBalance;\r\n  uint public houseEdge;\r\n  uint public maxProfit;\r\n  uint public maxProfitAsPercentOfHouse;\r\n  uint public minBet;\r\n  \r\n  uint public totalBets = 0;\r\n  uint public totalSunWon = 0;\r\n  uint public totalSunWagered = 0;\r\n  \r\n  address[100] lastUser;\r\n  \r\n  /*\r\n  * player vars\r\n  */\r\n  mapping (uint => address) playerAddress;\r\n  mapping (uint => address) playerTempAddress;\r\n  mapping (uint => uint) playerBetValue;\r\n  mapping (uint => uint) playerTempBetValue;\r\n  mapping (uint => uint) playerDieResult;\r\n  mapping (uint => uint) playerNumber;\r\n  mapping (address => uint) playerPendingWithdrawals;\r\n  mapping (uint => uint) playerProfit;\r\n  mapping (uint => uint) playerTempReward;\r\n  \r\n  /*\r\n  * events\r\n  */\r\n  /* output to web3 UI on bet result*/\r\n  /* Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send*/\r\n  event LogResult(uint indexed BetID, address indexed PlayerAddress, uint PlayerNumber, uint DiceResult, uint ProfitValue, uint BetValue, int Status);\r\n  /* log owner transfers */\r\n  event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\r\n  \r\n  /*\r\n  * init\r\n  */\r\n  constructor() public {\r\n    \r\n    owner = msg.sender;\r\n    treasury = msg.sender;\r\n    /* init 980 = 98% (2% houseEdge)*/\r\n    ownerSetHouseEdge(980);\r\n    /* init 50,000 = 5% */\r\n    ownerSetMaxProfitAsPercentOfHouse(50000);\r\n    /* init min bet (0.1 eth) */\r\n    ownerSetMinBet(100000000000000000);   \r\n  }\r\n  \r\n  /*\r\n  * public function\r\n  * player submit bet\r\n  * only if game is active & bet is valid can rollDice\r\n  */\r\n  function playerRollDice(uint rollUnder) public\r\n  payable\r\n  gameIsActive\r\n  betIsValid(msg.value, rollUnder)\r\n  {\r\n    /* total number of bets */\r\n    \r\n    lastUser[totalBets % 100] = msg.sender;\r\n    totalBets += 1;\r\n    \r\n    /* map player lucky number to totalBets */\r\n    playerNumber[totalBets] = rollUnder;\r\n    /* map value of wager to totalBets */\r\n    playerBetValue[totalBets] = msg.value;\r\n    /* map player address to totalBets */\r\n    playerAddress[totalBets] = msg.sender;\r\n    /* safely map player profit to totalBets */\r\n    playerProfit[totalBets] = ((((msg.value * (100-(rollUnder.sub(1)))) / (rollUnder.sub(1))+msg.value))*houseEdge/houseEdgeDivisor)-msg.value;\r\n    \r\n    //rand result\r\n    uint256 random1 = uint256(blockhash(block.number-1));\r\n    uint256 random2 = uint256(lastUser[random1 % 100]);\r\n    uint256 random3 = uint256(block.coinbase) + random2;\r\n    uint256 result = uint256(keccak256(abi.encodePacked(random1 + random2 + random3 + now + totalBets))) % 100 + 1; // this is an efficient way to get the uint out in the [0, maxRange] range;\r\n    \r\n    /* map random result to player */\r\n    playerDieResult[totalBets] = result;\r\n    /* get the playerAddress for this query id */\r\n    playerTempAddress[totalBets] = playerAddress[totalBets];\r\n    /* delete playerAddress for this query id */\r\n    delete playerAddress[totalBets];\r\n    \r\n    /* map the playerProfit for this query id */\r\n    playerTempReward[totalBets] = playerProfit[totalBets];\r\n    /* set playerProfit for this query id to 0 */\r\n    playerProfit[totalBets] = 0;\r\n    \r\n    /* map the playerBetValue for this query id */\r\n    playerTempBetValue[totalBets] = playerBetValue[totalBets];\r\n    /* set playerBetValue for this query id to 0 */\r\n    playerBetValue[totalBets] = 0;\r\n    \r\n    /* total wagered */\r\n    totalSunWagered += playerTempBetValue[totalBets];\r\n    \r\n    /*\r\n    * pay winner\r\n    * update contract balance to calculate new max bet\r\n    * send reward\r\n    * if send of reward fails save value to playerPendingWithdrawals\r\n    */\r\n    if(playerDieResult[totalBets] < playerNumber[totalBets]){\r\n      \r\n      /* safely reduce contract balance by player profit */\r\n      contractBalance = contractBalance.sub(playerTempReward[totalBets]);\r\n      \r\n      /* update total sun won */\r\n      totalSunWon = totalSunWon.add(playerTempReward[totalBets]);\r\n      \r\n      /* safely calculate payout via profit plus original wager */\r\n      playerTempReward[totalBets] = playerTempReward[totalBets].add(playerTempBetValue[totalBets]);\r\n      \r\n      emit LogResult(totalBets, playerTempAddress[totalBets], playerNumber[totalBets], playerDieResult[totalBets], playerTempReward[totalBets], playerTempBetValue[totalBets],1);\r\n      \r\n      /* update maximum profit */\r\n      setMaxProfit();\r\n      \r\n      /*\r\n      * send win - external call to an untrusted contract\r\n      * if send fails map reward value to playerPendingWithdrawals[address]\r\n      * for withdrawal later via playerWithdrawPendingTransactions\r\n      */\r\n      if(!playerTempAddress[totalBets].send(playerTempReward[totalBets])){\r\n        emit LogResult(totalBets, playerTempAddress[totalBets], playerNumber[totalBets], playerDieResult[totalBets], playerTempReward[totalBets], playerTempBetValue[totalBets], 2);\r\n        /* if send failed let player withdraw via playerWithdrawPendingTransactions */\r\n        playerPendingWithdrawals[playerTempAddress[totalBets]] = playerPendingWithdrawals[playerTempAddress[totalBets]].add(playerTempReward[totalBets]);\r\n      }\r\n      \r\n      return;\r\n      \r\n    }\r\n    \r\n    /*\r\n    * no win\r\n    * send 1 sun to a losing bet\r\n    * update contract balance to calculate new max bet\r\n    */\r\n    if(playerDieResult[totalBets] >= playerNumber[totalBets]){\r\n      \r\n      emit LogResult(totalBets, playerTempAddress[totalBets], playerNumber[totalBets], playerDieResult[totalBets], 0, playerTempBetValue[totalBets], 0);\r\n      \r\n      /*\r\n      * safe adjust contractBalance\r\n      * setMaxProfit\r\n      * send 1 sun to losing bet\r\n      */\r\n      contractBalance = contractBalance.add((playerTempBetValue[totalBets]-1));\r\n      \r\n      /* update maximum profit */\r\n      setMaxProfit();\r\n      \r\n      /*\r\n      * send 1 sun - external call to an untrusted contract\r\n      */\r\n      if(!playerTempAddress[totalBets].send(1)){\r\n        /* if send failed let player withdraw via playerWithdrawPendingTransactions */\r\n        playerPendingWithdrawals[playerTempAddress[totalBets]] = playerPendingWithdrawals[playerTempAddress[totalBets]].add(1);\r\n      }\r\n      \r\n      return;\r\n      \r\n    }\r\n  }\r\n  \r\n  /*\r\n  * public function\r\n  * in case of a failed refund or win send\r\n  */\r\n  function playerWithdrawPendingTransactions() public\r\n  payoutsAreActive\r\n  returns (bool)\r\n  {\r\n    uint withdrawAmount = playerPendingWithdrawals[msg.sender];\r\n    playerPendingWithdrawals[msg.sender] = 0;\r\n    /* external call to untrusted contract */\r\n    if (msg.sender.call.value(withdrawAmount)()) {\r\n      return true;\r\n      } else {\r\n        /* if send failed revert playerPendingWithdrawals[msg.sender] = 0; */\r\n        /* player can try to withdraw again later */\r\n        playerPendingWithdrawals[msg.sender] = withdrawAmount;\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    /* check for pending withdrawals */\r\n    function playerGetPendingTxByAddress(address addressToCheck) public view returns (uint) {\r\n      return playerPendingWithdrawals[addressToCheck];\r\n    }\r\n    \r\n    /* get game status */\r\n    function getGameStatus() public view returns(uint, uint, uint, uint, uint, uint) {\r\n      return (minBet, minNumber, maxNumber, houseEdge, houseEdgeDivisor, maxProfit);\r\n    }\r\n    \r\n    /*\r\n    * internal function\r\n    * sets max profit\r\n    */\r\n    function setMaxProfit() internal {\r\n      maxProfit = (contractBalance*maxProfitAsPercentOfHouse)/maxProfitDivisor;\r\n    }\r\n    \r\n    /*\r\n    * owner/treasury address only functions\r\n    */\r\n    function ()\r\n        payable public\r\n        onlyTreasury\r\n    {\r\n      /* safely update contract balance */\r\n      contractBalance = contractBalance.add(msg.value);\r\n      /* update the maximum profit */\r\n      setMaxProfit();\r\n    }\r\n    \r\n    /* only owner adjust contract balance variable (only used for max profit calc) */\r\n    function ownerUpdateContractBalance(uint newContractBalanceInSun) public\r\n    onlyOwner\r\n    {\r\n      contractBalance = newContractBalanceInSun;\r\n    }\r\n    \r\n    /* only owner address can set houseEdge */\r\n    function ownerSetHouseEdge(uint newHouseEdge) public\r\n    onlyOwner\r\n    {\r\n      houseEdge = newHouseEdge;\r\n    }\r\n    \r\n    /* only owner address can set maxProfitAsPercentOfHouse */\r\n    function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\r\n    onlyOwner\r\n    {\r\n      /* restrict each bet to a maximum profit of 5% contractBalance */\r\n      require(newMaxProfitAsPercent <= 50000);\r\n      maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\r\n      setMaxProfit();\r\n    }\r\n    \r\n    /* only owner address can set minBet */\r\n    function ownerSetMinBet(uint newMinimumBet) public\r\n    onlyOwner\r\n    {\r\n      minBet = newMinimumBet;\r\n    }\r\n    \r\n    /* only owner address can transfer eth */\r\n    function ownerTransferEth(address sendTo, uint amount) public\r\n    onlyOwner\r\n    {\r\n      /* safely update contract balance when sending out funds*/\r\n      contractBalance = contractBalance.sub(amount);\r\n      /* update max profit */\r\n      setMaxProfit();\r\n      if(!sendTo.send(amount)) revert();\r\n      emit LogOwnerTransfer(sendTo, amount);\r\n    }\r\n    \r\n    \r\n    /* only owner address can set emergency pause #1 */\r\n    function ownerPauseGame(bool newStatus) public\r\n    onlyOwner\r\n    {\r\n      gamePaused = newStatus;\r\n    }\r\n    \r\n    /* only owner address can set emergency pause #2 */\r\n    function ownerPausePayouts(bool newPayoutStatus) public\r\n    onlyOwner\r\n    {\r\n      payoutsPaused = newPayoutStatus;\r\n    }\r\n    \r\n    /* only owner address can set treasury address */\r\n    function ownerSetTreasury(address newTreasury) public\r\n    onlyOwner\r\n    {\r\n      treasury = newTreasury;\r\n    }\r\n    \r\n    /* only owner address can set owner address */\r\n    function ownerChangeOwner(address newOwner) public\r\n    onlyOwner\r\n    {\r\n      require(newOwner != 0);\r\n      owner = newOwner;\r\n    }\r\n    \r\n    /* only owner address can suicide - emergency */\r\n    function ownerkill() public\r\n    onlyOwner\r\n    {\r\n      selfdestruct(owner);\r\n    }\r\n    \r\n    \r\n  }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitAsPercentOfHouse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseEdge\",\"type\":\"uint256\"}],\"name\":\"ownerSetHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutsPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"ownerSetTreasury\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSunWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addressToCheck\",\"type\":\"address\"}],\"name\":\"playerGetPendingTxByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractBalanceInSun\",\"type\":\"uint256\"}],\"name\":\"ownerUpdateContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPayoutStatus\",\"type\":\"bool\"}],\"name\":\"ownerPausePayouts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxProfitAsPercent\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfitAsPercentOfHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"playerWithdrawPendingTransactions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerkill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSunWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rollUnder\",\"type\":\"uint256\"}],\"name\":\"playerRollDice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ownerTransferEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"server\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"BetID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"PlayerNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"DiceResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ProfitValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"BetValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Status\",\"type\":\"int256\"}],\"name\":\"LogResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"SentToAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"AmountTransferred\",\"type\":\"uint256\"}],\"name\":\"LogOwnerTransfer\",\"type\":\"event\"}]","ContractName":"BMRoll","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8d426f256e95dcb26555d32881842c0374e8a97dcdb87f72a000fb3df96140be"}]}