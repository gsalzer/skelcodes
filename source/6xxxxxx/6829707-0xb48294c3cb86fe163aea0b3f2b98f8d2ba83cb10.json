{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\ncontract o2 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public DEPOSIT_MINIMUM_AMOUNT = 100 wei;\r\n    uint256 constant public MAXIMUM_DEPOSITS_PER_USER = 50;\r\n\r\n    uint256 constant public MINIMUM_DAILY_PERCENT = 40;\r\n    uint256 constant public REFERRAL_PERCENT = 50;\r\n    uint256 constant public MARKETING_PERCENT = 100;\r\n    uint256 constant public BonusContract_PERCENT = 50;\r\n    uint256 constant public MAXIMUM_RETURN_PERCENT = 1500;\r\n    uint256 constant public PERCENTS_DIVIDER = 1000;\r\n\r\n    uint256 constant public BALANCE_STEP = 300 ether;\r\n    uint256 constant public TIME_STEP = 1 days;\r\n    uint256 constant public STEP_MULTIPLIER = 10;\r\n\r\n    address constant public MARKETING_ADDRESS = 0xc9f78aa0A1BD3EAB43F30F0D960e423DE7784C48;\r\n    address constant public BonusContract_ADDRESS = 0xfE6ea4625b57B6503677a1083ad9920BC9021B18;\r\n   \r\n    uint256 public usersCount = 0;\r\n    uint256 public depositsCount = 0;\r\n    uint256 public totalDeposited = 0;\r\n    uint256 public totalWithdrawn = 0;\r\n    event Invest( address indexed investor, uint256 amount);\r\n    event Withdraw( address indexed investor, uint256 amount);\r\n   \r\n    struct User {\r\n        uint256 deposited;\r\n        uint256 withdrawn;\r\n        uint256 timestamp;\r\n        uint256 depositsCount;\r\n        uint256[] deposits;\r\n    }\r\n\r\n    struct Deposit {\r\n        uint256 amount;\r\n        uint256 payed;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping (address => User) public users;\r\n    mapping (uint256 => Deposit) public deposits;\r\n\r\n    function() public payable {\r\n        if (msg.value >= DEPOSIT_MINIMUM_AMOUNT) {\r\n            makeDeposit();\r\n        } else {\r\n            payDividends();\r\n        }\r\n    }\r\n\r\n    function createUser() private {\r\n        users[msg.sender] = User({\r\n            deposited : 0,\r\n            withdrawn : 0,\r\n            timestamp : now,\r\n            depositsCount : 0,\r\n            deposits : new uint256[](0)\r\n        });\r\n\r\n        usersCount++;\r\n    }\r\n\r\n    function makeDeposit() private {\r\n        if (users[msg.sender].deposited == 0) {\r\n            createUser();\r\n        }\r\n\r\n        User storage user = users[msg.sender];\r\n\r\n        require(user.depositsCount < MAXIMUM_DEPOSITS_PER_USER);\r\n\r\n        Deposit memory deposit = Deposit({\r\n            amount : msg.value,\r\n            payed : 0,\r\n            timestamp : now\r\n        });\r\n\r\n        deposits[depositsCount] = deposit;\r\n        user.deposits.push(depositsCount);\r\n\r\n        user.deposited = user.deposited.add(msg.value);\r\n        totalDeposited = totalDeposited.add(msg.value);\r\n\r\n        user.depositsCount++;\r\n        depositsCount++;\r\n\r\n        uint256 marketingAmount = msg.value.mul(MARKETING_PERCENT).div(PERCENTS_DIVIDER);\r\n        MARKETING_ADDRESS.transfer(marketingAmount);\r\n       \r\n        uint256 BonusAmount = msg.value.mul(BonusContract_PERCENT).div(PERCENTS_DIVIDER);\r\n        BonusContract_ADDRESS.transfer(BonusAmount);\r\n\r\n        address refAddress = bytesToAddress(msg.data);\r\n        if (refAddress != address(0) && refAddress != msg.sender) {\r\n            uint256 refAmount = msg.value.mul(REFERRAL_PERCENT).div(PERCENTS_DIVIDER);\r\n            refAddress.transfer(refAmount);\r\n        }\r\n    }\r\n\r\n    function payDividends() private {\r\n        User storage user = users[msg.sender];\r\n\r\n        uint256 userMaximumReturn = user.deposited.mul(MAXIMUM_RETURN_PERCENT).div(PERCENTS_DIVIDER);\r\n\r\n        require(user.deposited > 0 && user.withdrawn < userMaximumReturn);\r\n\r\n        uint256 userDividends = 0;\r\n\r\n        for (uint256 i = 0; i < user.depositsCount; i++) {\r\n            if (deposits[user.deposits[i]].payed < deposits[user.deposits[i]].amount.mul(MAXIMUM_RETURN_PERCENT).div(PERCENTS_DIVIDER)) {\r\n                uint256 depositId = user.deposits[i];\r\n\r\n                Deposit storage deposit = deposits[depositId];\r\n\r\n                uint256 depositDividends = getDepositDividends(depositId, msg.sender);\r\n                userDividends = userDividends.add(depositDividends);\r\n\r\n                deposits[depositId].payed = deposit.payed.add(depositDividends);\r\n                deposits[depositId].timestamp = now;\r\n            }\r\n        }\r\n\r\n        msg.sender.transfer(userDividends.add(msg.value));\r\n\r\n        users[msg.sender].timestamp = now;\r\n\r\n        users[msg.sender].withdrawn = user.withdrawn.add(userDividends);\r\n        totalWithdrawn = totalWithdrawn.add(userDividends);\r\n    }\r\n\r\n    function getDepositDividends(uint256 depositId, address userAddress) private view returns (uint256) {\r\n        uint256 userActualPercent = getUserActualPercent(userAddress);\r\n\r\n        Deposit storage deposit = deposits[depositId];\r\n\r\n        uint256 timeDiff = now.sub(deposit.timestamp);\r\n        uint256 depositDividends = deposit.amount.mul(userActualPercent).div(PERCENTS_DIVIDER).mul(timeDiff).div(TIME_STEP);\r\n\r\n        uint256 depositMaximumReturn = deposit.amount.mul(MAXIMUM_RETURN_PERCENT).div(PERCENTS_DIVIDER);\r\n\r\n        if (depositDividends.add(deposit.payed) > depositMaximumReturn) {\r\n            depositDividends = depositMaximumReturn.sub(deposit.payed);\r\n        }\r\n\r\n        return depositDividends;\r\n    }\r\n\r\n    function getContractActualPercent() public view returns (uint256) {\r\n        uint256 contractBalance = address(this).balance;\r\n        uint256 balanceAddPercent = contractBalance.div(BALANCE_STEP).mul(STEP_MULTIPLIER);\r\n\r\n        return MINIMUM_DAILY_PERCENT.add(balanceAddPercent);\r\n    }\r\n\r\n    function getUserActualPercent(address userAddress) public view returns (uint256) {\r\n        uint256 contractActualPercent = getContractActualPercent();\r\n\r\n        User storage user = users[userAddress];\r\n\r\n        uint256 userMaximumReturn = user.deposited.mul(MAXIMUM_RETURN_PERCENT).div(PERCENTS_DIVIDER);\r\n\r\n        if (user.deposited > 0 && user.withdrawn < userMaximumReturn) {\r\n            uint256 timeDiff = now.sub(user.timestamp);\r\n            uint256 userAddPercent = timeDiff.div(TIME_STEP).mul(STEP_MULTIPLIER);\r\n        }\r\n\r\n        return contractActualPercent.add(userAddPercent);\r\n    }\r\n\r\n    function getUserDividends(address userAddress) public view returns (uint256) {\r\n        User storage user = users[userAddress];\r\n\r\n        uint256 userDividends = 0;\r\n\r\n        for (uint256 i = 0; i < user.depositsCount; i++) {\r\n            if (deposits[user.deposits[i]].payed < deposits[user.deposits[i]].amount.mul(MAXIMUM_RETURN_PERCENT).div(PERCENTS_DIVIDER)) {\r\n                userDividends = userDividends.add(getDepositDividends(user.deposits[i], userAddress));\r\n            }\r\n        }\r\n\r\n        return userDividends;\r\n    }\r\n\r\n    function getUserDeposits(address userAddress) public view returns (uint256[]){\r\n        return users[userAddress].deposits;\r\n    }\r\n\r\n    function bytesToAddress(bytes data) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(data, 20))\r\n        }\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\n library SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_DAILY_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BALANCE_STEP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEPOSIT_MINIMUM_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRAL_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BonusContract_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_DEPOSITS_PER_USER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STEP_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractActualPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_RETURN_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"deposited\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"depositsCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"payed\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserActualPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MARKETING_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MARKETING_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BonusContract_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"o2","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://750dcf49f628b75844064a7a25e7b34c292cd7e4d124fa97780930a5a746b407"}]}