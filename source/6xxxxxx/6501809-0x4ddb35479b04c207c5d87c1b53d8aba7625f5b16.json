{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract ERC20Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) public view  returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns  (bool );\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\ncontract HHLCTOKEN is ERC20Token {\r\n    using SafeMath for uint256;\r\n\r\n    address public manager;\r\n    modifier onlyManager() {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n    \r\n    mapping(address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256 )) allowed;\r\n\r\n    uint256 exchangeTimestamp;\r\n\r\n    uint256[] public privateTimes;\r\n    uint256[] public airdropTimes;\r\n\r\n    uint256[] public privateRates=[50,60,70,80,90,100];\r\n    uint256[] public airdropRates=[5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100];\r\n\r\n    struct LockRuler {\r\n        uint256 utype;\r\n        uint256 money;\r\n    }\r\n\r\n    mapping (address => LockRuler[]) public  mapLockRulers;\r\n\r\n    function transfer( address _to, uint256 _value )\r\n    public \r\n    returns (bool success)\r\n    {\r\n\r\n        if( mapLockRulers[msg.sender].length > 0 ){\r\n\r\n            require (exchangeTimestamp > 0);\r\n\r\n            uint256 _lockMoney = 0;\r\n            uint256 _preMoney = 0;\r\n            uint256 _idx = 0;\r\n            uint256 _idx2 = 0;\r\n            uint256 _rate = 0;\r\n            uint256 _hundred = 100;\r\n            uint256 _var1 = 0;\r\n            uint256 _var2 = 0;\r\n            uint256 _var3 = 0;\r\n\r\n            for( _idx = 0; _idx < mapLockRulers[msg.sender].length; _idx++ ){\r\n\r\n\r\n                if( mapLockRulers[msg.sender][_idx].utype == 0){\r\n\r\n                    for( _idx2 = 0; _idx2 < privateTimes.length -1; _idx2++ ){\r\n\r\n                        if(privateTimes[_idx2]<=block.timestamp && block.timestamp < privateTimes[_idx2+1]){\r\n                            _rate = privateRates[_idx2];\r\n\r\n                            _var1 = _hundred.sub(_rate);\r\n                            _var2 = _var1.mul(mapLockRulers[msg.sender][_idx].money);\r\n                            _var3 = _var2.div(_hundred);\r\n\r\n                            _lockMoney = _lockMoney.add(_var3 );\r\n                            break;\r\n\r\n                        }else if( block.timestamp > privateTimes[privateTimes.length -1] ){\r\n\r\n                            _lockMoney = _lockMoney.add(0);\r\n                            break;\r\n\r\n                        }else if(block.timestamp<privateTimes[0]){\r\n\r\n                            _lockMoney = _lockMoney.add(mapLockRulers[msg.sender][_idx].money);\r\n                            break;\r\n\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                if(mapLockRulers[msg.sender][_idx].utype == 1){\r\n\r\n                    for( _idx2 = 0; _idx2 < airdropTimes.length -1; _idx2++ ){\r\n\r\n                        if(airdropTimes[_idx2] <= block.timestamp && block.timestamp <= airdropTimes[_idx2+1]){\r\n                            _rate = airdropRates[_idx2];\r\n\r\n                            _var1 = _hundred.sub(_rate);\r\n                            _var2 = _var1.mul(mapLockRulers[msg.sender][_idx].money);\r\n                            _var3 = _var2.div(_hundred);\r\n\r\n                            _lockMoney = _lockMoney.add(_var3 );\r\n                            break;\r\n\r\n                        }else if( block.timestamp > airdropTimes[airdropTimes.length -1] ){\r\n\r\n                            _lockMoney = _lockMoney.add(0);\r\n                            break;\r\n\r\n                        }else if(block.timestamp < airdropTimes[0]){\r\n\r\n                            _lockMoney = _lockMoney.add(mapLockRulers[msg.sender][_idx].money);\r\n                            break;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            _preMoney = _value.add(_lockMoney);\r\n\r\n            require ( _preMoney <= balances[msg.sender] );\r\n            return _transfer(_to, _value);\r\n\r\n        }else{\r\n\r\n            return _transfer(_to, _value);\r\n\r\n        }\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _value)\r\n    internal returns (bool success){\r\n\r\n        require(_to != 0x0);\r\n        require(_value > 0);\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        uint256 previousBalances = balances[msg.sender] + balances[_to];\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        assert(balances[msg.sender] + balances[_to] == previousBalances);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n    public\r\n    view\r\n    returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    function allowance(address _owner, address _spender)\r\n    public\r\n    view\r\n    returns (uint256){\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    event NewToken(uint256 indexed _decimals, uint256  _totalSupply, string  _tokenName, string  _tokenSymbol);\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n\r\n\r\n    constructor(\r\n        uint256 _initialAmount,\r\n        uint256 _decimals,\r\n        string _tokenName,\r\n        string _tokenSymbol\r\n    )public{\r\n\r\n        require (_decimals > 0);\r\n        require (_initialAmount > 0);\r\n        require (bytes(_tokenName).length>0);\r\n        require (bytes(_tokenSymbol).length>0);\r\n\r\n        manager = msg.sender;\r\n\r\n        decimals = _decimals;\r\n        totalSupply = _initialAmount * (10 ** uint256(decimals));\r\n        balances[manager] = totalSupply;\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n\r\n\r\n        exchangeTimestamp = 0;\r\n\r\n\r\n        emit NewToken(_decimals, totalSupply, name, symbol);\r\n    }\r\n\r\n\r\n    function addAirdropUsers( address[] _accounts, uint256[] _moneys )\r\n    onlyManager\r\n    public{\r\n\r\n        require (_accounts.length > 0);\r\n        require (_accounts.length == _moneys.length);\r\n\r\n        uint256 _totalMoney = 0;\r\n        uint256 _idx = 0;\r\n\r\n        for(_idx = 0; _idx < _moneys.length; _idx++){\r\n            _totalMoney += _moneys[_idx];\r\n        }\r\n\r\n        require ( _totalMoney <= balances[manager] );\r\n\r\n\r\n        for( _idx = 0; _idx < _accounts.length; _idx++ ){\r\n\r\n            LockRuler memory _lockRuler = LockRuler({\r\n                money:_moneys[_idx],\r\n                utype:1\r\n            });\r\n\r\n            mapLockRulers[_accounts[_idx]].push(_lockRuler);\r\n            _transfer(_accounts[_idx], _moneys[_idx]);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function addPrivateUsers( address[] _accounts, uint256[] _moneys )\r\n    onlyManager\r\n    public{\r\n\r\n        require (_accounts.length > 0);\r\n        require (_accounts.length == _moneys.length);\r\n\r\n        uint256 _totalMoney = 0;\r\n        uint256 _idx = 0;\r\n\r\n        for(_idx = 0; _idx < _moneys.length; _idx++){\r\n            _totalMoney = _totalMoney.add(_moneys[_idx]) ;\r\n        }\r\n\r\n        require ( _totalMoney <= balances[manager] );\r\n\r\n\r\n        for( _idx = 0; _idx < _accounts.length; _idx++ ){\r\n\r\n            LockRuler memory _lockRuler = LockRuler({\r\n                money:_moneys[_idx],\r\n                utype:0\r\n            });\r\n\r\n            mapLockRulers[_accounts[_idx]].push(_lockRuler);\r\n            _transfer(_accounts[_idx], _moneys[_idx]);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function addExchangeTime( uint256 _time )\r\n    onlyManager\r\n    public{\r\n        require (_time > 0);\r\n        require (privateTimes.length == 0);\r\n        require (airdropTimes.length == 0);\r\n\r\n\r\n        exchangeTimestamp = _time;\r\n\r\n        uint256 _idx = 0;\r\n        for(_idx = 0; _idx < privateRates.length; _idx++){\r\n            privateTimes.push( _getDate(_time, _idx) );\r\n        }\r\n\r\n\r\n\r\n        for(_idx = 0; _idx < airdropRates.length; _idx++){\r\n            airdropTimes.push( _getDate(_time, _idx) );\r\n        }\r\n\r\n    }\r\n\r\n    function _getDate(uint256 start, uint256 daysAfter)\r\n    internal\r\n    pure\r\n    returns (uint256){\r\n        daysAfter = daysAfter.mul(60);\r\n        return start + daysAfter * 1 days;\r\n    }  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"privateRates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"addExchangeTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accounts\",\"type\":\"address[]\"},{\"name\":\"_moneys\",\"type\":\"uint256[]\"}],\"name\":\"addAirdropUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accounts\",\"type\":\"address[]\"},{\"name\":\"_moneys\",\"type\":\"uint256[]\"}],\"name\":\"addPrivateUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"privateTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdropRates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapLockRulers\",\"outputs\":[{\"name\":\"utype\",\"type\":\"uint256\"},{\"name\":\"money\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdropTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_decimals\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"name\":\"NewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"HHLCTOKEN","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000002540be4000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000a6875616c69746f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000448484c4300000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://9926c217f8908294f97a6afce711c2fa9d33992946d44f86bc5a32bae5afc9dc"}]}