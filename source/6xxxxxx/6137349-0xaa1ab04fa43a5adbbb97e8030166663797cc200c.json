{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract SigningLogicInterface {\r\n  function recoverSigner(bytes32 _hash, bytes _sig) external pure returns (address);\r\n  function generateRequestAttestationSchemaHash(\r\n    address _subject,\r\n    address _attester,\r\n    address _requester,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _nonce\r\n    ) external view returns (bytes32);\r\n  function generateAttestForDelegationSchemaHash(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _paymentNonce,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _requestNonce\r\n    ) external view returns (bytes32);\r\n  function generateContestForDelegationSchemaHash(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _paymentNonce\r\n  ) external view returns (bytes32);\r\n  function generateStakeForDelegationSchemaHash(\r\n    address _subject,\r\n    uint256 _value,\r\n    bytes32 _paymentNonce,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _requestNonce,\r\n    uint256 _stakeDuration\r\n    ) external view returns (bytes32);\r\n  function generateRevokeStakeForDelegationSchemaHash(\r\n    uint256 _subjectId,\r\n    uint256 _attestationId\r\n    ) external view returns (bytes32);\r\n  function generateAddAddressSchemaHash(\r\n    address _senderAddress,\r\n    bytes32 _nonce\r\n    ) external view returns (bytes32);\r\n  function generateVoteForDelegationSchemaHash(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    address _poll\r\n    ) external view returns (bytes32);\r\n  function generateReleaseTokensSchemaHash(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _uuid\r\n    ) external view returns (bytes32);\r\n  function generateLockupTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n    ) external view returns (bytes32);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ninterface AccountRegistryInterface {\r\n  function accountIdForAddress(address _address) public view returns (uint256);\r\n  function addressBelongsToAccount(address _address) public view returns (bool);\r\n  function createNewAccount(address _newUser) external;\r\n  function addAddressToAccount(\r\n    address _newAddress,\r\n    address _sender\r\n    ) external;\r\n  function removeAddressFromAccount(address _addressToRemove) external;\r\n}\r\n/**\r\n * @title Bloom account registry\r\n * @notice Account Registry Logic provides a public interface for Bloom and users to \r\n * create and control their Bloom Ids.\r\n * Users can associate create and accept invites and associate additional addresses with their BloomId.\r\n * As the Bloom protocol matures, this contract can be upgraded to enable new capabilities\r\n * without needing to migrate the underlying Account Registry storage contract.\r\n *\r\n * In order to invite someone, a user must generate a new public key private key pair\r\n * and sign their own ethereum address. The user provides this signature to the\r\n * `createInvite` function where the public key is recovered and the invite is created.\r\n * The inviter should then share the one-time-use private key out of band with the recipient.\r\n * The recipient accepts the invite by signing their own address and passing that signature\r\n * to the `acceptInvite` function. The contract should recover the same public key, demonstrating\r\n * that the recipient knows the secret and is likely the person intended to receive the invite.\r\n *\r\n * @dev This invite model is supposed to aid usability by not requiring the inviting user to know\r\n *   the Ethereum address of the recipient. If the one-time-use private key is leaked then anyone\r\n *   else can accept the invite. This is an intentional tradeoff of this invite system. A well built\r\n *   dApp should generate the private key on the backend and sign the user's address for them. Likewise,\r\n *   the signing should also happen on the backend (not visible to the user) for signing an address to\r\n *   accept an invite. This reduces the private key exposure so that the dApp can still require traditional\r\n *   checks like verifying an associated email address before finally signing the user's Ethereum address.\r\n *\r\n * @dev The private key generated for this invite system should NEVER be used for an Ethereum address.\r\n *   The private key should be used only for the invite flow and then it should effectively be discarded.\r\n *\r\n * @dev If a user DOES know the address of the person they are inviting then they can still use this\r\n *   invite system. All they have to do then is sign the address of the user being invited and share the\r\n *   signature with them.\r\n */\r\ncontract AccountRegistryLogic is Ownable{\r\n\r\n  SigningLogicInterface public signingLogic;\r\n  AccountRegistryInterface public registry;\r\n  address public registryAdmin;\r\n\r\n  /**\r\n   * @notice The AccountRegistry constructor configures the signing logic implementation\r\n   *  and creates an account for the user who deployed the contract.\r\n   * @dev The owner is also set as the original registryAdmin, who has the privilege to\r\n   *  create accounts outside of the normal invitation flow.\r\n   * @param _signingLogic The address of the deployed SigningLogic contract\r\n   * @param _registry The address of the deployed account registry\r\n   */\r\n  constructor(\r\n    SigningLogicInterface _signingLogic,\r\n    AccountRegistryInterface _registry\r\n    ) public {\r\n    signingLogic = _signingLogic;\r\n    registry = _registry;\r\n    registryAdmin = owner;\r\n  }\r\n\r\n  event AccountCreated(uint256 indexed accountId, address indexed newUser);\r\n  event InviteCreated(address indexed inviter, address indexed inviteAddress);\r\n  event InviteAccepted(address recipient, address indexed inviteAddress);\r\n  event AddressAdded(uint256 indexed accountId, address indexed newAddress);\r\n  event AddressRemoved(uint256 indexed accountId, address indexed oldAddress);\r\n  event RegistryAdminChanged(address oldRegistryAdmin, address newRegistryAdmin);\r\n  event SigningLogicChanged(address oldSigningLogic, address newSigningLogic);\r\n  event AccountRegistryChanged(address oldRegistry, address newRegistry);\r\n\r\n  /**\r\n   * @dev Addresses with Bloom accounts already are not allowed\r\n   */\r\n  modifier onlyNonUser {\r\n    require(!registry.addressBelongsToAccount(msg.sender));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Addresses without Bloom accounts already are not allowed\r\n   */\r\n  modifier onlyUser {\r\n    require(registry.addressBelongsToAccount(msg.sender));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Zero address not allowed\r\n   */\r\n  modifier nonZero(address _address) {\r\n    require(_address != 0);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Restricted to registryAdmin\r\n   */\r\n  modifier onlyRegistryAdmin {\r\n    require(msg.sender == registryAdmin);\r\n    _;\r\n  }\r\n\r\n  // Signatures contain a nonce to make them unique. usedSignatures tracks which signatures\r\n  //  have been used so they can't be replayed\r\n  mapping (bytes32 => bool) public usedSignatures;\r\n\r\n  // Mapping of public keys as Ethereum addresses to invite information\r\n  // NOTE: the address keys here are NOT Ethereum addresses, we just happen\r\n  // to work with the public keys in terms of Ethereum address strings because\r\n  // this is what `ecrecover` produces when working with signed text.\r\n  mapping(address => bool) public pendingInvites;\r\n\r\n  /**\r\n   * @notice Change the implementation of the SigningLogic contract by setting a new address\r\n   * @dev Restricted to AccountRegistry owner and new implementation address cannot be 0x0\r\n   * @param _newSigningLogic Address of new SigningLogic implementation\r\n   */\r\n  function setSigningLogic(SigningLogicInterface _newSigningLogic) public nonZero(_newSigningLogic) onlyOwner {\r\n    address oldSigningLogic = signingLogic;\r\n    signingLogic = _newSigningLogic;\r\n    emit SigningLogicChanged(oldSigningLogic, signingLogic);\r\n  }\r\n\r\n  /**\r\n   * @notice Change the address of the registryAdmin, who has the privilege to create new accounts\r\n   * @dev Restricted to AccountRegistry owner and new admin address cannot be 0x0\r\n   * @param _newRegistryAdmin Address of new registryAdmin\r\n   */\r\n  function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner nonZero(_newRegistryAdmin) {\r\n    address _oldRegistryAdmin = registryAdmin;\r\n    registryAdmin = _newRegistryAdmin;\r\n    emit RegistryAdminChanged(_oldRegistryAdmin, registryAdmin);\r\n  }\r\n\r\n  /**\r\n   * @notice Change the address of AccountRegistry, which enables authorization of subject comments\r\n   * @dev Restricted to owner and new address cannot be 0x0\r\n   * @param _newRegistry Address of new Account Registry contract\r\n   */\r\n  function setAccountRegistry(AccountRegistryInterface _newRegistry) public nonZero(_newRegistry) onlyOwner {\r\n    address oldRegistry = registry;\r\n    registry = _newRegistry;\r\n    emit AccountRegistryChanged(oldRegistry, registry);\r\n  }\r\n\r\n  /**\r\n   * @notice Create an invite using the signing model described in the contract description\r\n   * @dev Recovers public key of invitation key pair using \r\n   * @param _sig Signature of one-time-use keypair generated for invite\r\n   */\r\n  function createInvite(bytes _sig) public onlyUser {\r\n    address inviteAddress = signingLogic.recoverSigner(keccak256(abi.encodePacked(msg.sender)), _sig);\r\n    require(!pendingInvites[inviteAddress]);\r\n    pendingInvites[inviteAddress] = true;\r\n    emit InviteCreated(msg.sender, inviteAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Accept an invite using the signing model described in the contract description\r\n   * @dev Recovers public key of invitation key pair\r\n   * Assumes signed message matches format described in recoverSigner\r\n   * Restricted to addresses that are not already registered by a user\r\n   * Invite is accepted by setting recipient to nonzero address for invite associated with recovered public key\r\n   * and creating an account for the sender\r\n   * @param _sig Signature for `msg.sender` via the same key that issued the initial invite\r\n   */\r\n  function acceptInvite(bytes _sig) public onlyNonUser {\r\n    address inviteAddress = signingLogic.recoverSigner(keccak256(abi.encodePacked(msg.sender)), _sig);\r\n    require(pendingInvites[inviteAddress]);\r\n    pendingInvites[inviteAddress] = false;\r\n    createAccountForUser(msg.sender);\r\n    emit InviteAccepted(msg.sender, inviteAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Create an account instantly without an invitation\r\n   * @dev Restricted to the \"invite admin\" which is managed by the Bloom team\r\n   * @param _newUser Address of the user receiving an account\r\n   */\r\n  function createAccount(address _newUser) public onlyRegistryAdmin {\r\n    createAccountForUser(_newUser);\r\n  }\r\n\r\n  /**\r\n   * @notice Create an account for a user and emit an event\r\n   * @dev Records address as taken so it cannot be used to sign up for another account\r\n   *  accountId is a unique ID across all users generated by calculating the length of the accounts array\r\n   *  addressId is the position in the unordered list of addresses associated with a user account \r\n   *  AccountInfo is a struct containing accountId and addressId so all addresses can be found for a user\r\n   * new Login structs represent user accounts. The first one is pushed onto the array associated with a user's accountID\r\n   * To push a new account onto the same Id, accounts array should be addressed accounts[_accountID - 1].push\r\n   * @param _newUser Address of the new user\r\n   */\r\n  function createAccountForUser(address _newUser) internal nonZero(_newUser) {\r\n    registry.createNewAccount(_newUser);\r\n    uint256 _accountId = registry.accountIdForAddress(_newUser);\r\n    emit AccountCreated(_accountId, _newUser);\r\n  }\r\n\r\n  /**\r\n   * @notice Add an address to an existing id on behalf of a user to pay the gas costs\r\n   * @param _newAddress Address to add to account\r\n   * @param _newAddressSig Signed message from new address confirming ownership by the sender\r\n   * @param _senderSig Signed message from address currently associated with account confirming intention\r\n   * @param _sender User requesting this action\r\n   * @param _nonce uuid used when generating sigs to make them one time use\r\n   */\r\n  function addAddressToAccountFor(\r\n    address _newAddress,\r\n    bytes _newAddressSig,\r\n    bytes _senderSig,\r\n    address _sender,\r\n    bytes32 _nonce\r\n    ) public onlyRegistryAdmin {\r\n    addAddressToAccountForUser(_newAddress, _newAddressSig, _senderSig, _sender, _nonce);\r\n  }\r\n\r\n  /**\r\n   * @notice Add an address to an existing id by a user\r\n   * @dev Wrapper for addAddressTooAccountForUser with msg.sender as sender\r\n   * @param _newAddress Address to add to account\r\n   * @param _newAddressSig Signed message from new address confirming ownership by the sender\r\n   * @param _senderSig Signed message from msg.sender confirming intention by the sender\r\n   * @param _nonce uuid used when generating sigs to make them one time use\r\n   */\r\n  function addAddressToAccount(\r\n    address _newAddress,\r\n    bytes _newAddressSig,\r\n    bytes _senderSig,\r\n    bytes32 _nonce\r\n    ) public onlyUser {\r\n    addAddressToAccountForUser(_newAddress, _newAddressSig, _senderSig, msg.sender, _nonce);\r\n  }\r\n\r\n  /**\r\n   * @notice Add an address to an existing id \r\n   * @dev Checks that new address signed _sig \r\n   * @param _newAddress Address to add to account\r\n   * @param _newAddressSig Signed message from new address confirming ownership by the sender\r\n   * @param _senderSig Signed message from new address confirming ownership by the sender\r\n   * @param _sender User requesting this action\r\n   * @param _nonce uuid used when generating sigs to make them one time use\r\n   */\r\n  function addAddressToAccountForUser(\r\n    address _newAddress,\r\n    bytes _newAddressSig,\r\n    bytes _senderSig,\r\n    address _sender,\r\n    bytes32 _nonce\r\n    ) private nonZero(_newAddress) {\r\n\r\n    require(!usedSignatures[keccak256(abi.encodePacked(_newAddressSig))], \"Signature not unique\");\r\n    require(!usedSignatures[keccak256(abi.encodePacked(_senderSig))], \"Signature not unique\");\r\n\r\n    usedSignatures[keccak256(abi.encodePacked(_newAddressSig))] = true;\r\n    usedSignatures[keccak256(abi.encodePacked(_senderSig))] = true;\r\n\r\n    // Confirm new address is signed by current address\r\n    bytes32 _currentAddressDigest = signingLogic.generateAddAddressSchemaHash(_newAddress, _nonce);\r\n    require(_sender == signingLogic.recoverSigner(_currentAddressDigest, _senderSig));\r\n\r\n    // Confirm current address is signed by new address\r\n    bytes32 _newAddressDigest = signingLogic.generateAddAddressSchemaHash(_sender, _nonce);\r\n    require(_newAddress == signingLogic.recoverSigner(_newAddressDigest, _newAddressSig));\r\n\r\n    registry.addAddressToAccount(_newAddress, _sender);\r\n    uint256 _accountId = registry.accountIdForAddress(_newAddress);\r\n    emit AddressAdded(_accountId, _newAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove an address from an account for a user\r\n   * @dev Restricted to admin\r\n   * @param _addressToRemove Address to remove from account\r\n   */\r\n  function removeAddressFromAccountFor(\r\n    address _addressToRemove\r\n  ) public onlyRegistryAdmin {\r\n    uint256 _accountId = registry.accountIdForAddress(_addressToRemove);\r\n    registry.removeAddressFromAccount(_addressToRemove);\r\n    emit AddressRemoved(_accountId, _addressToRemove);\r\n  }\r\n}\r\n\r\n\r\ncontract AccountRegistryBatchAdmin is Ownable{\r\n\r\n  AccountRegistryInterface public registry;\r\n  AccountRegistryLogic public logic;\r\n  address public registryAdmin;\r\n\r\n  constructor(\r\n    AccountRegistryInterface _registry,\r\n    AccountRegistryLogic _logic\r\n    ) public {\r\n    registry = _registry;\r\n    logic = _logic;\r\n    registryAdmin = owner;\r\n  }\r\n\r\n  event addressSkipped(address skippedAddress);\r\n\r\n  /**\r\n   * @dev Restricted to registryAdmin\r\n   */\r\n  modifier onlyRegistryAdmin {\r\n    require(msg.sender == registryAdmin);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Change the address of the registryAdmin, who has the privilege to create new accounts\r\n   * @dev Restricted to AccountRegistry owner and new admin address cannot be 0x0\r\n   * @param _newRegistryAdmin Address of new registryAdmin\r\n   */\r\n  function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {\r\n    address _oldRegistryAdmin = registryAdmin;\r\n    registryAdmin = _newRegistryAdmin;\r\n  }\r\n\r\n  /**\r\n   * @notice Create an account instantly without an invitation\r\n   * @dev Restricted to the \"invite admin\" which is managed by the Bloom team\r\n   * @param _newUsers Address array of the users receiving an account\r\n   */\r\n  function batchCreateAccount(address[] _newUsers) public onlyRegistryAdmin {\r\n    for (uint256 i = 0; i < _newUsers.length; i++) {\r\n      if (registry.addressBelongsToAccount(_newUsers[i])) {\r\n        emit addressSkipped(_newUsers[i]);\r\n      } else {\r\n        logic.createAccount(_newUsers[i]);\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"setRegistryAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registryAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newUsers\",\"type\":\"address[]\"}],\"name\":\"batchCreateAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_logic\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"skippedAddress\",\"type\":\"address\"}],\"name\":\"addressSkipped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AccountRegistryBatchAdmin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a08b00eb41a452540c44e953d9ee86f86793af55000000000000000000000000017925fdb447544da8ed671b5305461cfc6c6e1d","Library":"","SwarmSource":"bzzr://f0a05884a0a919f92db08a61ead4c37a0413203afd20604c418048bfb7e0dd72"}]}