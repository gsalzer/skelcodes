{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * Libraries\r\n**/\r\n\r\nlibrary ExtendedMath {\r\n    function limitLessThan(uint a, uint b) internal pure returns(uint c) {\r\n        if (a > b) return b;\r\n        return a;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns(uint256);\r\n\r\n    function balanceOf(address _who) public view returns(uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address _owner, address _spender) public view returns(uint256);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath\r\n    for uint256;\r\n\r\n    mapping(address => uint256) internal balances;\r\n\r\n    uint256 internal totalSupply_;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns(bool) {\r\n        //require(_value <= balances[msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns(uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n    public\r\n    returns(bool) {\r\n        //require(_value <= balances[_from]);\r\n        //require(_value <= allowed[_from][msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns(bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n    public\r\n    view\r\n    returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n    public\r\n    returns(bool) {\r\n        allowed[msg.sender][_spender] = (\r\n            allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n    public\r\n    returns(bool) {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ninterface IRemoteFunctions {\r\n  function _externalAddMasternode(address) external;\r\n  function _externalStopMasternode(address) external;\r\n}\r\n\r\ninterface IcaelumVoting {\r\n    function getTokenProposalDetails() external view returns(address, uint, uint, uint);\r\n    function getExpiry() external view returns (uint);\r\n    function getContractType () external view returns (uint);\r\n}\r\n\r\ninterface EIP918Interface  {\r\n\r\n    /*\r\n     * Externally facing mint function that is called by miners to validate challenge digests, calculate reward,\r\n     * populate statistics, mutate epoch variables and adjust the solution difficulty as required. Once complete,\r\n     * a Mint event is emitted before returning a success indicator.\r\n     **/\r\n  \tfunction mint(uint256 nonce, bytes32 challenge_digest) external returns (bool success);\r\n\r\n\r\n\t/*\r\n     * Returns the challenge number\r\n     **/\r\n    function getChallengeNumber() external constant returns (bytes32);\r\n\r\n    /*\r\n     * Returns the mining difficulty. The number of digits that the digest of the PoW solution requires which\r\n     * typically auto adjusts during reward generation.\r\n     **/\r\n    function getMiningDifficulty() external constant returns (uint);\r\n\r\n    /*\r\n     * Returns the mining target\r\n     **/\r\n    function getMiningTarget() external constant returns (uint);\r\n\r\n    /*\r\n     * Return the current reward amount. Depending on the algorithm, typically rewards are divided every reward era\r\n     * as tokens are mined to provide scarcity\r\n     **/\r\n    function getMiningReward() external constant returns (uint);\r\n\r\n    /*\r\n     * Upon successful verification and reward the mint method dispatches a Mint Event indicating the reward address,\r\n     * the reward amount, the epoch count and newest challenge number.\r\n     **/\r\n    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n\r\n}\r\n\r\ncontract NewMinerProposal is IcaelumVoting {\r\n\r\n    enum VOTE_TYPE {MINER, MASTER, TOKEN}\r\n\r\n    VOTE_TYPE public contractType = VOTE_TYPE.TOKEN;\r\n    address contractAddress;\r\n    uint validUntil;\r\n    uint votingDurationInDays;\r\n\r\n    /**\r\n     * @dev Create a new vote proposal for an ERC20 token.\r\n     * @param _contract ERC20 contract\r\n     * @param _valid How long do we accept these tokens on the contract (UNIX timestamp)\r\n     * @param _voteDuration How many days is this vote available\r\n     */\r\n    constructor(address _contract, uint _valid, uint _voteDuration) public {\r\n        require(_voteDuration >= 14 && _voteDuration <= 50, \"Proposed voting duration does not meet requirements\");\r\n\r\n        contractAddress = _contract;\r\n        validUntil = _valid;\r\n        votingDurationInDays = _voteDuration;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all details about this proposal\r\n     */\r\n    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\r\n        return (contractAddress, 0, validUntil, uint(contractType));\r\n    }\r\n\r\n    /**\r\n     * @dev Displays the expiry date of contract\r\n     * @return uint Days valid\r\n     */\r\n    function getExpiry() external view returns (uint) {\r\n        return votingDurationInDays;\r\n    }\r\n\r\n    /**\r\n     * @dev Displays the type of contract\r\n     * @return uint Enum value {TOKEN, TEAM}\r\n     */\r\n    function getContractType () external view returns (uint){\r\n        return uint(contractType);\r\n    }\r\n}\r\n\r\ncontract CaelumVotings is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    enum VOTE_TYPE {MINER, MASTER, TOKEN}\r\n\r\n    struct Proposals {\r\n        address tokenContract;\r\n        uint totalVotes;\r\n        uint proposedOn;\r\n        uint acceptedOn;\r\n        VOTE_TYPE proposalType;\r\n    }\r\n\r\n    struct Voters {\r\n        bool isVoter;\r\n        address owner;\r\n        uint[] votedFor;\r\n    }\r\n\r\n    uint MAJORITY_PERCENTAGE_NEEDED = 60;\r\n    uint MINIMUM_VOTERS_NEEDED = 1;\r\n    bool public proposalPending;\r\n\r\n    mapping(uint => Proposals) public proposalList;\r\n    mapping (address => Voters) public voterMap;\r\n    mapping(uint => address) public voterProposals;\r\n    uint public proposalCounter;\r\n    uint public votersCount;\r\n    uint public votersCountTeam;\r\n\r\n\r\n    function setMasternodeContractFromVote(address _t) internal ;\r\n    function setTokenContractFromVote(address _t) internal;\r\n    function setMiningContractFromVote (address _t) internal;\r\n\r\n    event NewProposal(uint ProposalID);\r\n    event ProposalAccepted(uint ProposalID);\r\n\r\n    address _CaelumMasternodeContract;\r\n    CaelumMasternode public MasternodeContract;\r\n\r\n    function setMasternodeContractForData(address _t) onlyOwner public {\r\n        MasternodeContract = CaelumMasternode(_t);\r\n        _CaelumMasternodeContract = (_t);\r\n    }\r\n\r\n    function setVotingMinority(uint _total) onlyOwner public {\r\n        require(_total > MINIMUM_VOTERS_NEEDED);\r\n        MINIMUM_VOTERS_NEEDED = _total;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Create a new proposal.\r\n     * @param _contract Proposal contract address\r\n     * @return uint ProposalID\r\n     */\r\n    function pushProposal(address _contract) onlyOwner public returns (uint) {\r\n        if(proposalCounter != 0)\r\n        require (pastProposalTimeRules (), \"You need to wait 90 days before submitting a new proposal.\");\r\n        require (!proposalPending, \"Another proposal is pending.\");\r\n\r\n        uint _contractType = IcaelumVoting(_contract).getContractType();\r\n        proposalList[proposalCounter] = Proposals(_contract, 0, now, 0, VOTE_TYPE(_contractType));\r\n\r\n        emit NewProposal(proposalCounter);\r\n\r\n        proposalCounter++;\r\n        proposalPending = true;\r\n\r\n        return proposalCounter.sub(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that handles the proposal after it got accepted.\r\n     * This function determines if the proposal is a token or team member proposal and executes the corresponding functions.\r\n     * @return uint Returns the proposal ID.\r\n     */\r\n    function handleLastProposal () internal returns (uint) {\r\n        uint _ID = proposalCounter.sub(1);\r\n\r\n        proposalList[_ID].acceptedOn = now;\r\n        proposalPending = false;\r\n\r\n        address _address;\r\n        uint _required;\r\n        uint _valid;\r\n        uint _type;\r\n        (_address, _required, _valid, _type) = getTokenProposalDetails(_ID);\r\n\r\n        if(_type == uint(VOTE_TYPE.MINER)) {\r\n            setMiningContractFromVote(_address);\r\n        }\r\n\r\n        if(_type == uint(VOTE_TYPE.MASTER)) {\r\n            setMasternodeContractFromVote(_address);\r\n        }\r\n\r\n        if(_type == uint(VOTE_TYPE.TOKEN)) {\r\n            setTokenContractFromVote(_address);\r\n        }\r\n\r\n        emit ProposalAccepted(_ID);\r\n\r\n        return _ID;\r\n    }\r\n\r\n    /**\r\n     * @dev Rejects the last proposal after the allowed voting time has expired and it's not accepted.\r\n     */\r\n    function discardRejectedProposal() onlyOwner public returns (bool) {\r\n        require(proposalPending);\r\n        require (LastProposalCanDiscard());\r\n        proposalPending = false;\r\n        return (true);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the last proposal allowed voting time has expired and it's not accepted.\r\n     * @return bool\r\n     */\r\n    function LastProposalCanDiscard () public view returns (bool) {\r\n\r\n        uint daysBeforeDiscard = IcaelumVoting(proposalList[proposalCounter - 1].tokenContract).getExpiry();\r\n        uint entryDate = proposalList[proposalCounter - 1].proposedOn;\r\n        uint expiryDate = entryDate + (daysBeforeDiscard * 1 days);\r\n\r\n        if (now >= expiryDate)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all details about a proposal\r\n     */\r\n    function getTokenProposalDetails(uint proposalID) public view returns(address, uint, uint, uint) {\r\n        return IcaelumVoting(proposalList[proposalID].tokenContract).getTokenProposalDetails();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if our 90 day cooldown has passed\r\n     * @return bool\r\n     */\r\n    function pastProposalTimeRules() public view returns (bool) {\r\n        uint lastProposal = proposalList[proposalCounter - 1].proposedOn;\r\n        if (now >= lastProposal + 90 days)\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allow any masternode user to become a voter.\r\n     */\r\n    function becomeVoter() public  {\r\n        require (MasternodeContract.isMasternodeOwner(msg.sender), \"User has no masternodes\");\r\n        require (!voterMap[msg.sender].isVoter, \"User Already voted for this proposal\");\r\n\r\n        voterMap[msg.sender].owner = msg.sender;\r\n        voterMap[msg.sender].isVoter = true;\r\n        votersCount = votersCount + 1;\r\n\r\n        if (MasternodeContract.isTeamMember(msg.sender))\r\n        votersCountTeam = votersCountTeam + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow voters to submit their vote on a proposal. Voters can only cast 1 vote per proposal.\r\n     * If the proposed vote is about adding Team members, only Team members are able to vote.\r\n     * A proposal can only be published if the total of votes is greater then MINIMUM_VOTERS_NEEDED.\r\n     * @param proposalID proposalID\r\n     */\r\n    function voteProposal(uint proposalID) public returns (bool success) {\r\n        require(voterMap[msg.sender].isVoter, \"Sender not listed as voter\");\r\n        require(proposalID >= 0, \"No proposal was selected.\");\r\n        require(proposalID <= proposalCounter, \"Proposal out of limits.\");\r\n        require(voterProposals[proposalID] != msg.sender, \"Already voted.\");\r\n\r\n\r\n        require(votersCount >= MINIMUM_VOTERS_NEEDED, \"Not enough voters in existence to push a proposal\");\r\n        voterProposals[proposalID] = msg.sender;\r\n        proposalList[proposalID].totalVotes++;\r\n\r\n        if(reachedMajority(proposalID)) {\r\n            // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\r\n            // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\r\n            handleLastProposal();\r\n            return true;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a proposal has reached the majority vote\r\n     * @param proposalID Token ID\r\n     * @return bool\r\n     */\r\n    function reachedMajority (uint proposalID) public view returns (bool) {\r\n        uint getProposalVotes = proposalList[proposalID].totalVotes;\r\n        if (getProposalVotes >= majority())\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that calculates the majority\r\n     * @return uint Total of votes needed for majority\r\n     */\r\n    function majority () internal view returns (uint) {\r\n        uint a = (votersCount * MAJORITY_PERCENTAGE_NEEDED );\r\n        return a / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a proposal has reached the majority vote for a team member\r\n     * @param proposalID Token ID\r\n     * @return bool\r\n     */\r\n    function reachedMajorityForTeam (uint proposalID) public view returns (bool) {\r\n        uint getProposalVotes = proposalList[proposalID].totalVotes;\r\n        if (getProposalVotes >= majorityForTeam())\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that calculates the majority\r\n     * @return uint Total of votes needed for majority\r\n     */\r\n    function majorityForTeam () internal view returns (uint) {\r\n        uint a = (votersCountTeam * MAJORITY_PERCENTAGE_NEEDED );\r\n        return a / 100;\r\n    }\r\n\r\n}\r\n\r\ncontract CaelumAcceptERC20 is Ownable  {\r\n    using SafeMath for uint;\r\n\r\n    IRemoteFunctions public DataVault;\r\n\r\n    address[] public tokensList;\r\n    bool setOwnContract = true;\r\n\r\n    struct _whitelistTokens {\r\n        address tokenAddress;\r\n        bool active;\r\n        uint requiredAmount;\r\n        uint validUntil;\r\n        uint timestamp;\r\n    }\r\n\r\n    mapping(address => mapping(address => uint)) public tokens;\r\n    mapping(address => _whitelistTokens) acceptedTokens;\r\n\r\n    event Deposit(address token, address user, uint amount, uint balance);\r\n    event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n    \r\n\r\n\r\n    /**\r\n     * @notice Allow the dev to set it's own token as accepted payment.\r\n     * @dev Can be hardcoded in the constructor. Given the contract size, we decided to separate it.\r\n     * @return bool\r\n     */\r\n    function addOwnToken() onlyOwner public returns (bool) {\r\n        require(setOwnContract);\r\n        addToWhitelist(this, 5000 * 1e8, 36500);\r\n        setOwnContract = false;\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Add a new token as accepted payment method.\r\n     * @param _token Token contract address.\r\n     * @param _amount Required amount of this Token as collateral\r\n     * @param daysAllowed How many days will we accept this token?\r\n     */\r\n    function addToWhitelist(address _token, uint _amount, uint daysAllowed) internal {\r\n        _whitelistTokens storage newToken = acceptedTokens[_token];\r\n        newToken.tokenAddress = _token;\r\n        newToken.requiredAmount = _amount;\r\n        newToken.timestamp = now;\r\n        newToken.validUntil = now + (daysAllowed * 1 days);\r\n        newToken.active = true;\r\n\r\n        tokensList.push(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev internal function to determine if we accept this token.\r\n     * @param _ad Token contract address\r\n     * @return bool\r\n     */\r\n    function isAcceptedToken(address _ad) internal view returns(bool) {\r\n        return acceptedTokens[_ad].active;\r\n    }\r\n\r\n    /**\r\n     * @dev internal function to determine the requiredAmount for a specific token.\r\n     * @param _ad Token contract address\r\n     * @return bool\r\n     */\r\n    function getAcceptedTokenAmount(address _ad) internal view returns(uint) {\r\n        return acceptedTokens[_ad].requiredAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev internal function to determine if the token is still accepted timewise.\r\n     * @param _ad Token contract address\r\n     * @return bool\r\n     */\r\n    function isValid(address _ad) internal view returns(bool) {\r\n        uint endTime = acceptedTokens[_ad].validUntil;\r\n        if (block.timestamp < endTime) return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns an array of all accepted token. You can get more details by calling getTokenDetails function with this address.\r\n     * @return array Address\r\n     */\r\n    function listAcceptedTokens() public view returns(address[]) {\r\n        return tokensList;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a full list of the token details\r\n     * @param token Token contract address\r\n     */\r\n    function getTokenDetails(address token) public view returns(address ad,uint required, bool active, uint valid) {\r\n        return (acceptedTokens[token].tokenAddress, acceptedTokens[token].requiredAmount,acceptedTokens[token].active, acceptedTokens[token].validUntil);\r\n    }\r\n\r\n    /**\r\n     * @notice Public function that allows any user to deposit accepted tokens as collateral to become a masternode.\r\n     * @param token Token contract address\r\n     * @param amount Amount to deposit\r\n     */\r\n    function depositCollateral(address token, uint amount) public {\r\n        require(isAcceptedToken(token), \"ERC20 not authorised\");  // Should be a token from our list\r\n        require(amount == getAcceptedTokenAmount(token));         // The amount needs to match our set amount\r\n        require(isValid(token));                                  // It should be called within the setup timeframe\r\n\r\n        tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n\r\n        require(StandardToken(token).transferFrom(msg.sender, this, amount), \"error with token\");\r\n        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n\r\n        DataVault._externalAddMasternode(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Public function that allows any user to withdraw deposited tokens and stop as masternode\r\n     * @param token Token contract address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function withdrawCollateral(address token, uint amount) public {\r\n        require(token != 0);                                        // token should be an actual address\r\n        require(isAcceptedToken(token), \"ERC20 not authorised\");    // Should be a token from our list\r\n        require(amount == getAcceptedTokenAmount(token));           // The amount needs to match our set amount, allow only one withdrawal at a time.\r\n        require(tokens[token][msg.sender] >= amount);               // The owner must own at least this amount of tokens.\r\n\r\n        uint amountToWithdraw = tokens[token][msg.sender];\r\n        tokens[token][msg.sender] = 0;\r\n\r\n        DataVault._externalStopMasternode(msg.sender);\r\n\r\n        if (!StandardToken(token).transfer(msg.sender, amountToWithdraw)) revert();\r\n        emit Withdraw(token, msg.sender, amountToWithdraw, amountToWithdraw);\r\n    }\r\n\r\n    function setDataStorage (address _masternodeContract) onlyOwner public {\r\n        DataVault = IRemoteFunctions(_masternodeContract);\r\n    }\r\n}\r\n\r\ncontract CaelumAbstractMasternode is Ownable{\r\n    using SafeMath for uint;\r\n\r\n    bool onTestnet = false;\r\n    bool genesisAdded = false;\r\n\r\n    uint public masternodeRound;\r\n    uint public masternodeCandidate;\r\n    uint public masternodeCounter;\r\n    uint public masternodeEpoch;\r\n    uint public miningEpoch;\r\n\r\n    uint public rewardsProofOfWork;\r\n    uint public rewardsMasternode;\r\n    uint rewardsGlobal = 50 * 1e8;\r\n\r\n    uint public MINING_PHASE_DURATION_BLOCKS = 4500;\r\n\r\n    struct MasterNode {\r\n        address accountOwner;\r\n        bool isActive;\r\n        bool isTeamMember;\r\n        uint storedIndex;\r\n        uint startingRound;\r\n        uint[] indexcounter;\r\n    }\r\n\r\n    uint[] userArray;\r\n    address[] userAddressArray;\r\n\r\n    mapping(uint => MasterNode) userByIndex; // UINT masterMapping\r\n    mapping(address => MasterNode) userByAddress; //masterMapping\r\n    mapping(address => uint) userAddressIndex;\r\n\r\n    event Deposit(address token, address user, uint amount, uint balance);\r\n    event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n    event NewMasternode(address candidateAddress, uint timeStamp);\r\n    event RemovedMasternode(address candidateAddress, uint timeStamp);\r\n\r\n    /**\r\n     * @dev Add the genesis accounts\r\n     */\r\n    function addGenesis(address _genesis, bool _team) onlyOwner public {\r\n        require(!genesisAdded);\r\n\r\n        addMasternode(_genesis);\r\n\r\n        if (_team) {\r\n            updateMasternodeAsTeamMember(msg.sender);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Close the genesis accounts\r\n     */\r\n    function closeGenesis() onlyOwner public {\r\n        genesisAdded = true; // Forever lock this.\r\n    }\r\n\r\n    /**\r\n     * @dev Add a user as masternode. Called as internal since we only add masternodes by depositing collateral or by voting.\r\n     * @param _candidate Candidate address\r\n     * @return uint Masternode index\r\n     */\r\n    function addMasternode(address _candidate) internal returns(uint) {\r\n        userByIndex[masternodeCounter].accountOwner = _candidate;\r\n        userByIndex[masternodeCounter].isActive = true;\r\n        userByIndex[masternodeCounter].startingRound = masternodeRound + 1;\r\n        userByIndex[masternodeCounter].storedIndex = masternodeCounter;\r\n\r\n        userByAddress[_candidate].accountOwner = _candidate;\r\n        userByAddress[_candidate].indexcounter.push(masternodeCounter);\r\n\r\n        userArray.push(userArray.length);\r\n        masternodeCounter++;\r\n\r\n        emit NewMasternode(_candidate, now);\r\n        return masternodeCounter - 1; //\r\n    }\r\n\r\n    /**\r\n     * @dev Allow us to update a masternode's round to keep progress\r\n     * @param _candidate ID of masternode\r\n     */\r\n    function updateMasternode(uint _candidate) internal returns(bool) {\r\n        userByIndex[_candidate].startingRound++;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow us to update a masternode to team member status\r\n     * @param _member address\r\n     */\r\n    function updateMasternodeAsTeamMember(address _member) internal returns (bool) {\r\n        userByAddress[_member].isTeamMember = true;\r\n        return (true);\r\n    }\r\n\r\n    /**\r\n     * @dev Let us know if an address is part of the team.\r\n     * @param _member address\r\n     */\r\n    function isTeamMember (address _member) public view returns (bool) {\r\n        if (userByAddress[_member].isTeamMember)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a specific masternode\r\n     * @param _masternodeID ID of the masternode to remove\r\n     */\r\n    function deleteMasternode(uint _masternodeID) internal returns(bool success) {\r\n\r\n        uint rowToDelete = userByIndex[_masternodeID].storedIndex;\r\n        uint keyToMove = userArray[userArray.length - 1];\r\n\r\n        userByIndex[_masternodeID].isActive = userByIndex[_masternodeID].isActive = (false);\r\n        userArray[rowToDelete] = keyToMove;\r\n        userByIndex[keyToMove].storedIndex = rowToDelete;\r\n        userArray.length = userArray.length - 1;\r\n\r\n        removeFromUserCounter(_masternodeID);\r\n\r\n        emit RemovedMasternode(userByIndex[_masternodeID].accountOwner, now);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev returns what account belongs to a masternode\r\n     */\r\n    function isPartOf(uint mnid) public view returns (address) {\r\n        return userByIndex[mnid].accountOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to remove a masternode from a user address if this address holds multpile masternodes\r\n     * @param index MasternodeID\r\n     */\r\n    function removeFromUserCounter(uint index)  internal returns(uint[]) {\r\n        address belong = isPartOf(index);\r\n\r\n        if (index >= userByAddress[belong].indexcounter.length) return;\r\n\r\n        for (uint i = index; i<userByAddress[belong].indexcounter.length-1; i++){\r\n            userByAddress[belong].indexcounter[i] = userByAddress[belong].indexcounter[i+1];\r\n        }\r\n\r\n        delete userByAddress[belong].indexcounter[userByAddress[belong].indexcounter.length-1];\r\n        userByAddress[belong].indexcounter.length--;\r\n        return userByAddress[belong].indexcounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Primary contract function to update the current user and prepare the next one.\r\n     * A number of steps have been token to ensure the contract can never run out of gas when looping over our masternodes.\r\n     */\r\n    function setMasternodeCandidate() internal returns(address) {\r\n\r\n        uint hardlimitCounter = 0;\r\n\r\n        while (getFollowingCandidate() == 0x0) {\r\n            // We must return a value not to break the contract. Require is a secondary killswitch now.\r\n            require(hardlimitCounter < 6, \"Failsafe switched on\");\r\n            // Choose if loop over revert/require to terminate the loop and return a 0 address.\r\n            if (hardlimitCounter == 5) return (0);\r\n            masternodeRound = masternodeRound + 1;\r\n            masternodeCandidate = 0;\r\n            hardlimitCounter++;\r\n        }\r\n\r\n        if (masternodeCandidate == masternodeCounter - 1) {\r\n            masternodeRound = masternodeRound + 1;\r\n            masternodeCandidate = 0;\r\n        }\r\n\r\n        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\r\n            if (userByIndex[i].isActive) {\r\n                if (userByIndex[i].startingRound == masternodeRound) {\r\n                    updateMasternode(i);\r\n                    masternodeCandidate = i;\r\n                    return (userByIndex[i].accountOwner);\r\n                }\r\n            }\r\n        }\r\n\r\n        masternodeRound = masternodeRound + 1;\r\n        return (0);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to loop through our masternodes at start and return the correct round\r\n     */\r\n    function getFollowingCandidate() internal view returns(address _address) {\r\n        uint tmpRound = masternodeRound;\r\n        uint tmpCandidate = masternodeCandidate;\r\n\r\n        if (tmpCandidate == masternodeCounter - 1) {\r\n            tmpRound = tmpRound + 1;\r\n            tmpCandidate = 0;\r\n        }\r\n\r\n        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\r\n            if (userByIndex[i].isActive) {\r\n                if (userByIndex[i].startingRound == tmpRound) {\r\n                    tmpCandidate = i;\r\n                    return (userByIndex[i].accountOwner);\r\n                }\r\n            }\r\n        }\r\n\r\n        tmpRound = tmpRound + 1;\r\n        return (0);\r\n    }\r\n\r\n    /**\r\n     * @dev Displays all masternodes belonging to a user address.\r\n     */\r\n    function belongsToUser(address userAddress) public view returns(uint[]) {\r\n        return (userByAddress[userAddress].indexcounter);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to know if an address owns masternodes\r\n     */\r\n    function isMasternodeOwner(address _candidate) public view returns(bool) {\r\n        if(userByAddress[_candidate].indexcounter.length <= 0) return false;\r\n        if (userByAddress[_candidate].accountOwner == _candidate)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to get the last masternode belonging to a user\r\n     */\r\n    function getLastPerUser(address _candidate) public view returns (uint) {\r\n        return userByAddress[_candidate].indexcounter[userByAddress[_candidate].indexcounter.length - 1];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the base rewards. This should be overrided by the miner contract.\r\n     * Return a base value for standalone usage ONLY.\r\n     */\r\n    function getMiningReward() public view returns(uint) {\r\n        return 50 * 1e8;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate and set the reward schema for Caelum.\r\n     * Each mining phase is decided by multiplying the MINING_PHASE_DURATION_BLOCKS with factor 10.\r\n     * Depending on the outcome (solidity always rounds), we can detect the current stage of mining.\r\n     * First stage we cut the rewards to 5% to prevent instamining.\r\n     * Last stage we leave 2% for miners to incentivize keeping miners running.\r\n     */\r\n    function calculateRewardStructures() internal {\r\n        //ToDo: Set\r\n        uint _global_reward_amount = getMiningReward();\r\n        uint getStageOfMining = miningEpoch / MINING_PHASE_DURATION_BLOCKS * 10;\r\n\r\n        if (getStageOfMining < 10) {\r\n            rewardsProofOfWork = _global_reward_amount / 100 * 5;\r\n            rewardsMasternode = 0;\r\n            return;\r\n        }\r\n\r\n        if (getStageOfMining > 90) {\r\n            rewardsProofOfWork = _global_reward_amount / 100 * 2;\r\n            rewardsMasternode = _global_reward_amount / 100 * 98;\r\n            return;\r\n        }\r\n\r\n        uint _mnreward = (_global_reward_amount / 100) * getStageOfMining;\r\n        uint _powreward = (_global_reward_amount - _mnreward);\r\n\r\n        setBaseRewards(_powreward, _mnreward);\r\n    }\r\n\r\n    function setBaseRewards(uint _pow, uint _mn) internal {\r\n        rewardsMasternode = _mn;\r\n        rewardsProofOfWork = _pow;\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the masternode flow. Should be called after mining a block.\r\n     */\r\n    function _arrangeMasternodeFlow() internal {\r\n        calculateRewardStructures();\r\n        setMasternodeCandidate();\r\n        miningEpoch++;\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the masternode flow. Should be called after mining a block.\r\n     * This is an emergency manual loop method.\r\n     */\r\n    function _emergencyLoop() onlyOwner public {\r\n        calculateRewardStructures();\r\n        setMasternodeCandidate();\r\n        miningEpoch++;\r\n    }\r\n\r\n    function masternodeInfo(uint index) public view returns\r\n    (\r\n        address,\r\n        bool,\r\n        uint,\r\n        uint\r\n    )\r\n    {\r\n        return (\r\n            userByIndex[index].accountOwner,\r\n            userByIndex[index].isActive,\r\n            userByIndex[index].storedIndex,\r\n            userByIndex[index].startingRound\r\n        );\r\n    }\r\n\r\n    function contractProgress() public view returns\r\n    (\r\n        uint epoch,\r\n        uint candidate,\r\n        uint round,\r\n        uint miningepoch,\r\n        uint globalreward,\r\n        uint powreward,\r\n        uint masternodereward,\r\n        uint usercounter\r\n    )\r\n    {\r\n        return (\r\n            masternodeEpoch,\r\n            masternodeCandidate,\r\n            masternodeRound,\r\n            miningEpoch,\r\n            getMiningReward(),\r\n            rewardsProofOfWork,\r\n            rewardsMasternode,\r\n            masternodeCounter\r\n        );\r\n    }\r\n\r\n}\r\n\r\ncontract CaelumMasternode is CaelumVotings, CaelumAbstractMasternode {\r\n\r\n    /**\r\n     * @dev Hardcoded token mining address. For trust and safety we do not allow changing this.\r\n     * Should anything change, a new instance needs to be redeployed.\r\n     */\r\n    address public miningContract;\r\n    address public tokenContract;\r\n    \r\n    bool minerSet = false;\r\n    bool tokenSet = false;\r\n\r\n    function setMiningContract(address _t) onlyOwner public {\r\n        require(!minerSet);\r\n        miningContract = _t;\r\n        minerSet = true;\r\n    }\r\n\r\n    function setTokenContract(address _t) onlyOwner public {\r\n        require(!tokenSet);\r\n        tokenContract = _t;\r\n        tokenSet = true;\r\n    }\r\n\r\n    function setMasternodeContractFromVote(address _t) internal {\r\n    }\r\n\r\n    function setTokenContractFromVote(address _t) internal{\r\n        tokenContract = _t;\r\n    }\r\n\r\n    function setMiningContractFromVote (address _t) internal {\r\n        miningContract = _t;\r\n    }\r\n\r\n    /**\r\n     * @dev Only allow the token mining contract to call this function when used remotely.\r\n     * Use the internal function when working within the same contract.\r\n     */\r\n    modifier onlyMiningContract() {\r\n        require(msg.sender == miningContract);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Only allow the token contract to call this function when used remotely.\r\n     * Use the internal function when working within the same contract.\r\n     */\r\n    modifier onlyTokenContract() {\r\n        require(msg.sender == tokenContract);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Only allow the token contract to call this function when used remotely.\r\n     * Use the internal function when working within the same contract.\r\n     */\r\n    modifier bothRemoteContracts() {\r\n        require(msg.sender == tokenContract || msg.sender == miningContract);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Use this to externaly call the _arrangeMasternodeFlow function. ALWAYS set a modifier !\r\n     */\r\n    function _externalArrangeFlow() onlyMiningContract external {\r\n        _arrangeMasternodeFlow();\r\n    }\r\n\r\n    /**\r\n     * @dev Use this to externaly call the addMasternode function. ALWAYS set a modifier !\r\n     */\r\n    function _externalAddMasternode(address _received) onlyMiningContract external {\r\n        addMasternode(_received);\r\n    }\r\n\r\n    /**\r\n     * @dev Use this to externaly call the deleteMasternode function. ALWAYS set a modifier !\r\n     */\r\n    function _externalStopMasternode(address _received) onlyMiningContract external {\r\n        deleteMasternode(getLastPerUser(_received));\r\n    }\r\n\r\n    function getMiningReward() public view returns(uint) {\r\n        return CaelumMiner(miningContract).getMiningReward();\r\n    }\r\n    \r\n    address cloneDataFrom = 0x7600bF5112945F9F006c216d5d6db0df2806eDc6;\r\n    \r\n    function getDataFromContract () onlyOwner public returns(uint) {\r\n        \r\n        CaelumMasternode prev = CaelumMasternode(cloneDataFrom);\r\n        (uint epoch,\r\n        uint candidate,\r\n        uint round,\r\n        uint miningepoch,\r\n        uint globalreward,\r\n        uint powreward,\r\n        uint masternodereward,\r\n        uint usercounter) = prev.contractProgress();\r\n        \r\n        masternodeEpoch = epoch;\r\n        masternodeRound = round;\r\n        miningEpoch = miningepoch;\r\n        rewardsProofOfWork = powreward;\r\n        rewardsMasternode = masternodereward;\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract CaelumToken is Ownable, StandardToken, CaelumVotings, CaelumAcceptERC20 {\r\n    using SafeMath for uint;\r\n\r\n    ERC20 previousContract;\r\n    \r\n    bool contractSet = false;\r\n    bool public swapClosed = false;\r\n    uint public swapCounter;\r\n\r\n    string public symbol = \"CLM\";\r\n    string public name = \"Caelum Token\";\r\n    uint8 public decimals = 8;\r\n    uint256 public totalSupply = 2100000000000000;\r\n    \r\n    address public miningContract = 0x0;\r\n\r\n    /**\r\n     * @dev Only allow the token mining contract to call this function when used remotely.\r\n     * Use the internal function when working within the same contract.\r\n     */\r\n    modifier onlyMiningContract() {\r\n        require(msg.sender == miningContract);\r\n        _;\r\n    }\r\n\r\n    constructor(address _previousContract) public {\r\n        previousContract = ERC20(_previousContract);\r\n        swapClosed = false;\r\n        swapCounter = 0;\r\n    }\r\n\r\n    function setMiningContract (address _t) onlyOwner public {\r\n        require(!contractSet);\r\n        miningContract = _t;\r\n        contractSet = true;\r\n    }\r\n\r\n    function setMasternodeContractFromVote(address _t) internal {\r\n        return;\r\n    }\r\n\r\n    function setTokenContractFromVote(address _t) internal{\r\n        return;\r\n    }\r\n\r\n    function setMiningContractFromVote (address _t) internal {\r\n        miningContract = _t;\r\n    }\r\n    \r\n    function changeSwapState (bool _state) onlyOwner public {\r\n        require(swapCounter <= 9);\r\n        swapClosed = _state;\r\n        swapCounter++;\r\n    }\r\n\r\n    function rewardExternal(address _receiver, uint _amount) onlyMiningContract external {\r\n        balances[_receiver] = balances[_receiver].add(_amount);\r\n        emit Transfer(this, _receiver, _amount);\r\n    }\r\n\r\n\r\n    function upgradeTokens() public{\r\n        require(!swapClosed);\r\n        uint amountToUpgrade = previousContract.balanceOf(msg.sender);\r\n        require(amountToUpgrade <= previousContract.allowance(msg.sender, this));\r\n        \r\n        if(previousContract.transferFrom(msg.sender, this, amountToUpgrade)){\r\n            balances[msg.sender] = balances[msg.sender].add(amountToUpgrade); // 2% Premine as determined by the community meeting.\r\n            emit Transfer(this, msg.sender, amountToUpgrade);\r\n        }\r\n        \r\n        require(previousContract.balanceOf(msg.sender) == 0);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract AbstractERC918 is EIP918Interface {\r\n\r\n    // generate a new challenge number after a new reward is minted\r\n    bytes32 public challengeNumber;\r\n\r\n    // the current mining difficulty\r\n    uint public difficulty;\r\n\r\n    // cumulative counter of the total minted tokens\r\n    uint public tokensMinted;\r\n\r\n    // track read only minting statistics\r\n    struct Statistics {\r\n        address lastRewardTo;\r\n        uint lastRewardAmount;\r\n        uint lastRewardEthBlockNumber;\r\n        uint lastRewardTimestamp;\r\n    }\r\n\r\n    Statistics public statistics;\r\n\r\n    /*\r\n     * Externally facing mint function that is called by miners to validate challenge digests, calculate reward,\r\n     * populate statistics, mutate epoch variables and adjust the solution difficulty as required. Once complete,\r\n     * a Mint event is emitted before returning a success indicator.\r\n     **/\r\n    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\r\n\r\n\r\n    /*\r\n     * Internal interface function _hash. Overide in implementation to define hashing algorithm and\r\n     * validation\r\n     **/\r\n    function _hash(uint256 nonce, bytes32 challenge_digest) internal returns (bytes32 digest);\r\n\r\n    /*\r\n     * Internal interface function _reward. Overide in implementation to calculate and return reward\r\n     * amount\r\n     **/\r\n    function _reward() internal returns (uint);\r\n\r\n    /*\r\n     * Internal interface function _newEpoch. Overide in implementation to define a cutpoint for mutating\r\n     * mining variables in preparation for the next epoch\r\n     **/\r\n    function _newEpoch(uint256 nonce) internal returns (uint);\r\n\r\n    /*\r\n     * Internal interface function _adjustDifficulty. Overide in implementation to adjust the difficulty\r\n     * of the mining as required\r\n     **/\r\n    function _adjustDifficulty() internal returns (uint);\r\n\r\n}\r\n\r\ncontract CaelumAbstractMiner is AbstractERC918 {\r\n    /**\r\n     * CaelumMiner contract.\r\n     *\r\n     * We need to make sure the contract is 100% compatible when using the EIP918Interface.\r\n     * This contract is an abstract Caelum miner contract.\r\n     *\r\n     * Function 'mint', and '_reward' are overriden in the CaelumMiner contract.\r\n     * Function '_reward_masternode' is added and needs to be overriden in the CaelumMiner contract.\r\n     */\r\n\r\n    using SafeMath for uint;\r\n    using ExtendedMath for uint;\r\n\r\n    uint256 public totalSupply = 2100000000000000;\r\n\r\n    uint public latestDifficultyPeriodStarted;\r\n    uint public epochCount;\r\n    uint public baseMiningReward = 50;\r\n    uint public blocksPerReadjustment = 512;\r\n    uint public _MINIMUM_TARGET = 2 ** 16;\r\n    uint public _MAXIMUM_TARGET = 2 ** 234;\r\n    uint public rewardEra = 0;\r\n\r\n    uint public maxSupplyForEra;\r\n    uint public MAX_REWARD_ERA = 39;\r\n    uint public MINING_RATE_FACTOR = 60; //mint the token 60 times less often than ether\r\n\r\n    uint public MAX_ADJUSTMENT_PERCENT = 100;\r\n    uint public TARGET_DIVISOR = 2000;\r\n    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\r\n    mapping(bytes32 => bytes32) solutionForChallenge;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    bytes32 public challengeNumber;\r\n    uint public difficulty;\r\n    uint public tokensMinted;\r\n\r\n\r\n    Statistics public statistics;\r\n\r\n    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n    event RewardMasternode(address candidate, uint amount);\r\n\r\n    constructor() public {\r\n        tokensMinted = 0;\r\n        maxSupplyForEra = totalSupply.div(2);\r\n        difficulty = _MAXIMUM_TARGET;\r\n        latestDifficultyPeriodStarted = block.number;\r\n        _newEpoch(0);\r\n    }\r\n\r\n\r\n\r\n    function _newEpoch(uint256 nonce) internal returns(uint) {\r\n\r\n        if (tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < MAX_REWARD_ERA) {\r\n            rewardEra = rewardEra + 1;\r\n        }\r\n        maxSupplyForEra = totalSupply - totalSupply.div(2 ** (rewardEra + 1));\r\n        epochCount = epochCount.add(1);\r\n        challengeNumber = blockhash(block.number - 1);\r\n        return (epochCount);\r\n    }\r\n\r\n    function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success);\r\n\r\n    function _hash(uint256 nonce, bytes32 challenge_digest) internal returns(bytes32 digest) {\r\n        digest = keccak256(challengeNumber, msg.sender, nonce);\r\n        if (digest != challenge_digest) revert();\r\n        if (uint256(digest) > difficulty) revert();\r\n        bytes32 solution = solutionForChallenge[challengeNumber];\r\n        solutionForChallenge[challengeNumber] = digest;\r\n        if (solution != 0x0) revert(); //prevent the same answer from awarding twice\r\n    }\r\n\r\n    function _reward() internal returns(uint);\r\n\r\n    function _reward_masternode() internal returns(uint);\r\n\r\n    function _adjustDifficulty() internal returns(uint) {\r\n        //every so often, readjust difficulty. Dont readjust when deploying\r\n        if (epochCount % blocksPerReadjustment != 0) {\r\n            return difficulty;\r\n        }\r\n\r\n        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\r\n        //assume 360 ethereum blocks per hour\r\n        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one 0xbitcoin epoch\r\n        uint epochsMined = blocksPerReadjustment;\r\n        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\r\n        //if there were less eth blocks passed in time than expected\r\n        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\r\n            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\r\n            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\r\n            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\r\n            //make it harder\r\n            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra)); //by up to 50 %\r\n        } else {\r\n            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\r\n            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\r\n            //make it easier\r\n            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra)); //by up to 50 %\r\n        }\r\n        latestDifficultyPeriodStarted = block.number;\r\n        if (difficulty < _MINIMUM_TARGET) //very difficult\r\n        {\r\n            difficulty = _MINIMUM_TARGET;\r\n        }\r\n        if (difficulty > _MAXIMUM_TARGET) //very easy\r\n        {\r\n            difficulty = _MAXIMUM_TARGET;\r\n        }\r\n    }\r\n\r\n    function getChallengeNumber() public view returns(bytes32) {\r\n        return challengeNumber;\r\n    }\r\n\r\n    function getMiningDifficulty() public view returns(uint) {\r\n        return _MAXIMUM_TARGET.div(difficulty);\r\n    }\r\n\r\n    function getMiningTarget() public view returns(uint) {\r\n        return difficulty;\r\n    }\r\n\r\n    function getMiningReward() public view returns(uint) {\r\n        return (baseMiningReward * 1e8).div(2 ** rewardEra);\r\n    }\r\n\r\n    function getMintDigest(\r\n        uint256 nonce,\r\n        bytes32 challenge_digest,\r\n        bytes32 challenge_number\r\n    )\r\n    public view returns(bytes32 digesttest) {\r\n        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\r\n        return digest;\r\n    }\r\n\r\n    function checkMintSolution(\r\n        uint256 nonce,\r\n        bytes32 challenge_digest,\r\n        bytes32 challenge_number,\r\n        uint testTarget\r\n    )\r\n    public view returns(bool success) {\r\n        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\r\n        if (uint256(digest) > testTarget) revert();\r\n        return (digest == challenge_digest);\r\n    }\r\n}\r\n\r\ncontract CaelumMiner is CaelumVotings, CaelumAbstractMiner {\r\n\r\n    /**\r\n     * CaelumMiner main contract\r\n     *\r\n     * Inherit from our abstract CaelumMiner contract and override some functions\r\n     * of the AbstractERC918 contract to allow masternode rewardings.\r\n     *\r\n     * @dev use this contract to make all changes needed for your project.\r\n     */\r\n\r\n    address cloneDataFrom = 0x7600bF5112945F9F006c216d5d6db0df2806eDc6;\r\n\r\n    bool ACTIVE_CONTRACT_STATE = true;\r\n    bool MasternodeSet = false;\r\n    bool TokenSet = false;\r\n\r\n    address _CaelumMasternodeContract;\r\n    address _CaelumTokenContract;\r\n\r\n    CaelumMasternode public MasternodeContract;\r\n    CaelumToken public tokenContract;\r\n\r\n    function setMasternodeContract(address _t) onlyOwner public {\r\n        require(!MasternodeSet);\r\n        MasternodeContract = CaelumMasternode(_t);\r\n        _CaelumMasternodeContract = (_t);\r\n        MasternodeSet = true;\r\n    }\r\n\r\n    function setTokenContract(address _t) onlyOwner public {\r\n        require(!TokenSet);\r\n        tokenContract = CaelumToken(_t);\r\n        _CaelumTokenContract = (_t);\r\n        TokenSet = true;\r\n    }\r\n\r\n    function setMiningContract (address _t) onlyOwner public {\r\n        return; \r\n    }\r\n\r\n    function setMasternodeContractFromVote(address _t) internal {\r\n        MasternodeContract = CaelumMasternode(_t);\r\n        _CaelumMasternodeContract = (_t);\r\n    }\r\n\r\n    function setTokenContractFromVote(address _t) internal{\r\n        tokenContract = CaelumToken(_t);\r\n        _CaelumTokenContract = (_t);\r\n    }\r\n\r\n    function setMiningContractFromVote (address _t) internal {\r\n        return;\r\n    }\r\n    \r\n    function lockMiningContract () onlyOwner public {\r\n        ACTIVE_CONTRACT_STATE = false;\r\n    }\r\n\r\n    function getDataFromContract () onlyOwner public {\r\n\r\n        require(_CaelumTokenContract != 0);\r\n        require(_CaelumMasternodeContract != 0);\r\n\r\n        CaelumMiner prev = CaelumMiner(cloneDataFrom);\r\n        difficulty = prev.difficulty();\r\n        rewardEra = prev.rewardEra();\r\n        MINING_RATE_FACTOR = prev.MINING_RATE_FACTOR();\r\n        maxSupplyForEra = prev.maxSupplyForEra();\r\n        tokensMinted = prev.tokensMinted();\r\n        epochCount = prev.epochCount();\r\n        latestDifficultyPeriodStarted = prev.latestDifficultyPeriodStarted();\r\n\r\n        ACTIVE_CONTRACT_STATE = true;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev override of the original function since we want to call the masternode contract remotely.\r\n     */\r\n    function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success) {\r\n        // If contract is no longer active, stop accepting solutions.\r\n        require(ACTIVE_CONTRACT_STATE);\r\n\r\n        _hash(nonce, challenge_digest);\r\n\r\n        MasternodeContract._externalArrangeFlow();\r\n\r\n        uint rewardAmount =_reward();\r\n        uint rewardMasternode = _reward_masternode();\r\n\r\n        tokensMinted += rewardAmount.add(rewardMasternode);\r\n\r\n        uint epochCounter = _newEpoch(nonce);\r\n\r\n        _adjustDifficulty();\r\n\r\n        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\r\n\r\n        emit Mint(msg.sender, rewardAmount, epochCounter, challengeNumber);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev override of the original function since we want to call the masternode contract remotely.\r\n     */\r\n    function _reward() internal returns(uint) {\r\n\r\n        uint _pow = MasternodeContract.rewardsProofOfWork();\r\n\r\n        tokenContract.rewardExternal(msg.sender, _pow);\r\n\r\n        return _pow;\r\n    }\r\n\r\n    /**\r\n     * @dev override of the original function since we want to call the masternode contract remotely.\r\n     */\r\n    function _reward_masternode() internal returns(uint) {\r\n\r\n        uint _mnReward = MasternodeContract.rewardsMasternode();\r\n        if (MasternodeContract.masternodeCounter() == 0) return 0;\r\n\r\n        uint getCandidate = MasternodeContract.masternodeCandidate();\r\n        address _mnCandidate = MasternodeContract.isPartOf(getCandidate);\r\n        if (_mnCandidate == 0x0) return 0;\r\n\r\n        tokenContract.rewardExternal(_mnCandidate, _mnReward);\r\n\r\n        emit RewardMasternode(_mnCandidate, _mnReward);\r\n\r\n        return _mnReward;\r\n    }\r\n    \r\n    function getMiningReward() public view returns(uint) {\r\n        return MasternodeContract.rewardsProofOfWork();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Burn some gas and create all contracts in a single call :-)\r\n */\r\n\r\ncontract caelumFactory { \r\n\r\n    CaelumMiner public MINER;\r\n    CaelumMasternode public MASTER;\r\n    CaelumToken public TOKEN;\r\n\r\n    function newCookie() public {\r\n        MINER = new CaelumMiner();\r\n        MASTER = new CaelumMasternode();\r\n        TOKEN = new CaelumToken(0x0);\r\n\r\n        MASTER.setMiningContract(MINER);\r\n        MASTER.setTokenContract(TOKEN);\r\n\r\n        MINER.setMasternodeContract(MASTER);\r\n        MINER.setTokenContract(TOKEN);\r\n\r\n        TOKEN.setMiningContract(MINER);\r\n        TOKEN.setDataStorage(MASTER);\r\n\r\n        MASTER.transferOwnership(msg.sender);\r\n        TOKEN.transferOwnership(msg.sender);\r\n        MINER.transferOwnership(msg.sender);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_masternodeContract\",\"type\":\"address\"}],\"name\":\"setDataStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"changeSwapState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"discardRejectedProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voterMap\",\"outputs\":[{\"name\":\"isVoter\",\"type\":\"bool\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgradeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voterProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addOwnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MasternodeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"getTokenProposalDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeVoter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rewardExternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_t\",\"type\":\"address\"}],\"name\":\"setMasternodeContractForData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_t\",\"type\":\"address\"}],\"name\":\"setMiningContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"voteProposal\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"setVotingMinority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listAcceptedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenDetails\",\"outputs\":[{\"name\":\"ad\",\"type\":\"address\"},{\"name\":\"required\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"valid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"pushProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"reachedMajorityForTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"reachedMajority\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pastProposalTimeRules\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalPending\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalList\",\"outputs\":[{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"totalVotes\",\"type\":\"uint256\"},{\"name\":\"proposedOn\",\"type\":\"uint256\"},{\"name\":\"acceptedOn\",\"type\":\"uint256\"},{\"name\":\"proposalType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LastProposalCanDiscard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DataVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votersCountTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_previousContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ProposalID\",\"type\":\"uint256\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ProposalID\",\"type\":\"uint256\"}],\"name\":\"ProposalAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CaelumToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007600bf5112945f9f006c216d5d6db0df2806edc6","Library":"","SwarmSource":"bzzr://291711d9a848e18435dfd55244206d498f173b8e304bff9682aa5f9275a063bf"}]}