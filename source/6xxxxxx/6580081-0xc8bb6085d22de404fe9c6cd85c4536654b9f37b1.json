{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        uint256 c = _a / _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract GreenEthereus1 {\r\n    using SafeMath for uint;\r\n\r\n    address public owner;\r\n    address marketing;\r\n    address admin;\r\n\r\n    mapping (address => uint) index;\r\n    mapping (address => mapping (uint => uint)) deposit;\r\n    mapping (address => mapping (uint => uint)) finish;\r\n    mapping (address => uint) checkpoint;\r\n\r\n    mapping (address => address) referrers;\r\n    mapping (address => uint) refBonus;\r\n\r\n    event LogInvestment(address indexed _addr, uint _value);\r\n    event LogPayment(address indexed _addr, uint _value);\r\n    event LogReferralInvestment(address indexed _referrer, address indexed _referral, uint _value);\r\n\r\n    constructor(address _marketing, address _admin) public {\r\n        owner = msg.sender;\r\n        marketing = _marketing;\r\n        admin = _admin;\r\n    }\r\n\r\n    function renounceOwnership() external {\r\n        require(msg.sender == owner);\r\n        owner = 0x0;\r\n    }\r\n\r\n    function bytesToAddress(bytes _source) internal pure returns(address parsedreferrer) {\r\n        assembly {\r\n            parsedreferrer := mload(add(_source,0x14))\r\n        }\r\n        return parsedreferrer;\r\n    }\r\n\r\n    function setRef(uint _value) internal {\r\n        address _referrer = bytesToAddress(bytes(msg.data));\r\n        if (_referrer != msg.sender && getInfo3(_referrer) > 0) {\r\n            referrers[msg.sender] = _referrer;\r\n            marketing.transfer(msg.value * 7 / 50);\r\n            refBonus[msg.sender] += _value * 3 / 100;\r\n            refBonus[_referrer] += _value / 10;\r\n\r\n            emit LogReferralInvestment(_referrer, msg.sender, msg.value);\r\n        } else {\r\n            marketing.transfer(msg.value * 6 / 25);\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value < 50000000000000000) {\r\n            msg.sender.transfer(msg.value);\r\n            withdraw();\r\n        } else {\r\n            invest();\r\n        }\r\n    }\r\n\r\n    function invest() public payable {\r\n\r\n        require(msg.value >= 50000000000000000);\r\n        admin.transfer(msg.value * 3 / 100);\r\n\r\n        if (deposit[msg.sender][0] > 0 || refBonus[msg.sender] > 0) {\r\n            withdraw();\r\n            if (deposit[msg.sender][0] > 0) {\r\n                index[msg.sender] += 1;\r\n            }\r\n        }\r\n\r\n        checkpoint[msg.sender] = block.timestamp;\r\n        finish[msg.sender][index[msg.sender]] = block.timestamp + (20 * 1 days);\r\n        deposit[msg.sender][index[msg.sender]] = msg.value;\r\n\r\n        if (referrers[msg.sender] != 0x0) {\r\n            marketing.transfer(msg.value * 7 / 50);\r\n            refBonus[referrers[msg.sender]] += msg.value / 10;\r\n            emit LogReferralInvestment(referrers[msg.sender], msg.sender, msg.value);\r\n        } else if (msg.data.length == 20) {\r\n            setRef(msg.value);\r\n        } else {\r\n            marketing.transfer(msg.value * 6 / 25);\r\n        }\r\n\r\n        emit LogInvestment(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw() public {\r\n\r\n        uint _payout = refBonus[msg.sender];\r\n        refBonus[msg.sender] = 0;\r\n\r\n        _payout = _payout.add(getInfo3(msg.sender));\r\n\r\n        if (_payout > 0) {\r\n            checkpoint[msg.sender] = block.timestamp;\r\n            msg.sender.transfer(_payout);\r\n\r\n            emit LogPayment(msg.sender, _payout);\r\n        }\r\n    }\r\n\r\n    function getInfo1(address _address) public view returns(uint Invested) {\r\n        uint _sum;\r\n        for (uint i = 0; i <= index[_address]; i++) {\r\n            if (block.timestamp < finish[_address][i]) {\r\n                _sum += deposit[_address][i];\r\n            }\r\n        }\r\n        Invested = _sum;\r\n    }\r\n\r\n    function getInfo2(address _address, uint _number) public view returns(uint Deposit_N) {\r\n        if (block.timestamp < finish[_address][_number - 1]) {\r\n            Deposit_N = deposit[_address][_number - 1];\r\n        } else {\r\n            Deposit_N = 0;\r\n        }\r\n    }\r\n\r\n    function getInfo3(address _address) public view returns(uint Dividends) {\r\n\r\n        uint _payout;\r\n        uint _multiplier;\r\n\r\n        if (block.timestamp > checkpoint[_address] + 2 days) {\r\n            _multiplier = 1;\r\n        }\r\n\r\n        for (uint i = 0; i <= index[_address]; i++) {\r\n\r\n            if (checkpoint[_address] < finish[_address][i]) {\r\n\r\n                if (block.timestamp > finish[_address][i]) {\r\n\r\n                    if (finish[_address][i] > checkpoint[_address] + 2 days) {\r\n\r\n                        _payout = _payout.add((deposit[_address][i].mul(_multiplier.mul(12).add(70)).div(1000)).mul(finish[_address][i].sub(checkpoint[_address].add(_multiplier.mul(2 days)))).div(1 days));\r\n                        _payout = _payout.add(deposit[_address][i].mul(14).div(100).mul(_multiplier));\r\n\r\n                    } else {\r\n\r\n                        _payout = _payout.add((deposit[_address][i].mul(7).div(100)).mul(finish[_address][i].sub(checkpoint[_address])).div(1 days));\r\n\r\n                    }\r\n                    \r\n                } else {\r\n\r\n                    _payout = _payout.add((deposit[_address][i].mul(_multiplier.mul(12).add(70)).div(1000)).mul(block.timestamp.sub(checkpoint[_address].add(_multiplier.mul(2 days)))).div(1 days));\r\n                    _payout = _payout.add(deposit[_address][i].mul(14).div(100).mul(_multiplier));\r\n\r\n                }\r\n            }\r\n        }\r\n        Dividends = _payout;\r\n    }\r\n\r\n    function getInfo4(address _address) public view returns(uint Bonuses) {\r\n        Bonuses = refBonus[_address];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getInfo2\",\"outputs\":[{\"name\":\"Deposit_N\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInfo4\",\"outputs\":[{\"name\":\"Bonuses\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInfo1\",\"outputs\":[{\"name\":\"Invested\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInfo3\",\"outputs\":[{\"name\":\"Dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_marketing\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogReferralInvestment\",\"type\":\"event\"}]","ContractName":"GreenEthereus1","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000053e10ad589f223d88aa178d7c8fd2ee3716df863000000000000000000000000a3592653e52125c905041ed85a787540313df8d9","Library":"","SwarmSource":"bzzr://a852ac2c3b0903f6956f185c3406ad4cf0898bac613a974840117f7908181b00"}]}