{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary addressSet {\r\n    struct _addressSet {\r\n        address[] members;\r\n        mapping(address => uint) memberIndices;\r\n    }\r\n\r\n    function insert(_addressSet storage self, address other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(_addressSet storage self, address other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            address lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(_addressSet storage self, address other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(_addressSet storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface SnowflakeResolver {\r\n    function callOnSignUp() external returns (bool);\r\n    function onSignUp(string hydroId, uint allowance) external returns (bool);\r\n    function callOnRemoval() external returns (bool);\r\n    function onRemoval(string hydroId) external returns(bool);\r\n}\r\n\r\ninterface ClientRaindrop {\r\n    function getUserByAddress(address _address) external view returns (string userName);\r\n    function isSigned(\r\n        address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s\r\n    ) external pure returns (bool);\r\n}\r\n\r\ninterface ViaContract {\r\n    function snowflakeCall(address resolver, string hydroIdFrom, string hydroIdTo, uint amount, bytes _bytes) external;\r\n    function snowflakeCall(address resolver, string hydroIdFrom, address to, uint amount, bytes _bytes) external;\r\n}\r\n\r\ncontract Snowflake is Ownable {\r\n    using SafeMath for uint;\r\n    using addressSet for addressSet._addressSet;\r\n\r\n    // hydro token wrapper variable\r\n    mapping (string => uint) internal deposits;\r\n\r\n    // signature variables\r\n    uint signatureTimeout;\r\n    mapping (bytes32 => bool) signatureLog;\r\n\r\n    // lookup mappings -- accessible only by wrapper functions\r\n    mapping (string => Identity) internal directory;\r\n    mapping (address => string) internal addressDirectory;\r\n    mapping (bytes32 => string) internal initiatedAddressClaims;\r\n\r\n    // admin/contract variables\r\n    address public clientRaindropAddress;\r\n    address public hydroTokenAddress;\r\n\r\n    addressSet._addressSet resolverWhitelist;\r\n\r\n    constructor() public {\r\n        setSignatureTimeout(7200);\r\n    }\r\n\r\n    // identity structures\r\n    struct Identity {\r\n        address owner;\r\n        addressSet._addressSet addresses;\r\n        addressSet._addressSet resolvers;\r\n        mapping(address => uint) resolverAllowances;\r\n    }\r\n\r\n    // checks whether the given address is owned by a token (does not throw)\r\n    function hasToken(address _address) public view returns (bool) {\r\n        return bytes(addressDirectory[_address]).length != 0;\r\n    }\r\n\r\n    // enforces that a particular address has a token\r\n    modifier _hasToken(address _address, bool check) {\r\n        require(hasToken(_address) == check, \"The transaction sender does not have a Snowflake.\");\r\n        _;\r\n    }\r\n\r\n    // gets the HydroID for an address (throws if address doesn't have a HydroID or doesn't have a snowflake)\r\n    function getHydroId(address _address) public view returns (string hydroId) {\r\n        require(hasToken(_address), \"The address does not have a hydroId\");\r\n        return addressDirectory[_address];\r\n    }\r\n\r\n    // allows whitelisting of resolvers\r\n    function whitelistResolver(address resolver) public {\r\n        resolverWhitelist.insert(resolver);\r\n        emit ResolverWhitelisted(resolver);\r\n    }\r\n\r\n    function isWhitelisted(address resolver) public view returns(bool) {\r\n        return resolverWhitelist.contains(resolver);\r\n    }\r\n\r\n    function getWhitelistedResolvers() public view returns(address[]) {\r\n        return resolverWhitelist.members;\r\n    }\r\n\r\n    // set the signature timeout\r\n    function setSignatureTimeout(uint newTimeout) public {\r\n        require(newTimeout >= 1800, \"Timeout must be at least 30 minutes.\");\r\n        require(newTimeout <= 604800, \"Timeout must be less than a week.\");\r\n        signatureTimeout = newTimeout;\r\n    }\r\n\r\n    // set the raindrop and hydro token addresses\r\n    function setAddresses(address clientRaindrop, address hydroToken) public onlyOwner {\r\n        clientRaindropAddress = clientRaindrop;\r\n        hydroTokenAddress = hydroToken;\r\n    }\r\n\r\n    // token minting\r\n    function mintIdentityToken() public _hasToken(msg.sender, false) {\r\n        _mintIdentityToken(msg.sender);\r\n    }\r\n\r\n    function mintIdentityTokenDelegated(address _address, uint8 v, bytes32 r, bytes32 s)\r\n        public _hasToken(_address, false)\r\n    {\r\n        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\r\n        require(\r\n            clientRaindrop.isSigned(\r\n                _address, keccak256(abi.encodePacked(\"Create Snowflake\", _address)), v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n        _mintIdentityToken(_address);\r\n    }\r\n\r\n    function _mintIdentityToken(address _address) internal {\r\n        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\r\n        string memory hydroId = clientRaindrop.getUserByAddress(_address);\r\n\r\n        Identity storage identity = directory[hydroId];\r\n\r\n        identity.owner = _address;\r\n        identity.addresses.insert(_address);\r\n\r\n        addressDirectory[_address] = hydroId;\r\n\r\n        emit SnowflakeMinted(hydroId);\r\n    }\r\n\r\n    // wrappers that enable modifying resolvers\r\n    function addResolvers(address[] resolvers, uint[] withdrawAllowances) public _hasToken(msg.sender, true) {\r\n        _addResolvers(addressDirectory[msg.sender], resolvers, withdrawAllowances);\r\n    }\r\n\r\n    function addResolversDelegated(\r\n        string hydroId, address[] resolvers, uint[] withdrawAllowances, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) public\r\n    {\r\n        require(directory[hydroId].owner != address(0), \"Must initiate claim for a HydroID with a Snowflake\");\r\n        // solium-disable-next-line security/no-block-members\r\n        require(timestamp.add(signatureTimeout) > block.timestamp, \"Message was signed too long ago.\");\r\n    \r\n        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\r\n        require(\r\n            clientRaindrop.isSigned(\r\n                directory[hydroId].owner,\r\n                keccak256(abi.encodePacked(\"Add Resolvers\", resolvers, withdrawAllowances, timestamp)),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        _addResolvers(hydroId, resolvers, withdrawAllowances);\r\n    }\r\n\r\n    function _addResolvers(\r\n        string hydroId, address[] resolvers, uint[] withdrawAllowances\r\n    ) internal {\r\n        require(resolvers.length == withdrawAllowances.length, \"Malformed inputs.\");\r\n        Identity storage identity = directory[hydroId];\r\n\r\n        for (uint i; i < resolvers.length; i++) {\r\n            require(resolverWhitelist.contains(resolvers[i]), \"The given resolver is not on the whitelist.\");\r\n            require(!identity.resolvers.contains(resolvers[i]), \"Snowflake has already set this resolver.\");\r\n            SnowflakeResolver snowflakeResolver = SnowflakeResolver(resolvers[i]);\r\n            identity.resolvers.insert(resolvers[i]);\r\n            identity.resolverAllowances[resolvers[i]] = withdrawAllowances[i];\r\n            if (snowflakeResolver.callOnSignUp()) {\r\n                require(\r\n                    snowflakeResolver.onSignUp(hydroId, withdrawAllowances[i]),\r\n                    \"Sign up failure.\"\r\n                );\r\n            }\r\n            emit ResolverAdded(hydroId, resolvers[i], withdrawAllowances[i]);\r\n        }\r\n    }\r\n\r\n    function changeResolverAllowances(address[] resolvers, uint[] withdrawAllowances) \r\n        public _hasToken(msg.sender, true)\r\n    {\r\n        _changeResolverAllowances(addressDirectory[msg.sender], resolvers, withdrawAllowances);\r\n    }\r\n\r\n    function changeResolverAllowancesDelegated(\r\n        string hydroId, address[] resolvers, uint[] withdrawAllowances, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) public\r\n    {\r\n        require(directory[hydroId].owner != address(0), \"Must initiate claim for a HydroID with a Snowflake\");\r\n\r\n        bytes32 _hash = keccak256(\r\n            abi.encodePacked(\"Change Resolver Allowances\", resolvers, withdrawAllowances, timestamp)\r\n        );\r\n\r\n        require(signatureLog[_hash] == false, \"Signature was already submitted\");\r\n        signatureLog[_hash] = true;\r\n\r\n        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\r\n        require(clientRaindrop.isSigned(directory[hydroId].owner, _hash, v, r, s), \"Permission denied.\");\r\n\r\n        _changeResolverAllowances(hydroId, resolvers, withdrawAllowances);\r\n    }\r\n\r\n    function _changeResolverAllowances(string hydroId, address[] resolvers, uint[] withdrawAllowances) internal {\r\n        require(resolvers.length == withdrawAllowances.length, \"Malformed inputs.\");\r\n\r\n        Identity storage identity = directory[hydroId];\r\n\r\n        for (uint i; i < resolvers.length; i++) {\r\n            require(identity.resolvers.contains(resolvers[i]), \"Snowflake has not set this resolver.\");\r\n            identity.resolverAllowances[resolvers[i]] = withdrawAllowances[i];\r\n            emit ResolverAllowanceChanged(hydroId, resolvers[i], withdrawAllowances[i]);\r\n        }\r\n    }\r\n\r\n    function removeResolvers(address[] resolvers, bool force) public _hasToken(msg.sender, true) {\r\n        Identity storage identity = directory[addressDirectory[msg.sender]];\r\n\r\n        for (uint i; i < resolvers.length; i++) {\r\n            require(identity.resolvers.contains(resolvers[i]), \"Snowflake has not set this resolver.\");\r\n            identity.resolvers.remove(resolvers[i]);\r\n            delete identity.resolverAllowances[resolvers[i]];\r\n            if (!force) {\r\n                SnowflakeResolver snowflakeResolver = SnowflakeResolver(resolvers[i]);\r\n                if (snowflakeResolver.callOnRemoval()) {\r\n                    require(\r\n                        snowflakeResolver.onRemoval(addressDirectory[msg.sender]),\r\n                        \"Removal failure.\"\r\n                    );\r\n                }\r\n            }\r\n            emit ResolverRemoved(addressDirectory[msg.sender], resolvers[i]);\r\n        }\r\n    }\r\n\r\n    // functions to read token values (does not throw)\r\n    function getDetails(string hydroId) public view returns (\r\n        address owner,\r\n        address[] resolvers,\r\n        address[] ownedAddresses,\r\n        uint256 balance\r\n    ) {\r\n        Identity storage identity = directory[hydroId];\r\n        return (\r\n            identity.owner,\r\n            identity.resolvers.members,\r\n            identity.addresses.members,\r\n            deposits[hydroId]\r\n        );\r\n    }\r\n\r\n    // check resolver membership (does not throw)\r\n    function hasResolver(string hydroId, address resolver) public view returns (bool) {\r\n        Identity storage identity = directory[hydroId];\r\n        return identity.resolvers.contains(resolver);\r\n    }\r\n\r\n    // check address ownership (does not throw)\r\n    function ownsAddress(string hydroId, address _address) public view returns (bool) {\r\n        Identity storage identity = directory[hydroId];\r\n        return identity.addresses.contains(_address);\r\n    }\r\n\r\n    // check resolver allowances (does not throw)\r\n    function getResolverAllowance(string hydroId, address resolver) public view returns (uint withdrawAllowance) {\r\n        Identity storage identity = directory[hydroId];\r\n        return identity.resolverAllowances[resolver];\r\n    }\r\n \r\n    // allow contract to receive HYDRO tokens\r\n    function receiveApproval(address sender, uint amount, address _tokenAddress, bytes _bytes) public {\r\n        require(msg.sender == _tokenAddress, \"Malformed inputs.\");\r\n        require(_tokenAddress == hydroTokenAddress, \"Sender is not the HYDRO token smart contract.\");\r\n\r\n        address recipient;\r\n        if (_bytes.length == 20) {\r\n            assembly { // solium-disable-line security/no-inline-assembly\r\n                recipient := div(mload(add(add(_bytes, 0x20), 0)), 0x1000000000000000000000000)\r\n            }\r\n        } else {\r\n            recipient = sender;\r\n        }\r\n        require(hasToken(recipient), \"Invalid token recipient\");\r\n\r\n        ERC20 hydro = ERC20(_tokenAddress);\r\n        require(hydro.transferFrom(sender, address(this), amount), \"Unable to transfer token ownership.\");\r\n\r\n        deposits[addressDirectory[recipient]] = deposits[addressDirectory[recipient]].add(amount);\r\n\r\n        emit SnowflakeDeposit(addressDirectory[recipient], sender, amount);\r\n    }\r\n\r\n    function snowflakeBalance(string hydroId) public view returns (uint) {\r\n        return deposits[hydroId];\r\n    }\r\n\r\n    // transfer snowflake balance from one snowflake holder to another\r\n    function transferSnowflakeBalance(string hydroIdTo, uint amount) public _hasToken(msg.sender, true) {\r\n        _transfer(addressDirectory[msg.sender], hydroIdTo, amount);\r\n    }\r\n\r\n    // withdraw Snowflake balance to an external address\r\n    function withdrawSnowflakeBalance(address to, uint amount) public _hasToken(msg.sender, true) {\r\n        _withdraw(addressDirectory[msg.sender], to, amount);\r\n    }\r\n\r\n    // allows resolvers to transfer allowance amounts to other snowflakes (throws if unsuccessful)\r\n    function transferSnowflakeBalanceFrom(string hydroIdFrom, string hydroIdTo, uint amount) public {\r\n        handleAllowance(hydroIdFrom, amount);\r\n        _transfer(hydroIdFrom, hydroIdTo, amount);\r\n    }\r\n\r\n    // allows resolvers to withdraw allowance amounts to external addresses (throws if unsuccessful)\r\n    function withdrawSnowflakeBalanceFrom(string hydroIdFrom, address to, uint amount) public {\r\n        handleAllowance(hydroIdFrom, amount);\r\n        _withdraw(hydroIdFrom, to, amount);\r\n    }\r\n\r\n    // allows resolvers to send withdrawal amounts to arbitrary smart contracts 'to' hydroIds (throws if unsuccessful)\r\n    function withdrawSnowflakeBalanceFromVia(\r\n        string hydroIdFrom, address via, string hydroIdTo, uint amount, bytes _bytes\r\n    ) public {\r\n        handleAllowance(hydroIdFrom, amount);\r\n        _withdraw(hydroIdFrom, via, amount);\r\n        ViaContract viaContract = ViaContract(via);\r\n        viaContract.snowflakeCall(msg.sender, hydroIdFrom, hydroIdTo, amount, _bytes);\r\n    }\r\n\r\n    // allows resolvers to send withdrawal amounts 'to' addresses via arbitrary smart contracts \r\n    function withdrawSnowflakeBalanceFromVia(\r\n        string hydroIdFrom, address via, address to, uint amount, bytes _bytes\r\n    ) public {\r\n        handleAllowance(hydroIdFrom, amount);\r\n        _withdraw(hydroIdFrom, via, amount);\r\n        ViaContract viaContract = ViaContract(via);\r\n        viaContract.snowflakeCall(msg.sender, hydroIdFrom, to, amount, _bytes);\r\n    }\r\n\r\n    function _transfer(string hydroIdFrom, string hydroIdTo, uint amount) internal returns (bool) {\r\n        require(directory[hydroIdTo].owner != address(0), \"Must transfer to an HydroID with a Snowflake\");\r\n\r\n        require(deposits[hydroIdFrom] >= amount, \"Cannot withdraw more than the current deposit balance.\");\r\n        deposits[hydroIdFrom] = deposits[hydroIdFrom].sub(amount);\r\n        deposits[hydroIdTo] = deposits[hydroIdTo].add(amount);\r\n\r\n        emit SnowflakeTransfer(hydroIdFrom, hydroIdTo, amount);\r\n    }\r\n\r\n    function _withdraw(string hydroIdFrom, address to, uint amount) internal {\r\n        require(to != address(this), \"Cannot transfer to the Snowflake smart contract itself.\");\r\n\r\n        require(deposits[hydroIdFrom] >= amount, \"Cannot withdraw more than the current deposit balance.\");\r\n        deposits[hydroIdFrom] = deposits[hydroIdFrom].sub(amount);\r\n        ERC20 hydro = ERC20(hydroTokenAddress);\r\n        require(hydro.transfer(to, amount), \"Transfer was unsuccessful\");\r\n        emit SnowflakeWithdraw(to, amount);\r\n    }\r\n\r\n    function handleAllowance(string hydroIdFrom, uint amount) internal {\r\n        Identity storage identity = directory[hydroIdFrom];\r\n        require(identity.owner != address(0), \"Must withdraw from a HydroID with a Snowflake\");\r\n\r\n        // check that resolver-related details are correct\r\n        require(identity.resolvers.contains(msg.sender), \"Resolver has not been set by from tokenholder.\");\r\n        \r\n        if (identity.resolverAllowances[msg.sender] < amount) {\r\n            emit InsufficientAllowance(hydroIdFrom, msg.sender, identity.resolverAllowances[msg.sender], amount);\r\n            require(false, \"Insufficient Allowance\");\r\n        }\r\n\r\n        identity.resolverAllowances[msg.sender] = identity.resolverAllowances[msg.sender].sub(amount);\r\n    }\r\n\r\n    // address ownership functions\r\n    // to claim an address, users need to send a transaction from their snowflake address containing a sealed claim\r\n    // sealedClaims are: keccak256(abi.encodePacked(<address>, <secret>, <hydroId>)),\r\n    // where <address> is the address you'd like to claim, and <secret> is a SECRET bytes32 value.\r\n    function initiateClaimDelegated(string hydroId, bytes32 sealedClaim, uint8 v, bytes32 r, bytes32 s) public {\r\n        require(directory[hydroId].owner != address(0), \"Must initiate claim for a HydroID with a Snowflake\");\r\n\r\n        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\r\n        require(\r\n            clientRaindrop.isSigned(\r\n                directory[hydroId].owner, keccak256(abi.encodePacked(\"Initiate Claim\", sealedClaim)), v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        _initiateClaim(hydroId, sealedClaim);\r\n    }\r\n\r\n    function initiateClaim(bytes32 sealedClaim) public _hasToken(msg.sender, true) {\r\n        _initiateClaim(addressDirectory[msg.sender], sealedClaim);\r\n    }\r\n\r\n    function _initiateClaim(string hydroId, bytes32 sealedClaim) internal {\r\n        require(bytes(initiatedAddressClaims[sealedClaim]).length == 0, \"This sealed claim has been submitted.\");\r\n        initiatedAddressClaims[sealedClaim] = hydroId;\r\n    }\r\n\r\n    function finalizeClaim(bytes32 secret, string hydroId) public {\r\n        bytes32 possibleSealedClaim = keccak256(abi.encodePacked(msg.sender, secret, hydroId));\r\n        require(\r\n            bytes(initiatedAddressClaims[possibleSealedClaim]).length != 0, \"This sealed claim hasn't been submitted.\"\r\n        );\r\n\r\n        // ensure that the claim wasn't stolen by another HydroID during initialization\r\n        require(\r\n            keccak256(abi.encodePacked(initiatedAddressClaims[possibleSealedClaim])) ==\r\n            keccak256(abi.encodePacked(hydroId)),\r\n            \"Invalid signature.\"\r\n        );\r\n\r\n        directory[hydroId].addresses.insert(msg.sender);\r\n        addressDirectory[msg.sender] = hydroId;\r\n\r\n        emit AddressClaimed(msg.sender, hydroId);\r\n    }\r\n\r\n    function unclaim(address[] addresses) public _hasToken(msg.sender, true) {\r\n        for (uint i; i < addresses.length; i++) {\r\n            require(addresses[i] != directory[addressDirectory[msg.sender]].owner, \"Cannot unclaim owner address.\");\r\n            directory[addressDirectory[msg.sender]].addresses.remove(addresses[i]);\r\n            delete addressDirectory[addresses[i]];\r\n            emit AddressUnclaimed(addresses[i], addressDirectory[msg.sender]);\r\n        }\r\n    }\r\n\r\n    // events\r\n    event SnowflakeMinted(string hydroId);\r\n\r\n    event ResolverWhitelisted(address indexed resolver);\r\n\r\n    event ResolverAdded(string hydroId, address resolver, uint withdrawAllowance);\r\n    event ResolverAllowanceChanged(string hydroId, address resolver, uint withdrawAllowance);\r\n    event ResolverRemoved(string hydroId, address resolver);\r\n\r\n    event SnowflakeDeposit(string hydroId, address from, uint amount);\r\n    event SnowflakeTransfer(string hydroIdFrom, string hydroIdTo, uint amount);\r\n    event SnowflakeWithdraw(address to, uint amount);\r\n    event InsufficientAllowance(\r\n        string hydroId, address indexed resolver, uint currentAllowance, uint requestedWithdraw\r\n    );\r\n\r\n    event AddressClaimed(address indexed _address, string hydroId);\r\n    event AddressUnclaimed(address indexed _address, string hydroId);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getWhitelistedResolvers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"}],\"name\":\"getDetails\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"ownedAddresses\",\"type\":\"address[]\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"},{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"getResolverAllowance\",\"outputs\":[{\"name\":\"withdrawAllowance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clientRaindropAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sealedClaim\",\"type\":\"bytes32\"}],\"name\":\"initiateClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"},{\"name\":\"sealedClaim\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"initiateClaimDelegated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroIdFrom\",\"type\":\"string\"},{\"name\":\"via\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"withdrawSnowflakeBalanceFromVia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"removeResolvers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroIdFrom\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSnowflakeBalanceFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"withdrawAllowances\",\"type\":\"uint256[]\"}],\"name\":\"changeResolverAllowances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTimeout\",\"type\":\"uint256\"}],\"name\":\"setSignatureTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hydroTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"},{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"hasResolver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"},{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"withdrawAllowances\",\"type\":\"uint256[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"addResolversDelegated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ownsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"withdrawAllowances\",\"type\":\"uint256[]\"}],\"name\":\"addResolvers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"clientRaindrop\",\"type\":\"address\"},{\"name\":\"hydroToken\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secret\",\"type\":\"bytes32\"},{\"name\":\"hydroId\",\"type\":\"string\"}],\"name\":\"finalizeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getHydroId\",\"outputs\":[{\"name\":\"hydroId\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hasToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"},{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"withdrawAllowances\",\"type\":\"uint256[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"changeResolverAllowancesDelegated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroIdFrom\",\"type\":\"string\"},{\"name\":\"hydroIdTo\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferSnowflakeBalanceFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSnowflakeBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hydroId\",\"type\":\"string\"}],\"name\":\"snowflakeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"whitelistResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintIdentityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroIdFrom\",\"type\":\"string\"},{\"name\":\"via\",\"type\":\"address\"},{\"name\":\"hydroIdTo\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"withdrawSnowflakeBalanceFromVia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintIdentityTokenDelegated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hydroIdTo\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferSnowflakeBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"unclaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"}],\"name\":\"SnowflakeMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"ResolverWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAllowance\",\"type\":\"uint256\"}],\"name\":\"ResolverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAllowance\",\"type\":\"uint256\"}],\"name\":\"ResolverAllowanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"ResolverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hydroIdFrom\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"hydroIdTo\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentAllowance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestedWithdraw\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"}],\"name\":\"AddressClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hydroId\",\"type\":\"string\"}],\"name\":\"AddressUnclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Snowflake","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"addressSet:Ae9C078C2D5a2701Ce0FF2962c9E3A0f06Fd4601","SwarmSource":"bzzr://45b9c38a4e2f259368ceb341b1f4ede9ff3fdbda39169bc389a917749886a053"}]}