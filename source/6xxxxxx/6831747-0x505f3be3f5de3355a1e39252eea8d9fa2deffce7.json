{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n\r\n/// general helpers.\r\n/// `internal` so they get compiled into contracts using them.\r\nlibrary Helpers {\r\n    /// returns whether `array` contains `value`.\r\n    function addressArrayContains(address[] array, address value) internal pure returns (bool) {\r\n        for (uint256 i = 0; i < array.length; i++) {\r\n            if (array[i] == value) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // returns the digits of `inputValue` as a string.\r\n    // example: `uintToString(12345678)` returns `\"12345678\"`\r\n    function uintToString(uint256 inputValue) internal pure returns (string) {\r\n        // figure out the length of the resulting string\r\n        uint256 length = 0;\r\n        uint256 currentValue = inputValue;\r\n        do {\r\n            length++;\r\n            currentValue /= 10;\r\n        } while (currentValue != 0);\r\n        // allocate enough memory\r\n        bytes memory result = new bytes(length);\r\n        // construct the string backwards\r\n        uint256 i = length - 1;\r\n        currentValue = inputValue;\r\n        do {\r\n            result[i--] = byte(48 + currentValue % 10);\r\n            currentValue /= 10;\r\n        } while (currentValue != 0);\r\n        return string(result);\r\n    }\r\n\r\n    /// returns whether signatures (whose components are in `vs`, `rs`, `ss`)\r\n    /// contain `requiredSignatures` distinct correct signatures\r\n    /// where signer is in `allowed_signers`\r\n    /// that signed `message`\r\n    function hasEnoughValidSignatures(bytes message, uint8[] vs, bytes32[] rs, bytes32[] ss, address[] allowed_signers, uint256 requiredSignatures) internal pure returns (bool) {\r\n        // not enough signatures\r\n        if (vs.length < requiredSignatures) {\r\n            return false;\r\n        }\r\n\r\n        var hash = MessageSigning.hashMessage(message);\r\n        var encountered_addresses = new address[](allowed_signers.length);\r\n\r\n        for (uint256 i = 0; i < requiredSignatures; i++) {\r\n            var recovered_address = ecrecover(hash, vs[i], rs[i], ss[i]);\r\n            // only signatures by addresses in `addresses` are allowed\r\n            if (!addressArrayContains(allowed_signers, recovered_address)) {\r\n                return false;\r\n            }\r\n            // duplicate signatures are not allowed\r\n            if (addressArrayContains(encountered_addresses, recovered_address)) {\r\n                return false;\r\n            }\r\n            encountered_addresses[i] = recovered_address;\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// Library used only to test Helpers library via rpc calls\r\nlibrary HelpersTest {\r\n    function addressArrayContains(address[] array, address value) public pure returns (bool) {\r\n        return Helpers.addressArrayContains(array, value);\r\n    }\r\n\r\n    function uintToString(uint256 inputValue) public pure returns (string str) {\r\n        return Helpers.uintToString(inputValue);\r\n    }\r\n\r\n    function hasEnoughValidSignatures(bytes message, uint8[] vs, bytes32[] rs, bytes32[] ss, address[] addresses, uint256 requiredSignatures) public pure returns (bool) {\r\n        return Helpers.hasEnoughValidSignatures(message, vs, rs, ss, addresses, requiredSignatures);\r\n    }\r\n}\r\n\r\n\r\n// helpers for message signing.\r\n// `internal` so they get compiled into contracts using them.\r\nlibrary MessageSigning {\r\n    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {\r\n        require(signature.length == 65);\r\n        bytes32 r;\r\n        bytes32 s;\r\n        bytes1 v;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := mload(add(signature, 0x60))\r\n        }\r\n        return ecrecover(hashMessage(message), uint8(v), r, s);\r\n    }\r\n\r\n    function hashMessage(bytes message) internal pure returns (bytes32) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\r\n        return keccak256(prefix, Helpers.uintToString(message.length), message);\r\n    }\r\n}\r\n\r\n\r\n/// Library used only to test MessageSigning library via rpc calls\r\nlibrary MessageSigningTest {\r\n    function recoverAddressFromSignedMessage(bytes signature, bytes message) public pure returns (address) {\r\n        return MessageSigning.recoverAddressFromSignedMessage(signature, message);\r\n    }\r\n}\r\n\r\n\r\nlibrary Message {\r\n    // layout of message :: bytes:\r\n    // offset  0: 32 bytes :: uint256 (big endian) - message length (not part of message. any `bytes` begins with the length in memory)\r\n    // offset 32: 20 bytes :: address - recipient address\r\n    // offset 52: 32 bytes :: uint256 (big endian) - value\r\n    // offset 84: 32 bytes :: bytes32 - transaction hash\r\n    // offset 116: 32 bytes :: uint256 (big endian) - main gas price\r\n\r\n    // mload always reads 32 bytes.\r\n    // if mload reads an address it only interprets the last 20 bytes as the address.\r\n    // so we can and have to start reading recipient at offset 20 instead of 32.\r\n    // if we were to read at 32 the address would contain part of value and be corrupted.\r\n    // when reading from offset 20 mload will ignore 12 bytes followed\r\n    // by the 20 recipient address bytes and correctly convert it into an address.\r\n    // this saves some storage/gas over the alternative solution\r\n    // which is padding address to 32 bytes and reading recipient at offset 32.\r\n    // for more details see discussion in:\r\n    // https://github.com/paritytech/parity-bridge/issues/61\r\n\r\n    function getRecipient(bytes message) internal pure returns (address) {\r\n        address recipient;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            recipient := mload(add(message, 20))\r\n        }\r\n        return recipient;\r\n    }\r\n\r\n    function getValue(bytes message) internal pure returns (uint256) {\r\n        uint256 value;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            value := mload(add(message, 52))\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function getTransactionHash(bytes message) internal pure returns (bytes32) {\r\n        bytes32 hash;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            hash := mload(add(message, 84))\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    function getMainGasPrice(bytes message) internal pure returns (uint256) {\r\n        uint256 gasPrice;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            gasPrice := mload(add(message, 116))\r\n        }\r\n        return gasPrice;\r\n    }\r\n}\r\n\r\n\r\n/// Library used only to test Message library via rpc calls\r\nlibrary MessageTest {\r\n    function getRecipient(bytes message) public pure returns (address) {\r\n        return Message.getRecipient(message);\r\n    }\r\n\r\n    function getValue(bytes message) public pure returns (uint256) {\r\n        return Message.getValue(message);\r\n    }\r\n\r\n    function getTransactionHash(bytes message) public pure returns (bytes32) {\r\n        return Message.getTransactionHash(message);\r\n    }\r\n\r\n    function getMainGasPrice(bytes message) public pure returns (uint256) {\r\n        return Message.getMainGasPrice(message);\r\n    }\r\n}\r\n\r\n\r\ncontract MainBridge {\r\n    /// Number of authorities signatures required to withdraw the money.\r\n    ///\r\n    /// Must be lesser than number of authorities.\r\n    uint256 public requiredSignatures;\r\n\r\n    /// The gas cost of calling `MainBridge.withdraw`.\r\n    ///\r\n    /// Is subtracted from `value` on withdraw.\r\n    /// recipient pays the relaying authority for withdraw.\r\n    /// this shuts down attacks that exhaust authorities funds on main chain.\r\n    uint256 public estimatedGasCostOfWithdraw;\r\n\r\n    /// reject deposits that would increase `this.balance` beyond this value.\r\n    /// security feature:\r\n    /// limits the total amount of mainnet ether that can be lost\r\n    /// if the bridge is faulty or compromised in any way!\r\n    /// set to 0 to disable.\r\n    uint256 public maxTotalMainContractBalance;\r\n\r\n    /// reject deposits whose `msg.value` is higher than this value.\r\n    /// security feature.\r\n    /// set to 0 to disable.\r\n    uint256 public maxSingleDepositValue;\r\n\r\n    /// Contract authorities.\r\n    address[] public authorities;\r\n\r\n    /// Used side transaction hashes.\r\n    mapping (bytes32 => bool) public withdraws;\r\n\r\n    /// Event created on money deposit.\r\n    event Deposit (address recipient, uint256 value);\r\n\r\n    /// Event created on money withdraw.\r\n    event Withdraw (address recipient, uint256 value, bytes32 transactionHash);\r\n\r\n    /// Constructor.\r\n    function MainBridge(\r\n        uint256 requiredSignaturesParam,\r\n        address[] authoritiesParam,\r\n        uint256 estimatedGasCostOfWithdrawParam,\r\n        uint256 maxTotalMainContractBalanceParam,\r\n        uint256 maxSingleDepositValueParam\r\n    ) public\r\n    {\r\n        require(requiredSignaturesParam != 0);\r\n        require(requiredSignaturesParam <= authoritiesParam.length);\r\n        requiredSignatures = requiredSignaturesParam;\r\n        authorities = authoritiesParam;\r\n        estimatedGasCostOfWithdraw = estimatedGasCostOfWithdrawParam;\r\n        maxTotalMainContractBalance = maxTotalMainContractBalanceParam;\r\n        maxSingleDepositValue = maxSingleDepositValueParam;\r\n    }\r\n\r\n    /// Should be used to deposit money.\r\n    function () public payable {\r\n        require(maxSingleDepositValue == 0 || msg.value <= maxSingleDepositValue);\r\n        // the value of `this.balance` in payable methods is increased\r\n        // by `msg.value` before the body of the payable method executes\r\n        require(maxTotalMainContractBalance == 0 || this.balance <= maxTotalMainContractBalance);\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /// Called by the bridge node processes on startup\r\n    /// to determine early whether the address pointing to the main\r\n    /// bridge contract is misconfigured.\r\n    /// so we can provide a helpful error message instead of the very\r\n    /// unhelpful errors encountered otherwise.\r\n    function isMainBridgeContract() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /// final step of a withdraw.\r\n    /// checks that `requiredSignatures` `authorities` have signed of on the `message`.\r\n    /// then transfers `value` to `recipient` (both extracted from `message`).\r\n    /// see message library above for a breakdown of the `message` contents.\r\n    /// `vs`, `rs`, `ss` are the components of the signatures.\r\n\r\n    /// anyone can call this, provided they have the message and required signatures!\r\n    /// only the `authorities` can create these signatures.\r\n    /// `requiredSignatures` authorities can sign arbitrary `message`s\r\n    /// transfering any ether `value` out of this contract to `recipient`.\r\n    /// bridge users must trust a majority of `requiredSignatures` of the `authorities`.\r\n    function withdraw(uint8[] vs, bytes32[] rs, bytes32[] ss, bytes message) public {\r\n        require(message.length == 116);\r\n\r\n        // check that at least `requiredSignatures` `authorities` have signed `message`\r\n        require(Helpers.hasEnoughValidSignatures(message, vs, rs, ss, authorities, requiredSignatures));\r\n\r\n        address recipient = Message.getRecipient(message);\r\n        uint256 value = Message.getValue(message);\r\n        bytes32 hash = Message.getTransactionHash(message);\r\n        uint256 mainGasPrice = Message.getMainGasPrice(message);\r\n\r\n        // if the recipient calls `withdraw` they can choose the gas price freely.\r\n        // if anyone else calls `withdraw` they have to use the gas price\r\n        // `mainGasPrice` specified by the user initiating the withdraw.\r\n        // this is a security mechanism designed to shut down\r\n        // malicious senders setting extremely high gas prices\r\n        // and effectively burning recipients withdrawn value.\r\n        // see https://github.com/paritytech/parity-bridge/issues/112\r\n        // for further explanation.\r\n        require((recipient == msg.sender) || (tx.gasprice == mainGasPrice));\r\n\r\n        // The following two statements guard against reentry into this function.\r\n        // Duplicated withdraw or reentry.\r\n        require(!withdraws[hash]);\r\n        // Order of operations below is critical to avoid TheDAO-like re-entry bug\r\n        withdraws[hash] = true;\r\n\r\n        uint256 estimatedWeiCostOfWithdraw = estimatedGasCostOfWithdraw * mainGasPrice;\r\n\r\n        // charge recipient for relay cost\r\n        uint256 valueRemainingAfterSubtractingCost = value - estimatedWeiCostOfWithdraw;\r\n\r\n        // pay out recipient\r\n        recipient.transfer(valueRemainingAfterSubtractingCost);\r\n\r\n        // refund relay cost to relaying authority\r\n        msg.sender.transfer(estimatedWeiCostOfWithdraw);\r\n\r\n        Withdraw(recipient, valueRemainingAfterSubtractingCost, hash);\r\n    }\r\n}\r\n\r\n\r\ncontract SideBridge {\r\n    // following is the part of SideBridge that implements an ERC20 token.\r\n    // ERC20 spec: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n\r\n    uint256 public totalSupply;\r\n\r\n    string public name = \"SideBridge\";\r\n    // BETH = bridged ether\r\n    string public symbol = \"BETH\";\r\n    // 1-1 mapping of ether to tokens\r\n    uint8 public decimals = 18;\r\n\r\n    /// maps addresses to their token balances\r\n    mapping (address => uint256) public balances;\r\n\r\n    // owner of account approves the transfer of an amount by another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    /// Event created on money transfer\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\r\n    // returns the ERC20 token balance of the given address\r\n    function balanceOf(address tokenOwner) public view returns (uint256) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    /// Transfer `value` to `recipient` on this `side` chain.\r\n    ///\r\n    /// does not affect `main` chain. does not do a relay.\r\n    /// as specificed in ERC20 this doesn't fail if tokens == 0.\r\n    function transfer(address recipient, uint256 tokens) public returns (bool) {\r\n        require(balances[msg.sender] >= tokens);\r\n        // fails if there is an overflow\r\n        require(balances[recipient] + tokens >= balances[recipient]);\r\n\r\n        balances[msg.sender] -= tokens;\r\n        balances[recipient] += tokens;\r\n        Transfer(msg.sender, recipient, tokens);\r\n        return true;\r\n    }\r\n\r\n    // following is the part of SideBridge that is concerned\r\n    // with the part of the ERC20 standard responsible for giving others spending rights\r\n    // and spending others tokens\r\n\r\n    // created when `approve` is executed to mark that\r\n    // `tokenOwner` has approved `spender` to spend `tokens` of his tokens\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n\r\n    // allow `spender` to withdraw from your account, multiple times, up to the `tokens` amount.\r\n    // calling this function repeatedly overwrites the current allowance.\r\n    function approve(address spender, uint256 tokens) public returns (bool) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // returns how much `spender` is allowed to spend of `owner`s tokens\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool) {\r\n        // `from` has enough tokens\r\n        require(balances[from] >= tokens);\r\n        // `sender` is allowed to move `tokens` from `from`\r\n        require(allowed[from][msg.sender] >= tokens);\r\n        // fails if there is an overflow\r\n        require(balances[to] + tokens >= balances[to]);\r\n\r\n        balances[to] += tokens;\r\n        balances[from] -= tokens;\r\n        allowed[from][msg.sender] -= tokens;\r\n\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // following is the part of SideBridge that is\r\n    // no longer part of ERC20 and is concerned with\r\n    // with moving tokens from and to MainBridge\r\n\r\n    struct SignaturesCollection {\r\n        /// Signed message.\r\n        bytes message;\r\n        /// Authorities who signed the message.\r\n        address[] authorities;\r\n        /// Signatures\r\n        bytes[] signatures;\r\n    }\r\n\r\n    /// Number of authorities signatures required to withdraw the money.\r\n    ///\r\n    /// Must be less than number of authorities.\r\n    uint256 public requiredSignatures;\r\n\r\n    uint256 public estimatedGasCostOfWithdraw;\r\n\r\n    /// Contract authorities.\r\n    address[] public authorities;\r\n\r\n    /// Pending deposits and authorities who confirmed them\r\n    mapping (bytes32 => address[]) deposits;\r\n\r\n    /// Pending signatures and authorities who confirmed them\r\n    mapping (bytes32 => SignaturesCollection) signatures;\r\n\r\n    /// triggered when an authority confirms a deposit\r\n    event DepositConfirmation(address recipient, uint256 value, bytes32 transactionHash);\r\n\r\n    /// triggered when enough authorities have confirmed a deposit\r\n    event Deposit(address recipient, uint256 value, bytes32 transactionHash);\r\n\r\n    /// Event created on money withdraw.\r\n    event Withdraw(address recipient, uint256 value, uint256 mainGasPrice);\r\n\r\n    event WithdrawSignatureSubmitted(bytes32 messageHash);\r\n\r\n    /// Collected signatures which should be relayed to main chain.\r\n    event CollectedSignatures(address indexed authorityResponsibleForRelay, bytes32 messageHash);\r\n\r\n    function SideBridge(\r\n        uint256 _requiredSignatures,\r\n        address[] _authorities,\r\n        uint256 _estimatedGasCostOfWithdraw\r\n    ) public\r\n    {\r\n        require(_requiredSignatures != 0);\r\n        require(_requiredSignatures <= _authorities.length);\r\n        requiredSignatures = _requiredSignatures;\r\n        authorities = _authorities;\r\n        estimatedGasCostOfWithdraw = _estimatedGasCostOfWithdraw;\r\n    }\r\n\r\n    // Called by the bridge node processes on startup\r\n    // to determine early whether the address pointing to the side\r\n    // bridge contract is misconfigured.\r\n    // so we can provide a helpful error message instead of the\r\n    // very unhelpful errors encountered otherwise.\r\n    function isSideBridgeContract() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /// require that sender is an authority\r\n    modifier onlyAuthority() {\r\n        require(Helpers.addressArrayContains(authorities, msg.sender));\r\n        _;\r\n    }\r\n\r\n    /// Used to deposit money to the contract.\r\n    ///\r\n    /// deposit recipient (bytes20)\r\n    /// deposit value (uint256)\r\n    /// mainnet transaction hash (bytes32) // to avoid transaction duplication\r\n    function deposit(address recipient, uint256 value, bytes32 transactionHash) public onlyAuthority() {\r\n        // Protection from misbehaving authority\r\n        var hash = keccak256(recipient, value, transactionHash);\r\n\r\n        // don't allow authority to confirm deposit twice\r\n        require(!Helpers.addressArrayContains(deposits[hash], msg.sender));\r\n\r\n        deposits[hash].push(msg.sender);\r\n\r\n        // TODO: this may cause troubles if requiredSignatures len is changed\r\n        if (deposits[hash].length != requiredSignatures) {\r\n            DepositConfirmation(recipient, value, transactionHash);\r\n            return;\r\n        }\r\n\r\n        balances[recipient] += value;\r\n        // mints tokens\r\n        totalSupply += value;\r\n        // ERC20 specifies: a token contract which creates new tokens\r\n        // SHOULD trigger a Transfer event with the _from address\r\n        // set to 0x0 when tokens are created.\r\n        Transfer(0x0, recipient, value);\r\n        Deposit(recipient, value, transactionHash);\r\n    }\r\n\r\n    /// Transfer `value` from `msg.sender`s local balance (on `side` chain) to `recipient` on `main` chain.\r\n    ///\r\n    /// immediately decreases `msg.sender`s local balance.\r\n    /// emits a `Withdraw` event which will be picked up by the bridge authorities.\r\n    /// bridge authorities will then sign off (by calling `submitSignature`) on a message containing `value`,\r\n    /// `recipient` and the `hash` of the transaction on `side` containing the `Withdraw` event.\r\n    /// once `requiredSignatures` are collected a `CollectedSignatures` event will be emitted.\r\n    /// an authority will pick up `CollectedSignatures` an call `MainBridge.withdraw`\r\n    /// which transfers `value - relayCost` to `recipient` completing the transfer.\r\n    function transferToMainViaRelay(address recipient, uint256 value, uint256 mainGasPrice) public {\r\n        require(balances[msg.sender] >= value);\r\n        // don't allow 0 value transfers to main\r\n        require(value > 0);\r\n\r\n        uint256 estimatedWeiCostOfWithdraw = estimatedGasCostOfWithdraw * mainGasPrice;\r\n        require(value > estimatedWeiCostOfWithdraw);\r\n\r\n        balances[msg.sender] -= value;\r\n        // burns tokens\r\n        totalSupply -= value;\r\n        // in line with the transfer event from `0x0` on token creation\r\n        // recommended by ERC20 (see implementation of `deposit` above)\r\n        // we trigger a Transfer event to `0x0` on token destruction\r\n        Transfer(msg.sender, 0x0, value);\r\n        Withdraw(recipient, value, mainGasPrice);\r\n    }\r\n\r\n    /// Should be used as sync tool\r\n    ///\r\n    /// Message is a message that should be relayed to main chain once authorities sign it.\r\n    ///\r\n    /// for withdraw message contains:\r\n    /// withdrawal recipient (bytes20)\r\n    /// withdrawal value (uint256)\r\n    /// side transaction hash (bytes32) // to avoid transaction duplication\r\n    function submitSignature(bytes signature, bytes message) public onlyAuthority() {\r\n        // ensure that `signature` is really `message` signed by `msg.sender`\r\n        require(msg.sender == MessageSigning.recoverAddressFromSignedMessage(signature, message));\r\n\r\n        require(message.length == 116);\r\n        var hash = keccak256(message);\r\n\r\n        // each authority can only provide one signature per message\r\n        require(!Helpers.addressArrayContains(signatures[hash].authorities, msg.sender));\r\n        signatures[hash].message = message;\r\n        signatures[hash].authorities.push(msg.sender);\r\n        signatures[hash].signatures.push(signature);\r\n\r\n        // TODO: this may cause troubles if requiredSignatures len is changed\r\n        if (signatures[hash].authorities.length == requiredSignatures) {\r\n            CollectedSignatures(msg.sender, hash);\r\n        } else {\r\n            WithdrawSignatureSubmitted(hash);\r\n        }\r\n    }\r\n\r\n    function hasAuthoritySignedMainToSide(address authority, address recipient, uint256 value, bytes32 mainTxHash) public view returns (bool) {\r\n        var hash = keccak256(recipient, value, mainTxHash);\r\n\r\n        return Helpers.addressArrayContains(deposits[hash], authority);\r\n    }\r\n\r\n    function hasAuthoritySignedSideToMain(address authority, bytes message) public view returns (bool) {\r\n        require(message.length == 116);\r\n        var messageHash = keccak256(message);\r\n        return Helpers.addressArrayContains(signatures[messageHash].authorities, authority);\r\n    }\r\n\r\n    /// Get signature\r\n    function signature(bytes32 messageHash, uint256 index) public view returns (bytes) {\r\n        return signatures[messageHash].signatures[index];\r\n    }\r\n\r\n    /// Get message\r\n    function message(bytes32 message_hash) public view returns (bytes) {\r\n        return signatures[message_hash].message;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorities\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalMainContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainBridgeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSingleDepositValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"estimatedGasCostOfWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"},{\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdraws\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"requiredSignaturesParam\",\"type\":\"uint256\"},{\"name\":\"authoritiesParam\",\"type\":\"address[]\"},{\"name\":\"estimatedGasCostOfWithdrawParam\",\"type\":\"uint256\"},{\"name\":\"maxTotalMainContractBalanceParam\",\"type\":\"uint256\"},{\"name\":\"maxSingleDepositValueParam\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"MainBridge","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c2e2177e18bf454d0d114a53ea101b6a1d04ee1f","Library":"","SwarmSource":"bzzr://066923d240ec5c191ea6e94cd05df6e04c77faf9b071fb6391e30c190f05e0d1"}]}