{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Ownable {\r\n    \r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    \r\n    \r\n    /**\r\n     * Constructor assigns ownership to the address used to deploy the contract.\r\n     * */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Any function with this modifier in its method signature can only be executed by\r\n     * the owner of the contract. Any attempt made by any other account to invoke the \r\n     * functions with this modifier will result in a loss of gas and the contract's state\r\n     * will remain untampered.\r\n     * */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Allows for the transfer of ownership to another address;\r\n     * \r\n     * @param _newOwner The address to be assigned new ownership.\r\n     * */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(\r\n            _newOwner != address(0)\r\n            && _newOwner != owner \r\n        );\r\n        OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Contract acts as an interface between the DappleAirdrops contract and all ERC20 compliant\r\n * tokens. \r\n * */\r\ncontract ERCInterface {\r\n    function transferFrom(address _from, address _to, uint256 _value) public;\r\n    function balanceOf(address who) constant public returns (uint256);\r\n    function allowance(address owner, address spender) constant public returns (uint256);\r\n    function transfer(address to, uint256 value) public returns(bool);\r\n}\r\n\r\n\r\n\r\ncontract DappleAirdrops is Ownable {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    mapping (address => uint256) public bonusDropsOf;\r\n    mapping (address => uint256) public ethBalanceOf;\r\n    mapping (address => bool) public tokenIsBanned;\r\n    mapping (address => uint256) public trialDrops;\r\n        \r\n    uint256 public rate;\r\n    uint256 public dropUnitPrice;\r\n    uint256 public bonus;\r\n    uint256 public maxDropsPerTx;\r\n    uint256 public maxTrialDrops;\r\n    string public constant website = \"www.dappleairdrops.com\";\r\n    \r\n    event BonusCreditGranted(address indexed to, uint256 credit);\r\n    event BonusCreditRevoked(address indexed from, uint256 credit);\r\n    event CreditPurchased(address indexed by, uint256 etherValue, uint256 credit);\r\n    event AirdropInvoked(address indexed by, uint256 creditConsumed);\r\n    event BonustChanged(uint256 from, uint256 to);\r\n    event TokenBanned(address indexed tokenAddress);\r\n    event TokenUnbanned(address indexed tokenAddress);\r\n    event EthWithdrawn(address indexed by, uint256 totalWei);\r\n    event RateChanged(uint256 from, uint256 to);\r\n    event MaxDropsChanged(uint256 from, uint256 to);\r\n    event RefundIssued(address indexed to, uint256 totalWei);\r\n    event ERC20TokensWithdrawn(address token, address sentTo, uint256 value);\r\n\r\n    \r\n    /**\r\n     * Constructor sets the rate such that 1 ETH = 10,000 credits (i.e., 10,000 airdrop recipients)\r\n     * which equates to a unit price of 0.00001 ETH per airdrop recipient. The bonus percentage\r\n     * is set to 20% but is subject to change. Bonus credits will only be issued after once normal\r\n     * credits have been used (unless credits have been granted to an address by the owner of the \r\n     * contract).\r\n     * */\r\n    function DappleAirdrops() public {\r\n        rate = 10000;\r\n        dropUnitPrice = 1e14; \r\n        bonus = 20;\r\n        maxDropsPerTx = 1000000;\r\n        maxTrialDrops = 1000000;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Checks whether or not an ERC20 token has used its free trial of 100 drops. This is a constant \r\n     * function which does not alter the state of the contract and therefore does not require any gas \r\n     * or a signature to be executed. \r\n     * \r\n     * @param _addressOfToken The address of the token being queried.\r\n     * \r\n     * @return true if the token being queried has not used its 100 first free trial drops, false\r\n     * otherwise.\r\n     * */\r\n    function tokenHasFreeTrial(address _addressOfToken) public view returns(bool) {\r\n        return trialDrops[_addressOfToken] < maxTrialDrops;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Checks how many remaining free trial drops a token has.\r\n     * \r\n     * @param _addressOfToken the address of the token being queried.\r\n     * \r\n     * @return the total remaining free trial drops of a token.\r\n     * */\r\n    function getRemainingTrialDrops(address _addressOfToken) public view returns(uint256) {\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            return maxTrialDrops.sub(trialDrops[_addressOfToken]);\r\n        } \r\n        return 0;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the price of drops to be changed by the owner of the contract. Any attempt made by \r\n     * any other account to invoke the function will result in a loss of gas and the price will remain \r\n     * untampered.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function setRate(uint256 _newRate) public onlyOwner returns(bool) {\r\n        require(\r\n            _newRate != rate \r\n            && _newRate > 0\r\n        );\r\n        RateChanged(rate, _newRate);\r\n        rate = _newRate;\r\n        uint256 eth = 1 ether;\r\n        dropUnitPrice = eth.div(rate);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function getRate() public view returns(uint256) {\r\n        return rate;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Allows for the maximum number of participants to be queried. This is a constant function \r\n     * which does not alter the state of the contract and therefore does not require any gas or a\r\n     * signature to be executed. \r\n     * \r\n     * @return the maximum number of recipients per transaction.\r\n     * */\r\n    function getMaxDropsPerTx() public view returns(uint256) {\r\n        return maxDropsPerTx;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the maximum number of recipients per transaction to be changed by the owner. \r\n     * Any attempt made by any other account to invoke the function will result in a loss of gas \r\n     * and the maximum number of recipients will remain untampered.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function setMaxDrops(uint256 _maxDrops) public onlyOwner returns(bool) {\r\n        require(_maxDrops >= 1000000);\r\n        MaxDropsChanged(maxDropsPerTx, _maxDrops);\r\n        maxDropsPerTx = _maxDrops;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Allows for the bonus to be changed at any point in time by the owner of the contract. Any\r\n     * attempt made by any other account to invoke the function will result in a loss of gas and \r\n     * the bonus will remain untampered.\r\n     * \r\n     * @param _newBonus The value of the new bonus to be set.\r\n     * */\r\n    function setBonus(uint256 _newBonus) public onlyOwner returns(bool) {\r\n        require(bonus != _newBonus);\r\n        BonustChanged(bonus, _newBonus);\r\n        bonus = _newBonus;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for bonus drops to be granted to a recipient address by the owner of the contract. \r\n     * Any attempt made by any other account to invoke the function will result in a loss of gas \r\n     * and the bonus drops of the recipient will remain untampered.\r\n     * \r\n     * @param _addr The address which will receive bonus credits.\r\n     * @param _bonusDrops The amount of bonus drops to be granted.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function grantBonusDrops(address _addr, uint256 _bonusDrops) public onlyOwner returns(bool) {\r\n        require(\r\n            _addr != address(0) \r\n            && _bonusDrops > 0\r\n        );\r\n        bonusDropsOf[_addr] = bonusDropsOf[_addr].add(_bonusDrops);\r\n        BonusCreditGranted(_addr, _bonusDrops);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for bonus drops of an address to be revoked by the owner of the contract. Any \r\n     * attempt made by any other account to invoke the function will result in a loss of gas\r\n     * and the bonus drops of the recipient will remain untampered.\r\n     * \r\n     * @param _addr The address to revoke bonus credits from.\r\n     * @param _bonusDrops The amount of bonus drops to be revoked.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function revokeBonusCreditOf(address _addr, uint256 _bonusDrops) public onlyOwner returns(bool) {\r\n        require(\r\n            _addr != address(0) \r\n            && bonusDropsOf[_addr] >= _bonusDrops\r\n        );\r\n        bonusDropsOf[_addr] = bonusDropsOf[_addr].sub(_bonusDrops);\r\n        BonusCreditRevoked(_addr, _bonusDrops);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the credit of an address to be queried. This is a constant function which\r\n     * does not alter the state of the contract and therefore does not require any gas or a\r\n     * signature to be executed. \r\n     * \r\n     * @param _addr The address of which to query the credit balance of. \r\n     * \r\n     * @return The total amount of credit the address has (minus any bonus credits).\r\n     * */\r\n    function getDropsOf(address _addr) public view returns(uint256) {\r\n        return (ethBalanceOf[_addr].mul(rate)).div(10 ** 18);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the bonus credit of an address to be queried. This is a constant function \r\n     * which does not alter the state of the contract and therefore does not require any gas \r\n     * or a signature to be executed. \r\n     * \r\n     * @param _addr The address of which to query the bonus credits. \r\n     * \r\n     * @return The total amount of bonus credit the address has (minus non-bonus credit).\r\n     * */\r\n    function getBonusDropsOf(address _addr) public view returns(uint256) {\r\n        return bonusDropsOf[_addr];\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the total credit (bonus + non-bonus) of an address to be queried. This is a \r\n     * constant function which does not alter the state of the contract and therefore does not  \r\n     * require any gas or a signature to be executed. \r\n     * \r\n     * @param _addr The address of which to query the total credits. \r\n     * \r\n     * @return The total amount of credit the address has (bonus + non-bonus credit).\r\n     * */\r\n    function getTotalDropsOf(address _addr) public view returns(uint256) {\r\n        return getDropsOf(_addr).add(getBonusDropsOf(_addr));\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the total ETH balance of an address to be queried. This is a constant\r\n     * function which does not alter the state of the contract and therefore does not  \r\n     * require any gas or a signature to be executed. \r\n     * \r\n     * @param _addr The address of which to query the total ETH balance. \r\n     * \r\n     * @return The total amount of ETH balance the address has.\r\n     * */\r\n    function getEthBalanceOf(address _addr) public view returns(uint256) {\r\n        return ethBalanceOf[_addr];\r\n    }\r\n\r\n    \r\n    /**\r\n     * Allows for suspected fraudulent ERC20 tokens to be banned from being airdropped by the \r\n     * owner of the contract. Any attempt made by any other account to invoke the function will \r\n     * result in a loss of gas and the token to remain unbanned.\r\n     * \r\n     * @param _tokenAddr The contract address of the ERC20 token to be banned from being airdropped. \r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function banToken(address _tokenAddr) public onlyOwner returns(bool) {\r\n        require(!tokenIsBanned[_tokenAddr]);\r\n        tokenIsBanned[_tokenAddr] = true;\r\n        TokenBanned(_tokenAddr);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for previously suspected fraudulent ERC20 tokens to become unbanned by the owner\r\n     * of the contract. Any attempt made by any other account to invoke the function will \r\n     * result in a loss of gas and the token to remain banned.\r\n     * \r\n     * @param _tokenAddr The contract address of the ERC20 token to be banned from being airdropped. \r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     **/\r\n    function unbanToken(address _tokenAddr) public onlyOwner returns(bool) {\r\n        require(tokenIsBanned[_tokenAddr]);\r\n        tokenIsBanned[_tokenAddr] = false;\r\n        TokenUnbanned(_tokenAddr);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the allowance of a token from its owner to this contract to be queried. \r\n     * \r\n     * As part of the ERC20 standard all tokens which fall under this category have an allowance \r\n     * function which enables owners of tokens to allow (or give permission) to another address \r\n     * to spend tokens on behalf of the owner. This contract uses this as part of its protocol.\r\n     * Users must first give permission to the contract to transfer tokens on their behalf, however,\r\n     * this does not mean that the tokens will ever be transferrable without the permission of the \r\n     * owner. This is a security feature which was implemented on this contract. It is not possible\r\n     * for the owner of this contract or anyone else to transfer the tokens which belong to others. \r\n     * \r\n     * @param _addr The address of the token's owner.\r\n     * @param _addressOfToken The contract address of the ERC20 token.\r\n     * \r\n     * @return The ERC20 token allowance from token owner to this contract. \r\n     * */\r\n    function getTokenAllowance(address _addr, address _addressOfToken) public view returns(uint256) {\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n        return token.allowance(_addr, address(this));\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows users to buy and receive credits automatically when sending ETH to the contract address.\r\n     * */\r\n    function() public payable {\r\n        ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(msg.value);\r\n        CreditPurchased(msg.sender, msg.value, msg.value.mul(rate));\r\n    }\r\n\r\n    \r\n    /**\r\n     * Allows users to withdraw their ETH for drops which they have bought and not used. This \r\n     * will result in the credit of the user being set back to 0. However, bonus credits will \r\n     * remain the same because they are granted when users use their drops. \r\n     * \r\n     * @param _eth The amount of ETH to withdraw\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function withdrawEth(uint256 _eth) public returns(bool) {\r\n        require(\r\n            ethBalanceOf[msg.sender] >= _eth\r\n            && _eth > 0 \r\n        );\r\n        uint256 toTransfer = _eth;\r\n        ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].sub(_eth);\r\n        msg.sender.transfer(toTransfer);\r\n        EthWithdrawn(msg.sender, toTransfer);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for refunds to be made by the owner of the contract. Any attempt made by any other account \r\n     * to invoke the function will result in a loss of gas and no refunds will be made.\r\n     * */\r\n    function issueRefunds(address[] _addrs) public onlyOwner returns(bool) {\r\n        require(_addrs.length <= maxDropsPerTx);\r\n        for(uint i = 0; i < _addrs.length; i++) {\r\n            if(_addrs[i] != address(0) && ethBalanceOf[_addrs[i]] > 0) {\r\n                uint256 toRefund = ethBalanceOf[_addrs[i]];\r\n                ethBalanceOf[_addrs[i]] = 0;\r\n                _addrs[i].transfer(toRefund);\r\n                RefundIssued(_addrs[i], toRefund);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the distribution of an ERC20 token to be transferred to up to 100 recipients at \r\n     * a time. This function only facilitates batch transfers of constant values (i.e., all recipients\r\n     * will receive the same amount of tokens).\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _value The amount of tokens all addresses will receive. \r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */\r\n    function singleValueAirdrop(address _addressOfToken,  address[] _recipients, uint256 _value) public returns(bool) {\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n        require(\r\n            _recipients.length <= maxDropsPerTx \r\n            && (\r\n                getTotalDropsOf(msg.sender)>= _recipients.length \r\n                || tokenHasFreeTrial(_addressOfToken) \r\n            )\r\n            && !tokenIsBanned[_addressOfToken]\r\n        );\r\n        for(uint i = 0; i < _recipients.length; i++) {\r\n            if(_recipients[i] != address(0)) {\r\n                token.transferFrom(msg.sender, _recipients[i], _value);\r\n            }\r\n        }\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            trialDrops[_addressOfToken] = trialDrops[_addressOfToken].add(_recipients.length);\r\n        } else {\r\n            updateMsgSenderBonusDrops(_recipients.length);\r\n        }\r\n        AirdropInvoked(msg.sender, _recipients.length);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows for the distribution of an ERC20 token to be transferred to up to 100 recipients at \r\n     * a time. This function facilitates batch transfers of differing values (i.e., all recipients\r\n     * can receive different amounts of tokens).\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _values The corresponding values of tokens which each address will receive.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */    \r\n    function multiValueAirdrop(address _addressOfToken,  address[] _recipients, uint256[] _values) public returns(bool) {\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n        require(\r\n            _recipients.length <= maxDropsPerTx \r\n            && _recipients.length == _values.length \r\n            && (\r\n                getTotalDropsOf(msg.sender) >= _recipients.length\r\n                || tokenHasFreeTrial(_addressOfToken)\r\n            )\r\n            && !tokenIsBanned[_addressOfToken]\r\n        );\r\n        for(uint i = 0; i < _recipients.length; i++) {\r\n            if(_recipients[i] != address(0) && _values[i] > 0) {\r\n                token.transferFrom(msg.sender, _recipients[i], _values[i]);\r\n            }\r\n        }\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            trialDrops[_addressOfToken] = trialDrops[_addressOfToken].add(_recipients.length);\r\n        } else {\r\n            updateMsgSenderBonusDrops(_recipients.length);\r\n        }\r\n        AirdropInvoked(msg.sender, _recipients.length);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Invoked internally by the airdrop functions. The purpose of thie function is to grant bonus \r\n     * drops to users who spend their ETH airdropping tokens, and to remove bonus drops when users \r\n     * no longer have ETH in their account but do have some bonus drops when airdropping tokens.\r\n     * \r\n     * @param _drops The amount of recipients which received tokens from the airdrop.\r\n     * */\r\n    function updateMsgSenderBonusDrops(uint256 _drops) internal {\r\n        if(_drops <= getDropsOf(msg.sender)) {\r\n            bonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].add(_drops.mul(bonus).div(100));\r\n            ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].sub(_drops.mul(dropUnitPrice));\r\n            owner.transfer(_drops.mul(dropUnitPrice));\r\n        } else {\r\n            uint256 remainder = _drops.sub(getDropsOf(msg.sender));\r\n            if(ethBalanceOf[msg.sender] > 0) {\r\n                bonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].add(getDropsOf(msg.sender).mul(bonus).div(100));\r\n                owner.transfer(ethBalanceOf[msg.sender]);\r\n                ethBalanceOf[msg.sender] = 0;\r\n            }\r\n            bonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].sub(remainder);\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * Allows for any ERC20 tokens which have been mistakenly  sent to this contract to be returned \r\n     * to the original sender by the owner of the contract. Any attempt made by any other account \r\n     * to invoke the function will result in a loss of gas and no tokens will be transferred out.\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipient The address which will receive tokens. \r\n     * @param _value The amount of tokens to refund.\r\n     * \r\n     * @return true if function executes successfully, false otherwise.\r\n     * */  \r\n    function withdrawERC20Tokens(address _addressOfToken,  address _recipient, uint256 _value) public onlyOwner returns(bool){\r\n        require(\r\n            _addressOfToken != address(0)\r\n            && _recipient != address(0)\r\n            && _value > 0\r\n        );\r\n        ERCInterface token = ERCInterface(_addressOfToken);\r\n        token.transfer(_recipient, _value);\r\n        ERC20TokensWithdrawn(_addressOfToken, _recipient, _value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxDropsPerTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBonus\",\"type\":\"uint256\"}],\"name\":\"setBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"banToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"tokenHasFreeTrial\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_bonusDrops\",\"type\":\"uint256\"}],\"name\":\"grantBonusDrops\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxDropsPerTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenIsBanned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTotalDropsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"issueRefunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trialDrops\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getDropsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"multiValueAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusDropsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"singleValueAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getBonusDropsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dropUnitPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"getRemainingTrialDrops\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getEthBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"website\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTrialDrops\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_bonusDrops\",\"type\":\"uint256\"}],\"name\":\"revokeBonusCreditOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"getTokenAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxDrops\",\"type\":\"uint256\"}],\"name\":\"setMaxDrops\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"unbanToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"credit\",\"type\":\"uint256\"}],\"name\":\"BonusCreditGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"credit\",\"type\":\"uint256\"}],\"name\":\"BonusCreditRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"credit\",\"type\":\"uint256\"}],\"name\":\"CreditPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creditConsumed\",\"type\":\"uint256\"}],\"name\":\"AirdropInvoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"BonustChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenBanned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenUnbanned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalWei\",\"type\":\"uint256\"}],\"name\":\"EthWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"RateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"MaxDropsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalWei\",\"type\":\"uint256\"}],\"name\":\"RefundIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sentTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ERC20TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DappleAirdrops","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1c28b76b715cf477dc51d7df1d3e0c11a8a5c6b9ff71cc7409e3c51be3c18193"}]}