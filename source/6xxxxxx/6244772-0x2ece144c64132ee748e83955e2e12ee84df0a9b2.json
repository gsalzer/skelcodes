{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, <nick@mokens.io>\r\n*\r\n* The MokenUpdates contract adds/updates/removes functions.\r\n*\r\n* Function changes emit the ContractUpdated event.\r\n* Monitor changes to the Mokens contract by watching/querying the\r\n* ContractUpdated event\r\n*\r\n* Functions and delegate contracts can be queried by using functions from the\r\n* QueryMokenDelegates contract.\r\n/******************************************************************************/\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n// All storage variables are declared here\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Storage version 0\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Contract Management\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n    address internal contractOwner;\r\n    string[] internal functionSignatures;\r\n    // signature => index+1\r\n    mapping(string => uint256) internal functionSignatureToIndex;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //SupportsInterfaces\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //RootOwnerOf\r\n    //ERC721Metadata\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n    //tokenId => moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength;\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC721\r\n    //ERC721Enumerable\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC998ERC721TopDown\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC998ERC20TopDown\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //ERC998ERC721BottomUp\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Era\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // index => era\r\n    mapping(uint256 => bytes32) internal eras;\r\n    uint256 internal eraLength;\r\n    // era => index+1\r\n    mapping(bytes32 => uint256) internal eraIndex;\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    //Minting\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    uint256 internal mintPriceOffset; // = 0 szabo;\r\n    uint256 internal mintStepPrice; // = 500 szabo;\r\n    uint256 internal mintPriceBuffer; // = 5000 szabo;\r\n    address[] internal mintContracts;\r\n    mapping(address => uint256) internal mintContractIndex;\r\n    //moken name => tokenId+1\r\n    mapping(string => uint256) internal tokenByName_;\r\n}\r\n\r\ncontract MokenUpdates is Storage0 {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event ContractUpdated(bytes32 indexed indexedFunctionSignature, address indexed delegate, bytes32 indexed updateType, string functionSignature);\r\n\r\n    function initializeMokensContract(address contractManagement) external {\r\n        require(contractOwner == address(0), \"Contract owner has been set.\");\r\n        contractOwner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n        updateContract(1 /* addFunctions */, contractManagement, \"executeDelegate(address,bytes)addFunctions(address,string)updateFunctions(address,string)removeFunctions(string)\");\r\n    }\r\n\r\n    function updateContract(uint256 _updateType, address _delegate, string signatures) internal {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        require(_delegate != address(0), \"delegate can't be zero address.\");\r\n        bytes memory signaturesBytes = bytes(signatures);\r\n        bytes memory signatureBytes;\r\n        string memory signature;\r\n        bytes4 funcId;\r\n        uint256 length = signaturesBytes.length;\r\n        uint256 pos = 2;\r\n        uint256 start = 0;\r\n        uint256 num;\r\n        uint256 index;\r\n        uint256 lastIndex;\r\n        bytes32 signatureHash;\r\n        for (; pos < length; pos++) {\r\n            // 0x29 == )\r\n            if (signaturesBytes[pos] == 0x29) {\r\n                num = (pos - start) + 1;\r\n                signatureBytes = new bytes(num);\r\n                for (uint i = 0; i < num; i++) {\r\n                    signatureBytes[i] = signaturesBytes[start + i];\r\n                }\r\n                start = pos + 1;\r\n                signature = string(signatureBytes);\r\n                signatureHash = keccak256(signatureBytes);\r\n                funcId = bytes4(signatureHash);\r\n                if (_updateType == 1) {\r\n                    require(functionSignatureToIndex[signature] == 0, \"Function already exists.\");\r\n                    require(delegates[funcId] == address(0), \"FuncId clash.\");\r\n                    delegates[funcId] = _delegate;\r\n                    functionSignatures.push(signature);\r\n                    functionSignatureToIndex[signature] = functionSignatures.length;\r\n                    emit ContractUpdated(signatureHash, _delegate, \"new\", signature);\r\n                }\r\n                else if (_updateType == 2) {\r\n                    index = functionSignatureToIndex[signature];\r\n                    if (index == 0) {\r\n                        require(delegates[funcId] == address(0), \"FuncId clash.\");\r\n                        delegates[funcId] = _delegate;\r\n                        emit ContractUpdated(signatureHash, _delegate, \"new\", signature);\r\n                    }\r\n                    else if (delegates[funcId] != _delegate) {\r\n                        delegates[funcId] = _delegate;\r\n                        emit ContractUpdated(signatureHash, _delegate, \"updated\", signature);\r\n                    }\r\n                }\r\n                else if (_updateType == 3) {\r\n                    index = functionSignatureToIndex[signature];\r\n                    require(index != 0, \"Function does not exist.\");\r\n                    index--;\r\n                    lastIndex = functionSignatures.length - 1;\r\n                    if (index != lastIndex) {\r\n                        functionSignatures[index] = functionSignatures[lastIndex];\r\n                        functionSignatureToIndex[functionSignatures[lastIndex]] = index + 1;\r\n                    }\r\n                    functionSignatures.length--;\r\n                    delete functionSignatureToIndex[signature];\r\n                    _delegate = delegates[funcId];\r\n                    delete delegates[funcId];\r\n                    emit ContractUpdated(signatureHash, _delegate, \"removed\", signature);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addFunctions(address _delegate, string signatures) external {\r\n        updateContract(1, _delegate, signatures);\r\n    }\r\n\r\n    function updateFunctions(address _delegate, string signatures) external {\r\n        updateContract(2, _delegate, signatures);\r\n    }\r\n\r\n    function removeFunctions(string signatures) external {\r\n        updateContract(3, address(1), signatures);\r\n    }\r\n\r\n\r\n    function executeDelegate(address _delegate, bytes _functionCall) external returns(string) {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        bytes memory functionCall = _functionCall;\r\n        assembly {\r\n            let callSuccess := delegatecall(gas, _delegate, add(functionCall, 0x20), mload(functionCall), 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(functionCall, 0, size)\r\n            switch callSuccess\r\n            case 0 {revert(functionCall, size)}\r\n            default {return (functionCall, size)}\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"signatures\",\"type\":\"string\"}],\"name\":\"removeFunctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractManagement\",\"type\":\"address\"}],\"name\":\"initializeMokensContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"signatures\",\"type\":\"string\"}],\"name\":\"updateFunctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"signatures\",\"type\":\"string\"}],\"name\":\"addFunctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_functionCall\",\"type\":\"bytes\"}],\"name\":\"executeDelegate\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"indexedFunctionSignature\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"updateType\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"functionSignature\",\"type\":\"string\"}],\"name\":\"ContractUpdated\",\"type\":\"event\"}]","ContractName":"MokenUpdates","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c5e2c61ea02d753b76f8e0ec85701cc78a9b01119278aea77be0cb8074ae2047"}]}