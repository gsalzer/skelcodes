{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title PLAYToken contract\r\n/// @notice defines standard ERC-20 functionality.\r\n//-----------------------------------------------------------------------------\r\ncontract PLAYToken {\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when ownership of PLAY changes by any mechanism. Also emits\r\n    ///  when tokens are destroyed ('to' == 0).\r\n    //-------------------------------------------------------------------------\r\n    event Transfer (address indexed from, address indexed to, uint tokens);\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when an approved spender is changed or reaffirmed, or if\r\n    ///  the allowance amount changes. The zero address indicates there is no\r\n    ///  approved address.\r\n    //-------------------------------------------------------------------------\r\n    event Approval (\r\n        address indexed tokenOwner, \r\n        address indexed spender, \r\n        uint tokens\r\n    );\r\n    \r\n    // total number of tokens in circulation (in pWei).\r\n    //  Burning tokens reduces this amount\r\n    uint totalPLAY = 1000000000 * 10**18;    // one billion\r\n    // the token balances of all token holders\r\n    mapping (address => uint) playBalances;\r\n    // approved spenders and allowances of all token holders\r\n    mapping (address => mapping (address => uint)) allowances;\r\n\r\n    constructor() public {\r\n        playBalances[msg.sender] = totalPLAY;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Throws if parameter is zero\r\n    //-------------------------------------------------------------------------\r\n    modifier notZero(uint param) {\r\n        require (param != 0, \"Parameter cannot be zero\");\r\n        _;\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @dev Throws if tokenOwner has insufficient PLAY balance\r\n    //-------------------------------------------------------------------------\r\n    modifier sufficientFunds(address tokenOwner, uint tokens) {\r\n        require (playBalances[tokenOwner] >= tokens, \"Insufficient balance\");\r\n        _;\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @dev Throws if spender has insufficient allowance from owner\r\n    //-------------------------------------------------------------------------\r\n    modifier sufficientAllowance(address owner, address spender, uint tokens) {\r\n        require (\r\n            allowances[owner][spender] >= tokens, \r\n            \"Insufficient allowance\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY to `to`.\r\n    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\r\n    ///  insufficient balance for transfer. Throws if `to` is the zero address.\r\n    /// @param to The address to where PLAY is being sent.\r\n    /// @param tokens The number of tokens to send (in pWei).\r\n    /// @return True upon successful transfer. Will throw if unsuccessful.\r\n    //-------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) \r\n        public \r\n        notZero(uint(to)) \r\n        notZero(tokens)\r\n        sufficientFunds(msg.sender, tokens)\r\n        returns(bool) \r\n    {\r\n        // subtract amount from sender\r\n        playBalances[msg.sender] -= tokens;\r\n        // add amount to token receiver\r\n        playBalances[to] += tokens;\r\n        // emit transfer event\r\n        emit Transfer(msg.sender, to, tokens);\r\n        \r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY from\r\n    ///  `from` to `to`.\r\n    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\r\n    ///  insufficient allowance for transfer. Throws if `from` has\r\n    ///  insufficient balance for transfer. Throws if `to` is the zero address.\r\n    /// @param from The address from where PLAY is being sent. Sender must be\r\n    ///  an approved spender.\r\n    /// @param to The token owner whose PLAY is being sent.\r\n    /// @param tokens The number of tokens to send (in pWei).\r\n    /// @return True upon successful transfer. Will throw if unsuccessful.\r\n    //-------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) \r\n        public \r\n        notZero(uint(to)) \r\n        notZero(tokens) \r\n        sufficientFunds(from, tokens)\r\n        sufficientAllowance(from, msg.sender, tokens)\r\n        returns(bool) \r\n    {\r\n        // subtract amount from sender's allowance\r\n        allowances[from][msg.sender] -= tokens;\r\n        // subtract amount from token owner\r\n        playBalances[from] -= tokens;\r\n        // add amount to token receiver\r\n        playBalances[to] += tokens;\r\n        // emit transfer event\r\n        emit Transfer(from, to, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Allow `spender` to withdraw from your account, multiple times,\r\n    ///  up to `(tokens/1000000000000000000).fixed(0,18)` PLAY. Calling this\r\n    ///  function overwrites the previous allowance of spender.\r\n    /// @dev Emits approval event\r\n    /// @param spender The address to authorize as a spender\r\n    /// @param tokens The new token allowance of spender (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) external returns(bool) {\r\n        // set the spender's allowance to token amount\r\n        allowances[msg.sender][spender] = tokens;\r\n        // emit approval event\r\n        emit Approval(msg.sender, spender, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the total number of tokens in circulation.\r\n    /// @return Total tokens tracked by this contract.\r\n    //-------------------------------------------------------------------------\r\n    function totalSupply() external view returns (uint) { return totalPLAY; }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the number of PLAY tokens owned by `tokenOwner`.\r\n    /// @dev Throws if trying to query the zero address.\r\n    /// @param tokenOwner The PLAY token owner.\r\n    /// @return The number of PLAY tokens owned by `tokenOwner` (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) \r\n        public \r\n        view \r\n        notZero(uint(tokenOwner))\r\n        returns(uint)\r\n    {\r\n        return playBalances[tokenOwner];\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the remaining allowance of `spender` for `tokenOwner`.\r\n    /// @param tokenOwner The PLAY token owner.\r\n    /// @param spender The approved spender address.\r\n    /// @return The remaining allowance of `spender` for `tokenOwner`.\r\n    //-------------------------------------------------------------------------\r\n    function allowance(\r\n        address tokenOwner, \r\n        address spender\r\n    ) public view returns (uint) {\r\n        return allowances[tokenOwner][spender];\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the token's name.\r\n    /// @return The token's name as a string\r\n    //-------------------------------------------------------------------------\r\n    function name() external pure returns (string) { \r\n        return \"PLAY Network Token\"; \r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the token's ticker symbol.\r\n    /// @return The token's ticker symbol as a string\r\n    //-------------------------------------------------------------------------\r\n    function symbol() external pure returns (string) { return \"PLAY\"; }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the number of allowed decimal places for the token.\r\n    /// @return The number of allowed decimal places for the token.\r\n    //-------------------------------------------------------------------------\r\n    function decimals() external pure returns (uint8) { return 18; }\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title BurnToken contract\r\n/// @notice defines token burning functionality.\r\n//-----------------------------------------------------------------------------\r\ncontract BurnToken is PLAYToken {\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Destroy `(tokens/1000000000000000000).fixed(0,18)` PLAY. These\r\n    ///  tokens cannot be viewed or recovered.\r\n    /// @dev Throws if amount to burn is zero. Throws if sender has\r\n    ///  insufficient balance to burn. Emits transfer event.\r\n    /// @param tokens The number of tokens to burn (in pWei). \r\n    /// @return True upon successful burn. Will throw if unsuccessful.\r\n    //-------------------------------------------------------------------------\r\n    function burn(uint tokens)\r\n        external \r\n        notZero(tokens) \r\n        sufficientFunds(msg.sender, tokens)\r\n        returns(bool) \r\n    {\r\n        // subtract amount from token owner\r\n        playBalances[msg.sender] -= tokens;\r\n        // subtract amount from total supply\r\n        totalPLAY -= tokens;\r\n        // emit transfer event\r\n        emit Transfer(msg.sender, address(0), tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Destroy `(tokens/1000000000000000000).fixed(0,18)` PLAY from \r\n    /// `from`. These tokens cannot be viewed or recovered.\r\n    /// @dev Throws if amount to burn is zero. Throws if sender has\r\n    ///  insufficient allowance to burn. Throws if `from` has insufficient\r\n    ///  balance to burn. Emits transfer event.\r\n    /// @param from The token owner whose PLAY is being burned. Sender must be\r\n    ///  an approved spender.\r\n    /// @param tokens The number of tokens to burn (in pWei).\r\n    /// @return True upon successful burn. Will throw if unsuccessful.\r\n    //-------------------------------------------------------------------------\r\n    function burnFrom(address from, uint tokens) \r\n        external \r\n        notZero(tokens) \r\n        sufficientFunds(from, tokens)\r\n        sufficientAllowance(from, msg.sender, tokens)\r\n        returns(bool) \r\n    {\r\n        // subtract amount from sender's allowance\r\n        allowances[from][msg.sender] -= tokens;\r\n        // subtract amount from token owner\r\n        playBalances[from] -= tokens;\r\n        // subtract amount from total supply\r\n        totalPLAY -= tokens;\r\n        // emit transfer event\r\n        emit Transfer(from, address(0), tokens);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title LockToken contract\r\n/// @notice defines token locking and unlocking functionality.\r\n//-----------------------------------------------------------------------------\r\ncontract LockToken is BurnToken {\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when PLAY tokens become locked for any number of years by\r\n    ///  any mechanism.\r\n    //-------------------------------------------------------------------------\r\n    event Lock (address indexed tokenOwner, uint tokens);\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when PLAY tokens become unlocked by any mechanism.\r\n    //-------------------------------------------------------------------------\r\n    event Unlock (address indexed tokenOwner, uint tokens);\r\n\r\n    // Unix Timestamp for 1-1-2018 at 00:00:00.\r\n    //  Used to calculate years since release.\r\n    uint constant FIRST_YEAR_TIMESTAMP = 1514764800;\r\n    // Tracks years since release. Starts at 0 and increments every 365 days.\r\n    uint public currentYear;\r\n    // Maximum number of years into the future locked tokens can be recovered.\r\n    uint public maximumLockYears = 10;\r\n    // Locked token balances by unlock year  \r\n    mapping (address => mapping(uint => uint)) tokensLockedUntilYear;\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Lock `(tokens/1000000000000000000).fixed(0,18)` PLAY for\r\n    ///  `numberOfYears` years.\r\n    /// @dev Throws if amount to lock is zero. Throws if numberOfYears is zero\r\n    ///  or greater than maximumLockYears. Throws if `msg.sender` has \r\n    ///  insufficient balance to lock.\r\n    /// @param numberOfYears The number of years the tokens will be locked.\r\n    /// @param tokens The number of tokens to lock (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function lock(uint numberOfYears, uint tokens) \r\n        public \r\n        notZero(tokens)\r\n        sufficientFunds(msg.sender, tokens)\r\n        returns(bool)\r\n    {\r\n        // number of years must be a valid amount.\r\n        require (\r\n            numberOfYears > 0 && numberOfYears <= maximumLockYears,\r\n            \"Invalid number of years\"\r\n        );\r\n\r\n        // subtract amount from sender\r\n        playBalances[msg.sender] -= tokens;\r\n        // add amount to sender's locked token balance\r\n        tokensLockedUntilYear[msg.sender][currentYear+numberOfYears] += tokens;\r\n        // emit lock event\r\n        emit Lock(msg.sender, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Lock `(tokens/1000000000000000000).fixed(0,18)` PLAY from \r\n    ///  `from` for `numberOfYears` years.\r\n    /// @dev Throws if amount to lock is zero. Throws if numberOfYears is zero\r\n    ///  or greater than maximumLockYears. Throws if `msg.sender` has\r\n    ///  insufficient allowance to lock. Throws if `from` has insufficient\r\n    ///  balance to lock.\r\n    /// @param from The token owner whose PLAY is being locked. Sender must be\r\n    ///  an approved spender.\r\n    /// @param numberOfYears The number of years the tokens will be locked.\r\n    /// @param tokens The number of tokens to lock (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function lockFrom(address from, uint numberOfYears, uint tokens) \r\n        external\r\n        notZero(tokens)\r\n        sufficientFunds(from, tokens)\r\n        sufficientAllowance(from, msg.sender, tokens)\r\n        returns(bool) \r\n    {\r\n        // number of years must be a valid amount.\r\n        require (\r\n            numberOfYears > 0 && numberOfYears <= maximumLockYears,\r\n            \"Invalid number of years\"\r\n        );\r\n\r\n        // subtract amount from sender's allowance\r\n        allowances[from][msg.sender] -= tokens;\r\n        // subtract amount from token owner's balance\r\n        playBalances[from] -= tokens;\r\n        // add amount to token owner's locked token balance\r\n        tokensLockedUntilYear[from][currentYear + numberOfYears] += tokens;\r\n        // emit lock event\r\n        emit Lock(from, tokens);\r\n        \r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY to `to`,\r\n    ///  then lock for `numberOfYears` years.\r\n    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\r\n    ///  insufficient balance for transfer. Throws if `to` is the zero\r\n    ///  address. Emits transfer and lock events.\r\n    /// @param to The address to where PLAY is being sent and locked.\r\n    /// @param numberOfYears The number of years the tokens will be locked.\r\n    /// @param tokens The number of tokens to send (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function transferAndLock(\r\n        address to, \r\n        uint numberOfYears, \r\n        uint tokens\r\n    ) external {\r\n        // Transfer will fail if sender's balance is too low or \"to\" is zero\r\n        transfer(to, tokens);\r\n\r\n        // subtract amount from token receiver's balance\r\n        playBalances[to] -= tokens;\r\n        // add amount to token receiver's locked token balance\r\n        tokensLockedUntilYear[to][currentYear + numberOfYears] += tokens;\r\n        // emit lock event\r\n        emit Lock(msg.sender, tokens);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Send `(tokens/1000000000000000000).fixed(0,18)` PLAY from \r\n    ///  `from` to `to`, then lock for `numberOfYears` years.\r\n    /// @dev Throws if amount to send is zero. Throws if `msg.sender` has\r\n    ///  insufficient allowance for transfer. Throws if `from` has \r\n    ///  insufficient balance for transfer. Throws if `to` is the zero\r\n    ///  address. Emits transfer and lock events.\r\n    /// @param from The token owner whose PLAY is being sent. Sender must be\r\n    ///  an approved spender.\r\n    /// @param to The address to where PLAY is being sent and locked.\r\n    /// @param tokens The number of tokens to send (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function transferFromAndLock(\r\n        address from, \r\n        address to, \r\n        uint numberOfYears, \r\n        uint tokens\r\n    ) external {\r\n        // Initiate transfer. Transfer will fail if sender's allowance is too\r\n        //  low, token owner's balance is too low, or \"to\" is zero\r\n        transferFrom(from, to, tokens);\r\n\r\n        // subtract amount from token owner's balance\r\n        playBalances[to] -= tokens;\r\n        // add amount to token receiver's locked token balance\r\n        tokensLockedUntilYear[to][currentYear + numberOfYears] += tokens;\r\n        // emit lock event\r\n        emit Lock(msg.sender, tokens);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Unlock all qualifying tokens for `tokenOwner`. Sender must \r\n    ///  either be tokenOwner or an approved address.\r\n    /// @dev If tokenOwner is empty, tokenOwner is set to msg.sender. Throws\r\n    ///  if sender is not tokenOwner or an approved spender (allowance > 0).\r\n    /// @param tokenOwner The token owner whose tokens will unlock.\r\n    //-------------------------------------------------------------------------\r\n    function unlockAll(address tokenOwner) external {\r\n        // create local variable for token owner\r\n        address addressToUnlock = tokenOwner;\r\n        // if tokenOwner parameter is empty, set tokenOwner to sender\r\n        if (addressToUnlock == address(0)) {\r\n            addressToUnlock = msg.sender;\r\n        }\r\n        // sender must either be tokenOwner or an approved address\r\n        if (msg.sender != addressToUnlock) {\r\n            require (\r\n                allowances[addressToUnlock][msg.sender] > 0,\r\n                \"Not authorized to unlock for this address\"\r\n            );\r\n        }\r\n\r\n        // create local variable for unlock total\r\n        uint tokensToUnlock;\r\n        // check each year starting from 1 year after release\r\n        for (uint i = 1; i <= currentYear; ++i) {\r\n            // add qualifying tokens to tokens to unlock variable\r\n            tokensToUnlock += tokensLockedUntilYear[addressToUnlock][i];\r\n            // set locked token balance of year i to 0 \r\n            tokensLockedUntilYear[addressToUnlock][i] = 0;\r\n        }\r\n        // add qualifying tokens back to token owner's account balance\r\n        playBalances[addressToUnlock] += tokensToUnlock;\r\n        // emit unlock event\r\n        emit Unlock (addressToUnlock, tokensToUnlock);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Unlock all tokens locked until `year` years since 2018 for \r\n    ///  `tokenOwner`. Sender must be tokenOwner or an approved address.\r\n    /// @dev If tokenOwner is empty, tokenOwner is set to msg.sender. Throws\r\n    ///  if sender is not tokenOwner or an approved spender (allowance > 0).\r\n    /// @param tokenOwner The token owner whose tokens will unlock.\r\n    /// @param year Number of years since 2018 the tokens were locked until.\r\n    //-------------------------------------------------------------------------\r\n    function unlockByYear(address tokenOwner, uint year) external {\r\n        // create local variable for token owner\r\n        address addressToUnlock = tokenOwner;\r\n        // if tokenOwner parameter is empty, set tokenOwner to sender\r\n        if (addressToUnlock == address(0)) {\r\n            addressToUnlock = msg.sender;\r\n        }\r\n        // sender must either be tokenOwner or an approved address\r\n        if (msg.sender != addressToUnlock) {\r\n            require (\r\n                allowances[addressToUnlock][msg.sender] > 0,\r\n                \"Not authorized to unlock for this address\"\r\n            );\r\n        }\r\n        // year of locked tokens must be less than or equal to current year\r\n        require (\r\n            currentYear >= year,\r\n            \"Tokens from this year cannot be unlocked yet\"\r\n        );\r\n        // create local variable for unlock amount\r\n        uint tokensToUnlock = tokensLockedUntilYear[addressToUnlock][year];\r\n        // set locked token balance of year to 0\r\n        tokensLockedUntilYear[addressToUnlock][year] = 0;\r\n        // add qualifying tokens back to token owner's account balance\r\n        playBalances[addressToUnlock] += tokensToUnlock;\r\n        // emit unlock event\r\n        emit Unlock(addressToUnlock, tokensToUnlock);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Update the current year.\r\n    /// @dev Throws if less than 365 days has passed since currentYear.\r\n    //-------------------------------------------------------------------------\r\n    function updateYearsSinceRelease() external {\r\n        // check if years since first year is greater than the currentYear\r\n        uint secondsSinceRelease = block.timestamp - FIRST_YEAR_TIMESTAMP;\r\n        require (\r\n            currentYear < secondsSinceRelease / (365 * 1 days),\r\n            \"Cannot update year yet\"\r\n        );\r\n        // increment years since release\r\n        ++currentYear;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the total locked token holdings of `tokenOwner`.\r\n    /// @param tokenOwner The locked token owner.\r\n    /// @return Total locked token holdings of an address.\r\n    //-------------------------------------------------------------------------\r\n    function getTotalLockedTokens(\r\n        address tokenOwner\r\n    ) public view returns (uint lockedTokens) {\r\n        for (uint i = 1; i < currentYear + maximumLockYears; ++i) {\r\n            lockedTokens += tokensLockedUntilYear[tokenOwner][i];\r\n        }\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the locked token holdings of `tokenOwner` unlockable in\r\n    ///  `(year + 2018)`.\r\n    /// @param tokenOwner The locked token owner.\r\n    /// @param year Years since 2018 the tokens are locked until.\r\n    /// @return Locked token holdings of an address for `(year + 2018)`.\r\n    //-------------------------------------------------------------------------\r\n    function getLockedTokensByYear(\r\n        address tokenOwner, \r\n        uint year\r\n    ) external view returns (uint) {\r\n        return tokensLockedUntilYear[tokenOwner][year];\r\n    }\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic \r\n///  authorization control functions, this simplifies the implementation of\r\n///  \"user permissions\".\r\n//-----------------------------------------------------------------------------\r\ncontract Ownable {\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when owner address changes by any mechanism.\r\n    //-------------------------------------------------------------------------\r\n    event OwnershipTransfer (address previousOwner, address newOwner);\r\n    \r\n    // Wallet address that can sucessfully execute onlyOwner functions\r\n    address owner;\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @dev Sets the owner of the contract to the sender account.\r\n    //-------------------------------------------------------------------------\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransfer(address(0), owner);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Throws if called by any account other than `owner`.\r\n    //-------------------------------------------------------------------------\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Function can only be called by contract owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Transfer control of the contract to a newOwner.\r\n    /// @dev Throws if `_newOwner` is zero address.\r\n    /// @param _newOwner The address to transfer ownership to.\r\n    //-------------------------------------------------------------------------\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        // for safety, new owner parameter must not be 0\r\n        require (\r\n            _newOwner != address(0),\r\n            \"New owner address cannot be zero\"\r\n        );\r\n        // define local variable for old owner\r\n        address oldOwner = owner;\r\n        // set owner to new owner\r\n        owner = _newOwner;\r\n        // emit ownership transfer event\r\n        emit OwnershipTransfer(oldOwner, _newOwner);\r\n    }\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title TOY Token Interface - ERC721-compliant view functions \r\n//-----------------------------------------------------------------------------\r\ninterface ToyTokenOwnership {\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(\r\n        address _owner, \r\n        address _operator\r\n    ) external view returns (bool);\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title Color Token Contract\r\n/// @notice defines colored token registration, creation, and spending\r\n///  functionality.\r\n//-----------------------------------------------------------------------------\r\ncontract ColorToken is LockToken, Ownable {\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when a new colored token is created.\r\n    //-------------------------------------------------------------------------\r\n    event NewColor(address indexed creator, string name);\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when colored tokens are deposited into TOY Tokens. Color\r\n    ///  equivalent to PLAY.transfer().\r\n    //-------------------------------------------------------------------------\r\n    event DepositColor(\r\n        uint indexed to, \r\n        uint indexed colorIndex, \r\n        uint tokens\r\n    );\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Emits when colored tokens are spent by any mechanism. Color\r\n    ///  equivalent to PLAY.burn().\r\n    //-------------------------------------------------------------------------\r\n    event SpendColor(\r\n        uint indexed from, \r\n        uint indexed color, \r\n        uint amount\r\n    );\r\n\r\n    // Colored token data\r\n    struct ColoredToken {\r\n        address creator;\r\n        string name;\r\n        mapping (uint => uint) balances;\r\n    }\r\n\r\n    // array containing all colored token data\r\n    ColoredToken[] coloredTokens;\r\n    // required locked tokens needed to register a color (in pWei)\r\n    uint public requiredLockedForColorRegistration = 10000 * 10**18;\r\n    // TOY Token contract to interface with\r\n    ToyTokenOwnership toy;\r\n    // UID value is 7 bytes. Max value is 2**56\r\n    uint constant UID_MAX = 0xFFFFFFFFFFFFFF;\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Set the address of the TOY Token interface to `toyAddress`.\r\n    /// @dev Throws if toyAddress is the zero address.\r\n    /// @param toyAddress The address of the TOY Token interface.\r\n    //-------------------------------------------------------------------------\r\n    function setToyTokenContractAddress (address toyAddress) \r\n        external \r\n        notZero(uint(toyAddress)) \r\n        onlyOwner\r\n    {\r\n        // initialize contract to toyAddress\r\n        toy = ToyTokenOwnership(toyAddress);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Set required total locked tokens to \r\n    ///  `(newAmount/1000000000000000000).fixed(0,18)`.\r\n    /// @dev Throws if the sender is not the contract owner. Throws if new\r\n    ///  amount is zero.\r\n    /// @param newAmount The new required locked token amount (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function setRequiredLockedForColorRegistration(uint newAmount) \r\n        external \r\n        onlyOwner\r\n        notZero(newAmount)\r\n    {\r\n        requiredLockedForColorRegistration = newAmount;\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @notice Registers `colorName` as a new colored token. Must own\r\n    ///  `requiredLockedForColorReg` locked tokens as a requirement.\r\n    /// @dev Throws if `msg.sender` has insufficient locked tokens. Throws if\r\n    ///  colorName is empty or is longer than 32 characters.\r\n    /// @param colorName The name for the new colored token.\r\n    /// @return Index number for the new colored token.\r\n    //-------------------------------------------------------------------------\r\n    function registerNewColor(string colorName) external returns (uint) {\r\n        // sender must have enough locked tokens\r\n        require (\r\n            getTotalLockedTokens(msg.sender) >= requiredLockedForColorRegistration,\r\n            \"Insufficient locked tokens\"\r\n        );\r\n        // colorName must be a valid length\r\n        require (\r\n            bytes(colorName).length > 0 && bytes(colorName).length < 32,\r\n            \"Invalid color name length\"\r\n        );\r\n        // push new colored token to colored token array and store the index\r\n        uint index = coloredTokens.push(ColoredToken(msg.sender, colorName));\r\n        return index;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Locks `(tokens/1000000000000000000).fixed(0,18)` PLAY tokens\r\n    ///  for 2 years, then deposits the same number of colored tokens with \r\n    ///  index `colorIndex` into TOY Token #`uid`.\r\n    /// @dev Throws if tokens to deposit is zero. Throws if colorIndex is\r\n    ///  greater than number of colored tokens. Throws if `msg.sender` has\r\n    ///  insufficient balance to lock. Throws if `uid` is greater than\r\n    ///  maximum UID value. Throws if token does not have an owner. Throws if\r\n    ///  sender is not the creator of the colored token.\r\n    /// @param to The Unique Identifier of the TOY Token receiving tokens.\r\n    /// @param colorIndex The index of the color to spend.\r\n    /// @param tokens The number of colored tokens to spend (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function deposit (uint colorIndex, uint to, uint tokens)\r\n        external \r\n        notZero(tokens)\r\n    {\r\n        // colorIndex must be valid color\r\n        require (colorIndex < coloredTokens.length, \"Invalid color index\");\r\n        // sender must be colored token creator\r\n        require (\r\n            msg.sender == coloredTokens[colorIndex].creator,\r\n            \"Not authorized to deposit this color\"\r\n        );\r\n        // uid must be a valid UID\r\n        require (to < UID_MAX, \"Invalid UID\");\r\n        // If TOY Token #uid is not owned, it does not exist yet.\r\n        require(toy.ownerOf(to) != address(0), \"TOY Token does not exist\");\r\n        // colorIndex must be less than the number of colored tokens.\r\n        require (colorIndex < coloredTokens.length, \"Invalid color index\");\r\n        \r\n        // Initiate lock. Fails if sender's balance is too low.\r\n        lock(2, tokens);\r\n\r\n        // add tokens to TOY Token #UID\r\n        coloredTokens[colorIndex].balances[to] += tokens;\r\n        // emit color transfer event\r\n        emit DepositColor(to, colorIndex, tokens);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Spend `(tokens/1000000000000000000).fixed(0,18)` colored \r\n    ///  tokens with index `colorIndex`.\r\n    /// @dev Throws if tokens to spend is zero. Throws if colorIndex is\r\n    ///  greater than number of colored tokens. Throws if `msg.sender` has\r\n    ///  insufficient balance to spend.\r\n    /// @param colorIndex The index of the color to spend.\r\n    /// @param from The UID of the TOY Token to spend from.\r\n    /// @param tokens The number of colored tokens to spend (in pWei).\r\n    /// @return True if spend successful. Throw if unsuccessful.\r\n    //-------------------------------------------------------------------------\r\n    function spend (uint colorIndex, uint from, uint tokens) \r\n        external \r\n        notZero(tokens)\r\n        returns(bool) \r\n    {\r\n        // colorIndex must be valid color\r\n        require (colorIndex < coloredTokens.length, \"Invalid color index\");\r\n        // sender must own TOY Token\r\n        require (\r\n            msg.sender == toy.ownerOf(from), \r\n            \"Sender is not owner of TOY Token\"\r\n        );\r\n        // token owner's balance must be enough to spend tokens\r\n        require (\r\n            coloredTokens[colorIndex].balances[from] >= tokens,\r\n            \"Insufficient tokens to spend\"\r\n        );\r\n        // deduct the tokens from the sender's balance\r\n        coloredTokens[colorIndex].balances[from] -= tokens;\r\n        // emit spend event\r\n        emit SpendColor(from, colorIndex, tokens);\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Spend `(tokens/1000000000000000000).fixed(0,18)` colored\r\n    ///  tokens with color index `index` from `from`.\r\n    /// @dev Throws if tokens to spend is zero. Throws if colorIndex is \r\n    ///  greater than number of colored tokens. Throws if `msg.sender` is not\r\n    ///  the colored token's creator. Throws if `from` has insufficient\r\n    ///  balance to spend.\r\n    /// @param colorIndex The index of the color to spend.\r\n    /// @param from The address whose colored tokens are being spent.\r\n    /// @param tokens The number of tokens to send (in pWei).\r\n    //-------------------------------------------------------------------------\r\n    function spendFrom(uint colorIndex, uint from, uint tokens)\r\n        external \r\n        notZero(tokens)\r\n        returns (bool) \r\n    {\r\n        // colorIndex must be valid color\r\n        require (colorIndex < coloredTokens.length, \"Invalid color index\");\r\n        // sender must be authorized address or operator for TOY Token\r\n        require (\r\n            msg.sender == toy.getApproved(from) ||\r\n            toy.isApprovedForAll(toy.ownerOf(from), msg.sender), \r\n            \"Sender is not authorized operator for TOY Token\"\r\n        );\r\n        // token owner's balance must be enough to spend tokens\r\n        require (\r\n            coloredTokens[colorIndex].balances[from] >= tokens,\r\n            \"Insufficient balance to spend\"\r\n        );\r\n        // deduct the tokens from token owner's balance\r\n        coloredTokens[colorIndex].balances[from] -= tokens;\r\n        // emit spend event\r\n        emit SpendColor(from, colorIndex, tokens);\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the number of colored tokens with color index `colorIndex`\r\n    ///  owned by TOY Token #`uid`.\r\n    /// @param uid The TOY Token with deposited color tokens.\r\n    /// @param colorIndex Index of the colored token to query.\r\n    /// @return The number of colored tokens with color index `colorIndex`\r\n    ///  owned by TOY Token #`uid`.\r\n    //-------------------------------------------------------------------------\r\n    function getColoredTokenBalance(uint uid, uint colorIndex) \r\n        external \r\n        view \r\n        returns(uint) \r\n    {\r\n        return coloredTokens[colorIndex].balances[uid];\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Count the number of colored token types\r\n    /// @return Number of colored token types\r\n    //-------------------------------------------------------------------------\r\n    function coloredTokenCount() external view returns (uint) {\r\n        return coloredTokens.length;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the name and creator address of colored token with index\r\n    ///  `colorIndex`\r\n    /// @param colorIndex Index of the colored token to query.\r\n    /// @return The creator address and name of colored token.\r\n    //-------------------------------------------------------------------------\r\n    function getColoredToken(uint colorIndex) \r\n        external \r\n        view \r\n        returns(address, string)\r\n    {\r\n        return (\r\n            coloredTokens[colorIndex].creator, \r\n            coloredTokens[colorIndex].name\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"colorIndex\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredLockedForColorRegistration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumLockYears\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberOfYears\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"colorIndex\",\"type\":\"uint256\"},{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"spend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"numberOfYears\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"lockFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"colorIndex\",\"type\":\"uint256\"},{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"spendFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toyAddress\",\"type\":\"address\"}],\"name\":\"setToyTokenContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"numberOfYears\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFromAndLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"numberOfYears\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAndLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateYearsSinceRelease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"colorIndex\",\"type\":\"uint256\"}],\"name\":\"getColoredToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coloredTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uid\",\"type\":\"uint256\"},{\"name\":\"colorIndex\",\"type\":\"uint256\"}],\"name\":\"getColoredTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setRequiredLockedForColorRegistration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"unlockAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"unlockByYear\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"getLockedTokensByYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"getTotalLockedTokens\",\"outputs\":[{\"name\":\"lockedTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"colorName\",\"type\":\"string\"}],\"name\":\"registerNewColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NewColor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"colorIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"DepositColor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"color\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SpendColor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ColorToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2d9619afb0ad2d878fe88e47a85f72fb0f3388ee154eb0345538920dde0cca2b"}]}