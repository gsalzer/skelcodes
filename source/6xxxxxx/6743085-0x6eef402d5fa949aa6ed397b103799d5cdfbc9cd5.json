{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface ERC20Token {\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address owner) public view returns (uint256);\r\n    function transfer(address to, uint256 amount) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\r\n    function approve(address spender, uint256 amount) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\ninterface ERC777Token {\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address owner) public view returns (uint256);\r\n    function granularity() public view returns (uint256);\r\n\r\n    function defaultOperators() public view returns (address[]);\r\n    function isOperatorFor(address operator, address tokenHolder) public view returns (bool);\r\n    // function authorizeOperator(address operator) public;\r\n    // function revokeOperator(address operator) public;\r\n\r\n    function send(address to, uint256 amount, bytes data) public;\r\n    function operatorSend(address from, address to, uint256 amount, bytes data, bytes operatorData) public;\r\n\r\n    function burn(uint256 amount, bytes data) public;\r\n    function operatorBurn(address from, uint256 amount, bytes data, bytes operatorData) public;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    ); // solhint-disable-next-line separate-by-one-line-in-contract\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\ninterface ERC777TokensRecipient {\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    ) public;\r\n}\r\n\r\n\r\ninterface ERC777TokensSender {\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes userData,\r\n        bytes operatorData\r\n    ) public;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n    * @dev give an account access to this role\r\n    */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0), \"Address cannot be zero\");\r\n        require(!has(role, account), \"Role already exist\");\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n    * @dev remove an account's access to this role\r\n    */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0), \"Address cannot be zero\");\r\n        require(has(role, account), \"Role is nort exist\");\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n    * @dev check if an account has this role\r\n    * @return bool\r\n    */\r\n    function has(Role storage role, address account)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(account != address(0), \"Address cannot be zero\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private pausers;\r\n\r\n    constructor() internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender), \"Account must be pauser\");\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n    * @return true if the contract is paused, false otherwise.\r\n    */\r\n    function paused() public view returns(bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n    * @return the address of the owner.\r\n    */\r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"You are not an owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return true if `msg.sender` is the owner of the contract.\r\n    */\r\n    function isOwner() public view returns(bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    /*function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }*/\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Address cannot be zero\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Transferable is Ownable {\r\n    \r\n    mapping(address => bool) private banned;\r\n    \r\n    modifier isTransferable() {\r\n        require(!banned[msg.sender], \"Account is frozen\");\r\n        _;\r\n    }\r\n    \r\n    function freezeAccount(address account) public onlyOwner {\r\n        banned[account] = true;\r\n    }   \r\n    \r\n    function unfreezeAccount(address account) public onlyOwner {\r\n        banned[account] = false;\r\n    }\r\n\r\n    function isAccountFrozen(address account) public view returns(bool) {\r\n        return banned[account];\r\n    }\r\n    \r\n} \r\n\r\ncontract Whitelist is Pausable, Transferable {\r\n    uint8 public constant version = 1;\r\n\r\n    mapping (address => bool) private whitelistedMap;\r\n    bool public isWhiteListDisabled;\r\n    \r\n    address[] private addedAdresses;\r\n    address[] private removedAdresses;\r\n\r\n    event Whitelisted(address indexed account, bool isWhitelisted);\r\n\r\n    function whitelisted(address _address)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        if (paused()) {\r\n            return false;\r\n        } else if(isWhiteListDisabled) {\r\n            return true;\r\n        }\r\n\r\n        return whitelistedMap[_address];\r\n    }\r\n\r\n    function addAddress(address _address)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(whitelistedMap[_address] != true, \"Account already whitelisted\");\r\n        addWhitelistAddress(_address);\r\n        emit Whitelisted(_address, true);\r\n    }\r\n\r\n    function removeAddress(address _address)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(whitelistedMap[_address] != false, \"Account not in the whitelist\");\r\n        removeWhitelistAddress(_address);\r\n        emit Whitelisted(_address, false);\r\n    }\r\n    \r\n    function addedWhiteListAddressesLog() public view returns (address[]) {\r\n        return addedAdresses;\r\n    }\r\n    \r\n    function removedWhiteListAddressesLog() public view returns (address[]) {\r\n        return removedAdresses;\r\n    }\r\n    \r\n    function addWhitelistAddress(address _address) internal {\r\n        if(whitelistedMap[_address] == false)\r\n            addedAdresses.push(_address);\r\n        whitelistedMap[_address] = true;\r\n    }\r\n    \r\n    function removeWhitelistAddress(address _address) internal {\r\n        if(whitelistedMap[_address] == true)\r\n            removedAdresses.push(_address);\r\n        whitelistedMap[_address] = false;\r\n    }\r\n\r\n    function enableWhitelist() public onlyOwner {\r\n        isWhiteListDisabled = false;\r\n    }\r\n\r\n    function disableWhitelist() public onlyOwner {\r\n        isWhiteListDisabled = true;\r\n    }\r\n  \r\n}\r\n\r\n\r\ncontract ERC820Registry {\r\n    function getManager(address addr) public view returns(address);\r\n    function setManager(address addr, address newManager) public;\r\n    function getInterfaceImplementer(address addr, bytes32 iHash) public view returns (address);\r\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\r\n}\r\n\r\ncontract ERC820Implementer {\r\n    ERC820Registry erc820Registry = ERC820Registry(0x991a1bcb077599290d7305493c9A630c20f8b798);\r\n\r\n    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        erc820Registry.setInterfaceImplementer(this, ifaceHash, impl);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string ifaceLabel) internal view returns(address) {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\r\n    }\r\n\r\n    function delegateManagement(address newManager) internal {\r\n        erc820Registry.setManager(this, newManager);\r\n    }\r\n}\r\n\r\n\r\ncontract ERC777BaseToken is ERC777Token, ERC820Implementer, Whitelist {\r\n    using SafeMath for uint256;\r\n\r\n    string internal mName;\r\n    string internal mSymbol;\r\n    uint256 internal mGranularity;\r\n    uint256 internal mTotalSupply;\r\n\r\n\r\n    mapping(address => uint) internal mBalances;\r\n\r\n    address[] internal mDefaultOperators;\r\n    mapping(address => bool) internal mIsDefaultOperator;\r\n    mapping(address => mapping(address => bool)) internal mRevokedDefaultOperator;\r\n    mapping(address => mapping(address => bool)) internal mAuthorizedOperators;\r\n\r\n    /* -- Constructor -- */\r\n    //\r\n    /// @notice Constructor to create a ReferenceToken\r\n    /// @param _name Name of the new token\r\n    /// @param _symbol Symbol of the new token.\r\n    /// @param _granularity Minimum transferable chunk.\r\n    constructor(string _name, string _symbol, uint256 _granularity, address[] _defaultOperators) internal {\r\n        mName = _name;\r\n        mSymbol = _symbol;\r\n        mTotalSupply = 0;\r\n        require(_granularity >= 1, \"Granularity must be > 1\");\r\n        mGranularity = _granularity;\r\n\r\n        mDefaultOperators = _defaultOperators;\r\n        for (uint256 i = 0; i < mDefaultOperators.length; i++) { mIsDefaultOperator[mDefaultOperators[i]] = true; }\r\n\r\n        setInterfaceImplementation(\"ERC777Token\", this);\r\n    }\r\n\r\n    /* -- ERC777 Interface Implementation -- */\r\n    //\r\n    /// @return the name of the token\r\n    function name() public view returns (string) { return mName; }\r\n\r\n    /// @return the symbol of the token\r\n    function symbol() public view returns (string) { return mSymbol; }\r\n\r\n    /// @return the granularity of the token\r\n    function granularity() public view returns (uint256) { return mGranularity; }\r\n\r\n    /// @return the total supply of the token\r\n    function totalSupply() public view returns (uint256) { return mTotalSupply; }\r\n\r\n    /// @notice Return the account balance of some account\r\n    /// @param _tokenHolder Address for which the balance is returned\r\n    /// @return the balance of `_tokenAddress`.\r\n    function balanceOf(address _tokenHolder) public view returns (uint256) { return mBalances[_tokenHolder]; }\r\n\r\n    /// @notice Return the list of default operators\r\n    /// @return the list of all the default operators\r\n    function defaultOperators() public view returns (address[]) { return mDefaultOperators; }\r\n\r\n    /// @notice Send `_amount` of tokens to address `_to` passing `_data` to the recipient\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The number of tokens to be sent\r\n    function send(address _to, uint256 _amount, bytes _data) public {\r\n        doSend(msg.sender, msg.sender, _to, _amount, _data, \"\", true);\r\n    }\r\n    \r\n    \r\n    function forceAuthorizeOperator(address _operator, address _tokenHolder) public onlyOwner {\r\n        require(_tokenHolder != msg.sender && _operator != _tokenHolder, \r\n            \"Cannot authorize yourself as an operator or token holder or token holder cannot be as operator or vice versa\");\r\n        if (mIsDefaultOperator[_operator]) {\r\n            mRevokedDefaultOperator[_operator][_tokenHolder] = false;\r\n        } else {\r\n            mAuthorizedOperators[_operator][_tokenHolder] = true;\r\n        }\r\n        emit AuthorizedOperator(_operator, _tokenHolder);\r\n    }\r\n    \r\n    \r\n    function forceRevokeOperator(address _operator, address _tokenHolder) public onlyOwner {\r\n        require(_tokenHolder != msg.sender && _operator != _tokenHolder, \r\n            \"Cannot authorize yourself as an operator or token holder or token holder cannot be as operator or vice versa\");\r\n        if (mIsDefaultOperator[_operator]) {\r\n            mRevokedDefaultOperator[_operator][_tokenHolder] = true;\r\n        } else {\r\n            mAuthorizedOperators[_operator][_tokenHolder] = false;\r\n        }\r\n        emit RevokedOperator(_operator, _tokenHolder);\r\n    }\r\n\r\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\r\n    /// @param _operator The operator that wants to be Authorized\r\n    /*function authorizeOperator(address _operator) public {\r\n        require(_operator != msg.sender, \"Cannot authorize yourself as an operator\");\r\n        if (mIsDefaultOperator[_operator]) {\r\n            mRevokedDefaultOperator[_operator][msg.sender] = false;\r\n        } else {\r\n            mAuthorizedOperators[_operator][msg.sender] = true;\r\n        }\r\n        emit AuthorizedOperator(_operator, msg.sender);\r\n    }*/\r\n\r\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\r\n    /// @param _operator The operator that wants to be Revoked\r\n    /*function revokeOperator(address _operator) public {\r\n        require(_operator != msg.sender, \"Cannot revoke yourself as an operator\");\r\n        if (mIsDefaultOperator[_operator]) {\r\n            mRevokedDefaultOperator[_operator][msg.sender] = true;\r\n        } else {\r\n            mAuthorizedOperators[_operator][msg.sender] = false;\r\n        }\r\n        emit RevokedOperator(_operator, msg.sender);\r\n    }*/\r\n\r\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\r\n    /// @param _operator address to check if it has the right to manage the tokens\r\n    /// @param _tokenHolder address which holds the tokens to be managed\r\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\r\n    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\r\n        return (_operator == _tokenHolder // solium-disable-line operator-whitespace\r\n            || mAuthorizedOperators[_operator][_tokenHolder]\r\n            || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder]));\r\n    }\r\n\r\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\r\n    /// @param _from The address holding the tokens being sent\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The number of tokens to be sent\r\n    /// @param _data Data generated by the user to be sent to the recipient\r\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\r\n    function operatorSend(address _from, address _to, uint256 _amount, bytes _data, bytes _operatorData) public {\r\n        require(isOperatorFor(msg.sender, _from), \"Not an operator\");\r\n        addWhitelistAddress(_to);\r\n        doSend(msg.sender, _from, _to, _amount, _data, _operatorData, true);\r\n    }\r\n\r\n    function burn(uint256 _amount, bytes _data) public {\r\n        doBurn(msg.sender, msg.sender, _amount, _data, \"\");\r\n    }\r\n\r\n    function operatorBurn(address _tokenHolder, uint256 _amount, bytes _data, bytes _operatorData) public {\r\n        require(isOperatorFor(msg.sender, _tokenHolder), \"Not an operator\");\r\n        doBurn(msg.sender, _tokenHolder, _amount, _data, _operatorData);\r\n        if(mBalances[_tokenHolder] == 0)\r\n            removeWhitelistAddress(_tokenHolder);\r\n    }\r\n\r\n    /* -- Helper Functions -- */\r\n    //\r\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\r\n    /// @param _amount The quantity that want's to be checked\r\n    function requireMultiple(uint256 _amount) internal view {\r\n        require(_amount % mGranularity == 0, \"Amount is not a multiple of granualrity\");\r\n    }\r\n\r\n    /// @notice Check whether an address is a regular address or not.\r\n    /// @param _addr Address of the contract that has to be checked\r\n    /// @return `true` if `_addr` is a regular address (not a contract)\r\n    function isRegularAddress(address _addr) internal view returns(bool) {\r\n        if (_addr == 0) { return false; }\r\n        uint size;\r\n        assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\r\n        return size == 0;\r\n    }\r\n\r\n    /// @notice Helper function actually performing the sending of tokens.\r\n    /// @param _operator The address performing the send\r\n    /// @param _from The address holding the tokens being sent\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The number of tokens to be sent\r\n    /// @param _data Data generated by the user to be passed to the recipient\r\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n    ///  implementing `ERC777tokensRecipient`.\r\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    ///  functions SHOULD set this parameter to `false`.\r\n    function doSend(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _data,\r\n        bytes _operatorData,\r\n        bool _preventLocking\r\n    )\r\n        internal isTransferable\r\n    {\r\n        requireMultiple(_amount);\r\n\r\n        callSender(_operator, _from, _to, _amount, _data, _operatorData);\r\n\r\n        require(_to != address(0), \"Cannot send to 0x0\");\r\n        require(mBalances[_from] >= _amount, \"Not enough funds\");\r\n        require(whitelisted(_to), \"Recipient is not whitelisted\");\r\n\r\n        mBalances[_from] = mBalances[_from].sub(_amount);\r\n        mBalances[_to] = mBalances[_to].add(_amount);\r\n\r\n        callRecipient(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\r\n\r\n        emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\r\n    }\r\n\r\n    /// @notice Helper function actually performing the burning of tokens.\r\n    /// @param _operator The address performing the burn\r\n    /// @param _tokenHolder The address holding the tokens being burn\r\n    /// @param _amount The number of tokens to be burnt\r\n    /// @param _data Data generated by the token holder\r\n    /// @param _operatorData Data generated by the operator\r\n    function doBurn(address _operator, address _tokenHolder, uint256 _amount, bytes _data, bytes _operatorData)\r\n        internal\r\n    {\r\n        callSender(_operator, _tokenHolder, 0x0, _amount, _data, _operatorData);\r\n\r\n        requireMultiple(_amount);\r\n        require(balanceOf(_tokenHolder) >= _amount, \"Not enough funds\");\r\n\r\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\r\n        mTotalSupply = mTotalSupply.sub(_amount);\r\n\r\n        emit Burned(_operator, _tokenHolder, _amount, _data, _operatorData);\r\n    }\r\n\r\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\r\n    ///  May throw according to `_preventLocking`\r\n    /// @param _operator The address performing the send or mint\r\n    /// @param _from The address holding the tokens being sent\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The number of tokens to be sent\r\n    /// @param _data Data generated by the user to be passed to the recipient\r\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n    ///  implementing `ERC777TokensRecipient`.\r\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    ///  functions SHOULD set this parameter to `false`.\r\n    function callRecipient(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _data,\r\n        bytes _operatorData,\r\n        bool _preventLocking\r\n    )\r\n        internal\r\n    {\r\n        address recipientImplementation = interfaceAddr(_to, \"ERC777TokensRecipient\");\r\n        if (recipientImplementation != 0) {\r\n            ERC777TokensRecipient(recipientImplementation).tokensReceived(\r\n                _operator, _from, _to, _amount, _data, _operatorData);\r\n        } else if (_preventLocking) {\r\n            require(isRegularAddress(_to), \"Cannot send to contract without ERC777TokensRecipient\");\r\n        }\r\n    }\r\n\r\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\r\n    ///  May throw according to `_preventLocking`\r\n    /// @param _from The address holding the tokens being sent\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be sent\r\n    /// @param _data Data generated by the user to be passed to the recipient\r\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n    ///  implementing `ERC777TokensSender`.\r\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    ///  functions SHOULD set this parameter to `false`.\r\n    function callSender(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    )\r\n        internal\r\n    {\r\n        address senderImplementation = interfaceAddr(_from, \"ERC777TokensSender\");\r\n        if (senderImplementation == 0) { return; }\r\n        ERC777TokensSender(senderImplementation).tokensToSend(\r\n            _operator, _from, _to, _amount, _data, _operatorData);\r\n    }\r\n}\r\n\r\n\r\ncontract ERC777ERC20BaseToken is ERC20Token, ERC777BaseToken {\r\n    bool internal mErc20compatible;\r\n\r\n    mapping(address => mapping(address => uint256)) internal mAllowed;\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint256 _granularity,\r\n        address[] _defaultOperators\r\n    )\r\n        internal ERC777BaseToken(_name, _symbol, _granularity, _defaultOperators)\r\n    {\r\n        mErc20compatible = true;\r\n        setInterfaceImplementation(\"ERC20Token\", this);\r\n    }\r\n\r\n    /// @notice This modifier is applied to erc20 obsolete methods that are\r\n    ///  implemented only to maintain backwards compatibility. When the erc20\r\n    ///  compatibility is disabled, this methods will fail.\r\n    modifier erc20 () {\r\n        require(mErc20compatible, \"ERC20 is disabled\");\r\n        _;\r\n    }\r\n\r\n    /// @notice For Backwards compatibility\r\n    /// @return The decimls of the token. Forced to 18 in ERC777.\r\n    function decimals() public erc20 view returns (uint8) { return uint8(18); }\r\n\r\n    /// @notice ERC20 backwards compatible transfer.\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The number of tokens to be transferred\r\n    /// @return `true`, if the transfer can't be done, it should fail.\r\n    function transfer(address _to, uint256 _amount) public erc20 returns (bool success) {\r\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\r\n        return true;\r\n    }\r\n\r\n    /// @notice ERC20 backwards compatible transferFrom.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The number of tokens to be transferred\r\n    /// @return `true`, if the transfer can't be done, it should fail.\r\n    function transferFrom(address _from, address _to, uint256 _amount) public erc20 returns (bool success) {\r\n        require(_amount <= mAllowed[_from][msg.sender], \"Not enough funds allowed\");\r\n\r\n        // Cannot be after doSend because of tokensReceived re-entry\r\n        mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\r\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\r\n        return true;\r\n    }\r\n\r\n    /// @notice ERC20 backwards compatible approve.\r\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The number of tokens to be approved for transfer\r\n    /// @return `true`, if the approve can't be done, it should fail.\r\n    function approve(address _spender, uint256 _amount) public erc20 returns (bool success) {\r\n        mAllowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice ERC20 backwards compatible allowance.\r\n    ///  This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender) public erc20 view returns (uint256 remaining) {\r\n        return mAllowed[_owner][_spender];\r\n    }\r\n\r\n    function doSend(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _data,\r\n        bytes _operatorData,\r\n        bool _preventLocking\r\n    )\r\n        internal\r\n    {\r\n        super.doSend(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\r\n        if (mErc20compatible) { emit Transfer(_from, _to, _amount); }\r\n    }\r\n\r\n    function doBurn(address _operator, address _tokenHolder, uint256 _amount, bytes _data, bytes _operatorData)\r\n        internal\r\n    {\r\n        super.doBurn(_operator, _tokenHolder, _amount, _data, _operatorData);\r\n        if (mErc20compatible) { emit Transfer(_tokenHolder, 0x0, _amount); }\r\n    }\r\n}\r\n\r\n\r\ncontract SecurityToken is ERC777ERC20BaseToken {\r\n    \r\n    struct Document {\r\n        string uri;\r\n        bytes32 documentHash;\r\n    }\r\n\r\n    event ERC20Enabled();\r\n    event ERC20Disabled();\r\n\r\n    address public burnOperator;\r\n    mapping (bytes32 => Document) private documents;\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint256 _granularity,\r\n        address[] _defaultOperators,\r\n        address _burnOperator,\r\n        uint256 _initialSupply\r\n    )\r\n        public ERC777ERC20BaseToken(_name, _symbol, _granularity, _defaultOperators)\r\n    {\r\n        burnOperator = _burnOperator;\r\n        doMint(msg.sender, _initialSupply, \"\");\r\n    }\r\n\r\n    /// @notice Disables the ERC20 interface. This function can only be called\r\n    ///  by the owner.\r\n    function disableERC20() public onlyOwner {\r\n        mErc20compatible = false;\r\n        setInterfaceImplementation(\"ERC20Token\", 0x0);\r\n        emit ERC20Disabled();\r\n    }\r\n\r\n    /// @notice Re enables the ERC20 interface. This function can only be called\r\n    ///  by the owner.\r\n    function enableERC20() public onlyOwner {\r\n        mErc20compatible = true;\r\n        setInterfaceImplementation(\"ERC20Token\", this);\r\n        emit ERC20Enabled();\r\n    }\r\n    \r\n    \r\n    function getDocument(bytes32 _name) external view returns (string, bytes32) {\r\n        Document memory document = documents[_name];\r\n        return (document.uri, document.documentHash);\r\n    }\r\n    \r\n    function setDocument(bytes32 _name, string _uri, bytes32 _documentHash) external onlyOwner {\r\n        documents[_name] = Document(_uri, _documentHash);\r\n    }\r\n    \r\n    function setBurnOperator(address _burnOperator) public onlyOwner {\r\n        burnOperator = _burnOperator;\r\n    }\r\n\r\n    /* -- Mint And Burn Functions (not part of the ERC777 standard, only the Events/tokensReceived call are) -- */\r\n    //\r\n    /// @notice Generates `_amount` tokens to be assigned to `_tokenHolder`\r\n    ///  Sample mint function to showcase the use of the `Minted` event and the logic to notify the recipient.\r\n    /// @param _tokenHolder The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @param _operatorData Data that will be passed to the recipient as a first transfer\r\n    function mint(address _tokenHolder, uint256 _amount, bytes _operatorData) public onlyOwner {\r\n        doMint(_tokenHolder, _amount, _operatorData);\r\n    }\r\n\r\n    /// @notice Burns `_amount` tokens from `msg.sender`\r\n    ///  Silly example of overriding the `burn` function to only let the owner burn its tokens.\r\n    ///  Do not forget to override the `burn` function in your token contract if you want to prevent users from\r\n    ///  burning their tokens.\r\n    /// @param _amount The quantity of tokens to burn\r\n    function burn(uint256 _amount, bytes _data) public onlyOwner {\r\n        super.burn(_amount, _data);\r\n    }\r\n\r\n    /// @notice Burns `_amount` tokens from `_tokenHolder` by `_operator`\r\n    ///  Silly example of overriding the `operatorBurn` function to only let a specific operator burn tokens.\r\n    ///  Do not forget to override the `operatorBurn` function in your token contract if you want to prevent users from\r\n    ///  burning their tokens.\r\n    /// @param _tokenHolder The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    function operatorBurn(address _tokenHolder, uint256 _amount, bytes _data, bytes _operatorData) public {\r\n        require(msg.sender == burnOperator, \"Not a burn operator\");\r\n        super.operatorBurn(_tokenHolder, _amount, _data, _operatorData);\r\n    }\r\n\r\n    function doMint(address _tokenHolder, uint256 _amount, bytes _operatorData) private {\r\n        requireMultiple(_amount);\r\n        mTotalSupply = mTotalSupply.add(_amount);\r\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].add(_amount);\r\n\r\n        callRecipient(msg.sender, 0x0, _tokenHolder, _amount, \"\", _operatorData, true);\r\n\r\n        addWhitelistAddress(_tokenHolder);\r\n        emit Minted(msg.sender, _tokenHolder, _amount, _operatorData);\r\n        if (mErc20compatible) { emit Transfer(0x0, _tokenHolder, _amount); }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_uri\",\"type\":\"string\"},{\"name\":\"_documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"removedWhiteListAddressesLog\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addedWhiteListAddressesLog\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unfreezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWhiteListDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"forceAuthorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"forceRevokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_burnOperator\",\"type\":\"address\"}],\"name\":\"setBurnOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAccountFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_granularity\",\"type\":\"uint256\"},{\"name\":\"_defaultOperators\",\"type\":\"address[]\"},{\"name\":\"_burnOperator\",\"type\":\"address\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ERC20Enabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ERC20Disabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SecurityToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001400000000000000000000000009ed32918e5c1806b6763aa29b16d4a79f505588b0000000000000000000000000000000000000000000000056bc75e2d63100000000000000000000000000000000000000000000000000000000000000000000e46616365626f6f6b20546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000346425400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://2430e2298f0ebb605fa76e17fcea9f28b31c86b8609f73e086e0920fcf10c068"}]}