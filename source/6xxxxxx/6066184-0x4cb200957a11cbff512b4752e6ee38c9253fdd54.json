{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/* ==================================================================== */\r\n/* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved.\r\n/* \r\n/* https://www.magicacademy.io One of the world's first idle strategy games of blockchain \r\n/*  \r\n/* authors rainy@livestar.com/Jony.Fu@livestar.com\r\n/*                 \r\n/* ==================================================================== */\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /*\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract AccessAdmin is Ownable {\r\n\r\n  /// @dev Admin Address\r\n  mapping (address => bool) adminContracts;\r\n\r\n  /// @dev Trust contract\r\n  mapping (address => bool) actionContracts;\r\n\r\n  function setAdminContract(address _addr, bool _useful) public onlyOwner {\r\n    require(_addr != address(0));\r\n    adminContracts[_addr] = _useful;\r\n  }\r\n\r\n  modifier onlyAdmin {\r\n    require(adminContracts[msg.sender]); \r\n    _;\r\n  }\r\n\r\n  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\r\n    actionContracts[_actionAddr] = _useful;\r\n  }\r\n\r\n  modifier onlyAccess() {\r\n    require(actionContracts[msg.sender]);\r\n    _;\r\n  }\r\n}\r\n\r\ninterface CardsInterface {\r\n  function balanceOf(address player) public constant returns(uint256);\r\n  function updatePlayersCoinByOut(address player) external;\r\n  function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public;\r\n  function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\r\n  function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\r\n}\r\ninterface RareInterface {\r\n  function getRareItemsOwner(uint256 rareId) external view returns (address);\r\n  function getRareItemsPrice(uint256 rareId) external view returns (uint256);\r\n    function getRareInfo(uint256 _tokenId) external view returns (\r\n    uint256 sellingPrice,\r\n    address owner,\r\n    uint256 nextPrice,\r\n    uint256 rareClass,\r\n    uint256 cardId,\r\n    uint256 rareValue\r\n  ); \r\n  function transferToken(address _from, address _to, uint256 _tokenId) external;\r\n  function transferTokenByContract(uint256 _tokenId,address _to) external;\r\n  function setRarePrice(uint256 _rareId, uint256 _price) external;\r\n  function rareStartPrice() external view returns (uint256);\r\n}\r\ncontract CardsRaffle is AccessAdmin {\r\n  using SafeMath for SafeMath;\r\n\r\n  function CardsRaffle() public {\r\n    setAdminContract(msg.sender,true);\r\n    setActionContract(msg.sender,true);\r\n  }\r\n  //data contract\r\n  CardsInterface public cards ;\r\n  RareInterface public rare;\r\n\r\n  function setCardsAddress(address _address) external onlyOwner {\r\n    cards = CardsInterface(_address);\r\n  }\r\n\r\n  //rare cards\r\n  function setRareAddress(address _address) external onlyOwner {\r\n    rare = RareInterface(_address);\r\n  }\r\n\r\n  function getRareAddress() public view returns (address) {\r\n    return rare;\r\n  }\r\n\r\n  //event\r\n  event UnitBought(address player, uint256 unitId, uint256 amount);\r\n  event RaffleSuccessful(address winner);\r\n\r\n  // Raffle structures\r\n  struct TicketPurchases {\r\n    TicketPurchase[] ticketsBought;\r\n    uint256 numPurchases; // Allows us to reset without clearing TicketPurchase[] (avoids potential for gas limit)\r\n    uint256 raffleRareId;\r\n  }\r\n    \r\n  // Allows us to query winner without looping (avoiding potential for gas limit)\r\n  struct TicketPurchase {\r\n    uint256 startId;\r\n    uint256 endId;\r\n  }\r\n    \r\n  // Raffle tickets\r\n  mapping(address => TicketPurchases) private ticketsBoughtByPlayer;\r\n  mapping(uint256 => address[]) private rafflePlayers; // Keeping a seperate list for each raffle has it's benefits. \r\n\r\n  uint256 private constant RAFFLE_TICKET_BASE_PRICE = 10000;\r\n  uint256 private constant MAX_LIMIT = 1000;\r\n\r\n  // Current raffle info  \r\n  uint256 private raffleEndTime;\r\n  uint256 private raffleRareId;\r\n  uint256 private raffleTicketsBought;\r\n  address private raffleWinner; // Address of winner\r\n  bool private raffleWinningTicketSelected;\r\n  uint256 private raffleTicketThatWon;\r\n\r\n  // Raffle for rare items  \r\n  function buyRaffleTicket(uint256 amount) external {\r\n    require(raffleEndTime >= block.timestamp);  //close it if need test\r\n    require(amount > 0 && amount<=MAX_LIMIT);\r\n        \r\n    uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);\r\n    require(cards.balanceOf(msg.sender) >= ticketsCost);\r\n        \r\n    // Update player's jade  \r\n    cards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);\r\n        \r\n    // Handle new tickets\r\n    TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\r\n        \r\n    // If we need to reset tickets from a previous raffle\r\n    if (purchases.raffleRareId != raffleRareId) {\r\n      purchases.numPurchases = 0;\r\n      purchases.raffleRareId = raffleRareId;\r\n      rafflePlayers[raffleRareId].push(msg.sender); // Add user to raffle\r\n    }\r\n        \r\n    // Store new ticket purchase \r\n    if (purchases.numPurchases == purchases.ticketsBought.length) {\r\n      purchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);\r\n    }\r\n    purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1)); // (eg: buy 10, get id's 0-9)\r\n        \r\n    // Finally update ticket total\r\n    raffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);\r\n    //event\r\n    UnitBought(msg.sender,raffleRareId,amount);\r\n  } \r\n\r\n  /// @dev start raffle\r\n  function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {\r\n    require(rareId>0);\r\n    require(rare.getRareItemsOwner(rareId) == getRareAddress());\r\n    require(block.timestamp < endTime); //close it if need test\r\n\r\n    if (raffleRareId != 0) { // Sanity to assure raffle has ended before next one starts\r\n      require(raffleWinner != 0);\r\n    }\r\n\r\n    // Reset previous raffle info\r\n    raffleWinningTicketSelected = false;\r\n    raffleTicketThatWon = 0;\r\n    raffleWinner = 0;\r\n    raffleTicketsBought = 0;\r\n        \r\n    // Set current raffle info\r\n    raffleEndTime = endTime;\r\n    raffleRareId = rareId;\r\n  }\r\n\r\n  function awardRafflePrize(address checkWinner, uint256 checkIndex) external { \r\n    require(raffleEndTime < block.timestamp);  //close it if need test\r\n    require(raffleWinner == 0);\r\n    require(rare.getRareItemsOwner(raffleRareId) == getRareAddress());\r\n        \r\n    if (!raffleWinningTicketSelected) {\r\n      drawRandomWinner(); // Ideally do it in one call (gas limit cautious)\r\n    }\r\n        \r\n  // Reduce gas by (optionally) offering an address to _check_ for winner\r\n    if (checkWinner != 0) {\r\n      TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\r\n      if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\r\n        TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\r\n        if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\r\n          assignRafflePrize(checkWinner); // WINNER!\r\n          return;\r\n        }\r\n      }\r\n    }\r\n        \r\n  // Otherwise just naively try to find the winner (will work until mass amounts of players)\r\n    for (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\r\n      address player = rafflePlayers[raffleRareId][i];\r\n      TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\r\n            \r\n      uint256 endIndex = playersTickets.numPurchases - 1;\r\n      // Minor optimization to avoid checking every single player\r\n      if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\r\n        for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\r\n          TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\r\n          if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\r\n            assignRafflePrize(player); // WINNER!\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function assignRafflePrize(address winner) internal {\r\n    raffleWinner = winner;\r\n    uint256 newPrice = (rare.rareStartPrice() * 25) / 20;\r\n    rare.transferTokenByContract(raffleRareId,winner);\r\n    rare.setRarePrice(raffleRareId,newPrice);\r\n       \r\n    cards.updatePlayersCoinByOut(winner);\r\n    uint256 upgradeClass;\r\n    uint256 unitId;\r\n    uint256 upgradeValue;\r\n    (,,,,upgradeClass, unitId, upgradeValue) = rare.getRareInfo(raffleRareId);\r\n    \r\n    cards.upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);\r\n    //event\r\n    RaffleSuccessful(winner);\r\n  }\r\n  \r\n  // Random enough for small contests (Owner only to prevent trial & error execution)\r\n  function drawRandomWinner() public onlyAdmin {\r\n    require(raffleEndTime < block.timestamp); //close it if need to test\r\n    require(!raffleWinningTicketSelected);\r\n        \r\n    uint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);\r\n    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\r\n    raffleWinningTicketSelected = true;\r\n  }  \r\n\r\n  // To allow clients to verify contestants\r\n  function getRafflePlayers(uint256 raffleId) external constant returns (address[]) {\r\n    return (rafflePlayers[raffleId]);\r\n  }\r\n\r\n    // To allow clients to verify contestants\r\n  function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {\r\n    TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\r\n        \r\n    if (playersTickets.raffleRareId == raffleRareId) {\r\n      uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\r\n      uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\r\n            \r\n      for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\r\n        startIds[i] = playersTickets.ticketsBought[i].startId;\r\n        endIds[i] = playersTickets.ticketsBought[i].endId;\r\n      }\r\n    }\r\n        \r\n    return (startIds, endIds);\r\n  }\r\n\r\n\r\n  // To display on website\r\n  function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\r\n    return (raffleEndTime, raffleRareId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);\r\n  }    \r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setAdminContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRareAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayersTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLatestRaffleInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"checkWinner\",\"type\":\"address\"},{\"name\":\"checkIndex\",\"type\":\"uint256\"}],\"name\":\"awardRafflePrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rare\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCardsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actionAddr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setActionContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRareAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getRafflePlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyRaffleTicket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drawRandomWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"rareId\",\"type\":\"uint256\"}],\"name\":\"startRareRaffle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnitBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"RaffleSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CardsRaffle","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f535911cd253488d32451f155e9482adf99d4094130f505f12a9a06b60a69090"}]}