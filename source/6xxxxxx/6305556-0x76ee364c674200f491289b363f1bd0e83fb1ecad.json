{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary StringUtils {\r\n\r\n  /**\r\n   * @notice Returns true if and only if source string\r\n   *      contains the specified query substring.\r\n   * @param source the string to look in.\r\n   * @param query the substring to search for.\r\n   * @return true if this string contains `query`, false otherwise\r\n   */\r\n  function contains(string source, string query) internal pure returns (bool) {\r\n    // delegate call to `indexOf` and verify the result is not -1\r\n    return indexOf(source, query) != -1;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the index within source ASCII string of the\r\n   *      first occurrence of the query substring.\r\n   *      If source string doesn't contain query substring, then -1 is returned.\r\n   * @param source the string to look in.\r\n   * @param query the substring to search for.\r\n   * @return the index of the first occurrence of the specified substring,\r\n   *      or -1 if there is no such occurrence.\r\n   */\r\n  function indexOf(string source, string query) internal pure returns (int256) {\r\n    // delegate call to `indexOf` with a zero `fromIndex`\r\n    return indexOf(source, query, 0);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the index within source ASCII string of the\r\n   *      first occurrence of the query substring, starting at the specified index.\r\n   *      If source string doesn't contain query substring, then -1 is returned.\r\n   * @param source the string to look in.\r\n   * @param query the substring to search for.\r\n   * @param fromIndex the index from which to start the search.\r\n   * @return the index of the first occurrence of the specified substring,\r\n   *      or -1 if there is no such occurrence.\r\n   */\r\n  function indexOf(string source, string query, uint256 fromIndex) internal pure returns (int256) {\r\n    // convert source into bytes, that's why only ASCII is supported\r\n    bytes memory sourceBytes = bytes(source);\r\n\r\n    // convert query into bytes, that's why only ASCII is supported\r\n    bytes memory queryBytes = bytes(query);\r\n\r\n    // empty string exists in any string at index zero\r\n    if(queryBytes.length == 0) {\r\n      // index zero\r\n      return 0;\r\n    }\r\n\r\n    // ensure query string is not longer than source string\r\n    if(sourceBytes.length < queryBytes.length) {\r\n      // if query is longer, it cannot be a substring\r\n      return -1;\r\n    }\r\n\r\n    // search for a substring match, index `i` points to position in `source`\r\n    for(uint256 i = fromIndex; i < sourceBytes.length - queryBytes.length; i++) {\r\n      // index `j` points to position in `query`\r\n      uint256 j = 0;\r\n      // search for substring at position `i`\r\n      while(j < queryBytes.length && queryBytes[j] == sourceBytes[j + i]) {\r\n        // increment index `j`\r\n        j++;\r\n      }\r\n      // check for full substring match\r\n      if(j == queryBytes.length) {\r\n        // substring found, return an index `i` as a result\r\n        return int256(i);\r\n      }\r\n    }\r\n\r\n    // substring match not found, return -1\r\n    return -1;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Access control module provides an API to check\r\n *      if specific operation is permitted globally and\r\n *      if particular user's has a permission to execute it\r\n */\r\ncontract AccessControl {\r\n  /// @notice Role manager is responsible for assigning the roles\r\n  /// @dev Role ROLE_ROLE_MANAGER allows executing addOperator/removeOperator\r\n  uint256 private constant ROLE_ROLE_MANAGER = 0x10000000;\r\n\r\n  /// @notice Feature manager is responsible for enabling/disabling\r\n  ///      global features of the smart contract\r\n  /// @dev Role ROLE_FEATURE_MANAGER allows enabling/disabling global features\r\n  uint256 private constant ROLE_FEATURE_MANAGER = 0x20000000;\r\n\r\n  /// @dev Bitmask representing all the possible permissions (super admin role)\r\n  uint256 private constant FULL_PRIVILEGES_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /// @dev A bitmask of globally enabled features\r\n  uint256 public features;\r\n\r\n  /// @notice Privileged addresses with defined roles/permissions\r\n  /// @notice In the context of ERC20/ERC721 tokens these can be permissions to\r\n  ///      allow minting tokens, transferring on behalf and so on\r\n  /// @dev Maps an address to the permissions bitmask (role), where each bit\r\n  ///      represents a permission\r\n  /// @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n  ///      represents all possible permissions\r\n  mapping(address => uint256) public userRoles;\r\n\r\n  /// @dev Fired in updateFeatures()\r\n  event FeaturesUpdated(address indexed _by, uint256 _requested, uint256 _actual);\r\n\r\n  /// @dev Fired in addOperator(), removeOperator(), addRole(), removeRole()\r\n  event RoleUpdated(address indexed _by, address indexed _to, uint256 _role);\r\n\r\n  /**\r\n   * @dev Creates an access controlled instance\r\n   */\r\n  constructor() public {\r\n    // contract creator has full privileges\r\n    userRoles[msg.sender] = FULL_PRIVILEGES_MASK;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates set of the globally enabled features (`f`),\r\n   *      taking into account sender's permissions.\r\n   * @dev Requires sender to have `ROLE_FEATURE_MANAGER` permission.\r\n   * @param mask bitmask representing a set of features to enable/disable\r\n   */\r\n  function updateFeatures(uint256 mask) public {\r\n    // call sender nicely - caller\r\n    address caller = msg.sender;\r\n    // read caller's permissions\r\n    uint256 p = userRoles[caller];\r\n\r\n    // caller should have a permission to update global features\r\n    require(__hasRole(p, ROLE_FEATURE_MANAGER));\r\n\r\n    // taking into account caller's permissions,\r\n    // 1) enable features requested\r\n    features |= p & mask;\r\n    // 2) disable features requested\r\n    features &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ mask));\r\n\r\n    // fire an event\r\n    emit FeaturesUpdated(caller, mask, features);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new `operator` - an address which has\r\n   *      some extended privileges over the smart contract,\r\n   *      for example token minting, transferring on behalf, etc.\r\n   * @dev Newly added `operator` cannot have any permissions which\r\n   *      transaction sender doesn't have.\r\n   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @dev Cannot update existing operator. Throws if `operator` already exists.\r\n   * @param operator address of the operator to add\r\n   * @param role bitmask representing a set of permissions which\r\n   *      newly created operator will have\r\n   */\r\n  function addOperator(address operator, uint256 role) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // read manager's permissions (role)\r\n    uint256 permissions = userRoles[manager];\r\n\r\n    // check that `operator` doesn't exist\r\n    require(userRoles[operator] == 0);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    require(__hasRole(permissions, ROLE_ROLE_MANAGER));\r\n\r\n    // recalculate permissions (role) to set:\r\n    // we cannot create an operator more powerful then calling `manager`\r\n    uint256 r = role & permissions;\r\n\r\n    // check if we still have some permissions (role) to set\r\n    require(r != 0);\r\n\r\n    // create an operator by persisting his permissions (roles) to storage\r\n    userRoles[operator] = r;\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, userRoles[operator]);\r\n  }\r\n\r\n  /**\r\n   * @dev Deletes an existing `operator`.\r\n   * @dev Requires sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @param operator address of the operator to delete\r\n   */\r\n  function removeOperator(address operator) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // check if an `operator` exists\r\n    require(userRoles[operator] != 0);\r\n\r\n    // do not allow transaction sender to remove himself\r\n    // protects from an accidental removal of all the operators\r\n    require(operator != manager);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    // and he must have all the permissions operator has\r\n    require(__hasRole(userRoles[manager], ROLE_ROLE_MANAGER | userRoles[operator]));\r\n\r\n    // perform operator deletion\r\n    delete userRoles[operator];\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates an existing `operator`, adding a specified role to it.\r\n   * @dev Note that `operator` cannot receive permission which\r\n   *      transaction sender doesn't have.\r\n   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @dev Cannot create a new operator. Throws if `operator` doesn't exist.\r\n   * @dev Existing permissions of the `operator` are preserved\r\n   * @param operator address of the operator to update\r\n   * @param role bitmask representing a set of permissions which\r\n   *      `operator` will have\r\n   */\r\n  function addRole(address operator, uint256 role) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // read manager's permissions (role)\r\n    uint256 permissions = userRoles[manager];\r\n\r\n    // check that `operator` exists\r\n    require(userRoles[operator] != 0);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    require(__hasRole(permissions, ROLE_ROLE_MANAGER));\r\n\r\n    // recalculate permissions (role) to add:\r\n    // we cannot make an operator more powerful then calling `manager`\r\n    uint256 r = role & permissions;\r\n\r\n    // check if we still have some permissions (role) to add\r\n    require(r != 0);\r\n\r\n    // update operator's permissions (roles) in the storage\r\n    userRoles[operator] |= r;\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, userRoles[operator]);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates an existing `operator`, removing a specified role from it.\r\n   * @dev Note that  permissions which transaction sender doesn't have\r\n   *      cannot be removed.\r\n   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @dev Cannot remove all permissions. Throws on such an attempt.\r\n   * @param operator address of the operator to update\r\n   * @param role bitmask representing a set of permissions which\r\n   *      will be removed from the `operator`\r\n   */\r\n  function removeRole(address operator, uint256 role) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // read manager's permissions (role)\r\n    uint256 permissions = userRoles[manager];\r\n\r\n    // check that we're not removing all the `operator`s permissions\r\n    // this is not really required and just causes inconveniences is function use\r\n    //require(userRoles[operator] ^ role != 0);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    require(__hasRole(permissions, ROLE_ROLE_MANAGER));\r\n\r\n    // recalculate permissions (role) to remove:\r\n    // we cannot revoke permissions which calling `manager` doesn't have\r\n    uint256 r = role & permissions;\r\n\r\n    // check if we still have some permissions (role) to revoke\r\n    require(r != 0);\r\n\r\n    // update operator's permissions (roles) in the storage\r\n    userRoles[operator] &= FULL_PRIVILEGES_MASK ^ r;\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, userRoles[operator]);\r\n  }\r\n\r\n  /// @dev Checks if requested feature is enabled globally on the contract\r\n  function __isFeatureEnabled(uint256 featureRequired) internal constant returns(bool) {\r\n    // delegate call to `__hasRole`\r\n    return __hasRole(features, featureRequired);\r\n  }\r\n\r\n  /// @dev Checks if transaction sender `msg.sender` has all the required permissions `roleRequired`\r\n  function __isSenderInRole(uint256 roleRequired) internal constant returns(bool) {\r\n    // read sender's permissions (role)\r\n    uint256 userRole = userRoles[msg.sender];\r\n\r\n    // delegate call to `__hasRole`\r\n    return __hasRole(userRole, roleRequired);\r\n  }\r\n\r\n  /// @dev Checks if user role `userRole` contain all the permissions required `roleRequired`\r\n  function __hasRole(uint256 userRole, uint256 roleRequired) internal pure returns(bool) {\r\n    // check the bitmask for the role required and return the result\r\n    return userRole & roleRequired == roleRequired;\r\n  }\r\n}\r\n\r\n/**\r\n * @notice DeedStamp allows to create a proof of existence for a deed document (register)\r\n * @notice Each proof is attached to its address which allow to query for documents by address\r\n */\r\ncontract DeedStamp is AccessControl {\r\n  /// @dev Using library `StringUtils` for string manipulations\r\n  using StringUtils for string;\r\n\r\n  /// @notice Deed registrant is responsible for registering deeds\r\n  /// @dev Role ROLE_DEED_REGISTRANT allows registering deeds within smart contract\r\n  uint32 private constant ROLE_DEED_REGISTRANT = 0x00000001;\r\n\r\n  /**\r\n   * @notice Proof of existence mapping\r\n   * @dev A mapping of deed document hash to a timestamp when\r\n   *      the document was added to this mapping\r\n   * @dev Zero value in the mapping indicates\r\n   *      the document's proof of existence doesn't exist\r\n   * @dev Non-zero value in the mapping indicates\r\n   *      a unix timestamp when the document was added\r\n   * @dev Unix timestamp â€“ number of seconds that have passed since Jan 1, 1970\r\n   */\r\n  mapping(uint256 => uint256) private documentRegistry;\r\n\r\n  /**\r\n   * @notice Property address index mapping\r\n   * @dev A mapping of property address hash to an array of\r\n   *      deed documents associated with this address\r\n   * @dev Each document from the mapping must have a corresponded\r\n   *      unix timestamp in the proof of existence mapping\r\n   * @dev To obtain timestamps of all the deeds for an address\r\n   *      an index can be used together with proof of existence mapping\r\n   */\r\n  mapping(uint256 => string[]) private addressRegistry;\r\n\r\n  /**\r\n   * @notice Iterable storage for all property addresses registered\r\n   * @dev Unordered, doesn't contain duplicates (entries with equal hash)\r\n   * @dev May be used as an entry point to iterate over all the deeds\r\n   *      stored in smart contract:\r\n   *      for propertyAddress in knownPropertyAddresses\r\n   *        for document in addressRegistry[propertyAddress]\r\n   *          unix timestamp is documentRegistry[document]\r\n   */\r\n  string[] public knownPropertyAddresses;\r\n\r\n  /// @dev Fired in `registerDeed`\r\n  event DeedRegistered(string propertyAddress, string document);\r\n\r\n  /**\r\n   * @notice Creates a proof of existence for a deed document `document`\r\n   * @notice Allows to specify property address `propertyAddress` as a first argument\r\n   * @notice A `document` may not necessarily represent a document itself,\r\n   *      it can also be its metadata or just a hash\r\n   * @dev Creates a mapping between a document and unix timestamp of the current time\r\n   *      (timestamp of the Ethereum transaction which creates that mapping)\r\n   * @dev Additionally stores a mapping between property address and the document\r\n   * @dev Requires sender to have ROLE_DEED_REGISTRANT permission\r\n   * @dev Throws if deed document doesn't contain specified property address inside\r\n   * @dev Throws if proof of existence for the deed document already exists\r\n   * @param propertyAddress a property address, must be included into the document\r\n   * @param document a deed document to create a proof of existence for\r\n   *      by putting it into the registry\r\n   */\r\n  function registerDeed(string propertyAddress, string document) public {\r\n    // check that the call is made by a deed registrant\r\n    require(__isSenderInRole(ROLE_DEED_REGISTRANT));\r\n\r\n    // calculate the hash\r\n    uint256 documentHash = uint256(keccak256(document));\r\n\r\n    // ensure document doesn't exist in the document registry mapping\r\n    require(documentRegistry[documentHash] == 0);\r\n\r\n    // ensure the document contains a property address specified\r\n    require(document.contains(propertyAddress));\r\n\r\n    // store proof of existence in the registry\r\n    documentRegistry[documentHash] = now;\r\n\r\n    // calculate property address hash\r\n    uint256 propertyAddressHash = uint256(keccak256(propertyAddress));\r\n\r\n    // if property address is new (doesn't exist in address index mapping)\r\n    if(addressRegistry[propertyAddressHash].length == 0) {\r\n      // add it to array of know property addresses\r\n      knownPropertyAddresses.push(propertyAddress);\r\n    }\r\n\r\n    // store property address in the property address index\r\n    addressRegistry[propertyAddressHash].push(document);\r\n\r\n    // emit an event\r\n    emit DeedRegistered(propertyAddress, document);\r\n  }\r\n\r\n  /**\r\n   * @notice Proves an existence of the document by checking\r\n   *      if it exists in a proof of existence mapping\r\n   * @param document a deed document to verify existence\r\n   * @return true if and only if document exists\r\n   */\r\n  function verifyDeed(string document) public constant returns (bool) {\r\n    // calculate the hash\r\n    uint256 documentHash = uint256(keccak256(document));\r\n\r\n    // verify if proof of existence timestamp is not zero\r\n    return documentRegistry[documentHash] > 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns a unix timestamp when the proof of existence for a document was created\r\n   * @dev This is a unix timestamp of the document addition to the registry\r\n   * @param document a deed document to get the proof of existence creation date for\r\n   * @return a unix timestamp when the proof of existence was created\r\n   */\r\n  function getDeedTimestamp(string document) public constant returns (uint256) {\r\n    // calculate the hash\r\n    uint256 documentHash = uint256(keccak256(document));\r\n\r\n    // lookup the registry\r\n    uint256 timestamp = documentRegistry[documentHash];\r\n\r\n    // ensure the document exists\r\n    require(timestamp > 0);\r\n\r\n    // return the timestamp\r\n    return timestamp;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns number of deeds registered for a particular address\r\n   * @dev May be used together with `getDeedByAddress` or `getDeedTimestampByAddress` for iteration\r\n   * @param propertyAddress a property address to lookup deeds for\r\n   * @return number of deeds registered for the property address specified\r\n   */\r\n  function getNumberOfDeedsByAddress(string propertyAddress) public constant returns (uint256) {\r\n    // calculate property address hash\r\n    uint256 propertyAddressHash = uint256(keccak256(propertyAddress));\r\n\r\n    // lookup the registry\r\n    return addressRegistry[propertyAddressHash].length;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the deed by property address and chronological index\r\n   * @dev Should be used together with `getNumberOfDeedsByAddress` for iteration\r\n   *      over the deed document for a particular address\r\n   * @dev Throws if index is equal or bigger than `getNumberOfDeedsByAddress(propertyAddress)`\r\n   * @param propertyAddress a property address to lookup deed for\r\n   * @param i a chronological index, starting at zero\r\n   */\r\n  function getDeedByAddress(string propertyAddress, uint256 i) public constant returns (string) {\r\n    // calculate property address hash\r\n    uint256 propertyAddressHash = uint256(keccak256(propertyAddress));\r\n\r\n    // lookup the registry\r\n    return addressRegistry[propertyAddressHash][i];\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the last deed by property address\r\n   * @dev Throws if no deeds exist for the address specified\r\n   * @param propertyAddress a property address to lookup last deed for\r\n   */\r\n  function getLastDeedByAddress(string propertyAddress) public constant returns (string) {\r\n    // calculate property address hash\r\n    uint256 propertyAddressHash = uint256(keccak256(propertyAddress));\r\n\r\n    // lookup the registry\r\n    return addressRegistry[propertyAddressHash][addressRegistry[propertyAddressHash].length - 1];\r\n  }\r\n  /**\r\n   * @notice Gets the deed registration timestamp by property address and chronological index\r\n   * @dev Should be used together with `getNumberOfDeedsByAddress` for iteration\r\n   *      over the deed timestamps for a particular address\r\n   * @dev Throws if index is equal or bigger than `getNumberOfDeedsByAddress(propertyAddress)`\r\n   * @param propertyAddress a property address to lookup deed timestamp for\r\n   * @param i a chronological index, starting at zero\r\n   */\r\n  function getDeedTimestampByAddress(string propertyAddress, uint256 i) public constant returns (uint256) {\r\n    // get the deed, delegate to `getDeedByAddress`\r\n    string memory deed = getDeedByAddress(propertyAddress, i);\r\n\r\n    // lookup for timestamp, delegate to `getDeedTimestamp`\r\n    return getDeedTimestamp(deed);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the last deed registration timestamp by property address\r\n   * @dev Throws if no deeds exist for the address specified\r\n   * @param propertyAddress a property address to lookup last deed timestamp for\r\n   */\r\n  function getLastDeedTimestampByAddress(string propertyAddress) public constant returns (uint256) {\r\n    // calculate property address hash\r\n    uint256 propertyAddressHash = uint256(keccak256(propertyAddress));\r\n\r\n    // lookup the registry for the last deed\r\n    string memory deed = addressRegistry[propertyAddressHash][addressRegistry[propertyAddressHash].length - 1];\r\n\r\n    // lookup for timestamp, delegate to `getDeedTimestamp`\r\n    return getDeedTimestamp(deed);\r\n  }\r\n\r\n  /**\r\n   * @dev A convenient way to to get last element of the `knownPropertyAddresses` array\r\n   * @return knownPropertyAddresses[knownPropertyAddresses.length - 1]\r\n   */\r\n  function lastKnownPropertyAddress() public constant returns (string) {\r\n    // no need to verify if array length is greater than zero\r\n    // if it is zero - an exception is thrown\r\n    return knownPropertyAddresses[knownPropertyAddresses.length - 1];\r\n  }\r\n\r\n  /**\r\n   * @dev A convenient way to get number of elements in the `knownPropertyAddresses` array\r\n   * @return knownPropertyAddresses.length\r\n   */\r\n  function getNumberOfKnownPropertyAddresses() public constant returns (uint256) {\r\n    return knownPropertyAddresses.length;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"knownPropertyAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyAddress\",\"type\":\"string\"},{\"name\":\"document\",\"type\":\"string\"}],\"name\":\"registerDeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyAddress\",\"type\":\"string\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getDeedByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyAddress\",\"type\":\"string\"}],\"name\":\"getLastDeedTimestampByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"removeRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"addRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfKnownPropertyAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyAddress\",\"type\":\"string\"}],\"name\":\"getNumberOfDeedsByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"document\",\"type\":\"string\"}],\"name\":\"getDeedTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastKnownPropertyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"document\",\"type\":\"string\"}],\"name\":\"verifyDeed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyAddress\",\"type\":\"string\"}],\"name\":\"getLastDeedByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyAddress\",\"type\":\"string\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getDeedTimestampByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"propertyAddress\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"document\",\"type\":\"string\"}],\"name\":\"DeedRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"FeaturesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_role\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"}]","ContractName":"DeedStamp","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c4e636dba2181acbd8824defc34568a53a221a59b24f4d2a12a95a4d7d5e977a"}]}