{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n */\r\ncontract ERC721 {\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed tokenId\r\n  );\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed approved,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  function implementsERC721() public pure returns (bool);\r\n  function totalSupply() public view returns (uint256 total);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n  function approve(address _to, uint256 _tokenId) external;\r\n  function transfer(address _to, uint256 _tokenId) external;\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Interface of auction contract\r\n */\r\ninterface CurioAuction {\r\n  function isCurioAuction() external returns (bool);\r\n  function withdrawBalance() external;\r\n  function setAuctionPriceLimit(uint256 _newAuctionPriceLimit) external;\r\n  function createAuction(\r\n    uint256 _tokenId,\r\n    uint256 _startingPrice,\r\n    uint256 _endingPrice,\r\n    uint256 _duration,\r\n    address _seller\r\n  )\r\n    external;\r\n}\r\n\r\n\r\n/**\r\n * @title Curio\r\n * @dev Curio core contract implements ERC721 token.\r\n */\r\ncontract Curio is ERC721 {\r\n  event Create(\r\n    address indexed owner,\r\n    uint256 indexed tokenId,\r\n    string name\r\n  );\r\n  event ContractUpgrade(address newContract);\r\n\r\n  struct Token {\r\n    string name;\r\n  }\r\n\r\n  // Name and symbol of ERC721 token\r\n  string public constant NAME = \"Curio\";\r\n  string public constant SYMBOL = \"CUR\";\r\n\r\n  // Array of token's data\r\n  Token[] tokens;\r\n\r\n  // A mapping from token IDs to the address that owns them\r\n  mapping (uint256 => address) public tokenIndexToOwner;\r\n\r\n  // A mapping from owner address to count of tokens that address owns\r\n  mapping (address => uint256) ownershipTokenCount;\r\n\r\n  // A mapping from token IDs to an address that has been approved\r\n  mapping (uint256 => address) public tokenIndexToApproved;\r\n\r\n  address public ownerAddress;\r\n  address public adminAddress;\r\n\r\n  bool public paused = false;\r\n\r\n  // The address of new contract when this contract was upgraded\r\n  address public newContractAddress;\r\n\r\n  // The address of CurioAuction contract that handles sales of tokens\r\n  CurioAuction public auction;\r\n\r\n  // Restriction on release of tokens\r\n  uint256 public constant TOTAL_SUPPLY_LIMIT = 900;\r\n\r\n  // Count of released tokens\r\n  uint256 public releaseCreatedCount;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == ownerAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the admin.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == adminAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner or admin.\r\n   */\r\n  modifier onlyOwnerOrAdmin() {\r\n    require(\r\n      msg.sender == adminAddress ||\r\n      msg.sender == ownerAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  constructor() public {\r\n    // Contract paused after start\r\n    paused = true;\r\n\r\n    // Set owner and admin addresses\r\n    ownerAddress = msg.sender;\r\n    adminAddress = msg.sender;\r\n  }\r\n\r\n\r\n  // -----------------------------------------\r\n  // External interface\r\n  // -----------------------------------------\r\n\r\n\r\n  /**\r\n   * @dev Check implementing ERC721 standard (needed in auction contract).\r\n   */\r\n  function implementsERC721() public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Default payable function rejects all Ether from being sent here, unless it's from auction contract.\r\n   */\r\n  function() external payable {\r\n    require(msg.sender == address(auction));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether from this contract to owner.\r\n   */\r\n  function withdrawBalance() external onlyOwner {\r\n    ownerAddress.transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total number of tokens currently in existence.\r\n   */\r\n  function totalSupply() public view returns (uint) {\r\n    return tokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of tokens owned by a specific address.\r\n   * @param _owner The owner address to check\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256 count) {\r\n    return ownershipTokenCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address currently assigned ownership of a given token.\r\n   * @param _tokenId The ID of the token\r\n   */\r\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\r\n    owner = tokenIndexToOwner[_tokenId];\r\n\r\n    require(owner != address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns information about token.\r\n   * @param _id The ID of the token\r\n   */\r\n  function getToken(uint256 _id) external view returns (string name) {\r\n    Token storage token = tokens[_id];\r\n\r\n    name = token.name;\r\n  }\r\n\r\n  /**\r\n   * @dev Set new owner address. Only available to the current owner.\r\n   * @param _newOwner The address of the new owner\r\n   */\r\n  function setOwner(address _newOwner) onlyOwner external {\r\n    require(_newOwner != address(0));\r\n\r\n    ownerAddress = _newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Set new admin address. Only available to owner.\r\n   * @param _newAdmin The address of the new admin\r\n   */\r\n  function setAdmin(address _newAdmin) onlyOwner external {\r\n    require(_newAdmin != address(0));\r\n\r\n    adminAddress = _newAdmin;\r\n  }\r\n\r\n  /**\r\n   * @dev Set new auction price limit.\r\n   * @param _newAuctionPriceLimit Start and end price limit\r\n   */\r\n  function setAuctionPriceLimit(uint256 _newAuctionPriceLimit) onlyOwnerOrAdmin external {\r\n    auction.setAuctionPriceLimit(_newAuctionPriceLimit);\r\n  }\r\n\r\n  /**\r\n   * @dev Set the address of upgraded contract.\r\n   * @param _newContract Address of new contract\r\n   */\r\n  function setNewAddress(address _newContract) onlyOwner whenPaused external {\r\n    newContractAddress = _newContract;\r\n\r\n    emit ContractUpgrade(_newContract);\r\n  }\r\n\r\n  /**\r\n   * @dev Pause the contract. Called by owner or admin to pause the contract.\r\n   */\r\n  function pause() onlyOwnerOrAdmin whenNotPaused external {\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Unpause the contract. Can only be called by owner, since\r\n   *      one reason we may pause the contract is when admin account is\r\n   *      compromised. Requires auction contract addresses\r\n   *      to be set before contract can be unpaused. Also, we can't have\r\n   *      newContractAddress set either, because then the contract was upgraded.\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    require(auction != address(0));\r\n    require(newContractAddress == address(0));\r\n\r\n    paused = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer a token to another address.\r\n   * @param _to The address of the recipient, can be a user or contract\r\n   * @param _tokenId The ID of the token to transfer\r\n   */\r\n  function transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    whenNotPaused\r\n    external\r\n  {\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_to != address(0));\r\n\r\n    // Disallow transfers to this contract to prevent accidental misuse.\r\n    // The contract should never own any tokens (except very briefly\r\n    // after a release token is created and before it goes on auction).\r\n    require(_to != address(this));\r\n\r\n    // Disallow transfers to the auction contract to prevent accidental\r\n    // misuse. Auction contracts should only take ownership of tokens\r\n    // through the allow + transferFrom flow.\r\n    require(_to != address(auction));\r\n\r\n    // Check token ownership\r\n    require(_owns(msg.sender, _tokenId));\r\n\r\n    // Reassign ownership, clear pending approvals, emit Transfer event.\r\n    _transfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Grant another address the right to transfer a specific token via\r\n   *      transferFrom(). This is the preferred flow for transfering NFTs to contracts.\r\n   * @param _to The address to be granted transfer approval. Pass address(0) to\r\n   *            clear all approvals\r\n   * @param _tokenId The ID of the token that can be transferred if this call succeeds\r\n   */\r\n  function approve(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    whenNotPaused\r\n    external\r\n  {\r\n    // Only an owner can grant transfer approval.\r\n    require(_owns(msg.sender, _tokenId));\r\n\r\n    // Register the approval (replacing any previous approval).\r\n    _approve(_tokenId, _to);\r\n\r\n    // Emit approval event.\r\n    emit Approval(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers a token owned by another address, for which the calling address\r\n   *      has previously been granted transfer approval by the owner.\r\n   * @param _from The address that owns the token to be transferred\r\n   * @param _to The address that should take ownership of the token. Can be any address,\r\n   *            including the caller\r\n   * @param _tokenId The ID of the token to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    whenNotPaused\r\n    external\r\n  {\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_to != address(0));\r\n\r\n    // Disallow transfers to this contract to prevent accidental misuse.\r\n    // The contract should never own any tokens (except very briefly\r\n    // after a release token is created and before it goes on auction).\r\n    require(_to != address(this));\r\n\r\n    // Check for approval and valid ownership\r\n    require(_approvedFor(msg.sender, _tokenId));\r\n    require(_owns(_from, _tokenId));\r\n\r\n    // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n    _transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a list of all tokens assigned to an address.\r\n   * @param _owner The owner whose tokens we are interested in\r\n   * @notice This method MUST NEVER be called by smart contract code. First, it's fairly\r\n   *         expensive (it walks the entire token array looking for tokens belonging to owner),\r\n   *         but it also returns a dynamic array, which is only supported for web3 calls, and\r\n   *         not contract-to-contract calls.\r\n   */\r\n  function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n    uint256 tokenCount = balanceOf(_owner);\r\n\r\n    if (tokenCount == 0) {\r\n      // Return an empty array\r\n      return new uint256[](0);\r\n    } else {\r\n      uint256[] memory result = new uint256[](tokenCount);\r\n      uint256 totalTokens = totalSupply();\r\n      uint256 resultIndex = 0;\r\n\r\n      uint256 tokenId;\r\n\r\n      for (tokenId = 0; tokenId <= totalTokens; tokenId++) {\r\n        if (tokenIndexToOwner[tokenId] == _owner) {\r\n          result[resultIndex] = tokenId;\r\n          resultIndex++;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Set the reference to the auction contract.\r\n   * @param _address Address of auction contract\r\n   */\r\n  function setAuctionAddress(address _address) onlyOwner external {\r\n    CurioAuction candidateContract = CurioAuction(_address);\r\n\r\n    require(candidateContract.isCurioAuction());\r\n\r\n    // Set the new contract address\r\n    auction = candidateContract;\r\n  }\r\n\r\n  /**\r\n   * @dev Put a token up for auction.\r\n   * @param _tokenId ID of token to auction, sender must be owner\r\n   * @param _startingPrice Price of item (in wei) at beginning of auction\r\n   * @param _endingPrice Price of item (in wei) at end of auction\r\n   * @param _duration Length of auction (in seconds)\r\n   */\r\n  function createAuction(\r\n    uint256 _tokenId,\r\n    uint256 _startingPrice,\r\n    uint256 _endingPrice,\r\n    uint256 _duration\r\n  )\r\n    whenNotPaused\r\n    external\r\n  {\r\n    // Auction contract checks input sizes\r\n    // If token is already on any auction, this will throw because it will be owned by the auction contract\r\n    require(_owns(msg.sender, _tokenId));\r\n\r\n    // Set auction contract as approved for token\r\n    _approve(_tokenId, auction);\r\n\r\n    // Sale auction throws if inputs are invalid\r\n    auction.createAuction(\r\n      _tokenId,\r\n      _startingPrice,\r\n      _endingPrice,\r\n      _duration,\r\n      msg.sender\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the balance of the auction contract to this contract by owner or admin.\r\n   */\r\n  function withdrawAuctionBalance() onlyOwnerOrAdmin external {\r\n    auction.withdrawBalance();\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a new release token with the given name and creates an auction for it.\r\n   * @param _name Name ot the token\r\n   * @param _startingPrice Price of item (in wei) at beginning of auction\r\n   * @param _endingPrice Price of item (in wei) at end of auction\r\n   * @param _duration Length of auction (in seconds)\r\n   */\r\n  function createReleaseTokenAuction(\r\n    string _name,\r\n    uint256 _startingPrice,\r\n    uint256 _endingPrice,\r\n    uint256 _duration\r\n  )\r\n    onlyAdmin\r\n    external\r\n  {\r\n    // Check release tokens limit\r\n    require(releaseCreatedCount < TOTAL_SUPPLY_LIMIT);\r\n\r\n    // Create token and tranfer ownership to this contract\r\n    uint256 tokenId = _createToken(_name, address(this));\r\n\r\n    // Set auction address as approved for release token\r\n    _approve(tokenId, auction);\r\n\r\n    // Call createAuction in auction contract\r\n    auction.createAuction(\r\n      tokenId,\r\n      _startingPrice,\r\n      _endingPrice,\r\n      _duration,\r\n      address(this)\r\n    );\r\n\r\n    releaseCreatedCount++;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates free token and transfer it to recipient.\r\n   * @param _name Name of the token\r\n   * @param _to The address of the recipient, can be a user or contract\r\n   */\r\n  function createFreeToken(\r\n    string _name,\r\n    address _to\r\n  )\r\n    onlyAdmin\r\n    external\r\n  {\r\n    require(_to != address(0));\r\n    require(_to != address(this));\r\n    require(_to != address(auction));\r\n\r\n    // Check release tokens limit\r\n    require(releaseCreatedCount < TOTAL_SUPPLY_LIMIT);\r\n\r\n    // Create token and transfer to owner\r\n    _createToken(_name, _to);\r\n\r\n    releaseCreatedCount++;\r\n  }\r\n\r\n\r\n  // -----------------------------------------\r\n  // Internal interface\r\n  // -----------------------------------------\r\n\r\n\r\n  /**\r\n   * @dev Create a new token and stores it.\r\n   * @param _name Token name\r\n   * @param _owner The initial owner of this token, must be non-zero\r\n   */\r\n  function _createToken(\r\n    string _name,\r\n    address _owner\r\n  )\r\n    internal\r\n    returns (uint)\r\n  {\r\n    Token memory _token = Token({\r\n      name: _name\r\n    });\r\n\r\n    uint256 newTokenId = tokens.push(_token) - 1;\r\n\r\n    // Check overflow newTokenId\r\n    require(newTokenId == uint256(uint32(newTokenId)));\r\n\r\n    emit Create(_owner, newTokenId, _name);\r\n\r\n    // This will assign ownership\r\n    _transfer(0, _owner, newTokenId);\r\n\r\n    return newTokenId;\r\n  }\r\n\r\n  /**\r\n   * @dev Check claimant address as token owner.\r\n   * @param _claimant The address we are validating against\r\n   * @param _tokenId Token id, only valid when > 0\r\n   */\r\n  function _owns(\r\n    address _claimant,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return tokenIndexToOwner[_tokenId] == _claimant;\r\n  }\r\n\r\n  /**\r\n   * @dev Check if a given address currently has transferApproval for a particular token.\r\n   * @param _claimant The address we are confirming token is approved for\r\n   * @param _tokenId Token id, only valid when > 0\r\n   */\r\n  function _approvedFor(\r\n    address _claimant,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return tokenIndexToApproved[_tokenId] == _claimant;\r\n  }\r\n\r\n  /**\r\n   * @dev Marks an address as being approved for transferFrom().\r\n   *      Setting _approved to address(0) clears all transfer approval.\r\n   *      NOTE: _approve() does NOT send the Approval event. This is intentional because\r\n   *      _approve() and transferFrom() are used together for putting tokens on auction, and\r\n   *      there is no value in spamming the log with Approval events in that case.\r\n   */\r\n  function _approve(\r\n    uint256 _tokenId,\r\n    address _approved\r\n  )\r\n    internal\r\n  {\r\n    tokenIndexToApproved[_tokenId] = _approved;\r\n  }\r\n\r\n  /**\r\n   * @dev Assigns ownership of a specific token to an address.\r\n   */\r\n  function _transfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    ownershipTokenCount[_to]++;\r\n\r\n    // Transfer ownership\r\n    tokenIndexToOwner[_tokenId] = _to;\r\n\r\n    // When creating new token _from is 0x0, but we can't account that address\r\n    if (_from != address(0)) {\r\n      ownershipTokenCount[_from]--;\r\n\r\n      // Clear any previously approved ownership exchange\r\n      delete tokenIndexToApproved[_tokenId];\r\n    }\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"releaseCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"createFreeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createReleaseTokenAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAuctionPriceLimit\",\"type\":\"uint256\"}],\"name\":\"setAuctionPriceLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAuctionBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Curio","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://510820d8bace0852bb95aaf9413b51a1b4d3b227fadff2e54cca52c1eb7954f7"}]}