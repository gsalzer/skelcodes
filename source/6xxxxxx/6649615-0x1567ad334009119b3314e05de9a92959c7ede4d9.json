{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: zeppelin/token/ERC20.sol\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// File: contracts/interface/ERC223.sol\r\n\r\n/*\r\n  ERC223 additions to ERC20\r\n\r\n  Interface wise is ERC20 + data paramenter to transfer and transferFrom.\r\n */\r\n\r\n\r\ncontract ERC223 is ERC20 {\r\n  function transfer(address to, uint value, bytes data) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);\r\n}\r\n\r\n// File: contracts/interface/ERC223Receiver.sol\r\n\r\n/*\r\nBase class contracts willing to accept ERC223 token transfers must conform to.\r\n\r\nSender: msg.sender to the token contract, the address originating the token transfer.\r\n          - For user originated transfers sender will be equal to tx.origin\r\n          - For contract originated transfers, tx.origin will be the user that made the tx that produced the transfer.\r\nOrigin: the origin address from whose balance the tokens are sent\r\n          - For transfer(), origin = msg.sender\r\n          - For transferFrom() origin = _from to token contract\r\nValue is the amount of tokens sent\r\nData is arbitrary data sent with the token transfer. Simulates ether tx.data\r\n\r\nFrom, origin and value shouldn't be trusted unless the token contract is trusted.\r\nIf sender == tx.origin, it is safe to trust it regardless of the token.\r\n*/\r\n\r\ncontract ERC223Receiver {\r\n  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);\r\n}\r\n\r\n// File: zeppelin/SafeMath.sol\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n// File: zeppelin/token/StandardToken.sol\r\n\r\n/**\r\n * Standard ERC20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/implementation/Standard223Token.sol\r\n\r\n/* ERC223 additions to ERC20 */\r\n\r\n\r\n\r\n\r\ncontract Standard223Token is ERC223, StandardToken {\r\n  //function that is called when a user or another contract wants to transfer funds\r\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\r\n    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    return transfer(_to, _value, new bytes(0));\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    return transferFrom(_from, _to, _value, new bytes(0));\r\n  }\r\n\r\n  //function that is called when transaction target is a contract\r\n  function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\r\n    ERC223Receiver reciever = ERC223Receiver(_to);\r\n    return reciever.tokenFallback(msg.sender, _origin, _value, _data);\r\n  }\r\n\r\n  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  function isContract(address _addr) private returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n}\r\n\r\n// File: contracts/XNR.sol\r\n\r\ncontract XNR is Standard223Token {\r\n  \r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  // Requires that before a function executes either:\r\n  // The global isThawed value is set true\r\n  // The sender is in a whitelisted thawedAddress\r\n  // It has been a year since contract deployment\r\n  modifier requireThawed() {\r\n    require(isThawed == true || thawedAddresses[msg.sender] == true || now > thawTime);\r\n    _;\r\n  }\r\n\r\n  // Applies to thaw functions. Only the designated manager is allowed when this modifier is present\r\n  modifier onlyManager() {\r\n    require(msg.sender == owner || msg.sender == manager);\r\n    _;\r\n  }\r\n\r\n  address owner;\r\n  address manager;\r\n  uint initialBalance;\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n  mapping (uint=>string) public metadata;\r\n  mapping (uint=>string) public publicMetadata;\r\n  bool isThawed = false;\r\n  mapping (address=>bool) public thawedAddresses;\r\n  uint256 thawTime;\r\n\r\n  constructor() public {\r\n    address bountyMgrAddress = address(0x03de5f75915dc5382c5df82538f8d5e124a7ebb8);\r\n    initialBalance = 18666666667;\r\n    uint256 bountyMgrBalance = 933333333;\r\n    balances[msg.sender] = safeSub(initialBalance, bountyMgrBalance);\r\n    balances[bountyMgrAddress] = bountyMgrBalance;\r\n    totalSupply = initialBalance;\r\n    name = \"Neuroneum\";\r\n    symbol = \"XNR\";\r\n    decimals = 18;\r\n    owner = msg.sender;\r\n    thawedAddresses[msg.sender] = true;\r\n    thawedAddresses[bountyMgrAddress] = true;\r\n    thawTime = now + 1 years;\r\n  }\r\n\r\n  // **\r\n  // ** Manager functions **\r\n  // **\r\n  // Thaw a specific address, allowing it to send tokens\r\n  function thawAddress(address _address) onlyManager {\r\n    thawedAddresses[_address] = true;\r\n  }\r\n  // Thaw all addresses. This is irreversible\r\n  function thawAllAddresses() onlyManager {\r\n    isThawed = true;\r\n  }\r\n  // Freeze all addresses except for those whitelisted in thawedAddresses. This is irreversible\r\n  // This only applies if the thawTime has not yet past.\r\n  function freezeAllAddresses() onlyManager {\r\n    isThawed = false;\r\n  }\r\n\r\n  // **\r\n  // ** Owner functions **\r\n  // **\r\n  // Set a new owner\r\n  function setOwner(address _newOwner) onlyOwner {\r\n    owner = _newOwner;\r\n  }\r\n\r\n  // Set a manager, who can unfreeze wallets as needed\r\n  function setManager(address _address) onlyOwner {\r\n    manager = _address;\r\n  }\r\n\r\n  // Change the ticker symbol of the token\r\n  function changeSymbol(string newSymbol) onlyOwner {\r\n    symbol = newSymbol;\r\n  }\r\n\r\n  // Change the long-form name of the token\r\n  function changeName(string newName) onlyOwner {\r\n    name = newName;\r\n  }\r\n\r\n  // Set any admin level metadata needed for XNR mainnet purposes\r\n  function setMetadata(uint key, string value) onlyOwner {\r\n    metadata[key] = value;\r\n  }\r\n\r\n  // **\r\n  // ** Public functions **\r\n  // **\r\n  // Set any public metadata needed for XNR mainnet purposes\r\n  function setPublicMetadata(uint key, string value) {\r\n    publicMetadata[key] = value;\r\n  }\r\n\r\n  // Standard ERC20 transfer commands, with additional requireThawed modifier\r\n  function transfer(address _to, uint _value, bytes _data) requireThawed returns (bool success) {\r\n    return super.transfer(_to, _value, _data);\r\n  }\r\n  function transferFrom(address _from, address _to, uint _value, bytes _data) requireThawed returns (bool success) {\r\n    return super.transferFrom(_from, _to, _value, _data);\r\n  }\r\n  function transfer(address _to, uint _value) requireThawed returns (bool success) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n  function transferFrom(address _from, address _to, uint _value) requireThawed returns (bool success) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setPublicMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"thawAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"publicMetadata\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"changeSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"thawedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeAllAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"thawAllAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"XNR","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4418cd941ff2c6362f452947641b5681ca475f30e657755386ceed9ea7d365ff"}]}